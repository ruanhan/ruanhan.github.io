<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>socket - Hexo</title>
  
    <meta name="keywords" content="doc">
  
  
    <meta name="description" content="socket">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/12/16/apue-11/">
      socket
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/apue/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>apue</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Dec 16, 2020</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p><img src="./socket_1.png" alt=""></p>
<blockquote>
<p>如图所示，socket 可以理解为中间层。底层是若干不同的协议来完成协议族的指定，上层可以是不同的网络实现方式（流失传输，报式传输等等）。在不同的协议族当中对于这些不同的网络实现方式都会有支持，比如IPv4既能支持流失套接字，也能支持报式套接字等等。这样的话，下层换一种协议，上层换一种实现方式，程序员都要新写一套代码。</p>
</blockquote>
<p>解决方法：</p>
<p>借助一种机制，把下面用什么协议族，上面用什么实现方式指定起来，这样的机制就是socket。socket函数抽象出来 是一个文件描述符，也就是说拿着一个文件描述符就能完成套接字传输的问题。</p>
<p>对文件描述符的操作无非：</p>
<p>打开<br>关闭<br>读写<br>定位</p>
<p>还有相关的函数能把文件描述符封装到流当中，封装成<code>FILE *</code>。 通过stream 的概念来操作，这个时候就能使用标准IO了。只要是文件，标准io和系统调用io都能拿来使用了。</p>
<p>说到守护进程，为什么写守护进程不把所有文件描述符关掉呢，因为守护进程脱离控制终端。（因为在apue某个版本上的demo上，有把1024个文件描述符都关闭掉的实现。）因为写守护进程，多半与传输有关系，和socket都会产生或多或少的关联。那关掉文件描述符的是没有必要的。所以写程序的时候主要还是要看目的。不要盲目的模仿</p>
<h2 id="1-1-跨主机的传输要注意的问题"><a href="#1-1-跨主机的传输要注意的问题" class="headerlink" title="1.1 跨主机的传输要注意的问题"></a>1.1 跨主机的传输要注意的问题</h2><blockquote>
<p>字节序， 对齐问题</p>
</blockquote>
<p>前面讨论了进程间通讯（IPC）的各种常用手段，但是那些手段都是指通讯双方在同一台机器上的情况。在现实生活中我们会经常接触到各种各样的网络应用程序，比如大家经常使用的 ftp、svn、甚至QQ、迅雷等等，它们的通讯双方通常都是在不同的机器上的，那么它们的通讯就是跨主机的进程间通讯了，所以网络通讯也是一种进程间通讯的手段。</p>
<p>跨主机的程序在传输数据之前要制定严谨的协议，不然对方可能会看不懂你发送的数据，从而导致数据传送失败，甚至造成安全类bug，所以跨主机的通讯就不像我们之前学习的在同一台主机上的进程间通讯那么简单了。</p>
<p>制定协议要考虑的问题至少包括以下几点：</p>
<p>1）告诉对方自己的 IP 和端口；</p>
<p>先来看看 IP 和端口的概念。</p>
<p>当我们的程序在进行网络通讯之前，需要先与自己的机器进行约定，告诉操作系统我需要使用哪个端口，这样操作系统的某个端口在收到数据的时候就会发送给我们的进程。当另一个程序也来通知操作系统它要使用这个端口时，操作系统要保证这个端口只有我们使用而不能再让别人使用，否则当它收到数据的时候就不知道应该发送给谁了。</p>
<p>当我们需要发送数据的时候，也会使用这个端口进行发送，只有特殊情况才会使用别的端口或者使用多个端口。</p>
<h3 id="1-1-1-类型长度问题"><a href="#1-1-1-类型长度问题" class="headerlink" title="1.1.1 类型长度问题"></a>1.1.1 类型长度问题</h3><p>2）还要考虑的问题是通信的双方应该采用什么数据类型呢？</p>
<p>假如通讯双方要传送一个 int 类型的数据，那么对方机器上 int 类型的位数与我们机器上的位数是否相同呢？</p>
<p>也就是说 int 类型在我的机器上是 32bit，但是在对方的机器上也是 32bit 吗？假设在对方机器上是 16bit，那么我发送给它的 int 值它能正确解析吗？</p>
<p><strong>解决方法</strong></p>
<blockquote>
<p>使用一些通用类型的数值</p>
</blockquote>
<p><code>int32_t</code></p>
<p><code>uint32_t</code></p>
<p><code>int64_t</code></p>
<p><code>int8_t</code></p>
<p><code>uint8_t</code></p>
<p>所以通信双方的数据类型要采用完全一致的约定，这个我们在下面会讨论如何让数据类型一致。</p>
<h3 id="1-1-2-字节序问题：-大端存储，小端存储"><a href="#1-1-2-字节序问题：-大端存储，小端存储" class="headerlink" title="1.1.2 字节序问题： 大端存储，小端存储"></a>1.1.2 字节序问题： 大端存储，小端存储</h3><p>大端存储： 低地址处放高字节<br>小端存储： 低地址处放低字节</p>
<blockquote>
<p>还要考虑字节序问题，这个说的是大小端的问题。</p>
</blockquote>
<p>大端格式是：低地址存放高位数据，高地址存放低位数据。</p>
<p>小端格式是：低地址存放低位数据，高地址存放高位数据。</p>
<p><img src="./socket_01.png" alt=""></p>
<p>图1 大小端</p>
<p>如图1 所示，假设要存放的数据是一个16进制的数值， 0x30313233，那么 33 是低位，30 是高位，在大端存储格式中，30 存放在低位，33 存放在高位；而在小端存储格式中，33 存放在低位，30 存放在高位。</p>
<p>大小端存储跟发送的区别，不管是文件传输的时候，还是io来实现的时候，永远是低地址的数据先出去，高地址的数据后出去。就这有问题了，比如我现在发出去的一个数据是小端格式存放的。结果发到你那里去之后，你将它当作大端格式来接收。0x30313233 当大端存储的格式来接收，和按小端格式来接收的结果是天差地别的。解决的思路是 不再严格的去区分到底是大端存储还是小端存储，区分主机字节序和网络字节序；</p>
<p>主机字节序： host<br>网络字节序： network</p>
<p>这个东西有什么作用呢？它其实就是我们使用的网络设备（计算机、平板电脑、智能手机等等）在内存当中存储数据的格式。所以如果通讯双方的设备存储数据的格式不同，那么一端发送过去的数据，另一端是无法正确解析的，这可怎么办呢？ </p>
<p>没关系，还好系统为我们准备了一组函数可以帮我们实现字节序转换，我们可以像使用公式一样使用它们。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// htonl,  htons,  ntohl,  ntohs - convert values between host and network byte order</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;  <span class="comment">// 主机到网络</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; <span class="comment">// 主机到网络</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;  <span class="comment">// 网络到主机</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>; <span class="comment">// 网络到主机</span></span><br></pre></td></tr></table></figure>

<p>_ to __:</p>
<p>当前pc机上的内容要上传网络传给对端的话，当前就应该是主机序转网络序；<br>如果数据是从网络上接收过来的话，那就是网络序转主机序；</p>
<p>这组函数的名字好奇怪是吧，所以为了便于记忆，在讨论它们的功能之前我们先来分析一下它们名字里的玄机：</p>
<p>h 是 host，表示主机；n 是 network，表示网络。l 表示 long，s 表示 short。<br>short为两个字节的， long为四个字节的</p>
<p>这样一来就好理解多了吧？它们的作用从名字中就可以看出来了，<br>就是把数据从主机序转换为网络序，<br>或者把数据从网络序转换为主机序。</p>
<p>网路字节序一般都是大端的，而主机字节序则根据硬件平台的不同而不同（在 x86 平台和绝大多数的 ARM 平台都是小端）。所以为了简化我们编程的复杂度，这些函数的内部会根据当前机器的结构自动为我们选择是否要转换数据的字节序。我们不用管到底我们自己的主机采用的是什么字节序，只要是从主机发送数据到网络就需要调用 hton 函数，从网络接收数据到主机就需要调用 ntoh 函数。</p>
<h3 id="1-1-3-对齐问题"><a href="#1-1-3-对齐问题" class="headerlink" title="1.1.3 对齐问题"></a>1.1.3 对齐问题</h3><p>4）最后一项约定是结构体成员不对齐，由于数据对齐也是与硬件平台相关的，所以不同的主机如果使用不同的对齐方式，就会导致数据无法解析。</p>
<p><strong>解决的办法</strong></p>
<blockquote>
<p>不对齐</p>
</blockquote>
<p>如何使数据不对齐呢，只需要在定义结构体的时候在结尾添加 <strong>attribute</strong>((packed)) 就可以了，见如下栗子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 struct msg_st</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">     <span class="keyword">uint32_t</span> math;</span><br><span class="line">     <span class="keyword">uint32_t</span> chinese;</span><br><span class="line"> &#125;__attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>网络传输的结构体中的成员都是紧凑的，所以不能地址对齐，需要在结构体外面增加 <strong>attribute</strong>((packed))。</p>
<p>关于字节对齐的东西就足够写一篇博文了，LZ 在这里仅仅简单介绍一下什么是字节对齐，如果感兴趣大家可以去查阅专门的资料。</p>
<p>结构体的地址对齐是通过 起始地址 % sizeof(type) == 0 这个公式计算的，也就是说存放数据的起始地址位于数据类型本身长度的整倍数。<br>如果当前成员的起始地址能被 sizeof 整除，就可以把数据存放在这；否则就得继续看下一个地址能不能被 sizeof 整除，直到找到合适的地址为止。不适合作为起始地址的空间将被空(lang)闲(fei)。</p>
<p><img src="./socket_02.png" alt=""><br>图2 字节对齐</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-2-报式套接字-UDP"><a href="#1-2-报式套接字-UDP" class="headerlink" title="1.2 报式套接字(UDP)"></a>1.2 报式套接字(UDP)</h2><p>从进程间通信开始，我们写程序就是一步一步按部就班的写就可以了，编写网络应用也一样，网络通信本质上就是一种跨主机的进程间通信（IPC）。</p>
<p>前面我们了解了主动端和被动端的概念，那么接下来看看在 Socket 中主动端和被动端都要做什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">主动端（先发包的一方）</span><br><span class="line"></span><br><span class="line">1.取得 Socket</span><br><span class="line"></span><br><span class="line">2.给 Socket 取得地址（可省略， 给socket取得地址指的是绑定本地地址，不必与操作系统约定端口，由操作系统指定随机端口）</span><br><span class="line"></span><br><span class="line">3.发&#x2F;收消息</span><br><span class="line"></span><br><span class="line">4.关闭 Socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">被动端（先收包的一方，程序需要先运行）</span><br><span class="line"></span><br><span class="line">1.取得 Socket</span><br><span class="line"></span><br><span class="line">2.给 Socket 取得地址 （绑定地址）</span><br><span class="line"></span><br><span class="line">3.收&#x2F;发消息</span><br><span class="line"></span><br><span class="line">4.关闭 Socket</span><br></pre></td></tr></table></figure>


<p>proto.h 里面主要是通讯双方约定的协议，包含端口号、传送数据的结构体等等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p>rcver.c 是被动端的代码，也是通讯双方先启动的一端。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ./rcver</span><br><span class="line">$&gt; netstat -anu   <span class="comment"># u代表 udp   -ant  t代表 tcp</span></span><br></pre></td></tr></table></figure>

<p>snder.c 是主动端，主动向另一端发送消息。这端可以不用向操作系统绑定端口，发送数据的时候由操作系统为我们分配可用的端口即可，当然如果想要自己绑定特定的端口也是可以的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    bind();    // 主动端可省略绑定端口的步骤</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sbuf,<span class="string">'\0'</span>,<span class="keyword">sizeof</span>(sbuf));</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由这三个文件组成的程序就可以进行网络通讯了，不知道大家有没有注意到，无论是发送端还是接收端，执行的步骤都是固定的，将来大家在开发更复杂的网络应用时也是基于这几个步骤进行扩展。</p>
<p>根据上面的代码中协议（proto.h）的定义，我们知道其中 msg_st 结构体中 name 成员的长度是固定的，这样并不好用，那么我们就把它修改为变长结构体。</p>
<p>修改成变长结构体很简单，只需把变长的部分放到结构体的最后面，然后通过 malloc(3) 动态内存管理来为它分配我们需要的大小。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">    <span class="keyword">uint8_t</span> name[<span class="number">1</span>];</span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure>


<p>UDP 包常规的最大尺寸是 512 字节，去掉包头的 8 个字节，再去掉结构体中除了最后一个成员以外其它成员大小的总和，剩下的就是我们最后一个成员最大能分配的大小。</p>
<p>大家还记得如何操作一个文件吗？</p>
<p>1.首先通过 open(2) 函数打开文件，并获得文件描述符；</p>
<p>2.通过 read(2)、write(2) 函数读写文件；</p>
<p>3.调用 close(2) 函数关闭文件，释放相关资源。</p>
<p>没错，在 Linux 的一切皆文件的设计理念中，网络也是文件，网络之间的通讯也可以像操作文件一样，对它进行读写。</p>
<p>在网络程序中，通常步骤是这样的：</p>
<p>1.首先通过 socket(2) 函数获得 socket 文件描述符；</p>
<p>2.通过 send(2)、sendto(2)、recv(2)、recvfrom(2) 等函数读写数据，这一步就相当于在网络上收发数据了。</p>
<p>3.调用 close(2) 函数关闭网络，释放相关资源。你没看错，这个函数就是我们关闭文件描述符的时候使用的函数。</p>
<p>下面我们依次介绍上面遇到的各种函数。</p>
<h3 id="1-2-1-socket函数"><a href="#1-2-1-socket函数" class="headerlink" title="1.2.1 socket函数"></a>1.2.1 socket函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket - create an endpoint for communication</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>socket(2) 函数是用来获取对网络操作的文件描述符的，就像 open(2) 函数一样。</p>
<p>参数列表：</p>
<p>　　domain：协议族/地址族；</p>
<p>　　type：上层如何进行实现/链接方式；</p>
<p>　　protocol：具体使用哪个协议。在 domain 的协议族中每一个对应的 type 都有一个或多个协议，使用协议族中默认的协议可以填写 0。</p>
<p><code>用 domain（协议族）中的 某种 protocol（具体哪个协议）进行 type类型的传输</code></p>
<p>返回值：如果成功，返回的是一个代表当前网络链接的文件描述符，你要保存好它，因为后续的网络操作都需要它。如果失败，返回 -1，并设置 errno。</p>
<p>下面就是 Linux 支持的协议族，也就是 <code>domain</code> 参数可以选择的宏，它们都定义在 sys/socket.h 头文件中，所以想要使用下面的宏不要忘记包含这个头文件哟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AF_UNIX、AF_LOCAL：本地协议；通过 man 7 unix 可以得到有关这个协议族更详细的描述。</span><br><span class="line"></span><br><span class="line">AF_INET：IPV4 协议；这是我们最常见的协议族，通过 man 7 ip 可以得到有关这个协议族更详细的描述。</span><br><span class="line"></span><br><span class="line">AF_INET6：IPV6 协议；，通过 man 7 ipv6 可以得到有关这个协议族更详细的描述。</span><br><span class="line"></span><br><span class="line">AF_IPX：Novell 当年是网络的代名词，是非常古老的操作系统，出现在 TCP&#x2F;IP 之前；</span><br><span class="line"></span><br><span class="line">AF_NETLINK：是用户态与内核态通信的协议；</span><br><span class="line"></span><br><span class="line">AF_X25：这是很早的协议，感兴趣的话可以自己去 Google 一下；</span><br><span class="line"></span><br><span class="line">AF_AX25：应用于业余无线电，也称为短波通信，都是一些无线电爱好者使用的协议。据说汶川地震时灾区所有通讯都瘫痪了，第一个求救信号就是短波发送出来的，因为这些无线电爱好者家里一般都有大大小小的发电机。</span><br><span class="line"></span><br><span class="line">AF_ATMPVC：当年如日中天，后来死于封闭。协议设计得非常好，后来几家公司都为了拿大头就僵持起来，谁都没有推广它，就在这时候以太网发展起来了，就把它打败了。以太网发展起来就是因为很简陋，所以更容易推广。</span><br><span class="line"></span><br><span class="line">AF_APPLETALK：苹果使用的一个局域网协议；</span><br><span class="line"></span><br><span class="line">AF_PACKET：底层 socket 所用到的协议，比如抓包器所遵循的协议一定要在网卡驱动层，而不能在应用层，否则无法见到包封装的过程。再比如 ping(1) 命令大家都熟悉吧，想要实现 ping(1) 命令就需要了解这个协议族，感兴趣的话大家可以自行 Google 一下。</span><br></pre></td></tr></table></figure>

<p>如果想要对网络编程进行更深入的学习，那么《APUE》作者写的《UNIX 网络编程》有必要读一遍；《TCP/IP详解》三卷也要读一下，但是这三卷都很难读，而且翻译质量也一般，可以买一本中文的再找一本英文电子版的，遇到中文的读不通的时候拿出来英文原文对照一下就可以了。</p>
<p>下面我们看一下 <code>type</code> 参数有哪些可选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SOCK_STREAM：流式套接字，特点是有序、可靠。有序、双工、基于链接的、以字节流为单位的。</span><br><span class="line"></span><br><span class="line">可靠不是指不丢包，而是流式套接字保证只要你能接收到这个包，那么包中的数据的完整性一定是正确的。</span><br><span class="line"></span><br><span class="line">双工是指双方都能收发。</span><br><span class="line"></span><br><span class="line">基于链接的是指：比如大街上张三、李四进行对话，一定不会说每句话之前都叫着对方的名字。也就是说通信双方是知道对方是谁的。</span><br><span class="line"></span><br><span class="line">字节流是指数据没有明显的界限，一端数据可以分为任意多个包发送。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SOCK_DGRAM：报式套接字，无链接的，固定的最大长度，不可靠的消息。</span><br><span class="line"></span><br><span class="line">就像写信，无法保证你发出的信对方一定能收到，而且无法保证内容不会被篡改。如果今天发了一封信，明天又发了一封信，不能保证哪封信先到。大家都能收到这个包，但是发现不是自己的之后就会丢弃，发现是自己的包再处理，有严格的数据分界线。更详细的解释可以参阅 man 手册。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SOCK_SEQPACKET：提供有序、可靠、双向基于连接的数据报通信。</span><br><span class="line"></span><br><span class="line">SOCK_RAW：原始的套接字，提供的是网络协议层的访问。</span><br><span class="line"></span><br><span class="line">SOCK_RDM：数据层的访问，不保证传输顺序。</span><br><span class="line"></span><br><span class="line">SOCK_PACKET：不好用，具体的 bug 要查 man 7 packet。</span><br></pre></td></tr></table></figure>





<p>bind(2)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind - bind a name to a socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">  <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind(2) 函数用于绑定本机端口，就是提前跟操作系统约定好，来自 xx 端口的数据都要转交给我（当前进程）处理，并且我占用了这个端口号别人（其它进程）就不能再使用了。</p>
<p>参数列表：</p>
<p>　　sockfd：刚刚使用 socket(2) 函数得到的文件描述符，表示要对该网络链接绑定端口。</p>
<p>　　addr：要绑定到套接字上的地址。根据不同的协议要在 man 手册第 7 章查阅具体的章节，然后在 Address Types 一栏里面找到对应的结构体。比如你在调用 socket(2) 函数的时候，domain 参数选择的是 AF_INET，那么这个结构体就可以在 man 手册 ip(7) 章节中找到。</p>
<p>　　addrlen：addr 传递的地址结构体的长度。</p>
<p>以 AF_INET 为例，下面这两个结构体就是在 ip(7) 中找到的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* 指定协议族，一定是 AF_INET，因为既然是 man ip(7)，那么一定是 AF_INET 协议族的 */</span></span><br><span class="line">  <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* 端口，需要使用 htons(3) 转换为网络序 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* 无符号32位大整数，可以使用 inet_pton(3) 将便于记忆的点分式 IP 地址表示法转换为便于计算机使用的大整数，inet_ntop(3) 的作用则正好相反。本机地址转换的时候可以使用万能IP：0.0.0.0(称为any address)，函数会自动将 0.0.0.0 解析为真实的本机 IP 地址。 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 大家可以看到，这个结构体的类型是 struct sockaddr_in，而 bind(2) 函数的第二个参数 的类型是 struct sockaddr，它们二者有什么关系呢？别瞎想，不是继承关系啦，C 语言中没有继承这种东东。在传参的时候直接把实参强转为 void* 类型即可，就像上面栗子中 rcver.c 写得那样。</p>
<p>recv(2) 和 recvfrom(2) 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recv, recvfrom - receive a message from a socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// src_addr 对端的地址</span></span><br><span class="line"><span class="comment">// addrlen  对端的地址长度</span></span><br></pre></td></tr></table></figure>


<p>这两个函数的作用是从网络上接收内容并写入 len 个字节长度的数据到 buf 中，且将发送端的地址信息填写到 src_addr 中。</p>
<p>返回值是真正能接收到的字节数，返回 -1 表示失败。</p>
<p>recv(2) 函数一般用在流式（SOCK_STREAM）套接字中，而 recvfrom(2) 则一般用在报式（SOCK_DGRAM）套接字中。很明显 recv(2) 函数并没有地址相关的参数，因为是提前建立好连接的一对一点对点的，所以不必记录每次对方是谁。</p>
<p>recvfrom 函数用在报式套接字当中，比如做一下现场答疑，有10个学生在提问问题，每个学生提问的问题不一致，也就说是说话的来源不一致，大家说话是带着自己身份来的。比如a同学的请求，要把回答信息准备回递给a同学。b同学的请求要回递给b同学，这点跟流式套接字不同，流式套接字已经建立一对一点对点的传输了。 需要记录对端的地址和地址长度。</p>
<p>为什么这么说呢，还记得上面我们提到过吗，流式套接字是基于链接的，而报式套接字是无链接的。<br>那么我们再来观察下这两个函数的参数列表，，而 recvfrom(2) 函数则会将对方的地址端口等信息回填给调用者。</p>
<p>网络中的数据只有单字节数据不用考虑字节序，从网络上接收过来的数据只要涉及到字节序就需要使用 ntoh 系列函数进行字节序转换。这一组函数我们上面介绍过了，没记住的童鞋可以往上翻。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小提示：通过 netstat(1) 命令 ant 参数可以查看 TCP 链接情况，或通过 netstat(1) 命令 anu 参数可以查看 UDP 链接情况。</span><br><span class="line"></span><br><span class="line">t 参数表示 TCP；</span><br><span class="line"></span><br><span class="line">u 参数表示 UDP；</span><br></pre></td></tr></table></figure>



<p>send(2) 和 sendto(2) 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send, sendto, sendmsg - send a message on a socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>


<p>这两个函数与 recv(2) 和 recvfrom(2) 函数正好是对应的，它们的作用是向网络上发送数据。</p>
<p>参数列表：</p>
<p>　　sockfd：通过哪个 Socket 往外发数据，这个参数的值就是在调用 socket(2) 函数的时候取得的；</p>
<p>　　buf：要发送的数据；</p>
<p>　　len：要发送的数据的长度；</p>
<p>　　flags：特殊要求，没有填 0；</p>
<p>　　src_addr：目标地址；就像上面我们讨论 bind(2) 函数时一样，具体使用哪个结构体要根据你在调用 socket(2) 函数的时候使用的具体协议族有关系，然后到对应的 man 手册第 7 章去查找。</p>
<p>　　addrlen：目标地址的长度；</p>
<p>返回值是真正发送出去的数据的长度；出现错误返回 -1 并设置 errno。</p>
<ul>
<li>动态报式套接字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ip 到 agrv的地方去指定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMEMAX     512-8-8 <span class="comment">// 512 是 udp包的 推荐长度， -8 是两个 固有字节 math 和 Chinese，再减8 是减去udp的包头</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">    <span class="keyword">uint8_t</span> name[<span class="number">1</span>]; <span class="comment">// 把当前的数组 设为一个 变长的内容, </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// uint8_t name[1]; 把name放在 结构体的首部 发送的名字只能接收第一个字符</span></span><br><span class="line">    <span class="comment">// uint32_t math;</span></span><br><span class="line">    <span class="comment">// uint32_t chinese;</span></span><br><span class="line">     </span><br><span class="line">&#125;__attribute__((packed)); <span class="comment">// 不对齐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> <span class="comment">// ./snder  IP  NAME</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> *<span class="title">sbufp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) <span class="comment">// ./snder  IP  NAME</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">2</span>]) &gt; NAMEMAX) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Name is too long"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = <span class="keyword">sizeof</span>(struct msg_st) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    sbufp = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sbufp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"malloc()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    bind();    // 主动端可省略绑定端口的步骤</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(sbufp-&gt;name, argv[<span class="number">2</span>]);</span><br><span class="line">    sbufp-&gt;math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbufp-&gt;chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd, sbufp, <span class="built_in">size</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> *<span class="title">rbufp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="built_in">size</span> = <span class="keyword">sizeof</span>(struct msg_st) + NAMEMAX <span class="number">-1</span>;</span><br><span class="line">    rbufp = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rbufp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"malloc()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>); <span class="comment">// 如果不太确定那个具体协议的名字是多少，</span></span><br><span class="line">    <span class="comment">// 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话，</span></span><br><span class="line">    <span class="comment">//一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * struct socket_in &#123;</span></span><br><span class="line"><span class="comment">     *    sa_family_t     sin_family;</span></span><br><span class="line"><span class="comment">     *    in_port_t       sin_port;  // 端口号</span></span><br><span class="line"><span class="comment">     *    struct_in_addr  sin_addr;   // ip地址</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * struct in addr &#123;</span></span><br><span class="line"><span class="comment">     *    uint32_t  s_addr; // 32位无符号的整型数</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // ip地址点分式和大整数之间的转换</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // 将ipv4 和 ipv6的地址转成二进制的格式</span></span><br><span class="line"><span class="comment">     * int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 跟本机约定哪个端口是给自己使用的；</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) <span class="comment">// bind 给socket取得地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr); <span class="comment">// addrlen 需要初始化一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd, rbufp,<span class="built_in">size</span>,<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>) <span class="comment">// 接收消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);<span class="comment">// 把一个大整数形式转成点分式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbufp-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbufp-&gt;math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbufp-&gt;chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后剩下 close(2) 函数就不需要 LZ 在这里介绍了吧，如果还有童鞋对 close(2) 函数不熟悉，那么请翻阅到前面 文件 IO 部分的博文中复习一遍。</p>
<h3 id="1-2-2-多点通讯"><a href="#1-2-2-多点通讯" class="headerlink" title="1.2.2 多点通讯"></a>1.2.2 多点通讯</h3><p>上面我们讨论的是单点通讯，多点通讯只能用报式套接字来实现。</p>
<p>一般多点通讯分为：广播 和 多播（组播）两种方式。</p>
<p>广播又分为 全网广播（255.255.255.255） 和 子网广播 两种形式。</p>
<p>多播：都是 D 类地址，以 224. 开头。224.0.0.1 是一个组播中的特殊地址，发到这个地址的消息会强制所有组播地址中的主机接收，类似于全网广播。</p>
<p>广播：往（255，255，255，255发送消息）范围非常大，愿不愿意接收都得接收到；</p>
<p>组播： 建立一个播组，如果想接收到消息，就加入这个组；不想收就退组。多播的使用权更加灵活，当然多播当中有一个特殊地址，如果往这个特殊地址发送消息的话。实际就如同发送一个广播，效果是一样的。从另外一个角度来实现广播的特点</p>
<p>注意：广播和组播仅在局域网内有效。</p>
<ul>
<li>一个广播实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ip 到 agrv的地方去指定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed)); <span class="comment">// 不对齐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>); <span class="comment">// 如果不太确定那个具体协议的名字是多少，</span></span><br><span class="line">    <span class="comment">// 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话，</span></span><br><span class="line">    <span class="comment">//一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &amp;val, <span class="keyword">sizeof</span>(val))&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsocket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * struct socket_in &#123;</span></span><br><span class="line"><span class="comment">     *    sa_family_t     sin_family;</span></span><br><span class="line"><span class="comment">     *    in_port_t       sin_port;  // 端口号</span></span><br><span class="line"><span class="comment">     *    struct_in_addr  sin_addr;   // ip地址</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * struct in addr &#123;</span></span><br><span class="line"><span class="comment">     *    uint32_t  s_addr; // 32位无符号的整型数</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // ip地址点分式和大整数之间的转换</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // 将ipv4 和 ipv6的地址转成二进制的格式</span></span><br><span class="line"><span class="comment">     * int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 跟本机约定哪个端口是给自己使用的；</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) <span class="comment">// bind 给socket取得地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr); <span class="comment">// addrlen 需要初始化一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>) <span class="comment">// 接收消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);<span class="comment">// 把一个大整数形式转成点分式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前广播默认要求是不能够发出的，组播其实也一样。</span></span><br><span class="line"><span class="comment">     * socket层上面的实现层也好 还是下面的协议层也好。打开来看实际上有很多薄的层，</span></span><br><span class="line"><span class="comment">     * IP层，TCP层，UDP层，甚至socket层面。在不同的层上会有不同的开关或选钮加以控制。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 全网广播实际上是禁止被发送的，而有一个开关是能够使当前的广播是能够实现的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sbuf,<span class="string">'\0'</span>,<span class="keyword">sizeof</span>(sbuf));</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"255.255.255.255"</span>,&amp;raddr.sin_addr);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./rcver</span><br><span class="line">./snder</span><br><span class="line">ok!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端并没有收到响应， 原因可能是防火墙的问题</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-抓包工具使用"><a href="#1-4-抓包工具使用" class="headerlink" title="1.4 抓包工具使用"></a>1.4 抓包工具使用</h2><p>过滤表达式</p>
<p><code>ip.dist == 255.255.255.255</code></p>
<p>getsockopt(2) 和 setsockopt(2) 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getsockopt, setsockopt - get and set options on sockets</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数用于读取和设置套接字的特殊要求。</p>
<p>对 sockfd 这个套接字的 level 层的 optname 选项进行设置，值放在 optval 里，大小是 optlen。</p>
<p>参数 sockfd、level 和 optname 的对应关系就是：一个 sock 有多个 level，每个 level 有多个选项。</p>
<p>所有的选项需要在不同协议的 man 手册(第7章) Socket options 一栏查找。</p>
<p>常用 optname 参数：</p>
<p>SO_BROADCAST：设置或获取广播标识，当这个标识被打开时才允许接收和发送报式套接字广播，所以大家使用广播的时候不要忘记设置这个 opt，但在流式套接字中无效。</p>
<p>IP_MULTICAST_IF：创建多播组，optval 参数应该使用 ip_mreqn 还是 ip_mreq 结构体，取决于 IP_ADD_MEMBERSHIP 选项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">/* 多播组 IP 地址，大整数，可以用 inet_pton(3) 将点分式转换为大整数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_address</span>;</span> <span class="comment">/* 本机 IP 地址，可以用 0.0.0.0 代替，大整数，可以用 inet_pton(3) 将点分式转换为大整数 */</span></span><br><span class="line"><span class="keyword">int</span> imr_ifindex; <span class="comment">/* 当前使用的网络设备的索引号，ip ad sh 命令可以查看编号，用 if_nametoindex(3) 函数也可以通过网络设备名字获取编号，名字就是 ifconfig(1) 看到的名字，如 eth0、wlan0 等 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>IP_ADD_MEMBERSHIP：加入多播组</p>
<h3 id="1-4-1-多播-组播"><a href="#1-4-1-多播-组播" class="headerlink" title="1.4.1 多播/组播"></a>1.4.1 多播/组播</h3><blockquote>
<p>多播属于D类IP地址，都是224. 开头</p>
</blockquote>
<p><code>224.0.0.1</code> 表示所有支持多播的节点；默认都存在这个组当中，并且无法离开。所以在sender方往这个地址发消息相当于往 <code>255.255.255.255</code>上发消息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MGROUP      <span class="meta-string">"224.2.2.2"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定多播组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 发送方应该创建多播组，并且发组间消息。而接收方应该是加入多播组，从这个多播组中来收消息。</span></span><br><span class="line"><span class="comment"> * 这个组就从为大家需要知道的内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed)); <span class="comment">// 不对齐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>); <span class="comment">// 如果不太确定那个具体协议的名字是多少，</span></span><br><span class="line">    <span class="comment">// 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话，</span></span><br><span class="line">    <span class="comment">//一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mreq</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, MGROUP, &amp;mreq.imr_multiaddr);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;mreq.imr_address);</span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq) )&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsocket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 跟本机约定哪个端口是给自己使用的；</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) <span class="comment">// bind 给socket取得地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr); <span class="comment">// addrlen 需要初始化一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>) <span class="comment">// 接收消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);<span class="comment">// 把一个大整数形式转成点分式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前广播默认要求是不能够发出的，组播其实也一样。</span></span><br><span class="line"><span class="comment">     * socket层上面的实现层也好 还是下面的协议层也好。打开来看实际上有很多薄的层，</span></span><br><span class="line"><span class="comment">     * IP层，TCP层，UDP层，甚至socket层面。在不同的层上会有不同的开关或选钮加以控制。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 全网广播实际上是禁止被发送的，而有一个开关是能够使当前的广播是能够实现的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mrep</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, MGROUP, &amp;mrep.imr_multiaddr);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;mrep.imr_address);</span><br><span class="line">    mrep.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(sd, IPPROTO_IP, IP_MULTICAST_IF,&amp;mrep, <span class="keyword">sizeof</span>(mrep) ) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sbuf,<span class="string">'\0'</span>,<span class="keyword">sizeof</span>(sbuf));</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 约定多播组</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 发送方应该创建多播组，并且发组间消息。而接收方应该是加入多播组，从这个多播组中来收消息。</span></span><br><span class="line"><span class="comment">     * 这个组就从为大家需要知道的内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    inet_pton(AF_INET, MGROUP, &amp;raddr.sin_addr);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-wireShark"><a href="#1-4-2-wireShark" class="headerlink" title="1.4.2 wireShark"></a>1.4.2 wireShark</h3><blockquote>
<p>41:6c:61:6e:00:00:00:00:00:34:00:00:00:00:00:00:53:00:00:00:56</p>
</blockquote>
<p>这是<code>basic</code>包中程序 实际发出的数据包。看到6e 到 53 中间的 34 就是内存泄漏，泄漏的是栈上残留的数据；</p>
<p>处理方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"> * <span class="comment">// 把从 某某位置开始 到 某某位置结束 中间 n个位置的数值 清空为 '\0'</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-udp-丢包"><a href="#1-4-3-udp-丢包" class="headerlink" title="1.4.3 udp 丢包"></a>1.4.3 udp 丢包</h3><p>下面来谈谈丢包和校验的问题</p>
<ul>
<li>TTl</li>
</ul>
<blockquote>
<p>TTL（time to leave） 是一个数据包能够经过的路由器数量的上限;</p>
</blockquote>
<p>UDP 会丢包，为什么会丢包呢？丢包由于阻塞造成的</p>
<blockquote>
<p>因为不同的请求会选择不同的路径经过不同的路由器，这些包到达路由器的时候会进入路由器的等待队列，当路由比较繁忙的时候队列就会满，当队列满了的时候各个路由会根据不同的“丢包算法（当队列达到80%的时候，选择随机丢包。或者当包占到这个队列百分之多少的时候，剩下的包不再接收等等）”丢弃多余的包（一般是丢弃新来的包或随机丢弃包）。所以丢包的根本原因是拥塞。</p>
</blockquote>
<p>ping 命令的 TTL（time to leave） 是一个数据包能够经过的路由器数量的上限，这个上限在 Linux 环境里默认是 64，在 Windows 里默认是 128。</p>
<p>假设从中国某个点发送一个包到美国的某个点，从发出开始到中国的总路由器需要大约十几跳，从中国总路由到美国总路由大约两三跳就到了，再从美国总路由到达目标点也经过大约十几跳，因此无论 TTL 是 64 还是 128 都足以从全球任何一个点发送数据到另一个点了，况且发出去的这几个包走的路径也是不一致的，因为当前在经过沿途路由队列，本身会有一个选择算法（寻找最短路径），很有可能每个包走的都是不同路径。所以丢包绝不是因为 TTL 值太小导致的。</p>
<ul>
<li>数据校验</li>
</ul>
<blockquote>
<p>网站图片显示不全打X，或者部分显示不全。类似web服务等，都会有一个断点续传的功能。这里不能做硬性数据校验（刷新发包请求）， 而应该是 尝试读-&gt;读不出来就跳一个字节-&gt; 依次循环，而不是读不到就卡住这种非硬性校验。在做一些网络操作的时候，网络的一些也不会做硬性的数据校验</p>
</blockquote>
<p>解决丢包的方法是使用流量控制，之前我们写过令牌桶还记得吧？流控分为开环式（没有校验的流控）和闭环式。</p>
<p>我们在这里介绍一种<code>停等式流控</code>：它是一种闭环式流控。它的实现方式很简单，一问一答即可。就是发送方每次发送一个数据包之后要等待接收方的响应，确认接收方收到了自己的数据包后再发送下一个数据包。这种方式的特点是每次等待的时间是不确定的，因为每次发包走的路径是不同的，所以包到达目的地的时间也是不同的，而且还要受网络等环境因素影响。</p>
<p><img src="./udp_01.png" alt=""></p>
<p>（发包之后等待ACK反馈之后再接着发）</p>
<p>并且停等式流控的缺点也很明显：<br>1.浪费时间，多数时间都花费在等待响应上面了。<br>2.双方发送包的数量增加了，这也意味着丢包率升高了。<br>3.为了降低错误率，实现的复杂度会变高。如果 s 端 data 包发过去了，但是 c 端响应的 ack 包丢了，s 端过了一会儿没收到 ack 认为 data 丢了再次发送 data，当 c 端再次收到一模一样的 data 包时不知道到底是有两段数据一模一样还是 s 端把包发重复了，所以需要给data包加编号，这样 c 端就知道当前这个 data 包是合法的数据还是多余的数据了。</p>
<p>停等式流控虽然上升了丢包率，但是能保证对方一定能收到数据包。</p>
<ul>
<li>rtt（解决发送data丢失的问题）</li>
</ul>
<p>平均等待时间，比如s第一次向c发送包就丢了，那又不可能一直傻等着根本来不了的ACK包。所以需要设置一个平均等待时间，初始化这个值设多大没有关系，只要发第一个data，收到ACK的时候，这个时间就作为一个完全的rrt。第二个ack到来的时候，又是一个时间。这两个rrt想办法做一个平均值。然后每一次的返回新的ack，都要拿新的时间汇总计算出平均值。所以第一次发包就丢的情况，在等待了一次rrt 之后就继续发一下包过去。等待ack返回在继续。然后依此类推。</p>
<ul>
<li>给data包加编号 （解决没有ack丢失的问题）</li>
</ul>
<p>同样，s第一次向c发送包成功了，但是c返回的ack包丢了。s在等待一个rtt时间之后，发现没见ack的踪迹。s没有能力去判断c那边到底是自己包没发成功，还是ack包丢包了。所以，s端只能认为是自己的data包丢了。所以就重新传了data包，这就有问题了，c那边接到两个一摸一样的data包。那c就怀疑两件事儿：1 自己的ack包是不是丢了，2 是不是就有两个一摸一样data包的情况呢。因此需要给data包添加编号。所以c端在处理刚才的情况的时候，发现两个data包编号一样的话，就知道自己丢ack包了，然后赶紧把给s端返回ack包，并顺带把重复的data给删除掉了。</p>
<p>web 传输通常采用两种校验方案：</p>
<p>1.不做硬性校验：交给用户来做。比如你在浏览网页，网页周边的广告都加载出来了，但是正文没有加载出来，你肯定会刷新页面吧？但是如果正文加载出来了，周边的广告没有加载出来，你会刷新网页一定要让整个网页全部都加载完整再看内容码？</p>
<p>2.延迟应答：下次通讯的时候把上次的 ack 带过来，表示上次的通讯是完整的。</p>
<ul>
<li>ack延迟</li>
</ul>
<p><img src="./socket_03.png" alt=""><br>图3 ack 延迟</p>
<p>不仅仅 data 包会出现延迟， ack 包也会出现延迟（见图3）。所以 ack 包也需要加编号。</p>
<p>为了防止被抓包，所以往往不会把原始的编号暴露出来，比如将编号+1或-1再发送。</p>
<p>网络的拥塞不仅仅会带来丢包的问题，还会带来延迟的问题。延迟并不可怕，可怕的是延迟抖动。比如在北京看新闻联播和在云南看新闻联播会是同时的吗？肯定会有相应的延迟吧，每一帧都延迟就没关系，就怕其中某些帧延迟，其它帧不延迟，这样看到的内容就全乱了。</p>
<p>上面说了用停等式流控可以保证数据一定能够让对方接收到，但是有没有觉得速度慢了点？</p>
<p>可以通过窗口或滑动窗口提高速度，见图4。</p>
<ul>
<li>滑动窗口（最大限度抢占路由资源）</li>
</ul>
<p><img src="./socket_04.png" alt=""><br>图4 窗口</p>
<p>使用窗口协议的停等式流控，不再是发送一个包之后等待 ack 然后再发送另一个包，而是一下子发送出去多个包（图中一次发送 5 个包），分别等待它们的响应后再发送下一批次的包。一次发送 5 个包，那么窗口的大小就是 5。使用窗口协议就可以尽可能多的抢占公共资源（交换机的等待队列等）了，这样传输效率相比简单的停等式流控就更高了。当然窗口的缺点也是显而易见的：窗口的大小不可变，对于复杂的网络情况并不灵活。那么只要对窗口稍加改变就可以更灵活的应对复杂多变的网络环境：动态改变窗口的大小，使之可以根据不同的网络情形动态的改变流控的速率，这样就可以平衡丢包率和传输速率之间的杠杆了，这种可以动态调整窗口大小的协议叫做“滑动窗口”。关于窗口和滑动窗口这里就不做过多介绍了，感兴趣的童鞋可以去查阅一些专门的资料。</p>
<p>新的问题</p>
<p>s第一次拿到的ack一定是第一个data包对应的ack吗？不一定把。所以s端和c端在进行对话之前，要进行编号的约定。</p>
<h2 id="1-5-TCP"><a href="#1-5-TCP" class="headerlink" title="1.5 TCP"></a>1.5 TCP</h2><p>说完了 UDP，接下来聊一聊 TCP。</p>
<p><img src="./tcp_00.png" alt=""></p>
<p>图x tcp三次握手原理</p>
<p>由报式套接字过渡到流式套接字(三次握手（中间两步合成一步，四步并三步）主要目的就是为了协同编号，实际上也是约定对话格式，指定协议的过程 )c端向s端说，我的编号从哪里开始，s端回收到并告诉自己从什么编号开始，c端发起第一次握手，s端回第二次握手，c端发起第三次握手。有了这三次握手之后，s端和c端就建立起一对一的，点对点的安全传输。这就是TCP三次握手的精髓所在。然后后面会有四次挥手，会把当前传输过程，或者传输的数据来进行总结，进行断开链接等操作。</p>
<p>说到 TCP 就不得不谈到 TCP 的三次握手，见图 5。</p>
<p><img src="./socket_05.png" alt=""></p>
<p>图5 TCP 三次握手</p>
<p>TCP 都是要客户端先发起请求，所以客户端可以称为“主动端”，而服务器被动接收请求，所以服务端也可以称为“被动端”。往往服务端要先运行起来，然后客户端再发送消息，否则客户端发送的包会因为找不到目的地而被丢弃。</p>
<ul>
<li>半连接状态</li>
</ul>
<p>如图x所示，1，2两步被称为半连接状态。然后在s端会有一个池，叫做半链接池；</p>
<p>服务端收到客户端发来的 SYN 报文后（第1步），会响应 SYN+ACK 报文给客户端（第2步），并将当前链接的一些信息放入一个叫做“半链接池”的缓冲区中，当对方发起第三次握手的时候（第3步），就在池中找到对方的信息（ip，port protocol等）。如果都存在的话，就说明前面已经建立了两个成功的握手。<br>那么就接收第三次握手，下面就进入正常的数据传输。当然如果超过一定时间后该客户端没有返回 ACK 报文给服务端，服务端再把这个半链接从半链接池中移除，释放相关资源。</p>
<ul>
<li>半链接洪水（无法从根本上进行防范）</li>
</ul>
<blockquote>
<p>占满你的链接池</p>
</blockquote>
<p>只要出现了“XX池”，那么该池的容量终归是有限的，所以有一种下流的拒绝服务攻击手段就是利用大量的半链接把服务端的半链接池沾满，以实现拒绝服务攻击。例如当很多肉鸡向某台服务器发送第一次握手（FIN）却永远不发送第三次握手（ACK），这样很快就把服务器的半链接池沾满了，有效的用户也就无法请求服务器了，这就是下流的半链接攻击手段的大致原理。</p>
<ul>
<li>取消链接池</li>
</ul>
<p>防范半链接的手段就是取消半链接池，然后通过一个算法为每个链接计算出一个独一无二的标识，再把这个标识放入 cookie 中通过 ACK 返回给客户端。cookie 由内核产生，仅保留这一秒和上一秒的 cookie。当用户再次请求时需要带着这个 cookie，用相同的 cookie 计算，只要与用户带来的 cookie 相同就认为是合法用户，如果不相同就用上一秒的cookie再次计算和比较，如果还不相同，就认为用户的cookie 是伪造的或是超时的，所以用户会立即重新建立第一次握手。</p>
<p>cookie计算公式：本机IP+本机端口+对端IP+对端端口 | Salt（由内核产生的，1秒变一次）</p>
<p>其实在实践当中也会保留半链接池，里面仅仅存放频繁访问的用户来优化 cookie 方式的链接。</p>
<p>简要的介绍了 TCP 的三次握手之后，我们来看看如何实现用 TCP 协议收发数据。有关更详细的 TCP 知识，感兴趣的童鞋可以参阅《TCP/IP 卷一：协议》。</p>
<h3 id="1-5-1-TCP实现"><a href="#1-5-1-TCP实现" class="headerlink" title="1.5.1 TCP实现"></a>1.5.1 TCP实现</h3><p>TCP 的步骤</p>
<p>S端（先运行）</p>
<p>1.取得 SOCKET (socket(2)) IPPROTO_SCTP 是一种新协议，也可以实现流式套接字<br>2.给 SOCKET 取得地址 (bind(2))<br>3.将 SOCKET 置为监听模式 (listen(2)) backlog 参数写什么正整数都行。<br>4.接受链接 (accept(2)) 如果成功返回接受链接的文件描述符，失败返回 -1 并设置 errno。注意不能直接用存放之前 socket(2) 返回的文件描述符变量来接收 accept(2) 的返回值，因为accept(2) 可能会遇到假错，这样之前变量里保存的文件描述符就丢了，会导致内存泄漏。<br>5.收/发消息 (send(2))<br>6.关闭 SOCKET (close(2))</p>
<p>C端（主动端）</p>
<p>1.取得 SOCKET (socket)<br>2.给 SOCKET 取得地址（可省） (bind)<br>3.发起链接 (connect)<br>4.收/发消息<br>5.关闭 SOCKET</p>
<p>proto.h，这个文件是客户端与服务端的协议，双方共同遵守的格式要定义在这里，所以两边都要包含这个头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端口号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVERPORT        <span class="meta-string">"12999"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FMT_STAMP        <span class="meta-string">"%lld\r\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>server.c 服务端，要先运行起来，监听指定的端口，操作系统指定的端口收到数据后就会送到服务端程序这里来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd,newsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>/*<span class="title">local</span> <span class="title">address</span>*/, <span class="title">raddr</span> /*<span class="title">remote</span> <span class="title">address</span>*/;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 TCP 协议</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动</span></span><br><span class="line">    <span class="comment">// 会导致 bind 端口短暂失效的情况</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>; <span class="comment">// bool值，除了0就是1；</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 指定服务端使用的端口号</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经</span></span><br><span class="line"><span class="comment">     * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个</span></span><br><span class="line"><span class="comment">     * 数值的上限。</span></span><br><span class="line"><span class="comment">     * 所以backlog 现在指能能够承受C端的全链接的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 开始监听端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待新消息传入</span></span><br><span class="line">        newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"newsd()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port)); <span class="comment">//知悉对方是谁</span></span><br><span class="line"></span><br><span class="line">        server_job(newsd); <span class="comment">// 解决sendto 问题的函数</span></span><br><span class="line">        <span class="built_in">close</span>(newsd); <span class="comment">// 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 正常情况下，执行不到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ./server</span><br><span class="line">$&gt; netstat -ant</span><br><span class="line"></span><br><span class="line">Proto Recv-Q Send-Q  Local Address    Foreign Address     State  </span><br><span class="line">tcp     0            0 0.0.0.0:1989   0.0.0.0:*           LISTEN  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提到这个 State状态，当通过ctrl+c的方式 LISTEN会变为 TIME_WAIT, 并且服务无法被客户端访问，当再次启动服务端程序时，报错，bind(): address already in use.说明 1989这个端口还在工作当中，ctrl+c属于异常结束，程序中没法正确把socket实例释放掉。</span></span><br><span class="line"><span class="comment">#当前被释放的资源 会被操作系统批量回收，也就是在说话期间，内核发现我们这个端口其实对应的socket已经被异常终止了。那么它就会帮你把这个资源释放掉。所以端口经过这个阶段就会变为一个free而可以使用的状态。再去bind就ok了。</span></span><br><span class="line"></span><br><span class="line">$&gt; nc 127.0.0.1 1989 <span class="comment"># 使用系统提供的客户端工具发送请求 没有nc 可以用 telnet代替</span></span><br><span class="line">1597216327</span><br><span class="line"></span><br><span class="line"><span class="comment">#server</span></span><br><span class="line">Client:127.0.0.1:59672</span><br></pre></td></tr></table></figure>

<p> client.c 是客户端，也就是主动端，它的发送端口可以不用手动指定而由操作系统来随机分配一个未被占用的端口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sd;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> stamp;    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 TCP 协议</span></span><br><span class="line">  sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">  <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">"socket()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  raddr.sin_family = AF_INET;</span><br><span class="line">  <span class="comment">// 指定服务器的端口号</span></span><br><span class="line">  raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">  <span class="comment">// 指定服务端 IP 地址</span></span><br><span class="line">  inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line">  <span class="comment">// 发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">connect</span>(sd,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">"connect()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp = fdopen(sd,<span class="string">"r+"</span>); <span class="comment">// 把scoket 返回的文件描述符 封装成一个文件流来使用</span></span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">"fdopen()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取服务端的响应，当然也可以使用 recv(3P) 函数来替代 fscanf(3) 函数。</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">fscanf</span>(fp,FMT_STAMP,&amp;stamp) &lt; <span class="number">1</span>) <span class="comment">// 标准IO来</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fscanf() failed.\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stamp = %lld\n"</span>,stamp);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-server端-并发版本重构"><a href="#1-5-2-server端-并发版本重构" class="headerlink" title="1.5.2 server端 并发版本重构"></a>1.5.2 server端 并发版本重构</h3><ul>
<li>发现问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c 大部分时间在此段代码中重复循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 阻塞等待新消息连接</span></span><br><span class="line">    newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perror(<span class="string">"newsd()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port)); <span class="comment">//输出连接信息</span></span><br><span class="line"></span><br><span class="line">    server_job(newsd); <span class="comment">// 主要处理请求函数， 阻塞10s，此函数阻塞10s的间隙，可能有几千个请求进来了。所以这个 请求函数应该变成一个并发的模式；</span></span><br><span class="line">    <span class="built_in">close</span>(newsd); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// sleep(10) // 假如在这里停顿10s，表示如果此函数阻塞了，那后面的请求就无法进来了</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd,newsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>/*<span class="title">local</span> <span class="title">address</span>*/, <span class="title">raddr</span> /*<span class="title">remote</span> <span class="title">address</span>*/;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 TCP 协议</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动</span></span><br><span class="line">    <span class="comment">// 会导致 bind 端口短暂失效的情况</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>; <span class="comment">// bool值，除了0就是1；</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 指定服务端使用的端口号</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经</span></span><br><span class="line"><span class="comment">     * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个</span></span><br><span class="line"><span class="comment">     * 数值的上限。</span></span><br><span class="line"><span class="comment">     * 所以backlog 现在指能能够承受C端的全链接的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 开始监听端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待新消息传入</span></span><br><span class="line">        newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"newsd()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(sd); <span class="comment">// 子进程由于会拷贝一份 父进程的所有资源，包含sd，但子进程没有用到sd，所以需要关闭</span></span><br><span class="line">            inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port)); <span class="comment">//知悉对方是谁</span></span><br><span class="line"></span><br><span class="line">            server_job(newsd); <span class="comment">// 解决sendto 问题的函数</span></span><br><span class="line">            <span class="built_in">close</span>(newsd); <span class="comment">// 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符，</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 子进程处理函数结果后，要结束进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(newsd); <span class="comment">// 同样的，newsd 复制了一份给子进程，在父进程的域内，newsd没有被引用到了，所以需要主动去释放掉；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 正常情况下，执行不到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p>上面这个多进程版本虽然可以实现网络连接的并发问题，但假如请求服务端的客户端特别多的情况下，为每一个人都fork一个子进程。这个开销你能不能承受。又绕回去到老问题去了。实际情况下，根本没富裕的资源用来创造无限的进程空间来处理请求；</p>
<h3 id="1-5-3-静态进程池重构"><a href="#1-5-3-静态进程池重构" class="headerlink" title="1.5.3 静态进程池重构"></a>1.5.3 静态进程池重构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态进程池版本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCNUM   4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_loop</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">int</span> newsd;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// accept 本身就能实现单一的链接，也就是说它本身就能实现互斥</span></span><br><span class="line">        newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"newsd()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]Client:%s:%d\n"</span>,getpid(),ipstr,ntohs(raddr.sin_port)); <span class="comment">//知悉对方是谁</span></span><br><span class="line"></span><br><span class="line">        server_job(newsd); <span class="comment">// 解决sendto 问题的函数</span></span><br><span class="line">        <span class="built_in">close</span>(newsd); <span class="comment">// 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>/*<span class="title">local</span> <span class="title">address</span>*/;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 TCP 协议</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动</span></span><br><span class="line">    <span class="comment">// 会导致 bind 端口短暂失效的情况</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>; <span class="comment">// bool值，除了0就是1；</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 指定服务端使用的端口号</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经</span></span><br><span class="line"><span class="comment">     * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个</span></span><br><span class="line"><span class="comment">     * 数值的上限。</span></span><br><span class="line"><span class="comment">     * 所以backlog 现在指能能够承受C端的全链接的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 开始监听端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt; PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            server_loop(sd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p>当前静态进程池中就四个进程，如果每个服务要10s才能完成处理函数。这四个人肯定在某个时刻都在忙着。假如C端当前来了一万+请求，其实该程序也只能忙完当前四个再去忙下四个。这个池缺乏弹性。闲时四个进程闲置，千万级别并发请求时，四个进程也没法忙过来。</p>
<p>该模型能优化为动态进程池，比如当前池中最少有10个进程，最多可以容纳100个进程。闲时10个进程，十个accept在等着，防止访问激增。当请求来了，这10个进程能马上进入工作。父进程来主宰进程池中的状态，当发现进程池中10个常规进程都忙去了，父进程就需要动态创建新的进程去处理新任务了。要保证进程池中至少保证有10个闲置的进程在待命，当然进程池上限不超过200个。假如客户端真的有1万+，也管不了拉。进程池上限就是200个。一万个请求总归是会服务完了，当一个用户都没有的时候，进程池资源是需要释放到掉只保留常规的10个进程即可。总之，父进程需要管理不同状态下的进程池的增删改查。</p>
<p>模型在大一些，可以服务一个集群，根据负载均衡将请求分发给不同的服务器去处理；</p>
<h3 id="1-5-4-动态进程池实现"><a href="#1-5-4-动态进程池实现" class="headerlink" title="1.5.4 动态进程池实现"></a>1.5.4 动态进程池实现</h3><p>通过这几个栗子可以看出来，TCP 一般使用 recv(3P)、send(3P) 等函数来收发数据，而 UDP 一般使用 recvfrom(3P)、sendto(3P) 等函数来收发数据。因为 TCP 一开始就创建了稳定的链接，所以在通讯的过程中就不需要每次都指定对方的地址了。而 UDP 是报式传输协议，并没有建立一个稳定的链接，所以通讯的过程中要始终指定当前这个数据报要发送到哪里，或者是指明它是从哪里来的。</p>
<p>最后再补充一点：如果 Ctrl+C 结束服务端，再次启动后执行 bind(2) 就会报错。</p>
<p>bind(): Address already in use</p>
<p>使用 netstat -ant 命令会发现之前的链接都没有释放，且端口也没有释放，所以由于无法监听一个没有被释放的端口就报错了。</p>
<p>有两种办法，一种是等一会儿就好了，另一种是使用 setsockopt(2) 函数，这个在上面 server.c 的注释中说明过了，没有注意到的童鞋请翻到上面去参考一下。</p>
<p>为什么等一会儿就好了呢？因为操作系统会经常检查有哪些端口被无效的进程占用了，找到了就会释放这个端口。</p>
<p>在 bind(2) 之前使用 setsockopt(2) 函数，将 optname 设置为 SO_REUSEADDR，它表示如果占用当前端口的程序已经消亡了，那么重新使用这个端口。</p>
<h3 id="1-5-5-抓包图片"><a href="#1-5-5-抓包图片" class="headerlink" title="1.5.5 抓包图片"></a>1.5.5 抓包图片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&gt; eog xy.png <span class="comment"># 打开一张图片</span></span><br><span class="line"></span><br><span class="line">$&gt; cp /home/hy/xy.png  /var/www/html/test.jpg</span><br><span class="line"></span><br><span class="line">$&gt; ls /var/www/html/test.jpg</span><br><span class="line"></span><br><span class="line">$&gt; service httpd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器</span></span><br><span class="line">127.0.0.1/test.jpg</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>
          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2020/12/16/apue-11/>http://yoursite.com/2020/12/16/apue-11/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-04-28T18:53:05+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Apr 28, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/doc/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>doc</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2020/12/16/apue-11/&title=socket - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2020/12/16/apue-11/&title=socket - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2020/12/16/apue-11/&title=socket - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/12/16/apue-6/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>信号</p>
                <p class='content'>信号
信号的概念
signal();
信号的不可靠
可重入函数
信号的响应过程（非常重要的图）
常用函数（kill raise alarm pause abort system sleep ）
...</p>
              </a>
            
            
              <a class='next' href='/2020/12/16/apue-7/'>
                <p class='title'>线程<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>线程
实际项目中多线程用得比较多，因为多线程是先有标准后有实现的，所以不会向多进程那样在不同平台上有许多不同的情况。


线程的概念
线程的创建、线程终止、 线程的取消、线程的清理
线程的同步（...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'socket',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-跨主机的传输要注意的问题"><span class="toc-text">1.1 跨主机的传输要注意的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-类型长度问题"><span class="toc-text">1.1.1 类型长度问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-字节序问题：-大端存储，小端存储"><span class="toc-text">1.1.2 字节序问题： 大端存储，小端存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-对齐问题"><span class="toc-text">1.1.3 对齐问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-报式套接字-UDP"><span class="toc-text">1.2 报式套接字(UDP)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-socket函数"><span class="toc-text">1.2.1 socket函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-多点通讯"><span class="toc-text">1.2.2 多点通讯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-抓包工具使用"><span class="toc-text">1.4 抓包工具使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-多播-组播"><span class="toc-text">1.4.1 多播&#x2F;组播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-wireShark"><span class="toc-text">1.4.2 wireShark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-udp-丢包"><span class="toc-text">1.4.3 udp 丢包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-TCP"><span class="toc-text">1.5 TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-TCP实现"><span class="toc-text">1.5.1 TCP实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-server端-并发版本重构"><span class="toc-text">1.5.2 server端 并发版本重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-静态进程池重构"><span class="toc-text">1.5.3 静态进程池重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-4-动态进程池实现"><span class="toc-text">1.5.4 动态进程池实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-5-抓包图片"><span class="toc-text">1.5.5 抓包图片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
