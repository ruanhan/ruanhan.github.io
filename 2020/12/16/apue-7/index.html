<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>线程 - Hexo</title>
  
    <meta name="keywords" content="doc">
  
  
    <meta name="description" content="7.线程">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/12/16/apue-7/">
      线程
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/apue/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>apue</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Dec 16, 2020</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p>实际项目中多线程用得比较多，因为多线程是先有标准后有实现的，所以不会向多进程那样在不同平台上有许多不同的情况。</p>
</blockquote>
<ol>
<li>线程的概念</li>
<li>线程的创建、线程终止、 线程的取消、线程的清理</li>
<li>线程的同步（互斥量， 通知法，读写锁）</li>
<li>线程相关的属性 （线程同步属性）</li>
<li>重入，线程和信号的关系， 线程与fork</li>
</ol>
<h2 id="1-1-线程概念"><a href="#1-1-线程概念" class="headerlink" title="1.1 线程概念"></a>1.1 线程概念</h2><ol>
<li>线程就是一个正在运行函数</li>
<li>一个进程空间最少要有一个线程，一个进程里面最少有一个函数在运行。</li>
<li>线程没有主次之分，不分前后的，即使线程自己创建出来的线程反过来把自己取消或者收尸都是可以的。main函数产生的main进程并不是主线程</li>
<li>线程之间独立运行，而不是调用与被调用的关系。多个线程的内存是共享的。所以线程间通信依赖全局变量</li>
<li>线程是先有标准，然后才有标准实现的</li>
<li>一个新的库被开发出来，默认是需要支持多线程的，如果不能支持需要在函数的调用以及函数名上做说明。很多函数都是支持多线程的，比如getchar putchar等</li>
</ol>
<h3 id="1-1-1-线程有不同的标准"><a href="#1-1-1-线程有不同的标准" class="headerlink" title="1.1.1 线程有不同的标准"></a>1.1.1 线程有不同的标准</h3><blockquote>
<p>线程标准只是一套标准，而不是实现</p>
</blockquote>
<ul>
<li>POSIX标准<br>C 语言线程有很多标准，POSIX 是其中的一种。POSIX 是一套标准，而不是一种实现。</li>
<li>openmp标准<br>openmp是另外一种线程标准。约定了另外并发的方式，可以产生多线程的并发。它并发的方式不是从语言的角度了。</li>
</ul>
<h3 id="1-1-2-线程的标识"><a href="#1-1-2-线程的标识" class="headerlink" title="1.1.2 线程的标识"></a>1.1.2 线程的标识</h3><p><code>pthread_t (p 表示 POSIX, thread 线程)·</code></p>
<blockquote>
<p>pthread_t类型 是 POSIX 下的线程标识， pthread_t是什么类型，不清楚，正因为 POSIX 是一套标准而不是实现，所以 POSIX 只是规定了 pthread_t 作为线程标识符，但是并没有规定它必须是由什么类型组成的，所以在有的平台上它可能是 int，有些平台上它可能是 struct，还有些平台上它可能是 union，所以不要直接操作这个类型，而是要使用 POSIX 规定的各种线程函数来操作它。</p>
</blockquote>
<p>有木有觉得像标准 IO 里 FILE 的赶脚？没错，标准制定出来的很多东西都是这种风格的，它为你提供一个数据类型而不让你直接对这个类型操作，要通过它定义的一系列函数来实现对这个类型的操作，这样就在各个平台上实现统一的接口了，所以这样做才能让标准制定出来的东西具有较好的可移植性。</p>
<p>pthread_t 是个很重要的东西，我们所有使用 PSOIX 标准的线程操作都是围绕着它来进行的，通过它配合各种函数就可以对线程进行各种花样作死的玩了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ps ax -L <span class="comment"># 以linux方式查看进程</span></span><br><span class="line">PID   LWP TTY      STAT   TIME COMMAND</span><br><span class="line"> 1     1   ?        Ss     0:02 /sbin/init</span><br><span class="line"> 2     2   ?        S      0:00 [kthreadd]</span><br><span class="line"> 3     3   ?        S      0:00 [ksoftirqd/0]</span><br><span class="line"> 877   877 ?        Ss     0:06 dbus-daemon --system --fork</span><br><span class="line"> 948   948 ?        Ssl    0:00 /usr/sbin/ModemManager</span><br><span class="line"> 948   965 ?        Ssl    0:00 /usr/sbin/ModemManager</span><br><span class="line"> 948   975 ?        Ssl    0:00 /usr/sbin/ModemManager</span><br><span class="line"> 956   956 ?        Ss     0:00 /usr/sbin/bluetoothd</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>PID 是进程号。 LWP虚拟进程ID，即线程 ID。</p>
<p>在linux环境下，其实是以线程来消耗当前进程号的。当前所看到的线程号其实就是用进程标识来进行描述的。 尽管如此 依然不能 <code>printf(&quot;%d&quot;, pthread_t)</code>, 因为其他线程标准下的 pthread_t 并不一定是 int类型。</p>
<p>这里看到的 PID 为 948 的进程有三个 LWP，它们就是三个线程。</p>
<h3 id="1-1-3-多线程相比信号要简单不少"><a href="#1-1-3-多线程相比信号要简单不少" class="headerlink" title="1.1.3 多线程相比信号要简单不少"></a>1.1.3 多线程相比信号要简单不少</h3><blockquote>
<p>多线程太规范了，信号处理函数应该越短越好。里面不能用IO，不能用不可重入的函数。只能安全的在里面做一些计算和系统调用。其他都慎用。线程不存在这样的问题。线程里面可以io，也可以使用可重用和不可重用的函数。要做到线程的安全比做到信号的安全 条件要松散一些。具体原因还是 多线程是先有标准 后有实现。更像亲儿子。同样是解决异步的两种方式，多线程和信号。至少要对其中一种方式掌握的很熟练。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; vim makefile</span><br><span class="line"></span><br><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br></pre></td></tr></table></figure>

<ol>
<li>pthread_equal(3)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_equal - compare thread IDs</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>

<p>第一个要介绍的函数是 pthread_equal(3)，比较两个线程标识符是否相同。为什么不能使用 if (t1 == t2) 的方式比较两个线程标识符呢？就像我们上面说的，因为你不知道 pthread_t 是什么类型的，所以永远不要自己直接操作它。</p>
<ol start="2">
<li>pthread_self(3)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_self - obtain ID of the calling thread</span></span><br><span class="line"><span class="comment">// 当前线程的ID</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>

<p>大家还记得一个进程可以通过 getpid(2) 函数获得当前进程的 ID 号吧？pthread_self(3) 就是获得当前线程 ID 的函数。</p>
<h2 id="1-2-线程操作"><a href="#1-2-线程操作" class="headerlink" title="1.2 线程操作"></a>1.2 线程操作</h2><h3 id="1-2-1-线程的创建"><a href="#1-2-1-线程的创建" class="headerlink" title="1.2.1 线程的创建"></a>1.2.1 线程的创建</h3><p><code>pthread_create(3)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_create - create a new thread</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>

<p>pthread_create(3) 函数的作用就是创建一个新线程。</p>
<p>参数列表：</p>
<p>　　thread：由函数回填的线程标识符，它来唯一的标识产生的新线程，后面我们只要需要操作新线程就需要用到它；</p>
<p>　　attr：线程属性，在本篇博文（第 11 章）中，所有的属性都是使用 NULL，也就是使用默认属性。</p>
<p>　　start_routine：线程的执行函数；入参是 void<em>，返回值是 void</em>，恭喜你，这两个值的类型都是百搭的，任何类型你都可以在这使用了。</p>
<p>　　arg：传递给 start_routine 的 void* 参数。</p>
<p>返回值：成功返回 0；失败返回 errno。<br>为什么线程函数返回的是 errno 呢？因为在一些平台上 error 是全局变量，如果大家都使用同一个全局变量，在多线程的情况下就可能会出现竞争，所以 POSIX 的线程函数一般在失败的时候都是直接返回 errno 的，这样就避免了某些平台 errno 的缺陷了。</p>
<p>新线程和当前的线程是两个兄弟线程，他们是平等的，没有父子关系。</p>
<p>新线程被创建之后，这两个线程哪个先执行是不确定的，由调度器来决定。如果你希望哪个线程一定先执行，那么就在其它线程中使用类似 sleep(3) 的函数让它们等一会儿再运行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    error = pthread_create(&amp;tid, <span class="literal">NULL</span>,func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(error));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Begin!</span></span><br><span class="line"><span class="comment">// End!</span></span><br></pre></td></tr></table></figure>

<p><strong>为何没有打印 “Thread is working!”</strong></p>
<blockquote>
<p>线程的调度取决于调度器的策略,这个现象也不难理解，因为在虚拟机的环境上，没办法去模拟一个多核并发的内容。因为虚拟机本身在宿主机上跑的，一定是在一个核上运行。所以单个核上无法虚拟出多个核。</p>
</blockquote>
<p>回过头看代码，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    error = pthread_create(&amp;tid, <span class="literal">NULL</span>,func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(error));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 在创建的 func线程，还没来得及没调度的时候，就执行了exit(0) 结束掉了进程。在进程的任意位置 执行 exit 函数 都表示当前进程的结束。 所以没有机会打印出 Thread is working! 这句话了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个多核机器上，理论是可以打印出 “new pthread working!” 的，有时存在 begin 和 end之间，有时存在 end之后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macos</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Begin!</span></span><br><span class="line"><span class="comment"># end!</span></span><br><span class="line"><span class="comment"># new pthread working!</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-线程的终止"><a href="#1-2-2-线程的终止" class="headerlink" title="1.2.2 线程的终止"></a>1.2.2 线程的终止</h3><blockquote>
<p>线程的终止有三种方式</p>
</blockquote>
<ol>
<li>线程从启动例程返回，返回值就是线程的退出码</li>
<li>线程可以被同一进程中的其他线程取消（异常终止的一种方式）</li>
<li>线程调用 pthread_exit() 函数，</li>
</ol>
<p><code>pthread_exit(3)</code></p>
<blockquote>
<p>这个函数相当于进程阶段的 exit 函数，它表示结束当前正在跑的线程（函数），当然如果你 用 pthread_exit 调用的线程是当前进程的最后一个正在跑的线程，那么进程也会被结束。<br>最后一个线程从启动例程里面返回，也会导致进程结束。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_exit - terminate calling thread</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>


<p>在线程执行函数中调用，作用是退出当前线程，并将返回值通过 retval 参数返回给调用 pthread_join(3) 函数的地方，如果不需要返回值可以传入 NULL。</p>
<p>pthread_join(3) 是为线程收尸的函数，我们会在下面详细介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第二个参数不传，指的是 只收尸，不关心状态</span></span><br><span class="line"><span class="comment">// Compile and link with -pthread</span></span><br></pre></td></tr></table></figure>

<p>为线程收尸，在上面的栗子中大家已经见到了。不像 wait(2) 函数，线程之间谁都可以为别人收尸，它们之间是没有父子关系的。而 wait(2) 函数只能是由父进程对子进程收尸。</p>
<p>参数列表：</p>
<p>　　thread：指定为哪个线程收尸；</p>
<p>　　retval：这个二级指针是什么呢？它就是线程在退出的时候的返回值（pthread_exit(3) 的参数），它会把线程的返回值的地址回填到这个参数中。</p>
<p>我们先来看个小栗子，直观的了解下线程是如何被创建的，以及它是如何工作的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working."</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">// 延时是为了方便我们使用 ps(1) 命令验证线程是否被创建了</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//    return NULL;  return 指的是一个函数的结束。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程</span></span><br><span class="line">    err = pthread_create(&amp;tid,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为线程收尸</span></span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>); <span class="comment">// 这个等的动作相当于是等待创建完的线程执行完。所以最终控制台输出的结果，无论是单核还是双核，‘Thread is working.’都会在 ends 输出之前 输出出来。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 编译并运行，同时使用 LZ 上面介绍过的 ps(1) 命令验证线程是否被创建成功了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./create</span><br><span class="line">Begin!</span><br><span class="line">Thread is working.</span><br><span class="line">End!</span><br><span class="line">$</span><br><span class="line"><span class="comment"># 在线程结束之前打开另一个终端，验证线程的状态</span></span><br><span class="line">$ ps ax -L</span><br><span class="line">  PID   LWP TTY      STAT   TIME COMMAND</span><br><span class="line"> 4354  4354 pts/1    Sl+    0:00 ./create</span><br><span class="line"> 4354  4355 pts/1    Sl+    0:00 ./create</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<p>通过 ps(1) 命令的验证，可以看到这两个线程拥有同一个 PID 不同的 LWP，所以可以直观的看出来我们的线程创建成功了！</p>
<p>大家注意，编译 POSIX 线程程序的时候需要使用 -pthread 参数，这个其实在 man 手册里已经说得很清楚了.</p>
<h3 id="1-2-3-线程的清理"><a href="#1-2-3-线程的清理" class="headerlink" title="1.2.3 线程的清理"></a>1.2.3 线程的清理</h3><p><code>pthread_cleanup_push()</code><br><code>pthread_cheanup_pop()</code></p>
<p>7.线程清理处理程序（thread cleanup handler）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>

<p>就像在进程级别使用 atexit(3) 函数挂钩子函数一样，线程可能也需要在结束时执行一些清理工作，这时候就需要派出线程清理处理程序上场了。钩子函数的调用顺序也是逆序的，也就是执行顺序与注册顺序相反。</p>
<p>这两个是带参的宏而不是函数，所以必须成对使用，而且必须先使用 pthread_cleanup_push 再使用  pthread_cleanup_pop，否则会报语法错误，括号不匹配。</p>
<p>参数列表：</p>
<p>　　routine：钩子函数。</p>
<p>　　arg：传递给钩子函数的参数。</p>
<p>　　execute：0 不调用该钩子函数；1 调用该钩子函数。</p>
<p>pthread_cleanup_pop 写到哪都行，只要写了让语法不报错就行，就算你把它写到 pthread_exit(3) 下面也没问题，但是 execute 参数就看不到了，所以无论 pthread_cleanup_pop 的参数是什么，所有注册过的钩子函数都会被执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">routine</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun</span> <span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_cleanup_push(routine, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//这里是其它代码</span></span><br><span class="line">  pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预编译，查看宏替换的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E cleanup.c <span class="comment"># 预处理， 解决所有 #开发的语句</span></span><br><span class="line"></span><br><span class="line">void routine (void *p) &#123;&#125;</span><br><span class="line">void* fun (void *p)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123; __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (((void *)0)); int not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *) __cancel_buf.__cancel_jmp_buf, 0); <span class="keyword">if</span> (__builtin_expect (not_first_call, 0)) &#123; __cancel_routine (__cancel_arg); __pthread_unwind_next (&amp;__cancel_buf); &#125; __pthread_register_cancel (&amp;__cancel_buf); <span class="keyword">do</span> &#123;;</span><br><span class="line"> // 这里是其它代码</span><br><span class="line"> <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (0); &#125; <span class="keyword">while</span> (0); __pthread_unregister_cancel (&amp;__cancel_buf); <span class="keyword">if</span> (1) __cancel_routine (__cancel_arg); &#125; <span class="keyword">while</span> (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过预编译可以看出来 pthread_cleanup_push 和 pthread_cleanup_pop 两个宏被替换了，并且每个宏仅定义了一半，如果不成对写另一个宏编译的时候就会报括号不匹配的错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:1"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:2"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"push over!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // pthread_cleanup_pop 和 pthread_cleanup_push 需要成双成对出现， 有多少个push 就的有多少个pop</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">// 参数  1表示调用，0表示只弹栈 不调用</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">// 栈方法，后进先出</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"begin"</span>);</span><br><span class="line"></span><br><span class="line">  err =  pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">Thread is working</span><br><span class="line">push over!</span><br><span class="line">cleanup:3</span><br><span class="line">cleanup:2</span><br><span class="line">cleanup:1</span><br><span class="line">End!</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-线程取消"><a href="#1-2-4-线程取消" class="headerlink" title="1.2.4 线程取消"></a>1.2.4 线程取消</h3><blockquote>
<p>linux 一共有8种终止进程的方式，其中5种正常终止和3种异常终止。 其中‘最后一个线程对取消请求作出响应；’ 是三种异常中止方式中的一种</p>
</blockquote>
<p><code>pthread_cancel(3)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cancel - send a cancellation request to a thread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>

<p><code>setcanceltype</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>; <span class="comment">// 设置是否允许取消</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>;<span class="comment">// 设置取消方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 本函数什么都不做，就是一个取消点</span></span><br></pre></td></tr></table></figure>



<p><strong>取消有两种状态： 允许 和 不允许</strong></p>
<p>允许取消又分为  异步cancel 和 推迟 cancel(默认) -&gt; 推迟至cancel点再响应<br>cancel点： POSIX定义的cancel点，都是可能引发阻塞的系统调用；</p>
<p>pthread_cancel(3) 函数的作用是取消同一个进程中的其它线程线程。</p>
<p>为什么要取消线程呢？当一个线程没有必要继续执行下去时，我们又没法为它收尸，所以就需要先取消这个线程，然后再为它收尸。</p>
<p>比如在使用多线程遍历一个很大的二叉树查找一个数据时，其中某一个线程找到了要查找的数据，那么其它线程就没有必要继续执行了，所以就可以取消它们了。</p>
<p>注意 pthread_cancel(3) 并不等待线程终止，它仅仅提出请求。</p>
<p>而线程收到这个请求也不会立即终止，线程要执行到取消点才能被取消，关于取消点在下一篇博文中会介绍。</p>
<p><strong>线程分离</strong></p>
<p><code>pthread_detach(3)</code></p>
<blockquote>
<p>不想管它，扔到一边去，生死存亡各有天命</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_detach - detach a thread</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>

<p>pthread_detach(3) 函数用于分离线程，被分离的线程是不能被收尸的。</p>
<p><strong>primer</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, &amp;i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = *(<span class="keyword">int</span> *)p;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./primer</span><br><span class="line">30000023 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000049 is a primer</span><br><span class="line">30000071 is a primer</span><br><span class="line">30000059 is a primer</span><br><span class="line">30000079 is a primer</span><br><span class="line">30000133 is a primer</span><br><span class="line"><span class="comment"># 结果不对</span></span><br></pre></td></tr></table></figure>

<p>这种现象是因为线程发生了竞争；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单粗暴的更改</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i); <span class="comment">//主要处理这个 i 的问题，因为 prime0 程序里面这个 i 是地址传递</span></span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = (<span class="keyword">int</span>)p; <span class="comment">// 将p 强制 转换成int 类型</span></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">30000149 is a primer</span><br><span class="line">30000137 is a primer</span><br><span class="line">30000041 is a primer</span><br><span class="line">30000079 is a primer</span><br><span class="line">30000083 is a primer</span><br><span class="line">30000169 is a primer</span><br><span class="line">30000163 is a primer</span><br><span class="line">30000133 is a primer</span><br><span class="line">30000023 is a primer</span><br><span class="line">30000071 is a primer</span><br><span class="line">30000167 is a primer</span><br><span class="line">30000109 is a primer</span><br><span class="line">30000001 is a primer</span><br><span class="line">30000049 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000199 is a primer</span><br><span class="line">30000193 is a primer</span><br><span class="line">30000059 is a primer</span><br><span class="line"></span><br><span class="line">$ ./primer0 | wc -l</span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用更多的空间，优化策略是创建一个结构体数组用来存储</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i); <span class="comment">//主要处理这个 i 的问题，因为 prime0 程序里面这个 i 是地址传递</span></span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = (<span class="keyword">int</span>)p; <span class="comment">// 将p 强制 转换成int 类型</span></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建结构体用于接受</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"malloc()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;n = i;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime,p);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = ((struct thr_arg_st *)p) -&gt;n;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 及时回收，不然会造成内存泄露，且泄露200个结构体的空间</span></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然这个函数还有优化的空间，比如malloc 和 free 尽量放在一个函数当中</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将malloc 和free放在一个函数当中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT  30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">      <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 定义指针，接受线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"malloc()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;n = i;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime,p);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT], &amp;ptr);</span><br><span class="line">        <span class="built_in">free</span>(ptr); <span class="comment">// 收尸的同时调用 free ptr</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = ((struct thr_arg_st *)p) -&gt;n;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 目前的写法依然不科学，因为一个进程里面未必就能创建出来这么多的线程，那么如何测试一个进程能创建多少线程呢？</span></span><br></pre></td></tr></table></figure>

<p><strong>一个进程能创建多少线程</strong></p>
<blockquote>
<p>32位的机器，一个进程最多创建300个左右的线程</p>
</blockquote>
<p><code>thr_prime</code>这个函数，该函数实际被扔出去201次，201份同时跑。在资源的使用上，他们的代码段是公用的，它们的栈是独立的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">ulimit</span> -a</span><br><span class="line">stack size  10240  <span class="comment"># 栈大小是 10240 也就是10M</span></span><br></pre></td></tr></table></figure>

<p>c程序地址空间分布，32位环境上，c进程的虚拟空间是4GB，最高的一GB是给内核态使用的，用户态用的虚拟空间是不足3GB的。在这不足3GB的空间里面，代码段，静态区域，数据段，堆，栈都得预留出来。所以说，当前能创建多少个线程，也就要看在当前的进程空间里面能够创建多少个10MB大小的栈。所以能创建多少线程还是取决于资源量的</p>
<p>在64位的机器上，一个C程序的虚拟空间是128T。所以，是消耗不完的，纵使能消耗完，也是先消耗完<code>pid</code>号</p>
<h2 id="1-3-线程的同步"><a href="#1-3-线程的同步" class="headerlink" title="1.3 线程的同步"></a>1.3 线程的同步</h2><p>在介绍互斥量之前我们先思考一个问题：如何让 20 个线程同时从一个文件中读取数字，累加 1 然后再写入回去，并且保证程序运行之后文件中的数值比运行程序之前大 20？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">echo</span> 100 &gt; /tmp/out/  <span class="comment"># 往out文件里面写入一个 1个数</span></span><br><span class="line">cat /tmp/out</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20个线程，打开一个文件，读数 + 1，写回去。不要乱</span></span><br><span class="line"><span class="comment">// add.c,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(linebuf,LINESIZE,fp); <span class="comment">// 将读取的内容放进 linebuf中</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET); <span class="comment">// 文件位置指针 指回去</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>, atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，在虚拟机上是正确的，因为虚拟机是运行在一个核上面的。没办法做到并行<br>而在macos上发现，结果是不正确的。</p>
<h3 id="1-3-1-互斥量"><a href="#1-3-1-互斥量" class="headerlink" title="1.3.1 互斥量"></a>1.3.1 互斥量</h3><p><code>pthead_mutex_t</code></p>
<blockquote>
<p>限制一段代码以独占的形势在实现</p>
</blockquote>
<p>互斥量是一种机制</p>
<p>多线程就是为了充分利用硬件资源，使程序可以并发的运行，但是只要是并发就会遇到竞争的问题，互斥量就是解决竞争的多种手段之一。</p>
<p>程序中每一个线程都要做：读取文件 — 累加 1 — 写入文件 的动作，如果 20 个线程同时做这件事，那么就很有可能多个线程读到的数据是相同的，这样累加的结果也就是相同的了，就没办法保证 20 个线程每个人读到的数据都是独一无二的了。</p>
<p>怎么样才能让 20 个线程读到独一无二的数值呢？很简单，让 读取文件 — 累加 1 — 写入文件 的这个动作同一时刻只能有一个线程来做，这样每个线程读取到的数值都是上一个线程写入的数值了。那么 读取文件 — 累加 1 — 写入文件 这段代码（也就是发生竞争的这段区域）就叫做“临界区”。</p>
<p>互斥量正如它的名字描述的一般，可以使各个线程实现互斥的效果。由它来保护临界区每次只能由一个线程进入，当一个线程想要进入临界区之前需要先抢锁（加锁），如果能抢到锁就进入临界区工作，并且要在离开的时候解锁以便让其它线程可以抢到锁进入临界区；如果没有抢到锁则进入阻塞状态等待锁被释放然后再抢锁。</p>
<p>要在进入临界区之前加锁，在退出临界区的时候解锁。</p>
<p>与 ptread_t 一样，互斥量也使用一种数据类型来表示，它使用 pthread_mutex_t 类型来表示。</p>
<p>初始化互斥量有两种方式：</p>
<p>1）用宏初始化：如同使用默认属性；</p>
<p>2）使用 pthread_mutex_init(3) 函数初始化，可以为互斥量指定属性。</p>
<p>pthread_mutex_t 使用完成之后需要使用 pthread_mutex_destroy(3) 函数销毁，否则会导致内存泄漏。</p>
<p>一般什么情况使用宏初始化，什么情况使用函数初始化互斥量呢？请看下面的伪代码：</p>
<p>前面说了，要在进入临界区之前加锁，在退出临界区的时候解锁。我们来了解一下加锁和解锁的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> pthread_mutexattr * <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_destroy();</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock -  lock and unlock a mutex</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 尝试等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>_lock() 是阻塞加锁，当抢锁的时候被抢不到就死等，直到别人通过 _unlock() 把这把锁解锁再抢。</p>
<p>_trylock() 是尝试加锁，无论能否抢到锁都返回。</p>
<p>临界区是每个线程要单独执行的，所以临界区中的代码执行时间越短越好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add1.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"./p"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut);  <span class="comment">// 上锁</span></span><br><span class="line">    fgets(linebuf,LINESIZE,fp); <span class="comment">// 将读取的内容放进 linebuf中</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET); <span class="comment">// 文件位置指针 指回去</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>, atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    pthread_mutex_unlock(&amp;mut); <span class="comment">// 开锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证临界区代码每次只有一个线程在运行</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁解锁针对的是一段代码，而不是一个变量</p>
<p>了解了互斥量之后，我们再来看一道经典的面试题：用 4 个线程疯狂的打印 abcd 持续 5 秒钟，但是要按照顺序打印，不能是乱序的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abcd.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">'a'</span> + (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./abcd</span><br><span class="line">aaaaaaaa...</span><br><span class="line"><span class="comment">#  结果不对，连续打了满篇的a，然后b 然后c 然后d</span></span><br></pre></td></tr></table></figure>

<p>解决思路： 锁链，打印a的线程去解锁打印b的线程，b打印完解锁c，c打印完解锁d，d打印完解锁a；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a+<span class="number">1</span> == THRNUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">int</span> ch = n + <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mut+n);</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,&amp;ch,<span class="number">1</span>);</span><br><span class="line">        pthread_mutex_unlock(mut+next(n));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; THRNUM ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mut+i,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_lock(mut+i);</span><br><span class="line">        err = pthread_create(tid+i,<span class="literal">NULL</span>,thr_func,(<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(mut+<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; THRNUM ; i++)</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdabcdabcdabcdabcdabcd...</span><br></pre></td></tr></table></figure>

<p>上面这段代码是通过多个互斥量实现了一个锁链的结构巧妙的实现了要求的效果。</p>
<p>首先定义 4 个互斥量，然后创建 4 个线程，每个互斥量对应一个线程，每个线程负责打印一个字母。4 个线程刚刚被创建好时，4 把锁都处于锁定状态，4 个线程全部都阻塞在临界区之外，等 4 个线程全部都创建好之后解锁其中一把锁。被解锁的线程首先将自己的互斥量上锁，然后打印字符再解锁下一个线程对应的互斥量，然后再次等待自己被解锁。如此往复，使 4 个线程有条不紊的循环执行 锁定自己 — 打印字符 – 解锁下一个线程 的步骤，这样打印到控制台上的 abcd 就是有序的了。</p>
<p>从上面的栗子可以看出来：互斥量限制的是一段代码能否执行，而不是一个变量或一个资源。</p>
<p>上面的代码虽然使用锁链巧妙的完成了任务，但是它的实现方式并不是最漂亮的，更好的办法我们下面介绍条件变量（pthread_cond_t）的时候会讨论。</p>
<h4 id="1-3-1-1线程池"><a href="#1-3-1-1线程池" class="headerlink" title="1.3.1.1线程池"></a>1.3.1.1线程池</h4><p>在primer程序中，201个数字 用 201个线程去处理。<br>现在变幻一下思路，用201个数字对应 N个线程。（N可以是3/4/甚至更多）只要保证当前进程空间可以创建出来这么多线程即可</p>
<p>分块法/交叉分配/池类写法</p>
<h4 id="1-3-1-2-池类写法"><a href="#1-3-1-2-池类写法" class="headerlink" title="1.3.1.2 池类写法"></a>1.3.1.2 池类写法</h4><blockquote>
<p>非标准线程池写法，标准的进程池/线程池。 这个池并非标准线程池的写法。这里是任务池。</p>
</blockquote>
<p><img src="./xianchengchi.png" alt=""></p>
<p>简单描述一下， 就是main发牌到牌桌，线程池到牌桌抢牌，抢到之后，给num 写成0. main获取到num为0 之后，再次发牌。顺便把num写成一个非0的值。当main把最后一张牌扔下来，然后确定被某一个线程抢走之后。那main就负责把这一块写成 -1.这个 -1 提醒下游线程退出。上游线程等着收尸。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line"><span class="comment">//-------------------上游------------------ 期待num！=0</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="comment">// sleep(1); sleep会让当前进程进入 沉睡状态 用下面sched_yield</span></span><br><span class="line">            sched_yield();   <span class="comment">// sched 开头的全部是针对于调度器来操作的，sched_yield的作用是出让调度器给其他的线程，</span></span><br><span class="line">            <span class="comment">// 可以理解为一个非常短的sleep，不会引起当前进程的调度颠簸</span></span><br><span class="line">            <span class="comment">// 这里调用该函数是希望其他线程能拿到 num的值， 并有机会改写num的值</span></span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line">        num = i;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num!= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>; <span class="comment">// 当main发放 最后一张牌的时候，并不能直接置成 -1. 所以需要上面</span></span><br><span class="line">    <span class="comment">// 的sched_yield 出让出去，让其他线程抢到；</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>); <span class="comment">// 给线程收尸</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line"><span class="comment">//--------------------下游------------------------------期待变成非 0</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 临界区内的任何一个跳转语句，这个跳转如果是跳转到临界区以外的。一定不要忘了解锁再</span></span><br><span class="line">            <span class="comment">// 跳转。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何写多并发程序不会造成死锁。</span></span><br><span class="line"></span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]%d is a primer\n"</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[3]30000023 is a primer</span><br><span class="line">[1]30000037 is a primer</span><br><span class="line">[0]30000041 is a primer</span><br><span class="line">[2]30000001 is a primer</span><br><span class="line">[1]30000059 is a primer</span><br><span class="line">[3]30000049 is a primer</span><br><span class="line">[2]30000079 is a primer</span><br><span class="line">[0]30000071 is a primer</span><br><span class="line">[1]30000083 is a primer</span><br><span class="line">[3]30000109 is a primer</span><br><span class="line">[2]30000133 is a primer</span><br><span class="line">[0]30000137 is a primer</span><br><span class="line">[1]30000149 is a primer</span><br><span class="line">[3]30000163 is a primer</span><br><span class="line">[2]30000167 is a primer</span><br><span class="line">[0]30000169 is a primer</span><br><span class="line">[1]30000193 is a primer</span><br><span class="line">[3]30000199 is a primer</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<blockquote>
<p>细心会发现，在运行程序时，会有一些卡顿。而且cpu使用率一下上去了。该程序其实还是一个盲等的版本。 上下游都在等待。（代码中查看上下游位置）。<br>现在某一个任务已经被下游线程取走了，上游的main总是抢不到锁，一直阻塞在lock。下游的线程总是在被调度，不停的lock，发现是0 然后解锁， 因为下游线程较多。上游是一个人在抢，下游是4个人在抢。因此抢到的几率是不同的<br>所以该程序是个盲等版，盲在不停的在查看状态。确保这个状态是自己要的那个状态。可以尝试优化成通知法。上游等待num变成0，有人通知自己。就把新任务放进去。而下游等上游把任务放进去之后发一个通知或者消息，下游叫醒任何一个线程来计算这个任务。</p>
</blockquote>
<p>大家还记得我们在上一篇博文中提到过令牌桶吗？当时只是实现了一个简单的令牌桶，这次我们来写一个通用的多线程并发版的令牌桶。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mytbf.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTBF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_MAX  1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">mytbf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps,<span class="keyword">int</span> burst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *,<span class="keyword">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mytbf.c  原博客 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个令牌桶 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> cps; <span class="comment">// 速率</span></span><br><span class="line">  <span class="keyword">int</span> burst; <span class="comment">// 令牌上限</span></span><br><span class="line">  <span class="keyword">int</span> token; <span class="comment">// 可用令牌数量</span></span><br><span class="line">  <span class="keyword">int</span> pos; <span class="comment">// 当前令牌桶在 job 数组中的下标</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> mut; <span class="comment">// 用来保护令牌竞争的互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有的令牌桶 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="comment">/* 用来保护令牌桶数组竞争的互斥量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">/* 添加令牌的线程 ID */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="comment">/* 初始化添加令牌的线程 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程处理函数：负责定时向令牌桶中添加令牌 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_alrm</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">      <span class="comment">// 遍历所有的桶</span></span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; MYTBF_MAX; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 为可用的桶添加令牌</span></span><br><span class="line">          <span class="keyword">if</span>(job[i] != <span class="literal">NULL</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">              job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">              <span class="comment">// 桶中可用的令牌不能超过上限</span></span><br><span class="line">              <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                  job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">              pthread_mutex_unlock(&amp;job[i]-&gt;mut);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 等待一秒钟后继续添加令牌</span></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  pthread_cancel(tid);</span><br><span class="line">  pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; MYTBF_MAX ; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(job[i] != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 互斥量使用完毕不要忘记释放资源</span></span><br><span class="line">          pthread_mutex_destroy(&amp;job[i]-&gt;mut);</span><br><span class="line">          <span class="built_in">free</span>(job[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  </span><br><span class="line">  err = pthread_create(&amp;tid,<span class="literal">NULL</span>,thr_alrm,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 为了不破坏调用者对令牌桶操作的原子性，</span></span><br><span class="line"><span class="comment">* 在该函数内加锁可能会导致死锁，</span></span><br><span class="line"><span class="comment">* 所以该函数内部无法加锁，</span></span><br><span class="line"><span class="comment">* 必须在调用该函数之前先加锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_free_pos_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; MYTBF_MAX; i++)</span><br><span class="line">      <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps,<span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">  pthread_once(&amp;init_once,module_load);</span><br><span class="line"></span><br><span class="line">  me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">  <span class="keyword">if</span>(me == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  me-&gt;cps = cps;</span><br><span class="line">  me-&gt;burst = burst;</span><br><span class="line">  me-&gt;token = <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_init(&amp;me-&gt;mut,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">  </span><br><span class="line">  pos = get_free_pos_unlocked();</span><br><span class="line">  <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 带锁跳转不要忘记先解锁再跳转</span></span><br><span class="line">      pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">      <span class="built_in">free</span>(me);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">  job[pos] = me;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">  <span class="comment">// 令牌数量不足，等待令牌被添加进来</span></span><br><span class="line">  <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 先解锁，出让调度器让别人先跑起来，然后再抢锁检查令牌是否够用</span></span><br><span class="line">      pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">      sched_yield();</span><br><span class="line">      pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n = <span class="built_in">min</span>(me-&gt;token,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">  me-&gt;token -= n;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令牌用不完要归还哟，可不能浪费了 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逗我玩呢？</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">  me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">  <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">      me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">  job[me-&gt;pos] = <span class="literal">NULL</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// me  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span>* <span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> tid_alrm;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> inited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;</span><br><span class="line">    <span class="keyword">int</span> burst;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mut;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    pthread_cancel(tid_alrm);</span><br><span class="line">    pthread_join(tid_alrm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mytbf_destroy(job[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">get_free_pos_unloaded</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_alrm</span><span class="params">(<span class="keyword">void</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(job[i]!= <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">                job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">                <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                    job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">                pthread_mutex_unlock(&amp;job[i]-&gt;mut);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = pthread_create(&amp;tid_alrm, <span class="literal">NULL</span>, thr_alrm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(!inited)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//      module_load();</span></span><br><span class="line">    <span class="comment">//      inited = 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 用 pthread_once 代替上面语句</span></span><br><span class="line">    pthread_once(&amp;init_once, module_load);</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    pos = get_free_pos_unloaded();  <span class="comment">// 在数组中 找空位</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me; <span class="comment">//将该结构体存储至 数组中</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut); <span class="comment">// 盲在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)   <span class="comment">// 这里一秒钟 循环数次</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> * ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    job[me -&gt; pos] = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序依然是盲等法，</p>
<p>上面这个令牌桶库可以支持最多 1024 个桶，也就是可以使用多线程同时操作这 1024 个桶来获得不同的速率，每个桶的速率是固定的。</p>
<p>这 1024 个桶保存在一个数组中，所以每次访问桶的时候都需要对它进行加锁，避免多个线程同时访问发生竞争。</p>
<p>同样每个桶也允许使用多个线程同时访问，所以每个桶中也需要一个互斥量来保障处理令牌的时候不会发生竞争。</p>
<p>写互斥量的代码一定要注意临界区内的所有的跳转，通常在跳转之前需要解锁，避免产生死锁。常见的跳转包括 continue; break; return; goto; longjmp(3); 等等，甚至函数调用也是一种跳转。</p>
<p>当某个函数内包含临界区，也就是需要加锁再进入临界区，但是从程序的布局来看该函数无法加锁，那么根据 POSIX 标准的约定，这种函数的命名规则是必须以 _unlocked 作为后缀，所以大家在看到这样的函数时在调用之前一定要先加锁。总结起来说就是以这个后缀命名的函数表示函数内需要加锁但是没有加锁，所以调用者需要先加锁再调用，例如上面代码中的 get_free_pos_unlocked() 函数。</p>
<p>LZ 来解释一下上面这个令牌桶中用过的几个没见过的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sched_yield — yield the processor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sched_yield(2) 这个函数的作用是出让调度器。在用户态无法模拟它的实现，它会让出当前线程所占用的调度器给其它线程使用，而不必等待时间片耗尽才切换调度器，大家暂时可以把它理解成一个很短暂的 sleep(3) 。一般用于在使用一个资源时需要同时获得多把锁但是却没法一次性获得全部的锁的场景下，只要有任何一把锁没有抢到，那么就立即释放已抢到的锁，并让出自己的调度器让其它线程有机会获得被自己释放的锁。当再次调度到自己时再重新抢锁，直到能一次性抢到所有的锁时再进入临界区，这样就避免了出现死锁的情况。</p>
<p><strong>动态模块的单次初始化函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_once - dynamic package initialization</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure>


<p>pthread_once(3) 函数一般用于动态单次初始化，它能保证 init_routine 函数仅被调用一次。</p>
<p>pthread_once_t 只能使用 PTHREAD_ONCE_INIT 宏初始化，没有提供其它初始化方式。这个与我们前面见到的初始化 pthread_t 和 pthread_nutex_t 不一样。</p>
<p>上面的代码中，向令牌桶添加令牌的线程只需要启动一次，而初始化令牌桶的函数却在开启每个令牌桶的时候都需要调用。为了在初始化令牌桶的函数中仅启动一次添加令牌的线程，采用 pthread_once(3) 函数来创建线程就可以了。这样之后在第一次调用 mytbf_init() 函数的时候会启动新线程添加令牌，而后续再调用 mytbf_init() 的时候就不会启动添加令牌的线程了。</p>
<p>上面代码中调用 pthread_once(3) 相当于下面的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span> (init_flag)</span><br><span class="line">&#123;</span><br><span class="line">    init_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span>;</span><br><span class="line">pthread_mutex_init();</span><br><span class="line">pthread_mutex_destroy();</span><br><span class="line">pthread_mutex_lock();</span><br><span class="line">pthread_mutex_trylock();</span><br><span class="line">pthread_mutex_unlock();</span><br><span class="line">pthread_once();</span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-通知法"><a href="#1-3-2-通知法" class="headerlink" title="1.3.2 通知法"></a>1.3.2 通知法</h3><blockquote>
<p>上面的几种方法是盲等法，下面介绍通知法。</p>
</blockquote>
<p>条件变量（pthread_cond_t）（通知法的一种机制）</p>
<p>上面的程序经过测试，发现 CPU 正在满负荷工作，说明程序中出现了忙等， 是哪里出现了忙等呢？其实就是 mytbf_fetchtoken() 函数获得锁的时候采用了忙等的方式。前面我们提到过，异步程序有两种处理方式，一种是通知法，一种是查询法，我们这里用的就是查询法，下面我们把它修改成个通知法来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个令牌桶 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;             <span class="comment">// 速率</span></span><br><span class="line">    <span class="keyword">int</span> burst;           <span class="comment">// 令牌上限</span></span><br><span class="line">    <span class="keyword">int</span> token;           <span class="comment">// 可用令牌数量</span></span><br><span class="line">    <span class="keyword">int</span> pos;             <span class="comment">// 当前令牌桶在 job 数组中的下标</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mut; <span class="comment">// 用来保护令牌竞争的互斥量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 用于在令牌互斥量状态改变时发送通知</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有的令牌桶 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="comment">/* 用来保护令牌桶数组竞争的互斥量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">/* 添加令牌的线程 ID */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="comment">/* 初始化添加令牌的线程 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程处理函数：负责定时向令牌桶中添加令牌 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_alrm</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">        <span class="comment">// 遍历所有的桶</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MYTBF_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 为可用的桶添加令牌</span></span><br><span class="line">            <span class="keyword">if</span> (job[i] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">                job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">                <span class="comment">// 桶中可用的令牌不能超过上限</span></span><br><span class="line">                <span class="keyword">if</span> (job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                    job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">                <span class="comment">// 令牌添加完毕之后，通知所有等待使用令牌的线程准备抢锁</span></span><br><span class="line">                <span class="comment">// 因为 pthread_cond_sigal 只能唤醒一个等待，假如当前有10个令牌桶都在等待取token</span></span><br><span class="line">                pthread_cond_broadcast(&amp;job[i]-&gt;cond);</span><br><span class="line">                pthread_mutex_unlock(&amp;job[i]-&gt;mut);</span><br><span class="line">                <span class="comment">// 先broadcast/sigal 还是 先 unlock 区别并不大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        <span class="comment">// 等待一秒钟后继续添加令牌</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (job[i] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 互斥量和条件变量使用完之后不要忘记释放资源</span></span><br><span class="line">            pthread_mutex_destroy(&amp;job[i]-&gt;mut);</span><br><span class="line">            pthread_cond_destroy(&amp;job[i]-&gt;cond);</span><br><span class="line">            <span class="built_in">free</span>(job[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_alrm, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 为了不破坏调用者对令牌桶操作的原子性，</span></span><br><span class="line"><span class="comment">  * 在该函数内加锁可能会导致死锁，</span></span><br><span class="line"><span class="comment">  * 所以该函数内部无法加锁，</span></span><br><span class="line"><span class="comment">  * 必须在调用该函数之前先加锁。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_free_pos_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MYTBF_MAX; i++)</span><br><span class="line">        <span class="keyword">if</span> (job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    pthread_once(&amp;init_once, module_load);</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pos = get_free_pos_unlocked();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="comment">// 令牌数量不足，等待令牌被添加进来</span></span><br><span class="line">    <span class="keyword">while</span> (me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 原子化的解锁、出让调度器再抢锁以便工作或等待</span></span><br><span class="line"><span class="comment">          * 它会等待其它线程发送通知再唤醒</span></span><br><span class="line"><span class="comment">          * 放在循环中是因为可能同时有多个线程再使用同一个桶，</span></span><br><span class="line"><span class="comment">          * 被唤醒时未必就能拿得到令牌，所以要直到能拿到令牌再出去工作</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="comment">// 发现 me-&gt;token &lt;= 0</span></span><br><span class="line">        <span class="comment">// 就解锁等待，等到什么时候。等待 pthread_cond_broadcast/pthread_cond_signal</span></span><br><span class="line">        <span class="comment">// pthread_cond_broadcast是发通知/发消息，来打断一个wait，signal是打断任意一个wait。</span></span><br><span class="line"></span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond, &amp;me-&gt;mut); <span class="comment">// 解锁等待</span></span><br><span class="line">        <span class="comment">// pthread_cond_wait 相当于下面三句话的功能，但不是等价封装；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        pthread_mutex_unlock(&amp;me-&gt;mut);</span></span><br><span class="line">        <span class="comment">//        sched_yield();</span></span><br><span class="line">        <span class="comment">//        pthread_mutex_lock(&amp;me-&gt;mut);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令牌用不完要归还哟，可不能浪费了 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逗我玩呢？</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span> (me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 令牌归还完毕，通知其它正在等待令牌的线程赶紧起床，准备抢锁</span></span><br><span class="line"><span class="comment">      * 这两行谁在上面谁在后面都无所谓</span></span><br><span class="line"><span class="comment">      * 如果先发通知再解锁，收到通知的线程发现锁没有释放会等待锁释放再抢；</span></span><br><span class="line"><span class="comment">      * 如果先解锁再发通知，反正已经出了临界区了，</span></span><br><span class="line"><span class="comment">      * 就算有线程在通知发出之前抢到了锁也不会发生竞争，</span></span><br><span class="line"><span class="comment">      * 大不了其它被唤醒的线程起床之后发现没有锁可以抢，那就继续睡呗。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    job[me-&gt;pos] = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 大家不难看出这两段代码的差别，把查询法（忙等）修改为通知法（非忙等）仅仅加一个条件变量（pthread_cond_t） 就行了。</p>
<p>条件变量的作用是什么？其实就是让线程以无竞争的形式等待某个条件的发生，当条件发生时通知等待的线程醒来去做某件事。</p>
<p>通知进程醒来有两种方式，一种是仅通知一个线程醒来，如果有多个线程都在等待，那么不一定是哪个线程被唤醒；另一种方式是把所有等待同一个条件的线程都唤醒。</p>
<p>在下面我们会介绍这两种方式，先从条件变量的初始化和销毁开始讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cond_destroy, pthread_cond_init - destroy and initialize condition variables</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>


<p>与互斥量一样，条件变量也有两种方式初始化，一种是使用 pthread_cond_init(3) 函数，另一种是使用 PTHREAD_COND_INITIALIZER 宏。这两种方式的使用场景也与互斥量相同，这里就不再赘述了。</p>
<p>条件变量在使用完毕之后不要忘记用 pthread_cond_destroy(3) 函数释放资源，否则会导致内存泄漏！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cond_broadcast, pthread_cond_signal -  broadcast  or  signal  a condition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>


<p>这两个函数就是条件变量的关键操作了，大家注意看。</p>
<p>pthread_cond_signal(3) 函数用于唤醒当前多个等待的线程中的任何一个。虽然名字上有 signal，但是跟系统中的信号没有任何关系。</p>
<p>pthread_cond_broadcast(3) 惊群，将现在正在等待的线程全部唤醒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cond_timedwait, pthread_cond_wait - wait on a condition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这几个函数与上面的两个函数的作用是成对的，上面的两个函数用于唤醒线程，唤醒什么线程呢？当然是唤醒 _wait() 等待条件满足的线程啦。</p>
<p>当一个线程做某件事之前发现条件不满足，那就使用这几个 _wait() 函数进入等待状态，当某个线程使条件满足了就要用上面的两个函数唤醒等待的线程继续工作了。</p>
<p>pthread_cond_wait(3) 在临界区外阻塞等待某一个条件发生变化，直到有一个通知到来打断它的等待。这种方式是死等。</p>
<p>pthread_cond_timedwait(3) 增加了超时功能的等待，超时之后无论能否拿到锁都返回。这种方式是尝试等。</p>
<p>pthread_cond_wait(3) 相当于下面三行代码的原子操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(mutex);</span><br><span class="line">sched_yield();</span><br><span class="line">pthread_mutex_lock(mutex);</span><br></pre></td></tr></table></figure>


<p>通常等待会放在一个循环中，就像上面的令牌桶栗子一样，因为可能有多个线程都在等待条件满足，当前的线程被唤醒时不代表执行条件一定满足，可能先被唤醒的线程发现条件满足已经去工作了，等轮到当前线程调度的时候条件可能就又不满足了，所以如果条件不满足需要继续进入等待。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primer0_pool.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 期待num 变成一个任务，然后就能去抢任务了。</span></span><br><span class="line"><span class="comment"> * 忙等，忙在哪里？</span></span><br><span class="line"><span class="comment"> * 忙在上流和下流在不停的 抢num， 看状态。下流在抢num ，期待它不是 0.</span></span><br><span class="line"><span class="comment"> * 变为通知法，逻辑应该是</span></span><br><span class="line"><span class="comment"> * 下流一直处于等待状态，上流往num中放了一个任务之后。发一个通知，下流的几个都在wait。</span></span><br><span class="line"><span class="comment"> * 上流其实 发一个 signal就可以，因为下游的任务长的一样，叫醒任何一个让它拿num的值去计算即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span>  cond_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pthread_mutex_unlock(&amp;mut_num);</span></span><br><span class="line">            <span class="comment">// // sleep(1); sleep会让当前进程进入 沉睡状态 造成调度颠簸，用下面sched_yield</span></span><br><span class="line">            <span class="comment">// sched_yield();   // sched 开头的全部是针对于调度器来操作的，sched_yield的作用是出让调度器给其他的线程，</span></span><br><span class="line">            <span class="comment">// // 可以理解为一个非常短的sleep，但不会引起当前进程的调度颠簸</span></span><br><span class="line">            <span class="comment">// // 这里调用该函数是希望其他线程能拿到 num的值， 并有机会改写num的值</span></span><br><span class="line">            <span class="comment">// pthread_mutex_lock(&amp;mut_num);</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num); <span class="comment">// 解锁在临界区外的等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        num = i;</span><br><span class="line">        pthread_cond_signal(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num!= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>; <span class="comment">// 当main发放 最后一张牌的时候，并不能直接置成 -1. 须先调用sched_yield 出让出去，让其他线程抢到；</span></span><br><span class="line">    pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>); <span class="comment">// 给线程收尸</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num); <span class="comment">// 销毁互斥量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond_num); <span class="comment">// 销毁条件变量</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pthread_mutex_unlock(&amp;mut_num);</span></span><br><span class="line">            <span class="comment">// sched_yield();</span></span><br><span class="line">            <span class="comment">// pthread_mutex_lock(&amp;mut_num);</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 临界区内的任何一个跳转到临界区以外的break。跳转之前须解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]%d is a primer\n"</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>还记得我们上面提到的面试题吗？用锁链实现的疯狂的有序的打印 abcd 5 秒钟。</p>
<p>上面我们说了，锁链的办法并不是这道题的考点，这道题真正的考点其实是使用互斥量 + 条件变量的方式来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n+<span class="number">1</span> == THRNUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用条件变量将其变为通知法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">'a'</span> + n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut);</span><br><span class="line">        <span class="keyword">while</span>(num != n)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mut);</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        num = next(num);</span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-信号量"><a href="#1-3-3-信号量" class="headerlink" title="1.3.3 信号量"></a>1.3.3 信号量</h3><blockquote>
<p>14线程- 信号量 跳过， 有时间要回过头好好看一下</p>
</blockquote>
<h3 id="1-3-4-读写锁"><a href="#1-3-4-读写锁" class="headerlink" title="1.3.4 读写锁"></a>1.3.4 读写锁</h3><blockquote>
<p>互斥量和信号量的综合使用</p>
</blockquote>
<p>读写锁： 读锁-&gt; 共享锁    写锁 -&gt; 互斥锁</p>
<p>那么应该在什么场景中选择使用 pthread_cond_signal(3) 还是使用 pthread_cond_broadcast(3) 呢？</p>
<p>这个其实没有固定的套路，要根据具体的场景来选择。一般只有一个线程在等待或者明确知道哪个线程应该被唤醒的时候使用 _signal() 函数，如果有多个线程在等待并且不确定应该由谁起来工作的时候使用惊群。</p>
<p>LZ 说的不确定是指业务上不能确定哪个线程应该工作，而不是你作为程序猿稀里糊涂的不知道哪个线程该工作。程序猿应该保证了解你的每一行代码在做什么，而不要写出一坨自己都不知道它在做什么的代码。</p>
<p>至于应该先发通知再解锁还是先解锁再发通知，效果上没有太大的区别，这一点在上面令牌桶的栗子中已经阐述了。</p>
<p>11.下面纯属吐槽： </p>
<p>处理常规任务时，是采用多线程比较快还是采用多进程比较快？</p>
<p>如果只回答多线程比较快，那么你歇了。</p>
<p>应该回答常规情况下是多线程较快，因为多进程需要重新布置进程的执行空间，还需要进行数据拷贝以及部分配置，所以会比创建线程慢xx倍。不要只回答一个大方向就完事了，而是要量化你的答案，这样才能体现出来你在平时学习工作中很注重这些细节问题。</p>
<p>12.一个进程最多能创建多少个线程</p>
<p>一个进程能够创建多少个线程呢？主要受两个因素影响，一个是 PID 耗尽，一个是我们在之前的博文中画 C 程序地址空间布局时的阴影区域被栈空间占满了 。（不记得那副图了，去前面的博文里找找。）</p>
<p>PID 看上去是进程 ID，但是在之前讨论进程的博文中我们讨论过，内核的最小执行单元其实是线程，实际上是线程在消耗 PID。一个系统中的线程可以有很多，所以 PID 被耗尽也是有可能的。</p>
<p>使用 ulimit(1) 命令可以查看栈空间的大小，阴影区剩余空间的大小 / 栈空间的大小 == 就是我们能创建的线程数量。</p>
<p>大家可以自己写个程序测试一下一个进程最多能够创建多少个线程，然后使用 ulimit(1) 命令修改栈的大小再测试几次，看看能有什么发现。代码很简单，LZ 就不贴出来了。</p>
<p>13.管道的特点</p>
<p>1）管道的同义词是队列；</p>
<p>2）管道是单工的；</p>
<p>3）管道必须凑齐读写双方，如果只有一方，则阻塞等待。</p>
<p>关于管道的详细内容，我们在后面讨论进程间通信（IPC）的时候还会再详细讨论。</p>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2020/12/16/apue-7/>http://yoursite.com/2020/12/16/apue-7/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-04-28T18:54:37+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Apr 28, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/doc/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>doc</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2020/12/16/apue-7/&title=线程 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2020/12/16/apue-7/&title=线程 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2020/12/16/apue-7/&title=线程 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/12/16/apue-11/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>socket</p>
                <p class='content'>socket

如图所示，socket 可以理解为中间层。底层是若干不同的协议来完成协议族的指定，上层可以是不同的网络实现方式（流失传输，报式传输等等）。在不同的协议族当中对于这些不同的网络实现...</p>
              </a>
            
            
              <a class='next' href='/2020/12/09/test/'>
                <p class='title'>nginx<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>配置hexo到阿里云
网上大多数教程问题不大，额外需要注意修改一些文件的写入权限

1234567# 将post-receive 设置为可执行文件chmod +x ~/hexo.git/hook...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '线程',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-线程概念"><span class="toc-text">1.1 线程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-线程有不同的标准"><span class="toc-text">1.1.1 线程有不同的标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-线程的标识"><span class="toc-text">1.1.2 线程的标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-多线程相比信号要简单不少"><span class="toc-text">1.1.3 多线程相比信号要简单不少</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-线程操作"><span class="toc-text">1.2 线程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-线程的创建"><span class="toc-text">1.2.1 线程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-线程的终止"><span class="toc-text">1.2.2 线程的终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-线程的清理"><span class="toc-text">1.2.3 线程的清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-线程取消"><span class="toc-text">1.2.4 线程取消</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-线程的同步"><span class="toc-text">1.3 线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-互斥量"><span class="toc-text">1.3.1 互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-1线程池"><span class="toc-text">1.3.1.1线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-2-池类写法"><span class="toc-text">1.3.1.2 池类写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-通知法"><span class="toc-text">1.3.2 通知法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-信号量"><span class="toc-text">1.3.3 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-读写锁"><span class="toc-text">1.3.4 读写锁</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
