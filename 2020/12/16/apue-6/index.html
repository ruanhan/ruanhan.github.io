<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>信号 - Hexo</title>
  
    <meta name="keywords" content="doc">
  
  
    <meta name="description" content="信号">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/12/16/apue-6/">
      信号
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/apue/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>apue</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Dec 16, 2020</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><ol>
<li>信号的概念</li>
<li>signal();</li>
<li>信号的不可靠</li>
<li>可重入函数</li>
<li>信号的响应过程（非常重要的图）</li>
<li>常用函数（kill raise alarm pause abort system sleep ）</li>
<li>信号集</li>
<li>信号屏蔽字/pending集的处理</li>
<li>扩展（sigsuspend sigaction setitimer）</li>
<li>实时信号</li>
</ol>
<h2 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h2><p>到目前为止，之前写的程序还没有一个是异步运行的，全部都是同步运行的。</p>
<blockquote>
<p>Linux 环境中的并发可以分为 多进程+信号 和 多线程两种，信号属于初级异步，多线程属于强烈异步。</p>
</blockquote>
<p>在实际项目中信号和多线程基本不会一块儿使用，要么使用 多进程+信号 的形式，要么采用多线程的形式。</p>
<h3 id="1-1-同步、异步，-异步意味着并发"><a href="#1-1-同步、异步，-异步意味着并发" class="headerlink" title="1.1  同步、异步， 异步意味着并发"></a>1.1  同步、异步， 异步意味着并发</h3><p>同步程序的特点是程序的执行流程、分支都是明确的。</p>
<p>异步事件的特点：事件到来的时间不确定，到来之后产生的结果是不确定的。比如在俄罗斯方块游戏中需要异步接收用户的方向控制输入，你永远无法知道用户什么时候按下方向键，以及按下哪个方向键。</p>
<h3 id="1-2-异步事件的获取方式通常只有两种：查询法，通知法"><a href="#1-2-异步事件的获取方式通常只有两种：查询法，通知法" class="headerlink" title="1.2  异步事件的获取方式通常只有两种：查询法，通知法"></a>1.2  异步事件的获取方式通常只有两种：查询法，通知法</h3><blockquote>
<p>如果当前这个异步时间发生的频率非常稀疏，就使用通知法。如果异步发生的频率高， 就使用主动的查询法；</p>
</blockquote>
<p>假如我们使用一个烟雾传感器监测库房中是否发生了火灾，火灾的到来的时间就是一种异步事件。</p>
<p>我们可以通过两种方式获取是否发生了火灾：</p>
<p>1）查询法：传感器将状态写到一个位图当中，我们不停的查询位图的状态来得到传感器的最新监测结果。</p>
<p>2）通知法：当检测到火灾时传感器推送一个消息给我们，这样我们就不用不停的查询位图了。</p>
<h3 id="1-3-那么什么情况使用查询法更好，什么情况使用通知法更好呢？"><a href="#1-3-那么什么情况使用查询法更好，什么情况使用通知法更好呢？" class="headerlink" title="1.3  那么什么情况使用查询法更好，什么情况使用通知法更好呢？"></a>1.3  那么什么情况使用查询法更好，什么情况使用通知法更好呢？</h3><p>异步事件到来的频率比较高的情况考虑使用查询法，因为撞到异步事件到来的概率比较高。</p>
<p>异步事件到来的频率比较稀疏的情况考虑通知法，因为比较经济实惠。</p>
<h3 id="1-4-没有严格意义上的通知法"><a href="#1-4-没有严格意义上的通知法" class="headerlink" title="1.4  没有严格意义上的通知法"></a>1.4  没有严格意义上的通知法</h3><blockquote>
<p>通知法的实现是需要在特定场景下的；因为通知法也必须满足一定的条件。比如订阅者需要保持接受的状态或者说保持能够准时接收到通知的状态。</p>
</blockquote>
<p>所有的通知法都需要配合一个监听机制才行。否则比如你在垂钓，放下一个鱼竿之后你就走了，就算鱼上钩了你也不可能知道。</p>
<p>即使计算机中没有连接任何外部硬件设备，内核每秒钟也会发生成百上千个中断来打断正在运行的程序。</p>
<h3 id="1-5-异步"><a href="#1-5-异步" class="headerlink" title="1.5  异步"></a>1.5  异步</h3><p>什么是真正的异步，单核的机器会出现真正意义的异步吗？</p>
<blockquote>
<p>回本溯源，不可打断的就是一条机器指令。在单核机器上，同时聊QQ，打游戏，听歌不是并发，而是大家轮流占用当前的处理器，但是每个人会有限定的时间片，当时间片耗尽，就需要进去就绪队列中排队。只不过操作系统的调度关系特别块，对于用户来讲，感知不到计算机做这样分时的实现。因此在单核机器上不会存在并发，不可能有两件事一起做的情况。</p>
</blockquote>
<p>所以在单核 CPU 上其实是不存在真正意义上的异步的，你感受到的异步无非就是时间片切换给你带来的错觉。你以为你边听音乐边写程序，这两件事是同时进行的吗？其实内核在快速的不断的打断其中一个程序，然后再让另一个程序运行一会儿，如此往复，给你一种两件事情在同时发生的错觉。</p>
<p>时间片调度其实就是通过中断打断程序的执行，把时间片耗尽的进程移动到队列中等待。所以任何一个进程在执行的过程中都是磕磕绊绊的不断被打断的，程序在任何地方都可能被打断，唯独一条机器指令是无法被打断的（机器指令是原子的）。</p>
<p>比如你在执行一句 printf(“Hello World!\n”); 的时候，看似是很流畅的打印出来了，但是执行过程中已经被打断很多次了。</p>
<h2 id="2-信号的概念"><a href="#2-信号的概念" class="headerlink" title="2. 信号的概念"></a>2. 信号的概念</h2><blockquote>
<p>信号是软件中断， 信号的响应依赖于中断</p>
</blockquote>
<p>信号不是中断，中断只能由硬件产生，信号是模拟硬件中断的原理在软件层面上进行的实现。设计信号这个机制的人，大概率有非常强的硬件中断的经验。所以在软件层面来模仿硬件的打断机制。可以使用 kill(1) 命令向其它进程查看或发送信号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP          2) SIGINT          3) SIGQUIT         4) SIGILL          5) SIGTRAP         6) SIGABRT         7) SIGBUS          8) SIGFPE          9) SIGKILL        10) SIGUSR1         11) SIGSEGV        12) SIGUSR2        13) SIGPIPE        14) SIGALRM        15) SIGTERM</span><br><span class="line">16) SIGSTKFLT      17) SIGCHLD        18) SIGCONT        19) SIGSTOP        20) SIGTSTP</span><br><span class="line">21) SIGTTIN        22) SIGTTOU        23) SIGURG         24) SIGXCPU        25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM      27) SIGPROF        28) SIGWINCH       29) SIGIO          30) SIGPWR</span><br><span class="line">31) SIGSYS         34) SIGRTMIN       35) SIGRTMIN+1     36) SIGRTMIN+2     37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4     39) SIGRTMIN+5     40) SIGRTMIN+6     41) SIGRTMIN+7     42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9     44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9     56) SIGRTMAX-8     57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6     59) SIGRTMAX-5     60) SIGRTMAX-4     61) SIGRTMAX-3     62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1     64) SIGRTMAX</span><br><span class="line">$</span><br><span class="line"><span class="comment">#1 - 31 是标准信号，</span></span><br><span class="line"><span class="comment">#34 - 64 是实时信号。</span></span><br></pre></td></tr></table></figure>



<p><em>下面讨论的内容如果没有特殊说明则都是针对标准信号</em></p>
<p>信号有五种不同的默认行为：<code>终止、终止+core、忽略、停止进程、继续。</code></p>
<p> core 文件就是程序在崩溃时由操作系统为它生成的内存现场映像和调试信息，主要是用来调试程序的，可以使用 ulimit(1) 命令设置允许生成的 core 文件的最大大小。</p>
<p>1）终止：使程序异常结束。还记得我们在前面的博文中提到的程序的 3 种异常终止情况吗？其中被信号杀死就是异常终止的一种。</p>
<p>2）终止+core：杀死进程，并为其产生一个 core dump 文件，可以使用这个 core dump 文件获得程序被杀死的原因。</p>
<p>3）忽略：程序会忽略该信号，不作出任何响应。</p>
<p>4）停止进程：将运行中的程序中断。被停止的进程就像被下了一个断点一样，停止运行并不会再被调度，直到收到继续运行的信号。当按下 Ctrl+Z 时就会将一个正在运行的前台进程停止，其实就是向这个进程发送了一个 SIGTSTP 信号。</p>
<p>5）继续：使被停止的进程继续运行。只有 SIGCONT 信号具有这项功能。</p>
<p>这里介绍下常用的标准信号，但是有时间所有的信号都要仔细的看（见《APUE》第三版 P252 - P256）。</p>
<table>
<thead>
<tr>
<th align="left">信号</th>
<th align="center">默认动作</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIGABRT</td>
<td align="center">终止+core</td>
<td align="right">调用 abort(3) 函数会向自己发送该信号使程序异常终止，通常在程序自杀时使用。</td>
</tr>
<tr>
<td align="left">SIGALRM</td>
<td align="center">终止</td>
<td align="right">调用 alarm(2) 或 setitimer(2) 定时器超时时向自身发送的信号。setitimer(2) 设置 which 参数的值为 ITIMER_REAL 时，超时后会发送此信号。</td>
</tr>
<tr>
<td align="left">SIGCHLD（某些平台是 SIGCLD）</td>
<td align="center">忽略</td>
<td align="right">当子进程状态改变系统会将该信号发送给其父进程。状态改变是指由运行状态改变为暂停状态、由暂停状态改变为运行状态、由运行状态改变为终止状态等等。</td>
</tr>
<tr>
<td align="left">SIGHUP</td>
<td align="center">终止</td>
<td align="right">如果终端接口检测到链接断开则将此信号发送给该终端的控制进程，通常会话首进程就是该终端的控制进程。</td>
</tr>
<tr>
<td align="left">SIGINT</td>
<td align="center">终止</td>
<td align="right">当用户按下中断键(Ctrl+C)时，终端驱动程序产生此信号并发送给前台进程组中的每一个进程。大家经常使用 Ctrl + C 来杀死进程，这回知道是什么原理了吧？</td>
</tr>
<tr>
<td align="left">SIGPROF</td>
<td align="center">终止</td>
<td align="right">setitimer(2) 设置 which 参数的值为 ITIMER_PROF 时，超时后会发送此信号。</td>
</tr>
<tr>
<td align="left">SIGQUIT</td>
<td align="center">终止+core</td>
<td align="right">当用户在终端上按下退出键(Ctrl+)时，终端驱动程序产生此信号并发送给前台进程组中的所有进程。该信号与 SIGINT 的区别是，在终止进程的同时为它生成 core dump 文件。</td>
</tr>
<tr>
<td align="left">SIGTERM</td>
<td align="center">终止</td>
<td align="right">使用 kill(1) 命令发送信号时，如果不指定具体的信号，则默认发送该信号。</td>
</tr>
<tr>
<td align="left">SIGUSR1</td>
<td align="center">终止</td>
<td align="right">用户自定义的信号。有童鞋说不明白什么是用户自定义的信号，其实所谓自定义的信号就是系统不赋予它什么特殊的意义，你想用它来做什么都行，根据你的程序逻辑为它定义好相应的信号处理函数就行了。</td>
</tr>
<tr>
<td align="left">SIGUSR2</td>
<td align="center">终止</td>
<td align="right">另一个用户自定义的信号，作用同上。</td>
</tr>
<tr>
<td align="left">SIGVTALRM</td>
<td align="center">终止</td>
<td align="right">setitimer(2) 设置 which 参数的值为 ITIMER_VIRTUAL 时，超时后会发送此信号。</td>
</tr>
</tbody></table>
<p>表1 常见的标准信号</p>
<ol>
<li>signal(2)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal - ANSI C signal handling</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* man 手册中定义的写法 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* APUE 课本上的写法 */</span></span><br><span class="line"><span class="keyword">void</span> (*signal (<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func) (<span class="keyword">int</span>))) (<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>signal(2) 函数的作用是为某个信号注册一个信号处理函数。</p>
<p>课本上的写法比 man 手册中的写法更好，因为 sighandler_t 这个名字纯属手册捏造出来的，如果某一天标准库发布了一个函数的名字恰巧也叫 sighandler_t，那么手册就出问题了，这是C 语言名空间管理不善导致的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./star</span><br><span class="line"></span><br><span class="line">********** <span class="comment"># 打印十次之后进程结束，如果在没到10次时，ctrl+c 相当于SIGINT 的快捷方式</span></span><br></pre></td></tr></table></figure>

<p>参数列表：</p>
<p>　　singno：1 - 31 是标准信号，34 - 64 是实时信号，当然也可以使用 kill(1) -l 所列出的宏名；</p>
<p>　　func：收到信号时的处理行为，也就是信号处理函数；<br>  也可以使用 SIG_DEF 和  SIG_IGN 两个宏来替代。<br>  <code>SIG_DEF</code> 表示使用信号的默认处理行为。<br>  <code>SIG_IGN</code> 表示忽略该信号。</p>
<p>返回值：原来的信号处理函数。有时候我们在定义自己的信号处理函数之前会把原来的信号处理函数保存下来，这样当我们的库使用完之后需要还原原来注册的信号处理函数，避免因为调用了我们的库而导致别人的库失效的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 SIG_IGN 来忽略信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    signal(SIGINT, SIG_IGN); <span class="comment">// 忽略掉信号</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./star1</span><br><span class="line">******^C**** <span class="comment"># ctrl+c 无法阻断进程</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用回调函数来 反馈信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个程序运行起来之后，每秒钟会打印一个星号（*），当按下 Ctrl+C 时会打印一个感叹号（!），直到 10 秒钟后程序退出，下面是不停的按 Ctrl+C 的运行结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall signal.c</span><br><span class="line">$ time ./a.out</span><br><span class="line"></span><br><span class="line">*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C! <span class="comment"># 按住ctrl c不放，程序运行不到10秒就结束！</span></span><br><span class="line">real    0m1.656s</span><br><span class="line">user    0m0.000s</span><br><span class="line">sys     0m0.002s</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h3 id="2-1-信号会打断阻塞的系统调用"><a href="#2-1-信号会打断阻塞的系统调用" class="headerlink" title="2.1 信号会打断阻塞的系统调用"></a>2.1 信号会打断阻塞的系统调用</h3><p>通过 time(1) 命令可以测试出来，程序并没有持续 10 秒钟才结束，这是因为信号会打断阻塞的系统调用，也就是说 SIGINT 这个信号打断了 sleep(3)。</p>
<p>如果加上信号机制的话，那么前面学习的例子没有一个是对的；</p>
<p>比如使用 read(2) 函数读取一个设备的时候，当设备中没有充足的数据供读取时，read(2) 函数会进入阻塞等待数据的状态，这时候如果收到了一个信号就会打断阻塞中的 read(2) 函数，它会设置 EINTR 的 errno。所以收到函数报错的时候往往需要判断一下是否被信号打断了，如果是被信号打断的，还要重新再执行一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) <span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        dfd = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)<span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">          &#123;</span><br><span class="line">                <span class="built_in">close</span>(sfd);</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(dfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">read</span>(sfd,buf, BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)<span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR) <span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-竞争"><a href="#2-2-竞争" class="headerlink" title="2.2 竞争"></a>2.2 竞争</h3><p>当学习了信号之后，我们的程序中就出现异步的情况了，只要是异步的程序就可能会出现竞争，先来了解下什么是竞争。</p>
<p>竞争：一个十字路口没有红绿灯，两辆不同方向驶来车可能会发生碰撞，而且碰撞可能很严重也可能很轻微。当安装上红绿灯之后就相当于增加了一个协议，如果没有这个协议的限制，大家就可以随意的使用公共资源了，你在十字路口中间跳广场舞也可以。所以为了避免竞争带来的后果，我们会使用一些协议来避免竞争的发生。</p>
<p>当然，避免竞争的办法我们后面会讨论。</p>
<h2 id="3-信号的不可靠"><a href="#3-信号的不可靠" class="headerlink" title="3. 信号的不可靠"></a>3. 信号的不可靠</h2><blockquote>
<p>标准信号会丢失</p>
</blockquote>
<p><strong>不可靠的信号</strong></p>
<p>很多人看到了不可靠的信号这一章节，就认为因为额信号会丢失所以是不可靠的，其实这么理解是不对的，不可靠的信号是指信号的行为不可靠。</p>
<p>信号的处理就好比现在 LZ 正在写这篇博文，忽然来了一个电话，于是打断了手头的工作，先接电话去了。</p>
<p>信号处理函数的执行现场不是程序员布置的，而是内核布置的，因为程序中不会有调用信号处理函数的地方。 同一个信号处理函数的执行现场会被布置在同一个地方，所以当一次信号处理函数未执行完成时再次触发了相同的信号，信号处理函数发生了第二次调用，则第一次调用的执行现场会被覆盖。<br>基于此，出过各种馊主意。有用队列存的，还有不管多少信号只执行第一次的回调函数，其他时候执行默认行为的。（比如上上面的例子，第一次执行ctrl+c打印出 ！，第二次执行ctrl+c 直接取ctrl+c默认行为，把进程杀了 😳）</p>
<h2 id="4-可重入函数"><a href="#4-可重入函数" class="headerlink" title="4. 可重入函数"></a>4. 可重入函数</h2><blockquote>
<p>所有的系统调用都是可重入的，一部分库函数也是可重入的。尤其是返回值是一个指针的函数。比如说： memcpy</p>
</blockquote>
<p>函数重入乍一看上去像是递归，但又是有区别的，递归调用的现场是程序员布置的，而重入是在一个函数执行未结束时再次发生了调用并且进入了同一个函数现场。</p>
<p>重入时函数会发生错误的函数称为“不可重入函数”，重入不会出现错误的函数叫做“可重入函数”。</p>
<p>所有的系统调用都是可重入函数，所以信号处理函数中可以放心的使用系统调用。但并不是说所有的非系统调用都是不可重入的。</p>
<p>man 手册所有的函数中如果有一个同名的带 <code>_r</code> 后缀的函数，<br>那么不带<code>_r</code> 后缀的函数是不可重入的函数，<br>而带 <code>_r</code> 后缀的函数是可重入的函数。比如下面这两个常见的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// strerror,  strerror_r - return string describing error number</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strerror_r</span><span class="params">(<span class="keyword">int</span> errnum, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen)</span></span>;</span><br><span class="line"><span class="comment">/* XSI-compliant */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror_r</span><span class="params">(<span class="keyword">int</span> errnum, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen)</span></span>;</span><br><span class="line"><span class="comment">/* GNU-specific */</span></span><br></pre></td></tr></table></figure>

<h2 id="5-信号的响应过程"><a href="#5-信号的响应过程" class="headerlink" title="5. 信号的响应过程"></a>5. 信号的响应过程</h2><blockquote>
<p>这部分知识涉及调度问题，信号软件层面的中断，</p>
</blockquote>
<ul>
<li>信号从收到到响应是有一个不可避免的延迟，</li>
<li>思考： 如何忽略掉一个信号的？</li>
<li>思考： 标准信号为什么要丢失</li>
<li>标准信号的响应没有严格的顺序（先响应哪个不知道，可能会根据优先级大小决定响应顺序，碰到优先级差不多的响应顺序不确定）</li>
<li>不能从信号处理函数中随意的往外跳</li>
</ul>
<p><strong>信号从收到到响应是有一个不可避免的延迟</strong></p>
<p>因为只收到信号是体现在padding位图上，由0变成了1.要有中断来打断才能够去内核排队。从kernel回到user的时候，要做 mask&amp;padding 按位与才能看到这个信号。所以，信号就有一个不可避免的时延；</p>
<p><strong>如何忽略掉一个信号的？</strong></p>
<p>把某个信号的mask位永远置成0；</p>
<p><strong>标准信号为什么要丢失</strong></p>
<p>位图，一万次1还是1，最终在执行信号回调的时候是需要 mask&amp;padding的， 通过这个按位与的结果来决定是否有收到该信号的</p>
<ul>
<li>先把模型缩小</li>
</ul>
<p>当程序在正常运行的时候，mask为1，padding为0；突然接到一个信号，mask继续是1，padding 变成了1. 这个时候被中断打断了，加内核排队。等待调度的时候往外走，当从kernel态回到user态的时候。拿 mask&amp;padding 做一个按位与，发现收到了1个信号了。然后再执行信号响应回调的时候，把mask和padding都置成0的，然后去执行响应回调。等执行完响应之后，把mask置成1.padding继续保持是0. 然后再做一次按位与，ok，发现没有信号了。然后程序执行其他的去了。</p>
<ul>
<li>再把模型放大</li>
</ul>
<p>当前没有信号的时候，mask为1，padding为0（初始化的状态）。当执行过程中，收到信号了，mask继续是1，padding变成1. 然后继续 中断。。排队。。调度。。kernel -》user 。。按位与。。。发现有信号。。执行响应回调前， 把 mask 和 padding 都置成0. 在这个时候又来了一个或者十万个信号，那么 mask继续是0， 而padding 被反复置换成1（置1次1，或者十万次1，位图不会累加，不会计数，不管多少次1，最终还是1）.所以这里会丢失信号。</p>
<p><strong>标准信号的响应没有严格的顺序</strong></p>
<p><strong>不能从信号处理函数中随意的往外跳</strong></p>
<h3 id="6-1-可靠信号术语和语义"><a href="#6-1-可靠信号术语和语义" class="headerlink" title="6.1 可靠信号术语和语义"></a>6.1 可靠信号术语和语义</h3><p>这是信号这章比较重要的内容，通过这个我们来了解信号在 Linux 系统中是如何实现的。</p>
<p><img src="./signal_01.png" alt=""><br>图1 标准信号的处理过程（从进程角度来分析应该的响应过程）</p>
<p>进程线程并不分家，从内核的角度来看，当前操作的任务只有一个，叫线程。从开发者的角度来讲，先产生的概念叫进程，后来发现其实不是这么回事儿，其实细化到线程来进行调度。进程是容器。所以进程和线程其实是 开发者角度去区分的。从内核的角度来讲，内核只有进程一个概念。<br>进程线程不分家，开发者完全可以做出既不是线程也不是进程的东西来使用。</p>
<p>内核为每个进程维护了一组位图（两个位置），mask（信号屏蔽字）和 padding， 理论来讲， mask 和 padding都是 32位的。mask用来表示当前的信号的状态，padding是一个位图，用来记录当前这个进程收到哪些信号。</p>
<p>mask屏蔽字的值一般情况下都是1，padding位初始值一上来初始值为0。<br>都知道程序会被中断（打断），举个例子，比如说时间片耗尽了，实际上也可以理解为某种形式反映给你的中断。然后要抱着当前的执行现场扎内核（把当前的执行现场压栈存放，相当于整个进程暂停起来，然后去到内核）。内核中有个等待调度的就绪队列，然后在那里进行排队。排队等待调度到你的时候，别人把调度器出让给你。这个时候相当于你重新被调用。然后再从刚才（刚才已经压栈了一个现场）的现场进程恢复，来继续进行下面的程序。然后在执行过程当中，又被别人打断了。然后重复前面说的过程。继续压栈，排队，等待调度，恢复现场执行等等这样一个过程。</p>
<p>mask 和 padding 位图是一一对应的，它们用于反映当前进程信号的状态。每一位代表了一个标准信号。</p>
<p>mask 位图用于记录哪些信号可以响应。1 表示该信号可以响应，0 表示该信号不可响应（会被忽略）。</p>
<p>padding 位图用于记录收到了哪些信号。1 表示收到了该信号，0 表示没有收到该信号。</p>
<p>前面说过了，程序在执行的过程中会被内核打断无数次，也就是说程序被打断后要停止手头的工作，进入一个队列排队等待再次被调度才能继续工作。</p>
<p>当进程获得调度机会后，从内核态返回到用户态之前要做很多事情，其中一件事就是将 mask 位图和 padding 位图进行 &amp; 运算，当计算的结果不为 0 时就需要调用相应的信号处理函数或执行信号的默认动作。</p>
<p>这就是 Linux 的信号处理机制，从这个机制中，我们可以总结出几个信号的特点：</p>
<p>1）如果想要屏蔽某个信号，只需将对应的 mask 位 置为 0 即可。这样当程序从内核态返回用户态进行 mask &amp; padding 时，该信号位的计算结果一定为 0。</p>
<p>2）信号从收到到响应是存在延迟的，一般最长延迟 10 毫秒。因为只有程序被打断并且重新被调度的时候才有机会发现收到了信号，所以当我们向一个程序按下 Ctrl+C 时程序并没有立即挂掉，只不过这个时间非常短暂我们一般情况下感觉不到而已，我们自己以为程序是立即挂掉了。其实想要实验也很容易，写一个死循环不断打印一个字符，然后在它跑起来的时候按下 Ctrl+C，你会发现并不是打印了 ^C 之后程序会立即停止，而是继续打印了一些字符之后才停止。</p>
<p>3)当一个信号没有被处理时，无论再次接受到多少个相同的信号都只能保留一个，因为 padding 是位图，位图的特点就是只能保留最后一次的状态。这一点说的就是标准信号会丢失的特点，如果想要不丢失信号就只能使用实时信号了。</p>
<p>4）信号处理函数轻易不允许使用 longjmp(3) 进行跨函数跳转。因为处理信号之前系统会把 mask 对应的位设置为 0 来避免信号处理函数重入，当信号处理完成之后系统会把对应的 mask 位设置为 1 恢复进程对该信号的响应能力。如果进行了长跳转系统就不会恢复 mask 位图了，也就再也无法收到该信号了。其实这个图只是一个草图，信号实际上是线程级别的（这个我们在后面讲到线程的时候会详细讨论），所以即使 mask 位图在处理前被置为 0，依然有可能出现重入的现象，因为无法保证兄弟线程也同步屏蔽了相应的位。</p>
<p>5）信号处理函数的执行时间越短越好，因为信号处理函数是在用户态执行的，在它的执行过程中也会不停的被内核打断，所以如果信号处理函数执行的时间过长会使情况变得复杂。</p>
<p>6）信号的响应是嵌套执行的。就是说假设进程先收到了 SIGINT 信号，当它的信号处理函数还没有执行完毕时又收到了另一个信号 SIGQUIT，那么当进程从内核态返回到用户态时会优先执行 SIGQUIT 的信号处理函数，等 SIGQUIT 的信号处理函数执行完毕后再回到 SIGINT 信号处理函数上次被打断时的地方继续执行，函数调用栈看上去就像在 SIGINT 的信号处理函数中调用了 SIGQUIT 的信号处理函数一样。这也是上面所说的为什么信号处理函数的执行时间要越短越好，要尽量避免这种复杂的情况发生。</p>
<p>7）如果同时到来多个优先级差不多的信号，无法保证优先响应哪个信号，它们的响应没有严格意义上的顺序。除非是收到了优先级较高的信号，系统会保证高优先级的先被处理。</p>
<h3 id="6-2-信号处理函数"><a href="#6-2-信号处理函数" class="headerlink" title="6.2 信号处理函数"></a>6.2 信号处理函数</h3><blockquote>
<p>信号处理函数 尽量使用可重入的函数，系统调用可以，一部分库函数可以。然后由于在信号当中不能用到大家都在用的东西，防止产生竞争和冲突，比如标准IO是不能用在信号处理函数当中的。因为公用缓冲区，防止别人在用缓冲区，自己也在用缓冲区。就会存在问题。信号处理函数还应该做到尽量小，小到尽量能够一闪而过才好。</p>
</blockquote>
<h2 id="6-信号常用函数"><a href="#6-信号常用函数" class="headerlink" title="6. 信号常用函数"></a>6. 信号常用函数</h2><p><code>kill raise alarm pause abort system sleep</code></p>
<h3 id="6-1-kill-2"><a href="#6-1-kill-2" class="headerlink" title="6.1 kill(2)"></a>6.1 kill(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kill - send a signal to a process or a group of processes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>kill(2) 函数的作用是将指定的信号(sig)发送给指定的进程(pid)。</p>
<p>大家一看到 kill 就觉得有杀死进程的意味，其实未必如此，kill(3) 也负责给进程发送各种信号。</p>
<p>参数列表：</p>
<p>pid：接收信号的进程 ID。可填的内容详见下表：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&gt;0</td>
<td align="center">接收信号的进程 ID。</td>
</tr>
<tr>
<td align="left">==0</td>
<td align="center">发送信号给当前进程所在进程组的所有进程。</td>
</tr>
<tr>
<td align="left">==-1</td>
<td align="center">发送信号给当前进程有权向它们发送信号的所有进程，1 号 init 进程除外。相当于一个全局广播信号，发送这种信号一般只有 1 号 init 会做，比如在关机的时候 init 进程会发送全局广播信号通知大家该结束了。</td>
</tr>
<tr>
<td align="left">&lt;-1</td>
<td align="center">将 pid 的绝对值作为组 ID，给这个组中所有的进程发送信号。</td>
</tr>
<tr>
<td align="left">表2 kill(2) 函数 pid 参数的取值</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>　　sig：要发送的信号，可以使用 kill(1) -l 所列出的信号。如果 sig 是 0 会执行所有的错误检查，但并不真正发送信号。所以通常使用 0 值检查一个进程是否仍然存在，如果该进程不存在则返回 -1 并将 errno 设置为 ESRCH。需要注意的是这种检查并不原子，当 kill(2) 返回测试结果的时候也许被测试的进程已经终止了。当然也可以测试当前进程是否对目标进程有权限发送信号，如果 errno 为 EPERM 表示被测试的进程存在但当前进程无权限访问。</p>
<p>返回值：成功为 0，失败为 -1，并设置 errno。</p>
<h3 id="6-2-raise"><a href="#6-2-raise" class="headerlink" title="6.2 raise"></a>6.2 raise</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send a signal to the caller 对当前进程发一个信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法 单线程模式 相当于</span></span><br><span class="line">kill(getpid(), sig); <span class="comment">// 以进程单位发信号</span></span><br><span class="line"><span class="comment">// 此方法 多线程模式 相当于</span></span><br><span class="line">pthread_kill(pthread_self());  <span class="comment">// 以线程为单位发</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-pause-3P"><a href="#6-3-pause-3P" class="headerlink" title="6.3 pause(3P)"></a>6.3 pause(3P)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pause - wait for signal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>专门用于阻塞当前进程，等待一个信号来打断它。</p>
<h3 id="6-4-alarm-3P"><a href="#6-4-alarm-3P" class="headerlink" title="6.4 alarm(3P)"></a>6.4 alarm(3P)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alarm - schedule an alarm signal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>指定  seconds 秒，发送一个 SIGALRM 信号给自己。</p>
<p>seconds 为 0 的时候，表示取消这个定时器，并且新设置的值会覆盖上次设置的值。所以当程序中出现了多个对 alarm(3P) 的调用时，计时是不准确的。</p>
<p><strong>思考： 那如何用一个单一的计时器，来实现一个多任务的计时器</strong></p>
<p>注意，SIGALRM 信号默认动作是杀死进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    alarm(<span class="number">1</span>); <span class="comment">// 新设置的值会覆盖上次设置的值。</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 秒 之后结束程序</span></span><br><span class="line"><span class="comment">// alarm没办法实现多任务的 计时器</span></span><br></pre></td></tr></table></figure>

<p>上面提到 新设置的值会覆盖上次设置的值，当程序中出现了多个对 alarm(3P) 的调用时，计时是不准确的。</p>
<p>sleep -&gt; alarm + pause</p>
<p><strong>尽量不要用sleep的原因</strong></p>
<blockquote>
<p>是因为在有些环境下， sleep是用 alarm 和 pause 封装的。 有些环境的sleep是用nanosleep封装的。所以考虑移植的情况下，不要在程序中使用 sleep。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">5</span>); <span class="comment">// 5秒后 杀死进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        pause(); <span class="comment">// 阻塞当前进程，等待信号</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时循环实验</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5sec.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">end</span> = time(<span class="literal">NULL</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(time(<span class="literal">NULL</span>) &lt;= <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">time ./5sec &gt; /tmp/out</span><br><span class="line"></span><br><span class="line">5.49s user</span><br><span class="line">0.00s system</span><br><span class="line">94% cpu</span><br><span class="line">5.831 total</span><br><span class="line"></span><br><span class="line">cat /tmp/out</span><br><span class="line">2044174125</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line">    alarm(<span class="number">5</span>); <span class="comment">// 5秒钟后杀掉进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count); <span class="comment">// 5秒后进程被杀，没机会打印printf了</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该功能无法通过 这种方式来实现</span></span><br></pre></td></tr></table></figure>

<p>我们来看看代码 count_alarm.c、count_time.c，哪个效率更高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* count_alarm.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alarm_handler</span> <span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意 signal 再 alarm之前</span></span><br><span class="line">    signal(SIGALRM, alarm_handler); <span class="comment">// 先设置信号回调</span></span><br><span class="line">    alarm(<span class="number">5</span>);  <span class="comment">// 再设置时钟</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* count_time.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (time(<span class="literal">NULL</span>) &lt; t) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ make count_alarm count_time</span><br><span class="line">cc     count_alarm.c   -o count_alarm</span><br><span class="line">cc     count_time.c   -o count_time</span><br><span class="line">$ time ./count_alarm</span><br><span class="line">2374311494</span><br><span class="line"></span><br><span class="line">real    0m5.004s</span><br><span class="line">user    0m4.780s</span><br><span class="line">sys    0m0.194s</span><br><span class="line">$ time ./count_time</span><br><span class="line">2139947</span><br><span class="line"></span><br><span class="line">real    0m4.152s</span><br><span class="line">user    0m4.116s</span><br><span class="line">sys    0m0.021s</span><br><span class="line">$</span><br></pre></td></tr></table></figure>


<p>通过执行结果可以看出来，alarm(3P) 的方式和 time(2) 的方式执行效率竟然差了 1000 多倍，当然这个简单的测试精度是不高的。</p>
<p>上面的代码通过 gcc count_alarm.c -O1 优化之后就无法正确执行了。</p>
<p>我们先把 count_alarm.c 编译成汇编代码再讨论它为什么被优化之后无法正确执行了。</p>
<p>优化前：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ gcc -S count_alarm.c -o count_alarm.S</span><br><span class="line">&gt;$ vim count_alarm.S</span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">alarm_handler:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    <span class="variable">$0</span>, flag(%rip)   ; 修改 flag 的值</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    <span class="variable">$alarm_handler</span>, %esi</span><br><span class="line">    movl    <span class="variable">$14</span>, %edi</span><br><span class="line">    call    signal</span><br><span class="line">    movl    <span class="variable">$5</span>, %edi</span><br><span class="line">    call    alarm</span><br><span class="line">    movl    <span class="variable">$1</span>, flag(%rip)</span><br><span class="line">    jmp    .L4</span><br><span class="line">.L5:</span><br><span class="line">    movq    count(%rip), %rax</span><br><span class="line">    addq    <span class="variable">$1</span>, %rax</span><br><span class="line">    movq    %rax, count(%rip)</span><br><span class="line">.L4:</span><br><span class="line">    movl    flag(%rip), %eax</span><br><span class="line">    testl    %eax, %eax        ; 每次循环会检测 flag 的值是否改变</span><br><span class="line">    jne    .L5</span><br><span class="line">    movq    count(%rip), %rdx</span><br><span class="line">movl    $.LC0, %eax</span><br><span class="line">    movq    %rdx, %rsi</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    movl    <span class="variable">$0</span>, %eax</span><br><span class="line">    call    <span class="built_in">printf</span></span><br><span class="line">movl    <span class="variable">$0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">    ; ...... 省略不相关代码</span><br></pre></td></tr></table></figure>


<p>优化后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ gcc -S count_alarm.c -O1 -o count_alarm1.S</span><br><span class="line">&gt;$ vim count_alarm1.S</span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">alarm_handler:</span><br><span class="line">.LFB21:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    movl    <span class="variable">$0</span>, flag(%rip)    ; 修改 flag 的值</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">.LFB22:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    subq    <span class="variable">$8</span>, %rsp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    movl    <span class="variable">$alarm_handler</span>, %esi</span><br><span class="line">    movl    <span class="variable">$14</span>, %edi</span><br><span class="line">    call    signal</span><br><span class="line">    movl    <span class="variable">$5</span>, %edi</span><br><span class="line">    call    alarm</span><br><span class="line">    movl    <span class="variable">$1</span>, flag(%rip)</span><br><span class="line">.L4:</span><br><span class="line">    jmp    .L4                ; 变成了死循环</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">; ...... 省略不相关代码</span><br></pre></td></tr></table></figure>

<p>从上面的代码不难看出，优化时编译器认为 flag 的值一直没有改变，所以直接把 flag 的值拿过来作为循环条件了，每次循环的时候不再从 flag 变量所在的内存位置取值了。</p>
<p>为了避免编译器犯这种错误，我们需要把 flag 定义成 volatile 变量，volatile 关键字表示一定要到变量定义的位置取变量的值，而不要轻信曾经拿到的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mycat 初步实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  do&#123;</span></span><br><span class="line"><span class="comment">//     dfd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0600);</span></span><br><span class="line"><span class="comment">//     if (dfd &lt; 0)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(errno != EINTR)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//                 close(sfd);</span></span><br><span class="line"><span class="comment">//                 perror("open()");</span></span><br><span class="line"><span class="comment">//                 exit(1);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">// &#125; while(dfd &lt; 0);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    len = <span class="built_in">read</span>(sfd,buf, BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perror(<span class="string">"read()"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"write()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        pos += ret;</span><br><span class="line">        len -= ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(dfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-流量控制（流控算法）"><a href="#6-5-流量控制（流控算法）" class="headerlink" title="6.5 流量控制（流控算法）"></a>6.5 流量控制（流控算法）</h3><p>播放音乐和电影的时候都要按照播放的速率读取文件，而不能像 cat(1) 命令一样，直接将交给它的文件用最快的速度读取出来，否则你听到的音乐就转瞬即逝了。</p>
<p>我们先通过一个栗子了解下什么是流量控制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slowcat 的实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    loop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!loop)</span><br><span class="line">        &#123;</span><br><span class="line">            pause();  <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len = <span class="built_in">read</span>(sfd,buf, BUFSIZE))&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 假如读取的 sfd 是一个设备，现在这个 设备没有数据，我们都知道程序中信号总会到来，所以 一直 continue， 程序就在这个while语句里面一直打转。</span></span><br><span class="line">        <span class="comment">// 另外，如果当前数据量非常大的话，那程序在这里也无能为力，因为1秒钟也只能读取 10个字节。</span></span><br><span class="line">        <span class="comment">// 这里是一个 漏桶的实现，可以看见 当前数据量不管有多少，这里只慢慢的10个字节10个字节的读。如果没有数据也只能闲着。读不到东西，假错，continue，死循环。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面文件 IO 的部分我们做过一个栗子 mycp，用来模仿 cp(1) 命令。这次我们把它修改为 mycat，用来模仿 cat(1) 命令，并且是慢慢的 cat，每秒钟输出 10 个字节的数据。</p>
<p>这个流控方案就是漏桶：当没有数据可读的时候就是闲着，并没有积攒权限，所以当数据再次可读的时候它的速率不会变。</p>
<p>我们前面提到过，stream 这种东西并非像小河流水一样是非常均匀的潺潺细流，而是要么没有数据，要么一下子来一大坨。如果用漏桶处理这种情况速度会非常慢，那么有没有什么更好的流控方案呢？当然有，用令牌桶来处理就可以很好的解决这种流量激增的情况。</p>
<p>令牌桶闲着的时候在积攒权限，既然有1秒钟可以传输10个字节的权限，那就攒着。如果暂停3秒钟，就攒下了传输30个字节的权限。这个时候突然来了一大波数据，然后瞬间就可以把这30个字节都解决掉。权限没有了，就只能一秒钟10个字节 10个字节的走。这种就叫做令牌桶</p>
<p>所以实际使用时令牌同比漏桶用得更普遍。</p>
<p>具体要用哪种桶需要根据实际需求来决定，比如在线听音乐的时候网速不好，不能等数据来了的时候用最快的速度把之前积攒了权限的数据一下子都播放出来，应当还保持原来的速率播放，所以这时候选择漏桶就更加合适了。</p>
<p>下面我们重构一下上面的漏桶流控代码，把它改成令牌桶的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10 <span class="comment">// 流量速率</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BURST 100 <span class="comment">// 令牌上限</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 积攒的令牌数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> token = <span class="number">0</span>; <span class="comment">// sig_atomic_t 信号原子类型，保证该类型的取值和赋值操作一定是一条机器指令</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    token++;</span><br><span class="line">    <span class="keyword">if</span>(token &gt; BURST)</span><br><span class="line">        token = BURST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (token &lt;= <span class="number">0</span>) &#123; <span class="comment">// 如果令牌数量不足则等待添加令牌</span></span><br><span class="line">            pause(); <span class="comment">// 因为添加令牌是通过信号实现的，所以可以使用 pause(2) 实现非忙等（通知法）</span></span><br><span class="line">        &#125;</span><br><span class="line">        token--; <span class="comment">// 每次读取 BUFSIZE 个字节的数据时要扣减令牌</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len = <span class="built_in">read</span>(sfd,buf, BUFSIZE))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这只是一个简单的令牌桶的雏形，不过已经足以让我们了解令牌桶的工作原理了。</p>
<p>令牌桶的三要素：令牌、令牌上限、流量速率（CPS）。</p>
<p>从上面的代码可以看出来：SIGALRM 的回调函数负责向令牌桶中添加令牌，而每次读取数据之前要先检查令牌的剩余数量。如果令牌充足则扣减令牌后开始读取数据，如果令牌数量不足则阻塞等待 SIGALRM 回调函数向令牌桶中补充令牌。</p>
<p>设计令牌上限是为了防止令牌桶溢出，通常没必要让令牌无限制的上涨。</p>
<h3 id="6-6-封装令牌桶库"><a href="#6-6-封装令牌桶库" class="headerlink" title="6.6 封装令牌桶库"></a>6.6 封装令牌桶库</h3><p>用户进行一个程序当中多个不同速率的流控的时候，该如何去做。</p>
<p><img src="./mytbf.png" alt=""></p>
<p>把行为封装起来，把更改属性的接口暴露给用户</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytbf.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span>* <span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> inited = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sighandler_t</span>  alrm_handler_save;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;</span><br><span class="line">    <span class="keyword">int</span> burst;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    signal(SIGALRM, alrm_handler_save);</span><br><span class="line">    alarm(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(job[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">get_free_pos</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i]!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">            <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alrm_handler_save = signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inited)</span><br><span class="line">    &#123;</span><br><span class="line">        module_load();</span><br><span class="line">        inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = get_free_pos();  <span class="comment">// 在数组中 找空位</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me; <span class="comment">//将该结构体存储至 数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> * ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    job[me -&gt; pos] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytbf.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTBF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_MAX 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">mytbf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> * <span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BURST 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">mytbf_t</span> *tbf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    tbf =  mytbf_init(CPS, BURST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tbf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mutbf_int() failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">        <span class="built_in">size</span> = mytbf_fetchtoken(tbf, BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mytbf_fetchtoken():%s"</span>, strerror(-<span class="built_in">size</span>));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len = <span class="built_in">read</span>(sfd,buf, <span class="built_in">size</span>))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> - len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mytbf_returntoken(tbf, <span class="built_in">size</span>-len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    mytbf_destroy(tbf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-实现计时器"><a href="#6-7-实现计时器" class="headerlink" title="6.7 实现计时器"></a>6.7 实现计时器</h3><blockquote>
<p>使用单一计时器，利用alarm或setitimer构造一组函数，实现任意数量的计时器（alarm实现）</p>
</blockquote>
<p>什么是单一计时器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alarm(<span class="number">1</span>);</span><br><span class="line">alarm(<span class="number">5</span>);</span><br><span class="line">alarm(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 比如三个 alarm，其实只有最后一个 alarm有效；</span></span><br><span class="line"><span class="comment">// 但能不能实现一个计时器，使 1分钟时 提示一下，5分钟时提示一下，10分钟时提示一下</span></span><br></pre></td></tr></table></figure>

<p>getitimer(3P) 和 setitimer(3P) 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getitimer, setitimer - get or set value of an interval timer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getitimer</span><span class="params">(<span class="keyword">int</span> which, struct itimerval *curr_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>setitimer(2) 函数可以用来替代 alarm(2) 函数。</p>
<p>setitimer(2) 函数主要有两点比 alarm(2) 函数更好：</p>
<p>setitimer 函数没有延迟累计的；</p>
<p>1）setitimer(2) 函数可以使用精度更高的微秒为计时单位； alarm只能按秒计数 </p>
<p>2）从 it_interval 赋值给 it_value 是采用原子操作的。</p>
<p>setitimer(2) 直接可以构成一个类似 alarm(2) 链的执行结构。也就是说当 it_value 的值被递减为 0 时会发送一个信号给当前进程，并且自动将 it_interval 的值赋给 it_value 使计时重新开始。</p>
<p>参数列表：</p>
<p>which：使用不同的时间，并发送不同的信号；详见下表（其实在 表1 中我们也提到它们了）</p>
<table>
<thead>
<tr>
<th align="left">which 可选宏值</th>
<th align="center">对应的信号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ITIMER_PROF</td>
<td align="center">SIGPROF</td>
</tr>
<tr>
<td align="left">ITIMER_REAL</td>
<td align="center">SIGALRM</td>
</tr>
<tr>
<td align="left">ITIMER_VIRTUAL</td>
<td align="center">SIGVTALRM</td>
</tr>
</tbody></table>
<p>表3 which 与对应的信号</p>
<p>　　new_value：新的定时器周期；这个结构体的定义可以见下面的说明。</p>
<p>　　old_value：由该函数回填以前设定的定时器周期，不需要保存可以设置为 NULL；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* next value */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>递减的是 it_value 的值，当 it_value 被递减为 0 的时候将 it_interval 的值 原子化 的赋给 it_value。</p>
<p>tv_sec 表示以秒为单位；tv_usec 表示以微秒为单位。使用一种计时方式时，另一种必须设置为 0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 setitimer 重构的漏桶程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//alarm(1);</span></span><br><span class="line">    loop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sfd, dfd = <span class="number">1</span>; <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line">	&#123;</span><br><span class="line">			<span class="comment">/* data */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	signal(SIGALRM, alrm_handler);</span><br><span class="line">	<span class="comment">// alarm(1);</span></span><br><span class="line">	itv.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">	itv.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	itv.it_value.tv_sec = <span class="number">1</span>;</span><br><span class="line">	itv.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (setitimer(ITIMER_REAL, &amp;itv, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setitimer()"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">		<span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"open()"</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	len = <span class="number">0</span>;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!loop)</span><br><span class="line">		&#123;</span><br><span class="line">			pause();</span><br><span class="line">		&#125;</span><br><span class="line">		loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> ((len = <span class="built_in">read</span>(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			perror(<span class="string">"read()"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			ret = <span class="built_in">write</span>(dfd, buf + pos, len);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				perror(<span class="string">"write()"</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;;</span><br><span class="line">			pos += ret;</span><br><span class="line">			len -= ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//  sleep(1);  sleep可以帮助程序实现这个功能，但是不建议在线上程序使用sleep函数</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(dfd);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-8-sleep"><a href="#6-8-sleep" class="headerlink" title="6.8 sleep"></a>6.8 sleep</h3><blockquote>
<p>有些平台的sleep 是 用alarm + pause封装的，因此当程序出现多个alarm函数时， sleep是会出错的</p>
</blockquote>
<h3 id="6-9-nanosleep"><a href="#6-9-nanosleep" class="headerlink" title="6.9 nanosleep"></a>6.9 nanosleep</h3><blockquote>
<p>可以用来替换sleep</p>
</blockquote>
<h3 id="6-10-usleep"><a href="#6-10-usleep" class="headerlink" title="6.10 usleep"></a>6.10 usleep</h3><h3 id="6-11-abort-3"><a href="#6-11-abort-3" class="headerlink" title="6. 11 abort(3)"></a>6. 11 abort(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abort - cause abnormal process termination</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>给调用者发送一个 SIGABRT 信号，收到这个信号的默认动作是终止 + 产生 coredump 文件。</p>
<p>我们在上面的 表1 中提到过它，一般都是程序发现自己出现了明显的异常，为了避免缺陷扩散，自杀的时候使用。</p>
<h3 id="6-12-system-3"><a href="#6-12-system-3" class="headerlink" title="6.12 system(3)"></a>6.12 system(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//system - execute a shell command</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>


<p>在前面介绍进程相关的博文中我们介绍过 system(3) 函数，所以对于它的功能我们这里就不再赘述了，今天聊点关于它与信号的花边新闻。</p>
<p>对于它的使用有一些需要注意的内容，想要正确的使用 system(3) 函数，必须阻塞 SIGCHLD 信号并忽略 SIGINT、SIGQUIT 信号。</p>
<p>为什么使用 system(3) 函数之前要做这些动作呢？这与 shell 的内部命令处理有关系，如果想要了解更详细的内容，请自行参阅 《APUE》 第三版第九章。</p>
<h3 id="6-13-select-2"><a href="#6-13-select-2" class="headerlink" title="6.13 select(2)"></a>6.13 select(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select,  pselect - synchronous I/O multiplexing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to POSIX.1-2001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">        fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>


<p>其实 sleep(3) 函数是不好用的，因为某些平台上是使用 alarm(2) + pause(2) 封装它的，大家知道 alarm(2) 的计时是不太准确的。</p>
<p>在当前平台（Linux）sleep(3) 函数是使用 nanosleep 封装的，所以如果不考虑移植的话在当前平台上可以安全的使用 sleep(3) 函数。</p>
<p>其实 usleep(3)、nanosleep(2)、select(2) 这些函数都比 sleep(3) 好用。</p>
<p>select 我们在第14章还会讲，这里说一下利用它的副作用来为我们实现一个安全的定时器。</p>
<p>这样设定它的参数列表就可以了：-1, NULL, NULL, NULL, 定时结构体。</p>
<p>本来不打算贴出代码的，但是后来 LZ 发现用 select(2) 作为计数器使用的时候有几个坑，有必要在这里强调一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * struct timeval 结构体表示剩余的时间</span></span><br><span class="line"><span class="comment">        * select(2) 函数内部会修改这个结构体的值</span></span><br><span class="line"><span class="comment">        * 如果把这两行写在循环上面...</span></span><br><span class="line"><span class="comment">        * 效果大家可以自己测试一下</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        timeout.tv_sec = <span class="number">1</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 作为定时器使用时只给时间就行了，其它参数都填 0。</span></span><br><span class="line">        <span class="keyword">if</span> (select(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, &amp;timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"select()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果不写 \n，那么程序会在结束的时候把所有的haha显示出来，</span></span><br><span class="line"><span class="comment">        * 而不是在每次循环的时候都显示，</span></span><br><span class="line"><span class="comment">        * 原因很简单，在前面我们讨论 IO 的时候就讨论过，</span></span><br><span class="line"><span class="comment">        * 默认情况下标准输出是行缓冲模式。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hehe\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-信号集"><a href="#7-信号集" class="headerlink" title="7. 信号集"></a>7. 信号集</h2><p>信号集就是一种能表示一组信号的数据类型，一般都是用在批量设置信号掩码时使用。</p>
<p>信号集使用 sigset_t 类型表示，有一组函数可以操作它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal set operations</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这一组函数的作用无非就是对信号集中的信号进行曾删改差，具体的用法各位可以自行查阅 man 手册。</p>
<h2 id="8-信号屏蔽字-pending集的处理"><a href="#8-信号屏蔽字-pending集的处理" class="headerlink" title="8. 信号屏蔽字/pending集的处理"></a>8. 信号屏蔽字/pending集的处理</h2><h3 id="8-1-sigprocmask-2"><a href="#8-1-sigprocmask-2" class="headerlink" title="8.1 sigprocmask(2)"></a>8.1 sigprocmask(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigprocmask - examine and change blocked signals</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>前面我们提到过我们可以人为的干扰信号 mask 位图，唯一的途径就是通过这个函数实现。但是 padding 位图是无法人为干扰的。</p>
<p>我们不能保证信号什么时候来，使用这个函数的目的就是为了让我们来决定什么时候响应信号。</p>
<p>参数列表：</p>
<p>how：指定如何来干扰 mask 位图，可以使用下表中三个宏中的任何一个来指定；</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIG_BLOCK</td>
<td align="center">将当前进程的信号屏蔽字和 set 信号集中的信号全部屏蔽，也就是将它们的 mask 位设置为 0</td>
</tr>
<tr>
<td align="left">SIG_UNBLOCK</td>
<td align="center">将 set 信号集中与当前信号屏蔽字重叠的信号解除屏蔽，也就是将它们的 mask 位设置为 1</td>
</tr>
<tr>
<td align="left">SIG_SETMASK</td>
<td align="center">将 set 信号集中的信号 mask 位设置为 0，其它的信号全部恢复为 1</td>
</tr>
<tr>
<td align="left">表4 干扰 mask 位图的方式</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>　　set：需要被干扰 mask 位图的信号集；</p>
<p>　　oldset：由该函数回填之前被干扰的信号集。</p>
<p>使用这个函数，我们来重构上面那个打印星号和感叹号的程序，新需求是这样的：</p>
<p>每行打印 5 个星号，然后停止。期间如果收到了 SIGINT 信号不会立即响应，而是等待本行打印结束后再响应，并且在收到信号之后再打印下一行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGINT, SIG_IGN);</span></span><br><span class="line">    signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原blog</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"!"</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oset,saveset; <span class="comment">// saveset 用来保存当前状态</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于下面三行的原子操作</span></span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sigset_t tmpset;</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK,&amp;oset,&amp;tmpset);</span></span><br><span class="line"><span class="comment">        pause();</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK,&amp;tmpset,NULL);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致的实现思路是：开始打印每行星号之前先屏蔽信号，当打印完成之后再恢复信号，然后等待被信号打断，再重新屏蔽信号，打印星号。</p>
<p>但是在测试的时候会发现，这样只能实现当一行信号打印完毕时可以停住，然后按下 Ctrl+C 发送信号，可以继续打印下一行。但是当一行没有打印完成时就按 Ctrl+C 发送信号，下一行会在行首打印感叹号，但是却并不继续开始打印星号。</p>
<p>这是什么原因导致的呢？其实仔细分析一下信号的处理过程就明白了，在开始打印星号之前我们屏蔽了信号的 mask 位，当接收到信号时对应的 padding 位被置1，由于 mask 位是 0 所以程序不会响应信号。当星号打印完成时 mask 位被置为 1，程序会再次看到信号，所以会打印感叹号并进入 pause 状态等待被信号打断，所以程序只打印了一个感叹号却没有继续打印星号。</p>
<p>归根结底还是因为 解除信号屏蔽 — 等待被信号打断 — 屏蔽信号 的这三个步骤不原子导致的。</p>
<p>sigsuspend(2) 函数我们在这篇博文的最后面还会讲解。</p>
<p>当使用 sigsuspend(2) 函数使这三个步骤原子化时我们再来分析一下程序的执行过程：</p>
<p>开始打印星号之前将 mask 位设置为 0，开始打印星号，此时如果接收到了信号 padding 被设置为 1，但是由于 mask 为 0 所以程序不会响应信号。当程序打印完星号时将 mask 位设置为 1，此时响应信号打印出感叹号，并原子化的解除信号屏蔽 + 被信号打断 + 重新屏蔽信号，然后继续开始打印下一行星号。</p>
<p>我们再来看另一种情况：开始打印星号之前将 mask 位设置为 0 并开始打印星号，当一行星号打印完成时没有收到信号，那么原子化的解除信号屏蔽并等待被信号打断。当信号到来时重新屏蔽信号并继续开始打印下一行星号。</p>
<p>根据上面的分析，只要 解除信号屏蔽 — 等待被信号打断 — 屏蔽信号 的这三个步骤原子化后就没问题了。当某件事情需要信号驱动时，在该事件未处理完成时又不希望再次被信号打断的时候，就可以采用类似的这种方式。</p>
<p>当然，这个这个程序是用标准信号实现的，所以标准信号的特点也被它集成了下来：当连续接收到多个信号时只能驱动打印一行星号，而不能收到多少个信号就打印多少行星号，因为标准信号会丢失。</p>
<p>如果想要让程序收到多少个信号就打印多少行星号，其实代码别的地方都不用修改，直接把信号集中的标准信号替换成实时信号就可以了，因为实时信号的特点是不丢失。代码很简单 LZ 就不贴出来了，感兴趣的小伙伴可以自己实验一下。</p>
<h3 id="8-2-sigpending-3P"><a href="#8-2-sigpending-3P" class="headerlink" title="8.2 sigpending(3P)"></a>8.2 sigpending(3P)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigpending - examine pending signals</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用于获取当前收到但是没有响应的信号。</p>
<p>它是一个系统调用，所以当它从内核中返回的时候需要对信号位图做 &amp; 操作，相应的信号已经被处理了，所以当它返回用户态的时候，它带回来的结果可能已经不准确了。</p>
<p>除非调用它之前先把所有的信号都 block 住，然后再调用它，返回的结果才是准确的。</p>
<p>目前还未发现这个函数在实际开发当中有什么作用，主要有两个理由：</p>
<p>　　1）该函数没有后续操作；</p>
<p>　　2）没有上面说的手段，取出来的信号集是不准确的。</p>
<h3 id="8-3-sigaction-2"><a href="#8-3-sigaction-2" class="headerlink" title="8.3 sigaction(2)"></a>8.3 sigaction(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigaction - examine and change a signal action</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数也是信号这章比较重要的一个函数。sigaction(2) 是用来替换 signal(2) 函数的。因为 signal(2) 有一些设计上的缺陷，所以小伙伴们学过了这个函数之后以后就尽量不要再使用 signal(2) 函数了。</p>
<p>参数列表：</p>
<p>　　signum：要设定信号处理函数的信号；</p>
<p>　　act：对信号处理函数的设定；</p>
<p>　　oldact：由函数回填之前的信号处理函数设定，备份用，如果不需要可以填 NULL。</p>
<p>下面看看 struct sigaction 这个结构体的成员表示什么意思：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前两个是信号处理函数，二选一，在某些平台上是一个共用体。</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>); <span class="comment">// 为了兼容 signal(2) 函数</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">// 第二个参数可以获得信号的来源和属性。第三个参数最原始时是 ucontext_t* 而不是 void*，与 setcontext(3) 有关，目前该参数已经禁止使用。</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask; <span class="comment">// 信号集位图，指定要处理的信号集，并且信号集中的任何一个信号被触发时，信号集中的其它成员同时会被 block，避免像 signal(2) 的信号处理函数一样当多个信号同时到来时发生重入。</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags; <span class="comment">// 特殊要求。如果使用三参的信号处理函数，需要指定为 SA_SIGINFO</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>); <span class="comment">// 基本被废弃了，不用管</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上一个参数的信号处理函数和三个参数的信号处理函数使用哪个都行，一般一个参数的就够用了。假设你的程序需要区分信号的来源或属性信息，那么就需要使用三参的信号处理函数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid =  fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup2(fd, <span class="number">0</span>);</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    dup2(fd, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&gt;<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    setsid();</span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"><span class="comment">//  umask(0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    closelog();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    sa.sa_handler = daemon_exit;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGTERM);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGINT);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//   signal(SIGINT, daemon_exit);</span></span><br><span class="line"><span class="comment">//   signal(SIGQUIT, daemon_exit);</span></span><br><span class="line"><span class="comment">//   signal(SIGTERM, daemon_exit);</span></span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>, LOG_PID, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(daemonize())</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">"daemonize() failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_INFO, <span class="string">"daemonize() successed"</span>); <span class="comment">// 结尾写 \n 会被当作文本</span></span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">"fopen(): %s"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syslog(LOG_INFO, <span class="string">"%s was opend."</span>, FNAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, i);</span><br><span class="line">        fflush(fp);</span><br><span class="line">        syslog(LOG_DEBUG, <span class="string">"%d is printed."</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下两句执行不到，因为守护进程一定是异常中止。因为守护进程脱离控制终端，一定会是kill pid的</span></span><br><span class="line">    <span class="comment">// 方式杀死。所以没办法做一个收尾的工作，释放资源等等。</span></span><br><span class="line">    <span class="comment">// fclose(fp);</span></span><br><span class="line">    <span class="comment">// closelog();</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们再来说说 signal(2) 函数哪里不靠谱。</p>
<p>还记得使用 signal(2) 函数注册的信号处理函数的原型吗？它的参数 s 的作用被设计出来的目的是为了让信号处理函数区别出来是哪个信号触发了它，也就是允许多个不同的信号共用同一个信号处理函数，并且动作可以不一样，可以根据 s 的不同做不同的事。</p>
<p>下面举一个简单的小栗子给大家演示一下如何使用 sigaction(2) 代替 signal(2)，以及为什么说 signal(2) 函数是不靠谱的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME        <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//      syslog(LOG_ERR,"fork():%s",strerror(errno));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">    dup2(fd,<span class="number">0</span>);</span><br><span class="line">    dup2(fd,<span class="number">1</span>);</span><br><span class="line">    dup2(fd,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &gt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    closelog();</span><br><span class="line">    syslog(LOG_INFO,<span class="string">"daemonize exited."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    如果使用 signal(2) 函数则是这样注册信号处理函数</span></span><br><span class="line"><span class="comment">//    signal(SIGINT,daemon_exit);</span></span><br><span class="line"><span class="comment">//    signal(SIGTERM,daemon_exit);</span></span><br><span class="line"><span class="comment">//    signal(SIGQUIT,daemon_exit);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  现在改用 sigaction(2) 来替代 signal(2) 函数</span></span><br><span class="line">    sa.sa_handler = daemon_exit;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGTERM);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGINT);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGINT,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line">    sigaction(SIGTERM,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line">    sigaction(SIGQUIT,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>,LOG_PID,LOG_DAEMON);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  启动守护进程</span></span><br><span class="line">    <span class="keyword">if</span>(daemonize())</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"daemonize() failed."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_INFO,<span class="string">"daemonize() successed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME,<span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"fopen():%s"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>,i);</span><br><span class="line">        fflush(fp);</span><br><span class="line">        syslog(LOG_DEBUG,<span class="string">"%d was printed."</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，就是启动一个守护进程每秒钟向 /tmp/out 文件输出一个序列。</p>
<p>上面的代码动机是好的，注册了三个信号处理函数，企图将异常结束行为改变为正常结束行为。但是信号处理函数中并不需要区分不同的信号，只要任何一个信号到来想要杀死进程的时候把资源释放掉再结束即可。</p>
<p>所以有一个重要的缺陷：当多个信号同时到来的时候，一定会发生内存泄漏。因为 signal(2) 函数在一个信号到来的时候不会把其它注册了同一个信号处理函数的信号屏蔽掉。</p>
<p>上面已经说过了，sigaction(2) 在收到信号集中的任何一个信号的时候，都会将信号集中的其它信号屏蔽掉，所以就会避免信号处理函数发生重入。上面的代码改成使用 sigaction(2) 的方式实现就变得安全了。</p>
<h3 id="8-4-setjmp-3-和-sigsetjmp-3-函数"><a href="#8-4-setjmp-3-和-sigsetjmp-3-函数" class="headerlink" title="8.4 setjmp(3) 和 sigsetjmp(3) 函数"></a>8.4 setjmp(3) 和 sigsetjmp(3) 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setjmp, sigsetjmp - save stack context for nonlocal goto</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们前面说过，在信号处理函数中是不能使用跨函数的长跳转的还记得吗？是因为进入处理函数之前系统会帮我们屏蔽对应的信号掩码，而当信号处理完成的时候系统会帮我们还原信号掩码。如果我们在信号处理函数中跳走了，那么信号掩码就不会被还原了，可能会造成当前进程再也无法接收到该信号了。</p>
<p>setjmp(3) 在 FreeBSD 平台上和其他平台上的实现不一致。FreeBSD 在跳转的时候还会保存信号掩码，并且在跳转的时候恢复信号掩码，所以在 FreeBSD 上使用 setjmp(3) 从信号处理函数中跳转是安全的。</p>
<p>由于其它平台的实现在跳转时不支持恢复信号掩码，大家一定猜到了为什么又出现了一个 sigsetjmp(3) 函数了。</p>
<p>果然标准再一次跳出来和稀泥了，制定了 sigsetjmp(3) 函数。</p>
<p>sigsetjmp(3) 函数的参数：如果 savesigs 为真，表示与 FreeBSD 平台的 setjmp(3) 实现相同，否则跳转时不保存信号掩码。就这么一点差别，仅此而已。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> sigjmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sigsetjmp(env, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before %s\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end %s\n"</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before %s\n"</span>, __FUNCTION__);</span><br><span class="line">    siglongjmp(env, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end %s\n"</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line">    fun();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, i);</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 编译运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ gcc -Wall siglongjmp.c -o siglongjmp</span><br><span class="line">&gt;$ ./siglongjmp </span><br><span class="line">before fun</span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line"><span class="built_in">end</span> fun</span><br><span class="line"><span class="number">0</span></span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line"><span class="built_in">end</span> fun</span><br><span class="line"></span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br><span class="line">&gt;$</span><br></pre></td></tr></table></figure>


<p>从上面的执行结果可以看出来，第一次执行 fun() 函数的时候设置了跳转点，在 fun() 函数执行完成之前发送 SIGINT 信号使程序切换到 handler() 函数运行，并且在 handler() 函数中再次跳转到 fun() 函数。在 fun() 函数运行结束之前再次发送信号依然可以被程序看到，说明 siglongjmp(3) 在跳转的时候确实恢复信号掩码了。</p>
<p>但是继续往下看，当 fun() 函数执行完毕时再次发送 SIGINT 信号给程序，handler() 函数会再次被调用，但是当从 handler() 跳转到 fun() 函数的时候出现段错误了！</p>
<p>为什么呢？经过 LZ 实验发现：siglongjmp(3) 函数只能从信号处理函数中跳转到当前被打断的函数，而不能随意跳转到其它函数中！（信号处理的过程可以见上面的图1）</p>
<p>也就是说当 fun() 函数在运行时被打断，从内核态回到用户态时发现收到了信号，这时候跳转到信号处理函数中运行，这个信号处理函数如果使用 siglongjmp(3) 函数进行跳转，则只能跳转到 fun() 函数中，否则会报段错误。</p>
<p>同理，上面的代码当 fun() 函数运行结束时回到 main() 函数继续运行，在 main() 被打断后进入内核排队等待被调度，当它获得调度机会从内核态回到用户态时发现收到了信号并且需要处理，这个时候信号处理函数 handler() 开始运行，如果信号处理函数需要使用 siglongjmp(3) 进行跳转，那么它只能选择跳转到 main() 函数中，而不能跳转到其它函数中。因为前面 LZ 说了，当前被打断的是 main() 函数，谁被打断就只能跳转到谁那去。这时候信号处理函数依然选择跳转到 fun() 函数中，所以引发了段错误。</p>
<p>为什么会有这么奇怪的现象 LZ 也不明白，估计跟执行现场有关系，各位如果知道是什么原因的话请在留言中告诉 LZ 哈。</p>
<h3 id="8-5-sigsuspend-2"><a href="#8-5-sigsuspend-2" class="headerlink" title="8.5 sigsuspend(2)"></a>8.5 sigsuspend(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigsuspend - wait for a signal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>与pause之间的区别</li>
</ul>
<p>这个函数我们在上面已经见过了， 它就是为了解决解除信号阻塞和 pause(2) 之间不原子的问题。</p>
<p>如果本来程序期望的是解除该信号的阻塞之后用 pause(2) 来等待被该信号打断，结果这个信号在解除阻塞和 pause(2) 之间到来了，这就导致它无法打断 pause(2) 了，因为它是在进行 pause(2) 之前到来的。如果后面不会再见到该信号，那么 pause(2) 将永远阻塞下去。</p>
<p>我们用下面的栗子来说明这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"!"</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oset,saveset;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">   sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//  sigprocmask 和 pause 不原子</span></span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;oset,<span class="literal">NULL</span>);</span><br><span class="line">        pause();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oset,saveset;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">   sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line">   sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line">        sigsuspend(&amp;oset); <span class="comment">// 原子操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sigset_t tmpset;</span></span><br><span class="line"><span class="comment">        //  sigprocmask 和 pause 不原子</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;oset, &amp;tmpset);</span></span><br><span class="line"><span class="comment">        pause();</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;tmpset, NULL);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序跟上面的栗子类似，每秒钟打印一个星号，每 5 个星号组成一行，只有当一行星号打印完毕时才响应 SIGINT 信号。</p>
<p>如果解除阻塞和等待信号打断不采用原子操作，那么在 pause(2) 之前收到了信号就无法驱动下一行星号的打印了。</p>
<p><strong>测试一个东西</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">cd</span>  /apue/parallel/signal/mytbf</span><br><span class="line">make</span><br><span class="line">./mytbf /etc/services</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">kill</span> - ALRM 45625 ; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 从user角度，给一个指定的进程发 alrm信号。你会发现流控已经不成立了。这个问题 signal 解决不了。问题是根源是 signal并没有管信号的来源，信号的属性信息，它要做的是，你只要来一个信号，我给这个信号注册一个行为了，那就执行这个信号的行为。它并没有区分信号的来源是哪儿，而直接执行这个信号的行为。如何能区分信号的来源了，那就好办了，可以只响应从kernel来的信号。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br></pre></td></tr></table></figure>

<p>这个问题需要用到 sigaction 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef void (*sighandler_t)(int);</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span>* <span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> inited = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//static sighandler_t  alrm_handler_save;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">alrm_sa_save</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;</span><br><span class="line">    <span class="keyword">int</span> burst;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//   signal(SIGALRM, alrm_handler_save);</span></span><br><span class="line"><span class="comment">//   alarm(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM, &amp;alrm_sa_save, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    itv.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">    itv.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    itv.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">    itv.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;itv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(job[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">get_free_pos</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_action</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//    alarm(1);</span></span><br><span class="line">    <span class="keyword">if</span>(infop -&gt; si_code != SI_KERNEL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i]!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">            <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//   alrm_handler_save = signal(SIGALRM, alrm_handler);</span></span><br><span class="line"><span class="comment">//   alarm(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line"></span><br><span class="line">    sa.sa_sigaction = alrm_action;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM, &amp;sa, &amp;alrm_sa_save);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if error */</span></span><br><span class="line">    itv.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    itv.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    itv.it_value.tv_sec = <span class="number">1</span>;</span><br><span class="line">    itv.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;itv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inited)</span><br><span class="line">    &#123;</span><br><span class="line">        module_load();</span><br><span class="line">    inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = get_free_pos();  <span class="comment">// 在数组中 找空位</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me; <span class="comment">//将该结构体存储至 数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> * ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    job[me -&gt; pos] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数可以指定 响应从 哪儿来的信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction * act,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sigaction * oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用sigaction 重构 mytbf库，在信号处理函数当中。<br>在alarm前面加 if判断，只有是kernel来的就响应，不是kernel来的一概不响应。</p>
<h3 id="8-6-实时信号"><a href="#8-6-实时信号" class="headerlink" title="8.6 实时信号"></a>8.6 实时信号</h3><blockquote>
<p>标准信号会丢失，因为是用位图来进行记录的。 标准信号的响应没有严格的顺序，实时信号的产生是为了解决标准信号的不足。<br>首先实时信号是需要排队的，其次实时信号的响应有一个顺序要求。标准信号的响应无顺序，不能说它是随机响应。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYRTSIG (SIGRTMIN+6)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mysig_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line"></span><br><span class="line">    signal(MYRTSIG, mysig_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, MYRTSIG);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给 17177 号进程发信号</span></span><br><span class="line"><span class="built_in">kill</span> -40 57245</span><br><span class="line"><span class="built_in">kill</span> -40 57245</span><br><span class="line"><span class="built_in">kill</span> -40 57245</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续发送三次信号，我们发现 程序连续执行了三次。</span></span><br><span class="line"><span class="comment"># 说明实时信号能做到 信号不丢失 （实时信号和标准信号的区别就在于此）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然这个信号也无法无休止的发的，也是有资源上限的</span></span><br><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line"></span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-m: resident <span class="built_in">set</span> size (kbytes)      unlimited</span><br><span class="line">-u: processes                       7144</span><br><span class="line">-n: file descriptors                1024</span><br><span class="line">-l: locked-in-memory size (kbytes)  64</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 7144  <span class="comment"># pending signals 实时信号上限</span></span><br><span class="line">-q: bytes <span class="keyword">in</span> POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以 ulimit -i 来更改这个最大实时信号的上限</span></span><br></pre></td></tr></table></figure>

<h3 id="8-7-有关信号的其它内容"><a href="#8-7-有关信号的其它内容" class="headerlink" title="8.7 有关信号的其它内容"></a>8.7 有关信号的其它内容</h3><p>除了 kill -l 可以查看所有的信号，还可以通过 /usr/include/bits/signum.h 文件查看。</p>
<p>实时信号会按照先到先响应的顺序处理，并且信号会排队，不会丢失。</p>
<p>信号是否排队、是否丢失，不取决于使用哪个函数，而是取决于使用哪种信号。</p>
<p>实时信号具有这些特点是因为它不是采用位图实现的，而是采用链式结构实现的。</p>
<p>其它方面与标准信号没有区别。</p>
<p>信号处理函数中只能安全的使用可重入函数（所有系统调用都是可重入函数）和所有的科学计算（科学计算都是可重入的），编写信号处理函数要时刻防止重入发生。</p>
<p>尽量不要大范围的混用信号和多线程，如果在小范围内信号 + 多线程可以方便的解决某个问题时才可以在小范围内混用它们</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>实际上，使用多线程并发要比信号并发简单的多。</p>
</blockquote>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2020/12/16/apue-6/>http://yoursite.com/2020/12/16/apue-6/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-04-28T18:52:32+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Apr 28, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/doc/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>doc</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2020/12/16/apue-6/&title=信号 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2020/12/16/apue-6/&title=信号 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2020/12/16/apue-6/&title=信号 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/12/16/apue-1/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>标准io</p>
                <p class='content'>APUEAPUE主要讨论了三部分内容：文件IO、并发、进程间通信。
*文件IO: *
标准IO：优点是可移植性高，缺点是性能比系统 IO 差，且功能没有系统 IO 丰富。系统IO：因为是内核直接...</p>
              </a>
            
            
              <a class='next' href='/2020/12/16/apue-11/'>
                <p class='title'>socket<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>socket

如图所示，socket 可以理解为中间层。底层是若干不同的协议来完成协议族的指定，上层可以是不同的网络实现方式（流失传输，报式传输等等）。在不同的协议族当中对于这些不同的网络实现...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '信号',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-并发"><span class="toc-text">1. 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-同步、异步，-异步意味着并发"><span class="toc-text">1.1  同步、异步， 异步意味着并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-异步事件的获取方式通常只有两种：查询法，通知法"><span class="toc-text">1.2  异步事件的获取方式通常只有两种：查询法，通知法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-那么什么情况使用查询法更好，什么情况使用通知法更好呢？"><span class="toc-text">1.3  那么什么情况使用查询法更好，什么情况使用通知法更好呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-没有严格意义上的通知法"><span class="toc-text">1.4  没有严格意义上的通知法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-异步"><span class="toc-text">1.5  异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-信号的概念"><span class="toc-text">2. 信号的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-信号会打断阻塞的系统调用"><span class="toc-text">2.1 信号会打断阻塞的系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-竞争"><span class="toc-text">2.2 竞争</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-信号的不可靠"><span class="toc-text">3. 信号的不可靠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-可重入函数"><span class="toc-text">4. 可重入函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-信号的响应过程"><span class="toc-text">5. 信号的响应过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-可靠信号术语和语义"><span class="toc-text">6.1 可靠信号术语和语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-信号处理函数"><span class="toc-text">6.2 信号处理函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-信号常用函数"><span class="toc-text">6. 信号常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-kill-2"><span class="toc-text">6.1 kill(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-raise"><span class="toc-text">6.2 raise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-pause-3P"><span class="toc-text">6.3 pause(3P)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-alarm-3P"><span class="toc-text">6.4 alarm(3P)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-流量控制（流控算法）"><span class="toc-text">6.5 流量控制（流控算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-封装令牌桶库"><span class="toc-text">6.6 封装令牌桶库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-实现计时器"><span class="toc-text">6.7 实现计时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-sleep"><span class="toc-text">6.8 sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-nanosleep"><span class="toc-text">6.9 nanosleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-usleep"><span class="toc-text">6.10 usleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-abort-3"><span class="toc-text">6. 11 abort(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-system-3"><span class="toc-text">6.12 system(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-13-select-2"><span class="toc-text">6.13 select(2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-信号集"><span class="toc-text">7. 信号集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-信号屏蔽字-pending集的处理"><span class="toc-text">8. 信号屏蔽字&#x2F;pending集的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-sigprocmask-2"><span class="toc-text">8.1 sigprocmask(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-sigpending-3P"><span class="toc-text">8.2 sigpending(3P)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-sigaction-2"><span class="toc-text">8.3 sigaction(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-setjmp-3-和-sigsetjmp-3-函数"><span class="toc-text">8.4 setjmp(3) 和 sigsetjmp(3) 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-sigsuspend-2"><span class="toc-text">8.5 sigsuspend(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-实时信号"><span class="toc-text">8.6 实时信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-有关信号的其它内容"><span class="toc-text">8.7 有关信号的其它内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
