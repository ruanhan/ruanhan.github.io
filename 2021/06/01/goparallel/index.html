<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>goparallel - Hexo</title>
  
    <meta name="keywords" content="guide">
  
  
    <meta name="description" content="go并行和并发">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2021/06/01/goparallel/">
      goparallel
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/go/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>go</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Jun 1, 2021</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="1-并行与并发"><a href="#1-并行与并发" class="headerlink" title="1. 并行与并发"></a>1. 并行与并发</h2><h3 id="1-1-并行（parallel）"><a href="#1-1-并行（parallel）" class="headerlink" title="1.1 并行（parallel）"></a>1.1 并行（parallel）</h3><blockquote>
<p>并行，同一时刻，有多条指令在多个处理器上同时执行。并行需要借助多核cpu实现。</p>
</blockquote>
<h3 id="1-2-并发"><a href="#1-2-并发" class="headerlink" title="1.2 并发"></a>1.2 并发</h3><p>宏观：在用户体验上，程序在并行执行</p>
<p>微观：多个计划任务，顺序执行。在飞快的切换，轮换使用cpu时间轮片；（cpu时间调度算法）</p>
<p>进程状态：</p>
<p>初始态、 就绪态、 运行态、 挂起（阻塞）态、终止（停止）态</p>
<p>线程并发：</p>
<p>什么是线程</p>
<p>Lwp（light weight process）轻量级进程，本质上仍是进程（Linux下）</p>
<p>进程： 独立地址空间，拥有PCB</p>
<p>线程： 有独立的PCB，但没有独立的地址空间（共享）</p>
<p>区别： 在于是否共享地址空间，独居（进程）； 合租（线程）</p>
<p>线程： 最小的执行单位</p>
<p>进程： 最小分配资源单位，可看成是只有一个线程的进程；</p>
<h3 id="1-3-线程同步"><a href="#1-3-线程同步" class="headerlink" title="1.3 线程同步"></a>1.3 线程同步</h3><p>同步即协同步调，按预定的先后次序运行。</p>
<p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回，同时其它线程为保证数据一致性，不能调用该功能；</p>
<p>举例：A，B两张银行卡取钱。当两个线程访问共享资源时，如果没有协调机制，会产生与时间有关的错误。—— 锁</p>
<p>因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</p>
<h4 id="1-3-1-线程同步机制："><a href="#1-3-1-线程同步机制：" class="headerlink" title="1.3.1 线程同步机制："></a>1.3.1 线程同步机制：</h4><p>互斥锁（互斥量）：建议锁，拿到锁以后，才能访问数据，没有拿到锁的线程，阻塞等待。等到拿锁的线程释放锁。</p>
<p>读写锁： 一把锁（读属性、写属性），写独占，读共享，写锁优先级高 </p>
<p>信号量：</p>
<p>条件变量：</p>
<h3 id="1-4-协程并发"><a href="#1-4-协程并发" class="headerlink" title="1.4 协程并发"></a>1.4 协程并发</h3><p>协程： coroutine，也叫轻量级线程。</p>
<p>与传统系统级线程和进程相比，协程最大优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源崩溃。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。</p>
<p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行。多个协程分享该线程分配到的计算机资源。</p>
<p>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</p>
<h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>在一次并发任务中，进程、线程、协程都可以实现，从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。</p>
<p>进程并发：优点是稳定性强，开销较线程大。</p>
<p>线程并发：优点是节省资源，尤其是调度时，线程与线程之间切换的时候。而进程间切换的开销就比较大一些。</p>
<p>协程并发： 效率高，系统利用率高</p>
<h2 id="2-goroutine"><a href="#2-goroutine" class="headerlink" title="2. goroutine"></a>2. goroutine</h2><p>Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP（communicating sequential processes）。这就意味着显式锁都是可以避免的。因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p>
<p>Go语言中的并发程序主要是用两种手段来实现。goroutine 和 channel</p>
<h3 id="3-1-概论"><a href="#3-1-概论" class="headerlink" title="3.1 概论"></a>3.1 概论</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> sing()</span><br><span class="line">  <span class="keyword">go</span> dance()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="goroutine1.png" alt="image-20210325101308012"></p>
<p>Goroutine 的并发机制；main goroutine中的for{} 占据较长的时间。可以确保两个goroutine能执行完毕；</p>
<p><strong>Goroutine的特性：</strong></p>
<p>主go程结束，子go程随之退出；</p>
<p>在Go里，无需修改现有顺序式的代码，就可以通过goroutine以并发的方式运行任意数量的任务；</p>
<h4 id="3-1-1-启动goroutine"><a href="#3-1-1-启动goroutine" class="headerlink" title="3.1.1 启动goroutine"></a>3.1.1 启动goroutine</h4><p>只需在调用前面加一个go关键字；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> sleepGopher() <span class="comment">// go 关键字相当于启动一个 goroutine,另开辟了一条道路，在那条道路里面执行。然后main函数是一条主干道。主干道继续往下执行，当main函数返回的时候，该程序运行的所有goroutine都会立即停止，无论有没有走完。</span></span><br><span class="line">  <span class="comment">//所以想在main函数返回之前让 sleepGopher 函数输出 ...snore... 的话，就需要多等待一段时间，已知 sleepGopher sleep了3秒，所以选择让main函数sleep了4秒</span></span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">// 3*time.Second = 3s</span></span><br><span class="line">	fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-1-2-不止一个goroutine"><a href="#3-1-2-不止一个goroutine" class="headerlink" title="3.1.2 不止一个goroutine"></a>3.1.2 不止一个goroutine</h4><p>每次使用go关键字都会产生一个新的goroutine</p>
<p>表面上看，goroutine似乎在同时运行，但由于计算机处理单元有限，其实技术上来说，这些goroutine不是真的在同时运行；</p>
<ul>
<li>计算机处理器会使用“分时”技术，在多个goroutine上轮流花费一些时间；</li>
<li>在使用goroutine时，各个goroutine的执行顺序无法确定；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-1-3-goroutine的参数"><a href="#3-1-3-goroutine的参数" class="headerlink" title="3.1.3 goroutine的参数"></a>3.1.3 goroutine的参数</h4><p>向goroutine传递参数就根向函数传递参数一样，参数都是按值传递的（传入的是副本）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"...snore..."</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...snore... 2</span></span><br><span class="line"><span class="comment">// ...snore... 3</span></span><br><span class="line"><span class="comment">// ...snore... 0</span></span><br><span class="line"><span class="comment">// ...snore... 1</span></span><br><span class="line"><span class="comment">// ...snore... 4</span></span><br></pre></td></tr></table></figure>

<p>在使用goroutine时，各个goroutine的执行顺序无法确定；</p>
<h3 id="3-2-runtime包"><a href="#3-2-runtime包" class="headerlink" title="3.2 runtime包"></a>3.2 runtime包</h3><h4 id="3-2-1-Gosched"><a href="#3-2-1-Gosched" class="headerlink" title="3.2.1 Gosched"></a>3.2.1 Gosched</h4><p>runtime.Gosched() 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次再获得cpu时间轮片的时候，从该让cpu的位置恢复执行。</p>
<p>当再次获得cpu时，从出让位置继续回复执行；</p>
<p>—— 时间片轮转调度算法；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"this is goroutine"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    runtime.Gosched() <span class="comment">// </span></span><br><span class="line">		fmt.Println(<span class="string">"this is main test"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-Goexit"><a href="#3-2-2-Goexit" class="headerlink" title="3.2.2 Goexit"></a>3.2.2 Goexit</h4><p>调用runtime.Goexit(), 将立即终止 当前goroutine执行，调度器确保所有已注册defer延迟调用被执行；</p>
<p>return和Goexit之间的差异</p>
<p>return：返回当前函数调用给调用者；后续语句不糊执行了。return之前的defer生效，之后的defer不生效了；</p>
<p>Goexit：结束调用该函数的当前goroutine，Goexit()之前注册的defer都生效；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">"ccc"</span>)</span><br><span class="line">  runtime.Goexit();</span><br><span class="line">  fmt.Println(<span class="string">"ddd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"aaa"</span>)</span><br><span class="line">    test()</span><br><span class="line">    fmt.Println(<span class="string">"bbb"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">for</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// aaa</span></span><br><span class="line"><span class="comment">// ccc</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-runtime-GOMAXPROCS"><a href="#3-2-3-runtime-GOMAXPROCS" class="headerlink" title="3.2.3 runtime.GOMAXPROCS()"></a>3.2.3 runtime.GOMAXPROCS()</h4><p>调用runtime.GOMAXPROCS() 设置可以并行计算的CPU核数最大值，并返回之前的值；</p>
<p>返回值：上一次设置的核心数</p>
<h2 id="3-channel"><a href="#3-channel" class="headerlink" title="3. channel"></a>3. channel</h2><p>channel是Go语言中的一个核心类型，可以把它看成管道（FIFO，first in ，first out）。并发核心单元通过它就可以发送或接收数据进行通讯，这在一定程度上又进一步降低了编程难度；</p>
<p>channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享的问题</p>
<p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步，<code>goroutine奉行通过通信来共享内存，而不是共享内存来通信；</code></p>
<p>引用类型channel可用于多个gouroutine通讯，其内部实现了同步，确保并发安全；</p>
<p>CSP是Communicating Sequential Process的简称，直译为通讯顺序进程，或者叫做交换信息的循序进程，是用来描述并发系统中进行交互的一种模式；</p>
<p>csp允许使用进程组件来描述系统，它们独立运行，并且只通过消息传递的方式通信；go通过引入Channel这个新的类型，来实现CSP的思想；</p>
<p>Don‘t  communicate by sharing memory, share memory by communication; (执行业务处理的goroutine不要通过共享内存的方式通信，而是要通过Channel通信的方式分享数据)</p>
<p>Don‘t  communicate by sharing memory:  是传统的并发编程处理方式，就是指，共享的数据需要锁保护，goroutine需要获取到锁，才能并发访问数据；</p>
<p> share memory by communication：类似CSP模型的方式，通过通信的方式，一个goroutine可以把数据“所有权”交给另外一个goroutine；</p>
<ul>
<li>啥时候用channel</li>
</ul>
<p>Go开发者极力推荐使用channel，不过，这两年，大家意识到，channel并不是处理并发问题的“银弹”，有时候使用并发原语更简单，并且不容易出错。</p>
<ol>
<li>共享资源的并发访问使用传统并发原语；</li>
<li>复杂的任务编排和消息传递使用channel；</li>
<li>消息通知机制使用channel，除非只想signal一个goroutine，才使用Cond；</li>
<li>简单等待所有任务的完成用WaitGroup，也有Channel的推崇者用Channel，都可以；</li>
<li>需要和Select语句结合，使用Channel；</li>
<li>需要和超时配合时，使用Channel和Context；</li>
</ol>
<h3 id="3-0-channel应用场景的五种类型"><a href="#3-0-channel应用场景的五种类型" class="headerlink" title="3.0 channel应用场景的五种类型"></a>3.0 channel应用场景的五种类型</h3><h4 id="3-0-1-数据交流"><a href="#3-0-1-数据交流" class="headerlink" title="3.0.1 数据交流"></a>3.0.1 数据交流</h4><blockquote>
<p>当作并发的buffer或者queue，解决生产者 - 消费者问题。多个goroutine可以并发当作生产者（producer）和消费者(Consumer)</p>
</blockquote>
<h4 id="3-0-2-数据传递"><a href="#3-0-2-数据传递" class="headerlink" title="3.0.2 数据传递"></a>3.0.2 数据传递</h4><blockquote>
<p>一个goroutine将数据交给另一个goroutine，相当于把数据的拥有权（引用）托付出去；</p>
</blockquote>
<ul>
<li><p>例题：有4个goroutine，编号为，1，2，3，4 没秒会有一个goroutine打印出它自己的编号，要求你编写程序，让输出的编号总是按照1，2，3，4，1，2，3，4.。。 这个顺序打印出来；</p>
<p>为了实现顺序的数据传递，可以定一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌传递给下一个goroutine，我们尝试使用chan来实现；</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// select，通过select 可以监听channel上的数据流动</span></span><br><span class="line"><span class="comment">// 如果给出default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复</span></span><br><span class="line"><span class="comment">// 如果没有default语句，那么select语句将会被阻塞，直到至少有一个通信可以进行下去</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWorker</span><span class="params">(id <span class="keyword">int</span>, ch <span class="keyword">chan</span> Token, nextCh <span class="keyword">chan</span> Token)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		token := &lt;-ch       <span class="comment">// 从自己的chan 中读取令牌</span></span><br><span class="line">		fmt.Println(id + <span class="number">1</span>) <span class="comment">// id 从1开始</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		nextCh &lt;- token</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for &#123;</span></span><br><span class="line">	<span class="comment">//	token := &lt;- chs[0]</span></span><br><span class="line">	<span class="comment">//	fmt.Println(0 + 1)</span></span><br><span class="line">	<span class="comment">//	time.Sleep(time.Second)</span></span><br><span class="line">	<span class="comment">//	chs[1] &lt;- token</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//for &#123;</span></span><br><span class="line">	<span class="comment">//	token := &lt;-chs[1]</span></span><br><span class="line">	<span class="comment">//	fmt.Println(1 + 1)</span></span><br><span class="line">	<span class="comment">//	time.Sleep(time.Second)</span></span><br><span class="line">	<span class="comment">//	chs[2] &lt;- token</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//for &#123;</span></span><br><span class="line">	<span class="comment">//	token := &lt;- chs[2]</span></span><br><span class="line">	<span class="comment">//	fmt.Println(2 + 1)</span></span><br><span class="line">	<span class="comment">//	time.Sleep(time.Second)</span></span><br><span class="line">	<span class="comment">//	chs[3] &lt;- token</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//for &#123;</span></span><br><span class="line">	<span class="comment">//	token := &lt;-chs[3]</span></span><br><span class="line">	<span class="comment">//	fmt.Println(3 + 1)</span></span><br><span class="line">	<span class="comment">//	time.Sleep(time.Second)</span></span><br><span class="line">	<span class="comment">//	chs[0] &lt;- token</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	chs := []<span class="keyword">chan</span> Token&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token)&#125;</span><br><span class="line">	<span class="comment">// 创建4个worker</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> newWorker(i, chs[i], chs[(i+<span class="number">1</span>)%<span class="number">4</span>]) <span class="comment">// 启动每个worker的goroutine</span></span><br><span class="line">		<span class="comment">//newWorker(0, chs[0], chs[1])</span></span><br><span class="line">		<span class="comment">//newWorker(1, chs[1], chs[2])</span></span><br><span class="line">		<span class="comment">//newWorker(2, chs[2], chs[3])</span></span><br><span class="line">		<span class="comment">//newWorker(3, chs[3], chs[0])</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 首先把令牌交给第一个worker</span></span><br><span class="line">	chs[<span class="number">0</span>] &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面注释代码所示，channel实现顺序打印1，2，3，4.实际上就是利用token的，来将多个channel串联；因为每个for循环中的channel如果在读写两端没有数据写入或读取的话。channel是被阻塞挂起的；</p>
<p>这类场景有一个特点，就是当前持有数据的goroutine都有一个信箱，信箱使用chan实现，goroutine只需要关注自己的信箱中的数据，处理完毕后，就把结果发送到下一家的信箱中；</p>
<h4 id="4-0-3-信号通知"><a href="#4-0-3-信号通知" class="headerlink" title="4.0.3 信号通知"></a>4.0.3 信号通知</h4><blockquote>
<p>一个goroutine可以将信号（closing，closed, data ready等）传递给另一个或者另一组goroutine</p>
<p>chan类型有这样一个特点，chan如果为空，那么receiver接收数据的时候就会阻塞等待，直刀chan被关闭或者有新的数据到来，利用这个机制，我们可以实现wait/notify的设计模式；</p>
</blockquote>
<p>除了正常业务处理时的wait/notify，经常碰到的一个场景，就是程序关闭的时候，我们需要在退出之前做一些清理，这个时候，经常用到chan</p>
<ul>
<li>退出的时候分为两个阶段</li>
</ul>
<ol>
<li>closing，代表程序退出，但是清理工作还没做</li>
<li>closed，代表清理工作已经做完；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/signal"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> closing = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> closed = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-closing:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// .... 业务计算</span></span><br><span class="line">				time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理 ctrl+c 等中断信号</span></span><br><span class="line">	termChan := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-termChan</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(closing)</span><br><span class="line">	<span class="comment">// 执行退出之前的清理动作</span></span><br><span class="line">	<span class="keyword">go</span> doCleanup(closed)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-closed:</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">		fmt.Println(<span class="string">"清理超时，不等了"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"优雅退出"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCleanup</span><span class="params">(closed <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Minute)</span><br><span class="line">	<span class="built_in">close</span>(closed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-0-4-任务编排"><a href="#4-0-4-任务编排" class="headerlink" title="4.0.4 任务编排"></a>4.0.4 任务编排</h4><blockquote>
<p>可以让一组goroutine按照一定的顺序并发或者串行的执行，这就是编排的功能；</p>
</blockquote>
<p>多个chan的编排方式，共5种</p>
<h5 id="4-0-4-1-Or-Done模式"><a href="#4-0-4-1-Or-Done模式" class="headerlink" title="4.0.4.1 Or-Done模式"></a>4.0.4.1 Or-Done模式</h5><blockquote>
<p>使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义一个类型为chan struct{}类型的done变量，等通知任务结束后，我们就可以close这个变量，然后，其他receiver就会收到这个通知；</p>
<p>这是有一个任务的情况，如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是Or-Done模式</p>
<p>比如，你发送同一个请求到多个微服务节点，只要任意一个微服务节点返回结果，就算成功，实现如下</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// 特殊情况，只有0个或者1个chan</span></span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">		<span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 2也是一种特殊情况</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">			<span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 超过2个，二分递归处理</span></span><br><span class="line">			m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-or(channels[:m]...):</span><br><span class="line">			<span class="keyword">case</span> &lt;-or(channels[m:]...):</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sig</span><span class="params">(after time.Duration)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">		time.Sleep(after)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	&lt;-or(</span><br><span class="line">		sig(<span class="number">10</span>*time.Second),</span><br><span class="line">		sig(<span class="number">20</span>*time.Second),</span><br><span class="line">		sig(<span class="number">30</span>*time.Second),</span><br><span class="line">		sig(<span class="number">40</span>*time.Second),</span><br><span class="line">		sig(<span class="number">50</span>*time.Second),</span><br><span class="line">		sig(<span class="number">01</span>*time.Minute),</span><br><span class="line">	)</span><br><span class="line">	fmt.Printf(<span class="string">"done after %v"</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-0-4-2-扇入模式"><a href="#4-0-4-2-扇入模式" class="headerlink" title="4.0.4.2 扇入模式"></a>4.0.4.2 扇入模式</h5><h5 id="4-0-4-3-扇出模式"><a href="#4-0-4-3-扇出模式" class="headerlink" title="4.0.4.3 扇出模式"></a>4.0.4.3 扇出模式</h5><h5 id="4-0-4-4-Stream"><a href="#4-0-4-4-Stream" class="headerlink" title="4.0.4.4 Stream"></a>4.0.4.4 Stream</h5><blockquote>
<p>介绍一种把Channel当作流式管道使用的方式，也就是把Channel看作流（Stream）,提供跳过几个元素，或者是只取其中几个元素等方法</p>
</blockquote>
<p>下面这个方法一个数据slice转换成流</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asStream</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, values ...<span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(s)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123; <span class="comment">// 遍历数组</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> s &lt;- v: <span class="comment">// 将数组元素塞入chan中</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>流创建好之后，下面介绍实现流的方法</p>
<ol>
<li>takeN: 只取流中前n个数据</li>
<li>takeFn: 筛选流中数据，只保留满足条件的数据：</li>
<li>takeWhile: 只取前面满足条件的数据，一旦不满足条件，就不再取：</li>
<li>skipN: 跳过流中前几个数据；</li>
<li>skipFn: 跳过满足条件的数据；</li>
<li>skipWhile: 跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给Channel的receiver</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takeN</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, num <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> takeStream &lt;- &lt;-valueStream: <span class="comment">// 从输入流中读取元素</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> takeStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-0-4-5-Map-Reduce"><a href="#4-0-4-5-Map-Reduce" class="headerlink" title="4.0.4.5 Map-Reduce"></a>4.0.4.5 Map-Reduce</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapChan</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> in == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">		<span class="keyword">return</span> out</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 启动一个goroutine，实现map的主要逻辑</span></span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123; <span class="comment">// 从输入chan读取数据，执行业务操作，也就是map操作</span></span><br><span class="line">			out &lt;- fn(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(r, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> in == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	out := &lt;-in         <span class="comment">// 先读取第一个元素</span></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123; <span class="comment">// 实现reduce 主要逻辑</span></span><br><span class="line">		out = fn(out, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个程序，这个程序使用 map-reduce 模式处理一组整数，map函数就是为每个整数乘以10， reduce函数就是把map处理的结果累加起来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个数据流</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsStream</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(s)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123; <span class="comment">// 从数组生成</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> s &lt;- v:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	in := AsStream(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// map *10</span></span><br><span class="line">	mapFn := <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">return</span> v.(<span class="keyword">int</span>) * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// reduce 累加</span></span><br><span class="line">	reduceFn := <span class="function"><span class="keyword">func</span><span class="params">(r, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">return</span> r.(<span class="keyword">int</span>) + v.(<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sum := reduce(mapChan(in, mapFn), reduceFn) <span class="comment">// 返回累加结果</span></span><br><span class="line">	fmt.Println(sum)                            <span class="comment">// 150</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-0-5-锁"><a href="#4-0-5-锁" class="headerlink" title="4.0.5 锁"></a>4.0.5 锁</h4><blockquote>
<p>利用Channel也可以实现互斥锁的机制；</p>
<p>要想使用chan实现互斥锁，至少有两种方法，</p>
<p>一种方式是先初始化一个capacity等于1的channel，然后再放入一个元素。这个元素就代表锁，谁取得了这个元素，就相当于获取了这把锁。</p>
<p>另一种方式是，先初始化一个capacity等于1的channel，它的空槽代表锁，谁能成功把元素发送这个Channel，谁就获取了这把锁；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用锁需要初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutex</span><span class="params">()</span> *<span class="title">Mutex</span></span> &#123;</span><br><span class="line">	mu := &amp;Mutex&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)&#125;</span><br><span class="line">	mu.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> mu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求锁，直到获取</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-m.ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">TryLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-m.ch:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入一个超时的设置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">LockTimeout</span><span class="params">(timeout time.Duration)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(timeout)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-m.ch:</span><br><span class="line">		timer.Stop()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁四否已被持有</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">IsLocked</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.ch) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := NewMutex()</span><br><span class="line">	ok := m.TryLock()</span><br><span class="line">	fmt.Printf(<span class="string">"locked v %v\n"</span>, ok)</span><br><span class="line">	ok = m.TryLock()</span><br><span class="line">	fmt.Printf(<span class="string">"locked %v\n"</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//locked v true</span></span><br><span class="line"><span class="comment">//locked false</span></span><br></pre></td></tr></table></figure>

<p>用buffer等于1的chan实现互斥锁，在初始化这个锁的时候往Channel中先塞入一个元素，谁把这个元素取走，谁就获取这把锁，把元素放回去，就是释放了锁。元素在放回chan之前，不会有goroutine能从chan中取出元素的，这就保证了互斥性；</p>
<p>利用select+chan的方式，很容易实现TryLock，Timeout的功能。具体来说就是，在select语句中，我们可以使用default实现TryLock，使用一个Timer来实现Timeout的功能；</p>
<h3 id="4-1-channel语法"><a href="#4-1-channel语法" class="headerlink" title="4.1 channel语法"></a>4.1 channel语法</h3><p>channel可以在多个goroutine之间安全的传值；</p>
<p>通道可以用作变量、函数参数、结构体字段。。。</p>
<p>创建通道用make函数，并指定其传递数据的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>Channel类型分为 只能接收，只能发送，既可以接收又可以发送三种类型；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelType=(<span class="string">"chan"</span> | <span class="string">"chan"</span> <span class="string">"&lt;-"</span> | <span class="string">"&lt;-"</span> <span class="string">"chan"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> <span class="keyword">string</span>     <span class="comment">// 可以发送接收string</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 只能发送struct&#123;&#125;</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>       <span class="comment">// 只能从chan接收int</span></span><br></pre></td></tr></table></figure>



<p>channel是一个对应make创建的底层数据结构的引用；</p>
<p>当复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和 其它的引用类型一样，channel的零值也是nil</p>
<p>定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的make函数来创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type 指定channel收发数据的类型；</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type) <span class="comment">// 等价于 make(chan Type, 0) 容量为0 称为 unbuffered chan</span></span><br><span class="line"><span class="comment">// capacity 容量 </span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity)   <span class="comment">// 称为 buffered chan</span></span><br></pre></td></tr></table></figure>



<p>当参数 capacity=0 时，channel是无缓冲阻塞读写的，当capacity&gt;0 时，channel有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入；</p>
<p>channel一边可以存东西，另一边可以取东西。channel通过 &lt;- 来接收和发送数据，发送和接收数据语法；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel &lt;- value <span class="comment">// 发送value到channel</span></span><br><span class="line">&lt;- channel       <span class="comment">// 接收并将其丢弃</span></span><br><span class="line">x := &lt;-channel   <span class="comment">// 从channel中接收数据，并赋值给x</span></span><br><span class="line">x, ok:= &lt;-channel <span class="comment">// 功能同上，同时检查通道是否已经关闭或者是否为空</span></span><br></pre></td></tr></table></figure>

<p>nil是 chan的零值，是一种特殊的chan，对值是nil的chan的发送接收调用者总是会阻塞；</p>
<p>go内建的函数 close，cap，len都可以操作chan类型： close会把chan关闭掉，cap返回chan的容量，len返回chan中缓存的还未被取走的元素数量；</p>
<p><code>for range ch{}</code> 用于清空chan</p>
<h3 id="4-2-channel实现原理"><a href="#4-2-channel实现原理" class="headerlink" title="4.2 channel实现原理"></a>4.2 channel实现原理</h3><h4 id="4-2-1-channel的数据结构"><a href="#4-2-1-channel的数据结构" class="headerlink" title="4.2.1 channel的数据结构"></a>4.2.1 channel的数据结构</h4><p><img src="chan1.jpg" alt=""></p>
<ul>
<li>qcount ：代表chan中已经接收但还没被取走的元素的个数，内建函数len可以返回这个字段的值；</li>
<li>dataqsiz： 队列的大小，chan使用一个循环队列存放元素，循环队列很适合这种生产者 - 消费者的场景；</li>
<li>buf： 存放元素的循环队列的buffer</li>
<li>elemtype 和elemsize： chan中元素的类型和size，因为chan一旦声明，它的元素类型是固定的，即普通类型或者指针类型，所以元素大小也是固定的；</li>
<li>sendx： 处理发送数据的指针在buf中的位置，一旦接收了新的数据，指针就会加上elemsize，移向了下一个位置。buf的总大小是elemsize的整数倍，而且buf是一个循环列表</li>
<li>recvx： 处理接收请求时的指针在buf中的位置，一旦取出数据，此指针会移动到下一个位置</li>
<li>recvq： chan是多生产者多消费者的模式，如果消费者因为没有数据可读而被阻塞了，就会被加入到recvq队列中；</li>
<li>sendq：如果生产者因为buf满了而阻塞，会被加入到sendq队列中； </li>
</ul>
<h3 id="4-2-groutine-通信"><a href="#4-2-groutine-通信" class="headerlink" title="4.2 groutine 通信"></a>4.2 groutine 通信</h3><p>每当一个进程启动时，系统会自动打开三个文件，标准输入·标准输出·标准错误 —— 对应三个文件：stdin、 stdout、 stderr</p>
<p>stdin对应的硬件 ——硬盘</p>
<p>stdout对应的硬件—— 屏幕</p>
<p>stderr对应的硬件——屏幕</p>
<p>当进程圆形结束，操作系统会自动关闭三个文件；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%c"</span>, ch)</span><br><span class="line">		time.Sleep(<span class="number">300</span>* time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define tow people use printer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printer(<span class="string">"person1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	printer(<span class="string">"person2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">go</span> person1()</span><br><span class="line">	<span class="keyword">go</span> person2()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ppeerrssoonn21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  channel&lt;<span class="number">-891</span></span><br><span class="line">	printer(<span class="string">"person1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	printer(<span class="string">"person2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">go</span> person1()</span><br><span class="line">	<span class="keyword">go</span> person2()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// person2</span></span><br><span class="line">  <span class="comment">// 因为channel不设置容量是 无缓冲阻塞读写的；所以go程person1的printer方法没发输出数据了；只能是go程序2 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>channel有两个端：</strong></p>
<p>一端：    写端（传入端） chan &lt;- </p>
<p>另一端： 读端（传出端）&lt;- chan</p>
<p>要求： 读端和写端必须同时满足条件，才能在chan上进行数据流动。否则，则阻塞；</p>
<p>（读端去读了，chan没有，就是读端阻塞。写端写了，但是chan没有读，就是写端阻塞。总之就是谁操作了，阻塞谁。）</p>
<h3 id="4-3-无缓冲的channel"><a href="#4-3-无缓冲的channel" class="headerlink" title="4.3 无缓冲的channel"></a>4.3 无缓冲的channel</h3><p>无缓冲的channel(unbuffered channel)是指在接收前没有能力保存任何值的通道；</p>
<p>这种类型的通道要求发送goroutine 和接收 goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的goroutinue阻塞。</p>
<p>这种对通道进行发送和接收的交互行为本身就是同步的，其中任意一个操作都无法离开另一个操作单独存在。</p>
<p><strong>阻塞</strong>：由于某种原因数据没有到达，当前协程持续处于等待状态，直到条件满足，才解除阻塞。</p>
<p><strong>同步</strong>： 在两个或多个协程（线程）间，保持数据内容一致性的机制；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写端</span></span><br><span class="line">ch &lt;- <span class="string">"he"</span> <span class="comment">// 写端写数据，读端不在读，阻塞</span></span><br><span class="line"><span class="comment">// 读端</span></span><br><span class="line">str:=&lt;-ch  <span class="comment">// 读端读数据，同时写端不在写，读端阻塞</span></span><br></pre></td></tr></table></figure>



<h4 id="4-3-1-channel同步，数据传递"><a href="#4-3-1-channel同步，数据传递" class="headerlink" title="4.3.1 channel同步，数据传递"></a>4.3.1 channel同步，数据传递</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">"i="</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		channel &lt;- <span class="string">"123"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	str := &lt;-channel <span class="comment">// 阻塞写，上面的go程才有机会执行；</span></span><br><span class="line">	fmt.Println(str) </span><br><span class="line">  </span><br><span class="line"><span class="comment">//  i= 0</span></span><br><span class="line"><span class="comment">//  i= 1</span></span><br><span class="line"><span class="comment">//  123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="channel.png" alt="image-20210325154035381"></p>
<p>第1步，两个goroutine都到达通道，但哪个都没有开始执行发送或接收</p>
<p>第2步，左侧的goroutine将它的手伸进了通道，这模拟了向通道发送数据的行为，这时，这个goroutine会在通道中被锁住，直到交换完成；</p>
<p>第3步，右侧的goroutine将它的手放入通道，这模拟了从通道里接收数据，这个goroutine一样也会在通道中被锁住，直到交换完成</p>
<p>在第4步和第5步，进行交换，并最终，在第6步，两个goroutine都将它们的手从通道里面拿出来，这模拟了被锁住的goroutine得到释放，两个goroutine现在都可以去做其他事情了；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">"子go程 i="</span>, i)</span><br><span class="line">			ch &lt;- i <span class="comment">// // 1.当程序一个值往ch中写入时，由于channel中读的goroutine未就位，当前goroutine阻塞，下一个goroutine得以执行</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		num := &lt;-ch <span class="comment">// // 2. 当执行到这里，读gorutine就位；上面的`ch&lt;-i` gorouine立即被唤醒并继续执行。执行之后，读gorouine也脱离channel，开始往下继续执行；</span></span><br><span class="line">		fmt.Println(<span class="string">"主go程读"</span>, num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">0</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">1</span> <span class="comment">// 这里为什么不是 主go程读 0</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">0</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">1</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">2</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">3</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">2</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">3</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">4</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p> *<em>为什么第二行不是 “子go程 i= 1” *</em></p>
<p>因为<code>fmt.Println(&quot;主go程读&quot;, num)</code>是IO操作，耗时（访问硬件）可能需要等待；</p>
<p>channel应用与 两个goroutine中，一个读，一个写；</p>
<p>具备同步的能力，读、写同步</p>
<p><strong>有缓冲channel</strong></p>
<h4 id="4-3-2-channel的len和cap"><a href="#4-3-2-channel的len和cap" class="headerlink" title="4.3.2 channel的len和cap"></a>4.3.2 channel的len和cap</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">len</span>(channel) <span class="comment">// 0 channel中剩余未读取数据个数</span></span><br><span class="line"><span class="built_in">cap</span>(channel) <span class="comment">// 0 channel的容量</span></span><br></pre></td></tr></table></figure>



<p><strong>有缓冲channel</strong></p>
<p>通道容量为非0， len(ch): channel中剩余未读取数据个数。cap(ch): 通道容量</p>
<p>channel应用于两个go程中，一个读，另一个写</p>
<p>缓冲区可以进行数据存储，存储至容量上限，阻塞，具备异步能力，不需要同时操作channel缓冲区（发短信）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">// 存满3个元素之前不会阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">"len="</span>, <span class="built_in">len</span>(ch), <span class="string">"cap="</span>, <span class="built_in">cap</span>(ch))</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			fmt.Println(<span class="string">"子go程 i="</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// time.Sleep(300 * time.Millisecond)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">		num := &lt;-ch</span><br><span class="line">		fmt.Println(<span class="string">"主go程读"</span>, num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>= <span class="number">0</span> <span class="built_in">cap</span>= <span class="number">2</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">0</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">1</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">2</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">0</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">1</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">2</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">3</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">3</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">4</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">5</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">4</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-关闭channel"><a href="#4-4-关闭channel" class="headerlink" title="4.4 关闭channel"></a>4.4 关闭channel</h3><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现；</p>
<p>确定不再向对端发送接收数据时，使用close关闭channel</p>
<p>对端可以判断channel是否关闭</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> num, ok:= &lt;-ch; ok == <span class="literal">true</span> &#123;</span><br><span class="line">  <span class="comment">// 如果对端已经关闭， ok--&gt;false, num无数据</span></span><br><span class="line">  <span class="comment">// 如果对端没有关闭，ok--&gt; true，num保存读到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">// 不再需要指定循环次数</span></span><br><span class="line">		<span class="keyword">if</span> num, ok := &lt;-ch; ok == <span class="literal">true</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"读取数据"</span>, num)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">读取数据 <span class="number">0</span></span><br><span class="line">读取数据 <span class="number">1</span></span><br><span class="line">读取数据 <span class="number">2</span></span><br><span class="line">读取数据 <span class="number">3</span></span><br><span class="line">读取数据 <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>1:数据没发送完，不应该关闭。</p>
<p>2 已经关闭的channel，不能再写入数据</p>
<p>3 写端已经关闭的channel，可以从中读取数据，</p>
<p>​            读无缓冲channel 读到0， —— 说明写端关闭</p>
<p>​            读有缓冲channel，如果缓冲区有数据，先读数据。读完数据可以无限读，读到0</p>
<h3 id="4-5-单向channel"><a href="#4-5-单向channel" class="headerlink" title="4.5 单向channel"></a>4.5 单向channel</h3><p>默认的channel是双向的， var ch chan int            ch:=make(chan int)</p>
<p>单向写channel：    var sendCh chan &lt;- int           sendCh = make(chan &lt;- int)</p>
<p>单向读channel：    var recvCh &lt;- chan int            recvCh = make(&lt;- chan int)</p>
<p>转换：</p>
<ol>
<li>双向channel 可以隐士转换为任意一种单向channel</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendCh = ch</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>单向channel不能转换为双向channel</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = sendCH/recvCh <span class="comment">// error!!!</span></span><br></pre></td></tr></table></figure>



<p>传参：传【引用】</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> sendCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = ch <span class="comment">// 双向channel赋值给写channel</span></span><br><span class="line">sendCh &lt;- <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recvCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = ch <span class="comment">// 双向channel赋值给读channel</span></span><br><span class="line">num := &lt;-recvCh</span><br><span class="line">fmt.Println(<span class="string">"num"</span>, num)</span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">int</span> = sendCh <span class="comment">//compiler error 单向channel无法赋值给双向channel</span></span><br></pre></td></tr></table></figure>



<p>单向channel的好处，约束子函数行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	out &lt;- <span class="number">123</span> <span class="comment">// 只能往channel写，无法做读取操作</span></span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(into &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	n := &lt;-into <span class="comment">// 只能从channel读，无法做写入操作</span></span><br><span class="line">	fmt.Println(<span class="string">"into="</span>, n) <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		send(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	recv(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-6-生产者消费者模型"><a href="#4-6-生产者消费者模型" class="headerlink" title="4.6 生产者消费者模型"></a>4.6 生产者消费者模型</h3><p>单向channel最典型的应用是“生产者消费者模型”</p>
<p>所谓“生产者消费者模型”： 某个模块（函数等）负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、协程、线程、进程等）产生数据的模块，就形象地成为生产者，而处理数据的模块，就称为消费者。</p>
<p>单单抽象出生产者和消费者，还够不上是生产者/消费者模型。改模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者——》缓冲区——》消费者</span><br></pre></td></tr></table></figure>



<p>举例，假如需要寄出一封信，大致流程如下：</p>
<ol>
<li>把信写好——相当于生产者制造数据</li>
<li>把信放入油桶——相当于生产者把数据放入缓冲区</li>
<li>邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区</li>
</ol>
<p>生产者：发送数据端</p>
<p>消费者：接收数据端</p>
<p><strong>缓冲区的好处</strong></p>
<ol>
<li>解耦（降低生产者和消费者之间耦合度）</li>
<li>生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据了；（生产者和消费者数量不对等时，能保持正常通信）基本不需要依赖消费者的处理速度；</li>
<li>缓存，生产者和消费者处理数据速度不一致时，暂存数据（如果生产者制造数据时快时慢，缓冲区的好处就提体现出来了。当数据制造快消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉）</li>
</ol>
<p><img src="buffer.png" alt="image-20210325223551771"></p>
<p>Channel 实现缓冲区</p>
<p>有缓冲channel和无缓冲channel都能实现缓冲区</p>
<p>有缓冲channel 异步通信 用于对实时不敏感的需求；</p>
<p>无缓冲channel 同步通信，用于实时需求；</p>
<h3 id="4-7-channel作为参数传递，是引用传递"><a href="#4-7-channel作为参数传递，是引用传递" class="headerlink" title="4.7 channel作为参数传递，是引用传递"></a>4.7 channel作为参数传递，是引用传递</h3><h3 id="4-8-模拟订单"><a href="#4-8-模拟订单" class="headerlink" title="4.8 模拟订单"></a>4.8 模拟订单</h3><p>订单处理就是典型的生产消费模式</p>
<p>当很多用户单击下订单按钮后，订单生产的数据全部放到缓冲区，然后消费者将队列中的数据取出来发送到管理系统</p>
<p>通过生产者消费模式，将订单系统与仓库管理系统隔离开，且用户可以随时下单。如果订单系统直接调用仓库系统，那么用户单击下订单按钮后，要等到仓库系统的结果返回，这样速度会很慢；</p>
<h3 id="4-9-定时器"><a href="#4-9-定时器" class="headerlink" title="4.9 定时器"></a>4.9 定时器</h3><p>time.Timer</p>
<p>Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;- <span class="keyword">chan</span> Time</span><br><span class="line">  r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统自动向timer.C这个channel中写入当前时间，阻塞即被解除；</p>
<h3 id="4-10-channel（通道）发送、接收"><a href="#4-10-channel（通道）发送、接收" class="headerlink" title="4.10 channel（通道）发送、接收"></a>4.10 channel（通道）发送、接收</h3><p>使用左箭头操作符 <code>&lt;-</code> 向channel发送值或从channel接收值；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- <span class="number">99</span> <span class="comment">// 向通道发送值， 把值为 99 的值 发送给通道c</span></span><br><span class="line">r:= &lt;- c <span class="comment">// 从通道接收值  从通道c接收一个值，并将此值赋给 r变量</span></span><br></pre></td></tr></table></figure>

<p>发送操作会等待直到另一个goroutine尝试对该channel进行接收操作为止；</p>
<ul>
<li>执行发送操作的goroutine在等待期间将无法执行其它操作</li>
<li>未在等待channel操作的goroutine仍然可以继续自由的运行</li>
</ul>
<p>执行接收操作的goroutine将等待直到另一个goroutine尝试向该channel进行发送操作为止；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 一共有5个 </span></span><br><span class="line">    <span class="comment">//gopher会往此通道发送值；</span></span><br><span class="line">		gopherID := &lt;-c <span class="comment">// 当i=0时，等待大约3s之后，有其它gopher给它发送值了。</span></span><br><span class="line">		<span class="comment">// 可能是 0 1 2 3 4 任意一个值，因为goroutine的顺序无法确定</span></span><br><span class="line">		fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"..."</span>, id, <span class="string">"snore ..."</span>)</span><br><span class="line">	c &lt;- id <span class="comment">// 向通道发送值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-11-使用select处理多个通道"><a href="#4-11-使用select处理多个通道" class="headerlink" title="4.11 使用select处理多个通道"></a>4.11 使用select处理多个通道</h3><p>前面的例子中是使用一个channel来等待多个 goroutine，这种做法在所有goroutine都产生相同类型值的时候是好用的。但实际开发中，情况并不只是如此；程序通常需要等待不同类型的值；</p>
<p>当等待通道中某些值的时候，不想等太久。或者想在网络请求等待数秒之后就将其设置为超时而不是白白等待好几分钟。go标准库提供了一个time.After函数，该函数返回一个channel，该channel在指定时间后会接收到一个值（这个值是由go运行时的一个goroutine发送的 ）；</p>
<p>如果程序想继续从goroutine接收值，那必须等到所有goroutine都结束睡眠或我们耐心耗尽为止。这意味着程序必须同时等到time.After这个计时器channel 和其它channel。这个时候就能使用select语句。select语句能做到这一点。</p>
<p>select语句与switch有点像</p>
<ul>
<li>该语句包含的每个case都持有一个通道，用来发送或接收数据；</li>
<li>select会等待直到某个case分支的操作就绪，然后就会执行该case 分支；</li>
<li>select语句不包含任何case的情况下将永远等下去</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">	&#125;</span><br><span class="line">	timeout := time.After(<span class="number">2</span> * time.Second) </span><br><span class="line">  <span class="comment">// 创建一个超时时间2s 的 channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> gopherID := &lt;-c: <span class="comment">// 从通道接收值</span></span><br><span class="line">			fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout: <span class="comment">//等2s 超时 还未接收到</span></span><br><span class="line">			fmt.Println(<span class="string">"my patience ran out"</span>)</span><br><span class="line">		 	<span class="keyword">return</span> <span class="comment">// return 会跳出select</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Duration(rand.Intn(<span class="number">4000</span>)) * time.Millisecond) <span class="comment">// 生成一个0-4s的随机时间</span></span><br><span class="line">	c &lt;- id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意： 即使已经停止等待goroutine，但只要main函数还没返回，仍在运行的goroutine将会继续占用内存；（有条件，尽量清理掉）</p>
<h3 id="4-12-nil通道"><a href="#4-12-nil通道" class="headerlink" title="4.12 nil通道"></a>4.12 nil通道</h3><blockquote>
<p>值为nil的通道</p>
</blockquote>
<p>如果不使用make初始化channel，那么channel变量的值就是nil(零值)</p>
<p>对nil通道进行发送或接收不会引起panic，但会导致永久阻塞；</p>
<p>对nil通道执行close函数，那么会引起panic</p>
<h4 id="2-3-1-nil通道的用处："><a href="#2-3-1-nil通道的用处：" class="headerlink" title="2.3.1 nil通道的用处："></a>2.3.1 nil通道的用处：</h4><p>对于包含select语句的循环，如果不希望每次循环都等待select所涉及的所有通道，那么可以先将某些channel设置为nil，等到发送值准备就绪之后，再将channel变成一个非nil值并执行发送操作；</p>
<h2 id="3-阻塞和死锁"><a href="#3-阻塞和死锁" class="headerlink" title="3 阻塞和死锁"></a>3 阻塞和死锁</h2><p>当goroutine在等待channel的发送或接收时，我们就说它被阻塞了；</p>
<p>除了goroutine本身占用少量的内存外，被阻塞的goroutine并不消耗任何其它资源；</p>
<ul>
<li>goroutine静静地停在那里，等到导致其阻塞的事情来解除阻塞</li>
</ul>
<p>当一个或多个goroutine因为某些永远无法发生的事情被阻塞时，我们称这种情况为死锁，而出现死锁的程序通常会崩溃或挂起；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引发死锁的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"><span class="comment">// goroutine 1 [chan receive]:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用goroutine 解决死锁问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="number">2</span> &#125;()</span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-地鼠装配线"><a href="#3-1-地鼠装配线" class="headerlink" title="3.1 地鼠装配线"></a>3.1 地鼠装配线</h3><p>Go允许在没有值可供发送的情况下通过close函数关闭通道</p>
<ul>
<li>例如close(c)</li>
</ul>
<p>通道被关闭后无法写入任何值，如果尝试写入将引发panic</p>
<p>尝试读取被关闭的通道会获得与通道类型对应的零值；</p>
<p>注意： 如果循环里读取一个已关闭的通道，并没有检查通道是否关闭，那么该循环可能会一直运转下去，耗费大量CPU时间</p>
<p>执行以下代码可得知通道是否被关闭</p>
<p><code>v,ok := &lt;-c</code> v为通道得到的值，ok bool类型，如果ok为false，那么说明此通道已关闭；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">		downstream &lt;- v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// downstream &lt;- ""</span></span><br><span class="line">	<span class="comment">// 重构为</span></span><br><span class="line">	<span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		item, ok := &lt;-upstream</span><br><span class="line">		<span class="comment">// if item == "" &#123; 重构</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">//	downstream &lt;- ""</span></span><br><span class="line">			<span class="built_in">close</span>(downstream)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">			downstream &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		v := &lt;-upstream</span><br><span class="line">		<span class="keyword">if</span> v == <span class="string">""</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line">	<span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">	printGopher(c1)</span><br><span class="line">	<span class="comment">// 	hello, world</span></span><br><span class="line">	<span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-常用模式"><a href="#3-2-常用模式" class="headerlink" title="3.2 常用模式"></a>3.2 常用模式</h3><p>从通道读取值，直到它关闭为止（常用）</p>
<ul>
<li>可以使用range关键字达到该目的</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">		downstream &lt;- v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// downstream &lt;- ""</span></span><br><span class="line">	<span class="comment">// 重构为</span></span><br><span class="line">	<span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> upstream &#123;</span><br><span class="line">		<span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">			downstream &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(downstream) <span class="comment">// 关闭下游通道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> upstream &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line">	<span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">	printGopher(c1)</span><br><span class="line">	<span class="comment">// 	hello, world</span></span><br><span class="line">	<span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>homework</p>
<ol>
<li>编写一个流水线部件（一个goroutine），他需要记住前面出现的所有值，并且只有在值之前从未出现过的情况下才会将值传递至流水线的下一个阶段，假定第一个值永远不是空字符串</li>
<li>编写一个流水线部件，它接收字符串并将它们拆分成单词，然后向流水线的下一阶段一个接一个发送这些单词（可以用strings.Fields函数）</li>
</ol>
<h2 id="4-并发状态"><a href="#4-并发状态" class="headerlink" title="4 并发状态"></a>4 并发状态</h2><h3 id="4-1-共享值与竞争条件（race-condition）"><a href="#4-1-共享值与竞争条件（race-condition）" class="headerlink" title="4.1 共享值与竞争条件（race condition）"></a>4.1 共享值与竞争条件（race condition）</h3><p>工厂某些生产线出现库存不足的情况，它们需要订购更多的原材料。尽管每条生产线都有固定电话，但是工厂只有一条共享的电话路线。当一个工人拿起电话下订单的时候，另一只地鼠可能会拿起电话拨号。对正在讲话的前一个工人产生干扰，而之后可能还会有其它的工人尝试使用电话。最终就是所有工人一头雾水，订单也无法下达。</p>
<p>为了解决这个问题，工厂工人必须达成某些协议。使得同一时间之内只有一只地鼠使用电话。而go语言里共享值的概念就跟共享电话有些相似。</p>
<p>当有两个或者多个goroutine同时使用共享值的时候，程序可能出错。把这种多个goroutine争相使用值的情况称之为竞争条件或者竞争状态（race condition）而go的compiler实际上包含了尝试在代码里发现静态条件这个功能。</p>
<p>两个goroutine同时读取，并不会产生 race condition。</p>
<h3 id="4-2-Go的互斥锁-mutex"><a href="#4-2-Go的互斥锁-mutex" class="headerlink" title="4.2 Go的互斥锁(mutex)"></a>4.2 Go的互斥锁(mutex)</h3><p>Mutex= mutual exclusive</p>
<p>​                相互的  独占的</p>
<p>一个工厂想出一个很好的主意，在工厂地板中间放置一个玻璃罐，并在玻璃罐中放置了一个金属令牌。每次想要打电话的地鼠都需要从罐子里面取出令牌。然后在打电话的过程中一直持有它。然后打完电话再把它放回到罐子里面。如果有一只地鼠想打电话，但是没有在罐子里面发现令牌。就需要轮训等待直到令牌归还为止。go语言的互斥锁就相当于此玻璃罐。goroutine就可以通过互斥锁阻止其它的goroutine在同一时间进行某些事情。为了保护互斥锁的互斥性质，程序在访问被保护的东西的时候必须得非常的小心。互斥锁有两个方法 <code>Lock</code> 和 <code>Unlock</code>, Lock相当于从金属罐里面取出令牌，Unlock相当于把令牌放回玻璃罐；</p>
<p>如果有goroutine尝试在互斥锁已经锁定的情况下，再调用lock方法，那么它就需要等待解锁之后再次上锁。为了正确使用互斥锁，就要确保锁访问共享值的代码必须先锁定互斥锁，然后才能执行所需的操作。并且在操作完成之后必须解除互斥锁，任何不遵循这一模式的代码都可能引发竞争条件。基于此原因，互斥锁在绝大多数情况下，只会在包内进行使用；这个包会通过互斥锁保护自定义的内容，并将相应的lock和unlock调用，巧妙的隐藏在函数和方法的背后。和channel不一样，互斥锁并未内置在go语言中。而是通过sync包来引入的；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	<span class="comment">// the lock is held until we return from the function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>互斥锁定义在被保护的变量之上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line">1. 当两个goroutine同时修改一个值的时候，会发生什么</span><br><span class="line">2. 尝试对一个已经被锁定的互斥锁进行锁定操作，会发生什么</span><br><span class="line">3. 尝试多一个未被锁定的互斥锁进行解锁操作，会发生什么</span><br><span class="line">4. 同时在多个不同的goroutine里面调用相同类型的方法是安全的吗</span><br></pre></td></tr></table></figure>



<h3 id="4-2-互斥锁的实现机制"><a href="#4-2-互斥锁的实现机制" class="headerlink" title="4.2 互斥锁的实现机制"></a>4.2 互斥锁的实现机制</h3><p>互斥锁是并发控制的一个基本手段；是为了避免竞争二建立的一种并发控制机制；</p>
<p>临界区：</p>
<p>​    临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作，对一个IO设备的使用；对一个连接池中的连接的调用；</p>
<p>使用互斥锁，限定临界区只能同时由一个线程持有；互斥锁又名排他锁</p>
<p>Mutex是使用最广泛的同步原语，有人也叫做并发原语；</p>
<h4 id="4-2-1-同步并发原语"><a href="#4-2-1-同步并发原语" class="headerlink" title="4.2.1 同步并发原语"></a>4.2.1 同步并发原语</h4><blockquote>
<p>mutex是使用最广泛的同步原语；</p>
</blockquote>
<ul>
<li>同步原语</li>
</ul>
<p>互斥锁Mutex</p>
<p>读写锁RWMutex</p>
<p>并发编排WaitGroup</p>
<p>条件变量Cond</p>
<p>Channel</p>
<ul>
<li>同步原语适应的场景</li>
</ul>
<p>共享资源：</p>
<p>​    并发读写共享资源，会引发数据竞争，所以需要Mutex，RWMutex这样的并发原语来保护</p>
<p>任务编排：</p>
<p>​    需要goroutine按照一定的规律执行，而goroutine之间有相互等待或者依赖的顺序关系，常常使用WaitGroup或Channel来实现；</p>
<p>消息传递：</p>
<p>​    信息交流以及不同的goroutine之间的线程安全的数据交流，常常使用channel；</p>
<h4 id="4-2-2-Locker-接口"><a href="#4-2-2-Locker-接口" class="headerlink" title="4.2.2 Locker 接口"></a>4.2.2 Locker 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Lock()</span><br><span class="line">	Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mutex 和 RWMutex都实现了Locker接口；</p>
<h4 id="4-2-3-sync-Mutex"><a href="#4-2-3-sync-Mutex" class="headerlink" title="4.2.3 sync.Mutex"></a>4.2.3 sync.Mutex</h4><blockquote>
<p>控制等待一组goroutine全部做完任务；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex <span class="comment">// mutex的零值是还没有goroutine等待的未加锁的状态，不需要额外初始化；</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">// 对变量count执行10次加1</span></span><br><span class="line">			<span class="keyword">for</span> j:=<span class="number">0</span> ;j&lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">				mutex.Lock()</span><br><span class="line">				count++</span><br><span class="line">				mutex.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待10个goroutine完成</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面如果不加 mutex.Lock，我们发现最终结果得不到100000， 说明count++ 不是个原子操作；因为操作不原子，所以就可能有并发问题；</p>
<h4 id="4-2-4-go-race-detector"><a href="#4-2-4-go-race-detector" class="headerlink" title="4.2.4 go race detector"></a>4.2.4 go race detector</h4><p><code>go run -race atomic.go</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read at 0x00c0000bc008 by goroutine 8:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:20 +0x78</span><br><span class="line"></span><br><span class="line">Previous write at 0x00c0000bc008 by goroutine 7:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:20 +0x91</span><br><span class="line"></span><br><span class="line">Goroutine 8 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:15 +0xe4</span><br><span class="line"></span><br><span class="line">Goroutine 7 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:15 +0xe4</span><br><span class="line">==================</span><br><span class="line">365768</span><br><span class="line">Found 1 data race(s)</span><br><span class="line"><span class="built_in">exit</span> status 66</span><br></pre></td></tr></table></figure>



<h4 id="4-2-5-mutex的用法"><a href="#4-2-5-mutex的用法" class="headerlink" title="4.2.5 mutex的用法"></a>4.2.5 mutex的用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很多情况，mutex会嵌入到其他struct中使用；mutex不会因为没有初始化出现空指针或者是无法获取到锁的情况；</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	Count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把获取锁，释放锁，计数加一的逻辑封装程一个方法，对外不需要暴露锁等逻辑</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> count Counter</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">// 对变量count执行10次加1</span></span><br><span class="line">			<span class="keyword">for</span> j:=<span class="number">0</span> ;j&lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">				count.Incr()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待10个goroutine完成</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(count.Count())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	CounterType <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	c.count++</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span>&#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-互斥锁的隐患和易错点"><a href="#4-3-互斥锁的隐患和易错点" class="headerlink" title="4.3 互斥锁的隐患和易错点"></a>4.3 互斥锁的隐患和易错点</h3><h4 id="4-3-1-死锁"><a href="#4-3-1-死锁" class="headerlink" title="4.3.1  死锁"></a>4.3.1  死锁</h4><blockquote>
<p>两个或者两个以上的进程（线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或者系统产生了死锁；</p>
</blockquote>
<p>如果你想避免死锁，只要破坏这四个条件中的一个或者几个就可以了</p>
<ol>
<li>互斥；</li>
<li>持有和等待   goroutine持有一个资源，并且还在请求其他goroutine持有的资源；</li>
<li>不可剥夺  资源只能有持有它的goroutine来释放；</li>
<li>环路等待 存在一组等待的进程，p={p1,p2,…pn},p1等待p2, p2等待 pn, pn等待 p1，这就形成了一个环路等待的死结； </li>
</ol>
<p>环路等待； 物业需要派出所证明，派出所需要物业证明。结果就陷入死锁状态。派出所和物业是两个goroutine，派出所证明和物业证明是两个资源，双方都持有自己的资源而要求对方的资源；而且自己的资源自己持有，不可剥夺；</p>
<p>所以为了保证这个互斥锁的使用安全，遵守以下两个原则</p>
<ol>
<li>尽可能的简化互斥锁保护的代码</li>
<li>对每一份共享状态只使用一个互斥锁</li>
</ol>
<h4 id="4-3-2-Lock-Unlock不成对出现"><a href="#4-3-2-Lock-Unlock不成对出现" class="headerlink" title="4.3.2 Lock/Unlock不成对出现"></a>4.3.2 Lock/Unlock不成对出现</h4><h4 id="4-3-3-Copy已使用的Mutex"><a href="#4-3-3-Copy已使用的Mutex" class="headerlink" title="4.3.3 Copy已使用的Mutex"></a>4.3.3 Copy已使用的Mutex</h4><p>package sync的同步原语在使用后是不能复制的，Mutex是最常用的一个同步原语，它也是不能复制的；原因在于Mutex是一个有状态的对象，它的state字段记录这个锁的状态； </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line">  Count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c Counter</span><br><span class="line">  c.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">  c.Count++</span><br><span class="line">  foo(c) <span class="comment">// 复制锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c Counter)</span></span>&#123;</span><br><span class="line">  c.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">  fmt.Println(<span class="string">"in foo"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-4-重入"><a href="#4-3-4-重入" class="headerlink" title="4.3.4 重入"></a>4.3.4 重入</h4><p>可重入锁：</p>
<p>​    当一线程获取锁时，如果没有其他线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其他线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时也叫做递归锁）。只要你拥有这把锁，你可以一直调用，比如通过递归实现一些算法，调用者不会阻塞或死锁</p>
<p><strong>mutex不是可重入锁</strong></p>
<p>因为mutex的实现中没有记录哪个goroutine拥有这把锁，理论上，任何goroutine都可以随意地Unlock这把锁，所以没办法计算重入条件；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(l sync.Locker)</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"in foo"</span>)</span><br><span class="line">  l.Lock()</span><br><span class="line">  bar(l)</span><br><span class="line">  l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(l sync.Locker)</span></span>&#123;</span><br><span class="line">  l.Lock()</span><br><span class="line">  fmt.Println(<span class="string">"in bar"</span>)</span><br><span class="line">  l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  l:=&amp;sync.Mutex&#123;&#125;</span><br><span class="line">  foo(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如何实现一个可重入锁，实现锁的关键点要记住当前是哪个goroutine持有这个锁；</p>
<h3 id="4-4-WaitGroup"><a href="#4-4-WaitGroup" class="headerlink" title="4.4 WaitGroup"></a>4.4 WaitGroup</h3><blockquote>
<p>WaitGroup很简单，就是package sync用来做任务编排的一个并发原语，它要解决的就是并发-等待的问题；现在有一个goroutine A在检查点（checkpoint）等待一组goroutine全部完成，如果在执行任务的这些goroutine还没全部完成，那么goroutine A就会阻塞在检查点，直到所有goroutine都完成后才能继续执行；</p>
<p>很多操作系统和编程语言都提供了类型的并发原语，比如Linux的barrier，Pthread(POSIX线程)中的barrier;</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span> // 设置计数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span> // 将计数减1，其实就是<span class="title">Add</span><span class="params">(-1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span> // 调用这个方法的<span class="title">goroutine</span>会一直阻塞，直到<span class="title">WaitGroup</span>计数值为0；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span>&#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	c.count++</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span>&#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c *Counter, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// 计数减1， 当有一个goroutine完成了就减1</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	c.Incr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> counter Counter</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">10</span>) <span class="comment">// 设置计数值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		<span class="keyword">go</span> worker(&amp;counter, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">// 阻塞 main goroutine 等待waitGroup计数归0</span></span><br><span class="line">	fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-5-Cond"><a href="#4-5-Cond" class="headerlink" title="4.5 Cond"></a>4.5 Cond</h3><blockquote>
<p>go标准库提供Cond的原语的目的是，为等待/通知场景下的并发问题提供支持，Cond通常应用于等待某个条件的一组goroutine，等条件变为true的时候，其中一个goroutine或者所有的goroutine都会呗唤醒执行；</p>
</blockquote>
<p>真正使用Cond的场景比较少，一旦遇到需要使用Cond的场景，更多地会使用Channel的方式去实现；</p>
<ul>
<li>Cond的基本用法</li>
</ul>
<p>Cond关联的Locker实例可以通过c.L访问，它内部维护着一个先入先出的等待队列；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // 会把调用者<span class="title">Caller</span> 放入<span class="title">Cond</span>的等待队列中并阻塞，直到<span class="title">Signal</span>或者广播方法从等待队列中移除并唤醒；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	c:= sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>))*time.Second)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 加锁更改等待条件</span></span><br><span class="line">			c.L.Lock()</span><br><span class="line">			ready++</span><br><span class="line">			c.L.Unlock()</span><br><span class="line"></span><br><span class="line">			log.Printf(<span class="string">"player #%d is ready\n"</span>, i)</span><br><span class="line">			<span class="comment">//broadcast</span></span><br><span class="line"></span><br><span class="line">			c.Broadcast()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.L.Lock()</span><br><span class="line">	<span class="keyword">for</span> ready != <span class="number">10</span>&#123;</span><br><span class="line">		c.Wait() <span class="comment">// 把调用者放入cond队列中并阻塞，等待被唤醒；</span></span><br><span class="line">		log.Println(<span class="string">"裁判员被唤醒一次"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.L.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有运动员是否准备就绪</span></span><br><span class="line">	log.Println(<span class="string">"所有运动员都准备就绪，game start,3,2,1..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-6-once"><a href="#4-6-once" class="headerlink" title="4.6 once"></a>4.6 once</h3><blockquote>
<p>once可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<p>sync.Once只暴露了一个方法Do，你可以多次调用Do方法，但是只有第一次调用Do方法时f参数才会执行，这里的f是一个无参无返回值的函数；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> once sync.Once</span><br><span class="line">	f1:= <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"in f1"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	once.Do(f1) <span class="comment">// 输出 in f1</span></span><br><span class="line"></span><br><span class="line">	f2:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"in f2"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	once.Do(f2) <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-7-context"><a href="#4-7-context" class="headerlink" title="4.7 context"></a>4.7 context</h3><blockquote>
<p>在API之间或者方法调用之间，所传递的除了业务参数之外的额外信息；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span>&#123;</span><br><span class="line">  Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  Err() error</span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-8-atomic"><a href="#4-8-atomic" class="headerlink" title="4.8 atomic"></a>4.8 atomic</h3><blockquote>
<p>原子操作，一个原子在执行的时候，其他线程不会看到执行一半的操作结果；在其他线程看来，原子操作要么执行完了，要么还在执行；就像一个最小的例子-原子一样，不可分割;</p>
</blockquote>
<p>再来看一个例子，假设你在开发应用程序的时候，需要从配置服务器中读取一个节点的配置信息。而且，在这个节点的配置发生变更的时候，你需要重新从配置服务器中拉去一个份新的配置并更新。你的程序中可能有多个goroutine都依赖这份配置，涉及到对这个配置对象的并发读写，你可以使用读写锁实现对配置对象的保护，在大部分情况下，你也可以利用atomic实现配置对象的更新和加载；</p>
<p>atomic原子操作还是实现lock-free数据结构的基石</p>
<p>在实现lock-free的数据结构时，我们可以不使用互斥锁，这样就不会让线程因为等待互斥锁阻塞休眠，而是让线程保持继续处理的状态。另外，不使用互斥锁的话，lock-free的数据结构还可以提供并发的性能；</p>
<h4 id="4-8-1-atomic提供的方法"><a href="#4-8-1-atomic提供的方法" class="headerlink" title="4.8.1 atomic提供的方法"></a>4.8.1 atomic提供的方法</h4><blockquote>
<p>atomic操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法；</p>
</blockquote>
<ul>
<li>Add</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="keyword">uint32</span>, delta <span class="keyword">uint32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="comment">// Add方法就是给第一个参数地址中的值增加一个delta值；</span></span><br></pre></td></tr></table></figure>

<ul>
<li>CAS(compareAndSwap)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要操作的地址，原数据值，新值；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 这个方法会比较当前addr地址里面的值是不是old，如果不等于old，就返回false；如果等于old，就把此地址的值替换成new值，返回true，这就相当于“判断相等才替换”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *addr == old &#123;</span><br><span class="line">  *addr = <span class="built_in">new</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Swap</li>
</ul>
<p>如果不需要比较旧值，只是比较粗暴地替换的话，就可以使用Swap方法，它替换后还可以返回旧值，伪代码如下；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old= *addr</span><br><span class="line">*addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> old</span><br></pre></td></tr></table></figure>

<ul>
<li>Load</li>
</ul>
<p>Load方法会取出addr地址中的值，即使在多处理器、多核、有cpu cache的情况下，这个操作也能保证Load是一个原子操作；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="keyword">int32</span>)</span><span class="params">(val <span class="keyword">int32</span>)</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>Store</li>
</ul>
<p>Store方法会把一个值存入到指定的addr地址中，即使在多处理器、多核、有cpu cache的情况下，这个操作也能保证Store是一个原子操作。别的goroutine通过Load读取出来，不会看到存取了一半的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func StoreInt32(addr *int32, val int32)</span><br></pre></td></tr></table></figure>



<h4 id="4-8-2-Value类型"><a href="#4-8-2-Value类型" class="headerlink" title="4.8.2 Value类型"></a>4.8.2 Value类型</h4><blockquote>
<p>Value类型，可以原子地存取对象类型，但也只能存取，不能CAS和Swap，常常用在配置变更等场景中</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(v *Value)</span> <span class="title">Load</span><span class="params">()</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(v *Value)</span> <span class="title">Store</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	NodeName <span class="keyword">string</span></span><br><span class="line">	Addr     <span class="keyword">string</span></span><br><span class="line">	Count    <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadNewConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Config&#123;</span><br><span class="line">		NodeName: <span class="string">"beijing"</span>,</span><br><span class="line">		Addr:     <span class="string">"10.13.12.88"</span>,</span><br><span class="line">		Count:    rand.Int31(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> config atomic.Value</span><br><span class="line">	config.Store(loadNewConfig())</span><br><span class="line">	<span class="keyword">var</span> cond = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新config</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(<span class="number">5</span>+rand.Int63n(<span class="number">5</span>)) * time.Second)</span><br><span class="line">			config.Store(loadNewConfig())</span><br><span class="line">			cond.Broadcast() <span class="comment">// 通知等待着配置已变更</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			cond.Wait()                 <span class="comment">// 阻塞等待变更信号</span></span><br><span class="line">			c := config.Load().(Config) <span class="comment">// 读取新的配置</span></span><br><span class="line">			fmt.Printf(<span class="string">"new config:%+v\n"</span>, c)</span><br><span class="line">			cond.L.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-9-map"><a href="#4-9-map" class="headerlink" title="4.9 map"></a>4.9 map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[k]v</span><br></pre></td></tr></table></figure>

<p>key类型的k必须是可比较的（comparable），也就是可以通过 == 和 != 操作符进行比较： value的值和类型无所谓，可以是任意类型，或者是nil</p>
<p>go内建的 map对象不是线程（goroutine）安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      m[<span class="number">1</span>] = <span class="number">1</span> <span class="comment">// 设置key</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">      _ = m[<span class="number">2</span>] <span class="comment">// 访问这个map</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// panic</span></span><br></pre></td></tr></table></figure>

<h4 id="4-9-1-实现线程安全的map类型"><a href="#4-9-1-实现线程安全的map类型" class="headerlink" title="4.9.1 实现线程安全的map类型"></a>4.9.1 实现线程安全的map类型</h4><p>加读写锁；</p>
<h4 id="4-9-2-应对特殊场景的sync-Map"><a href="#4-9-2-应对特殊场景的sync-Map" class="headerlink" title="4.9.2 应对特殊场景的sync.Map"></a>4.9.2 应对特殊场景的sync.Map</h4><p>sync.Map是线程安全的；</p>
<p>在以下两个场景中使用sync.Map ，会比使用map.RWMutex的方式，性能要好得多；</p>
<ol>
<li>只会增长的缓存系统中，一个key只写入一次而被读很多次；</li>
<li>多个goroutine为不相交的键集读、写和重写键值对；</li>
</ol>
<p>sync.Map很少使用，我们可以把sync.Map看成一个生产环境中很少使用的同步原语；</p>
<h3 id="4-10-pool"><a href="#4-10-pool" class="headerlink" title="4.10 pool"></a>4.10 pool</h3><blockquote>
<p>如果你想使用go开发一个高性能的应用程序时，就必须考虑垃圾回收给性能带来的影响；毕竟Go的自动垃圾回收机制还是有一个STW（stop-the-world，程序暂停）的时间，而且，大量地创建在堆上的对象，也会影响垃圾回收标记的时间；</p>
</blockquote>
<p>所以，一般做性能优化的时候，会采用对象池的方法，把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必在堆上重新创建了；</p>
<p>像数据库连接，TCP长连接，这些连接在创建的时候是一个非常耗时的操作，如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上；</p>
<p>Go标准库提供了sync.Pool，使用它可以创建池化的对象；</p>
<h3 id="4-4-长时间运行的工作进程"><a href="#4-4-长时间运行的工作进程" class="headerlink" title="4.4 长时间运行的工作进程"></a>4.4 长时间运行的工作进程</h3><p>工作进程（worker）</p>
<p>把一直存在并且独立运行的goroutine称作为 工作进程</p>
<p>而工作进程通常被写成包含select语句的for循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// wait for channels here.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-5-事件循环和goroutine"><a href="#4-5-事件循环和goroutine" class="headerlink" title="4.5 事件循环和goroutine"></a>4.5 事件循环和goroutine</h3><p>事件循环（event loop）</p>
<p>中心循环（central loop）</p>
<p>Go通过提供groutine作为核心概念，消除了对中心循环的需求；</p>
<p>某些编程语言会用事件循环的中心循环来等待时间，并在这个事件发生时调用相应的已注册函数。而go语言则是通过提供goroutine作为核心概念，消除对中心循环的需求。</p>
<p>我们可以把任何工作进程goroutine都看做是独立运行的事件循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"image"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos := image.Point&#123;X: <span class="number">10</span>, Y: <span class="number">10</span>&#125;</span><br><span class="line">	direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">	next := time.After(time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-next:</span><br><span class="line">			pos = pos.Add(direction)</span><br><span class="line">			fmt.Println(<span class="string">"current position is"</span>, pos)</span><br><span class="line">			next = time.After(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	right = command(<span class="number">0</span>)</span><br><span class="line">	left  = command(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoverDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">	commandc <span class="keyword">chan</span> command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoverDriver</span><span class="params">()</span> *<span class="title">RoverDriver</span></span> &#123;</span><br><span class="line">	r := &amp;RoverDriver&#123;</span><br><span class="line">		commandc: <span class="built_in">make</span>(<span class="keyword">chan</span> command),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> r.drive()</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos := image.Point&#123;X: <span class="number">0</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">	direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">	updateInterval := <span class="number">250</span> * time.Millisecond</span><br><span class="line">	nextMove := time.After(updateInterval)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c := &lt;-r.commandc:</span><br><span class="line">			<span class="keyword">switch</span> c &#123;</span><br><span class="line">			<span class="keyword">case</span> right:</span><br><span class="line">				direction = image.Point&#123;X: -direction.Y, Y: direction.X&#125;</span><br><span class="line">			<span class="keyword">case</span> left:</span><br><span class="line">				direction = image.Point&#123;X: direction.Y, Y: -direction.X&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			log.Printf(<span class="string">"new direction %v"</span>, direction)</span><br><span class="line">		<span class="keyword">case</span> &lt;-nextMove:</span><br><span class="line">			pos = pos.Add(direction)</span><br><span class="line">			log.Printf(<span class="string">"moved to %v"</span>, pos)</span><br><span class="line">			nextMove = time.After(updateInterval)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Left</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.commandc &lt;- left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Right</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.commandc &lt;- right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := NewRoverDriver()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	r.Left()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	r.Right()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改代码使得每次移动之间的间隔增加半秒</p>
<p>以RoverDriver类型为基础，定义start方法·stop方法和对应的命令，然后修改代码使得探测器可以接受这两个新命令</p>
<h3 id="4-6-互斥锁的实现"><a href="#4-6-互斥锁的实现" class="headerlink" title="4.6 互斥锁的实现"></a>4.6 互斥锁的实现</h3><h4 id="4-6-1-初版mutex实现"><a href="#4-6-1-初版mutex实现" class="headerlink" title="4.6.1 初版mutex实现"></a>4.6.1 初版mutex实现</h4><ul>
<li>CAS</li>
</ul>
<p>CAS指令是将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的；<em>原子性保证这个指令总是基于最新的值进行计算，如果同时有其他线程已经修改了这个值，那么CAS会返回失败</em></p>
<p>CAS是实现互斥锁和同步原语的基础；</p>
<p>mutex结构包含两个字段：</p>
<ul>
<li><p>字段key:</p>
<p>​    一个flag，用来标识这个排外锁是否被某个goroutine所持有，如果key大于1，说明这个排外锁已经被持有；</p>
</li>
<li><p>字段sema:</p>
<p>​    是个信号量变量，用来控制等待goroutine的阻塞休眠和唤醒；</p>
</li>
</ul>
<p><strong>Unlock方法可以被任意的goroutine调用释放锁，即使是没有持有这个互斥锁的goroutine，也可以进行这个操作，这是因为，Mutex本身并没有包含持有这把锁的goroutine的信息，所以，Unlock也不会对此进行检查，Mutex的这个和手机一直保持至今；</strong> 因此写代码时要遵循谁申请谁释放，以防造成死锁；</p>
<h2 id="5-select"><a href="#5-select" class="headerlink" title="5. select"></a>5. select</h2><h3 id="5-1-select的作用"><a href="#5-1-select的作用" class="headerlink" title="5.1 select的作用"></a>5.1 select的作用</h3><p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动</p>
<p>select与switch相似，但select有比较多的限制，其中最大的一条限制就是每个<strong>case语句里必须是一个IO操作</strong>（读写操作，读channel写channel也是一种IO操作）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- chan1:</span><br><span class="line">  <span class="comment">// 如果chan1成功读取到数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">case</span> chan2 &lt;<span class="number">-1</span>:</span><br><span class="line">  <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句；</p>
<p>如果其中的任意一语句可以继续执行（即没有被阻塞）那么就从那些可以执行的语句中任意选择一条来使用。</p>
<p>如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况</p>
<ul>
<li>如果给出default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复</li>
<li>如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> &lt;- chan1:</span><br><span class="line">    <span class="comment">// 如果chan1成功读取到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;<span class="number">-1</span>:</span><br><span class="line">    <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果需要轮训select监听channel数据流向的话，那么需要加上for语句。但是这样每次循环进来都需要default:这样就形成忙轮询死循环了。CPU一致被占用。所以一般在for的时候 不写default。这样的话select语句就会因为阻塞而挂起。挂起会出让cpu时间片。这样会提升计算机的效率</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-select基本使用"><a href="#5-2-select基本使用" class="headerlink" title="5.2 select基本使用"></a>5.2 select基本使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select </span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// 用来进行数据通信的channel</span></span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">// 用来判断是否退出的channel</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 写数据</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">		quit &lt;- <span class="literal">true</span> <span class="comment">// 通知主goroutine退出</span></span><br><span class="line">		runtime.Goexit()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">// 主goroutine 读数据</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> num := &lt;-ch:</span><br><span class="line">			fmt.Println(num)</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// 终止进程</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>select总结：</p>
<p>作用： 用来监听channel上的数据流动方向。读？写？</p>
<p>用法： 参考switch case语句，但！ case后面必须是IO操作，不可以任意写判别表达式</p>
<p>注意事项：</p>
<ol>
<li>监听的case中，没有满足监听条件，阻塞</li>
<li>监听的case中，有多个满足监听条件，任选一个执行</li>
<li>可以使用default来处理所有case都不满足监听条件的状况，通常不同（会产生忙轮训）</li>
<li>select自身不带有循环机制，需要借助外层for来循环监听</li>
<li>break只能跳出select，类似swtich中的用法</li>
</ol>
<h3 id="5-3-select实现斐波那契数列"><a href="#5-3-select实现斐波那契数列" class="headerlink" title="5.3 select实现斐波那契数列"></a>5.3 select实现斐波那契数列</h3><h3 id="5-4-超时"><a href="#5-4-超时" class="headerlink" title="5.4 超时"></a>5.4 超时</h3><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  c:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  quit:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> v:= &lt;-c:</span><br><span class="line">      <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span>*time.Second): <span class="comment">// 设置超时</span></span><br><span class="line">        quit&lt;-<span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ &#123;</span><br><span class="line">    ch &lt;- i;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;-quit <span class="comment">// 主go程，阻塞等待子go程通知，退出</span></span><br><span class="line">  fmt.Println(<span class="string">"finish!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select超时处理：</p>
<p>select监听time.After中channel的读事件，如果定时时间到，系统会向该channel中写入系统当前时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- time.After(time.Second*<span class="number">5</span>)</span><br><span class="line">  <span class="comment">// 定时到达后，要处理的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-Lock"><a href="#6-Lock" class="headerlink" title="6. Lock"></a>6. Lock</h2><p>什么是锁，就是某个协程（线程）在访问某个资源的时候先锁住，防止其他协程的访问，等访问完毕解锁后其他协程再来加锁访问。</p>
<h3 id="6-1-死锁"><a href="#6-1-死锁" class="headerlink" title="6.1 死锁"></a>6.1 死锁</h3><blockquote>
<p>不是锁的一种！！！ 是一种错误使用锁导致的现象</p>
</blockquote>
<p>死锁是指两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁；</p>
<ul>
<li>单go程死锁,（channel应该至少2个以上的go程中进行通信，否则死锁！）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch&lt;<span class="number">-789</span> <span class="comment">// 阻塞</span></span><br><span class="line">	num:=&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>go程间channel访问顺序导致死锁</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	num := &lt;-ch</span><br><span class="line"></span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="number">123</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用channel一端读（写），要保证另一端写（读）操作，同时有机会执行。否则死锁；</p>
<ul>
<li>多go程，多channel交叉死锁 （日常编程当中，逻辑控制不严谨。出现频率比较高）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 子</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> num := &lt;-ch1:</span><br><span class="line">				ch2 &lt;- num</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> num := &lt;-ch2:</span><br><span class="line">			ch1 &lt;- num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在go语言中，尽量不要将互斥锁，读写锁与channel混用，—— 隐形死锁</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> rwlock sync.RWMutex <span class="comment">// 锁只有1把</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readGo</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rwlock.RLock() <span class="comment">// 以读模式枷锁</span></span><br><span class="line">		num := &lt;-in</span><br><span class="line">		fmt.Printf(<span class="string">"-----%dth 读go程，读出：%d\n"</span>, idx, num)</span><br><span class="line">		rwlock.RUnlock() <span class="comment">// 以读模式解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeGo</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 生成随机数</span></span><br><span class="line">		num := rand.Intn(<span class="number">1000</span>)</span><br><span class="line">		rwlock.Lock() <span class="comment">//以写模式枷锁</span></span><br><span class="line">		out &lt;- num</span><br><span class="line">		fmt.Printf(<span class="string">"%dth 写go程,写入：%d\n"</span>, idx, num)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">300</span>)</span><br><span class="line">		rwlock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 播种随机种子</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 用于数据传递的channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> readGo(ch, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> writeGo(ch, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-2-互斥锁"><a href="#6-2-互斥锁" class="headerlink" title="6.2 互斥锁"></a>6.2 互斥锁</h3><p>每个资源都对应一个可称为“互斥锁”的标记，这个标记是用来保证在任意时刻，只能有一个协程（线程）访问该资源，其他的协程只能等待；</p>
<p>互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock，Lock锁定当前的共享资源，Unlock进行解锁；</p>
<p>在使用互斥锁时，一定要注意：对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用channel完成同步</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%c"</span>, ch)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">300</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch &lt;- <span class="number">98</span></span><br><span class="line">	printer(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-ch</span><br><span class="line">	printer(<span class="string">"mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> person1()</span><br><span class="line">	<span class="keyword">go</span> person2()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁：<br>强制锁<br>建议锁</p>
<p>建议锁和强制锁并不是真正存在的锁，而是一种能对诸如记录锁、文件锁产生影响的两种机制；</p>
<p>这里的互斥锁是属于建议锁，操作系统不强制提供；（建议锁只是建议性存在的，并不强制执行，内核和系统总体上都坚持不使用建议性锁机制，它们依靠程序猿遵守这个规定，Linux默认是采用建议性锁）</p>
<p>建议锁只在合作进程（cooperating precess）之间才有效。破坏性的IO操作会成功</p>
<p>合作进程： 考虑数据库访问例程库，如果该库中所有函数都以一致性的方法处理记录锁，责成使用这些函数访问数据库的任何进程集为合作进程</p>
<p><strong>上层应用使用的锁全部都是建议锁</strong></p>
<p>强制锁机制是这样规定的：所有记录或文件锁功能内核执行的。破坏性的IO操作会被内核禁止。被锁的文件，内核会强制阻止任何对该文件的读或写违规访问。每次读或写访问都得检查锁是否存在。也就是强制性锁机制。</p>
<p><strong>强制锁只在操作系统底层它自己会用到，编程用不上</strong></p>
<p><img src="metux.png" alt="阻塞在锁上"><br>阻塞在锁上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用互斥锁完成同步</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	mutex.Lock() <span class="comment">// 访问共享数据之前，</span></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%c"</span>, ch)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">300</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mutex.Unlock() <span class="comment">// 访问共享数据之后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printer(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printer(<span class="string">"mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> person1()</span><br><span class="line">	<span class="keyword">go</span> person2()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-读写锁"><a href="#6-3-读写锁" class="headerlink" title="6.3 读写锁"></a>6.3 读写锁</h3><p>互斥锁的本质是当一个goroutine访问的时候，其他goroutinue都不能 访问，这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。</p>
<p>其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在竞争的问题的。因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的；</p>
<p>所以问题不是出在读上，主要是修改，也就是“写”，修改的数据要同步，这样其他goroutinue才可以感知到。所以真正的互斥应该是读取和修改、修改和修改之间，读和读是没有互斥操作的必要的；</p>
<p>因此，衍生出另外一种锁，叫做读写锁。</p>
<p>读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutinue既不能进行读操作，也不能进行写操作。</p>
<p>Go中的读写锁由结构体类型sync.RWMutex表示，此类型的方法集合中包含两对方法：</p>
<p>一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁”</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span><span class="title">RLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span><span class="title">RUlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>数据同步</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> rwlock sync.RWMutex <span class="comment">// 锁只有1把</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readGo</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rwlock.RLock() <span class="comment">// 以读模式枷锁</span></span><br><span class="line">		num := count</span><br><span class="line">		fmt.Printf(<span class="string">"-----%dth 读go程，读出：%d\n"</span>, idx, num)</span><br><span class="line">		rwlock.RUnlock() <span class="comment">// 以读模式解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeGo</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 生成随机数</span></span><br><span class="line">		num := rand.Intn(<span class="number">1000</span>)</span><br><span class="line">		rwlock.Lock() <span class="comment">//以写模式枷锁</span></span><br><span class="line">		count = num</span><br><span class="line">		fmt.Printf(<span class="string">"%dth 写go程,写入：%d\n"</span>, idx, num)</span><br><span class="line">		rwlock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 播种随机种子</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> readGo(i + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> writeGo(i + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1th 写go程,写入：42</span></span><br><span class="line"><span class="comment">//-----1th 读go程，读出：42</span></span><br><span class="line"><span class="comment">//-----1th 读go程，读出：42</span></span><br><span class="line"><span class="comment">//-----3th 读go程，读出：42</span></span><br><span class="line"><span class="comment">//1th 写go程,写入：86</span></span><br><span class="line"><span class="comment">//-----2th 读go程，读出：86</span></span><br><span class="line"><span class="comment">//-----2th 读go程，读出：86</span></span><br><span class="line"><span class="comment">//-----1th 读go程，读出：86</span></span><br></pre></td></tr></table></figure>



<p>总结</p>
<p>读时共享，写时独占。写锁优先级比读锁高</p>
<h3 id="6-4-条件变量"><a href="#6-4-条件变量" class="headerlink" title="6.4 条件变量"></a>6.4 条件变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引出问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		num := rand.Intn(<span class="number">800</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"%dth:product -&gt; %d,\n "</span>, idx, num)</span><br><span class="line">		out &lt;- num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> num := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"-----%dth:consum -&gt; %d,\n "</span>, idx, num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> consumer(product, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> producer(product, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>th:product -&gt; <span class="number">15</span>,</span><br><span class="line"> <span class="number">3</span>th:product -&gt; <span class="number">481</span>,</span><br><span class="line"> <span class="number">2</span>th:product -&gt; <span class="number">546</span>,</span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">15</span>,</span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">481</span>,</span><br><span class="line"> <span class="number">1</span>th:product -&gt; <span class="number">790</span>,</span><br><span class="line"> <span class="number">1</span>th:product -&gt; <span class="number">738</span>,</span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">790</span>, <span class="comment">// 546 空过去了</span></span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">738</span>,</span><br></pre></td></tr></table></figure>



<p>本身不是锁！！但条件变量总是与锁一起使用</p>
<p>条件变量的作用并不保证在同一时刻仅有一个协程访问某个共享的数据资源，而是在对应的共享数据的状态发生变化时，通知阻塞在某个条件上的协程（线程）。条件变量不是锁，在并发中不能达到同步的目的，因此条件变量总是与锁一块使用</p>
<p>例如，如果仓库队列满了，我们可以使用条件变量让生产者对应的go程暂停（阻塞），但是当消费者消费了某个产品后，仓库就不再满了，应该唤醒（发送通知给）阻塞的生产者go程继续生产产品</p>
<p><img src="cond.png" alt="image-20210329110413577"></p>
<p>在抢锁之前，咨询条件变量。是否有必要抢锁（如果缓冲区满或空的时候）</p>
<p><strong>以前的顺序</strong></p>
<ol>
<li>抢锁</li>
<li>访问公共区</li>
<li>解锁</li>
</ol>
<p><strong>条件变量版本的顺序</strong></p>
<ol>
<li>判断条件变量</li>
<li>抢锁</li>
<li>访问公共区</li>
<li>解锁</li>
<li>唤醒阻塞在条件变量上的对端</li>
</ol>
<p>go标准库中的sync.Cond类型代表了条件变量，条件变量要与锁（互斥锁，或者读写锁）一起使用。成员变量L代表与条件变量搭配使用的锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line">  L Locker  <span class="comment">// 创建条件变量的时候，要指定其用的是什么锁</span></span><br><span class="line">  notify notifyList</span><br><span class="line">  checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的有3个常用方法，Wait，Signal，Broadcase</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(C *Cond)</span><span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">该函数的作用（一旦调用，会做下面三件事）</span></span><br><span class="line"><span class="comment">1. 阻塞等待条件变量满足</span></span><br><span class="line"><span class="comment">2. 释放已掌握的互斥锁相当于cond.L.Unlock() // 注意，1，2 两步为一个原子操作</span></span><br><span class="line"><span class="comment">3. 当被唤醒，Wait()函数返回时，解除阻塞并重新获取互斥锁，相当于cond.L.Lock()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 下面两个函数为 唤醒操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span><span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 单发通知，给一个正等待（阻塞）在该条件变量上的goroutinue 发送通知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span><span class="title">Broadcase</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 广播通知，给正在等待（阻塞）在该条件变量上的所有goroutinue发送通知 // 惊群效应</span></span><br></pre></td></tr></table></figure>

<p>使用条件变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义条件变量cond</span><br><span class="line"><span class="number">2.</span> cond.L--&gt;mutex ,指定一把锁</span><br><span class="line"><span class="number">3.</span> cond.L.lock() </span><br><span class="line"><span class="number">4</span> <span class="keyword">if</span> xxxx</span><br><span class="line">wait() <span class="comment">// 如果满足条件，做wait操作， wait包含3件事（一段时间的阻塞，解锁，加锁）</span></span><br></pre></td></tr></table></figure>

<p>一段时间的阻塞，解锁，加锁</p>
<p>为什么在等待的时候，要解开锁，一会儿又加上呢？</p>
<p>因为针对的对象是公共区（有缓冲channel），执行wait函数说明公共区达到了容器设定的条件。没办法继续往公共区读（写）数据。所以，当挂起等待的过程当中需要将锁让给对端。当对端写（读）数据之后，容器出现富余，它再唤醒对端，对端重新加上锁从而来访问公共区；</p>
<h2 id="7-定时器"><a href="#7-定时器" class="headerlink" title="7.  定时器"></a>7.  定时器</h2><p>time.Timer</p>
<p>Timer是一个定时器，代表未来的一个单一时间，你可以告诉timer你要等待多长时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;- <span class="keyword">chan</span> Time</span><br><span class="line">	r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统会自动向timer.C这个channel中写入当前时间，阻塞即被解除；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"current time"</span>, time.Now())</span><br><span class="line">	mytimer := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 定时时间到，系统会自动向timer.C这个channel写入了当前时间； </span></span><br><span class="line">	currentTime := &lt;-mytimer.C</span><br><span class="line">	fmt.Println(<span class="string">"currentTime is:"</span>, currentTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//current time 2021-03-28 19:27:55.330078 +0800 CST m=+0.000082012</span></span><br><span class="line"><span class="comment">//currentTime is: 2021-03-28 19:27:57.330273 +0800 CST m=+2.000328165</span></span><br></pre></td></tr></table></figure>



<h3 id="7-1-三种定时方法"><a href="#7-1-三种定时方法" class="headerlink" title="7.1 三种定时方法"></a>7.1 三种定时方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. sleep</span></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  <span class="comment">// 2. Timer.C</span></span><br><span class="line">  myTimer:= time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 定时器慢，系统自动写入系统时间</span></span><br><span class="line">  currentTime := &lt;-mytimer.C</span><br><span class="line">	fmt.Println(<span class="string">"currentTime is:"</span>, currentTime)</span><br><span class="line">  <span class="comment">// 3. time.After</span></span><br><span class="line">  nowTimer2 := time.After(time.Second*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>time.After定时：</p>
<p>指定定时时长，定时到达后，系统会自定向定时器的成员写入 系统当前时间。</p>
<p>返回可读 chan，读取，可获得系统写入时间；</p>
<p>总结： Sleep NewTimer， After 都是 time包的</p>
<h3 id="7-2-定时器的停止和重置"><a href="#7-2-定时器的停止和重置" class="headerlink" title="7.2 定时器的停止和重置"></a>7.2 定时器的停止和重置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  myTimer := time.NewTimer(time.Second * <span class="number">3</span>) <span class="comment">// 创建定时器</span></span><br><span class="line">  myTimer.Reset(<span class="number">1</span> *time.Second) <span class="comment">//重置定时器时长为1</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &lt;- myTimer.C</span><br><span class="line">    fmt.Println(<span class="string">"子go程，定时完毕"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  myTimer.Stop() <span class="comment">//设置定时器停止</span></span><br><span class="line">  <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-定时器周期定时"><a href="#7-3-定时器周期定时" class="headerlink" title="7.3 定时器周期定时"></a>7.3 定时器周期定时</h3><p>周一到周五每天早上8点起床上班</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"startTime:"</span>, time.Now())</span><br><span class="line">	myTicker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			nowTime := &lt;-myTicker.C</span><br><span class="line">			fmt.Println(<span class="string">"nowTime:"</span>, nowTime)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startTime: 2021-03-28 20:47:03.563903 +0800 CST m=+0.000099792</span></span><br><span class="line"><span class="comment">//nowTime: 2021-03-28 20:47:04.575006 +0800 CST m=+1.011228039</span></span><br><span class="line"><span class="comment">//nowTime: 2021-03-28 20:47:05.579668 +0800 CST m=+2.015915392</span></span><br><span class="line"><span class="comment">//nowTime: 2021-03-28 20:47:06.577759 +0800 CST m=+3.014031618</span></span><br></pre></td></tr></table></figure>



<p>可控的周期性定时器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	myTimer := time.NewTicker(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"now Time:="</span>, time.Now())</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			currentTime := &lt;-myTimer.C</span><br><span class="line">			i++</span><br><span class="line">			fmt.Println(<span class="string">"current Time:= "</span>, currentTime)</span><br><span class="line">      </span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">				quit &lt;- <span class="literal">true</span></span><br><span class="line">        runtime.Goexit()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>创建一个周期定时器 time.NewTicker，定时时长到达后，系统会自动向Ticker的C中写入系统当前时间，并且，每隔一个定时时长后，循环写入系统当前时间；</li>
<li>在子go程中循环读取C，获取系统写入的时间</li>
</ol>
<h2 id="8-内存模型：Go如何保证并发读写的顺序"><a href="#8-内存模型：Go如何保证并发读写的顺序" class="headerlink" title="8. 内存模型：Go如何保证并发读写的顺序"></a>8. 内存模型：Go如何保证并发读写的顺序</h2><h3 id="8-1-重排和可见性"><a href="#8-1-重排和可见性" class="headerlink" title="8.1 重排和可见性"></a>8.1 重排和可见性</h3><blockquote>
<p>由于指令重排，代码并不一定会按照你写的顺序执行</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello world"</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">// 这里未见一定输出 hello world，尽管你运行了100次都打印出来了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-happens-before"><a href="#8-2-happens-before" class="headerlink" title="8.2 happens-before"></a>8.2 happens-before</h3><blockquote>
<p>在一个goroutine内部，程序的执行顺序和它们的代码指定的顺序是一样的，即时编译器或者CPU重排了读写顺序，从行为上来看，也和代码指定的顺序一样；</p>
</blockquote>
<p>但是对于另一个goroutine来说，重排却产生非常大的影响。因为Go只保证goroutine内部重排对读写的顺序没有影响；</p>
<p>如果两个action（read或write）有明确的happens-before关系，你就可以确定它们之间的执行顺序（或者是行为表现上的顺序）</p>
<p>Go内存模型通过happens-before定义两个事件（读、写action）的顺序：</p>
<ul>
<li>如果事件e1 <code>happens before</code> 事件 e2，那么，我们就可以说事件e2在事件e1之后发生（happens after）</li>
<li>如果e1不是<code>happens before</code> e2，同时也不<code>happens after</code> e2，那么，我们就可以说事件 e1 和 e2 是同时发生的；</li>
</ul>
<p>如果要保证对 “变量v 的 读操作r” 能够观察到一个对 ”变量v 的 写操作w“， 并且r只能观察到w对变量v的写，没有其他对v的写操作，也就是说，我们要保证r绝对能观察到w操作的结果，那么就需要同时满足两个条件：</p>
<ol>
<li>w happens before r；</li>
<li>其他对v的写操作（w2，w3，w4，。。。）要么happens before w，要么happens after r， 绝对不和w、r同时发生，或者是在它们之间发生；</li>
</ol>
<p>在goroutine内部对一个局部变量v的读，一定能观察到最近一次对这个局部变量v的写。如果要保证多个goroutine之间对一个共享变量的读写顺序，在Go语言中，可以使用并发原语为读写操作建立happens-before关系；这样就可以保证顺序了；</p>
<ul>
<li>在Go语言中，对变量进行零值的初始化就是一个写操作；</li>
<li>如果对超过机器word（64bit，32bit或者其它）大小值进行读写，那么，就可以看作是对拆成word大小的几个读写无序进行；</li>
<li>Go并不提供直接的CPU屏障（CPU fence）来提示编译器或者CPU保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语；</li>
</ul>
<h3 id="8-3-Go语言中保证happens-before关系"><a href="#8-3-Go语言中保证happens-before关系" class="headerlink" title="8.3 Go语言中保证happens-before关系"></a>8.3 Go语言中保证happens-before关系</h3><h4 id="8-3-1-init函数"><a href="#8-3-1-init函数" class="headerlink" title="8.3.1 init函数"></a>8.3.1 init函数</h4><p>应用程序的初始化是在单一的goroutine执行，如果包p导入了包q， 那么，q的init函数的执行一定happens before p的任何初始化代码；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="keyword">import</span> <span class="string">"q"</span> <span class="comment">// q的init函数执行一定 happens before p的任何代码；</span></span><br></pre></td></tr></table></figure>

<p><em>main函数一定在导入包的init函数之后执行</em></p>
<h4 id="8-3-2-goroutine"><a href="#8-3-2-goroutine" class="headerlink" title="8.3.2 goroutine"></a>8.3.2 goroutine</h4><p><em>启动goroutine的go语句的执行，一定happens before此goroutine内的代码执行；</em></p>
<p>根据上面的规则，我们知道，如果go语句传入的参数是一个函数执行的结果，那么，这个函数一定先于goroutine内部的代码被执行；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">3</span>   <span class="built_in">print</span>(a)</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">6</span>   a = <span class="string">"hello,world"</span></span><br><span class="line"><span class="number">7</span>   <span class="keyword">go</span> f()</span><br><span class="line"><span class="number">8</span> &#125;</span><br></pre></td></tr></table></figure>

<p>第6 和 第7 在同一个goroutine执行，在main goroutine看来， 6 happens before 7.</p>
<p>7 子gouroutine happens before 第3行的变量输出，那么，可以推断出，第6行 happens before 第3行。</p>
<p>也就是说，在第3行 打印a的值的时候，肯定会打印出“hello world”；</p>
<p>启动goroutine的情况，goroutine退出的时候，是没有任何happens-before保证的。所以，如果你想观察某个goroutine的执行效果，你需要使用同步机制建立happens-before关系，比如Mutex或者Channel。</p>
<h4 id="8-3-3-channel"><a href="#8-3-3-channel" class="headerlink" title="8.3.3 channel"></a>8.3.3 channel</h4><p>通用的Channel happens-before关系保证有4条规则</p>
<ol>
<li>第一条规则</li>
</ol>
<p>往Channel中的发送操作，happens before 从该channel接收相应数据的动作完成之前；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  s= <span class="string">"hello,go"</span> <span class="comment">// 赋值</span></span><br><span class="line">  ch&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="comment">//  写channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> f()</span><br><span class="line">  &lt;-ch    <span class="comment">// 读channel</span></span><br><span class="line">  <span class="built_in">print</span>(s) <span class="comment">// 打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先‘赋值’  happens before ‘写channel’， ‘写channel’ happens before ‘读channel’；</p>
<p>‘打印’happens after ‘读channel’； 所以 ‘打印’必然输出 hello，go</p>
<ol start="2">
<li>第二条规则</li>
</ol>
<p>close一个channel的调用，肯定 happens before 从关闭的Channel中读取出一个零值；</p>
<ol start="3">
<li>第三条规则</li>
</ol>
<p>对于unbuffered的channel，读取channel数据的调用 一定 happens before  写入channel数据的调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">5</span>  s = <span class="string">"hello, go"</span></span><br><span class="line"><span class="number">6</span>  &lt;-ch</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">10</span>  <span class="keyword">go</span> f()</span><br><span class="line"><span class="number">11</span>  ch&lt;-<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="number">12</span>  <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果第11行发送语句执行成功，那么根据这个规则，第6行（接收）的调用肯定发生了，（执行完成不完成不重要，重要的是这一句“肯定执行了”），那么s也肯定初始化了，所以一定会打印出“hello ，go”</p>
<p>因为channel是unbuffered的Channel，所以这个规则也成立</p>
<ol start="4">
<li>第四条规则</li>
</ol>
<p>如果Channel的容量是m（m&gt;0），那么第n个 receive 一定 happens before 第 n+m 个 send 的完成；</p>
<h4 id="8-3-4-Mutex-RWMutex"><a href="#8-3-4-Mutex-RWMutex" class="headerlink" title="8.3.4 Mutex/RWMutex"></a>8.3.4 Mutex/RWMutex</h4><ol>
<li>第n次的m.Unlock 一定happens before第n+1 m.Lock方法的返回；</li>
<li>对于读写锁 RWMutex m，如果它的第 n 个 m.Lock 方法的调用已返回，那么它的第 n 个 m.Unlock 的方法调用一定 happens before 任何一个 m.RLock 方法调用的返回，只要这些 m.RLock 方法调用 happens after 第 n 次 m.Lock 的调用的返回。这就可以保证，只有释放了持有的写锁，那些等待的读请求才能请求到读锁。</li>
<li>对于读写锁 RWMutex m，如果它的第 n 个 m.RLock 方法的调用已返回，那么它的第 k （k&lt;=n）个成功的 m.RUnlock 方法的返回一定 happens before 任意的 m.RUnlockLock 方法调用，只要这些 m.Lock 方法调用 happens after 第 n 次 m.RLock。</li>
</ol>
<p>对于读写锁 i 的i.RLock方法调用，如果存在一个n，这次的 l.RLock 调用 happens after 第 n 次的 l.Unlock，那么，和这个 RLock 相对应的 l.RUnlock 一定 happens before 第 n+1 次 l.Lock。意思是，读写锁的 Lock 必须等待既有的读锁释放后才能获取到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">5</span>  s = <span class="string">"go"</span></span><br><span class="line"><span class="number">6</span>  mu.Unlock()</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">10</span>  mu.Lock()</span><br><span class="line"><span class="number">11</span>  <span class="keyword">go</span> foo()</span><br><span class="line"><span class="number">12</span>  m.Lock()</span><br><span class="line"><span class="number">13</span>  <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure>

<p>第6行第一次unLock 一定happens before第二次的Lock（第12行），所以这也能保证正确输出“go”</p>
<h4 id="8-3-5-WaitGroup"><a href="#8-3-5-WaitGroup" class="headerlink" title="8.3.5 WaitGroup"></a>8.3.5 WaitGroup</h4><p>Wait方法等到计数值归零之后才返回</p>
<h4 id="8-3-6-Once"><a href="#8-3-6-Once" class="headerlink" title="8.3.6 Once"></a>8.3.6 Once</h4><p>对于once.Do(f) 调用，f函数的那个单次调用一定happens before任何once.Do(f)调用的返回。换句话说，就是函数f一定会在Do方法返回之前执行；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">5</span>  s = <span class="string">"go"</span></span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">9</span>  once.Do(foo)</span><br><span class="line"><span class="number">10</span>  <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>

<p>第5行的执行一定happens before第9行的返回，所以执行到第10行的时候，s已经初始化了，所以会正确打印“go”</p>
<h4 id="8-3-7-atomic"><a href="#8-3-7-atomic" class="headerlink" title="8.3.7 atomic"></a>8.3.7 atomic</h4><p>现阶段还是不要使用atomic来保证顺序性；</p>
<h2 id="9-信号量"><a href="#9-信号量" class="headerlink" title="9. 信号量"></a>9. 信号量</h2><blockquote>
<p>信号量 是用来控制多个goroutine同时访问多个资源的并发原语；</p>
<p>信号量的概念是1963年提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等到可以继续进行的信号到来</p>
</blockquote>
<p>最简单的信号量就是一个变量加一些并发控制的能力，这个变量是 0 到 n 之间的一个数值。当 goroutine 完成对此信号量的等待（wait）时，该计数值就减 1，当 goroutine 完成对此信号量的释放（release）时，该计数值就加 1。当计数值为 0 的时候，goroutine 调用 wait 等待该信号量是不会成功的，除非计数器又大于 0，等待的 goroutine 才有可能成功返回。</p>
<ul>
<li>举例</li>
</ul>
<p>举个例子，图书馆新购买了 10 本《Go 并发编程的独家秘籍》，有 1 万个学生都想读这本书，“僧多粥少”。所以，图书馆管理员先会让这 1 万个同学进行登记，按照登记的顺序，借阅此书。如果书全部被借走，那么，其他想看此书的同学就需要等待，如果有人还书了，图书馆管理员就会通知下一位同学来借阅这本书。这里的资源是10本《Go 并发编程的独家秘籍》，想读此书的同学就是 goroutine，图书管理员就是信号量。</p>
<h3 id="9-1-P-V操作"><a href="#9-1-P-V操作" class="headerlink" title="9.1 P/V操作"></a>9.1 P/V操作</h3><p>P操作（descrease, wait, acquire） 减少信号量的计数值</p>
<p>V操作（increase, signal, release） 增加信号量的计数值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">V</span><span class="params">(semaphore S, integer I)</span>:</span></span><br><span class="line">	[S &lt;- S + I]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">P</span><span class="params">(semaphore S, integer I)</span>:</span></span><br><span class="line">	repeat:</span><br><span class="line">    [<span class="keyword">if</span> S&gt;= I:</span><br><span class="line">    S &lt;- S-I</span><br><span class="line">    <span class="keyword">break</span>]</span><br></pre></td></tr></table></figure>

<p>初始化信号量S有一个指定数量（n）的资源，它就像是一个有n个资源的池子。P操作相当于请求资源，如果资源可用，就立即返回； 如果没有资源或者不够，那么，它可以不断尝试或阻塞等待。</p>
<p>V操作会释放自己持有的资源，把资源返还给信号量，信号量的值除了初始化的操作以外，只能由P/V操作改变；</p>
<p>信号量的实现</p>
<ul>
<li>初始化信号量：设定初始的资源的数量</li>
<li>P操作： 将信号量的计数值减去1，如果新值已经为负，那么调用者会被阻塞并加入到等待队列中。否则，调用者会继续执行，并且获得一个资源；</li>
<li>V操作：将信号量的计数值加1，如果先前的计数值为负，就说明有等待的P操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行；</li>
</ul>
<p>其实，信号量可以分为计数信号量（counting semaphre）和二进位信号量（binary semaphore）。刚刚所说的图书馆借书的例子就是一个计数信号量，它的计数可以是任意一个整数。在特殊的情况下，如果计数值只能是 0 或者 1，那么，这个信号量就是二进位信号量，提供了互斥的功能（要么是 0，要么是 1），所以，有时候互斥锁也会使用二进位信号量来实现。</p>
<p>我们一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接，几个打印机资源，等等。如果信号量蜕变成二进位的信号量，那么，它的P/V就和互斥锁的Lock/Unlock一样了；</p>
<h3 id="9-2-官方扩展库实现"><a href="#9-2-官方扩展库实现" class="headerlink" title="9.2 官方扩展库实现"></a>9.2 官方扩展库实现</h3><p>在运行时，Go内部使用信号量来控制goroutine的阻塞和唤醒。</p>
<p>信号量的p/V操作是通过函数实现的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semacquire</span><span class="params">(s *<span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_SemacquireMutex</span><span class="params">(s *<span class="keyword">uint32</span>, lifo <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semrelease</span><span class="params">(s *<span class="keyword">uint32</span>, handoff <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>信号量的几个实现方法</p>
<ol>
<li>Acquire</li>
</ol>
<p>相当于 P 操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是 Context，这就意味着，你可以通过 Context 增加超时或者 cancel 的机制。如果是正常获取了资源，就返回 nil；否则，就返回 ctx.Err()，信号量不改变。</p>
<ol start="2">
<li>Release</li>
</ol>
<p>相当于V操作，可以将n个资源释放，返还给信号量。</p>
<ol start="3">
<li>TryAcquire</li>
</ol>
<p>尝试获取n个资源，但是它不会阻塞，要么成功获取n个资源，返回true，要么一个也不获取。返回false</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"golang.org/x/sync/semaphore"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	maxWorkers = runtime.GOMAXPROCS(<span class="number">0</span>)                    <span class="comment">// worker 数量</span></span><br><span class="line">	sema       = semaphore.NewWeighted(<span class="keyword">int64</span>(maxWorkers)) <span class="comment">// 信号量</span></span><br><span class="line">	task       = <span class="built_in">make</span>([]<span class="keyword">int</span>, maxWorkers*<span class="number">4</span>)                <span class="comment">// 任务数，是worker的四倍</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">main goroutine 相当于一个dispatcher，负责任务的分发，它先请求信号量，如果获取成功，就会启动一个goroutine去处理计算，然后</span></span><br><span class="line"><span class="comment">这个 goroutine会释放这个信号量（信号量的获取是在main goroutine，释放是在worker goroutine），如果获取不成功，就等到</span></span><br><span class="line"><span class="comment">信号量可以使用的时候，再去获取；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> task &#123;</span><br><span class="line">		<span class="comment">// 如果没有worker可用，会阻塞在这里，直到某个worker被释放</span></span><br><span class="line">		<span class="keyword">if</span> err := sema.Acquire(ctx, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 启动worker goroutine</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> sema.Release(<span class="number">1</span>)</span><br><span class="line">			time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">			task[i] = i + <span class="number">1</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 请求所有worker，这样能确保前面的worker都执行完 （想等所有的Worker都执行完，就可以获取最大计数值的信号量）</span></span><br><span class="line">	<span class="keyword">if</span> err := sema.Acquire(ctx, <span class="keyword">int64</span>(maxWorkers)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"获取所有worder失败: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-SingeFlight-和-SyclicBarrier"><a href="#10-SingeFlight-和-SyclicBarrier" class="headerlink" title="10. SingeFlight 和 SyclicBarrier"></a>10. SingeFlight 和 SyclicBarrier</h2><blockquote>
<p>SingeFlight将并发请求合并成一个请求， SyclicBarrier是一个可重用的栅栏并发原语，用来控制一组请求同时执行的数据结构</p>
</blockquote>
<h2 id="11-分组操作"><a href="#11-分组操作" class="headerlink" title="11 分组操作"></a>11 分组操作</h2><blockquote>
<p>共享资源保护、任务编排和消息传递是Go并发编程中常见的场景，而分组执行一批相同的或类似的任务则是任务编排中一类情形，分组编排的一些常用场景和并发原语，ErrGroup，gollback，Hunch和schedgroup</p>
</blockquote>
<h3 id="11-1-ErrGroup"><a href="#11-1-ErrGroup" class="headerlink" title="11.1 ErrGroup"></a>11.1 ErrGroup</h3><p>经常会碰到将一个通用的父任务拆成几个小任务并发执行的场景，其实，将一个大的任务拆成几个小任务并发执行。可以有效地提高程序的并发度，</p>
<p>ErrGroup就是用来应对这种场景的，它和WaitGroup有些类似，但是它提供功能更加丰富：</p>
<ul>
<li>和Context集成</li>
<li>error向上传播，可以把子任务的错误传递给Wait的调用者</li>
</ul>
<p>Api</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span><span class="params">(*Group, context.Context)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Go</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Wait</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h4 id="11-1-1-ErrGroup使用例子"><a href="#11-1-1-ErrGroup使用例子" class="headerlink" title="11.1.1 ErrGroup使用例子"></a>11.1.1 ErrGroup使用例子</h4><ul>
<li>返回第一个错误</li>
</ul>
<p>启动三个子任务，其中，子任务2会返回执行失败，其他两个执行成功。在三个子任务都执行后，group.Wait</p>
<p> 才会返回第2个子任务的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g errgroup.Group</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"exec #1"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"exec #2"</span>)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"failed to exec #2"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"exec #3"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待第三个任务都完成</span></span><br><span class="line">	<span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"successfully exec all"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec #1<br>exec #2<br>exec #3<br>failed: failed to exec #2</p>
<ul>
<li>返回所有子任务的错误</li>
</ul>
<p>Group只能返回子任务的第一个错误，后续的错误都会被丢弃，但是，有时候我们需要知道每个任务的执行情况，</p>
<p>我们使用一个result slice保存子任务的执行结果，这样，通过查询result，就可以知道每一个子任务的结果了；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g errgroup.Group</span><br><span class="line">	<span class="keyword">var</span> result = <span class="built_in">make</span>([]error, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"exec #1"</span>)</span><br><span class="line">		result[<span class="number">0</span>] = <span class="literal">nil</span> <span class="comment">//保存成功或者失败的结果</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"exec #2"</span>)</span><br><span class="line">		result[<span class="number">1</span>] = errors.New(<span class="string">"failed to exec #2"</span>)</span><br><span class="line">		<span class="keyword">return</span> result[<span class="number">1</span>]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"exec #3"</span>)</span><br><span class="line">		result[<span class="number">2</span>] = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待第三个任务都完成</span></span><br><span class="line">	<span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"successfully exec all. result:%v\n"</span>, result)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"failed: %v\n"</span>, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec #1<br>exec #2<br>exec #3<br>failed: [<nil> failed to exec #2 <nil>]</p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><blockquote>
<p>先用对姿势，go chan。  再去review底层实现</p>
</blockquote>
<h3 id="1-Goroutines-and-Parallelism"><a href="#1-Goroutines-and-Parallelism" class="headerlink" title="1. Goroutines and Parallelism"></a>1. Goroutines and Parallelism</h3><blockquote>
<p>go关键字可以快速让一个函数创建为goroutine，我们可以认为main函数就是作为goroutine执行的。操作系统调度线程在可用处理器上运行，go运行时调度goroutine在绑定到耽搁操作系统线程的逻辑处理器中运行（P）。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万goroutine以惊人的效率和性能并发运行。</p>
</blockquote>
<p>并发不是并行，并行是 指两个或多个线程同时在不同的处理器执行代码，如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配goroutine，这将导致goroutine在不同的操作系统线程上运行。但是，要获得真正的并行性，需要在具有多个物理处理器的计算机上运行程序。否则，goroutine将针对单个物理处理器并发运行，即使Go运行时使用多个逻辑处理器； </p>
<ul>
<li>keep yourself busy or do the work yourself</li>
</ul>
<p>空的select语句将永远阻塞  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// go关键字之后，可以理解为被扔到某一个核心上执行。并行或者并发执行。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">  <span class="comment">// go func出去之后，main是无法感知到的执行后续结果的；而且log.Fatal会导致当前goroutine的defer无法执行；</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 永远阻塞，防止main函数退出，main可看作是一个goroutine；main退出后导致main相关的资源被回收；</span></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的goroutine在从另一个goroutine获得结果之前无法取得进展，那么通常情况下，你自己去做这项工作比委托它（go func()) 更简单。</p>
<p>这通常消除了将结果从goroutine返回到其启动器所需的大量状态跟踪和chan操作；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err) <span class="comment">// 底层调用 os.Exit(1),会导致 defer无法执行；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-1不要启动一个goroutine，当你不知道它什么时候会结束"><a href="#1-1不要启动一个goroutine，当你不知道它什么时候会结束" class="headerlink" title="1.1不要启动一个goroutine，当你不知道它什么时候会结束"></a>1.1不要启动一个goroutine，当你不知道它什么时候会结束</h4><blockquote>
<p>（我们不仅要管error的panic，还要管goroutine的生命周期）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"hi"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="comment">// go出去的代码不知道什么时候会退出，什么时候会结束。我们需要管理goroutine的生命周期；</span></span><br><span class="line">	<span class="keyword">go</span> http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux)</span><br><span class="line">	http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动goroutine的时候通常需要问两个问题</p>
<ol>
<li>它什么时候结束；</li>
<li>如何让它结束；</li>
</ol>
<p>通过将serveApp 和 serveDebug处理程序分解为各自的函数，我们将它们与main.main 解耦，我们还遵循了上面的建议，并确保serveApp和serveDebug将它们的并发性留给调用者</p>
<p>如果serveApp返回，则main.main将返回导致程序关闭，只能靠类似supervisor进行管理来重新启动</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过将serveApp 和 serveDebug处理程序分解为各自的函数，我们将它们与main.main 解耦，我们还遵循了上面的建议，</span></span><br><span class="line"><span class="comment">并确保serveApp和serveDebug将它们的并发性留给调用者。如果serveApp返回，则main.main将返回导致程序关闭，</span></span><br><span class="line"><span class="comment">只能靠类似supervisor进行管理来重新启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux); err != <span class="literal">nil</span> 	&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug() <span class="comment">// 如果serveDebug异常，该goroutine会退出，而程序的其余部分继续运行，main函数依然感知不到；</span></span><br><span class="line">	serveApp() <span class="comment">// 因为serveApp会阻塞，所以main不会被退出；，如果该函数异常退出，则进程退出；只能依赖类似supervisor进程管理来拉起</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>继续迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux); err != <span class="literal">nil</span> 	&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe 返回nil error，最终main.main无法退出</span></span><br><span class="line"><span class="comment">// log.Fatal调用了os.Exit,会无条件终止程序；defers不会被调用到；</span></span><br><span class="line"><span class="comment">// 一般log.Fatal 只会在main.main和init functions中使用；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug()</span><br><span class="line">	<span class="keyword">go</span> serveApp()</span><br><span class="line">  <span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(addr <span class="keyword">string</span>, handler http.Handler, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr:    addr,</span><br><span class="line">		Handler: handler,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stop <span class="comment">//wait for stop signal</span></span><br><span class="line">		<span class="comment">// 通过外部的信号，通知内部的goroutine；</span></span><br><span class="line">		<span class="comment">// 让其可以正常执行Shutdown方法</span></span><br><span class="line">		s.Shutdown(context.Background())</span><br><span class="line">		<span class="comment">// 执行Shutdown之后，s.ListenAndServe() 就会退出；</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.ListenAndServe() <span class="comment">// 一旦报错会返回error，然后告诉调用方安全退出goroutine。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeApp</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">"0.0.0.0:8080"</span>, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeDebug</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// done 是知道对方什么时候退出；</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// stop 是控制内部相互通知两个人可以退出；</span></span><br><span class="line">	stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 空结构体，表示0 size的一个东西</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 让调用者启goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- ServeDebug(stop)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- ServeApp(stop)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stopped <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// cap(done) = 2;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"error: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !stopped &#123;</span><br><span class="line">			<span class="comment">// 但凡有一个报错，就调用close，来唤醒serveDebug和serveApp</span></span><br><span class="line">			stopped = <span class="literal">true</span></span><br><span class="line">			<span class="built_in">close</span>(stop)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>总结</li>
</ul>
<ol>
<li>让调用者决定一个goroutine到底需要在后台执行还是前台执行。</li>
<li>如果要启动一个goroutine，那么一定要知道它什么时候能够结束。有没有一个手段让它结束。知道它什么时候可以返回。</li>
</ol>
<h4 id="1-2-Leave-concurrency-to-the-caller"><a href="#1-2-Leave-concurrency-to-the-caller" class="headerlink" title="1. 2 Leave concurrency to the caller"></a>1. 2 Leave concurrency to the caller</h4><blockquote>
<p> 将并发逻辑交给调用者,不应该在内部去搞goroutine然后让消费者来处理。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传一个目录路径做参数，然后将目录路径列举出来；</span></span><br><span class="line"><span class="comment">// dir 目录路径，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span><span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>万一传递的目录树很大，是否可以使用chan 不断的去读取</p>
<p>上面两个function的做法</p>
<ol>
<li>将目录读取到一个slice中，然后返回整个切片，或者如果出现错误，则返回错误。这是同步调用的，ListDirectory的调用方会阻塞，直到读取所有目录条目。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目名称的slice；</li>
<li>第二个函数的做法是返回一个chan string, 将通过该chan 传递目录，当通道关闭时，这表示不再有目录。由于在ListDirectory返回后发生通道的填充，ListDirectory可能内部启动goroutine来填充通道；</li>
</ol>
<p>ListDirectory chan版本还有两个问题：</p>
<ol>
<li>通过使用一个关闭的通道作为不再需要处理的项目的信号，ListDirectory无法告诉调用者通过通道返回的项目集不完整，因为中途遇到了错误。调用方无法区分空目录（读完了）与完全从目录读取的错误之间的区别，这两种方法都会导致从ListDirectory返回的通道会立即关闭；</li>
<li>调用者必须继续从通道读取，直到它关闭，因为这是调用者知道开始填充通道的goroutine已经停止的唯一方法。这对ListDirectory的使用是一个严重的限制，调用者必须花时间从通道读取数据，即使它可能已经收到了它想要的答案。对于大中型目录，它可能在内存使用方面更为高效，但这种方法并不比原始的基于slice的方法快；</li>
</ol>
<ul>
<li>建议的做法</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>, fn <span class="keyword">func</span>(<span class="keyword">string</span>)</span>)</span></span><br><span class="line"><span class="comment">// 不断枚举目录，然后执行回调函数fn</span></span><br></pre></td></tr></table></figure>

<p>filepath.WalkDir也是类似的模型，如果函数启动goroutine，则必须向调用方提供显式停止该goroutine的方法。通常，将异步执行函数的决定权交给该函数的调用方通常更容易；</p>
<p>因此，设计一个并发函数的时候。可以参考官方的API吧；</p>
<h4 id="1-3-不用启动一个不知道什么时候结束的goroutine"><a href="#1-3-不用启动一个不知道什么时候结束的goroutine" class="headerlink" title="1.3 不用启动一个不知道什么时候结束的goroutine"></a>1.3 不用启动一个不知道什么时候结束的goroutine</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">search函数是一个模拟实现，用于模拟长时间运行的操作，如数据库</span></span><br><span class="line"><span class="comment">查询或者rpc调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(term <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"some value"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">定义一个名为process的函数，接受字符串参数，传递给search，对于某</span></span><br><span class="line"><span class="comment">些应用程序，顺序调用产生的延迟可能是不可接受的；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(term <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	record, err := search(term) <span class="comment">// 不确定search返回的时机；所以goroutine就会阻塞堆积</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Received:"</span>, record)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，一定要做<strong>代码超时控制</strong>；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(term <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"some value"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">	record <span class="keyword">string</span></span><br><span class="line">	err    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(term <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个100 之后结束的context</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="comment">// make a channel for the goroutine to report result.</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">	<span class="comment">// launch a goroutine to find the record. Create a result</span></span><br><span class="line">	<span class="comment">// from the returned values to send through the channel</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 此goroutine也会被context级联取消退出；</span></span><br><span class="line">		record, err := search(term)</span><br><span class="line">		<span class="comment">// 将search执行结果拿给chan来接收</span></span><br><span class="line">		ch &lt;- result&#123;record, err&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// Block waiting to either receive from the goroutine's</span></span><br><span class="line">	<span class="comment">// channel or for the context to be canceled;</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"search canceled"</span>)</span><br><span class="line">	<span class="keyword">case</span> result := &lt;-ch:</span><br><span class="line">		<span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> result.err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"Received:"</span>, result.record)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-另外一种导致goroutine泄漏"><a href="#1-4-另外一种导致goroutine泄漏" class="headerlink" title="1.4 另外一种导致goroutine泄漏"></a>1.4 另外一种导致goroutine泄漏</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用服务端埋点来跟踪记录一些事件</span></span><br><span class="line"><span class="comment">// Tracker knows how to track events for the application</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tracker <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">	track Tracker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上报event事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tracker)</span> <span class="title">Event</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Simulate network write latency</span></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	log.Println(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法保证创建的goroutine生命周期管理，会导致最场景的问题，</span></span><br><span class="line"><span class="comment">// 就是在服务关闭时候，有一些事件丢失</span></span><br><span class="line"><span class="comment">// App holds application state</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle represents example handler for the web service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Do some actual work</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Respond to the client</span></span><br><span class="line">	w.WriteHeader(http.StatusCreated)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fire and Hope</span></span><br><span class="line">	<span class="comment">// <span class="doctag">BUG:</span> We are not managing this goroutine</span></span><br><span class="line">	<span class="comment">// 无法管控这个goroutine，因为Event函数内部可能sleep 1毫秒，可能sleep一分钟</span></span><br><span class="line">	<span class="keyword">go</span> a.track.Event(<span class="string">"this event"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>good part</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	tr := NewTracker()</span><br><span class="line">	<span class="keyword">go</span> tr.Run()</span><br><span class="line">	_ = tr.Event(context.Background(), <span class="string">"test"</span>)</span><br><span class="line">	_ = tr.Event(context.Background(), <span class="string">"test"</span>)</span><br><span class="line">	_ = tr.Event(context.Background(), <span class="string">"test"</span>)</span><br><span class="line">	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(<span class="number">2</span>*time.Second))</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	tr.Shutdown(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTracker</span><span class="params">()</span> *<span class="title">Tracker</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Tracker&#123;</span><br><span class="line">		ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tracker knows how to track events for the application</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tracker <span class="keyword">struct</span> &#123;</span><br><span class="line">	ch   <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">	stop <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递context为了管控生命周期</span></span><br><span class="line"><span class="comment">// 用channel来做，而不是创建大量的goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tracker)</span> <span class="title">Event</span><span class="params">(ctx context.Context, data <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.ch &lt;- data:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">return</span> ctx.Err()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在后台消费消息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tracker)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> data := <span class="keyword">range</span> t.ch &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	&#125;</span><br><span class="line">	t.stop &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tracker)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="built_in">close</span>(t.ch)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-t.stop:</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><p>用channel而不是大量创建goroutine；</p>
<p>搞清楚channel什么时候退出，</p>
<p>同时能够控制channel什么时候退出；</p>
<p>将函数的并发主动权 交给调用者；</p>
<p>管理goroutine的生命周期就是管其什么时机退出，</p>
<ul>
<li>毛毛学go（最快的学习方式）</li>
</ul>
<ol>
<li>通篇看文档</li>
<li>然后看二手资料（别人的理解）</li>
</ol>
<h2 id="Memory-model"><a href="#Memory-model" class="headerlink" title="Memory model"></a>Memory model</h2><blockquote>
<p>如何保证在一个goroutine中看到在另一个goroutine修改的变量的值，如果程序中修改数据时有其他goroutine同时读取，那么必须将读取串行化，为了串行化访问，请使用channel或其他同步原语，例如sync 和 sync/atomic来保护数据</p>
</blockquote>
<h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h3><p>在一个goroutine中，读和写一定是按照程序中的顺序执行的，即编译器和处理器只有在不会改变这个goroutine的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine可能会看到不同的执行顺序。例如，一个goroutine执行a=1,b=2;另一个goroutine可能看到b在a之前更新</p>
<table>
<thead>
<tr>
<th></th>
<th>线程1</th>
<th></th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A=1</td>
<td>3</td>
<td>B=1</td>
</tr>
<tr>
<td>2</td>
<td>print(B)</td>
<td>4</td>
<td>print(A)</td>
</tr>
</tbody></table>
<p>是有可能打印出来两个1，原因就是产生了内存重排；</p>
<h3 id="Memory-Reordering"><a href="#Memory-Reordering" class="headerlink" title="Memory Reordering"></a>Memory Reordering</h3><blockquote>
<p>用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU的设计者们，为了榨干CPU的性能，无所不用其极，像流水线、分支预测等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的内存重排，英文Memory Recordering</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器重排</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="keyword">range</span>(<span class="number">100</span>):</span><br><span class="line">		x = <span class="number">1</span></span><br><span class="line">		<span class="built_in">print</span> x</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="keyword">range</span>(<span class="number">100</span>):</span><br><span class="line">		<span class="built_in">print</span> x</span><br></pre></td></tr></table></figure>

<p>但是，如果这时有另外一个线程同时干了这么一件事： <code>x=0</code></p>
<p>在多核心场景下，没有办法轻易判断两段程序是“等价”的；</p>
<p>现代CPU为了“抚平”内核、内存、硬盘之间的速度差异，搞出了各种策略，例如三级缓存等。</p>
<p>为了让（2）不必等待（1）的执行“效果”可见之后才能执行，</p>
<p>我们可以把（1）的效果保存到store buffer：</p>
<p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/goparallel/mr1.png" alt="image-20210712181109041"></p>
<p>store buffer 对单线程是完美的；</p>
<p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/goparallel/mr2.png" alt="image-20210712182237345"></p>
<p>先执行（1）和（3），将他们直接写入store buffer，接着执行（2）和（4）</p>
<p>（2）看了下store buffer，并没有发现有B的值，于是从Memory读出了0，（4）同样从Memory读出了0，最后，打印出了0 0；</p>
<p>因此，对于多线程的程序，所有的CPU都会提供“锁”支持，称之为barrier，或者fence。它要求：barrier指令要求所有对内存的操作都必须要“扩散”到memory之后才能继续执行其他对memory的操作。因此，我们可以用高级点的atomic compare-and-swap，或者直接用更高级的锁，通常是标准库提供；</p>
<h3 id="Memory-model-1"><a href="#Memory-model-1" class="headerlink" title="Memory model"></a>Memory model</h3><blockquote>
<p>为了说明读和写的必要条件，我们定义了先行发生（Happens Before）。如果事件e1 发生在 e2 前，我们可以说e2 发生在e1 后。如果e1 不发生在e2 前也不发生在e2 后，我们就说e1 和 e2 是并发的；</p>
</blockquote>
<p>在单一的独立的goroutine中先行发生的顺序即是顺序中表达的顺序；</p>
<p>当下面条件满足时，对变量v的读操作r是被允许看到对v的写操作w的：</p>
<ol>
<li>r不先行发生于w</li>
<li>在w后r前没有对v的其他写操作</li>
</ol>
<p>为了保证对变量v的读操作r看到对v的写操作w，要确保w是r允许看到的唯一写操作。即当下面条件满足时，r被保证看到w</p>
<ol>
<li>w先行发生于r</li>
<li>其他对共享变量v的写操作要么在w前，要么在r后；</li>
</ol>
<p>这一对条件比前面的条件更严格，需要没有其他写操作与w或r并发发生；</p>
<p>单个goroutine中没有并发，所以上面两个定义是相同的：</p>
<p>读操作r看到最近一次的写操作w写入v的值。</p>
<p>当多个goroutine访问共享变量v时，它们必须使用同步事件来建立先行发生这一条件来保证读操作能看到需要的写操作</p>
<ul>
<li>对变量v的零值初始化在内存模型中表现的与写操作相同</li>
<li>对大量single machine word（机器字：多个内存是可以原子赋值的）的变量的读写操作表现的像以不确定顺序对多个single machine word的变量的操作</li>
</ul>
<p><a href="https://www.jianshu.com/p/5e44168f47a3" target="_blank" rel="noopener">https://www.jianshu.com/p/5e44168f47a3</a></p>
<h2 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package sync</h2><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h2 id="Package-context"><a href="#Package-context" class="headerlink" title="Package context"></a>Package context</h2><blockquote>
<p>及联的传递</p>
</blockquote>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p>Need all read</p>
</blockquote>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2021/06/01/goparallel/>http://yoursite.com/2021/06/01/goparallel/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-07-13T14:58:15+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Jul 13, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/guide/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>guide</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2021/06/01/goparallel/&title=goparallel - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2021/06/01/goparallel/&title=goparallel - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2021/06/01/goparallel/&title=goparallel - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2021/06/09/microservice/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>microservice</p>
                <p class='content'>微服务绪论
工程方法论，方法， 理念；
抛出一个实际问题是如何解答；
1. 微服务概览1.1 组件服务化
传统实现组件的方式是通过库，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新...</p>
              </a>
            
            
              <a class='next' href='/2021/05/28/GMP/'>
                <p class='title'>GMP<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>

本节为重点章节本章节含视频版:





一、Golang“调度器”的由来？(1) 单进程时代不需要调度器我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'goparallel',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-并行与并发"><span class="toc-text">1. 并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-并行（parallel）"><span class="toc-text">1.1 并行（parallel）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-并发"><span class="toc-text">1.2 并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-线程同步"><span class="toc-text">1.3 线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-线程同步机制："><span class="toc-text">1.3.1 线程同步机制：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-协程并发"><span class="toc-text">1.4 协程并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-小结"><span class="toc-text">1.5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-goroutine"><span class="toc-text">2. goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-概论"><span class="toc-text">3.1 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-启动goroutine"><span class="toc-text">3.1.1 启动goroutine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-不止一个goroutine"><span class="toc-text">3.1.2 不止一个goroutine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-goroutine的参数"><span class="toc-text">3.1.3 goroutine的参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-runtime包"><span class="toc-text">3.2 runtime包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Gosched"><span class="toc-text">3.2.1 Gosched</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Goexit"><span class="toc-text">3.2.2 Goexit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-runtime-GOMAXPROCS"><span class="toc-text">3.2.3 runtime.GOMAXPROCS()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-channel"><span class="toc-text">3. channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0-channel应用场景的五种类型"><span class="toc-text">3.0 channel应用场景的五种类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-1-数据交流"><span class="toc-text">3.0.1 数据交流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-2-数据传递"><span class="toc-text">3.0.2 数据传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-0-3-信号通知"><span class="toc-text">4.0.3 信号通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-0-4-任务编排"><span class="toc-text">4.0.4 任务编排</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0-4-1-Or-Done模式"><span class="toc-text">4.0.4.1 Or-Done模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0-4-2-扇入模式"><span class="toc-text">4.0.4.2 扇入模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0-4-3-扇出模式"><span class="toc-text">4.0.4.3 扇出模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0-4-4-Stream"><span class="toc-text">4.0.4.4 Stream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0-4-5-Map-Reduce"><span class="toc-text">4.0.4.5 Map-Reduce</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-0-5-锁"><span class="toc-text">4.0.5 锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-channel语法"><span class="toc-text">4.1 channel语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-channel实现原理"><span class="toc-text">4.2 channel实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-channel的数据结构"><span class="toc-text">4.2.1 channel的数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-groutine-通信"><span class="toc-text">4.2 groutine 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-无缓冲的channel"><span class="toc-text">4.3 无缓冲的channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-channel同步，数据传递"><span class="toc-text">4.3.1 channel同步，数据传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-channel的len和cap"><span class="toc-text">4.3.2 channel的len和cap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-关闭channel"><span class="toc-text">4.4 关闭channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-单向channel"><span class="toc-text">4.5 单向channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-生产者消费者模型"><span class="toc-text">4.6 生产者消费者模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-channel作为参数传递，是引用传递"><span class="toc-text">4.7 channel作为参数传递，是引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-模拟订单"><span class="toc-text">4.8 模拟订单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-定时器"><span class="toc-text">4.9 定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-channel（通道）发送、接收"><span class="toc-text">4.10 channel（通道）发送、接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-使用select处理多个通道"><span class="toc-text">4.11 使用select处理多个通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-nil通道"><span class="toc-text">4.12 nil通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-nil通道的用处："><span class="toc-text">2.3.1 nil通道的用处：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-阻塞和死锁"><span class="toc-text">3 阻塞和死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-地鼠装配线"><span class="toc-text">3.1 地鼠装配线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-常用模式"><span class="toc-text">3.2 常用模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-并发状态"><span class="toc-text">4 并发状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-共享值与竞争条件（race-condition）"><span class="toc-text">4.1 共享值与竞争条件（race condition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Go的互斥锁-mutex"><span class="toc-text">4.2 Go的互斥锁(mutex)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-互斥锁的实现机制"><span class="toc-text">4.2 互斥锁的实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-同步并发原语"><span class="toc-text">4.2.1 同步并发原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-Locker-接口"><span class="toc-text">4.2.2 Locker 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-sync-Mutex"><span class="toc-text">4.2.3 sync.Mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-go-race-detector"><span class="toc-text">4.2.4 go race detector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-mutex的用法"><span class="toc-text">4.2.5 mutex的用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-互斥锁的隐患和易错点"><span class="toc-text">4.3 互斥锁的隐患和易错点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-死锁"><span class="toc-text">4.3.1  死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-Lock-Unlock不成对出现"><span class="toc-text">4.3.2 Lock&#x2F;Unlock不成对出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-Copy已使用的Mutex"><span class="toc-text">4.3.3 Copy已使用的Mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-重入"><span class="toc-text">4.3.4 重入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-WaitGroup"><span class="toc-text">4.4 WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Cond"><span class="toc-text">4.5 Cond</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-once"><span class="toc-text">4.6 once</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-context"><span class="toc-text">4.7 context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-atomic"><span class="toc-text">4.8 atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-1-atomic提供的方法"><span class="toc-text">4.8.1 atomic提供的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-2-Value类型"><span class="toc-text">4.8.2 Value类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-map"><span class="toc-text">4.9 map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-1-实现线程安全的map类型"><span class="toc-text">4.9.1 实现线程安全的map类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-2-应对特殊场景的sync-Map"><span class="toc-text">4.9.2 应对特殊场景的sync.Map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-pool"><span class="toc-text">4.10 pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-长时间运行的工作进程"><span class="toc-text">4.4 长时间运行的工作进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-事件循环和goroutine"><span class="toc-text">4.5 事件循环和goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-互斥锁的实现"><span class="toc-text">4.6 互斥锁的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-初版mutex实现"><span class="toc-text">4.6.1 初版mutex实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-select"><span class="toc-text">5. select</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-select的作用"><span class="toc-text">5.1 select的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-select基本使用"><span class="toc-text">5.2 select基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-select实现斐波那契数列"><span class="toc-text">5.3 select实现斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-超时"><span class="toc-text">5.4 超时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Lock"><span class="toc-text">6. Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-死锁"><span class="toc-text">6.1 死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-互斥锁"><span class="toc-text">6.2 互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-读写锁"><span class="toc-text">6.3 读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-条件变量"><span class="toc-text">6.4 条件变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-定时器"><span class="toc-text">7.  定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-三种定时方法"><span class="toc-text">7.1 三种定时方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-定时器的停止和重置"><span class="toc-text">7.2 定时器的停止和重置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-定时器周期定时"><span class="toc-text">7.3 定时器周期定时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-内存模型：Go如何保证并发读写的顺序"><span class="toc-text">8. 内存模型：Go如何保证并发读写的顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-重排和可见性"><span class="toc-text">8.1 重排和可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-happens-before"><span class="toc-text">8.2 happens-before</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Go语言中保证happens-before关系"><span class="toc-text">8.3 Go语言中保证happens-before关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-init函数"><span class="toc-text">8.3.1 init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-goroutine"><span class="toc-text">8.3.2 goroutine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-channel"><span class="toc-text">8.3.3 channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-4-Mutex-RWMutex"><span class="toc-text">8.3.4 Mutex&#x2F;RWMutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-5-WaitGroup"><span class="toc-text">8.3.5 WaitGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-6-Once"><span class="toc-text">8.3.6 Once</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-7-atomic"><span class="toc-text">8.3.7 atomic</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-信号量"><span class="toc-text">9. 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-P-V操作"><span class="toc-text">9.1 P&#x2F;V操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-官方扩展库实现"><span class="toc-text">9.2 官方扩展库实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-SingeFlight-和-SyclicBarrier"><span class="toc-text">10. SingeFlight 和 SyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-分组操作"><span class="toc-text">11 分组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-ErrGroup"><span class="toc-text">11.1 ErrGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-ErrGroup使用例子"><span class="toc-text">11.1.1 ErrGroup使用例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutine"><span class="toc-text">Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Goroutines-and-Parallelism"><span class="toc-text">1. Goroutines and Parallelism</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1不要启动一个goroutine，当你不知道它什么时候会结束"><span class="toc-text">1.1不要启动一个goroutine，当你不知道它什么时候会结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Leave-concurrency-to-the-caller"><span class="toc-text">1. 2 Leave concurrency to the caller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-不用启动一个不知道什么时候结束的goroutine"><span class="toc-text">1.3 不用启动一个不知道什么时候结束的goroutine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-另外一种导致goroutine泄漏"><span class="toc-text">1.4 另外一种导致goroutine泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-总结"><span class="toc-text">1.5 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-model"><span class="toc-text">Memory model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Happen-Before"><span class="toc-text">Happen-Before</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Reordering"><span class="toc-text">Memory Reordering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-model-1"><span class="toc-text">Memory model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Package-sync"><span class="toc-text">Package sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chan"><span class="toc-text">chan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Package-context"><span class="toc-text">Package context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-text">References</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
