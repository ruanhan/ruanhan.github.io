<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>GMP - Hexo</title>
  
    <meta name="keywords" content="guide">
  
  
    <meta name="description" content="GMP(转载的,https://www.kancloud.cn/aceld/golang/1958305)">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2021/05/28/GMP/">
      GMP
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/go/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>go</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：May 28, 2021</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <ul>
<li><blockquote>
<p>本节为<strong>重点</strong>章节<br>本章节含视频版:</p>
</blockquote>
</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx" target="_blank" rel="noopener"><img src="https://img.kancloud.cn/8c/36/8c367cb1f4ce2839f6ebc2f909372eba_1362x692.png" alt="img"></a></p>
<hr>
<h2 id="一、Golang“调度器”的由来？"><a href="#一、Golang“调度器”的由来？" class="headerlink" title="一、Golang“调度器”的由来？"></a>一、Golang“调度器”的由来？</h2><h3 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代”</p>
<p>一切的程序只能串行发生。</p>
<p><img src="https://img.kancloud.cn/30/f7/30f77ecceb7ae3b3f0911bf7c8904599_1586x1184.png" alt="img"></p>
<p>早期的单进程操作系统，面临2个问题：</p>
<p>1.单一的执行流程，计算机只能一个任务一个任务处理。</p>
<p>2.进程阻塞所带来的CPU时间浪费。</p>
<p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p>
<p>后来操作系统就具有了<strong>最早的并发能力：多进程并发</strong>，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<h3 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)多进程/线程时代有了调度器需求"></a>(2)多进程/线程时代有了调度器需求</h3><p><img src="https://img.kancloud.cn/de/49/de49ef2a1ef0fc553754b5ea87e133a6_1522x1332.png" alt="img"></p>
<p>在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p>
<p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p>
<p><strong>怎么才能提高CPU的利用率呢？</strong></p>
<p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p>
<p><img src="https://img.kancloud.cn/b1/d1/b1d10153ae6c22754d38328379fa395f_1442x976.png" alt="img"></p>
<p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3)协程来提高CPU利用率"></a>(3)协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</p>
<p>大量的进程/线程出现了新的问题</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗CPU</li>
</ul>
<p>好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。</p>
<p>一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。</p>
<p><img src="https://img.kancloud.cn/47/e3/47e396eea8f0e71532356197412d52f1_1294x1106.png" alt="img"></p>
<p> 这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”.</p>
<p><img src="https://img.kancloud.cn/45/9d/459db145d4e702994548a1757238946f_1248x1064.png" alt="img"></p>
<p> 看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p>
<p> 之后，我们就看到了有3中协程和线程的映射关系：</p>
<blockquote>
<h4 id="N-1关系"><a href="#N-1关系" class="headerlink" title="N:1关系"></a>N:1关系</h4></blockquote>
<p>N个协程绑定1个线程，优点就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</p>
<p>缺点：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
</ul>
<p><img src="https://img.kancloud.cn/f8/d7/f8d715899f6db333d37f2bf738116bfd_1352x1092.png" alt="img"></p>
<blockquote>
<h4 id="1-1-关系"><a href="#1-1-关系" class="headerlink" title="1:1 关系"></a>1:1 关系</h4></blockquote>
<p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</p>
<p>缺点：</p>
<ul>
<li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
</ul>
<p><img src="https://img.kancloud.cn/cf/9a/cf9a59f9776bf4c9cbbad6103b6c5e5a_1322x1112.png" alt="img"></p>
<blockquote>
<h4 id="M-N关系"><a href="#M-N关系" class="headerlink" title="M:N关系"></a>M:N关系</h4></blockquote>
<p>M个协程绑定1个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p>
<p><img src="https://img.kancloud.cn/00/37/0037f6c2e12ad82a912990bba3e0085c_1336x1112.png" alt="img"></p>
<p> 协程跟线程是有区别的，线程由CPU调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出CPU后，才执行下一个协程。</p>
<p>瓶颈就在协程调度器上了，协程调度器做的越好，整个架构性能越好；因为这个架构底层的线程涉及的CPU调度器是内核级别，是无法改变的；</p>
<h3 id="4-Go语言的协程goroutine"><a href="#4-Go语言的协程goroutine" class="headerlink" title="(4)Go语言的协程goroutine"></a>(4)Go语言的协程goroutine</h3><p><strong>Go为了提供更容易使用的并发方法，使用了goroutine和channel</strong>。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p>
<p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。</p>
<p>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(runtime调度)</li>
</ul>
<h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5)被废弃的goroutine调度器"></a>(5)被废弃的goroutine调度器</h3><p> 好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p>
<p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<blockquote>
<p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p>
</blockquote>
<p><img src="https://img.kancloud.cn/e1/49/e1499cd06be0cdbee19ac4ada8537326_984x738.png" alt="img"></p>
<p> 下面我们来看看被废弃的golang调度器是如何实现的？</p>
<p><img src="https://img.kancloud.cn/bd/cd/bdcdc5e6fcb03244a9843333cca62378_1292x860.png" alt="img"></p>
<p> M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>老调度器有几个缺点：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li>
<li>M转移G会造成<strong>延迟和额外的系统负载</strong>。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了<strong>很差的局部性</strong>，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p>
<p>在新调度器中，出列M(thread)和G(goroutine)，又引进了P(Processor)。</p>
<p><img src="https://img.kancloud.cn/6b/db/6bdb04101cc63565c17cd8fcaba17321_1068x876.png" alt="img"></p>
<p><strong>Processor，处理器，它是用来处理goroutine的，它包含了运行每一个goroutine的资源</strong>，</p>
<p>如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1)GMP模型"></a>(1)GMP模型</h3><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。</p>
<p><img src="https://img.kancloud.cn/eb/fe/ebfe3e28315f12a08fbb4ffaee32e046_1024x768.png" alt="img"></p>
<ol>
<li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li>
<li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li><strong>P列表</strong>：所有的P都在“程序启动时”创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。可通过环境变量$GOMAXPROCS或者在程序中通过runtime.GOMAXPROCS来设置；</li>
<li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
</ol>
<p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。</p>
<blockquote>
<h4 id="有关P和M的个数问题"><a href="#有关P和M的个数问题" class="headerlink" title="有关P和M的个数问题"></a>有关P和M的个数问题</h4></blockquote>
<p>1、P的数量：</p>
<ul>
<li>由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS</code>个goroutine在同时运行。</li>
</ul>
<p>2、M的数量:</p>
<ul>
<li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li>runtime/debug中的SetMaxThreads函数，设置M的最大数量</li>
<li>一个M阻塞了，会创建新的M。</li>
</ul>
<p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p>
<blockquote>
<h4 id="P和M何时会被创建"><a href="#P和M何时会被创建" class="headerlink" title="P和M何时会被创建"></a>P和M何时会被创建</h4></blockquote>
<p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p>
<p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p>
<h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2)调度器的设计策略"></a>(2)调度器的设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p>
<p>1）work stealing机制</p>
<p> 当本线程（本P）无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p>
<p>2）hand off机制</p>
<p> 当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p>
<p><strong>利用并行</strong>：<code>GOMAXPROCS</code>设置P的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的CPU核进行并行。</p>
<p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p>
<p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p>
<h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func() 调度流程"></a>(3) go func() 调度流程</h3><p><img src="https://img.kancloud.cn/76/4f/764f7be119026cc16314e87628e4013f_1920x1080.jpeg" alt="img"></p>
<p>从上图我们可以分析出几个结论：</p>
<p> 1、我们通过 go func()来创建一个goroutine；</p>
<p> 2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p>
<p> 3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p>
<p> 4、一个M调度G执行的过程是一个循环机制；</p>
<p> 5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p>
<p> 6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p>
<h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4)调度器的生命周期"></a>(4)调度器的生命周期</h3><blockquote>
<p>当启动一个go进程的时候，它是如何创建初始化这些线程和协程的。包括是如何启动main函数这么样的一个过程。调度器是如何完成的；</p>
<p>M0和G0: 一个特殊的线程和协程</p>
</blockquote>
<p><img src="https://img.kancloud.cn/b3/10/b31027eeb493fa86654b41d46f34a98b_439x872.png" alt="img"></p>
<p>特殊的M0和G0</p>
<p><strong>M0</strong></p>
<p><code>M0</code>是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p>
<p>(M0跟进程数量绑定，1比1的关系)</p>
<p><strong>G0</strong></p>
<p>每次启动一个M，都会第一个创建的goroutine，就是G0. <code>G0</code>是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G（保存一个调度，栈的信息，它来提供环境，来去调度其他的G），G0不指向任何可执行的函数,（当一个M从G1切换到G2，首先要先切换到G0，然后通过G0把G1干掉，然后把G2再加过来。G0是中间的桥梁） 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p>
<p>（G0根M绑定，每个M都会有第一个G）</p>
<p>我们来跟踪一段代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p>
<p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是<code>main.main</code>，<code>runtime</code>中也有1个main函数——<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p>
<h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5)可视化GMP编程"></a>(5)可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据。</p>
<p><strong>方式1：go tool trace</strong></p>
<p>trace记录了运行时的信息，能提供可视化的Web页面。</p>
<p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p>
<blockquote>
<p>trace.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run trace.go </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>会得到一个<code>trace.out</code>文件，然后我们可以用一个工具打开，来分析这个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go tool trace trace.out </span><br><span class="line">2020&#x2F;02&#x2F;23 10:44:11 Parsing trace...</span><br><span class="line">2020&#x2F;02&#x2F;23 10:44:11 Splitting trace...</span><br><span class="line">2020&#x2F;02&#x2F;23 10:44:11 Opening browser. Trace viewer is listening on http:&#x2F;&#x2F;127.0.0.1:33479</span><br></pre></td></tr></table></figure>

<p>我们可以通过浏览器打开<code>http://127.0.0.1:33479</code>网址，点击<code>view trace</code> 能够看见可视化的调度流程。</p>
<p><img src="https://img.kancloud.cn/ee/e8/eee828bc698d074e439f3e6929be74ef_2724x546.png" alt="img"></p>
<p><img src="https://img.kancloud.cn/25/ed/25ede16ec870076f211f8924c2c2bf6f_492x556.png" alt="img"></p>
<p><strong>G信息</strong></p>
<p>点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img src="https://img.kancloud.cn/87/e3/87e3994fbda4e883a8c51bea20dba91a_1168x372.png" alt="img"></p>
<p> 一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p>
<p>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p><strong>M信息</strong></p>
<p>点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img src="https://img.kancloud.cn/88/4f/884f6aa775a4596d3c8d4f9451d55e9b_1146x248.png" alt="img"></p>
<p> 一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</p>
<p><strong>P信息</strong></p>
<p><img src="https://img.kancloud.cn/5e/07/5e07a8515a023fcd10fbd8cf328b5d64_2736x224.png" alt="img"></p>
<p>G1中调用了<code>main.main</code>，创建了<code>trace goroutine g18</code>。G1运行在P1上，G18运行在P0上。</p>
<p>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</p>
<p>我们在来看看上面的M信息。</p>
<p><img src="https://img.kancloud.cn/6e/14/6e145c4c49656b77f9f2006733b88859_2142x466.png" alt="img"></p>
<p>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：<br><img src="https://img.kancloud.cn/19/60/19602c163ecfe63706e10cdc90e43794_1086x298.png" alt="img"></p>
<p>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p>
<p><strong>方式2：Debug trace</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build trace2.go</span><br></pre></td></tr></table></figure>

<p>通过Debug方式运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG&#x3D;schedtrace&#x3D;1000 .&#x2F;trace2 </span><br><span class="line">SCHED 0ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;1 idlethreads&#x3D;1 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</li>
<li><code>0ms</code>：即从程序启动到输出这行日志的时间；</li>
<li><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</li>
<li><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</li>
<li>t<code>hreads: os threads/M</code>的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</li>
<li><code>spinningthreads</code>: 处于自旋状态的os thread数量；</li>
<li><code>idlethread</code>: 处于idle状态的os thread的数量；</li>
<li><code>runqueue=0</code>： Scheduler全局队列中G的数量；</li>
<li><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</li>
</ul>
<p>下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</p>
<h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><h3 id="1-场景1"><a href="#1-场景1" class="headerlink" title="(1)场景1"></a>(1)场景1</h3><p>P拥有G1，M1获取P后开始运行G1，G1使用<code>go func()</code>创建了G2，为了局部性G2优先加入到P1的本地队列。<br><img src="https://img.kancloud.cn/2d/eb/2debce43683adca1acb5ca5210057232_1074x900.png" alt="img"></p>
<hr>
<h3 id="2-场景2"><a href="#2-场景2" class="headerlink" title="(2)场景2"></a>(2)场景2</h3><blockquote>
<p>M1优先从本地队列取G，并且切换G时，通过G0来调度；</p>
</blockquote>
<p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。<br><img src="https://img.kancloud.cn/93/65/93658da22081d52ed1caf32f42145e5a_1624x984.png" alt="img"></p>
<hr>
<p>场景3，场景4，场景5是相连的；</p>
<h3 id="3-场景3"><a href="#3-场景3" class="headerlink" title="(3)场景3"></a>(3)场景3</h3><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。<br><img src="https://img.kancloud.cn/64/15/6415bfab3595fc22090595acc7c1b4b1_1104x1030.png" alt="img"></p>
<hr>
<h3 id="4-场景4"><a href="#4-场景4" class="headerlink" title="(4)场景4"></a>(4)场景4</h3><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行<strong>负载均衡</strong>(把P1中本地队列中前一半的G，还有新创建G<strong>转移</strong>到全局队列)</p>
<blockquote>
<p>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）<br><img src="https://img.kancloud.cn/d1/27/d12776bfd5cd10f8c1979c61d467499c_1120x1068.png" alt="img"></p>
</blockquote>
<p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p>
<hr>
<h3 id="5-场景5"><a href="#5-场景5" class="headerlink" title="(5)场景5"></a>(5)场景5</h3><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p>
<p><img src="https://img.kancloud.cn/7a/01/7a01ac7a3a4fd14493224827409f77f8_1036x1048.png" alt="img"></p>
<p> G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
<hr>
<h3 id="6-场景6"><a href="#6-场景6" class="headerlink" title="(6)场景6"></a>(6)场景6</h3><p>规定：<strong>在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行</strong>。</p>
<p><img src="https://img.kancloud.cn/60/6a/606acb1e4bf6b85c352b213744771601_1976x1098.png" alt="img"></p>
<p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程<strong>（没有G但为运行状态的线程，不断寻找G）</strong>。</p>
<hr>
<h3 id="7-场景7"><a href="#7-场景7" class="headerlink" title="(7)场景7"></a>(7)场景7</h3><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：<code>findrunnable()</code>）。M2从全局队列取的G数量符合下面的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; min(len(GQ)&#x2F;GOMAXPROCS + 1, len(GQ&#x2F;2))</span><br></pre></td></tr></table></figure>

<p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。</p>
<p><img src="https://img.kancloud.cn/d6/46/d646d4d213d7b603f211cd74ba0dd391_1920x1080.jpeg" alt="img"></p>
<p> 假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p>
<hr>
<h3 id="8-场景8"><a href="#8-场景8" class="headerlink" title="(8)场景8"></a>(8)场景8</h3><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p>
<p><img src="https://img.kancloud.cn/8a/bf/8abf6b47b0871011b6f18f55365c1774_1632x1130.png" alt="img"></p>
<p> <strong>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列</strong>。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
<hr>
<h3 id="9-场景9"><a href="#9-场景9" class="headerlink" title="(9)场景9"></a>(9)场景9</h3><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于<strong>自旋状态</strong>，它们不断寻找goroutine。</p>
<p><img src="https://img.kancloud.cn/10/b4/10b49d04c42c3d688986ff41005ee63b_1682x1084.png" alt="img"></p>
<p> 为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU. 为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们<strong>希望当有新goroutine创建时，立刻能有M运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>GOMAXPROCS</code>个自旋的线程(当前例子中的<code>GOMAXPROCS</code>=4，所以一共4个P)，多余的没事做线程会让他们休眠。</p>
<hr>
<h3 id="10-场景10"><a href="#10-场景10" class="headerlink" title="(10)场景10"></a>(10)场景10</h3><p> 假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了<strong>阻塞的系统调用</strong>，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。<br><img src="https://img.kancloud.cn/54/9a/549aa458fab4c3e7cac5086d9326c1d2_2642x1494.png" alt="img"></p>
<hr>
<h3 id="11-场景11"><a href="#11-场景11" class="headerlink" title="(11)场景11"></a>(11)场景11</h3><p>G8创建了G9，假如G8进行了<strong>非阻塞系统调用</strong>。</p>
<p><img src="https://img.kancloud.cn/24/6c/246c03cdf1eb8307b70865d0debaa1f0_2678x1466.png" alt="img"></p>
<p> M2和P2会解绑，但M2会记住P2，然后G8和M2进入<strong>系统调用</strong>状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
<hr>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2021/05/28/GMP/>http://yoursite.com/2021/05/28/GMP/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-05-31T17:12:22+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：May 31, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/guide/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>guide</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2021/05/28/GMP/&title=GMP - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2021/05/28/GMP/&title=GMP - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2021/05/28/GMP/&title=GMP - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2021/06/01/goparallel/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>goparallel</p>
                <p class='content'>1. 并行与并发1.1 并行（parallel）
并行，同一时刻，有多条指令在多个处理器上同时执行。并行需要借助多核cpu实现。

1.2 并发宏观：在用户体验上，程序在并行执行
微观：多个计划...</p>
              </a>
            
            
              <a class='next' href='/2021/05/15/go-pro/'>
                <p class='title'>go_pro<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>项目架构
协议处理层： 支持各种协议
Controller： 服务入口，负责处理路由，参数校验，请求转发
Logic/Service: 逻辑（服务）层，负责处理业务逻辑
DAO/Reposito...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'GMP',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Golang“调度器”的由来？"><span class="toc-text">一、Golang“调度器”的由来？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-单进程时代不需要调度器"><span class="toc-text">(1) 单进程时代不需要调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-多进程-线程时代有了调度器需求"><span class="toc-text">(2)多进程&#x2F;线程时代有了调度器需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-协程来提高CPU利用率"><span class="toc-text">(3)协程来提高CPU利用率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#N-1关系"><span class="toc-text">N:1关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-关系"><span class="toc-text">1:1 关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#M-N关系"><span class="toc-text">M:N关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Go语言的协程goroutine"><span class="toc-text">(4)Go语言的协程goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-被废弃的goroutine调度器"><span class="toc-text">(5)被废弃的goroutine调度器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Goroutine调度器的GMP模型的设计思想"><span class="toc-text">二、Goroutine调度器的GMP模型的设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GMP模型"><span class="toc-text">(1)GMP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#有关P和M的个数问题"><span class="toc-text">有关P和M的个数问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P和M何时会被创建"><span class="toc-text">P和M何时会被创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-调度器的设计策略"><span class="toc-text">(2)调度器的设计策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-go-func-调度流程"><span class="toc-text">(3) go func() 调度流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-调度器的生命周期"><span class="toc-text">(4)调度器的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-可视化GMP编程"><span class="toc-text">(5)可视化GMP编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Go调度器调度场景过程全解析"><span class="toc-text">三、Go调度器调度场景过程全解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-场景1"><span class="toc-text">(1)场景1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-场景2"><span class="toc-text">(2)场景2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-场景3"><span class="toc-text">(3)场景3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-场景4"><span class="toc-text">(4)场景4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-场景5"><span class="toc-text">(5)场景5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-场景6"><span class="toc-text">(6)场景6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-场景7"><span class="toc-text">(7)场景7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-场景8"><span class="toc-text">(8)场景8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-场景9"><span class="toc-text">(9)场景9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-场景10"><span class="toc-text">(10)场景10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-场景11"><span class="toc-text">(11)场景11</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、小结"><span class="toc-text">四、小结</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
