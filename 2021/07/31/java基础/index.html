<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>java基础 - Hexo</title>
  
    <meta name="keywords" content="guide">
  
  
    <meta name="description" content="java入门">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2021/07/31/java%E5%9F%BA%E7%A1%80/">
      java基础
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Jul 31, 2021</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1. 快速开始"></a>1. 快速开始</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># HelloWorld.java </span><br><span class="line"># 类名要与文件名一致</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hi java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; javac Hello.java</span><br><span class="line">$&gt; java Hello.class</span><br><span class="line"><span class="comment"># hi java</span></span><br></pre></td></tr></table></figure>



<h3 id="idea安装"><a href="#idea安装" class="headerlink" title="idea安装"></a>idea安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create new project</span><br><span class="line">java</span><br><span class="line">jdk11 Groovy</span><br><span class="line">next</span><br><span class="line">next</span><br></pre></td></tr></table></figure>



<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bigRandom = (<span class="keyword">int</span>)(Math.random() * (rangeEnd * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (int)(...)</span></span><br><span class="line"><span class="comment">// 将。。。 转为int类型</span></span><br></pre></td></tr></table></figure>



<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scaner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> guess = in.nextInt(); <span class="comment">// 获取</span></span><br></pre></td></tr></table></figure>



<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>相同类型的变量的集合，指定数组包含元素个数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组元素类型[] 变量名 = <span class="keyword">new</span> 数组元素类型[数组长度]</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">double</span>[] doubleArray = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 对于没有初始化的数组类型，初始值都是其类型的初始值，比如int类型就是0</span></span><br></pre></td></tr></table></figure>

<p> 通过 变量名[索引] , 可读写</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MerchandiseV2[] all; </span><br><span class="line"><span class="keyword">for</span>(MerchandiseV2 m:all) &#123;</span><br><span class="line">  <span class="comment">// 将all里面的值，遍历赋给m</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="文件与IO"><a href="#文件与IO" class="headerlink" title="文件与IO"></a>文件与IO</h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><blockquote>
<p>文件是操作系统对磁盘上数据的组织形式，文件包括文件路径和文件名。文件后缀其实是文件名的一部分。文件不一定要有后缀，但是一定要有文件路径和文件名，后缀是为了让操作系统更好的分辨文件的类型，以便对文件进行正确的操作</p>
<p>所有的文件，不管是什么后缀名，都是一堆在磁盘上的二进制数据，这些二进制数据需要被正确的解析，文件才能被正确的使用。比如pptx文件，我们也可以用文本编辑器打开它，但是文本编辑器并不能正确的解析它；</p>
<p>即使是压缩文件，其实也只是一个文件，它通过内部的组织，将很多文件的数据以及目录结构信息，压缩到一个文件的内容中</p>
</blockquote>
<ul>
<li>使用File类操作文件和文件夹</li>
</ul>
<p>使用File可以判断一个路径是不是文件，文件夹，是不是存在。也可以创建/重命名/删除文件夹，文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDirAndFileApp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不同操作系统的同学可以更改这个值，比如mac或者linux可以写为 ~ 代表home目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"."</span>+ File.separator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Scanner  scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File类，依次创建多层文件夹，修改文件夹名字，在指定文件夹创建文件，删除文件，删除文件夹</span></span><br><span class="line">        File dir = createDirs();</span><br><span class="line">        File newDir = renameDir(dir);</span><br><span class="line">        <span class="keyword">if</span> (newDir == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        String fileName = createFiles(newDir);</span><br><span class="line">        String fileNameNew = renameFiles(newDir, fileName);</span><br><span class="line">        deleteFiles(newDir,fileNameNew);</span><br><span class="line">        deleteDir(newDir);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDir</span><span class="params">(File newDir)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除文件夹？"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> deleteDir = scanner.nextBoolean();</span><br><span class="line">        <span class="comment">// 删除文件夹的前提是文件夹是空的，否则将删除失败</span></span><br><span class="line">        <span class="keyword">if</span>(deleteDir) &#123;</span><br><span class="line">            System.out.println(<span class="string">"删除文件夹："</span>+newDir.delete());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFiles</span><span class="params">(File newDir, String fileNameNew)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除文件？"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> deleteFiles = scanner.nextBoolean();</span><br><span class="line">        <span class="keyword">if</span> (deleteFiles) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">                File fn = <span class="keyword">new</span> File(newDir, fileNameNew + i + <span class="string">".txt"</span>);</span><br><span class="line">                System.out.println(<span class="string">"删除文件"</span>+fn.delete());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">renameFiles</span><span class="params">(File newDir, String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"清输入新的文件名的前缀："</span>);</span><br><span class="line">        String fileNameNew = scanner.next().trim();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(newDir, fileName+i+<span class="string">".txt"</span>);</span><br><span class="line">            File fn = <span class="keyword">new</span> File(newDir, fileNameNew+ i+<span class="string">".txt"</span>);</span><br><span class="line">            System.out.println(<span class="string">"重命名文件"</span>+ f.getName()+<span class="string">": "</span>+f.renameTo(fn));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileNameNew;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">createFiles</span><span class="params">(File newDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入文件名的前缀"</span>);</span><br><span class="line">        String fileName = scanner.next().trim();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++) &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(newDir, fileName + i+<span class="string">".txt"</span>);</span><br><span class="line">            System.out.println(<span class="string">"创建文件"</span>+f.getName()+<span class="string">":"</span>+f.createNewFile());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileName;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">renameDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入新的文件夹的名字:"</span>);</span><br><span class="line">        String newDirName = scanner.nextLine().trim();</span><br><span class="line">        File newDir = <span class="keyword">new</span> File(dir.getParentFile(), newDirName);</span><br><span class="line">        <span class="keyword">boolean</span> renameSuccess = dir.renameTo(newDir);</span><br><span class="line">        <span class="keyword">if</span> (renameSuccess) &#123;</span><br><span class="line">            System.out.println(<span class="string">"改名为"</span>+ newDirName +<span class="string">"成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"改名为"</span>+ newDirName + <span class="string">"失败"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newDir;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">createDirs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; pathList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入文件路径，如果为空则结束"</span>);</span><br><span class="line">            String path = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(path.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pathList.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createDir(pathList.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">createDir</span><span class="params">(String... restPaths)</span> </span>&#123;</span><br><span class="line">        String rest = joinRestDir(restPaths);</span><br><span class="line">        System.out.println(<span class="string">"将在"</span>+ROOT+<span class="string">"下创建"</span>+rest);</span><br><span class="line">        File dir = <span class="keyword">new</span> File(ROOT,rest);</span><br><span class="line">        <span class="keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件夹已经存在"</span>+dir.toString());</span><br><span class="line">            <span class="keyword">return</span> dir;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> createSuccess = dir.mkdirs();</span><br><span class="line">            <span class="keyword">if</span>(createSuccess) &#123;</span><br><span class="line">                <span class="keyword">return</span> dir;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"无法在"</span>+ROOT+<span class="string">"下创建"</span>+rest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinRestDir</span><span class="params">(String... restPaths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(restPaths).map(String::trim).collect(Collectors.joining(File.separator));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java中支持的三种IO"><a href="#Java中支持的三种IO" class="headerlink" title="Java中支持的三种IO"></a>Java中支持的三种IO</h4><ul>
<li>IO也可以写作I/O，是Input/Output的缩写，也就是输入输出。这里的输入输出是指不同系统之间的数据输入输出，比如读写文件数据，读写网络数据等；</li>
<li>Java中有三代IO框架，分别是第一代的流失阻塞IO（Blocking IO），第二代的NIO（New IO）是非阻塞的，第三代NIO2（也叫AIO，async IO）又进一步支持了异步IO</li>
<li>在这里，学习的是流式阻塞IO，学习已经足够，也是最简单和易于理解的一种。如果是高吞吐量的生产环境下，建议使用更加优秀的netty。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream  -&gt; FilterInputStream  -&gt; InputStream</span><br><span class="line">											  FileInputStream    -&gt; InputStream</span><br><span class="line">											ByteArrayInputStream -&gt; InputStream</span><br></pre></td></tr></table></figure>



<h4 id="写文件内容小程序"><a href="#写文件内容小程序" class="headerlink" title="写文件内容小程序"></a>写文件内容小程序</h4><ol>
<li>用Scanner读取输入，并把输入的内容写入我们指定的文件 （装饰模式，创建出来的对象，把输入的文字写入到文件）</li>
<li>字符集和编码</li>
<li>try-with-resource</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteToFileAppMain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File targetFile = createFile();</span><br><span class="line">    writeFile(targetFile);</span><br><span class="line">    System.out.println(<span class="string">"程序执行结束"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(File targetFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// todo try with resource， 帮我们搞定close</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">    <span class="comment">// 创建一个inputStream，建立一起从文件到程序的byte数据传输流</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(targetFile);</span><br><span class="line">        <span class="comment">// 建立一个可以消费inputStream的writer， 并指定字符集，这样就可以一个个的写入字符了</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// 使用PrintWriter，可以方便的写入一行字符</span></span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(osw); ) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 猜猜System.out 是什么</span></span><br><span class="line">      System.out.println(<span class="string">"输入的内容会实时写入文件，如果输入空行则结束"</span>);</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String lineToWrite = in.next().trim();</span><br><span class="line">        System.out.println(<span class="string">"输入内容为："</span> + lineToWrite);</span><br><span class="line">        <span class="keyword">if</span> (lineToWrite.trim().isEmpty()) &#123;</span><br><span class="line">          System.out.println(<span class="string">"输入结束"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pw.println(lineToWrite);</span><br><span class="line">          pw.flush(); <span class="comment">// 将缓存内容写入文件</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="comment">// io操作过程中有极端情况存在，磁盘拔掉了，文件被删除等等；所以需要io exception</span></span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请输入文件名："</span>);</span><br><span class="line">    String fileName = in.nextLine().trim();</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">"."</span> + File.separator + fileName + <span class="string">".txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"目标文件存在，删除："</span> + f.delete());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(f.createNewFile());</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadStringFromFileApp</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SOURCE_FILE_NAME = <span class="string">"测试文件.txt"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    File sourceFile = <span class="keyword">new</span> File(<span class="string">"."</span> + File.separator + SOURCE_FILE_NAME);</span><br><span class="line">    <span class="comment">// 猜猜System.in是个啥，其实和output那边的套路是一样的，System.in只能读取标准的输入里的byte</span></span><br><span class="line">    <span class="comment">// 而Scanner可以将这个byte读取出来，转换成String，进而转换成不同的数据类型，比如int，boolean</span></span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    classicWay(sourceFile); <span class="comment">// 经典方式</span></span><br><span class="line">    coolerWay(sourceFile); <span class="comment">// lambda方式</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">classicWay</span><span class="params">(File sourceFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"--------经典的处理方式-------------"</span>);</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">    <span class="comment">// 建立从文件到程序的数据输入流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">        <span class="comment">// 用InputStreamReader 将这个byte 流套一下，装饰一下，并指定字符编码，让它能够读出的byte</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// 增加缓存功能，输入输出效率更高，并且可以一次读取一行</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(isr); ) &#123;</span><br><span class="line">      String line = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否读完的标识</span></span><br><span class="line">        System.out.println(line.trim().toUpperCase());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coolerWay</span><span class="params">(File sourceFile)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"---------------lambda处理方法-------------"</span>);</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, StandardCharsets.UTF_8);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(isr); ) &#123;</span><br><span class="line">      reader.lines().map(String::trim).map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><p>使用ServerSocket 和Socket让本季的两个进程可以通过网络建立连接；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.denon.SimpleServer.SERVER_PORT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        commWithServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commWithServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, SERVER_PORT);</span><br><span class="line">                ) &#123;</span><br><span class="line">            Chat chat = <span class="keyword">new</span> Chat(<span class="string">"服务器端"</span>,<span class="keyword">null</span>, socket);</span><br><span class="line">            chat.chatting();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">45632</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset SERVER_CHARSET = StandardCharsets.UTF_8;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BYE = <span class="string">"bye"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        commWithClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commWithClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server 端启动，在端口"</span>+ SERVER_PORT + <span class="string">"监听..."</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ServerSocket ss = <span class="keyword">new</span> ServerSocket(SERVER_PORT);</span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                )&#123;</span><br><span class="line">            Chat chat = <span class="keyword">new</span> Chat(<span class="string">"客户端"</span>,<span class="string">"你已经成功连接到我，我们可以开始对话了"</span>,s);</span><br><span class="line">            chat.chatting();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">static</span> com.denon.SimpleServer.BYE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.denon.SimpleServer.SERVER_CHARSET;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String greetings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chat</span><span class="params">(String from, String greetings, Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.greetings = greetings;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chatting</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream(),SERVER_CHARSET));</span><br><span class="line">                PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream(), SERVER_CHARSET))</span><br><span class="line">                )&#123;</span><br><span class="line">            System.out.println(<span class="string">"socket 连接成功！建立输入输出"</span>);</span><br><span class="line">            <span class="keyword">if</span>(greetings != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pw.println(<span class="string">"你好,"</span>+from+<span class="string">"."</span>+greetings);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                String line = br.readLine();</span><br><span class="line">                <span class="keyword">if</span>(line.trim().equalsIgnoreCase(BYE))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"对方要求断开连接"</span>);</span><br><span class="line">                    pw.println(BYE);</span><br><span class="line">                    pw.flush();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"来自"</span>+from+<span class="string">"的消息"</span>+line);</span><br><span class="line">                &#125;</span><br><span class="line">                line = in.nextLine();</span><br><span class="line">                pw.println(line);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"聊天结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">cd</span> /target/classes</span><br><span class="line">$&gt; java com.denon.SimpleServer</span><br><span class="line">$&gt; java com.denon.SimpleClient</span><br></pre></td></tr></table></figure>

<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><blockquote>
<p>使用IP/域名和端口连接到服务器，发送请求，接受服务器端的返回内容，并把内容输出到控制台</p>
</blockquote>
<h2 id="2-OO"><a href="#2-OO" class="headerlink" title="2. OO"></a>2. OO</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 public class 开头，类名和文件名一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merchandise</span></span>&#123;</span><br><span class="line">  <span class="comment">// 类中可以定义描述这个类的属性的变量，称为成员变量；</span></span><br><span class="line">  String name;</span><br><span class="line">  String id;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Merchandise 类，其实就是创建了一个模版，描述了一种我们需要的数据类型</span></span><br></pre></td></tr></table></figure>

<h4 id="类的实例-对象"><a href="#类的实例-对象" class="headerlink" title="类的实例/对象"></a>类的实例/对象</h4><blockquote>
<p>从数据类型的角度来看，类就是自己创建了一种新的数据类型，类也叫“自定义类型”。一个java程序中不允许类同名；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merchandise m1 = <span class="keyword">new</span> Merchandise();</span><br></pre></td></tr></table></figure>

<ol>
<li>使用new操作符，创建类的实例</li>
<li>使用new创建一个类实例之后，类中定义的每种变量会被赋以其类型的初始值；</li>
<li>使用一个同类型的对象变量（m1），可以指向并操作这个实例。</li>
</ol>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><blockquote>
<p>引用类型包含两个部分信息：类型和实例，每个引用（引用数据类型的变量，m1）都是指向某个类的一个实例/对象（instance/object），不同类型的引用在java世界里面都是引用的类型信息在创建时就已经确定，可以通过引用赋值，让其指向不同的实例。比如m1 = m5;</p>
<p>引用数据类型的值还是一个地址，需要通过“二级跳”找到实例；</p>
<p>所有new出来的实例，都会放在heap上。引用里面存放的就是指向实例的地址；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMaret</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new People() 创建一个地址，把地址赋值给people；</span></span><br><span class="line">    People people = <span class="keyword">new</span> People();</span><br><span class="line">    System.out.println(people);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// People@5e025e70</span></span><br></pre></td></tr></table></figure>



<h4 id="引用和类以及对象的关系"><a href="#引用和类以及对象的关系" class="headerlink" title="引用和类以及对象的关系"></a>引用和类以及对象的关系</h4><ol>
<li>引用必须是、只能是一个类的引用</li>
<li>引用只能指向其所属的类型的类的对象</li>
<li>相同类型的引用之间可以赋值</li>
<li>只能通过指向一个对象的引用，来操作一个对象，比如访问某个成员变量；</li>
</ol>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><blockquote>
<p>null是引用类型的缺省值，null代表空，不存在，可以读作空。引用类型的数组创建出来，初始值都是空</p>
</blockquote>
<ul>
<li>null带来的问题</li>
</ul>
<p>大名鼎鼎的NullPointerException</p>
<p>如果不确定，使用前要先判断引用是不是空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMaret</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    People[] people = <span class="keyword">new</span> People[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        people[i] = <span class="keyword">new</span> People();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">      System.out.println(people[i].age);<span class="comment">//NullPointerException </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="像自定义类型一样使用类"><a href="#像自定义类型一样使用类" class="headerlink" title="像自定义类型一样使用类"></a>像自定义类型一样使用类</h3><blockquote>
<p>类就是一种自定义类型</p>
</blockquote>
<ol>
<li>在类定义中可以使用类，创建类的引用</li>
<li>在类定义中，甚至可以使用类自己的类创建引用</li>
<li>引用类型的缺省值是null，一个类定义中如果有引用，创建出来的实例，其缺省值是null</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  Screen screen;</span><br><span class="line">  Mainboard mainboard;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">boolean</span> lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态变量-类变量"><a href="#静态变量-类变量" class="headerlink" title="静态变量/类变量"></a>静态变量/类变量</h3><blockquote>
<p>VIP的折扣作为一个成员变量，hin浪费</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseV2WithStaticVariable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> DISCOUNT_FOR_VIP = <span class="number">0.95</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>静态变量使用static修饰符</li>
<li>静态变量如果不赋值，Java也会给它赋以其类型的初始值</li>
<li>静态变量一般使用全大写字母加下划线分割，这是一个习惯用法；</li>
<li>所有的代码都可以使用静态变量，只要根据防范控制符的规范，这个静态变量对其可见即可；静态变量不会随着对象创建而创建，它是一个类变量。一经改动，影响全局。</li>
<li>比如public的静态变量，所有的代码都可以使用它；</li>
<li>如果没有public修饰符，只能当前包的代码能使用它；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.MerchandiseV2WithStaticVariable <span class="comment">// 引入类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引入类之后，直接用 DISCOUNT_FOR_VIP</span></span><br><span class="line">    System.out.println(DISCOUNT_FOR_VIP)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h3 id="包与类访问符"><a href="#包与类访问符" class="headerlink" title="包与类访问符"></a>包与类访问符</h3><blockquote>
<p>为了避免类在一起混乱，可以把类放在文件夹里。这时就需要用package语句告诉java这个类在哪个package中，class名与文件名一致，文件所在的路径就是package名；package语句要和源文件的目录完全对应，大小写要一致。</p>
</blockquote>
<p>package读作包，一般来说，类都会在包里，而不会直接放在跟目录；</p>
<p>不同的包可以有相同名字的类</p>
<p>一个类只能有一个package语句，如果有package语句，则必须是类的第一行有效代码（也就是说要放在顶部）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a</span><br><span class="line"> -b</span><br><span class="line">  -c</span><br><span class="line">    MyClass.java</span><br><span class="line">   </span><br><span class="line"><span class="comment"># MyClass的package就是 a.b.c</span></span><br></pre></td></tr></table></figure>



<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><blockquote>
<p>当使用另一个包里类的时候，需要带上包名</p>
<p>每次使用都带包名很繁琐，可以在使用类的上面使用import语句，</p>
<p>import语句可以有多个</p>
<p>如果需要import一个包中的很多类，可以使用*通配符</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.phone.parts.*</span><br></pre></td></tr></table></figure>



<h4 id="属性访问修饰符"><a href="#属性访问修饰符" class="headerlink" title="属性访问修饰符"></a>属性访问修饰符</h4><blockquote>
<p>可见性修饰符用在类，成员方法，构造方法，静态方法和属性上，其可见性的范围是一样的；</p>
</blockquote>
<p>看代码，学习可见性修饰符：</p>
<h5 id="public"><a href="#public" class="headerlink" title="public"></a>public</h5><ul>
<li>public：全局可见</li>
<li>缺省： 当前包可以见</li>
<li>private： 当前类可以见</li>
</ul>
<h5 id="private"><a href="#private" class="headerlink" title="private"></a>private</h5><p>理解访问修饰符：不只是为了限制不让人用，更为了有规矩才成方圆。成员变量应该是private的，不需要让外部使用的方法应该都是private的；</p>
<ol>
<li>类，静态方法，静态变量，成员变量，构造方法，成员方法都可以使用访问修饰符</li>
<li>成员变量应该都声明为private</li>
<li>如果要读写这些成员变量，最好使用get set方法，这些方法应该是public的，这样做的好处是，如果有需要，可以通过代码，检查每个属性值是否合法；</li>
<li>构造方法如果是private，那么就只有当前的类可以调用这个构造方法；</li>
<li>有些时候，会把所有的构造方法都定义成private的，然后使用静态方法调用构造方法</li>
<li>同样的，这样的好处是可以通过代码，检查每个属性值是否合法；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Demo</span> <span class="params">(String name, String id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用静态方法调用构造方法，检查每个属性值是否合法；</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo <span class="title">createMerchandise</span><span class="params">(String name, String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">""</span> || id == <span class="string">""</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Demo(name, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>public方法类似一种约定，既然外部的代码可以使用，就意味着不能乱改，比如签名不能改之类的；</li>
<li>对于private的方法，因为类外面调不到，所以无论怎么改，也不会影响（直接影响）类外面的代码</li>
</ol>
<h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><blockquote>
<p>protected = default + 继承者们可见</p>
<p>覆盖可以，但是不能让可见性更低</p>
</blockquote>
<p>构造方法可以是protected，但是如果是private，子类就不可以覆盖了；</p>
<p>如果父类只有一个private的构造方法，相当于这个类不能有子类；</p>
<p>子类覆盖父类的方法，不可以用可见性更低的修饰符，但是可以用更高的修饰符，</p>
<p>原因是？</p>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><blockquote>
<p>final修饰符最见不得变化</p>
</blockquote>
<p>final修饰类：不可被继承</p>
<p>final修饰方法： 不可被子类覆盖</p>
<p>final修饰变量：不可被修改，只能在构造函数里面或者声明变量时赋值。必须赋值一次且只能赋值一次；（这个最难理解）</p>
<p>构造方法不能用final修饰，（没有意义）</p>
<p>final修饰引用, 锁定了引用，而不锁定引用指向的对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MerchandiseV2 gift;</span><br></pre></td></tr></table></figure>



<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>设置断点，debug调试模式运行程序</p>
<p>断点（breakpoint）：可以让程序在调试模式停在某一行</p>
<p>程序调试标准动作</p>
<ol>
<li>查看变量的值，展开实例看哪部成员变量的值</li>
<li>程序继续执行之step Over：执行一行</li>
<li>程序继续执行之step Out：继续执行直到遇到下一个断点或程序结束</li>
<li>执行任意代码之Evaluate Expression：在对话框输入代码，直接执行看结果值</li>
<li>条件断点：给断点设置条件，只有满足条件时，程序才会在该断点停住；</li>
</ol>
<h4 id="Evaluate"><a href="#Evaluate" class="headerlink" title="Evaluate"></a>Evaluate</h4><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/java%E5%9F%BA%E7%A1%80/01.png" alt="image-20210801153627892"></p>
<p>在断点所在行处右键选择 Evaluate Expression，弹出Evaluate对话框；输入目标值点evaluate按钮直接计算出结果；</p>
<h4 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h4><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/java%E5%9F%BA%E7%A1%80/02.png" alt="image-20210801153909022"></p>
<p>在断点右击弹出对话框，在Condition输入框输入表达式；</p>
<p><code>m.soldPrice&gt;200</code>; 那么当程序满足这一条件时，程序会停止住；</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><blockquote>
<p>java中一个方法只能有一种返回值，如果不需要返回值则用void表示，用return 返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值如果是基本类型，则要类型完全相同，或者符合类型自动转换规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getxxx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果不符合规则，可以使用强制类型转换</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get1xxx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(xxx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>类型 标识符(参数名)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="参数与返回值是怎么传递的"><a href="#参数与返回值是怎么传递的" class="headerlink" title="参数与返回值是怎么传递的"></a>参数与返回值是怎么传递的</h4><ol>
<li>参数与方法里面的局部变量可以认为是一样的东西，只是在方法调用之前，会用实参给参数的行参赋值；</li>
<li>发生在代码块里的，就让它留在代码块里。方法执行完毕，参数和方法的局部变量的数据就会被删除回收；</li>
<li>调用一个有返回值的方法时，就好像访问了一个成员变量；</li>
<li>方法里的代码并不能改变实参的值，方法里使用的参数相当于一个局部变量。使用方法前，会用实参给局部变量赋值；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">willOutsideValueChangePrime</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">  p = <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">willOutsideValueChangeRef</span><span class="params">(type r)</span></span>&#123;</span><br><span class="line">  r = r1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> pramPrime = <span class="number">7</span>;</span><br><span class="line">type r = <span class="keyword">new</span> type();</span><br><span class="line">m.willOutsideValueChangePrime(pramPrime);</span><br><span class="line"><span class="comment">// 内部实现相当于</span></span><br><span class="line"><span class="comment">// int p = pramPrime;</span></span><br><span class="line"><span class="comment">// int p = 10000;</span></span><br><span class="line">m.willOutsideValueChangeRef(paramRef);</span><br><span class="line"><span class="comment">// 内部实现相当于</span></span><br><span class="line"><span class="comment">// type r = paramRef; </span></span><br><span class="line"><span class="comment">// r = r1;</span></span><br></pre></td></tr></table></figure>

<p>这一点跟JavaScript类似，传参都是拷贝操作。要么值拷贝，要么拷贝地址；</p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><blockquote>
<p>方法中参数与局部变量同名会怎么样, IDE会报错，参数和局部变量不能重名；javascript也是如此；</p>
<p>方法中隐藏着一个this自引用，指向调用这个方法的对象；</p>
<p>访问一个成员变量的完整形态，是”this.成员变量的名字”</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p> 方法不是对象的一部分，它是类的一部分，每个对象可以给成员变量赋不同的值，但是无法让方法有不同的行为。同理，无论在一个类中定义多少方法，都不会让影响创建一个对象所占用的内存；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeEnoughForOneByOne</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> hasEnough = <span class="keyword">this</span>.hasEnoughCountFor(count);</span><br><span class="line">  <span class="keyword">if</span>(!hasEnough) &#123;</span><br><span class="line">    <span class="comment">//递归调用自己，不用加this</span></span><br><span class="line">    makeEnoughForOneByOne(count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法签名与重载"><a href="#方法签名与重载" class="headerlink" title="方法签名与重载"></a>方法签名与重载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseV2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buyOne</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buyCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buyAsVIP</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">boolean</span> isVIP)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法功能很类似，大部分同质化的代码</p>
<h5 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h5><blockquote>
<p>方法签名： 方法名 + 依次参数类型，注意，返回值不属于方法签名。方法签名是一个方法在一个类中的唯一标识；</p>
<p>同一个类中方法可以重名，但是签名不可以重复，一个类中如果定义了名字相同，签名不同的方法，就叫做方法的重载</p>
</blockquote>
<ul>
<li>方法签名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseV2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buyOne</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buyCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buyAsVIP</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">boolean</span> isVIP)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比如上面这个类，方法的签名依次是</span></span><br><span class="line"><span class="comment">// buyOne()</span></span><br><span class="line"><span class="comment">// buyCount(int)</span></span><br><span class="line"><span class="comment">// buyAsVIP(int, boolean)</span></span><br><span class="line"><span class="comment">// 方法签名不包括返回值，因为如果带返回值的话，编译器就很难决定要去调哪个方法啦；</span></span><br><span class="line"><span class="comment">// 方法参数只看类型，不看参数名，参数类型相同也不行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法重载</li>
</ul>
<blockquote>
<p>类中方法签名不能重复，但是方法名可以重复</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改写MerchandiseV2 使用方法重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseV2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buy(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> buy(count, <span class="keyword">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">boolean</span> isVIP)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; count) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">   	  <span class="keyword">this</span>.count -= count;</span><br><span class="line">     <span class="keyword">double</span> totalCost = count * soldPrice;</span><br><span class="line">     <span class="keyword">if</span>(isVIP) &#123;</span><br><span class="line">       <span class="keyword">return</span> totalCost * <span class="number">0.95</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> totalCost;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重载的参数匹配规则"><a href="#重载的参数匹配规则" class="headerlink" title="重载的参数匹配规则"></a>重载的参数匹配规则</h5><blockquote>
<p>有了论斤卖的商品，数据编程double类型，有论整个卖，有散装称重卖的，事情开始复杂起来；</p>
</blockquote>
<blockquote>
<p> 方法调用时，参数就不必完全类型一样，对于数字类型的参数，实参数可以自动类型转换成行参类型即可</p>
</blockquote>
<blockquote>
<p>重载时如果参数类型不完全匹配怎么样</p>
</blockquote>
<p>如果重载的函数签名分别是 byte，short，int，long，float，doule类型的参数调用buy方法，哪个方法会被调用呢？</p>
<p>无论是否重载参数类型可以不完全匹配的规则是“实参数可以自动类型转换成行参类型”</p>
<p>重载的特殊之处是，参数满足自动类型转换的方法有好几个，重载的规则是选择最“近”的去调用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> count = <span class="number">11</span>;</span><br><span class="line">v2.buy(count); <span class="comment">// int</span></span><br><span class="line"><span class="comment">// byte 往后找 ，顺序分别为 byte short int long float double</span></span><br><span class="line"><span class="keyword">long</span> count1 = <span class="number">11</span>;</span><br><span class="line">v2.buy(count1); <span class="comment">// double</span></span><br><span class="line"><span class="comment">// long不能转化为int，只能往上找，就近转为double</span></span><br></pre></td></tr></table></figure>



<h4 id="构造方法：构造实例的方法"><a href="#构造方法：构造实例的方法" class="headerlink" title="构造方法：构造实例的方法"></a>构造方法：构造实例的方法</h4><blockquote>
<p>如果init方法能在对象创建的时候就自动被调用多方便；</p>
<p>自动调用的唯一的问题：调用哪个方法呢？</p>
</blockquote>
<ul>
<li>构造方法（constructor）的语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseV2WithConstructor</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  String id;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">double</span> soldPrice;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MerchandiseV2WithConstructor</span><span class="params">(String name, String id, <span class="keyword">int</span> count, <span class="keyword">double</span> soldPrice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">    <span class="keyword">this</span>.soldPrice = soldPrice;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>构造方法的方法名与类名一样，而且构造方法没有返回值，</li>
<li>构造方法可以有参数，规则和语法于普通方法一样，参数传递给new语句后类名的括号方法；</li>
<li>如果没有显示的添加一个构造方法，java会给每个类都默认自带一个无参数的构造方法；</li>
<li>如果我们自己添加类的构造方法，java就不会给该类添加无参数的构造方法，这时候，就不能直接new一个对象不传递参数了；</li>
<li>所以我们一直都在使用构造方法，这也是为什么创建对象的时候类名后面要有一个括号的原因；</li>
<li>构造方法无法被点操作符调用或者在普通方法里调用，只能通过new语句在创建对象的时候，间接调用；</li>
<li>所以为何构造方法不能有返回值，因为有返回值也没有意义，new语句永远返回的是创建出来的对象的引用；</li>
</ol>
<h5 id="构造方法的重载和互相调用"><a href="#构造方法的重载和互相调用" class="headerlink" title="构造方法的重载和互相调用"></a>构造方法的重载和互相调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseV2WithConstructor</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  String id;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">// 构造方法执行前，会执行给局部变量赋初始值的操作</span></span><br><span class="line">  <span class="comment">// 之前说过，所有的代码都必须在方法里，那么这种给成员变赋初始值的代码在哪个方法里？怎么看不到呢？</span></span><br><span class="line">  <span class="comment">// 原来构造方法在内部变成了&lt;init&gt;方法，</span></span><br><span class="line">  <span class="comment">// 实际上是 public &lt;init&gt; ()&#123;</span></span><br><span class="line">  		<span class="comment">// this.soldPrice = 1.1;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 值得注意的是 构造方法也会 被封装到&lt;init&gt;里面；</span></span><br><span class="line">  <span class="keyword">double</span> soldPrice = <span class="number">1.1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造方法的重载与普通方法一样；</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MerchandiseV2WithConstructor</span><span class="params">(String name, String id, <span class="keyword">int</span> count, <span class="keyword">double</span> soldPrice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">    <span class="keyword">this</span>.soldPrice = soldPrice;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在构造方法里面才能调用重载的构造方法，语法为this(实参列表)</span></span><br><span class="line">  <span class="comment">// 构造方法不能自己调用自己，这会是一个死循环</span></span><br><span class="line">  <span class="comment">// 在调用重载的构造方法时，不可以使用成员变量。因为用语意上讲，这个对象还没有被初始化完成，处于中间状态；</span></span><br><span class="line">  <span class="comment">// 在构造方法里才能调用重载的构造方法时，必须是方法的第一行，后面可以继续有代码；</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MerchandiseV2WithConstructor</span><span class="params">(String name, String id, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this(), this指向的是其中一个构造函数</span></span><br><span class="line">    <span class="keyword">this</span>(name, id, count, count+<span class="number">0.11</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 因为我们添加了构造方法之后，Java就不会再添加无参数的构造方法，如果需要的话，我们可以自己添加这样的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MerchandiseV2WithConstructor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"无名"</span>.<span class="string">"1"</span>,<span class="number">0</span>,<span class="number">1.1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// new 的时候直接传入参数，类的内部会调用构造函数执行初始化；</span></span><br><span class="line">    LitteSuperMarket littleSuperMarket = <span class="keyword">new</span> LitteSuperMarket(<span class="number">100</span>, <span class="number">19.11</span>, <span class="string">"1"</span>, <span class="string">"2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote>
<p>没有this自引用的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getVIPDiscount</span><span class="params">(LittleSuperMarket littleSuperMarket)</span></span>&#123;</span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 静态方法可以访问静态变量，包括自己类的静态变量和在访问控制符允许的别的类的静态变量；</span></span><br><span class="line">    <span class="comment">// 除了没有this，静态方法的定义和成员方法一样，也有方法名，返回值和参数</span></span><br><span class="line">    <span class="comment">// 静态变量没有this自引用，它不属于某个实例，调用的时候也无需引用，直接用类名调用，所以它也不能直接访问成员；</span></span><br><span class="line">    <span class="comment">// 当然在静态方法里面，也可以自己创建对象，或者通过参数，获得对象的引用，进而调用方法和访问成员变量</span></span><br><span class="line">    <span class="comment">// 静态方法只是没有this自引用的方法而已</span></span><br><span class="line">    <span class="keyword">double</span> activeityDiscount = littleSuperMarket.activitDiscount;</span><br><span class="line">    <span class="keyword">return</span> DISCOUNT_FOR_VIP * activeityDiscount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="静态方法的重载"><a href="#静态方法的重载" class="headerlink" title="静态方法的重载"></a>静态方法的重载</h5><blockquote>
<p>静态方法的重载和成员方法（实例方法）一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDiscount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BASE_DISCOUNT;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDiscount</span><span class="params">(<span class="keyword">boolean</span> isVIP)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> svipDiscount = (isVip?VIP_DISCOUNT:<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> getDiscount() * svipDiscount;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDiscount</span><span class="params">(<span class="keyword">int</span> svipLevel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = getDiscount() * VIP_DISCOUNT;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;svipLevel; i++) &#123;</span><br><span class="line">      ret *= SVIP_DISCOUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>静态方法的重载也是一样，方法签名不同即可；同样返回值不算事方法签名</li>
<li>判断调用哪个方法，也是根据调用时参数匹配决定的；</li>
</ol>
<h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> base1;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> base2;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    base1 = <span class="number">1</span>;</span><br><span class="line">    base2 = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用某个静态变量的代码块必须在静态变量后面，类似js预解析机制；</li>
<li></li>
</ol>
<h3 id="类的对象自己做事情"><a href="#类的对象自己做事情" class="headerlink" title="类的对象自己做事情"></a>类的对象自己做事情</h3><blockquote>
<p>之前的代码，赋值的到处都是，</p>
<p>想一下到处复制代码的话，一旦有变化，就得到处改；</p>
<p>解决这个问题的关键是什么？成熟的类会说：成熟的类自己操作自己的成员变量。</p>
</blockquote>
<h4 id="把操作成员变量的代码放在类里"><a href="#把操作成员变量的代码放在类里" class="headerlink" title="把操作成员变量的代码放在类里"></a>把操作成员变量的代码放在类里</h4><ol>
<li>初始化成员变量</li>
<li>简单访问和设置成员变量的值（Java Bean）</li>
<li>专有的一些计算逻辑</li>
<li>用类定义成员变量，并把操作成员变量的代码都放在类里，就是封装；<ol>
<li>可以集中管控，自己的成员变量别人不可以乱来，避免出现非法的状态，比如库存为负数；</li>
<li>代码逻辑可以共用，避免代码重复，修改的时候只需改一处；</li>
<li>封装的好，可以更好的抽象一类事物；</li>
</ol>
</li>
</ol>
<ul>
<li>初始化成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Merchandise v2 = <span class="keyword">new</span> Merchandise();</span><br><span class="line">v2.init(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="number">40</span>,<span class="number">999.9</span>);</span><br></pre></td></tr></table></figure>



<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><blockquote>
<p>String对象最重要的特点：不可变（immutable）不可变不可变，重要的事情说三遍，String用来存储字符的数据是private的，而且不提供任何修改内容的方法，所以String对象一旦生成，其内容就是完全不可能被修改的；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnString</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String string = <span class="string">"0123456789"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(string.length());</span><br><span class="line">    System.out.println(string.toLowerCase());</span><br><span class="line">    System.out.println(string.toUpperCase());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string指向对象的内容并没有变化</span></span><br><span class="line">    System.out.println(string);</span><br><span class="line">    System.out.println(string.charAt(<span class="number">1</span>));</span><br><span class="line">    System.out.println(string.substring(<span class="number">5</span>));</span><br><span class="line">    System.out.println(string.substring(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">0123456789</span></span><br><span class="line"><span class="number">0123456789</span></span><br><span class="line"><span class="number">0123456789</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">56789</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><blockquote>
<p>StringBuilder是一个非常方便的用来拼接和处理字符串的类，和String不同的是，它是可变的；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnStringBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StringBuilder首先是可变的；</span></span><br><span class="line">    <span class="comment">// 而且对它进行操作的方法，都会返回this自引用。这样我们就可以一直点下去，对String进行构造；</span></span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> longVal = <span class="number">123456789</span>;</span><br><span class="line">    <span class="comment">// append函数内部返回this，链式调用；</span></span><br><span class="line">    str.append(<span class="keyword">true</span>).append(<span class="string">"abc"</span>).append(longVal);</span><br><span class="line"></span><br><span class="line">    System.out.println(str.toString());</span><br><span class="line">    System.out.println(str.reverse().toString());</span><br><span class="line">    System.out.println(str.reverse().toString());</span><br><span class="line">    System.out.println(str.toString());</span><br><span class="line">    System.out.println(str.delete(<span class="number">0</span>, <span class="number">4</span>).toString());</span><br><span class="line">    System.out.println(str.insert(<span class="number">3</span>, <span class="string">"LLLLLL"</span>).toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">starttrueabc123456789</span><br><span class="line"><span class="number">987654321</span>cbaeurttrats</span><br><span class="line">starttrueabc123456789</span><br><span class="line">starttrueabc123456789</span><br><span class="line">ttrueabc123456789</span><br><span class="line">ttrLLLLLLueabc123456789</span><br></pre></td></tr></table></figure>



<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>取当前时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillis(); <span class="comment">// hao miao</span></span><br><span class="line">System.nanoTime(); <span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure>



<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>子类继承父类的方法和属性</li>
<li>使用子类的引用可以调用父类的公有方法</li>
<li>使用子类的引用可以访问父类的共有属性</li>
<li>就好像子类的引用可以一物二用，既可以当作父类的引用使用，又可以当作子类的引用使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneExtendsMerchandise</span> <span class="keyword">extends</span> <span class="title">Merchandise</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>继承的语法就是在类名后面使用extends加要继承的类名</li>
<li>被继承的类叫做父类，继承者叫子类</li>
<li>java只允许一个类有一个直接的父类，即所谓的单继承</li>
<li>没错，别的类也可以继承子类</li>
<li>子类继承父类的所有属性和方法</li>
<li>子类不能访问父类的private的成员（包括方法和属性）</li>
</ol>
<h4 id="子类对象藏着一个父类对象"><a href="#子类对象藏着一个父类对象" class="headerlink" title="子类对象藏着一个父类对象"></a>子类对象藏着一个父类对象</h4><blockquote>
<p>另一种解决问题的思路：组合</p>
<p>继承和组合的区别</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneHasAMerchandise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 除了继承，我们也可以在Phone中添加一个商品的引用；</span></span><br><span class="line">  <span class="comment">// 这样，我们也是可以实现类似的功能。</span></span><br><span class="line">  <span class="comment">// 这种在自己的类里，使用别的类的两类之间的关系，我们叫做“has-a”,也称为组合；</span></span><br><span class="line">  <span class="comment">// 具体到我们这个例子，在我们用类构造的世界中，“Phone中有一个商品，但是Phone本身不是商品（划重点！）”</span></span><br><span class="line">  <span class="keyword">private</span> MerchandiseV2 merchandise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">UsePhoneHasAMerchandise</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    merchandise = <span class="keyword">new</span> MerchandiseV2();</span><br><span class="line">    PhoneHasAMerchandise phone = <span class="keyword">new</span> PhoneHasAMerchandise();</span><br><span class="line">    phone.describePhone();</span><br><span class="line">    <span class="comment">// 所有和商品相关的操作，先从Phone里获得商品的引用，然后再通过这个引用操作商品；</span></span><br><span class="line">    phone.getMerchandise().describe();</span><br><span class="line">    <span class="comment">// 如果我们想要让手机返回不一样的商品名字，比如加上手机厂商和型号，但是不容易</span></span><br><span class="line">    <span class="comment">// 我们可以再每次修改手机的厂商和型号的时候，都去set一下商品的名字。繁琐，但是做得到；</span></span><br><span class="line">    phone.getMerchandise().getName();</span><br><span class="line">    <span class="comment">// 如果要限制购买的数量不超过5怎么办？</span></span><br><span class="line">    phone.getMerchandise().buy(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>继承，其实表达的是一种“is-A”的关系，也就是说，在你用类的构造的世界中，“子类”是父类的一种特殊类别；</p>
</li>
<li><p>组合和继承，是拿到一个问题，设计相应的java类的时候，不得不面对的来自灵魂拷问</p>
</li>
<li><p>XX到底是YY的一种，还是只是组合了YY？ 手机到底是手电筒的一种，还是组合了一个可以当手电的闪光灯？</p>
</li>
</ol>
<ul>
<li>如果要限制购买数量不超过5怎么办？</li>
</ul>
<ol>
<li>首先，不能修改MerchandiseV2 这个类，否则你会限制所有商品一次购买的数量</li>
<li>其次，在现实情况下，这个类可能根本不受你控制，你无权修改其代码</li>
<li>在每次调用buy方法的地方做限制，是不行的；<ol>
<li>你无法控制别人怎么用你的类；</li>
<li>而且会面临到处赋值代码的糟糕情况</li>
<li>如果说限制改成10个，所有复制的代码都要改，程序员都应该很懒，这不是一个程序员该做的事情；</li>
</ol>
</li>
<li>在只能修改手机类的情况下，我们可以提供一个buyPhone的方法，实现限制购买数量的逻辑；但是这样并不能阻止别人像下面这样调用merchandise的buy方法，这个方法是会修改库存的，所以还是无法硬性的限制一次性购买；</li>
</ol>
<p>   我们来理清一下自己的核心诉求：针对手机，限制一次性购买的数量，必须限制死，必须不影响别的商品，必须只能改手机类的代码。这时候，组合就无能为力，继承可以发挥其应有的作用；</p>
<p>   继承不是组合，继承也只是为了能简单的拿来父类的属性和方法，如果仅仅如此，原封不动拿来主义，组合也能做到。</p>
<p>   继承也不是通过组合的方式来实现的，和组合相比，继承更像是“融合”</p>
<h4 id="覆盖：子类想要一点不一样"><a href="#覆盖：子类想要一点不一样" class="headerlink" title="覆盖：子类想要一点不一样"></a>覆盖：子类想要一点不一样</h4><blockquote>
<p>覆盖才是继承的精髓和终极奥义</p>
<p>从覆盖的角度理解为什么使用方法读写属性，优于直接访问属性</p>
<p>为了避免代码重复，在子类里使用父类的buy和describe方法。如何在子类里，调用父类的方法？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseV2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> soldPrice;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; count) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count -= count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">MerchandiseV2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> screenSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> cpuHZ;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> memoryG;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> storageG;</span><br><span class="line">  <span class="keyword">private</span> String brand;</span><br><span class="line">  <span class="keyword">private</span> String os;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_BUY_ONE_ORDER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      String id,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> soldPrice,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> purchasePrice,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> screenSize,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> cpuHZ,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> memoryG,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> storageG,</span></span></span><br><span class="line"><span class="function"><span class="params">      String brand,</span></span></span><br><span class="line"><span class="function"><span class="params">      String os)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.screenSize = screenSize;</span><br><span class="line">    <span class="keyword">this</span>.cpuHZ = cpuHZ;</span><br><span class="line">    <span class="keyword">this</span>.memoryG = memoryG;</span><br><span class="line">    <span class="keyword">this</span>.storageG = storageG;</span><br><span class="line">    <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    <span class="keyword">this</span>.os = os;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setName(name);</span><br><span class="line">    <span class="keyword">this</span>.setId(id);</span><br><span class="line">    <span class="keyword">this</span>.setCount(count);</span><br><span class="line">    <span class="keyword">this</span>.setSoldPrice(soldPrice);</span><br><span class="line">    <span class="keyword">this</span>.setPurchasePrice(purchasePrice);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSoldPrice</span><span class="params">(<span class="keyword">double</span> soldPrice)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPurchasePrice</span><span class="params">(<span class="keyword">double</span> purchasePrice)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &gt;&gt; TODO 通过使用父类方法签名一样，并且返回值也一样的方法，可以让子类覆盖掉父类的方法</span></span><br><span class="line">  <span class="comment">// &gt;&gt; TODO 也就是说，子类并不是只能把父类的方法拿过来，并且可以通过覆盖来替换其中不适合子类的方法</span></span><br><span class="line">  <span class="comment">// &gt;&gt; TODO</span></span><br><span class="line">  <span class="comment">// &gt;&gt; TODO 为什么使用方法读写属性，优于直接访问属性？</span></span><br><span class="line">  <span class="comment">// &gt;&gt; TODO 属性是联动的，可能是有特殊意义的，所以直接给属性赋值是危险的，因为没有办法检查是否有意义，</span></span><br><span class="line">  <span class="comment">// &gt;&gt; TODO 也没法对这个修改做联动的修改</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo 这个方法里代码大部分和父类一样，肯定有方法解决；</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_BUY_ONE_ORDER) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; count) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count -= count;</span><br><span class="line">    <span class="keyword">return</span> count * soldPrice;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="super-和父类对象沟通的桥梁"><a href="#super-和父类对象沟通的桥梁" class="headerlink" title="super: 和父类对象沟通的桥梁"></a>super: 和父类对象沟通的桥梁</h4><blockquote>
<p>子类对象可以认为有一个特殊的父类的对象，这个父类对象和子类对象之间通过super关键字来沟通</p>
</blockquote>
<ul>
<li>super用法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">MerchandiseV2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_BUY_ONE_ORDER) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; count) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.buy(count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>super是子类和父类交流的桥梁，但是并不是父类的引用</li>
<li>所以，super和this自引用不一样，不是简单可以模拟的（可以模拟的话不就成了组合了吗）</li>
<li>使用super可以调用父类的public属性，但是super不是一个引用；</li>
<li>super的用法就像是一个父类的引用，它是继承的不一部分，像组合的那部分；但不是全部；</li>
</ol>
<h4 id="super：调用父类的构造方法"><a href="#super：调用父类的构造方法" class="headerlink" title="super：调用父类的构造方法"></a>super：调用父类的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">MerchandiseV2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      String id,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> soldPrice,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> purchasePrice,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> screenSize,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">double</span> cpuHZ,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> memoryG,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> storageG,</span></span></span><br><span class="line"><span class="function"><span class="params">      String brand,</span></span></span><br><span class="line"><span class="function"><span class="params">      String os)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">super</span>(name,id,count,soldPrice*<span class="number">1.2</span>,purchasePrice);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用super调用父类的构造方法，必须是子类构造方法的第一个语句</li>
<li>可以使用表达式</li>
<li>super调用构造方法，不可以使用super访问父类的属性和方法，不可以使用子类成员变量和方法</li>
<li>可以使用静态变量和方法</li>
<li>都是<init>方法；</li>
</ol>
<h4 id="父类和子类的引用赋值关系"><a href="#父类和子类的引用赋值关系" class="headerlink" title="父类和子类的引用赋值关系"></a>父类和子类的引用赋值关系</h4><blockquote>
<p>父类引用可以指向子类对象，子类引用不可以指向父类的对象</p>
<p>可以进行强制类转换，如果类型不对，会出错</p>
<p>可以调用的方法，是受引用类型决定的；</p>
</blockquote>
<p>idea-&gt;navigate-&gt;type hierarchy</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line">	- MerchandiseV2</span><br><span class="line">		- Phone</span><br><span class="line">			- ShellColorChangePhone</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefernceAssign</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Phone ph = <span class="keyword">new</span> Phone(</span><br><span class="line">    <span class="string">"phone"</span>,<span class="string">"001"</span>,<span class="number">100</span>,<span class="number">1999</span>,<span class="number">999</span>,<span class="number">4.5</span>,<span class="number">3.5</span>,<span class="number">4</span>...</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 子类的引用赋值给父类的引用，也就是说，父类的引用可以指向子类的对象；反之则不行，因为父类并没有子类的属性和方法；</span></span><br><span class="line">    MerchandiseV2 m = ph;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果确定一个父类的引用指向的对象，实际上就是一个子类的对象（或者子类的子类的对象），可以强制类型转换；</span></span><br><span class="line">    Phone aPhone = (Phone) m2;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 父类的引用，可以指向子类的对象，即可以用子类（以及子类的子类）的引用给父类的引用赋值</span></span><br><span class="line">   MerchandiseV2 ccm = <span class="keyword">new</span> ShellColorChangePhone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>因为子类继承了父类的方法和属性，所以父类的对象能做到的，子类的对象肯定能做到；</li>
<li>换句话说，可以在子类的对象上，执行父类的方法；</li>
<li>当父类的引用指向子类的实例，只能通过父类的引用，像父类一样操作子类的对象</li>
<li>也就是说“名”的类型，决定了能执行哪些操作</li>
<li>ph 和 m都指向同一个对象，通过ph可以调用getBrand方法；因为ph的类型是Phone，Phone里定义了getBrand方法；</li>
<li>ph和m都指向同一个对象，但是通过m就不可以调用getBrand方法；因为m是MerchandiseV2 类型，MerchandiseV2里面没有定义getBrand方法；</li>
</ol>
<h4 id="静态方法继承"><a href="#静态方法继承" class="headerlink" title="静态方法继承"></a>静态方法继承</h4><blockquote>
<p>静态方法可以被继承；子类.静态方法，可以访问到父类的同名静态方法；但是签名和返回值要一致；</p>
</blockquote>
<p>用引用调用静态方法没有覆盖；</p>
<p>使用引用调用静态方法，本身就是一种在规则边缘试探的用法，IDE都没提示。这些东西学了之后最好忘了，不是最佳实践；</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote>
<p>可以调用哪些方法，取决于引用类型。具体调用哪个方法，取决于实例所属的类是什么</p>
<p>覆盖的奥义</p>
<p>覆盖是多态里面最重要的一种形式</p>
<p>从this自引用角度，理解覆盖</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LittleSuperMarket superMarket = <span class="keyword">new</span> LittleSuperMarket();</span><br><span class="line"></span><br><span class="line">superMarket.getMerchandisOf(<span class="number">0</span>).getName();</span><br><span class="line">superMarket.getMerchandisOf(<span class="number">10</span>).getName();</span><br><span class="line">superMarket.getMerchandisOf(<span class="number">100</span>).getName();</span><br></pre></td></tr></table></figure>

<ol>
<li>虽然是用的父类的引用指向的不同类型的对象，调用getName方法时，实际执行的方法取决于对象的类型，而非引用的类型</li>
<li>也就是说，能调用哪些方法，是引用决定的，具体执行哪个类的方法，是引用指向的对象决定的；</li>
<li>这就是覆盖的精髓，覆盖是多态的一种，是最重要的一种；</li>
<li>以getName为例，父类里面有这个方法，所以肯定都可以调用，但是Phone覆盖了父类的getName方法；</li>
<li>之前我们使用子类的引用指向子类的对象，调用子类里覆盖父类的方法，比如getName，执行的是子类的getName方法，我们觉得很自然；</li>
<li>这里变换的是，我们用父类的引用指向子类的对象，调用被子类覆盖的方法，实际执行的还是子类里的getName方法；</li>
<li>我们用父类的引用指向一个Phone的实例，并调用getName方法时，实际调用的就是Phone类里定义的getName方法；</li>
<li>如果子类里没有覆盖这个方法，就去父类里找，父类里没有，就去父类的父类找，反之只要能让一个引用指向这个对象；</li>
<li>就说明这个对象肯定是这个类型或者其子类的一个实例（否则赋值会发生ClassCaseException），总归有父类兜底；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">polymorpismAppMainComplex</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LitterSuperMarket superMarket = <span class="keyword">new</span> LitterSuperMarket();</span><br><span class="line">    superMarket.getMerchandisOf(<span class="number">0</span>).describe();</span><br><span class="line"> superMarket.getMerchandisOf(<span class="number">10</span>).describe();</span><br><span class="line"> superMarket.getMerchandisOf(<span class="number">100</span>).describe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个复杂的例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MerchandiseV2.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(calculateProfit())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>MerchandV2 里的describe方法，调用了calculateProfit方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Phone.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span></span>&#123;</span><br><span class="line">  sout(<span class="string">"本手机下架"</span>);</span><br><span class="line">  <span class="keyword">super</span>.describe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Phone的describe方法，覆盖了直接父类MerchandiseV2里的describe方法，并且使用super调用了父类的describe方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShellColorChangePhone.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> describe&#123;</span><br><span class="line">  <span class="keyword">super</span>.describe();</span><br><span class="line">  sout(enableShellColorChange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateProfit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// TODO 促销，提供10个返点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.calculateProfit() + <span class="keyword">super</span>.getPurchasePrice() * <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ShellColorChangePhone里的describe方法，覆盖了直接父类Phone里的describe方法，并且使用super调用了父类的describe方法。更复杂的是，ShellColorChangePhone还覆盖了间接父类MerchandiseV2 里的 calculateProfit方法；</p>
<ul>
<li>总结<ul>
<li>无论一个方法是使用哪个引用被调用的，“它都是在实际的对象上执行的”。执行的任何一个方法，都是这个对象所属的类的方法。</li>
<li>如果没有，就去父类找，再没有，就去父类的父类找，依次寻找，直到找到；</li>
<li>换个角度理解，我们一直说子类里又一个（特殊的）父类的对象，这时候，这个特殊的父类的对象里的this自引用，是子类的引用；</li>
<li>那么自然的，即使是在继承自父类的代码里，去调用一个方法，也是先从子类开始，一层层继承关系的找；</li>
<li>这也是Java选择单继承的原因，在多继承的情况下，如果使用不当，多态可能会非常复杂，以至于使用的代价超过其带来的好处；</li>
</ul>
</li>
</ul>
<h4 id="多态里更多的语法点"><a href="#多态里更多的语法点" class="headerlink" title="多态里更多的语法点"></a>多态里更多的语法点</h4><blockquote>
<p>静态多态： 重载Overload</p>
<p>动态多态： 覆盖Override</p>
<p>勿忘初心：程序的执行就是找到要执行的代码，并且知道执行的代码能访问哪些数据，数据从哪里来。多态和核心问题就是：要调用哪个类的哪个方法，这个方法用到的数据（this引用）是谁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchandiseTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">// todo 之前重载的时候，参数是用的自定义类型。现在理解了父类和子类的引用赋值关系，重载又多了一层复杂性</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerchandiseOverload</span><span class="params">(MerchandiseV2 me)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"参数为MerchandiseV2的testMerchandiseOverload"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerchandiseOverload</span><span class="params">(ShellColorChangePhone shellColorChangePhone)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"参数为ShellColorChangePhone的testMerchandiseOverload"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerchandiseOverload</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"参数为String的testMerchandiseOverload"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerchandiseOverload</span><span class="params">(Phone ph)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"参数为Phone的testMerchandiseOverload"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerchandiseOverloadNotExactlyMatchType</span><span class="params">(MerchandiseV2 me)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"参数为MerchandiseV2的testMerchandiseOverloadNotExactlyMatchType"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerchandiseOverloadNotExactlyMatchType</span><span class="params">(Phone me)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"参数为Phone的testMerchandiseOverloadNotExactlyMatchType"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerchandiseOverloadNotExactlyMatchType</span><span class="params">(String me)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"参数为String的testMerchandiseOverloadNotExactlyMatchType"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tenon.supermarket.MerchandiseTest;</span><br><span class="line"><span class="keyword">import</span> com.tenon.supermarket.MerchandiseV2;</span><br><span class="line"><span class="keyword">import</span> com.tenon.supermarket.Phone;</span><br><span class="line"><span class="keyword">import</span> com.tenon.supermarket.ShellColorChangePhone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    MerchandiseV2 m;</span><br><span class="line">    MerchandiseTest merchandiseTest = <span class="keyword">new</span> MerchandiseTest();</span><br><span class="line"><span class="comment">// 重载调用哪个方法，和参数的引用类型相关，和引用实际指向的类型无关；</span></span><br><span class="line">    merchandiseTest.testMerchandiseOverload(m);</span><br><span class="line">    merchandiseTest.testMerchandiseOverload((Phone) m);</span><br><span class="line">    merchandiseTest.testMerchandiseOverload((ShellColorChangePhone) m);</span><br><span class="line">    <span class="comment">// 甚至是null也可以，但是要用强制类型转换，告诉java这个类型是什么，否则找不到一个唯一的方法去调用。</span></span><br><span class="line">    <span class="comment">// 重载的参数类型，相同位置，不一定要有继承或者兼容的关系，完全freestyle</span></span><br><span class="line">   merchandiseTest.testMerchandiseOverload((String) <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 引用本身是null没关系，确定调用哪个方法只需要引用的类型，这叫做静态多态，即在编译器就知道该调用哪个方法；</span></span><br><span class="line"></span><br><span class="line">    m = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    merchandiseTest.testMerchandiseOverload(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数为MerchandiseV2的testMerchandiseOverload</span><br><span class="line">参数为Phone的testMerchandiseOverload</span><br><span class="line">参数为ShellColorChangePhone的testMerchandiseOverload</span><br><span class="line">参数为String的testMerchandiseOverload</span><br></pre></td></tr></table></figure>



<p>如果引用类型没有完全匹配的，则会根据继承关系，沿着参数当前类型，向下撸；</p>
<h4 id="重载总结"><a href="#重载总结" class="headerlink" title="重载总结"></a>重载总结</h4><ol>
<li>静态多态，调用的方法和参数实际指向的对象无关，只和引用本身的类型相关；</li>
<li>因为调用时参数类型是确定的，所以，在编译期间就可以明确的知道哪个方法会被调用。如果有多种可能，则会编译错误；</li>
<li>如果没有类型完全匹配的候选，则根据类型的继承关系向下撸着找。找到最贴切参数类型的那个方法；</li>
<li>无论是静态方法，还是成员方法，重载寻找方法的顺序是一样的；</li>
<li>java没有多继承，（先贤的馈赠，保护了发际线）；</li>
</ol>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote>
<p>instanceof操作符，可以判断一个引用指向的对象是否是某一个类型或者其子类；是则返回true，否则返回false</p>
<p>如果引用是null，则肯定返回false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m <span class="keyword">instanceof</span> Phone) &#123;</span><br><span class="line">  <span class="comment">// 先判断，再强制类型转换，比较安全</span></span><br><span class="line">  Phone ph = (Phone)m;</span><br><span class="line">  sout(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m <span class="keyword">instanceof</span> ShellColorChangePhone) &#123;</span><br><span class="line">  <span class="comment">// 先判断，再强制类型转换，比较安全</span></span><br><span class="line">  Phone ph = (ShellColorChangePhone)m;</span><br><span class="line">  sout(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="万类之组：Object类"><a href="#万类之组：Object类" class="headerlink" title="万类之组：Object类"></a>万类之组：Object类</h3><blockquote>
<p>所有的类，都简洁或者直接的继承自Object类</p>
<p>Object类中的方法</p>
<p>Object类中的引用</p>
</blockquote>
<ul>
<li>toString方法</li>
<li>equals 和 hasCode</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><blockquote>
<p>Class类是代表类的类，每个Class类的实例，都代表了一个类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tenon.supermarket.MerchandiseV2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">    MerchandiseV2 m = <span class="keyword">new</span> MerchandiseV2();</span><br><span class="line">    Class clazz = m.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个类的Class 实例，可以获取一个类所有的信息，包括成员变量，方法，等</span></span><br><span class="line">    Field countField = clazz.getField(<span class="string">"count"</span>);</span><br><span class="line">    Field nameField = clazz.getField(<span class="string">"soldPrice"</span>);</span><br><span class="line">    <span class="comment">// 变长参数和它的等价形式</span></span><br><span class="line">    Method equalsMethod = clazz.getMethod(<span class="string">"equals"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Method buyMethod = clazz.getMethod(<span class="string">"buy"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz.getName());</span><br><span class="line">    System.out.println(clazz.getSimpleName());</span><br><span class="line">    System.out.println(countField);</span><br><span class="line">    System.out.println(nameField);</span><br><span class="line">    System.out.println(equalsMethod);</span><br><span class="line">    System.out.println(buyMethod);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// com.tenon.supermarket.MerchandiseV2</span></span><br><span class="line"><span class="comment">// MerchandiseV2</span></span><br><span class="line"><span class="comment">// public int com.tenon.supermarket.MerchandiseV2.count</span></span><br><span class="line"><span class="comment">// public double com.tenon.supermarket.MerchandiseV2.soldPrice</span></span><br><span class="line"><span class="comment">// public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">// public double com.tenon.supermarket.MerchandiseV2.buy(int)</span></span><br></pre></td></tr></table></figure>



<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote>
<p>使用反射（reflection）访问属性</p>
<p>使用反射访问方法</p>
<p>使用反射访问静态方法和属性</p>
<p>使用反射访问private的方法和属性</p>
<p>反射是什么: 动态去调用方法；反射慢，慢在查找field，执行方法的速度是一样的。所以找到field之后要保存起来；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外一种获得Class实例的方法，直接类点名</span></span><br><span class="line">MerchandiseV2 m100 = superMarket.getMerchandiseOf(<span class="number">100</span>);</span><br><span class="line">Class clazz = MerchandiseV2<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field countField = clazz.getField(<span class="string">"count"</span>);</span><br><span class="line">countField.get(m100); <span class="comment">// 100 相当于 m100.count;</span></span><br><span class="line">countField.set(m100, <span class="number">999</span>);</span><br><span class="line">countField.get(m100); <span class="comment">// 999</span></span><br><span class="line">m100.count; <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Field field: clazz.getFields())&#123;</span><br><span class="line">  sout(field.getType()+<span class="string">""</span>+field.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态传空即可</span></span><br><span class="line">Field field = clazz.getField(<span class="string">"STATIC_MEMBER"</span>);</span><br><span class="line">sout(field.get(<span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射去调用方法</span></span><br><span class="line">Method descMethod = clazz.getMethod(<span class="string">"describe"</span>);</span><br><span class="line">descMehtod.invoke(m100);</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Method buyMethod = clazz.getMethod(<span class="string">"buy"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">buyMethod.invoke(m100, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 等价于 m100.buy(10)</span></span><br></pre></td></tr></table></figure>



<h4 id="反射能做到，正常写做不到"><a href="#反射能做到，正常写做不到" class="headerlink" title="反射能做到，正常写做不到"></a>反射能做到，正常写做不到</h4><blockquote>
<p>访问private field 和 调用private 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchndiseV2</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> count = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MerchndiseV2 m100 = <span class="keyword">new</span> MerchndiseV2();</span><br><span class="line">    Class clazz = MerchndiseV2<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="comment">// getDeclaredField 获取声明的 field；别管是不是private</span></span><br><span class="line">    Field countField = clazz.getDeclaredField(<span class="string">"count"</span>);</span><br><span class="line">    countField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    countField.get(m100); <span class="comment">// </span></span><br><span class="line">    countField.set(m100, <span class="number">999</span>);</span><br><span class="line">    countField.get(m100); <span class="comment">// 999</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// private 方法</span></span><br><span class="line">    Method descMethod = clazz.getDeclareMethod(<span class="string">"describe"</span>);</span><br><span class="line">    descMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    descMethod.invoke(m100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><blockquote>
<p>使用枚举定义商品门类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类无法继承其他类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Category &#123;</span><br><span class="line">  <span class="comment">// 必须在开始的时候 以这种形式，创建所有的枚举对象</span></span><br><span class="line">  FOOD(<span class="number">1</span>),</span><br><span class="line">  COOK(<span class="number">3</span>),</span><br><span class="line">  SNACK(<span class="number">5</span>),</span><br><span class="line">  CLOTHES(<span class="number">7</span>),</span><br><span class="line">  ELECTRIC(<span class="number">9</span>);</span><br><span class="line">  <span class="comment">// 枚举的特殊之处在于，它就只有上面这么多的对象；FOOD，COOK这些为枚举对象的名字；对象名不能重复</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="comment">// 构造方法必须是private，不写默认也是private的</span></span><br><span class="line">  Category(<span class="keyword">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Category&#123;"</span> + <span class="string">"id="</span> + id + <span class="string">'&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseEnum</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Category category : Category.values()) &#123;</span><br><span class="line">      System.out.println(category.getId());</span><br><span class="line">      System.out.println(category.ordinal());</span><br><span class="line"></span><br><span class="line">      System.out.println(category.name());</span><br><span class="line">      System.out.println(category.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(Category.valueOf(<span class="string">"FOOD"</span>));</span><br><span class="line">    System.out.println(Category.valueOf(<span class="string">"food"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">FOOD</span><br><span class="line">Category&#123;id=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">COOK</span><br><span class="line">Category&#123;id=<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">SNACK</span><br><span class="line">Category&#123;id=<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">CLOTHES</span><br><span class="line">Category&#123;id=<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">ELECTRIC</span><br><span class="line">Category&#123;id=<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Category&#123;id=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><blockquote>
<p>接口定义</p>
<p>接口实现和接口引用的使用</p>
<p>接口的继承</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tenon.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口中的方法，就是这个类型的规范，接口专注于规范，怎么实现这些规范，不关心</span></span><br><span class="line"><span class="comment">// 接口无法被实例化，也就是不可以new一个接口的实例；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpireDateMerchandise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接口里面的方法都是public abstract修饰的，方法有名字，参数和返回值没有方法体，以</span></span><br><span class="line">  <span class="comment">// 分号；结束。</span></span><br><span class="line">  <span class="comment">// 因为接口里的方法都是且只能用public abstract修饰，所以这两修饰符可以省略</span></span><br><span class="line">  <span class="comment">// abstract就是抽象方法的修饰符，没有方法体，以分号结束；</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">notExpireInDays</span><span class="params">(<span class="keyword">int</span> days)</span></span>;</span><br><span class="line">  <span class="comment">// 接口内不能定义局部变量，定义的变量都是public static final的，这三个修饰可以省略</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VAL_IN_INTERFACE = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implements 实现接口</span></span><br><span class="line"><span class="comment">// 一个类只能继承一个父类，但可以实现多个接口</span></span><br><span class="line"><span class="comment">// 实现的接口里定义了一样的方法，那么也没问题，但是要求方法名，参数，返回值类型都一摸一样；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePointCard</span> <span class="keyword">extends</span> <span class="title">MerchandiseV2</span> <span class="keyword">implements</span> <span class="title">ExpireDateMerchandise</span>, <span class="title">VirtualMerchandise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以用实现接口的类的引用，给接口的引用赋值，类似于可以使用子类的引用给父类赋值；</span></span><br><span class="line">  ExpireDateMerchandise expireDateMerchandise = gamePointCard;</span><br><span class="line">  VirtualMerchandise virtual = gamePointCard;</span><br><span class="line">  MerchandiseV2 = gamePointCard;</span><br><span class="line">  expireDateMerchandise = (ExpireDateMerchandise) m;</span><br><span class="line">  virtual = (VirtualMerchandise) m;</span><br><span class="line">  <span class="keyword">if</span>(m <span class="keyword">instanceof</span> ExpireDateMerchandise) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(m <span class="keyword">instanceof</span> VirtualMerchandise)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>接口继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interf1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Intf1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// interf2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Intf2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// interf3</span></span><br><span class="line"><span class="comment">// 接口也可以继承接口，接口可以继承多个接口，接口之间的继承要用extends</span></span><br><span class="line"><span class="comment">// 继承的接口，可以有重复的方法，但是签名相同时，返回值必须完全一样，否则compile error</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Intf3</span> <span class="keyword">extends</span> <span class="title">Intf1</span>, <span class="title">Intf2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Abstract-抽象类：-接口和类的混合体"><a href="#Abstract-抽象类：-接口和类的混合体" class="headerlink" title="Abstract 抽象类： 接口和类的混合体"></a>Abstract 抽象类： 接口和类的混合体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类用abstract 修饰，抽象类可以继承别的类或者抽象类，也可以实现接口；</span></span><br><span class="line"><span class="comment">// 抽象类可以有抽象方法，抽象方法可以来自实现的接口，也可以自己定义；</span></span><br><span class="line"><span class="comment">// 抽象类不可以被实例化</span></span><br><span class="line"><span class="comment">// 抽象类也可以没有抽象方法，没有抽象方法的抽象类，也不可以被实例化；</span></span><br><span class="line"><span class="comment">// 简单来说，抽象类就两点特殊： 1 被abstract 修饰，可以有抽象方法 2 不可以被实例化；</span></span><br><span class="line"><span class="keyword">public</span> AbstractExpire extends MerchandiseV2 implements ExpireDateMerchandise&#123;</span><br><span class="line">  <span class="comment">// 抽象类里的构造方法和语法和类一样；</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractExpire</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="comment">// @Override代表此方法覆盖了父类的方法/实现了继承的接口的方法，否则会报错；</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">notExpireInDays</span><span class="params">(<span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daysBeforeExpire() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有方法代码的接口"><a href="#有方法代码的接口" class="headerlink" title="有方法代码的接口"></a>有方法代码的接口</h3><blockquote>
<p>接口中允许有缺省实现的抽象方法；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpireDateMerchandise</span></span>&#123;</span><br><span class="line">  <span class="comment">// 缺省的实现方法，用default修饰，可以有方法体</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">notExpireInDays</span><span class="params">(<span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daysBeforeExpire() &gt; days;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接口里的私有方法，不需要用default修饰。</span></span><br><span class="line">  <span class="comment">// 接口里的私有方法，可以认为是代码直接插入到使用的地方；</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">daysBeforeExpire</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expireMS = getExpireDate().getTime();</span><br><span class="line">    <span class="keyword">long</span> left = expireMS - System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left/(<span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管可以有方法，可以有缺省实现，但接口不能有成员变量，</p>
<h3 id="接口内的代码"><a href="#接口内的代码" class="headerlink" title="接口内的代码"></a>接口内的代码</h3><p>java中，接口中允许有静态方法，私有方法和带有缺省实现的抽象方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">daysBeforeExpire</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daysBetween(System.currentTimeMillis(), getExpireDate().getTime());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">daysAfterProduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daysBetween(getProducedDate().getTime(), System.currentTimeMillis());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO 接口中可以有静态方法，不需要用default修饰。静态方法可以被实现接口的类继承</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">daysBBefore</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> gap = to -from;</span><br><span class="line">    <span class="keyword">if</span>(gap &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gap/(<span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>接口中有方法，不代表是Java有多继承；</li>
</ul>
<p>有方法的接口，并不是多继承，接口不可以继承类，这一点就打破了；</p>
<p>同样，接口不可以声明实例变量。其方法是有限制的。比如这个接口，因为不能声明实例变量。</p>
<p>只能通过getProducedDate 和getExpireDate, 间接通过实现接口的类，获取数据；</p>
<p>“和抽象方法不同，如果一个类实现了两个接口，并且两个接口里有相同的缺省方法，编译器会报错；”</p>
<ul>
<li>理解接口方法里的this自引用；</li>
</ul>
<p>缺省方法，也有this自引用，但是只能调用接口里的方法，或者继承的接口里的方法；</p>
<p>因为能new出实例来的，肯定是实现了所有方法的，this自引用就是指向那个对象，所以使用起来不会有问题；</p>
<p>因为能new出实例来的，肯定是实现了所有方法的，this自引用就是指向那个对象，所以使用起来不会有问题；</p>
<p>实现有缺省方法的接口后，面对每个缺省的方法，一个类可以有三个选择。</p>
<p>1） 默默继承，相当于把这部分代码，拷贝到了当前类中；</p>
<p>2） 重新声明此方法为abstract，相当于把这部分代码拒之门外，但是有abstract方法，也就是类必须是抽象的；</p>
<p>3） 覆盖，重新实现；</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">phone</span> <span class="keyword">extends</span> <span class="title">MerchandiseV2</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CPU cpu;</span><br><span class="line">  <span class="keyword">private</span> String os;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> speed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CPU</span><span class="params">(<span class="keyword">double</span> speed, String priducer)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.speed = speed;</span><br><span class="line">      <span class="keyword">this</span>.producer = producer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 静态内部类，代码和这个类本身的访问权限一样，可以访问外部（Phone）的private属性；</span></span><br><span class="line">      <span class="comment">// 注意，这并不是说它可以访问private变量，</span></span><br><span class="line">      <span class="comment">// 静态内部类是静态的，就好像静态方法一样，没有this自引用，可以通过引用访问Phone对象的private</span></span><br><span class="line">      Phone phone = <span class="keyword">null</span>;</span><br><span class="line">      phone.memoryG = <span class="number">99</span>;</span><br><span class="line">      <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态内部类，里面可以有任意合法的类的组成部分，包括静态内部类</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ABC</span></span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessStaticClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 同样，外部类也可以访问静态内部类（CPU）的private属性</span></span><br><span class="line">    <span class="keyword">this</span>.cpu.priducer = <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">    <span class="comment">// 可以像平常的类一样使用静态内部类；</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公有类和静态内部类，实际区别就在于能否访问类的private成员；</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// TODO 在类的外面的代码，不能访问类的private成员；</span></span><br><span class="line">    Phone ph = <span class="keyword">null</span>;</span><br><span class="line">    ph.sreen = <span class="number">9</span>; <span class="comment">// IDE报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>静态内部类，是在类中使用static修饰的类</li>
<li>静态内部类，可以有访问控制符，静态内部类和静态方法，静态变量一样，都是类的静态组成部分；</li>
<li>静态内部类也是类，在继承，实现接口方面，都是一流的。以后我们讲的类，不特殊说明，在这方面都是一样的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPhoneMerchandise</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    phone.describePhone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类，可以认为是和静态方法，静态成员一样，是类的一个类内部的一个成员，一个组成部分；</span></span><br><span class="line">    <span class="comment">// 所以使用的时候，也可以点出来，只是点出来的是个类而已，点出来以后，改怎么用一个类都行；</span></span><br><span class="line">    Phone.CPU cpu = <span class="keyword">new</span> Phone.CPU(<span class="number">5.5</span>, <span class="string">"default"</span>);</span><br><span class="line">    <span class="comment">// 访问控制： 在定义静态内部类的外部的代码，就不可以访问其private的属性了；</span></span><br><span class="line">    cpu.speed = <span class="number">99</span>; <span class="comment">// 编译器报错，因为speed是private属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看Math类源代码，学习静态内部类的一种曲线用途： 实现单例模式</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><blockquote>
<p>和静态内部类相似，成员内部类是一个属性成员</p>
</blockquote>
<p>对比记忆： 成员内部类可以被什么修饰，可以在哪里使用，可以对比成员变量；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">MerchandiseV2</span></span>&#123;</span><br><span class="line">  <span class="comment">// 给Phone 增加新的属性和方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> screenSize;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 成员内部类，是在类中直接定义类</span></span><br><span class="line">  <span class="comment">// 成员内部类，不可以包含任何静态的成分，比如静态方法，静态变量，静态内部类，否则会造成内外部 类初始化问题</span></span><br><span class="line">  <span class="comment">// 成员内部类，可以有访问控制符。成员内部类和成员方法，成员变量一样，都是类的组成部分；</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以有final static的基本数据类型变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> abc = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> String priducer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CPU</span><span class="params">(String producer)</span></span>&#123;<span class="keyword">this</span>.producer = producer&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 成员内部类，代码和这个类本身的访问权限一样，可以访问外部（Phone）的private属性</span></span><br><span class="line">      <span class="comment">// 成员内部类中有一个外部类的引用，其访问外部类的对象的成员属性就是使用这个引用，完整的写法是：</span></span><br><span class="line">      <span class="keyword">return</span> Phone.<span class="keyword">this</span>.speed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员内部类，里面可以有任意合法的类的组成部分，包括成员内部类。但是不可以有静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABC</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.exception;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionFirstExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * try 语句中如果发生了异常（Exception）那么程序跳转到catch语句 Java会将异常相关信息封装在一个异常类的实例中，ex是指向这个异常实例的引用</span></span><br><span class="line"><span class="comment">     * "处理"最简单的方法，就是调用printStackTrace将异常信息输出到控制台 catch语句执行完毕，程序会继续向下顺序执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">      arr[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的继承关系分类"><a href="#异常的继承关系分类" class="headerlink" title="异常的继承关系分类"></a>异常的继承关系分类</h3><blockquote>
<p>异常是java中的类，所有异常的父类： Throwable</p>
</blockquote>
<blockquote>
<p>两类异常： Error 和 Exception</p>
</blockquote>
<p> Error： 不可修复，或者用户做什么东西不能恢复的异常；比如内存不够用，资源不够用；</p>
<p>Exeption： catch到之后是可以补救的，和应用程序相关的；</p>
<blockquote>
<p>看一下Throwable的继承关系</p>
</blockquote>
<p>两个子类，Error 和Exeption</p>
<p>java中，异常的类型很重要；判断出类型，最终的bug就八九不离十了；</p>
<ul>
<li>按照处理方式不同分类</li>
</ul>
<p>checked exception： 语法要求必须要用try catch或者 throws语句处理的异常；</p>
<p>unchecked exception: 语法不要求一定要用 try catch或者throws语句处理的异常；</p>
<p>Error 和  RuntimeException 是 unchecked exception的父类，我们一般使用RuntimeException；</p>
<ul>
<li>什么叫做语法要求必须处理的异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustHandel</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// ClassNotFoundException 必须要处理的异常</span></span><br><span class="line">    Class clazz = Class.forName(<span class="string">"com.denon.exception.MustHandel"</span>);</span><br><span class="line">    System.out.println(clazz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要求一定要处理的异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotHaveToHandle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空引用无时无刻不存在，如果都强制需要，那整个代码库都得捕获异常了；</span></span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    str.toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抛出异常的语法"><a href="#抛出异常的语法" class="headerlink" title="抛出异常的语法"></a>抛出异常的语法</h3><ol>
<li>抛出别的代码抛过来的异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowIt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 可以使用throws关键字，抛出一个异常</span></span><br><span class="line">    <span class="comment">// TODO 抛出异常类型，可以是实际异常的父类或本身</span></span><br><span class="line">    <span class="comment">// TODO 可以抛出多种类型的异常，用逗号分开就可以；</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"abc"</span>);</span><br><span class="line">    System.out.println(clazz.getField(<span class="string">""</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在代码里自己创建一个异常，并抛出去</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewAndThrowIt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    causeException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">causeException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 可以创建一个checked exception， 然后用throw 关键字扔出</span></span><br><span class="line">    <span class="comment">// 这时候就需要方法也要有throws语句，同样的，throws语句的类型要能覆盖实际异常的类型</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">causeRuntimeException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以创建一个unchecked exception，然后用throw关键字扔出去</span></span><br><span class="line">    <span class="comment">// 这时候，方法可以有，也可以没有throws语句</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>抽象方法中声明抛出的异常是接口方法签名的一部分</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntfWithEx</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">danger</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">safe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpIntfWithEx</span> <span class="keyword">implements</span> <span class="title">IntfWithEx</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">danger</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 接口中声明了抛出异常，实现类中可以抛，也可以不抛。抛的话必须是接口声明的类或其子类</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口中没有声明抛出异常，实现类中可以抛出RuntimeException，也可以不抛；</span></span><br><span class="line">    <span class="comment">// 如果抛 checked exception，就会出错</span></span><br><span class="line">    <span class="comment">// 可以选择catch住 checked exception，然后将它封在RuntimeException里</span></span><br><span class="line">    <span class="comment">//    throw new Exception();</span></span><br><span class="line">    <span class="comment">//    throw new RuntimeException();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Java异常的传递"><a href="#Java异常的传递" class="headerlink" title="Java异常的传递"></a>Java异常的传递</h3><blockquote>
<p>方法一个调一个的层层调用，组成了方法调用栈</p>
<p>学习Java异常在方法调用之间传递</p>
</blockquote>
<p>Java异常的归宿：要么沿着方法调栈顺序一路抛，最终造成当前线程出错退出，要么被catch住；</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><blockquote>
<p> 异常最重要的信息：类型，错误信息和出错时的调用栈；</p>
</blockquote>
<p>创建自己的异常类</p>
<ol>
<li>catch语句是根据异常类型匹配来捕获相应类型异常的；</li>
<li>如果类型不匹配，catch语句是不会执行的，异常会继续抛出；</li>
<li>也就是说，catch（Throwable）会捕捉到所有的异常，包括Error，建议最多只捕获Exception</li>
<li>如果catch一个其实并没有被抛出的checked exception，Java程序会报错，因为Java明确的知道这个类型的异常不会发生；</li>
<li>如果catch一个unchecked exception，Java程序会报错，因为Java明确的知道这个类型的异常不会发生；</li>
<li>如果throws 一个其实并没有被抛出的checked exception或者unchecked exception，Java程序不会报错；</li>
</ol>
<h3 id="trycatchfinally"><a href="#trycatchfinally" class="headerlink" title="trycatchfinally"></a>trycatchfinally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">withFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> s.length();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 异常的处理： 在有返回值的情况下，返回一个特殊的值，代表情况不对，有异常；</span></span><br><span class="line">    len = -<span class="number">1</span>;</span><br><span class="line">    sout(<span class="string">"执行catch里的return语句"</span>);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 可以认为finally语句会在方法返回后，后面的方法开始前，会在return语句后</span></span><br><span class="line">    <span class="comment">// 跟js一样，无论catch  还是其他的啥，最终都会走 finally</span></span><br><span class="line">    <span class="comment">// finally 最好不要有return 语句</span></span><br><span class="line">    <span class="comment">// finally给return 变量的赋值没用</span></span><br><span class="line">    VAL = <span class="number">999</span>;</span><br><span class="line">    sout(<span class="string">"finally"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">catchMultiTypeMultiMatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwMultiException(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// catch的类型不能有多种匹配可能，否则会出错</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">catchMultiNew</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    throwMultiException(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果捕获了不同类型的异常，但是处理方式一样，可以用简化模式</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(ClassNotFoundException | IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throwMultiException</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"demo"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"demo"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"demo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自动回收资源的try语句"><a href="#自动回收资源的try语句" class="headerlink" title="自动回收资源的try语句"></a>自动回收资源的try语句</h3><blockquote>
<p>和资源（网络，文件）相关的异常处理比较繁复，尤其是有多个资源的时候</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoCloseableResource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span>(Math.random()&gt;<span class="number">0.1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"you got lucky to read from"</span> + resName + <span class="string">"for "</span>+counter+<span class="string">" times..."</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"resource 不能存在哦"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    sout(<span class="string">"资源释放了："</span>+ resName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryWithResource</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (MyAutoCloseableResource res1 = <span class="keyword">new</span> MyAutoCloseableResource(<span class="string">"res1"</span>);</span><br><span class="line">        MyAutoCloseableResource res2 = <span class="keyword">new</span> MyAutoCloseableResource(<span class="string">"res2"</span>))&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        sout(res1.read());</span><br><span class="line">        sout(res2.read());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Java中的常见异常"><a href="#Java中的常见异常" class="headerlink" title="Java中的常见异常"></a>Java中的常见异常</h3><p>uncheckException</p>
<ul>
<li>NullPointException  空引用</li>
<li>IndexOutOfBoundsException 边界索引</li>
<li>ClassCaseException  类型强转</li>
</ul>
<p>checkException</p>
<ul>
<li>ClassNotFoundException 找不到类</li>
<li>IOException IO异常</li>
</ul>
<h2 id="4-Collection"><a href="#4-Collection" class="headerlink" title="4.Collection"></a>4.Collection</h2><p>计算机中基础的数据结构有List，Set，Queue，Map，比较高级一点的有Tree，Heap 这些数据结构需要代码来实现，这些实现也是一个个的类，只是专注的问题更抽象和通用</p>
<blockquote>
<p>Collection 代表一堆元素，集合。Collection接口的继承者和它们实现构成了我们所谓的Collection类族；</p>
</blockquote>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>Set代表一个元素不重复的集合，也就是说，Set中的元素两两不相等</p>
</blockquote>
<p>HashSet 顾名思义，是使用了元素的hash值帮忙做去重的</p>
<p>hashCode 和 equals符合这样一个约定：equals 返回true，hashCode必须相等。很多Java类库中的代码都是按照这种约定使用这两个方法的，比如HashSet，这也是为什么我们要求如果一个类覆盖了hashCode方法，就一定要覆盖equals方法，并保证方法的实现符合上述约定；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollctionApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    printCollection(addElementsToCollection(<span class="keyword">new</span> HashSet&lt;&gt;()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;?&gt; addElementsToCollection(Collection&lt;String&gt; collection) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      collection.add(<span class="string">"str"</span> + (i % <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(collection.getClass() + <span class="string">"中的元素，共"</span> + collection.size());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Object element : collection) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><h4 id="基本类型的自动装箱和拆箱"><a href="#基本类型的自动装箱和拆箱" class="headerlink" title="基本类型的自动装箱和拆箱"></a>基本类型的自动装箱和拆箱</h4><ul>
<li>数字的基本类型的封装类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperClassesForNumberPrimaryTypesAppMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从java 第一个版本开始，Java就为每种基本数据类型提供了封装的类，以便可以将其当作类而非基本数据类型使用</span></span><br><span class="line">    <span class="comment">// 比如List，Map这些类，都是操作的Object，无法操作基本数据类型</span></span><br><span class="line">    <span class="comment">// 和数字相关的基本数据类型对应的类依次为Byte， Short，Integer，Long，Float, Double</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// 可以使用数字创建一个Integer类，下面的方法在别的数字类中也都类似</span></span><br><span class="line">    Integer i1 = <span class="keyword">new</span> Integer(a);</span><br><span class="line">    Integer i2 = <span class="keyword">new</span> Integer(<span class="string">"789"</span>);</span><br><span class="line">    <span class="keyword">int</span> b = Integer.valueOf(a); <span class="comment">// 自动拆箱， valueOf返回一个Integer类型，通过自动拆箱让 基本类型 int 接受。</span></span><br><span class="line">    <span class="keyword">int</span> c = Integer.parseInt(<span class="string">"987"</span>);</span><br><span class="line">    System.out.println(<span class="string">"---------z自动封装拆箱-----------"</span>);</span><br><span class="line">    <span class="comment">// java 提供了自动为每种基本数据类型和其封装类之间的转换功能</span></span><br><span class="line">    <span class="comment">// 从基本数据类型到封装类，我们叫做自动封箱，英文叫做auto boxing，反之叫做自动拆箱，叫做auto unboxing</span></span><br><span class="line"></span><br><span class="line">    Integer ab = <span class="number">987</span>; <span class="comment">// 封箱</span></span><br><span class="line">    <span class="keyword">int</span> cd = ab; <span class="comment">// 拆箱</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动封箱为Integer，作为Map中的key</span></span><br><span class="line">    Map&lt;Integer, String&gt; int2Str = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    int2Str.put(<span class="number">1</span>, <span class="string">"一"</span>);</span><br><span class="line">    int2Str.put(<span class="number">2</span>, <span class="string">"二"</span>);</span><br><span class="line">    int2Str.put(<span class="number">3</span>, <span class="string">"三"</span>);</span><br><span class="line">    System.out.println(int2Str.get(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 自动拆箱为int，并给key值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key : int2Str.keySet()) &#123;</span><br><span class="line">      System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"---------有用的方法-----------"</span>);</span><br><span class="line">    System.out.println(Integer.toBinaryString(<span class="number">1024</span>));</span><br><span class="line">    System.out.println(Integer.toOctalString(<span class="number">1024</span>)); <span class="comment">// 8进制</span></span><br><span class="line">    System.out.println(Integer.toHexString(<span class="number">1024</span>)); <span class="comment">// 16进制</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------------Number类------------"</span>);</span><br><span class="line">    <span class="comment">// 所有和数字相关的封装类，都继承自Number类</span></span><br><span class="line">    Number num = <span class="number">9</span>;</span><br><span class="line">    num = <span class="keyword">new</span> Integer(<span class="number">12345</span>);</span><br><span class="line">    Number numD = <span class="number">9.99</span>;</span><br><span class="line">    numD = <span class="keyword">new</span> Double(<span class="number">12.456</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Number类可以方便的进行数字类型的转换</span></span><br><span class="line">    <span class="comment">// 当然所有的类都继承了Number的这些转换方法</span></span><br><span class="line">    System.out.println(<span class="string">"使用number将double转为long："</span> + numD.longValue());</span><br><span class="line">    System.out.println(<span class="string">"----------自动拆箱可能的NPE-----------"</span>);</span><br><span class="line">    int2Str.put(<span class="keyword">null</span>, <span class="string">"无"</span>);</span><br><span class="line">    System.out.println(int2Str.get(<span class="keyword">null</span>)); <span class="comment">// 无</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动拆箱为int，并给key赋值，但是有一个key为null，null是无法转成一个int的，注意，null不是0</span></span><br><span class="line">    <span class="comment">// 其实自动拆箱，后面是Java帮我们调用了对应的方法，在这里就是intValue()这个方法</span></span><br><span class="line">    <span class="comment">// 所以当引用为null时候自动拆箱，相当于是调用null的方法，所以这时候就会发生NPE (null pointer exception)</span></span><br><span class="line">    <span class="comment">// 对于其他封装类型的自动拆装箱，也是一样的。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key : int2Str.keySet()) &#123;</span><br><span class="line">      System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符的基本类型的封装类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WapperClassForChar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// char对应的类为 Character，里面有很多isXXX方法比较实用，比如判断字符是否为数字</span></span><br><span class="line">    System.out.println(Character.isDigit(<span class="string">'A'</span>));</span><br><span class="line">    System.out.println(Character.isDigit(<span class="string">'字'</span>));</span><br><span class="line">    System.out.println(Character.isDigit(<span class="string">'0'</span>));</span><br><span class="line">    System.out.println(Character.isDigit(<span class="string">'9'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>布尔的基本类型的封装类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperClassBoolean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// boolean对应的类为Boolean，布尔值因为只有两个值，所以Boolean类直接提供了这两个值的静态变量</span></span><br><span class="line">    System.out.println(<span class="string">"--------静态变量-------"</span>);</span><br><span class="line">    System.out.println(Boolean.TRUE);</span><br><span class="line">    System.out.println(Boolean.FALSE);</span><br><span class="line">    System.out.println(<span class="string">"----------valueof---------"</span>);</span><br><span class="line">    <span class="comment">// 只有不分大小写的true才是true，剩下的字符串都是false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Boolean.valueOf(<span class="string">"true"</span>));</span><br><span class="line">    System.out.println(Boolean.valueOf(<span class="string">"false"</span>));</span><br><span class="line">    System.out.println(Boolean.valueOf(<span class="string">"asdf"</span>));</span><br><span class="line">    System.out.println(Boolean.valueOf(<span class="string">" true "</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java是通过创建实例或者返回缓存住的实例来实现自动封箱的，是通过调用相应的转换方法实现自动拆箱的。Integer 是不可变的（没有set方法，不能改变值的）；</li>
</ul>
<h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5. 泛型"></a>5. 泛型</h2><p>generic</p>
<p>generic Method， generic Types</p>
<p>泛型可以是类，也可以是接口，定义Generic Methods和Generic Types。</p>
<p>解决问题： 定义泛型，让类中的代码有类型约束信息</p>
<h3 id="让一个List存储多个String对象"><a href="#让一个List存储多个String对象" class="headerlink" title="让一个List存储多个String对象"></a>让一个List存储多个String对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.learngenerics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseGenericApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    useStringList();</span></span><br><span class="line">    useStringListGenerics();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">createStringListGenerics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      ret.add(<span class="string">"str"</span> + (i % <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useStringListGenerics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strList = createStringListGenerics();</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">      str = str.toUpperCase();</span><br><span class="line">      System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="让一个List里只有String"><a href="#让一个List里只有String" class="headerlink" title="让一个List里只有String"></a>让一个List里只有String</h3><h3 id="解决问题：-让List中只有一种类型的元素，使用时不用强制类型转换"><a href="#解决问题：-让List中只有一种类型的元素，使用时不用强制类型转换" class="headerlink" title="解决问题： 让List中只有一种类型的元素，使用时不用强制类型转换"></a>解决问题： 让List中只有一种类型的元素，使用时不用强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型，就是把需要的类型定义在类后面的尖括号，然后在类里面就可以把定义好的泛型像符号一样使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">First</span>, <span class="title">Second</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 实际上这两个引号都是Object类型的</span></span><br><span class="line">  <span class="keyword">private</span> First first;</span><br><span class="line">  <span class="keyword">private</span> Second second;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span><span class="params">(First first, Second second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = first;</span><br><span class="line">    <span class="keyword">this</span>.second = second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> First <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(First first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Second <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Second second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.second = second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;Another&gt; <span class="function">Another <span class="title">getAnother</span><span class="params">(Object val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把强转逻辑封装成一个方法</span></span><br><span class="line">    <span class="keyword">return</span> (Another) val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">useMyGenericClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 泛型作用 1. 告诉编译器帮助检查类型是否匹配，类型是什么不重要，类型一样才重要； 2. 在使用的地方悄悄帮助做类型强制转换 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Field field2 = MyGenericClass.class.getDeclaredField("first");</span><br><span class="line">    System.out.println(<span class="string">"first的类型是"</span> + field2.getType());</span><br><span class="line"></span><br><span class="line">    MyGenericClass&lt;String, Object&gt; test = <span class="keyword">new</span> MyGenericClass&lt;&gt;(<span class="string">"inst1"</span>, <span class="keyword">new</span> Object());</span><br><span class="line">    MyGenericClass&lt;String, Object&gt; test2 = <span class="keyword">new</span> MyGenericClass&lt;&gt;(<span class="string">"inst2"</span>, <span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">    String first = test.getFirst();</span><br><span class="line">    System.out.println(first);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    Object second = test.getSecond();</span></span><br><span class="line">    <span class="comment">// 方法的类型参数也是一样，换到了使用的地方做类型强制转换</span></span><br><span class="line">    String another = test.getAnother(<span class="string">"safe"</span>);</span><br><span class="line">    <span class="comment">// 编辑器实际将其编译成下面这句，这也是编译器所做的优化。</span></span><br><span class="line">    <span class="comment">// String another = (String) test.getAnother(new Object());</span></span><br><span class="line">    System.out.println(another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果泛型信息缺失了，编译器也无法帮忙检查出类型不匹配，只能给出</span></span><br><span class="line">    <span class="comment">// unchecked编译警告</span></span><br><span class="line">    MyGenericClass mc = <span class="keyword">new</span> MyGenericClass(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">    MyGenericClass&lt;GrandParent, Parent&gt; cast = mc;</span><br><span class="line">    <span class="comment">// 会出错，因为cast指向的实例其实里面存的是两个String</span></span><br><span class="line">    GrandParent a = cast.getFirst();</span><br><span class="line">    <span class="comment">// 只调用这个方法，不会出错</span></span><br><span class="line">    cast.getFirst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="有界类型"><a href="#有界类型" class="headerlink" title="有界类型"></a>有界类型</h3><blockquote>
<p>泛型类型不可以调用方法，因为不知道是什么类型。如果需要使用某个类的方法，则需要给定类型的范围；</p>
</blockquote>
<p>在类型定义中给定类型的范围</p>
<p>解决的问题： 让自己类的代码可以调用泛型类型的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.learngenerics.define;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.denon.learngenerics.ext.GrandParent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义泛型，就是把需要的类型定义在类后面的尖括号里，</span></span><br><span class="line"><span class="comment">// 然后在类里面就可以把定义好的泛型像符号一样使用；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericBounded</span>&lt;<span class="title">MyType</span> <span class="keyword">extends</span> <span class="title">GrandParent</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 实际上myType 这个引用是GrandParent类型的；</span></span><br><span class="line">  <span class="keyword">private</span> MyType myType;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyGenericBounded</span><span class="params">(MyType myType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所以在这里可以通过这个引用，调用 GrandParent的方法</span></span><br><span class="line">    myType.getNum();</span><br><span class="line">    <span class="keyword">this</span>.myType = myType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyType</span><span class="params">(MyType myType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.myType = myType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.learngenerics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.denon.learngenerics.define.MyGenericBounded;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseBound</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果在定义的时候就制定了类型，那么引用的类型就是指定的类型的最父级的类型</span></span><br><span class="line">    <span class="comment">// 在这里就是 GrandParent</span></span><br><span class="line">    Field field = MyGenericBounded.class.getDeclaredField("myType");</span><br><span class="line">    System.out.println(field.getType());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h3><blockquote>
<p>Java泛型对协变和逆变的支持是为了支持范围更广的参数类型</p>
<p>协变和逆变是针对引用类型而言的，可以用在返回值类型，参数类型，等引用类型上，创建对象的时候，不能使用协变和逆变；</p>
<p>写入使用逆变，读取使用协变</p>
<p>解决问题：让参数和返回值等引用类型的泛型类型更灵活</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.learngenerics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.denon.learngenerics.ext.Children;</span><br><span class="line"><span class="keyword">import</span> com.denon.learngenerics.ext.GrandParent;</span><br><span class="line"><span class="keyword">import</span> com.denon.learngenerics.ext.Parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreGenericsApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    List&lt;Children&gt; g3List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 这么传递参数不行，泛型类型不管继承关系，只管严格的匹配</span></span><br><span class="line">    <span class="comment">// 换句话说，Children 是Parent 的子类，但是List&lt;Children&gt; 不是List&lt;Parent&gt;的子类</span></span><br><span class="line">    <span class="comment">//     justG2Method(g3List);</span></span><br><span class="line">    <span class="comment">// 那么怎么办呢？ 要让接收方，也就是行参，声明协变泛型</span></span><br><span class="line">    extMethod(g3List); <span class="comment">// List&lt;? extends Parent&gt; 指的是这个参数可以接受的List引用的泛型类型为Parent或者其子类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的道理，我们也可以创建协变的引用，让它可以接受的List引用的泛型类型为Parent或者子类,</span></span><br><span class="line">    List&lt;? extends Parent&gt; g2ListExt = <span class="keyword">null</span>;</span><br><span class="line">    g2ListExt = g3List;</span><br><span class="line">    g2ListExt = <span class="keyword">new</span> ArrayList&lt;Children&gt;();</span><br><span class="line">    g2ListExt = <span class="keyword">new</span> ArrayList&lt;Parent&gt;();</span><br><span class="line">    <span class="comment">//    g2ListExt = new ArrayList&lt;GrandParent&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是使用这个带协变泛型的引用，我们无法让具体的类型满足其参数要求</span></span><br><span class="line">    <span class="comment">// 下面均报错</span></span><br><span class="line">    <span class="comment">//    g2ListExt.add(new GrandParent());</span></span><br><span class="line">    <span class="comment">//    g2ListExt.add(new Parent());</span></span><br><span class="line">    <span class="comment">//    g2ListExt.add(new Children());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原因是如果Java允许了，那么就会造成潜在的错误；</span></span><br><span class="line">    List&lt;Children&gt; g3OnlyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    g2ListExt = g3OnlyList;</span><br><span class="line">    <span class="comment">// 这时候再看下一行，如果允许add 一个 Parent的对象，就代表什么呢？</span></span><br><span class="line">    <span class="comment">//    g2ListExt.add(new Parent());</span></span><br><span class="line">    <span class="comment">// g2ListExt可以被g3OnlyList 赋值，g3OnlyList是确定的Children类型。而g2ListExt</span></span><br><span class="line">    <span class="comment">// 是不确定的类型，所以直接往一个不确定的类型中 add 具体的类型肯定有问题；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了协变，java还有逆变，</span></span><br><span class="line">    <span class="comment">// 逆变和协变正好相反，允许的类型为Parent或者其父类</span></span><br><span class="line">    List&lt;? <span class="keyword">super</span> Parent&gt; g2ListSup = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//    g2ListSup = new ArrayList&lt;Children&gt;();</span></span><br><span class="line"></span><br><span class="line">    g2ListSup = <span class="keyword">new</span> ArrayList&lt;Parent&gt;();</span><br><span class="line">    g2ListSup = <span class="keyword">new</span> ArrayList&lt;GrandParent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是同样的原因，无法让具体的类型满足其参数需求，甚至是Object</span></span><br><span class="line">    <span class="comment">//    g2ListSup.add(new Parent());</span></span><br><span class="line">    <span class="comment">//    g2ListSup.add(new Children());</span></span><br><span class="line">    <span class="comment">//    g2ListSup.add(new GrandParent());</span></span><br><span class="line">    <span class="comment">//    g2ListSup.add(new Object());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论是协变还是逆变，都只能用在引用上，而不能在创建对象时使用其作为泛型参数；</span></span><br><span class="line">    <span class="comment">//    List&lt;? extends Parent&gt; g2ListExt11 = new ArrayList&lt;? extends Parent&gt;();</span></span><br><span class="line">    <span class="comment">//    List&lt;? super Parent&gt; g2ListSup11 = new ArrayList&lt;? super Parent&gt;();</span></span><br><span class="line">    <span class="comment">// 引用 可以指定一个宽泛的类型， 创建对象需要指定一个明确的类型</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协变语法如下，意思就是这个参数可以接受的List引用的泛型类型为Parent或者其子类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extMethod</span><span class="params">(List&lt;? extends Parent&gt; extParam)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">justG2Method</span><span class="params">(List&lt;Parent&gt; extParam)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">supMethod</span><span class="params">(List&lt;? <span class="keyword">super</span> Parent&gt; extParam)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>总结</li>
</ul>
<p>编译器检查并类型擦除</p>
<p>使用时的类型转换</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><blockquote>
<p>Iterator接口，实现这个接口就可以支持forEach循环</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><blockquote>
<p>Map最常用的实现类HashMap</p>
</blockquote>
<p>map不支持key重复，不是每种Map的实现都允许key或者value为null；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt;createMap(<span class="keyword">int</span> size) &#123;</span><br><span class="line">  Map&lt;String,String&gt; ret = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">    ret.put(<span class="string">"key"</span>+i, String.valueOf(Math.random()));</span><br><span class="line">    <span class="comment">// ret.remove("key0") </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历key和value</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt;entry: map.entrySet()) &#123;</span><br><span class="line">  sout(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历value</span></span><br><span class="line"><span class="keyword">for</span>(String value: map.values()) &#123;</span><br><span class="line">  sout(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历key</span></span><br><span class="line"><span class="keyword">for</span>(String key: map.keySet()) &#123;</span><br><span class="line">  sout(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自己写的类作为key，必须保证hashCode和equals方法都实现的妥妥的，而且一定是不可变的。如果作为key的对象是可变的；会出问题；</p>
<h2 id="6-注解"><a href="#6-注解" class="headerlink" title="6 注解"></a>6 注解</h2><blockquote>
<p>注解是元数据的搬运工</p>
<p>annotation，是给类，方法以及成员变量等元素增加元数据的方式，换言之，就是描述这些元素的。注解会被Java编译器处理；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Learnannotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="comment">// TODO 注解可以被用在哪个/哪些元素上；</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="comment">// @Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)  多个值的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 注解会被留存到哪阶段</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">// TODO 以上两个元素是每个注解都必须要有的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 定义一个自己的annotation，需要@interface, 实际上这个接口会继承Annotation接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PrimaryProperty &#123;</span><br><span class="line">  <span class="comment">// annotation 支持的类型有基本数据类型，Class，String， 枚举，其他注解，以上类型的数组</span></span><br><span class="line">  <span class="comment">//  比如下面分别定义了String， Class， int，String[], Override等</span></span><br><span class="line">  <span class="comment">// TODO 可以指定缺省值</span></span><br><span class="line">  <span class="function">String <span class="title">defaultValue</span><span class="params">()</span> <span class="keyword">default</span> "N/A"</span>; <span class="comment">// 缺省值是"N/A"</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Class <span class="title">targetClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">abc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  String[] defaultValues();</span><br><span class="line"></span><br><span class="line">  <span class="function">Override <span class="title">is</span><span class="params">()</span> <span class="keyword">default</span> @Override</span>; <span class="comment">// TODO 注解类型的缺省值；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Learnannotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUseAnnotation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object abc;</span><br><span class="line">  <span class="comment">// TODO 给 annotation里的属性赋值的方式</span></span><br><span class="line">  <span class="meta">@PrimaryProperty</span>(</span><br><span class="line">      abc = <span class="number">9</span>,</span><br><span class="line">      targetClass = TestUseAnnotation<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">      <span class="title">defaultValues</span> </span>= &#123;<span class="string">"aaa"</span>, <span class="string">"bbb"</span>&#125;,</span><br><span class="line">      defaultValue = <span class="string">"testbbb"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Learnannotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAnnotationApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Class clazz = TestUseAnnotation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : method.getAnnotations()) &#123;</span><br><span class="line">      System.out.println(annotation.annotationType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 读取到注解的内容，可以根据注解的内容，作为相应功能的配置，来实现相应的功能</span></span><br><span class="line">    PrimaryProperty primaryPropertyAnnotation = method.getAnnotation(PrimaryProperty<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">    System.out.println(primaryPropertyAnnotation.abc());</span><br><span class="line">    System.out.println(primaryPropertyAnnotation.defaultValue());</span><br><span class="line">    <span class="comment">// 输出数组</span></span><br><span class="line">    System.out.println(Arrays.asList(primaryPropertyAnnotation.defaultValues()));</span><br><span class="line">    System.out.println(primaryPropertyAnnotation.targetClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface com.denon.Learnannotation.PrimaryProperty</span></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// testbbb</span></span><br><span class="line"><span class="comment">// [aaa, bbb]</span></span><br><span class="line"><span class="comment">// class com.denon.Learnannotation.TestUseAnnotation</span></span><br></pre></td></tr></table></figure>

<h2 id="7-lambda"><a href="#7-lambda" class="headerlink" title="7. lambda"></a>7. lambda</h2><blockquote>
<p>lambda并不仅仅是语法糖，而是jvm做了一个指令的支持；</p>
</blockquote>
<p>Lambda VS 匿名类</p>
<p>lambda的理解和使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Learnlambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterateListLambdaAppMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    List&lt;String&gt; myList = addElementsToList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    String outside = <span class="string">"outside string"</span>;</span><br><span class="line">    <span class="comment">// TODO 匿名内部类版</span></span><br><span class="line">    myList.forEach(</span><br><span class="line">        <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            processString(outside + s);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambda的表达式必须能够符合接口中定义的抽象方法，从参数，到返回值，到异常，都必须匹配；</span></span><br><span class="line">    <span class="comment">// lambda完整版（参数）-&gt; &#123;code&#125;</span></span><br><span class="line">    <span class="comment">// lambda 可以有返回值，使用 return 语句就可以，当然我们这个接口没有，我们的lambda表达式也不能有</span></span><br><span class="line">    <span class="comment">// lambda 可以使用外部数据，看么看都和匿名内部类是一样的</span></span><br><span class="line">    myList.forEach(</span><br><span class="line">        (s) -&gt; &#123;</span><br><span class="line">          processString(outside + s);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// lambda 单参数，代码单行，简化版</span></span><br><span class="line">    myList.forEach(s -&gt; processString(outside + s));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambda 如果不实用外部变量，还有方法引用终极简化版</span></span><br><span class="line">    myList.forEach(IterateListLambdaAppMain::processString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambda 方法引用终极简化版：不是静态方法， 用引用也可以</span></span><br><span class="line">    IterateListLambdaAppMain inst = <span class="keyword">new</span> IterateListLambdaAppMain();</span><br><span class="line">    myList.forEach(inst::processStringInst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambda 也允许指定一个参数类型里的一个方法作为方法的引用</span></span><br><span class="line">    myList.forEach(String::toUpperCase);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    myMap.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">    myMap.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">    myMap.put(<span class="string">"k3"</span>, <span class="string">"v3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数也没问题，把参数用括号扩起来，用逗号分开</span></span><br><span class="line">    myMap.forEach((k, v) -&gt; processTwoStrings(k, v));</span><br><span class="line">    <span class="comment">// 省略也没问题</span></span><br><span class="line">    myMap.forEach(IterateListLambdaAppMain::processTwoStrings);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">addElementsToList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++) &#123;</span><br><span class="line">      list.add(<span class="string">"str"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processTwoStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"s1="</span> + str1 + <span class="string">",s2="</span> + str2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStringInst</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>lambda是函数式编程，很多语言中，函数（方法）是一等公民，无需依附于任何其他元素即可存在，并可以作为参数和返回值，而java中只有类是一等公民，方法必须依附于某个类，Java现在也支持lambda了；</p>
<h3 id="两种方式遍历List，Map"><a href="#两种方式遍历List，Map" class="headerlink" title="两种方式遍历List，Map"></a>两种方式遍历List，Map</h3><ul>
<li>lambda相当于是Java通过一顿后台操作帮我们生成了一个类来实现接口，并调用我们提供的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Learnlambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterateListLambdaWhereAppMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// action.accept 就直接跳到了我们的方法，其实中间Java 一顿后台操作帮我们生成了一个匿名类来实现接口，并调用我们提供的方法</span></span><br><span class="line">    List&lt;String&gt; myList = addElementsToList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    myList.forEach(IterateListLambdaWhereAppMain::processString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">addElementsToList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      list.add(<span class="string">"str"</span> + (i % <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="stream和collector"><a href="#stream和collector" class="headerlink" title="stream和collector"></a>stream和collector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Learnlambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseStreamAppMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    List&lt;String&gt; myList = addElementsToList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    System.out.println(<span class="string">"---lambda---"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambda 的奥义是使用lambda一个接着一个处理，不要停，一路处理下去，直到业务结束</span></span><br><span class="line">    <span class="comment">// 理性来说，lambda结构对计算化的有好的；</span></span><br><span class="line">    myList.stream()</span><br><span class="line">        .filter(s -&gt; s.length() &gt; <span class="number">4</span>)</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 当然也可以使用collector让数据重新生成一个List</span></span><br><span class="line">    System.out.println(<span class="string">"----使用collector-----"</span>);</span><br><span class="line">    List&lt;String&gt; longgerStrList =</span><br><span class="line">        myList.stream()</span><br><span class="line">            .filter(s -&gt; s.length() &gt; <span class="number">4</span>)</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    longgerStrList.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">addElementsToList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      list.add(<span class="string">"str"</span> + (i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="返回值和异常"><a href="#返回值和异常" class="headerlink" title="返回值和异常"></a>返回值和异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.Learnlambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnValue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    String ret = randomData(String::valueOf);</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">    String retException = randomDataWithExceptionHandling(String::valueOf);</span><br><span class="line">    System.out.println(retException);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 我有数据，你有代码吗</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomData</span><span class="params">(Function&lt;Object, String&gt; converter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> converter.apply(Math.random());</span><br><span class="line">  &#125;</span><br><span class="line">  ;</span><br><span class="line">  <span class="comment">// lambda如果有 checked exception异常，那么接口必须允许，在调用的地方，只要正常处理异常就可以了；</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomDataWithExceptionHandling</span><span class="params">(ExceptionLambda&lt;Object, String&gt; converter)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 正常的异常处理</span></span><br><span class="line">    <span class="keyword">return</span> converter.hasException(Math.random());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ExceptionLambda</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">R <span class="title">hasException</span><span class="params">(P p)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.18599344222267322</span></span><br><span class="line"><span class="number">0.18812708055607374</span></span><br></pre></td></tr></table></figure>

<p>理解lambda的精髓：让代码脱离类的束缚，这样就可以把代码传递给数据提供方，而不是只能把数据传递给代码，通过这种方法，达到链式的处理 数据，</p>
<p>java现在版本中lambda在最终的实现上其实也是使用类的，可以看到，我们在调用代码的时候，其实还是通过接口。知识java帮我们把如何用我们提供的lambda来实现这个接口的细节隐藏掉了，而且隐藏的很好</p>
<p>限制： lambda可以取代只有一个抽象方法的接口</p>
<p>lambda的使用： 缘分到了，感觉自然了，就用，缘分不到不强求；</p>
<h2 id="8-Java"><a href="#8-Java" class="headerlink" title="8. Java"></a>8. Java</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><h4 id="语法和基础"><a href="#语法和基础" class="headerlink" title="语法和基础"></a>语法和基础</h4><ul>
<li>数据类型</li>
<li>表达式，语句，代码块</li>
<li>面向对象：封装，继承和多态</li>
<li>线程和异常处理</li>
<li>标准类库</li>
</ul>
<h4 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h4><blockquote>
<p>完成一些标准的功能</p>
</blockquote>
<ul>
<li>jar包： 类库是以jar包的形式发布，jar包是Java中组织多个class文件的方式。其本质是一个zip压缩包，后缀名是jar</li>
<li>类库是以jar包发布的、可以完成某个功能的一个或者多个jar包</li>
</ul>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>Maven: 构建和打包，丰富的插件可以组成复杂的构建过程。</li>
<li>git： 源代码版本控制</li>
<li>IDE</li>
<li>jenkins： 自动化持续集成</li>
</ul>
<h5 id="值得学习的工具类库和框架类库"><a href="#值得学习的工具类库和框架类库" class="headerlink" title="值得学习的工具类库和框架类库"></a>值得学习的工具类库和框架类库</h5><p>工具类： util型类库，用来完成JDK自带的类库中没有提供的方便的通用的功能，比如concurrent包之前就是独立的类库出现的</p>
<ul>
<li>guava</li>
<li>apache common ， lang，io，common.  <a href="https://commons.apache.org" target="_blank" rel="noopener">https://commons.apache.org</a></li>
<li>测试 junit ，testng</li>
<li>日志: slf4j + logback</li>
<li>序列化： avro， protobuf</li>
<li>JSON处理： Jackson, Gson</li>
<li>http： apache http component, 网址为 <a href="http://hc.apache.org/httpclient-3.x/index.html" target="_blank" rel="noopener">http://hc.apache.org/httpclient-3.x/index.html</a></li>
</ul>
<p>框架类：框架类库要解决的一般是一个系统的复杂问题，框架型类库一般都有一套标准（比如接口，配置等）需要遵守，用起来不像工具型那样拿过来用一下就完事儿了，所以一般用某种框架的时候，都会说开发什么什么程序，比如，如果使用Spring框架，一般会说开发Spring程序/应用</p>
<ul>
<li>应用开发框架： Spring+Spring Boot</li>
<li>REST API： Swagger Codegen + Swagger UI + <a href="https://editor.swagger.io" target="_blank" rel="noopener">https://editor.swagger.io</a></li>
<li>网络框架： Netty</li>
<li>ORM框架： Hibernate，MyBatis/iBatis</li>
</ul>
<h4 id="底层和进阶"><a href="#底层和进阶" class="headerlink" title="底层和进阶"></a>底层和进阶</h4><h5 id="底层-内存相关"><a href="#底层-内存相关" class="headerlink" title="底层 - 内存相关"></a>底层 - 内存相关</h5><ul>
<li>内存堆（heap）和线程栈</li>
<li>JMM</li>
<li>GC（garbage collection）：GC log分析和GC调优</li>
</ul>
<h5 id="底层-JVM和Java规范相关"><a href="#底层-JVM和Java规范相关" class="headerlink" title="底层 - JVM和Java规范相关"></a>底层 - JVM和Java规范相关</h5><ul>
<li>JVM + java字节码</li>
<li>Class文件格式</li>
<li>Class Loader （很实用）</li>
</ul>
<h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><ul>
<li>多线程和线程安全</li>
<li>程序可读性</li>
<li>优化 （不要花过多的精力在过早的优化上）</li>
</ul>
<h4 id="超越代码：-能力"><a href="#超越代码：-能力" class="headerlink" title="超越代码： 能力"></a>超越代码： 能力</h4><ul>
<li>本能+直觉： 对问题的难度、复杂性和需要的时间有一个直觉的反应。能够快速且准确的判断问题的难点和可能出问题的地方</li>
<li>分解+架构：拿到一个问题的时候，可以将问题分解为某种编程语言/技术可以解决的子模块/功能</li>
<li>解决问题：任何工作中的问题。从需求分析到架构设计，从接口设计到代码实现，从文档到测试，从脑洞大开到靠谱创新，从内存使用到CPU占用，从bug可以重现到bug难以重现，从集成到联调，从数据到环境，从数据库到消息队列，从在线到离线，从开发到部署，从测试环境的问题到生产环境的问题，从单台机器的问题到集群分布式的问题，从上线到维护，从技术支持到hotfix，从性能到监控，从技术栈更新到系统完全重构，只有想不到，没有做不到。</li>
</ul>
<h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><blockquote>
<p>JRE相当于是游戏，JDK相当于游戏还有游戏编辑器，它有一套工具可以设计游戏。比如澄海三C是魔兽的地球编辑器，游戏编辑器编辑出来的地图。可以造一个自己小游戏。这些都是基于魔兽的。</p>
</blockquote>
<p>jdk是 java Development Kit；jre 是 java Runtime  environment，是运行java的环境；</p>
<blockquote>
<p>jre只管运行java，jre只有一个java命令，java自带的类库（类似String，Math这些）</p>
<p>jdk在此基础上（jre）增加了很多与开发相关的工具，jdk中包含了jre，而且还包含了很多和开发调试程序有关的工具；比如</p>
</blockquote>
<ul>
<li>javap</li>
</ul>
<blockquote>
<p>javap 是把class文件反编译的命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">cd</span> out/production/code/</span><br><span class="line">$&gt; javap com.xxx.xxx.SimpleServer</span><br><span class="line">Compiled from <span class="string">"SimpleServer.java"</span></span><br><span class="line">public class com.xxx.xxx.SimpleServer &#123;</span><br><span class="line">	xxx</span><br><span class="line">	xxx</span><br><span class="line">	static&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">$&gt; javap -v com.xxx.xxx.SimpleServer <span class="comment"># -v 即verbose 冗余，更详细的东西； 可以展示字节码级别的详细内容，</span></span><br></pre></td></tr></table></figure>

<p>可以通过学习java虚拟机/类加载器/字节码，对java底层运行机制有更深理解。还有基于jvm的scala语言，</p>
<ul>
<li>jar</li>
</ul>
<blockquote>
<p>jar用来打包的，把class文件打成一个jar包。方便我们去交换。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">cd</span> out/production/code/</span><br><span class="line">$&gt; <span class="built_in">pwd</span></span><br><span class="line">/Users/xxx/code/out/production/code</span><br><span class="line">$&gt; jar --create --file ../../../network.jar com/xxx/xxx/SimpleServer.class  com/xxx/xxx/SimpleClient.class</span><br><span class="line">$&gt; ls</span><br><span class="line">.idea code.iml command.txt network.jar out/ src/ </span><br><span class="line">$&gt; java -cp ./network.jar com.xxx.xxx.SimpleServer   <span class="comment">#class path 指定jar包路径   具体指定到jar包中的类名；</span></span><br><span class="line"><span class="comment"># Server端启动，在端口45632监听。。。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>jps</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; jps <span class="comment"># 列出所有java进程</span></span><br><span class="line">5730 Jps</span><br><span class="line">3849</span><br></pre></td></tr></table></figure>
</li>
<li><p>jmap 和 jstack</p>
</li>
</ul>
<blockquote>
<p>jmap , 查看java堆的，</p>
<p>jstack， 查看每个线程的栈；</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$&gt; jps</span><br><span class="line">5761 Jps</span><br><span class="line">3849</span><br><span class="line">5757 SimpleServer</span><br><span class="line">5758 Launcher</span><br><span class="line">5759 SimpleClient</span><br><span class="line">$&gt; jmap -histo 5759 <span class="comment"># 查看5759这个进程中有多少个对象，每种对象有多少个。</span></span><br><span class="line">num       <span class="comment">#instances       #bytes       class name (module)</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">1:         10926           2167440       [B (java.base@1.0.2)</span><br><span class="line">2:         1449            1070536       [I (java.base@11.0.2)</span><br><span class="line">3:         8724            279168        java.util.HashMap<span class="variable">$Node</span> (java.base@11.0.2)</span><br><span class="line">4:         8085            194040        java.lang.String(java.base@11.0.2)</span><br><span class="line"></span><br><span class="line">$&gt; jstack 5757 </span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br></pre></td></tr></table></figure>

<ul>
<li>jstat</li>
<li>jhat</li>
<li>Jvisualvm</li>
</ul>
<p>jdk中多了哪些东西，在开发java的时候一定要装jdk，不能装jre。只有那些只跑java的人才只需要装jre。</p>
<h3 id="Java平台"><a href="#Java平台" class="headerlink" title="Java平台"></a>Java平台</h3><h4 id="Java是什么：-语法之外"><a href="#Java是什么：-语法之外" class="headerlink" title="Java是什么： 语法之外"></a>Java是什么： 语法之外</h4><p>java的语法，写java的程序，但这并不是java的全部</p>
<p>符合java语法的源文件通过javac命令被编译成class文件，又可以通过不同操作系统平台下的java命令运行相同的class文件，得到相同的结果。在后面支撑着完成着一整套操作的系统才是完整的Java。</p>
<p>class文件也是java和的语言不一样的地方，所有的java程序的进程名字都是java，但是如果是一个C语言编写的程序，进程名字可以是程序本身决定的。而且C语言编写的程序，可以直接编译链接生成exe文件（Windows），可以直接运行。但是Java程序编译出来是class文件，运行还靠java命令。这一切的背后到底是什么？</p>
<h4 id="Java是什么：-字节码和class文件"><a href="#Java是什么：-字节码和class文件" class="headerlink" title="Java是什么： 字节码和class文件"></a>Java是什么： 字节码和class文件</h4><p>Bytecode: 字节码，类似于CPU的指令集，是Java程序跨平台的基础。字节码也是Java规范中的内容。</p>
<p>class文件： Java源文件可以生成class文件，class文件就是字节码组成的。只要有合适的编译器。别的语法也可以生成class文件，在JVM上运行。</p>
<p>执行字节码是Java虚拟机（JVM）直观的感受就是我们一直用的java命令。JVM是跨操作系统的，和平台无关的。所以这也就是为什么大家说java可以一次编写，到处运行（write once，run anywhere）</p>
<p>基于JVM（或者说字节码）的更多语言：Scala，Groovy，Kotlin</p>
<h4 id="Java是什么：-Java虚拟机（JVM）"><a href="#Java是什么：-Java虚拟机（JVM）" class="headerlink" title="Java是什么： Java虚拟机（JVM）"></a>Java是什么： Java虚拟机（JVM）</h4><blockquote>
<p>JVM Specification: Java虚拟机规范，核心功能是执行字节码，即Class文件的内容。我们一直启动的java命令，就是符合java虚拟机规范的；</p>
</blockquote>
<p>更多虚拟机： 既然JVM有一个规范，那么只要满足这个规范，就可以是Java虚拟机。Azul的Zulu就是一个Oracle之外的提供JDK/Java虚拟机的厂商，可以免费使用，商业版也比较便宜，支持所有主流操作系统。同样出自Azul的Zing虚拟机是业界公认性能最好的JVM虚拟机，最近阿里也开放了自己的JDK版本Dragonwell</p>
<p>在规范之外，每个厂商都可以在JDK的发行版里提供不同的工具；</p>
<h4 id="Java是什么：-规范"><a href="#Java是什么：-规范" class="headerlink" title="Java是什么： 规范"></a>Java是什么： 规范</h4><p>Java最核心的是规范，包括JVM的规范（其中就包含我们之前提过的JMM规范），包括字节码规范等。OpenJDK实现了这些规范，并在GPL V2协议下开源</p>
<p>Java是一个开放的平台，可以通过JSR（Java Specification Requests）的新式向JCP（Java Community Process）提出对Java规范的修改，修改包括Java的方方面面，可以小到一个语法糖，大到一个JVM的改动。比如我们之前提到的自动拆箱，concurrent包，annotation（新的语法和class文件格式），lambda（需要增加新的字节码指令）等都是JSR的方式推进，并增加到新版本的Java中的</p>
<p>正因为Java是一个开放的平台，所以才会生机勃勃；</p>
<h2 id="9-Maven"><a href="#9-Maven" class="headerlink" title="9. Maven"></a>9. Maven</h2><h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><ul>
<li>classpath：</li>
</ul>
<blockquote>
<p>classpath即类路径，它是Java命令在执行Java程序的时候，寻找class的路径。它可以是文件夹或者jar包的路径的组合。一般执行java命令的时候都会配以classpath参数，参数是这个程序用到的所有jar包路径组合；</p>
</blockquote>
<p>我们之前没有指定是因为java命令默认会把当前路径加入到classpath，而我们之前运行的HelloWorld程序没有使用别的jar包，所以不指定也没有问题； </p>
<h3 id="上古时代的做法"><a href="#上古时代的做法" class="headerlink" title="上古时代的做法"></a>上古时代的做法</h3><p>看例程： 使用guava包，将包加入IDE的项目中，运行时使用java命令的classpath参数传递jar包路径，注意不同操作系统下的分隔符；</p>
<p>问题： 发布jar包不方便，寻找jar包不方便，使用jar包不方便，编译打包自己的程序不方便，升级jar包不方便，jar包之间的依赖管理更是无法想象的困难和繁琐。</p>
<p>maven： 解决以上所有问题的利器，而且可以做的更多；</p>
<h3 id="jar包的仓库-Maven服务端"><a href="#jar包的仓库-Maven服务端" class="headerlink" title="jar包的仓库(Maven服务端)"></a>jar包的仓库(Maven服务端)</h3><p>maven有两部分，首先是服务器端，叫做maven repo，或者nexus server，它将所有的jar包放在一个仓库里</p>
<p>所有jar包都发布到这个仓库，需要用到某个jar包，就去这个仓库下载</p>
<p>仓库里每个jar包，都有唯一的id，这个id是由三部分组成的：group id（组织的名字，如com.google）， artifact id （简单理解为jar包的名字，如guava）和version</p>
<p>为了避免每次都从服务器下载artifact（jar包），maven会把下载好的artifact放在本地的文件夹，这个就叫做local repo；</p>
<h3 id="maven客户端"><a href="#maven客户端" class="headerlink" title="maven客户端"></a>maven客户端</h3><p>如果一个项目ChatRoom依赖某个jar包，比如guava，那么就把guava的id加入到自己的依赖里，maven客户端就可以通过id找到并使用guava了；</p>
<p>同时，maven的依赖是传递的，如果使用maven发布这个jar包到maven repo，maven还会记住ChatRoom的jar包依赖于guava，如果有别的项目依赖ChatRoom，那么它将自动依赖guava，无需再次声明。</p>
<h3 id="maven安装与配置"><a href="#maven安装与配置" class="headerlink" title="maven安装与配置"></a>maven安装与配置</h3><p>apache maven</p>
<p>测试maven安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>



<ul>
<li>Maven客户端配置（可选）</li>
</ul>
<p>maven repo的镜像</p>
<p>阿里云的maven repo镜像： <a href="https://yq.aliyun.com/articles/78124" target="_blank" rel="noopener">https://yq.aliyun.com/articles/78124</a></p>
<p>使用阿里云的镜像： 将项目下的settings.xml文件拷贝到home目录下的.m2文件夹下。（如果没有这个文件夹就尝试使用命令行创建）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ls -al ~/.m2</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   3 ruanhan  staff    96  3 23  2020 .</span><br><span class="line">drwxr-xr-x+ 98 ruanhan  staff  3136  8  7 18:55 ..</span><br><span class="line">drwxr-xr-x  41 ruanhan  staff  1312  5  8 15:20 repository</span><br></pre></td></tr></table></figure>



<ul>
<li>Intellij 的maven settings配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Build tools / Maven</span><br><span class="line">User settings file: override</span><br><span class="line">Local repository:  override</span><br></pre></td></tr></table></figure>



<ul>
<li>创建一个Maven项目</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -&gt; Maven -&gt; next -&gt; next</span><br></pre></td></tr></table></figure>

<p>src/main/java: 这个目录下面才是源代码</p>
<p>Cannot resolve plugin org.apache.maven.plugins:maven-compiler-plugin:3.1</p>
<p>Pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--描述自己的，描述依赖包的，都需要的三个属性，groupId artifactId version--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!--项目目录 jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myMavenPro<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>下载依赖</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">cd</span> myMavenPro</span><br><span class="line">$&gt; ls</span><br><span class="line">.idea code.iml pom.xml src target</span><br><span class="line">$&gt; mvn install -U</span><br><span class="line"></span><br><span class="line">ide打开pom.xml文件，右键选择 Maven -&gt; Reimport</span><br></pre></td></tr></table></figure>



<h3 id="Maven项目实战"><a href="#Maven项目实战" class="headerlink" title="Maven项目实战"></a>Maven项目实战</h3><blockquote>
<p>一个从pptx文件中抽取文件的小工具</p>
<p>Apache.poi</p>
</blockquote>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poi.apache.org/components/index.html</span><br></pre></td></tr></table></figure>

<p><img src="03.png" alt="image-20210807204936880"></p>
<p>查看类库必看的官方文档</p>
<p>cookbook， quick start，</p>
<h3 id="Maven常用命令和插件"><a href="#Maven常用命令和插件" class="headerlink" title="Maven常用命令和插件"></a>Maven常用命令和插件</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># maven构建中的几个主要的phase(逐步执行)：</span></span><br><span class="line">$&gt; compile <span class="comment"># 源文件编译成class文件</span></span><br><span class="line">$&gt;  <span class="built_in">test</span>  <span class="comment"># 执行测试代码</span></span><br><span class="line">$&gt;  package  <span class="comment"># 打成jar包</span></span><br><span class="line">$&gt;  install  <span class="comment"># 安装jar包到local repo，同时将源代码和 pom.xml也放在那里，以后若上传项目到Maven，也是pom.xml和jar包一起走的；</span></span><br><span class="line"></span><br><span class="line">$&gt; mvn clean install <span class="comment">#或者 </span></span><br><span class="line">$&gt; mvn clean install -U</span><br><span class="line"></span><br><span class="line">$&gt; mvn dependency:tree</span><br></pre></td></tr></table></figure>

<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件是什么：maven其实是一套框架，所有的具体任务都是插件完成的，除了核心的编译打包插件，还有非常多的别的目的的插件；</p>
<p>打出fatjar的插件；</p>
<h3 id="intellij"><a href="#intellij" class="headerlink" title="intellij"></a>intellij</h3><p>快捷键：</p>
<ul>
<li>Edit: Find:  Find In Path, Replace In Path, Find Usage</li>
<li>View: Recent Files</li>
<li>Navigate: Back, Forward, Last Edit Location, Next Edit Location, Implementations,Class…, File Structure</li>
<li>Code:Override Methods, Generate…, Reformat Code</li>
<li>Refactor: Rename, Extract Method</li>
</ul>
<p>插件</p>
<ul>
<li>Maven Help</li>
<li>Markdown support</li>
<li>Grep Console</li>
</ul>
<h2 id="10-线程"><a href="#10-线程" class="headerlink" title="10 线程"></a>10 线程</h2><h3 id="线程的执行"><a href="#线程的执行" class="headerlink" title="线程的执行"></a>线程的执行</h3><blockquote>
<p>线程其实就是执行一个入口方法，执行完毕就结束了，比如我们之前写的程序，都是使用一个线程执行main方法，执行完毕后，线程就结束了；</p>
<p>线程在执行方法的时候，每次遇到方法调用，都会给当前的线程栈增加一层。这一层里保存的，就是线程当前的执行状态，比如当前方法的局部变量的值，当前方法执行到哪里了等；</p>
<p>所以线程栈里的每一条，都是方法已经开始执行但是还没有结束的方法。没有结束时因为它代码还没执行完，或者是在等待其调用的方法执行完；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopALittle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printSlowly(<span class="string">"1234567..."</span>, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSlowly</span><span class="params">(String s, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch: s.toCharArray()) &#123;</span><br><span class="line">            Thread.sleep(i); <span class="comment">// 线程休眠</span></span><br><span class="line">            System.out.println(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sleep done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="debug线程"><a href="#debug线程" class="headerlink" title="debug线程"></a>debug线程</h3><blockquote>
<p>debug断点功能，让程序停住，学习idea查看进程里线程的数据，每个线程的线程栈是什么，</p>
<p>通过让方法执行结束，观察线程栈的变化</p>
</blockquote>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadApp</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEXT = <span class="string">"1234567890..."</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码是被线程执行的，任何代码都可以通过Thread.currentThread() 获取执行当前代码的线程</span></span><br><span class="line">    System.out.println(<span class="string">"程序开始，执行的线程名字叫做"</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="comment">// 改成2试试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 学习创建线程的方法</span></span><br><span class="line">      <span class="comment">// Runnable接口里的run 是线程执行的方法，执行完毕，线程就结束了</span></span><br><span class="line">      <span class="comment">// 理解代码是在线程里被执行的，同样的代码可以被多个线程执行</span></span><br><span class="line">      <span class="comment">// 暂停一下Java，看看有多少线程，每个线程的名字等信息</span></span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintStoryRunnable(TEXT, <span class="number">200</span> * i), <span class="string">"我的线程-"</span> + i);</span><br><span class="line">      <span class="comment">// 创建好线程之后，如果要启动线程，必须调用start方法，注意不是run方法</span></span><br><span class="line">      thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"启动线程结束，名字叫做"</span> + Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStoryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> interval;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintStoryRunnable</span><span class="params">(String text, <span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.text = text;</span><br><span class="line">      <span class="keyword">this</span>.interval = interval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行这段代码的线程名字叫做"</span> + Thread.currentThread().getName());</span><br><span class="line">        printSlowly(text, interval);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束"</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSlowly</span><span class="params">(String text, <span class="keyword">long</span> interval)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : text.toCharArray()) &#123;</span><br><span class="line">      Thread.sleep(interval);</span><br><span class="line">      System.out.println(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"sleep done"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程也是一个对象，执行完毕Runnable接口里的run 方法，线程就结束了</p>
<p>当一个进程里所有的线程都执行完毕了，一个进程就执行结束了</p>
<p>线程相当于是CPU，它从入口开始执行代码，一段代码可以被多个线程同时执行。可以通过Thread.currentThread() 获取执行当前代码的线程</p>
<p>代码就好像曲谱，线程就好像乐器，乐器可以演奏曲谱，多个乐器可以演奏相同的或者不同的曲谱；</p>
<h3 id="Java线程的状态"><a href="#Java线程的状态" class="headerlink" title="Java线程的状态"></a>Java线程的状态</h3><p><img src="04.png" alt="image-20210808234714544"></p>
<p>首先是初始状态（New），调用start方法之后就会在 运行（Running）和 就绪（Ready）之间转变。（运行即正在执行。就绪即线程可以执行，但操作系统决定先不执行，跟系统调度有关）</p>
<p>参考<code>java/lang/Thread/State</code> 1707-1806行</p>
<h3 id="守护线程和优先级属性"><a href="#守护线程和优先级属性" class="headerlink" title="守护线程和优先级属性"></a>守护线程和优先级属性</h3><p>守护线程： daemon thread，如果一个进程里没有线程，或者线程都是守护线程，那么进程就结束了；</p>
<ul>
<li>例子：只有守护线程，进程就结束了</li>
<li>例子： 可以设置线程的优先级，优先级的作用不能保证，这和线程的运行状态以及机器本身的运行状态有关，是不是守护线程都可以设置线程优先级  ；</li>
</ul>
<h3 id="线程的interrupt方法"><a href="#线程的interrupt方法" class="headerlink" title="线程的interrupt方法"></a>线程的interrupt方法</h3><p>线程的interrupt无法真的像这个方法的名字那样让线程中断</p>
<p>例程： 线程的stop方法可以让线程结束，但是这回带来很大的隐患，会造成程序状态的错误，比如锁没有释放等。不要在生产的代码里调用这个方法；</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>多线程版的修改数据</li>
<li>理解多线程版的结果：线程修改数据，人多手杂，一个线程在改，另一个线程也在改，读取当前值，修改为新的值，写入新的值这三个步骤并非是连续执行的，可能有别的线程的代码乱入，而且现代计算机的CPU都有缓存，让问题就更不可预测</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.learnThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadChaos</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DataHolder dataHolder = <span class="keyword">new</span> DataHolder();</span><br><span class="line">    <span class="comment">// 两个线程并发改 dataHolder,因为没有同步限制，导致结果的不可控</span></span><br><span class="line">    Thread increaseThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChangeData(-<span class="number">2</span>, Integer.MAX_VALUE, dataHolder));</span><br><span class="line">    Thread decreaseThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChangeData(<span class="number">2</span>, Integer.MAX_VALUE, dataHolder)); <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">"执行开始"</span>);</span><br><span class="line">    increaseThread.start();</span><br><span class="line">    decreaseThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    number += delta;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Number="</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步控制-synchronized"><a href="#同步控制-synchronized" class="headerlink" title="同步控制-synchronized"></a>同步控制-synchronized</h4><blockquote>
<p>synchronized 关键字用来修饰成员方法，代表这个方法对于同一个对象来说，同一时间只允许一个线程执行，别的线程如果也调用这个实例的这个方法，就需要等待已经在执行这个方法的线程执行完毕，才能进入方法执行；</p>
</blockquote>
<ul>
<li>看例子： 使用synchronized 解决问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.learnThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个synchronized 解决问题</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    number += delta;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Number="</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给一个方法加上synchronized 关键字的效果是，当有其他线程执行该方法的时候，此方法没法被其他线程执行；</p>
<p>线程会有自己的缓存，但有synchronized修饰的方法在释放之前会将 缓存的属性写进到 该对象的内存中，下一个其他线程在读取 属性时，也不是从缓存中读，而是从 该对象的内存中读取；</p>
<ul>
<li>看例子： 使用synchronized 修饰静态方法</li>
<li>看例子： 使用synchronized代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeSyncBlock</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 这里相当于锁 this， 而静态方法的synchronized 相当于锁 DataHolder.class</span></span><br><span class="line">    number += delta;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">changeStatic</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">  numberStatic += delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步控制-wait-notify"><a href="#同步控制-wait-notify" class="headerlink" title="同步控制 - wait notify"></a>同步控制 - wait notify</h4><blockquote>
<p>来自Object类里的方法</p>
<p>应用场景：当多个线程的互动，需要等待和被唤醒的时候，就可以考虑使用这个语法</p>
</blockquote>
<ul>
<li>例子： wait notify/notifyAll</li>
<li>例子：学习 lost  notification</li>
<li>知识点+注意点： synchronized 不是公平锁（会在等待队列中随机取一个，没有进行优先级排队算法）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.denon.waitNotify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotify</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Object locker = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">int</span> workingSec = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(</span><br><span class="line">              () -&gt; &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">": 线程开始工作..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                    sleepSec(workingSec);</span><br><span class="line">                    System.out.println(getName() + <span class="string">": 进入等待"</span>);</span><br><span class="line">                    <span class="comment">// wait 方法必须在进入相应对象的synchronized块中才能调用</span></span><br><span class="line">                    <span class="comment">// 执行wait方法之后，自动失去对象的monitor，也就是说别的线程可以进入这个对象synchronized代码块</span></span><br><span class="line">                    locker.wait();</span><br><span class="line">                    <span class="comment">// 被唤醒的线程，就相当于执行过了wait方法，开始向下执行</span></span><br><span class="line">                    <span class="comment">// 如果wait不是 synchronized 块中的最后一行，那么第一件事就是"排队"获取之前失去的monitor</span></span><br><span class="line">                    <span class="comment">// 排队加引号是因为synchronized是非公平的，也就是说，不是谁先等待谁就能先获得；</span></span><br><span class="line">                    System.out.println(getName() + <span class="string">":线程继续。。。"</span>);</span><br><span class="line">                    sleepSec(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(getName() + <span class="string">":结束"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">"工作线程"</span> + i)</span><br><span class="line">          .start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果notify/notifyAll在wait之前，会怎么样？</span></span><br><span class="line">    System.out.println(<span class="string">"-------------唤醒线程开始sleep---------------"</span>);</span><br><span class="line">    <span class="comment">// 如果执行notify的时候，线程还没有进入wait状态，那么notify是没有效果的</span></span><br><span class="line">    <span class="comment">// 先notify，后进入wait，就是所谓的lost notification问题，可能造成线程无法进行</span></span><br><span class="line">    <span class="comment">// 如果让唤醒的线程sleep的比worker短（sleep时间+1 变 -1，或者干脆不sleep）， 也就是先进行notify，那么就可能</span></span><br><span class="line">    <span class="comment">// 为什么说可能呢？因为 synchronized 还是阻碍了notify的执行，但是notify有机会在wait前执行了；</span></span><br><span class="line">    sleepSec(workingSec + <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"----------唤醒线程sleep结束---------------"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">      <span class="comment">// notify/notifyAll 方法必须在进入相应对象的synchronized 块中才能调用</span></span><br><span class="line">      System.out.println(<span class="string">"------------开始唤醒所有------------------"</span>);</span><br><span class="line">      locker.notifyAll();</span><br><span class="line">      <span class="comment">//      for (int i = 0; i &lt; threadCount; i++) &#123;</span></span><br><span class="line">      <span class="comment">//        System.out.println("---------开始逐个唤醒---------");</span></span><br><span class="line">      <span class="comment">//        locker.notify();</span></span><br><span class="line">      <span class="comment">//      &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleepSec</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(TimeUnit.SECONDS.toMillis(sec));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多线程经典模型-生产者消费者模型"><a href="#多线程经典模型-生产者消费者模型" class="headerlink" title="多线程经典模型-生产者消费者模型"></a>多线程经典模型-生产者消费者模型</h4><blockquote>
<p>生产者生产的任务一定能被消费，任何任务能被消费且只能被消费一次；</p>
</blockquote>
<blockquote>
<p>生产者消费者重点： 生产的任务不能被忽略或者多次消费；</p>
<p>使用List和wait notify实现生产者消费者；</p>
</blockquote>
<h4 id="多线程的思维转变"><a href="#多线程的思维转变" class="headerlink" title="多线程的思维转变"></a>多线程的思维转变</h4><blockquote>
<ol>
<li>程序随时可能停住，别的线程随时可能乱入任何代码；</li>
</ol>
</blockquote>
<h4 id="同步控制-join"><a href="#同步控制-join" class="headerlink" title="同步控制 - join"></a>同步控制 - join</h4><blockquote>
<p>wait this thread die；</p>
<p>让调用join的线程x 等着x线程执行结束，如果我是一个线程，我调用 aThread.join(超时时间)，那我会等在这个地方挂起。直到线程 aThread执行结束。这是join的用法</p>
</blockquote>
<ul>
<li>join方法</li>
<li>Thread的join方法</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote>
<p>一种死锁形成的条件： 在获取新的资源之前，没有释放之前获取的资源</p>
</blockquote>
<p>例子： 模拟死锁形成的条件</p>
<p>工具： 使用jstack 查看死锁信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; jstack -l 进程ID  <span class="comment"># -l long</span></span><br></pre></td></tr></table></figure>



<p>如何避免死锁： 按照顺序申请资源</p>
<p>也就是两个task 都按照一定的顺序申请，比如先申请 Input 再申请 Pointer。</p>
<p>不能一个task先申请Input，再申请Pointer，而另一个task先申请Pointer而后申请Input；</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p><img src="05.png" alt="image-20210809214956077"></p>
<p>ThreadLocal是一个类，有两个方法分别为 get ,set(value). 但是value不是放在ThreadLocal实例里面的，而是放在执行这段代码的thread里的，thread里面存有ThreadLocalMap的变量，key就是 ThreadLocal实例本身，value就是 ThreadLocal实例的get的value。</p>
<p>ThreadLocal一般用在跨类，跨方法的传递一些值。 在一些框架，底层的类中可能会用到，可以避免上层引用代码为了框架当数据的二传手；</p>
<h4 id="JMM和指令重排"><a href="#JMM和指令重排" class="headerlink" title="JMM和指令重排"></a>JMM和指令重排</h4><p>java memory Model：简称JMM，即java内存模型。可以简单认为是一套happens-before标准，规定了内存同步和缓存失效等节点，限制了指令重排；</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><blockquote>
<p> 有 volatile 修饰就会影响之前的指令重排 </p>
</blockquote>
<p>volatile 关键字强制每次都从主存获取变量数据，而不要用cpu的缓存。尽量让多线程的情况下读到相同的副本。</p>
<p>JMM 是java内涵之一，java字节码（java byte code）使得Java在指令层面有了统一的标准，JMM更让Java在执行优化层面又了统一的标准。让各大厂商可以根据操作系统和硬件，在执行优化上放飞自我。</p>
<h3 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h3><blockquote>
<p>开始由Doug lea 博士开发的，先提供了一个独立于JDK的concurrent包，后来主导了JSR166，将这个包纳入到了JDK1.5中，造福广大java开发者</p>
<p>JSR是java specification requests的简称，是java演进的标准，每个java版本的功能都是以jsr的形式推进的；</p>
</blockquote>
<h4 id="concurrent包基本原理"><a href="#concurrent包基本原理" class="headerlink" title="concurrent包基本原理"></a>concurrent包基本原理</h4><p>使用CAS，避免内核调用。CAS是Compare And Swap的缩写，CAS命令是现代CPU都支持的一种指令。这个指令对一个数据的写操作，需要三个操作数：<code>内存里的值的地址</code>，<code>旧的值</code>，<code>新的值</code>。只有当 <code>内存里的值 == 旧的值</code>，内存里的值才会被设置为新的值。而且这个操作是原子操作，不会被CPU执行调度打断；</p>
<p>源码： park和unpark</p>
<p>理解CAS如何实现锁的功能和自旋</p>
<p>有了新的锁的机制，就可以在同步的道路上越走越宽；</p>
<h4 id="Atomic类族"><a href="#Atomic类族" class="headerlink" title="Atomic类族"></a>Atomic类族</h4><blockquote>
<p>每种基本数据类型对应的Atomic类，以及引用类型的Atomic类</p>
</blockquote>
<p>AtomicLong的线程安全性和源代码</p>
<h4 id="concurrent包中的锁"><a href="#concurrent包中的锁" class="headerlink" title="concurrent包中的锁"></a>concurrent包中的锁</h4><p>Lock如何对标synchronized</p>
<p>Lock如何对标wait/notify</p>
<p>CountdownLatch如何替代Thread的join</p>
<h4 id="concurrent包中的线程池"><a href="#concurrent包中的线程池" class="headerlink" title="concurrent包中的线程池"></a>concurrent包中的线程池</h4><blockquote>
<p>创建100个线程，用一个工作队列存储来管理起来。避免重复创建销毁线程</p>
</blockquote>
<h2 id="11-程序设计"><a href="#11-程序设计" class="headerlink" title="11. 程序设计"></a>11. 程序设计</h2><p>理解要解决的问题： 一开始提键盘就写代码没问题，开始就是要多写代码培养感觉，慢慢的要开始思索，先把问题想清楚，再写代码。</p>
<p>将问题分解为模块： 理解了问题，就可以在大脑里构建这个问题的解决方案了。使用不同的模块，来解决问题，让不同的模块负责不同的功能</p>
<p>高内聚，低耦合：模块内部高内聚，聚焦解决模块所要解决的问题；模块与模块之间要低耦合，交互的接口要简单清晰，避免模块内部的细节出现在模块之间的交互中；（尽量不要把用到的哪些类库/接口暴露给别的模块，尽量用最少的 最基础的类，能用jdk自带的类做交互标准就不要用外部第三方的类做交互。）</p>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2021/07/31/java%E5%9F%BA%E7%A1%80/>http://yoursite.com/2021/07/31/java%E5%9F%BA%E7%A1%80/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-08-09T22:55:03+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Aug 9, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/guide/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>guide</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2021/07/31/java%E5%9F%BA%E7%A1%80/&title=java基础 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2021/07/31/java%E5%9F%BA%E7%A1%80/&title=java基础 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2021/07/31/java%E5%9F%BA%E7%A1%80/&title=java基础 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
            
              <a class='next' href='/2021/07/02/product/'>
                <p class='title'>product<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'></p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'java基础',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-快速开始"><span class="toc-text">1. 快速开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译"><span class="toc-text">编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#idea安装"><span class="toc-text">idea安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O"><span class="toc-text">I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环"><span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件与IO"><span class="toc-text">文件与IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件"><span class="toc-text">文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中支持的三种IO"><span class="toc-text">Java中支持的三种IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写文件内容小程序"><span class="toc-text">写文件内容小程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读文件"><span class="toc-text">读文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络IO"><span class="toc-text">网络IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#爬虫"><span class="toc-text">爬虫</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-OO"><span class="toc-text">2. OO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建类"><span class="toc-text">创建类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的实例-对象"><span class="toc-text">类的实例&#x2F;对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用类型"><span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用和类以及对象的关系"><span class="toc-text">引用和类以及对象的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-text">null</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#像自定义类型一样使用类"><span class="toc-text">像自定义类型一样使用类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态变量-类变量"><span class="toc-text">静态变量&#x2F;类变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包与类访问符"><span class="toc-text">包与类访问符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#import"><span class="toc-text">import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性访问修饰符"><span class="toc-text">属性访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public"><span class="toc-text">public</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#private"><span class="toc-text">private</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#protected"><span class="toc-text">protected</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final"><span class="toc-text">final</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#debug"><span class="toc-text">debug</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Evaluate"><span class="toc-text">Evaluate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#condition"><span class="toc-text">condition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#返回值"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数"><span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数与返回值是怎么传递的"><span class="toc-text">参数与返回值是怎么传递的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法签名与重载"><span class="toc-text">方法签名与重载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法重载-overload"><span class="toc-text">方法重载(overload)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重载的参数匹配规则"><span class="toc-text">重载的参数匹配规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法：构造实例的方法"><span class="toc-text">构造方法：构造实例的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#构造方法的重载和互相调用"><span class="toc-text">构造方法的重载和互相调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法"><span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#静态方法的重载"><span class="toc-text">静态方法的重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#静态代码块"><span class="toc-text">静态代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的对象自己做事情"><span class="toc-text">类的对象自己做事情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#把操作成员变量的代码放在类里"><span class="toc-text">把操作成员变量的代码放在类里</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String类"><span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder"><span class="toc-text">StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System"><span class="toc-text">System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#子类对象藏着一个父类对象"><span class="toc-text">子类对象藏着一个父类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖：子类想要一点不一样"><span class="toc-text">覆盖：子类想要一点不一样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super-和父类对象沟通的桥梁"><span class="toc-text">super: 和父类对象沟通的桥梁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super：调用父类的构造方法"><span class="toc-text">super：调用父类的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#父类和子类的引用赋值关系"><span class="toc-text">父类和子类的引用赋值关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法继承"><span class="toc-text">静态方法继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多态里更多的语法点"><span class="toc-text">多态里更多的语法点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载总结"><span class="toc-text">重载总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#万类之组：Object类"><span class="toc-text">万类之组：Object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class类"><span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反射能做到，正常写做不到"><span class="toc-text">反射能做到，正常写做不到</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface"><span class="toc-text">interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Abstract-抽象类：-接口和类的混合体"><span class="toc-text">Abstract 抽象类： 接口和类的混合体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有方法代码的接口"><span class="toc-text">有方法代码的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口内的代码"><span class="toc-text">接口内的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态内部类"><span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员内部类"><span class="toc-text">成员内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-异常"><span class="toc-text">3. 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常的继承关系分类"><span class="toc-text">异常的继承关系分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抛出异常的语法"><span class="toc-text">抛出异常的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java异常的传递"><span class="toc-text">Java异常的传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常"><span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trycatchfinally"><span class="toc-text">trycatchfinally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动回收资源的try语句"><span class="toc-text">自动回收资源的try语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的常见异常"><span class="toc-text">Java中的常见异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Collection"><span class="toc-text">4.Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装箱和拆箱"><span class="toc-text">装箱和拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本类型的自动装箱和拆箱"><span class="toc-text">基本类型的自动装箱和拆箱</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-泛型"><span class="toc-text">5. 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#让一个List存储多个String对象"><span class="toc-text">让一个List存储多个String对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#让一个List里只有String"><span class="toc-text">让一个List里只有String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决问题：-让List中只有一种类型的元素，使用时不用强制类型转换"><span class="toc-text">解决问题： 让List中只有一种类型的元素，使用时不用强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有界类型"><span class="toc-text">有界类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协变和逆变"><span class="toc-text">协变和逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator"><span class="toc-text">Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-注解"><span class="toc-text">6 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-lambda"><span class="toc-text">7. lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两种方式遍历List，Map"><span class="toc-text">两种方式遍历List，Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream和collector"><span class="toc-text">stream和collector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回值和异常"><span class="toc-text">返回值和异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Java"><span class="toc-text">8. Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编程语言"><span class="toc-text">编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语法和基础"><span class="toc-text">语法和基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类库"><span class="toc-text">类库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工具"><span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#值得学习的工具类库和框架类库"><span class="toc-text">值得学习的工具类库和框架类库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#底层和进阶"><span class="toc-text">底层和进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#底层-内存相关"><span class="toc-text">底层 - 内存相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#底层-JVM和Java规范相关"><span class="toc-text">底层 - JVM和Java规范相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进阶"><span class="toc-text">进阶</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#超越代码：-能力"><span class="toc-text">超越代码： 能力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-和-JRE"><span class="toc-text">JDK 和 JRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java平台"><span class="toc-text">Java平台</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java是什么：-语法之外"><span class="toc-text">Java是什么： 语法之外</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java是什么：-字节码和class文件"><span class="toc-text">Java是什么： 字节码和class文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java是什么：-Java虚拟机（JVM）"><span class="toc-text">Java是什么： Java虚拟机（JVM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java是什么：-规范"><span class="toc-text">Java是什么： 规范</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Maven"><span class="toc-text">9. Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#classpath"><span class="toc-text">classpath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上古时代的做法"><span class="toc-text">上古时代的做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jar包的仓库-Maven服务端"><span class="toc-text">jar包的仓库(Maven服务端)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maven客户端"><span class="toc-text">maven客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maven安装与配置"><span class="toc-text">maven安装与配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven项目实战"><span class="toc-text">Maven项目实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven常用命令和插件"><span class="toc-text">Maven常用命令和插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#命令"><span class="toc-text">命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插件"><span class="toc-text">插件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intellij"><span class="toc-text">intellij</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-线程"><span class="toc-text">10 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的执行"><span class="toc-text">线程的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#debug线程"><span class="toc-text">debug线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程"><span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java线程的状态"><span class="toc-text">Java线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程和优先级属性"><span class="toc-text">守护线程和优先级属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的interrupt方法"><span class="toc-text">线程的interrupt方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步控制-synchronized"><span class="toc-text">同步控制-synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步控制-wait-notify"><span class="toc-text">同步控制 - wait notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程经典模型-生产者消费者模型"><span class="toc-text">多线程经典模型-生产者消费者模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程的思维转变"><span class="toc-text">多线程的思维转变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步控制-join"><span class="toc-text">同步控制 - join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM和指令重排"><span class="toc-text">JMM和指令重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrent包"><span class="toc-text">concurrent包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#concurrent包基本原理"><span class="toc-text">concurrent包基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Atomic类族"><span class="toc-text">Atomic类族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#concurrent包中的锁"><span class="toc-text">concurrent包中的锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#concurrent包中的线程池"><span class="toc-text">concurrent包中的线程池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-程序设计"><span class="toc-text">11. 程序设计</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
