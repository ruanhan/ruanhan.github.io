<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>go1 - Hexo</title>
  
    <meta name="keywords" content="doc">
  
  
    <meta name="description" content="go语言语法">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2021/03/09/go1/">
      go1
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/go/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>go</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Mar 9, 2021</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="1-编译型语言"><a href="#1-编译型语言" class="headerlink" title="1. 编译型语言"></a>1. 编译型语言</h2><p>Go 语言是一门编译语言</p>
<ul>
<li>在运行程序之前，GO首先使用编译器把代码编译成机器可以识别的1和0</li>
<li>它会把代码编译成一个可执行文件，在编译的过程中，编译器能捕获一些错误；</li>
</ul>
<p>解释型语言</p>
<ul>
<li>python，js等都是使用解释器，随着程序运行，一个语句一个语句进行翻译，但也这意味着bug可能就潜伏在你还没测试过的路径上。这些就是解释型语言；</li>
</ul>
<h2 id="2-install-go"><a href="#2-install-go" class="headerlink" title="2. install go"></a>2. install go</h2><p>go 代理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/go <span class="comment"># go环境 编译器路径</span></span><br><span class="line">$&gt; <span class="built_in">cd</span> go/bin &amp;&amp; ls</span><br><span class="line">$&gt; go     <span class="comment"># go语言编译环境 # 需要将这个路径配置到环境变量中  /usr/local/go/bin/go</span></span><br><span class="line">$&gt; gofmt</span><br><span class="line">$&gt; vim ~/.bashrc</span><br><span class="line"><span class="comment">#编辑之后</span></span><br><span class="line">$&gt; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置go语言路径</span></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go <span class="comment"># 源码包所在路径</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/go  <span class="comment"># go开发者 go的项目默认路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go env <span class="comment"># 查看配置</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on <span class="comment"># 修改go env</span></span><br></pre></td></tr></table></figure>



<h2 id="3-const-var"><a href="#3-const-var" class="headerlink" title="3. const var"></a>3. const var</h2><p>常量与变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> distance, speed = <span class="number">56</span>, <span class="number">108</span></span><br><span class="line"><span class="keyword">const</span> hours, minutes = <span class="number">24</span>, <span class="number">60</span></span><br></pre></td></tr></table></figure>



<h3 id="3-1-短声明"><a href="#3-1-短声明" class="headerlink" title="3.1 短声明"></a>3.1 短声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种声明效果一样</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line">count:= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短声明可以在无法使用var的地方使用</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> count= <span class="number">10</span>; count&gt;<span class="number">0</span>; count-- &#123;</span><br><span class="line">  fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> count:=<span class="number">10</span>; count&gt;<span class="number">0</span>; count-- &#123;</span><br><span class="line">  fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num:=rand.Intn(<span class="number">3</span>);num==<span class="number">0</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> num:=rand.Intn(<span class="number">10</span>); num&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Printls(<span class="string">"1"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>,<span class="number">3</span>:</span><br><span class="line">  	fmt.Printls(<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>短声明不能用来声明 package作用域的变量</p>
<ul>
<li>era变量在main函数外声明的<ul>
<li>它拥有package作用域</li>
<li>如果main package有多个函数，那么era对它们都可见</li>
<li>package作用域的变量不能用短声明</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> era = <span class="string">"AD"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  year := <span class="number">2018</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下3个等价</span></span><br><span class="line">age = age + <span class="number">1</span></span><br><span class="line">age += <span class="number">1</span></span><br><span class="line">age++</span><br><span class="line">++age <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-逻辑运算符"><a href="#4-1-逻辑运算符" class="headerlink" title="4.1 逻辑运算符"></a>4.1 逻辑运算符</h3><p>|| 或</p>
<p> &amp;&amp; 与</p>
<p>！ 可以把true 变为 false，反之亦然</p>
<h2 id="5-包"><a href="#5-包" class="headerlink" title="5. 包"></a>5. 包</h2><p>引用多个包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> number = rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">	fmt.Println(number)</span><br><span class="line"></span><br><span class="line">	number = rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">	fmt.Println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-包路径管理"><a href="#5-1-包路径管理" class="headerlink" title="5.1 包路径管理"></a>5.1 包路径管理</h3><p>把项目建在 GOPATH的src目录下；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"golangStudy/00module/lib1"</span> <span class="comment">// 路径需要写全 ，此路径针基于 gopath下的src 往下查找的</span></span><br><span class="line">	<span class="string">"golangStudy/00module/lib2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lib1.Lib1Test1()</span><br><span class="line">	lib2.Lib2Test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-匿名导包"><a href="#5-2-匿名导包" class="headerlink" title="5.2 匿名导包"></a>5.2 匿名导包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"_lib1"</span> <span class="comment">// 添加下划线，某个场景只需要执行该包 init方法的时候</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-取别名"><a href="#5-3-取别名" class="headerlink" title="5.3 取别名"></a>5.3 取别名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mylib2 <span class="string">"lib2"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-Go-modules"><a href="#5-4-Go-modules" class="headerlink" title="5.4 Go modules"></a>5.4 Go modules</h3><p>Go modules 是go语言的依赖解决方案，发布于Go1.11， 成长于Go1.12，正式于Go1.14 推荐在生产上使用</p>
<p>Go modules解决Go1.11 前的几个常见争议问题</p>
<ol>
<li>GO语言长久以来的依赖管理问题</li>
<li>淘汰 现有的GOPATH的使用模式</li>
<li>统一社区中的其它的依赖管理工具（提供迁移功能）</li>
</ol>
<p><strong>GOPATH</strong>的工作模式</p>
<p>Go modules的目的之一就是淘汰GOPATH；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go env</span><br><span class="line">$&gt; GOPATH=Users/xxx/go</span><br><span class="line">$&gt; <span class="built_in">cd</span> <span class="variable">$GOPATH</span></span><br></pre></td></tr></table></figure>

<p><strong>GOPATH</strong>的弊端</p>
<ol>
<li>无版本控制概念， <code>go get -u  github.com/xxx/xxx</code> 无法指定版本</li>
<li>无法同步一致第三方版本号</li>
<li>无法指定当前项目引用的第三方版本号</li>
</ol>
<h4 id="5-4-1-Go-mod-命令"><a href="#5-4-1-Go-mod-命令" class="headerlink" title="5.4.1 Go mod 命令"></a>5.4.1 Go mod 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go mode init <span class="comment"># 生成 go.mod</span></span><br><span class="line">go mode download <span class="comment"># 下载go.mod 文件中指明的所有依赖</span></span><br><span class="line">go mode tidy <span class="comment"># 整理现有的依赖</span></span><br><span class="line">go mode graph <span class="comment"># 查看现有的依赖结构</span></span><br><span class="line">go mode edit <span class="comment"># 编辑 go.mod 文件</span></span><br><span class="line">go mode vendor <span class="comment"># 导出项目所有的依赖到vendor</span></span><br><span class="line">go mode verify <span class="comment"># 校验一个模块是否被篡改过</span></span><br><span class="line">go mode why <span class="comment"># 查看为什么需要依赖某模块</span></span><br></pre></td></tr></table></figure>



<h4 id="5-4-2-Go-mod环境变量"><a href="#5-4-2-Go-mod环境变量" class="headerlink" title="5.4.2 Go mod环境变量"></a>5.4.2 Go mod环境变量</h4><p>GO111MODULE</p>
<p>go提供 GO111MODULE 作为go modules的开关；其允许设置以下参数</p>
<ul>
<li>auto 只要项目包含了go.mod文件的话启用Go modules，</li>
<li>on 启用Go modules，推荐设置</li>
<li>off 禁用Go modules，不推荐设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 GO111MODULE</span></span><br><span class="line">go env -w GO111MODULE=<span class="string">"on"</span></span><br></pre></td></tr></table></figure>



<p>GOPROXY</p>
<p>这个环境变量主要是用于设置Go模块代理（Go module proxy），其作用是用于使Go在后续拉取模块版本时直接通过镜像站点来快速拉取</p>
<p>代理</p>
<ul>
<li>阿里云 <code>https://mirrors.aliyun.com/goproxy</code></li>
<li>七牛云 <code>https://goproxy.io,direct</code></li>
</ul>
<p>GOSUMDB</p>
<p>它的值是一个Go checksum database， 用于在拉取模块版本时，保证拉去的模块版本数据未经过篡改，若发现不一致，将会立即中止；</p>
<p>GOPARVATE</p>
<p>私有仓库，设置了GOPARVATE的话，就不再需要去GOPROXY上去下载，也不需要从GOSUMDB上去校验了</p>
<p><code>go env -w GOPRIVATE=&quot;*.example.com&quot;</code></p>
<h4 id="5-4-3-go-mod-初始化项"><a href="#5-4-3-go-mod-初始化项" class="headerlink" title="5.4.3 go mod  初始化项"></a>5.4.3 go mod  初始化项</h4><p>任意文件夹创建一个项目（不要求在 $GOPATH/src）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mkdir modules_test</span><br><span class="line">$&gt; <span class="built_in">cd</span> modules_test &amp;&amp; go mod init github.com/orgs/TenonMortise/modules_test</span><br><span class="line">$&gt; go get github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_github.com/<span class="keyword">go</span>-sql-driver/mysql</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go mod模式中 包都下载到了  $GOPATH/pkg  中</p>
<p><strong>在该项目编写源代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动下载</span></span><br><span class="line">go get github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure>

<p><strong>go.sum</strong></p>
<p>作用： 罗列当前项目直接或间接的依赖所有模块版本，保证今后项目以来的版本不会被覆盖</p>
<p>h1:hash 表示整体项目的zip文件打开之后的全部文件的校验和生成的hash， 如果不存在，可能表示依赖的库可能用不上；</p>
<p>xxx/go.mod  h1:hash.  Go.mod文件做的hash</p>
<h4 id="5-4-4-修改项目模块的版本依赖关系"><a href="#5-4-4-修改项目模块的版本依赖关系" class="headerlink" title="5.4.4 修改项目模块的版本依赖关系"></a>5.4.4 修改项目模块的版本依赖关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go mod edit -replace=zinx@v0.0.0-xxx=zin@v1.0.0-xxx</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go.mod 会多一行replace语句</span></span><br><span class="line">replace zin -replace=zinx@v0.0.0-xxx=&gt;zin@v1.0.0-xxx</span><br></pre></td></tr></table></figure>



<h2 id="6-循环-分支"><a href="#6-循环-分支" class="headerlink" title="6 循环 分支"></a>6 循环 分支</h2><h3 id="6-1-Boolean类型"><a href="#6-1-Boolean类型" class="headerlink" title="6.1 Boolean类型"></a>6.1 Boolean类型</h3><p>true 和false</p>
<p>go中，” “ 空串不会自动转为false </p>
<h3 id="6-2-strings-Contains"><a href="#6-2-strings-Contains" class="headerlink" title="6.2 strings.Contains"></a>6.2 strings.Contains</h3><p>来自strings包的Contains函数可以判断某个字符串是否包含另外要给字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"you find yourself in a dimlu lit cavern"</span>)</span><br><span class="line">	<span class="keyword">var</span> command = <span class="string">"walk outside"</span></span><br><span class="line">	<span class="keyword">var</span> exit = strings.Contains(command, <span class="string">"outside"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"you leave the cave: "</span>, exit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-compare"><a href="#6-3-compare" class="headerlink" title="6.3 compare"></a>6.3 compare</h3><p>如果比较两个值，得到的结果也是 true 或false</p>
<p>比较运算符：</p>
<p><code>== &lt;= &lt; != &gt;= &gt;</code></p>
<h3 id="6-4-if"><a href="#6-4-if" class="headerlink" title="6.4 if"></a>6.4 if</h3><p>判断条件不加括号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> command == <span class="string">"alex"</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> command == <span class="string">"let"</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-6-swtch"><a href="#6-6-swtch" class="headerlink" title="6.6 swtch"></a>6.6 swtch</h3><p>条件不加括号，不需要break关键字</p>
<p>还有一个fallthrough关键字，它用来执行下一个case的body部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">"alex"</span></span><br><span class="line"><span class="keyword">switch</span> command &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"gi"</span>:</span><br><span class="line">  	..</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"go"</span>,<span class="string">"run"</span>:</span><br><span class="line">  	..</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> room = <span class="string">"cave"</span></span><br><span class="line"><span class="keyword">switch</span> room &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"cave"</span>:</span><br><span class="line">    fmt.Printls(<span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"go"</span>,<span class="string">"run"</span>:</span><br><span class="line">  	fmt.Printls(<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	..</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 1，2</span></span><br></pre></td></tr></table></figure>



<h3 id="6-7-循环"><a href="#6-7-循环" class="headerlink" title="6.7 循环"></a>6.7 循环</h3><p>for关键字让代码重复执行</p>
<p>for后边没有根条件，那就是无限循环</p>
<ul>
<li>可以使用break跳出循环</li>
</ul>
<p><strong>遍历数组</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numbers := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i, num := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">		fmt.Println(i, num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-8-变量的作用域"><a href="#6-8-变量的作用域" class="headerlink" title="6.8 变量的作用域"></a>6.8 变量的作用域</h3><p>当变量被声明以后，它就进入了作用域</p>
<ul>
<li>只要变量在作用域内，你就可以访问它</li>
<li>否则，访问它会报错的</li>
</ul>
<p>变量声明的位置，决定了它的作用域</p>
<p>作用域的好处？</p>
<ul>
<li>可以在不通的作用域内使用相同的变量名</li>
</ul>
<p>在Go里面， 作用域的范围就是{}之间的部分</p>
<h2 id="7-数据类型"><a href="#7-数据类型" class="headerlink" title="7. 数据类型"></a>7. 数据类型</h2><h3 id="7-1-声明浮点型变量"><a href="#7-1-声明浮点型变量" class="headerlink" title="7.1 声明浮点型变量"></a>7.1 声明浮点型变量</h3><p>下面这三个语句的效果是一样的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">days := <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">var</span> days = <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">var</span> days <span class="keyword">float64</span> = <span class="number">365.2425</span></span><br></pre></td></tr></table></figure>

<p>只要数字含有小数部分，那么它的类型就是float64</p>
<p>如果你使用一个整数来初始化某个变量，那么你必须指定它的类型为float64，否则它就是一个整数类型</p>
<h3 id="7-2-单精度浮点数类型"><a href="#7-2-单精度浮点数类型" class="headerlink" title="7.2 单精度浮点数类型"></a>7.2 单精度浮点数类型</h3><p>Go语言有两种浮点数类型</p>
<p>默认是float64</p>
<ul>
<li>64位的浮点类型</li>
<li>占用8字节内存</li>
<li>某些编程语言把这种类型叫做double（双精度）</li>
</ul>
<p>float32</p>
<ul>
<li>占用4字节内存</li>
<li>精度比float64低</li>
<li>有时叫做单精度类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi64 = math.Pi</span><br><span class="line"><span class="keyword">var</span> pi32 <span class="keyword">float32</span> = math.Pi</span><br><span class="line"></span><br><span class="line">fmt.Println(pi64)</span><br><span class="line">fmt.Println(pi32)</span><br></pre></td></tr></table></figure>

<h3 id="7-3-单双精度的使用场景"><a href="#7-3-单双精度的使用场景" class="headerlink" title="7.3 单双精度的使用场景"></a>7.3 单双精度的使用场景</h3><ul>
<li>当处理大量数据时，例如3D游戏中的数千个顶点，使用float32牺牲精度来节省内存是很有意义的；</li>
<li>math包里面的函数操作的都是float64类型，所以应该首选使用float64，除非你有足够的理由不去使用它；</li>
</ul>
<h3 id="7-4-零值"><a href="#7-4-零值" class="headerlink" title="7.4 零值"></a>7.4 零值</h3><p>Go里面每个类型都有一个默认值，称作零值</p>
<p>当你声明却不对它进行初始化的时候，它的值就是零值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price <span class="keyword">float64</span></span><br><span class="line">fmt.Println(price)</span><br><span class="line"></span><br><span class="line">price := <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<h3 id="7-5-显示浮点类型"><a href="#7-5-显示浮点类型" class="headerlink" title="7.5 显示浮点类型"></a>7.5 显示浮点类型</h3><ul>
<li>使用Print或Println打印浮点类型的时候，默认的行为是尽可能的多显示几位小数</li>
<li>结合%f格式显示小数的位置</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">third := <span class="number">1.0</span>/<span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%f\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%.3f\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%4.2f\n"</span>, third)</span><br></pre></td></tr></table></figure>

<p>%4.2f</p>
<p>%4 标识宽度</p>
<p>2f 表示precision</p>
<ul>
<li>宽度： 会显示出的最少字符个数（包括小数点和小数）<ul>
<li>如果宽度大于数字的个数，那么左边会填充空格</li>
<li>如果没指定宽度，那么就按实际的位数进行显示</li>
</ul>
</li>
<li>精度： 小数点后边显示的位数</li>
</ul>
<h3 id="7-6-整数类型"><a href="#7-6-整数类型" class="headerlink" title="7.6 整数类型"></a>7.6 整数类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> year <span class="keyword">int</span> = <span class="number">2018</span>  <span class="comment">// 常用整型</span></span><br><span class="line"><span class="keyword">var</span> month <span class="keyword">uint</span> = <span class="number">2</span> <span class="comment">// 无符号整数类型</span></span><br></pre></td></tr></table></figure>

<h4 id="7-6-1-int-和-uint"><a href="#7-6-1-int-和-uint" class="headerlink" title="7.6.1 int 和 uint"></a>7.6.1 int 和 uint</h4><p>int和uint是针对目标设备优化的类型</p>
<ul>
<li>在old 的移动设备上，int 和 uint都是32位的</li>
<li>比较新的计算机上，int 和 uint都是64位的</li>
<li>虽然在某些设备上int可以看作int32，在某些设备上可以看作是int64，但他们其实是3种不同的类型</li>
<li>int并不是其它类型的别名</li>
</ul>
<p>tip</p>
<p>如果你在较老的32位设备上，使用了超过20亿的整数，而且代码还能运行，那么最好使用int64 和 uint64 来代替 int和uint</p>
<h4 id="7-6-2-uint8"><a href="#7-6-2-uint8" class="headerlink" title="7.6.2 uint8"></a>7.6.2 uint8</h4><p>uint8 可以表示8位的颜色（红绿蓝： 0-255）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue <span class="keyword">uint8</span> = <span class="number">0</span>,<span class="number">141</span>,<span class="number">213</span></span><br></pre></td></tr></table></figure>

<p>为什么不使用int</p>
<ul>
<li>uint8取值范围正好合适，而int则多出来几十亿不合理的数字</li>
<li>如果很多颜色数据连续存储，例如未被压缩的图片，那么使用uint8可以节省很多内存</li>
</ul>
<h3 id="7-7-输出数据类型"><a href="#7-7-输出数据类型" class="headerlink" title="7.7 输出数据类型"></a>7.7 输出数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:= <span class="number">1.0</span></span><br><span class="line">fmt.Println(<span class="string">"%T"</span>, a)</span><br></pre></td></tr></table></figure>



<h3 id="7-8-文本"><a href="#7-8-文本" class="headerlink" title="7.8 文本"></a>7.8 文本</h3><h3 id="7-8-1-声明字符串"><a href="#7-8-1-声明字符串" class="headerlink" title="7.8.1 声明字符串"></a>7.8.1 声明字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peace := <span class="string">"peace"</span></span><br><span class="line"><span class="keyword">var</span> peace = <span class="string">"peace"</span></span><br><span class="line"><span class="keyword">var</span> peace <span class="keyword">string</span> = <span class="string">"peace"</span></span><br></pre></td></tr></table></figure>

<p>字符串的零值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blank <span class="keyword">string</span></span><br></pre></td></tr></table></figure>



<h3 id="7-9-类型转换"><a href="#7-9-类型转换" class="headerlink" title="7.9 类型转换"></a>7.9 类型转换</h3><p>连接两个字符串，使用+运算符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout:= <span class="string">"alex"</span> + <span class="string">"leo"</span> <span class="comment">// compiler success</span></span><br></pre></td></tr></table></figure>

<p>如果想连接字符串和数值，是会报错的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout:= <span class="string">"alex"</span> + <span class="number">10</span> + <span class="string">"leo"</span> <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure>

<p>整数和浮点数也不能直接连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想把age转化成浮点类型，需要使用目标类型将其“包裹”起来</span></span><br><span class="line">age := <span class="number">41</span></span><br><span class="line">marsAge := float(age)</span><br></pre></td></tr></table></figure>



<p>从浮点类型转为整数类型</p>
<ul>
<li>可以从浮点类型转化为整数类型，小数点后面的部分会被截断，而不是舍入</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">earthDays := <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">int</span>(earthDays)</span><br></pre></td></tr></table></figure>



<h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><h3 id="8-1-函数声明"><a href="#8-1-函数声明" class="headerlink" title="8.1 函数声明"></a>8.1 函数声明</h3><p>在go里，大写字母开头的函数、变量或其它标识符都会被导出，对其它包可用；</p>
<p>小写字母开头的就不行；</p>
<h3 id="8-2-方法"><a href="#8-2-方法" class="headerlink" title="8.2 方法"></a>8.2 方法</h3><p>也是一个函数，但是它根某一个类型相关联的；</p>
<p><strong>声明新类型</strong></p>
<p>关键字type可以用来声明新类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> temperature celsius = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>虽然celsius 是一种全新的类型，但是由于它和float64具有相同的行为和表示，所以赋值操作能顺利执行；</p>
<p>例如加法等运算，也可以像float64那样使用；</p>
<h4 id="8-2-1-通过方法添加行为"><a href="#8-2-1-通过方法添加行为" class="headerlink" title="8.2.1 通过方法添加行为"></a>8.2.1 通过方法添加行为</h4><p>在C#、java里，方法属于类</p>
<p>在Go里，它提供了方法，但是没提供类和对象</p>
<p>go比其它语言的方法要灵活</p>
<p>可以将方法与同包中声明的任何类型相关联、但不可以是int、float64等预声明的类型进行关联；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 两种类型不能混用，哪怕底层指向的是同一类型</span></span><br><span class="line">  <span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line">	<span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line">  <span class="keyword">var</span> w <span class="keyword">float64</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> k kelvin = <span class="number">20</span></span><br><span class="line">  k+=w <span class="comment">// compiler error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">float64</span></span><br><span class="line">	y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p为接收者， 类似this 的作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">distance</span><span class="params">(q Point)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.y &gt; p.y &amp;&amp; q.X &gt; p.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> point = Point&#123;<span class="number">3.12</span>, <span class="number">3.14</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> point1 = Point&#123;<span class="number">4.10</span>, <span class="number">3.12</span>&#125;</span><br><span class="line">	fmt.Println(point.y)</span><br><span class="line">	fmt.Println(point.distance(point1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个方法可以有多个参数，但只能有一个接收者</p>
<p>在方法体中，接收者的行为和其它参数一样；</p>
<h4 id="8-2-2-方法调用"><a href="#8-2-2-方法调用" class="headerlink" title="8.2.2 方法调用"></a>8.2.2 方法调用</h4><p>变量.方法()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">float64</span></span><br><span class="line">	y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p为接收者， 类似this 的作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">distance</span><span class="params">(q Point)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.y &gt; p.y &amp;&amp; q.X &gt; p.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> point = Point&#123;<span class="number">3.12</span>, <span class="number">3.14</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> point1 = Point&#123;<span class="number">4.10</span>, <span class="number">3.12</span>&#125;</span><br><span class="line">	fmt.Println(point.distance(point1)) <span class="comment">// 变量.方法()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-一等函数"><a href="#8-3-一等函数" class="headerlink" title="8.3 一等函数"></a>8.3 一等函数</h3><p>在go里，函数是头等的，它可以用在整数、字符串或其它类型能用的地方；</p>
<ul>
<li>将函数赋给变量</li>
<li>将函数作为函数的返回类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  sensor:= fakeSensor</span><br><span class="line">  sensor()</span><br><span class="line">  sensor:= realSensor</span><br><span class="line">  sensor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>将函数作为参数传递给函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, sensor <span class="keyword">func</span>()</span> <span class="title">kelvin</span>)</span>  &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  measureTemperature(<span class="number">3</span>, fakeSensor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>声明函数类型</strong></p>
<p>为函数声明类型有助于精简和明确调用者的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sensor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">kelvin</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, s <span class="keyword">func</span>()</span> <span class="title">kelvin</span>)</span></span><br><span class="line"><span class="comment">// 可以优化为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, s sensor )</span></span></span><br></pre></td></tr></table></figure>



<p><strong>闭包和匿名函数</strong></p>
<p>匿名函数就是没有名字的函数，在Go里也称作函数字面值；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	fmt.Println(<span class="string">"&gt;&gt;."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  f() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"&gt;&gt;."</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> k <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> sensor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realSensor</span><span class="params">()</span> <span class="title">k</span></span> &#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calibrate</span><span class="params">(s sensor, offset k)</span> <span class="title">sensor</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s() + offset</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  sensor := calibrate(realSensor, <span class="number">5</span>)</span><br><span class="line">  sensor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包就是由于怒名函数封闭并包围作用域中的变量而得名的；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> k <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">type</span> sersor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span></span><br><span class="line">	<span class="keyword">var</span> f k = <span class="number">3</span></span><br><span class="line">	ser := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(ser()) <span class="comment">// 3</span></span><br><span class="line">	f++</span><br><span class="line">	fmt.Println(ser()) <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-多返回值"><a href="#8-4-多返回值" class="headerlink" title="8.4 多返回值"></a>8.4 多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">666</span>, <span class="number">777</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo3</span><span class="params">()</span><span class="params">(r1 <span class="keyword">int</span> ,r2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 有名称的返回值</span></span><br><span class="line">  	r1= <span class="number">666</span></span><br><span class="line">  	r2 =<span class="number">777</span></span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo4</span><span class="params">()</span><span class="params">(r1 ,r2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 有名称的返回值</span></span><br><span class="line">  	r1= <span class="number">666</span></span><br><span class="line">  	r2 =<span class="number">777</span></span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ret1, ret2 := foo2()</span><br><span class="line">  r1, r2 := foo3() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9 数组"></a>9 数组</h2><h3 id="9-1-数组的复制"><a href="#9-1-数组的复制" class="headerlink" title="9.1 数组的复制"></a>9.1 数组的复制</h3><p>无论数组赋值给新的变量还是将它传递给函数，都会产生一个完整的数组副本</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	plants := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">	clones := plants</span><br><span class="line">	plants[<span class="number">0</span>] = <span class="string">"alex"</span></span><br><span class="line">	fmt.Println(plants)</span><br><span class="line">	fmt.Println(clones)</span><br><span class="line">	<span class="comment">// 	[alex b c]</span></span><br><span class="line">	<span class="comment">// [a b c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组也是一种值，函数通过值传递来接收参数，所以数组作为函数的参数就非常低效</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func clonefunc(p [<span class="number">3</span>]string) [<span class="number">3</span>]string &#123;</span><br><span class="line">	<span class="keyword">for</span> i := range p &#123;</span><br><span class="line">		p[i] = <span class="string">"pruffix"</span> + p[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	plants := [...]string&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(clonefunc(plants))</span><br><span class="line">	fmt.Println(plants)</span><br><span class="line">	<span class="comment">// 	[pruffixa pruffixb pruffixc]</span></span><br><span class="line">	<span class="comment">// [a b c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>数组的长度也是数组类型的一部分</p>
<ul>
<li>尝试将长度不符的数组作为参数传递，将会报错</li>
<li>函数一般使用slice而不是数组作为参数</li>
</ul>
<h2 id="10-slice"><a href="#10-slice" class="headerlink" title="10 slice"></a>10 slice</h2><p>指向数组的窗口</p>
<p>假如p 是一个数组，那么 p[0:4] 就是一个切片，它切分出数组里面前4个元素</p>
<p>切分数组不会导致数组被修改，它只是创建了指向数组的一个窗口或视图，这种视图就是slice类型；</p>
<p>默认索引</p>
<p>[:10]</p>
<p>[1:]</p>
<p>[:]</p>
<p>切分数组的语法也可以用于切分字符串</p>
<ul>
<li>切分字符串时，索引代表的是字节数而非 字符串的数；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">que := <span class="string">"汉字^&amp;COMasf"</span></span><br><span class="line">fmt.Println(que[:<span class="number">3</span>]) <span class="comment">// 汉</span></span><br></pre></td></tr></table></figure>



<h3 id="10-1-slice的字面值"><a href="#10-1-slice的字面值" class="headerlink" title="10.1 slice的字面值"></a>10.1 slice的字面值</h3><p>Go里面很多函数都倾向于使用slice而不是数组作为参数</p>
<p>想要获得与底层数组相同元素的slice，那么可以使用[:]进行切分</p>
<h3 id="10-2-声明slice"><a href="#10-2-声明slice" class="headerlink" title="10.2 声明slice"></a>10.2 声明slice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明slice</span></span><br><span class="line">d := []<span class="keyword">string</span> &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line"><span class="comment">// 声明array</span></span><br><span class="line">f := [...]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"c"</span>&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hyper</span><span class="params">(worlds []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> worlds &#123;</span><br><span class="line">		worlds[i] = strings.TrimSpace(worlds[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	planets := []<span class="keyword">string</span>&#123;<span class="string">"a   "</span>, <span class="string">"   b"</span>, <span class="string">" c "</span>&#125;</span><br><span class="line">	hyper(planets)</span><br><span class="line">	fmt.Println(planets) <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-3-带有方法的切片"><a href="#10-3-带有方法的切片" class="headerlink" title="10.3 带有方法的切片"></a>10.3 带有方法的切片</h3><p>在go里，可以将slice或数组作为底层类型，然后绑定其它方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	planets := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.StringSlice(planets).Sort()</span><br><span class="line">	fmt.Println(planets) <span class="comment">// [Ear Mer Ven]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-4-append函数"><a href="#10-4-append函数" class="headerlink" title="10.4 append函数"></a>10.4 append函数</h3><p>append函数也是内置函数，它可以将元素添加到slice里面</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>,</span><br><span class="line">&#125;</span><br><span class="line">sort.StringSlice(planets).Sort()</span><br><span class="line">planets = <span class="built_in">append</span>(planets, <span class="string">"Xyy"</span>)</span><br><span class="line">fmt.Println(planets) <span class="comment">// [Ear Mer Ven Xyy]</span></span><br></pre></td></tr></table></figure>



<p>思考一个问题</p>
<p>当直接声明<code>planets := []string{&quot;Mer&quot;, &quot;Ven&quot;, &quot;Ear&quot;,}</code>的时候，会创建一个数组。该数组有3个元素。后面append又给 planets添加了1个元素。因为声明的数组是定长，那么append的这个元素被添加到哪里了呢？</p>
<h3 id="10-5-长度和容量"><a href="#10-5-长度和容量" class="headerlink" title="10.5 长度和容量"></a>10.5 长度和容量</h3><blockquote>
<p>长度就是切片里有多少个元素，</p>
<p>容量就是指切片对应的底层数组，底层数组的容量是多少，那么切片的容量就是多少</p>
</blockquote>
<p>slice中元素的个数决定slice的长度</p>
<p>如果slice底层数组比slice还大，那么就说该slice还有容量可供增长</p>
<ul>
<li>获取切片的长度 len(slice)</li>
<li>获取切片的容量 cap(slice)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dump</span><span class="params">(label <span class="keyword">string</span>, slice []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%v: length %v, cap %v \n"</span>, label, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	planets := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	dump(<span class="string">"planets"</span>, planets)</span><br><span class="line">	dump(<span class="string">"planets[1:2]"</span>, planets[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// planets: length 5, cap 5 </span></span><br><span class="line"><span class="comment">// planets[1:2]: length 1, cap 4</span></span><br></pre></td></tr></table></figure>



<p>当往一个切片append元素的时候，要看一下底层数组的长度够不够，如果不够的话，新声明一个长度为当前数组长度两倍长度的数组，然后将老数组的值依次复制到新数组里面，再追加append的元素。<br>如果够的话，直接追加不创建新数组；</p>
<p>planets[1:2] cap为何是 4 ？</p>
<h3 id="10-6-三个索引的切分操作"><a href="#10-6-三个索引的切分操作" class="headerlink" title="10.6 三个索引的切分操作"></a>10.6 三个索引的切分操作</h3><p>Go1.2 引入了能够限制新建切片容量的三索引切分操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	planets := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">  ter := planets[<span class="number">0</span>:<span class="number">4</span>:<span class="number">4</span>] <span class="comment">// 第三个指定切片容量为4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-7-使用make函数对slice进行预分配"><a href="#10-7-使用make函数对slice进行预分配" class="headerlink" title="10.7 使用make函数对slice进行预分配"></a>10.7 使用make函数对slice进行预分配</h3><p>当slice的容量不足以执行append操作时，Go必须创建新数组并复制旧数组中的内容</p>
<p>但通过内置的make函数，可以对slice进行预分配策略</p>
<ul>
<li>尽量避免额外的内存分配和数组复制操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dump</span><span class="params">(label <span class="keyword">string</span>, slice []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%v: length %v, cap %v \n"</span>, label, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	planets := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">10</span>) <span class="comment">// 设置 长度 容量</span></span><br><span class="line">	dump(<span class="string">"aa"</span>, planets) <span class="comment">// aa: length 0, cap 10</span></span><br><span class="line">	planets = <span class="built_in">append</span>(planets,</span><br><span class="line">		<span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">	)</span><br><span class="line">	dump(<span class="string">"bb"</span>, planets) <span class="comment">// bb: length 5, cap 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-8-声明可变参数的函数"><a href="#10-8-声明可变参数的函数" class="headerlink" title="10.8 声明可变参数的函数"></a>10.8 声明可变参数的函数</h3><p>声明Printf append 这样的可变参数函数，需要在函数的最后一个参数前面加上 … 符号；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...string 行参</span></span><br><span class="line"><span class="comment">// planets... 实参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">terraform</span><span class="params">(prefix <span class="keyword">string</span>, worlds ...<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	newWorlds := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(worlds))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> worlds &#123;</span><br><span class="line">		newWorlds[i] = prefix + <span class="string">" "</span> + worlds[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newWorlds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	twoWorlds := terraform(<span class="string">"New"</span>, <span class="string">"Venus"</span>, <span class="string">"Mars"</span>)</span><br><span class="line">	fmt.Println(twoWorlds)</span><br><span class="line">	<span class="comment">// [New Venus New Mars]</span></span><br><span class="line"></span><br><span class="line">	planets := []<span class="keyword">string</span>&#123;<span class="string">"Venus"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>&#125;</span><br><span class="line">	newPlanets := terraform(<span class="string">"New"</span>, planets...)</span><br><span class="line">	fmt.Println(newPlanets)</span><br><span class="line">	<span class="comment">// [New Venus New Mars New Jupiter]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-map"><a href="#11-map" class="headerlink" title="11. map"></a>11. map</h2><h3 id="11-1-声明"><a href="#11-1-声明" class="headerlink" title="11.1 声明"></a>11.1 声明</h3><p><code>map[string]int</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temperature := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">  <span class="string">"E"</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="string">"M"</span>: <span class="number">-65</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-map不会被复制"><a href="#11-2-map不会被复制" class="headerlink" title="11.2 map不会被复制"></a>11.2 map不会被复制</h3><p>数组，int 等类型在赋值给新变量或传递至函数/方法的时候会创建相应的副本</p>
<p>map不会, </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	planets := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"E"</span>:    <span class="string">"Sector zz9"</span>,</span><br><span class="line">		<span class="string">"Mars"</span>: <span class="string">"Sector zz9"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	planetsMark := planets</span><br><span class="line">	planets[<span class="string">"Earth"</span>] = <span class="string">"whoops"</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(planets)     <span class="comment">// map[E:Sector zz9 Earth:whoops Mars:Sector zz9]</span></span><br><span class="line">	fmt.Println(planetsMark) <span class="comment">// map[E:Sector zz9 Earth:whoops Mars:Sector zz9]</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(planets, <span class="string">"Earth"</span>)</span><br><span class="line">	fmt.Println(planetsMark) <span class="comment">// map[E:Sector zz9 Mars:Sector zz9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3-使用make对map进行预分配"><a href="#11-3-使用make对map进行预分配" class="headerlink" title="11.3 使用make对map进行预分配"></a>11.3 使用make对map进行预分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temperature := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>创建map时，make函数可以接受一个或者两个参数</p>
<ul>
<li>第二个参数用于为指定数量的key预先分配空间</li>
<li>使用make函数创建的map初始长度为0</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	temperatures := []<span class="keyword">float64</span>&#123;</span><br><span class="line">		<span class="number">-28.0</span>, <span class="number">32.0</span>, <span class="number">-31.0</span>, <span class="number">-29.0</span>, <span class="number">-23.0</span>, <span class="number">-29.0</span>, <span class="number">-28.0</span>, <span class="number">-33.0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	frequency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>) <span class="comment">// key 为float64 value为int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> temperatures &#123;</span><br><span class="line">		frequency[t]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> t, num := <span class="keyword">range</span> frequency &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%+.2f occurs %d times\n"</span>, t, num)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-struct"><a href="#12-struct" class="headerlink" title="12. struct"></a>12. struct</h2><p>struct允许将不同的类型的东西组合在一起</p>
<h3 id="12-1-声明"><a href="#12-1-声明" class="headerlink" title="12.1 声明"></a>12.1 声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">  lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-将struct编码为JSON"><a href="#12-2-将struct编码为JSON" class="headerlink" title="12.2 将struct编码为JSON"></a>12.2 将struct编码为JSON</h3><p>json包的Marshal函数可以将struct中的数据转化为JSON格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">		Lat, Long <span class="keyword">float64</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	curiosity := location&#123;<span class="number">-4.12</span>, <span class="number">123.23</span>&#125;</span><br><span class="line">	bytes, err := json.Marshal(curiosity)</span><br><span class="line">	exitOnError(err)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(bytes)) <span class="comment">// &#123;"Lat":-4.12,"Long":123.23&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitOnError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-3-使用struct标签来自定义JSON"><a href="#12-3-使用struct标签来自定义JSON" class="headerlink" title="12.3 使用struct标签来自定义JSON"></a>12.3 使用struct标签来自定义JSON</h3><p>go语言中的json包要求struct中的字段必须以大写字母开头，类似驼峰命名；</p>
<p>但有时候需要snake_case蛇形命名规范，那么该怎么办？</p>
<p>可以为字段标注标签，使得json包在进行编码的时候能够按照标签里的样式修改字段名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat  <span class="keyword">float64</span> <span class="string">`json:"latitude"xml:"latitude"`</span></span><br><span class="line">		Long <span class="keyword">float64</span> <span class="string">`json:"longitude"`</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	curiosity := location&#123;<span class="number">-4.12</span>, <span class="number">123.23</span>&#125;</span><br><span class="line">	bytes, err := json.Marshal(curiosity)</span><br><span class="line">	exitOnError(err)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(bytes)) <span class="comment">// &#123;"latitude":-4.12,"longitude":123.23&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitOnError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-3-1-结构体标签在json中的应用"><a href="#12-3-1-结构体标签在json中的应用" class="headerlink" title="12.3.1 结构体标签在json中的应用"></a>12.3.1 结构体标签在json中的应用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title  <span class="keyword">string</span>   <span class="string">`json:"title"`</span> <span class="comment">// 当前的字段在json中显示的名称是什么</span></span><br><span class="line">	Year   <span class="keyword">int</span>      <span class="string">`json:"year"`</span></span><br><span class="line">	Actors []<span class="keyword">string</span> <span class="string">`json:"actors"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	movie := Movie&#123;<span class="string">"alex"</span>, <span class="number">2000</span>, []<span class="keyword">string</span>&#123;<span class="string">"xing"</span>&#125;&#125;</span><br><span class="line">	<span class="comment">// struct -&gt; json</span></span><br><span class="line">	jsonStr, err := json.Marshal(movie)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"jsonStr = %s\n"</span>, jsonStr)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// json -&gt; struct</span></span><br><span class="line">	movie2 := Movie&#123;&#125;</span><br><span class="line">	err = json.Unmarshal(jsonStr, &amp;movie2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jsonStr = &#123;"title":"alex","year":2000,"actors":["xing"]&#125;</span></span><br><span class="line"><span class="comment">// struct=&#123;alex 2000 [xing]&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="12-4-将方法关联到struct"><a href="#12-4-将方法关联到struct" class="headerlink" title="12.4 将方法关联到struct"></a>12.4 将方法关联到struct</h3><p>方法可以关联到声明的类型上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">  d,m,s <span class="keyword">float64</span></span><br><span class="line">  h <span class="keyword">rune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c coordinate)</span> <span class="title">decimal</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-4-1-构造函数"><a href="#12-4-1-构造函数" class="headerlink" title="12.4.1 构造函数"></a>12.4.1 构造函数</h4><p>可以使用struct复合字面值来初始化你所要的数据</p>
<p>但如struct初始化的时候还要做很多事情，那就可以考虑写一个构造用的函数</p>
<p>Go语言没有专用的构造函数，但以new或者New开头的函数，通常是用来构造数据的，例如 newPerson NewPerson</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">  d,m,s <span class="keyword">float64</span></span><br><span class="line">  h <span class="keyword">rune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c coordinate)</span> <span class="title">decimal</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  sign := <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">switch</span> c.h &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>, <span class="string">'W'</span>,<span class="string">'s'</span>,<span class="string">'w'</span>:</span><br><span class="line">    	sign = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sign * (c.d + c.m/<span class="number">60</span> + c.s/<span class="number">3600</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造用的函数,在go中没有专业的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLocation</span><span class="params">(lat, long coordinate)</span> <span class="title">location</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> location&#123;lat.decimal(), long.decimal()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">  lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  lat := coordinate&#123;...&#125;</span><br><span class="line">  long := coordinate&#123;...&#125;</span><br><span class="line">  curiosity := newLocation(lat, long)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-4-2-New函数"><a href="#12-4-2-New函数" class="headerlink" title="12.4.2 New函数"></a>12.4.2 New函数</h4><p>有一些用于构造的函数的名称就是New （例如errors包里面的New函数）</p>
<p>这是因为函数调用时使用 包名.函数名 的形式</p>
<p>如果该函数叫NewError，那么调用的时候就是errors.NewError()， 这就不如errors.New() 简洁</p>
<h3 id="12-5-class的替代方案"><a href="#12-5-class的替代方案" class="headerlink" title="12.5 class的替代方案"></a>12.5 class的替代方案</h3><p>Go语言没有class，但使用struct并配备几个方法也可以达到同样的效果</p>
<h3 id="12-6-反射"><a href="#12-6-反射" class="headerlink" title="12.6 反射"></a>12.6 反射</h3><p>对一个已经的变量作为输入，得出该变量的type 和 value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Valueof</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="comment">// valueof 用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Typeof</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// Typeof 用来动态获取输入参数接口的值的类型，如果接口为空则返回nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectName</span><span class="params">(num <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(reflect.TypeOf(num))</span><br><span class="line">	fmt.Println(reflect.ValueOf(num))</span><br><span class="line">  <span class="comment">// float64</span></span><br><span class="line">	<span class="comment">// 1.23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this User)</span> <span class="title">Call</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoFileAndMethod</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	inputType := reflect.TypeOf(input)</span><br><span class="line">	fmt.Println(<span class="string">"inputType is:"</span>, inputType.Name())</span><br><span class="line"></span><br><span class="line">	inputValue := reflect.ValueOf(input)</span><br><span class="line">	fmt.Println(<span class="string">"inputValue is:"</span>, inputValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过type 获取里面的字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputType.NumField(); i++ &#123;</span><br><span class="line">		field := inputType.Field(i)</span><br><span class="line">		value := inputValue.Field(i)</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">"%s: %v = %v\n"</span>, field.Name, field.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过type获取里面的方法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputType.NumMethod(); i++ &#123;</span><br><span class="line">		m := inputType.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">"%s: %v\n"</span>, m.Name, m.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user := User&#123;<span class="number">1</span>, <span class="string">"alex"</span>, <span class="number">18</span>&#125;</span><br><span class="line">	DoFileAndMethod(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inputType is: User</span></span><br><span class="line"><span class="comment">// inputValue is: &#123;1 alex 18&#125;</span></span><br><span class="line"><span class="comment">// id: int = 1</span></span><br><span class="line"><span class="comment">// name: string = alex</span></span><br><span class="line"><span class="comment">// age: int = 18</span></span><br><span class="line"><span class="comment">// Call: func(main.User) int</span></span><br></pre></td></tr></table></figure>

<p><strong>反射结构体标签</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> resume <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`info:"name" doc:"名字"`</span></span><br><span class="line">	Sex  <span class="keyword">string</span> <span class="string">`info:"sex"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTag</span><span class="params">(str <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(str).Elem()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		tagstring := t.Field(i).Tag.Get(<span class="string">"info"</span>)</span><br><span class="line">		tagdoc := t.Field(i).Tag.Get(<span class="string">"doc"</span>)</span><br><span class="line">		fmt.Println(<span class="string">"info:"</span>, tagstring, <span class="string">"doc:"</span>, tagdoc)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> re resume</span><br><span class="line">	findTag(&amp;re)</span><br><span class="line">	<span class="comment">// info: name doc: 名字</span></span><br><span class="line">	<span class="comment">// info: sex doc:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13-组合和转发"><a href="#13-组合和转发" class="headerlink" title="13. 组合和转发"></a>13. 组合和转发</h2><h3 id="13-1-组合"><a href="#13-1-组合" class="headerlink" title="13.1 组合"></a>13.1 组合</h3><p>在面向对象的世界中，对象由更小的对象组合而成</p>
<p>术语： 对象组合或组合</p>
<p>Go通过结构体视线组合（composition）</p>
<p>Go提供了“嵌入”（embedding） 特性，他可以实现方法的转发（forwarding）</p>
<p>组合是一种更简单，灵活的方式</p>
<p><strong>拆分类型</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> report <span class="keyword">struct</span> &#123;</span><br><span class="line">	sol       <span class="keyword">int</span></span><br><span class="line">	high, low <span class="keyword">float64</span></span><br><span class="line">	lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">	sol         <span class="keyword">int</span></span><br><span class="line">	temperature temperature</span><br><span class="line">	location    location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">	high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">	lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br></pre></td></tr></table></figure>



<p><strong>duck type</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">	sol         <span class="keyword">int</span></span><br><span class="line">	temperature temperature</span><br><span class="line">	location    location</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">	high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">	lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t temperature)</span> <span class="title">averae</span><span class="params">()</span> <span class="title">celsius</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (t.high + t.low) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reportNew)</span> <span class="title">averae</span><span class="params">()</span> <span class="title">celsius</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.temperature.averae()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := temperature&#123;high: <span class="number">12.4</span>, low: <span class="number">134.5</span>&#125;</span><br><span class="line">	loc := location&#123;lat: <span class="number">22.3</span>, long: <span class="number">34.9</span>&#125;</span><br><span class="line">	report := reportNew&#123;</span><br><span class="line">		sol:         <span class="number">12</span>,</span><br><span class="line">		temperature: t,</span><br><span class="line">		location:    loc,</span><br><span class="line">	&#125;</span><br><span class="line">	t.averae()</span><br><span class="line">	report.temperature.averae() <span class="comment">// duck type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-2-转发方法"><a href="#13-2-转发方法" class="headerlink" title="13.2 转发方法"></a>13.2 转发方法</h3><p>Go可以通过struct嵌入 来实现方法的转发</p>
<p>在struct中只给定字段类型，不给定字段名即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">	sol         <span class="keyword">int</span></span><br><span class="line">	temperature temperature <span class="comment">// 字段名 类型</span></span><br><span class="line">	location    location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">	sol <span class="keyword">int</span></span><br><span class="line">	temperature <span class="comment">// struct 嵌入</span></span><br><span class="line">	location <span class="comment">// 只有类型，没有字段名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>struct的嵌入之后，被嵌入的类型可以直接使用 嵌入类型上的方法了</p>
<p>在struct中，可以转发任意类型</p>
<h3 id="13-3-命名冲突"><a href="#13-3-命名冲突" class="headerlink" title="13.3 命名冲突"></a>13.3 命名冲突</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> report <span class="keyword">struct</span> &#123;</span><br><span class="line">	sol</span><br><span class="line">	temperature</span><br><span class="line">	location</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">	high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">	lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> sol <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	days := <span class="keyword">int</span>(s2 - s)</span><br><span class="line">	<span class="keyword">if</span> days &lt; <span class="number">0</span> &#123;</span><br><span class="line">		days = -days</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> days</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">days</span><span class="params">(l2 location)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	report := report&#123;sol: <span class="number">15</span>&#125;</span><br><span class="line">	fmt.Println(report.sol.days(<span class="number">1446</span>))</span><br><span class="line">	fmt.Println(report.days(<span class="number">1446</span>)) <span class="comment">// error 发生歧义， 编译器不知道该调 location类型还是sol类型下面的days方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	days := <span class="keyword">int</span>(s2 - s)</span><br><span class="line">	<span class="keyword">if</span> days &lt; <span class="number">0</span> &#123;</span><br><span class="line">		days = -days</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> days</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">days</span><span class="params">(l2 location)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r report)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123; <span class="comment">// 顶级类型，可以调用report.days直接访问</span></span><br><span class="line">  <span class="keyword">return</span> r.sol.days(s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	report := report&#123;sol: <span class="number">15</span>&#125;</span><br><span class="line">	fmt.Println(report.sol.days(<span class="number">1446</span>))</span><br><span class="line">	fmt.Println(report.days(<span class="number">1446</span>)) <span class="comment">// compiler success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-4-继承还是组合"><a href="#13-4-继承还是组合" class="headerlink" title="13.4 继承还是组合"></a>13.4 继承还是组合</h3><p>优先使用对象组合而不是类的继承</p>
<p>对传统的继承不是必须额，所有使用继承解决的问题都可以通过其它方法解决；</p>
<h2 id="14-接口"><a href="#14-接口" class="headerlink" title="14. 接口"></a>14. 接口</h2><p>接口关注于类型可以做什么，而不是存储了什么</p>
<p>接口通过列举类型必须满足的一组方法来进行声明</p>
<p>在Go语言中，不需要显式声明接口；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 多态</span></span><br><span class="line">	t = martian&#123;&#125; <span class="comment">// martian 类型实现了talk方法，所以可以直接赋值</span></span><br><span class="line">	fmt.Println(t.talk())</span><br><span class="line">	t = laser(<span class="number">3</span>) <span class="comment">// laser 类型实现了talk方法，所以可以直接赋值</span></span><br><span class="line">	fmt.Println(t.talk())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-1-接口类型"><a href="#14-1-接口类型" class="headerlink" title="14.1 接口类型"></a>14.1 接口类型</h3><p>为了复用，通常会把接口声明为类型</p>
<p>按约定，接口名称通常以er结尾</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">	louder := strings.ToUpper(t.talk())</span><br><span class="line">	fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	shout(martian&#123;&#125;) <span class="comment">// martian 实现了 talker 类型，可以直接调用</span></span><br><span class="line">	shout(laser(<span class="number">2</span>)) <span class="comment">// laser实现了 talker类型，可以直接调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接口可以和struct嵌入特性一同使用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">	louder := strings.ToUpper(t.talk())</span><br><span class="line">	fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> starship <span class="keyword">struct</span> &#123;</span><br><span class="line">	laser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := starship&#123;laser(<span class="number">3</span>)&#125; <span class="comment">// starship 类型包含了laser</span></span><br><span class="line">	fmt.Println(s.talk()) <span class="comment">// 因为laser实现talk方法，所以 starship可以调用talk方法</span></span><br><span class="line">	shout(s) <span class="comment">// starship有talk方法，满足了 talker类型，而talker类型又能作为 shout函数的参数，所以可以将 starship 传入shout方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时使用组合和接口将构成非常强大的设计工具；</p>
<h3 id="14-2-探索接口"><a href="#14-2-探索接口" class="headerlink" title="14.2 探索接口"></a>14.2 探索接口</h3><p>Go语言的接口都是隐式满足的</p>
<p>Go允许在实现代码的过程中，随时创建新的接口。任何代码都能实现接口。包括已经存在的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stardater <span class="keyword">interface</span> &#123;</span><br><span class="line">	YearDay() <span class="keyword">int</span></span><br><span class="line">	Hour() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> sol <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">YearDay</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(s % <span class="number">668</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">Hour</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func stardate(t time.Time) float64 &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stardate</span><span class="params">(t stardater)</span> <span class="title">float64</span></span> &#123; <span class="comment">// 既然 stardater实现了 YearDay和Hour，可以更改此类型</span></span><br><span class="line">	doy := <span class="keyword">float64</span>(t.YearDay())</span><br><span class="line">	h := <span class="keyword">float64</span>(t.Hour()) / <span class="number">24.0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000</span> + doy + h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	day := time.Date(<span class="number">2012</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">	fmt.Printf(<span class="string">"%.1f Has\n"</span>, stardate(day))</span><br><span class="line"></span><br><span class="line">	s := sol(<span class="number">1422</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%.1f Happy\n"</span>, stardate(s)) <span class="comment">// 因为sol类型也实现了stardater接口，所以可以传入stardate方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-3-满足接口"><a href="#14-3-满足接口" class="headerlink" title="14.3 满足接口"></a>14.3 满足接口</h3><p>Go标准库导出了很多只有单个方法的接口；</p>
<p>Go通过简单的、通常只有单个方法的接口… 来鼓励组合而不是继承，这些接口在各个组件之间形成了简明易懂的界限</p>
<p>例如在fmt包 声明的Stringer接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">	lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v, %v"</span>, l.lat, l.long)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	curiosity := location&#123;<span class="number">-4.5895</span>, <span class="number">137.4417</span>&#125;</span><br><span class="line">	fmt.Println(curiosity) <span class="comment">// location实现了String方法，满足了 Stringer接口。 所以就能被fmt.Println 调用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库中常用的接口还包括: io.Reader, io.Write, json.Marshaler</p>
<h2 id="15-指针"><a href="#15-指针" class="headerlink" title="15 指针"></a>15 指针</h2><p>指针是指向另一个变量地址的变量</p>
<p>Go语言的指针同时也强调安全性，不会出现迷途指针（dangling pointers）</p>
<h3 id="15-1-amp-和"><a href="#15-1-amp-和" class="headerlink" title="15.1 &amp; 和 *"></a>15.1 &amp; 和 *</h3><p>变量会将它们的值存储在计算机的RAM里，存储位置就是该变量的内存地址；</p>
<p>&amp; ： 获得变量的内存地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	answer := <span class="number">42</span></span><br><span class="line">	fmt.Println(&amp;answer) <span class="comment">// 0xc000014090</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&amp; 操作符无法获得字符串/数值/布尔字面值的地址；</p>
<ul>
<li>&amp;42， &amp;”hello” 这些都会导致编译器报错</li>
</ul>
<p><code>*操作符</code>与&amp;的作用相反，它用来解引用，提供内存地址指向的值；</p>
<p>C语言中的内存地址可以通过 address++ 这样的指针运算进行操作，在Go里面不允许这种不安全的操作</p>
<h3 id="15-2-指针类型"><a href="#15-2-指针类型" class="headerlink" title="15.2 指针类型"></a>15.2 指针类型</h3><p>指针存储的是内存地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	answer := <span class="number">42</span></span><br><span class="line">	address := &amp;answer    <span class="comment">// *int address就是一个指向int类型的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针类型和其它普通类型一样，出现在所有需要用到类型的地方，如变量声明、函数行参、返回值类型、结构体字段等</p>
<p>将*放在类型前面表示声明指针类型</p>
<p>将*放在变量前面表示解引用操作</p>
<h3 id="15-3-指针就是用来指向的"><a href="#15-3-指针就是用来指向的" class="headerlink" title="15.3 指针就是用来指向的"></a>15.3 指针就是用来指向的</h3><p>两个指针变量持有相同的内存地址，那么它们就是相等的；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 说明下面语句的作用</span></span><br><span class="line">a = *b; <span class="comment">// 将b指针解引用，赋值给a，这个是值拷贝</span></span><br><span class="line">*b = <span class="string">'alex'</span> <span class="comment">// b地址解引用，重复赋值</span></span><br></pre></td></tr></table></figure>



<h3 id="15-4-指向结构的指针"><a href="#15-4-指向结构的指针" class="headerlink" title="15.4 指向结构的指针"></a>15.4 指向结构的指针</h3><p>与字符串和数值不一样，复合字面量的前面可以放置&amp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">		name, superpower <span class="keyword">string</span></span><br><span class="line">		age              <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	timmy := &amp;person&#123;</span><br><span class="line">		name: <span class="string">"alex"</span>,</span><br><span class="line">		age:  <span class="number">10</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// (*timmy).superpower = "flying" // 访问字段时， 解引用不是必须要做的</span></span><br><span class="line">	timmy.superpower = <span class="string">"flying"</span></span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, timmy) <span class="comment">// &amp;&#123;name:alex superpower:flying age:10&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问字段时，对结构体进行解引用并不是必须的；</p>
<h3 id="15-5-指向数组的指针"><a href="#15-5-指向数组的指针" class="headerlink" title="15.5 指向数组的指针"></a>15.5 指向数组的指针</h3><p>和结构体一样，可以把&amp; 放在数组的复合字面值前面来创建指向数组的指针</p>
<p>数组在执行索引或切片操作时会自动解引用。没有必要写(*array)[0]这种形式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  arr := &amp;[<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line">  arr[<span class="number">0</span>]</span><br><span class="line">  arr[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与C语言不一样，Go里面数组和指针是两种完全独立的类型</p>
<p>slice和map的复合字面值前面也可以放置 &amp;操作符，但是Go并没有为它们提供自动解引用的功能；</p>
<h4 id="15-5-1-修改数组"><a href="#15-5-1-修改数组" class="headerlink" title="15.5.1  修改数组"></a>15.5.1  修改数组</h4><p>函数通过指针对数组的元素进行修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rune指的是？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">(board *[8][8]<span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line">	board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'r'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> board [<span class="number">8</span>][<span class="number">8</span>]<span class="keyword">rune</span></span><br><span class="line">	reset(&amp;board)</span><br><span class="line">	fmt.Printf(<span class="string">"%c"</span>, board[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">// r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-5-2-什么情况下应该使用指向数组的指针"><a href="#15-5-2-什么情况下应该使用指向数组的指针" class="headerlink" title="15.5.2 什么情况下应该使用指向数组的指针"></a>15.5.2 什么情况下应该使用指向数组的指针</h4><p>隐式的指针</p>
<p>Go语言里一些内置的集合类型就在暗中使用指针</p>
<p>map在被赋值或者被作为参数传递的时候不会被复制</p>
<ul>
<li>map就是一种隐式指针</li>
<li>这种写法就是多此一举： func demo(planets *map[string]string) 应该去掉🌟</li>
</ul>
<p>map的键值都可以是指针类型</p>
<p>需要将指针指向map的情况并不多见</p>
<h4 id="15-5-3-slice指向数组"><a href="#15-5-3-slice指向数组" class="headerlink" title="15.5.3 slice指向数组"></a>15.5.3 slice指向数组</h4><p>之前说过slice是指向数组的窗口，实际上slice在指向数组元素的时候也使用了指针；</p>
<p>每个slice内部都会被表示为一个包含3个元素的结构，它们分别指向：</p>
<ul>
<li>数组的指针</li>
<li>slice的容量</li>
<li>slice的长度</li>
</ul>
<p>当slice被直接传递至函数或方法时，slice的内部指针就可以对底层数据进行修改 </p>
<p>指向slice的显式指针的唯一作用就是修改slice本身： slice的长度、容量以及起始偏移量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reclassify</span><span class="params">(p *[]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	*p = (*p)[<span class="number">0</span>:<span class="number">8</span>] <span class="comment">// 修改切片本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	planets := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"m"</span>, <span class="string">"v"</span>, <span class="string">"E"</span>, <span class="string">"MA"</span>, <span class="string">"ju"</span>, <span class="string">"sa"</span>, <span class="string">"ur"</span>, <span class="string">"ne"</span>, <span class="string">"pl"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	reclassify(&amp;planets)</span><br><span class="line">	fmt.Println(planets) <span class="comment">// [m v E MA ju sa ur ne]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-5-4-指针和接口"><a href="#15-5-4-指针和接口" class="headerlink" title="15.5.4 指针和接口"></a>15.5.4 指针和接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">	louder := strings.ToUpper(t.talk())</span><br><span class="line">	fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	shout(martian&#123;&#125;)</span><br><span class="line">	shout(&amp;martian&#123;&#125;)</span><br><span class="line">	<span class="comment">// 	NACK NACK</span></span><br><span class="line">	<span class="comment">// NACK NACK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是martian 还是指向martian的指针，都可以满足talker接口</p>
<p>如果方法使用的指针接收者，那么情况会有所不同；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">	louder := strings.ToUpper(t.talk())</span><br><span class="line">	fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(*l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pew := laser(<span class="number">2</span>)</span><br><span class="line">	shout(&amp;pew) <span class="comment">// PEWPEW</span></span><br><span class="line">	shout(pew) <span class="comment">// compiler error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-6-实现修改"><a href="#15-6-实现修改" class="headerlink" title="15.6 实现修改"></a>15.6 实现修改</h3><p>Go语言的函数和方法都是按值传递参数的，这意味着函数总是操作于被传递参数的副本；</p>
<p>当指针被传递到函数时，函数将接收传入的内存地址的副本，之后函数可以通过解引用内存地址来修改指针指向的值；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, superpower <span class="keyword">string</span></span><br><span class="line">	age              <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">birthday</span><span class="params">(p *person)</span></span> &#123;</span><br><span class="line">	p.age++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	rebecca := person&#123;</span><br><span class="line">		name:       <span class="string">"alex"</span>,</span><br><span class="line">		age:        <span class="number">10</span>,</span><br><span class="line">		superpower: <span class="string">"imagination"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	birthday(&amp;rebecca) <span class="comment">// 传入的虽然是指针副本，但是指向同一地址</span></span><br><span class="line">	<span class="comment">// birthday(rebecca) // 传入的是引用类型副本，等于复制了一个引用类型，性能差</span></span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, rebecca) <span class="comment">// &#123;name:alex superpower:imagination age:11&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-7-指针接收者"><a href="#15-7-指针接收者" class="headerlink" title="15.7 指针接收者"></a>15.7 指针接收者</h3><p>方法的接收者和方法的参数在处理指针方面是很相似的</p>
<p>Go语言在变量通过点标记法进行调用的时候，自动使用&amp;取得变量的内存地址</p>
<ul>
<li>所以不用写 (&amp;nathan).birthday() 这种形式也可以正常运行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, superpower <span class="keyword">string</span></span><br><span class="line">	age              <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">birthday</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	terry := &amp;person&#123;</span><br><span class="line">		name: <span class="string">"alex"</span>,</span><br><span class="line">		age:  <span class="number">15</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	terry.birthday()</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, terry) <span class="comment">// &amp;&#123;name:alex age:16&#125;</span></span><br><span class="line"></span><br><span class="line">	nathan := person&#123;</span><br><span class="line">		name: <span class="string">"leo"</span>,</span><br><span class="line">		age:  <span class="number">17</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	nathan.birthday()</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, nathan) <span class="comment">// &#123;name:leo age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用指针作为接收者的策略应该始终如一：</p>
<p>如果一种类型的某些方法需要用到指针作为接收者，就应该为这种类型的所有方法都是用指针作为接收者；</p>
<h3 id="15-8-内部指针"><a href="#15-8-内部指针" class="headerlink" title="15.8 内部指针"></a>15.8 内部指针</h3><p>Go语言提供了内部指针这种特性</p>
<p>它用于确定结构体中指定字段的内存地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stats <span class="keyword">struct</span> &#123;</span><br><span class="line">	level             <span class="keyword">int</span></span><br><span class="line">	endurance, health <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelUp</span><span class="params">(s *stats)</span></span> &#123;</span><br><span class="line">	s.level++</span><br><span class="line">	s.endurance = <span class="number">42</span> + (<span class="number">15</span> * s.level)</span><br><span class="line">	s.health = <span class="number">5</span> * s.endurance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> character <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	stats stats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	player := character&#123;name: <span class="string">"alex"</span>&#125;</span><br><span class="line">	levelUp(&amp;player.stats)            <span class="comment">//  结构体某个字段的地址</span></span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, player.stats) <span class="comment">// &#123;level:1 endurance:57 health:285&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&amp;操作符不仅可以获得结构体的内存地址，还可以获得结构体中指定字段的内存地址；</p>
<h3 id="15-9-小结"><a href="#15-9-小结" class="headerlink" title="15.9 小结"></a>15.9 小结</h3><p>应合理使用指针，不要过度使用指针</p>
<h2 id="16-nil"><a href="#16-nil" class="headerlink" title="16. nil"></a>16. nil</h2><p>nil是一个名字，表示“无” 或“零”</p>
<p>Go里面，nil是一个零值</p>
<p>如果一个指针没有明确的指向，那么它的值就是nil</p>
<p>除了指针，nil还是slice、map和接口的零值</p>
<p>Go语言的nil，比以往语言中的null更为友好，并且用的没那么频繁，但是仍需谨慎使用</p>
<h3 id="16-1-nil会导致panic"><a href="#16-1-nil会导致panic" class="headerlink" title="16.1 nil会导致panic"></a>16.1 nil会导致panic</h3><p>如果指针没有明确的指向，那么程序将无法对其实施的解引用。</p>
<p>尝试解引用一个nil指针将导致程序崩溃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nowhere *<span class="keyword">int</span></span><br><span class="line">	fmt.Println(nowhere) <span class="comment">//  &lt;nil&gt;</span></span><br><span class="line">	fmt.Println(*nowhere) <span class="comment">// compiler error</span></span><br><span class="line">  <span class="comment">// 防范代码</span></span><br><span class="line">  <span class="keyword">if</span> nowhere != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(*nowhere)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保护方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">days</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.age++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为值为nil的接收者和值为nil的参数在行为上并没有区别，所以go语言即使在接收者为nil的情况下，也会继续调用方法；</p>
<h3 id="16-2-nil函数值"><a href="#16-2-nil函数值" class="headerlink" title="16.2 nil函数值"></a>16.2 nil函数值</h3><p>当变量被声明为函数类型时，它的默认值是nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">	fmt.Println(fn == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查函数值是否为nil，并在有需要时提供默认行为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortStrings</span><span class="params">(s []<span class="keyword">string</span>, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> less == <span class="literal">nil</span> &#123;</span><br><span class="line">		less = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(s, less)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	food := []<span class="keyword">string</span>&#123;<span class="string">"onion"</span>, <span class="string">"carrot"</span>, <span class="string">"celery"</span>&#125;</span><br><span class="line">	sortStrings(food, <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(food) <span class="comment">// [carrot celery onion]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16-3-nil-slice"><a href="#16-3-nil-slice" class="headerlink" title="16.3 nil slice"></a>16.3 nil slice</h3><p>如果slice 在声明之后没有使用复合字面值或内置的make 函数进行初始化，那么它的值就是nil</p>
<p>幸运的是，range、len、append等内置数都可以正常处理值为nil的slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> soup []<span class="keyword">string</span></span><br><span class="line">	fmt.Println(soup == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">	<span class="keyword">for</span> _, ingredient := <span class="keyword">range</span> soup &#123;</span><br><span class="line">		fmt.Println(ingredient)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(soup)) <span class="comment">// 0</span></span><br><span class="line">	soup = <span class="built_in">append</span>(soup, <span class="string">"onion"</span>, <span class="string">"carrort"</span>, <span class="string">"celery"</span>)</span><br><span class="line">	fmt.Println(soup) <span class="comment">// [onion carrort celery]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然空slice和值为nil的slice并不相等，但它们通常可以替换使用；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirepoix</span><span class="params">(ingredients []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(ingredients, <span class="string">"onion"</span>, <span class="string">"carrot"</span>, <span class="string">"celery"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	soup := mirepoix(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(soup) <span class="comment">// [onion carrort celery]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-4-nil-map"><a href="#16-4-nil-map" class="headerlink" title="16.4 nil map"></a>16.4 nil map</h3><p>和slice一样，如果map在声明后没有使用复合字面值或内置的make函数进行初始化，那么它的值将会是默认的nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> soup <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">	fmt.Println(soup == <span class="literal">nil</span>)         <span class="comment">// true</span></span><br><span class="line">	measurement, ok := soup[<span class="string">"onion"</span>] <span class="comment">// 对值为nil的map读取不会报错</span></span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(measurement)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ingredient, measurement := <span class="keyword">range</span> soup &#123; <span class="comment">// 对值为nil的 map进行 range操作依然不会报错</span></span><br><span class="line">		fmt.Println(ingredient, measurement)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16-5-nil接口"><a href="#16-5-nil接口" class="headerlink" title="16.5 nil接口"></a>16.5 nil接口</h3><p>声明为接口类型的变量在未被赋值时，它的零值是nil</p>
<p>对于一个未被赋值的接口变量来说，它的接口类型和值都是nil，并且变量本身也等于nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// %T 接口类型</span></span><br><span class="line"><span class="comment">// %v 值</span></span><br></pre></td></tr></table></figure>

<p>当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line">	<span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">	v = p</span><br><span class="line">	fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// *int &lt;nil&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。</p>
<p>在Go中，接口类型的变量只有在类型和值都为nil时才等于nil</p>
<ul>
<li>即使接口变量的值仍为nil，但只要它的类型不是nil，那么该变量就不等于nil；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line">	<span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">	v = p</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, v) <span class="comment">//(*int)(nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-6-nil之外的另一个选择"><a href="#16-6-nil之外的另一个选择" class="headerlink" title="16.6 nil之外的另一个选择"></a>16.6 nil之外的另一个选择</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> number <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int</span></span><br><span class="line">	valid <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNumber</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">number</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> number&#123;value: v, valid: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n number)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !n.valid &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"not set"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>, n.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := newNumber(<span class="number">42</span>)</span><br><span class="line">	fmt.Println(n) <span class="comment">// 42</span></span><br><span class="line">	e := number&#123;&#125;</span><br><span class="line">	fmt.Println(e) <span class="comment">// not set</span></span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>



<h2 id="17-处理错误"><a href="#17-处理错误" class="headerlink" title="17 处理错误"></a>17 处理错误</h2><p>Go语言允许函数和方法同时返回多个值</p>
<p>按照惯例，函数在返回错误时，最后边的返回值应用来表示错误</p>
<p>调用函数后，应立即检查是否发生错误；</p>
<ul>
<li>如果没有错误发生，那么返回的错误值为nil</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	files, err := ioutil.ReadDir(<span class="string">"."</span>) <span class="comment">// . 表示当前目录</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">		fmt.Println(file.Name()) <span class="comment">// 00.go</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<p>当错误发生时候，函数返回的其它值通常就不再可信</p>
<h3 id="17-1-优雅的错误处理"><a href="#17-1-优雅的错误处理" class="headerlink" title="17.1 优雅的错误处理"></a>17.1 优雅的错误处理</h3><p>减少错误处理代码是一种策略是： 将程序中不会出错的部分和包含潜在错误隐患的部分隔离开来</p>
<p>对于不得不返回错误的代码，应尽力简化相应的错误处理代码</p>
<h3 id="17-2-go的谚语"><a href="#17-2-go的谚语" class="headerlink" title="17.2 go的谚语"></a>17.2 go的谚语</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Errors are value， </span><br><span class="line">Do not just check erros， handle them gracefully <span class="comment"># 除了检查错误，还要优雅的处理它们</span></span><br><span class="line">Do not panic</span><br><span class="line"></span><br><span class="line">Make the zero value useful</span><br><span class="line"></span><br><span class="line">the bigger the interface, the weaker the abstraction <span class="comment"># interface越大，抽象度越差</span></span><br><span class="line"></span><br><span class="line">interface &#123;&#125; says nothing <span class="comment"># interface&#123;&#125; 相当于什么都没定义，可以表示任意类型</span></span><br><span class="line"></span><br><span class="line">Gofmt is style is no one is favorite, yet gofmt is everyone is favorite <span class="comment"># gofmt的样式所有人都不喜欢，但gofmt 所有人都喜欢</span></span><br><span class="line"></span><br><span class="line">Doc is <span class="keyword">for</span> users</span><br><span class="line"></span><br><span class="line">a litter copying is better than a little dependency <span class="comment"># 少许的拷贝要比少许的依赖要好</span></span><br><span class="line"></span><br><span class="line">clear is better than clever</span><br><span class="line"><span class="comment"># 清晰比聪明更好</span></span><br><span class="line"></span><br><span class="line">concurrency is not parallelism</span><br><span class="line"><span class="comment"># 并发并不是并行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> not communicate by sharing memory, share memory by communicating</span><br><span class="line"><span class="comment"># 不要通过共享内存来进行通信,通过通信来共享内存</span></span><br><span class="line"></span><br><span class="line">channels orchestrate； mutexes serialize</span><br><span class="line"><span class="comment"># channels 应该进行编排，mutexes（互斥量）按序列化执行</span></span><br></pre></td></tr></table></figure>



<h3 id="17-3-文件写入"><a href="#17-3-文件写入" class="headerlink" title="17.3 文件写入"></a>17.3 文件写入</h3><p>写入文件的时候可能出错：</p>
<ul>
<li>路径不正确</li>
<li>权限不够</li>
<li>磁盘空间不足</li>
</ul>
<p>文件写入完毕后，必须被关闭，确保文件被刷到磁盘上，避免资源的泄漏；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f, err := os.Create(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入到 f文件内</span></span><br><span class="line">	_, err = fmt.Fprintln(f, <span class="string">"Errors are values."</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// write error</span></span><br><span class="line">		f.Close()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = fmt.Fprintln(f, <span class="string">"Do not just check erros, handle them gracefully"</span>)</span><br><span class="line">	f.Close()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := proverbs(<span class="string">"proverbs.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-4-内置类型-error"><a href="#17-4-内置类型-error" class="headerlink" title="17.4 内置类型 error"></a>17.4 内置类型 error</h3><p>内置类型error用来表示错误</p>
<h2 id="18-defer关键字"><a href="#18-defer关键字" class="headerlink" title="18 defer关键字"></a>18 defer关键字</h2><p>使用defer关键字，Go可以确保<code>所有deferred的动作可以在函数返回前执行</code>；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f, err := os.Create(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入到 f文件内</span></span><br><span class="line">	_, err = fmt.Fprintln(f, <span class="string">"Errors are values."</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// write error</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = fmt.Fprintln(f, <span class="string">"Do not just check erros, handle them gracefully"</span>)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := proverbs(<span class="string">"proverbs.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以defer任意的函数和方法</p>
<p>defer并不是专门做错误处理的；</p>
<p>defer可以消除必须时刻惦记执行资源释放的负担</p>
<h3 id="18-1-defer的动作什么时候会被执行"><a href="#18-1-defer的动作什么时候会被执行" class="headerlink" title="18.1 defer的动作什么时候会被执行"></a>18.1 defer的动作什么时候会被执行</h3><p>有创意的错误处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> safeWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	w   io.Writer</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *safeWriter)</span> <span class="title">writeln</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> sw.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	_, sw.err = fmt.Fprintln(sw.w, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f, err := os.Create(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	sw := safeWriter&#123;w: f&#125;</span><br><span class="line">	sw.writeln(<span class="string">"Errors are values"</span>)</span><br><span class="line">	sw.writeln(<span class="string">"Do not juse check errors, handle them gracefully"</span>)</span><br><span class="line">	sw.writeln(<span class="string">"do not panic"</span>)</span><br><span class="line">	<span class="keyword">return</span> sw.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-2-New-error"><a href="#18-2-New-error" class="headerlink" title="18.2 New error"></a>18.2 New error</h3><p>erros包里有一个构造用New函数，它接收string作为参数用来表示错误信息。该函数返回error类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	g[row][column] = digit</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g Grid</span><br><span class="line">	err := g.Set(<span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"An error occurred: %v, \n"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// An error occurred: out of bounds,</span></span><br><span class="line">		<span class="comment">// exit status 1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<p>错误信息应具有信息性</p>
<p>可以把错误信息当作用户界面的一部分，无论对最终用户还是开发者；</p>
<h3 id="18-3-按需返回错误"><a href="#18-3-按需返回错误" class="headerlink" title="18.3 按需返回错误"></a>18.3 按需返回错误</h3><p>按照惯例，包含错误信息的变量名应以Err开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// 按惯例，包含错误信息的变量名应以Err开头</span></span><br><span class="line">	ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">	ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrBounds</span><br><span class="line">	&#125;</span><br><span class="line">	g[row][column] = digit</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g Grid</span><br><span class="line">	err := g.Set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> ErrBounds, ErrDigit:</span><br><span class="line">			fmt.Println(<span class="string">"Les erreurs de parametres hors limites."</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>errors.New 这个构造函数是使用指针实现的，所以上例中的switch语句比较的是内存地址，而不是错误包含的文字信息</p>
<h3 id="18-4-自定义错误类型"><a href="#18-4-自定义错误类型" class="headerlink" title="18.4 自定义错误类型"></a>18.4 自定义错误类型</h3><p>error类型是一个内置的接口：任何类型只要实现了返回string的Error()方法就满足了该接口；</p>
<p>可以创建新的错误类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">	ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SudokuError []error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(se SudokuError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, err := <span class="keyword">range</span> se &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(s, <span class="string">", "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> errs SudokuError</span><br><span class="line">	<span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, ErrBounds)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !validDigit(digit) &#123;</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, ErrDigit)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errs</span><br><span class="line">	&#125;</span><br><span class="line">	g[row][column] = digit</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">int8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> digit &gt;= <span class="number">1</span> &amp;&amp; digit &lt;= <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g Grid</span><br><span class="line">	err := g.Set(<span class="number">12</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> ErrBounds, ErrDigit:</span><br><span class="line">			fmt.Println(<span class="string">"Les erreurs de parametres hors limites."</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out of bounds, invalid digit</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br></pre></td></tr></table></figure>

<p>按照惯例， 自定义错误类型的名字应以Error结尾</p>
<ul>
<li>有时候名字就是Error，例如 url.Error</li>
</ul>
<h3 id="18-5-类型断言"><a href="#18-5-类型断言" class="headerlink" title="18.5 类型断言"></a>18.5 类型断言</h3><p>上例中，我们可以使用类型断言来访问每一种错误；</p>
<p>使用类型断言，你可以把接口类型转化成底层的具体类型</p>
<ul>
<li>例如： err.(SudokuError)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">	ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SudokuError []error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(se SudokuError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, err := <span class="keyword">range</span> se &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(s, <span class="string">", "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> errs SudokuError</span><br><span class="line">	<span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, ErrBounds)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !validDigit(digit) &#123;</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, ErrDigit)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errs</span><br><span class="line">	&#125;</span><br><span class="line">	g[row][column] = digit</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">int8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> digit &gt;= <span class="number">1</span> &amp;&amp; digit &lt;= <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g Grid</span><br><span class="line">	err := g.Set(<span class="number">10</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 使用类型错误断言，</span></span><br><span class="line">		<span class="keyword">if</span> errs, ok := err.(SudokuError); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%d error(s) occurred: \n"</span>, <span class="built_in">len</span>(errs))</span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> errs &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"- %v\n"</span>, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - out of bounds</span></span><br><span class="line"><span class="comment">// - invalid digit</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br></pre></td></tr></table></figure>



<p>如果类型满足多个接口，那么类型断言使它从一个接口类型转化为另一个接口类型</p>
<h3 id="18-6-do-not-panic（不要恐慌）"><a href="#18-6-do-not-panic（不要恐慌）" class="headerlink" title="18.6 do not panic（不要恐慌）"></a>18.6 do not panic（不要恐慌）</h3><p>Go没有异常，它有个类似机制panic</p>
<p>当panic发生，那么程序就会崩溃</p>
<h3 id="18-7-其它语言的异常-vs-Go的错误值"><a href="#18-7-其它语言的异常-vs-Go的错误值" class="headerlink" title="18.7 其它语言的异常 vs Go的错误值"></a>18.7 其它语言的异常 vs Go的错误值</h3><p>其它语言的异常在行为和实现上与Go语言的错误值有很大的不同</p>
<ul>
<li>如果函数抛出异常，并且附近没人捕获它，那么它就会 冒泡 到函数的调用者那里，如果还没有人进行捕获，那么就继续“冒泡”到更上层的调用者。。。直到达到栈（Stack）的顶部（例如main函数）</li>
<li>异常这种错误处理方式可被看作是可选的；<ul>
<li>不处理异常，就不需要加入其它代码；</li>
<li>想要处理异常，就需要加入相当数量的专用代码</li>
</ul>
</li>
<li>Go语言中错误值更简单灵活；<ul>
<li>忽略错误是有意识的决定，从代码上看也是显而易见的；</li>
</ul>
</li>
</ul>
<h3 id="18-8-如何panic"><a href="#18-8-如何panic" class="headerlink" title="18.8 如何panic"></a>18.8 如何panic</h3><p>Go里有一个和其它语言异常类似的机制： panic</p>
<p>实际上，panic很少出现</p>
<p>创建panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="string">"i forgot my towel"</span>)</span><br></pre></td></tr></table></figure>

<p>panic的参数可以是任意类型</p>
<h3 id="18-9-错误值、panic、os-Exit"><a href="#18-9-错误值、panic、os-Exit" class="headerlink" title="18.9 错误值、panic、os.Exit"></a>18.9 错误值、panic、os.Exit</h3><p>通常，更推荐使用错误值，其次才是panic</p>
<p>panic比Os.Exit更好： panic后会执行所有defer的动作，而Os.Exit则不会</p>
<p>有时候Go程序会panic而不是返回错误值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> zero <span class="keyword">int</span></span><br><span class="line">	_ = <span class="number">42</span> / zero</span><br><span class="line">	<span class="comment">// panic: runtime error: integer divide by zero</span></span><br><span class="line">	<span class="comment">// exit status 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止panic导致程序崩溃，Go提供了recover函数(恢复)</p>
<p>defer的动作会在函数返回前执行，即使发生了panic</p>
<p>但如果defer的函数调用了recover，panic就会停止，程序将继续运行；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// defer会在函数返回前执行，即使发生panic</span></span><br><span class="line">		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;<span class="comment">// defer调用recover，panic就会停止，程序将继续执行</span></span><br><span class="line">			fmt.Println(e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"i forgot my towel"</span>)</span><br><span class="line">	<span class="comment">// i forgot my towel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-goroutine和并发（concurrent）"><a href="#19-goroutine和并发（concurrent）" class="headerlink" title="19 goroutine和并发（concurrent）"></a>19 goroutine和并发（concurrent）</h2><h3 id="19-1-goroutine"><a href="#19-1-goroutine" class="headerlink" title="19.1 goroutine"></a>19.1 goroutine</h3><p>在Go中，独立的任务叫做goroutine</p>
<ul>
<li>虽然goroutine与其它语言中的协程、进程、线程都有相似之处，但goroutine和它们并不完全相同</li>
<li>goroutine和它们并不完全相同，</li>
<li>Goroutine创建效率非常高</li>
<li>Go能直截了当的协同多个并发（concurrent）操作</li>
</ul>
<p>在某些语言中，将顺序式代码转化为并发式代码需要做大量修改。</p>
<p>在Go里，无需修改现有顺序式的代码，就可以通过goroutine以并发的方式运行任意数量的任务；</p>
<h3 id="19-2-启动goroutine"><a href="#19-2-启动goroutine" class="headerlink" title="19.2 启动goroutine"></a>19.2 启动goroutine</h3><p>只需在调用前面加一个go关键字；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> sleepGopher() <span class="comment">// go 关键字相当于启动一个 goroutine,另开辟了一条道路，在那条道路里面执行。然后main函数是一条主干道。主干道继续往下执行，当main函数返回的时候，该程序运行的所有goroutine都会立即停止，无论有没有走完。所以想在main函数返回之前让 sleepGopher 函数输出 ...snore... 的话，就需要多等待一段时间，已知 sleepGopher sleep了3秒，所以选择让main函数sleep了4秒</span></span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">// 3*time.Second = 3s</span></span><br><span class="line">	fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-3-不止一个goroutine"><a href="#19-3-不止一个goroutine" class="headerlink" title="19.3 不止一个goroutine"></a>19.3 不止一个goroutine</h3><p>每次使用go关键字都会产生一个新的goroutine</p>
<p>表面上看，goroutine似乎在同时运行，但由于计算机处理单元有限，其实技术上来说，这些goroutine不是真的在同时运行；</p>
<ul>
<li>计算机处理器会使用“分时”技术，在多个goroutine上轮流花费一些时间；</li>
<li>在使用goroutine时，各个goroutine的执行顺序无法确定；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="19-3-1-goroutine的参数"><a href="#19-3-1-goroutine的参数" class="headerlink" title="19.3.1 goroutine的参数"></a>19.3.1 goroutine的参数</h4><p>向goroutine传递参数就根向函数传递参数一样，参数都是按值传递的（传入的是副本）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"...snore..."</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...snore... 2</span></span><br><span class="line"><span class="comment">// ...snore... 3</span></span><br><span class="line"><span class="comment">// ...snore... 0</span></span><br><span class="line"><span class="comment">// ...snore... 1</span></span><br><span class="line"><span class="comment">// ...snore... 4</span></span><br></pre></td></tr></table></figure>

<p>在使用goroutine时，各个goroutine的执行顺序无法确定；</p>
<h2 id="20-channel"><a href="#20-channel" class="headerlink" title="20. channel"></a>20. channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher() <span class="comment">// 已知该程序3秒后结束，返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second) <span class="comment">// 所以main函数中，尽量大于3秒的时间来保证所有 goroutine能够足够时间执行完；但有些时候并不能显式的知道 goroutine需要耗费的时间，那么这个时候main函数无法确定什么时间点会有返回值回来；所以也无法确定需要等待的时长。 解决这个问题就需要引入 channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second) </span><br><span class="line">	fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel可以在多个goroutine之间安全的传值；</p>
<p>通道可以用作变量、函数参数、结构体字段。。。</p>
<p>创建通道用make函数，并指定其传递数据的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="20-1-channel（通道）发送、接收"><a href="#20-1-channel（通道）发送、接收" class="headerlink" title="20.1 channel（通道）发送、接收"></a>20.1 channel（通道）发送、接收</h3><p>使用左箭头操作符 <code>&lt;-</code> 向channel发送值或从channel接收值；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- <span class="number">99</span> <span class="comment">// 向通道发送值， 把值为 99 的值 发送给通道c</span></span><br><span class="line">r:= &lt;- c <span class="comment">// 从通道接收值  从通道c接收一个值，并将此值赋给 r变量</span></span><br></pre></td></tr></table></figure>

<p>发送操作会等待直到另一个goroutine尝试对该channel进行接收操作为止；</p>
<ul>
<li>执行发送操作的goroutine在等待期间将无法执行其它操作</li>
<li>未在等待channel操作的goroutine仍然可以继续自由的运行</li>
</ul>
<p>执行接收操作的goroutine将等待直到另一个goroutine尝试向该channel进行发送操作为止；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 一共有5个 </span></span><br><span class="line">    <span class="comment">//gopher会往此通道发送值；</span></span><br><span class="line">		gopherID := &lt;-c <span class="comment">// 当i=0时，等待大约3s之后，有其它gopher给它发送值了。</span></span><br><span class="line">		<span class="comment">// 可能是 0 1 2 3 4 任意一个值，因为goroutine的顺序无法确定</span></span><br><span class="line">		fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"..."</span>, id, <span class="string">"snore ..."</span>)</span><br><span class="line">	c &lt;- id <span class="comment">// 向通道发送值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-2-使用select处理多个通道"><a href="#20-2-使用select处理多个通道" class="headerlink" title="20.2 使用select处理多个通道"></a>20.2 使用select处理多个通道</h3><p>前面的例子中是使用一个channel来等待多个 goroutine，这种做法在所有goroutine都产生相同类型值的时候是好用的。但实际开发中，情况并不只是如此；程序通常需要等待不同类型的值；</p>
<p>当等待通道中某些值的时候，不想等太久。或者想在网络请求等待数秒之后就将其设置为超时而不是白白等待好几分钟。go标准库提供了一个time.After函数，该函数返回一个channel，该channel在指定时间后会接收到一个值（这个值是由go运行时的一个goroutine发送的 ）；</p>
<p>如果程序想继续从goroutine接收值，那必须等到所有goroutine都结束睡眠或我们耐心耗尽为止。这意味着程序必须同时等到time.After这个计时器channel 和其它channel。这个时候就能使用select语句。select语句能做到这一点。</p>
<p>select语句与switch有点像</p>
<ul>
<li>该语句包含的每个case都持有一个通道，用来发送或接收数据；</li>
<li>select会等待直到某个case分支的操作就绪，然后就会执行该case 分支；</li>
<li>select语句不包含任何case的情况下将永远等下去</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">	&#125;</span><br><span class="line">	timeout := time.After(<span class="number">2</span> * time.Second) </span><br><span class="line">  <span class="comment">// 创建一个超时时间2s 的 channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> gopherID := &lt;-c: <span class="comment">// 从通道接收值</span></span><br><span class="line">			fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout: <span class="comment">//等2s 超时 还未接收到</span></span><br><span class="line">			fmt.Println(<span class="string">"my patience ran out"</span>)</span><br><span class="line">		 	<span class="keyword">return</span> <span class="comment">// return 会跳出select</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Duration(rand.Intn(<span class="number">4000</span>)) * time.Millisecond) <span class="comment">// 生成一个0-4s的随机时间</span></span><br><span class="line">	c &lt;- id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意： 即使已经停止等待goroutine，但只要main函数还没返回，仍在运行的goroutine将会继续占用内存；（有条件，尽量清理掉）</p>
<h3 id="20-3-nil通道"><a href="#20-3-nil通道" class="headerlink" title="20.3 nil通道"></a>20.3 nil通道</h3><blockquote>
<p>值为nil的通道</p>
</blockquote>
<p>如果不使用make初始化channel，那么channel变量的值就是nil(零值)</p>
<p>对nil通道进行发送或接收不会引起panic，但会导致永久阻塞；</p>
<p>对nil通道执行close函数，那么会引起panic</p>
<h4 id="20-3-1-nil通道的用处："><a href="#20-3-1-nil通道的用处：" class="headerlink" title="20.3.1 nil通道的用处："></a>20.3.1 nil通道的用处：</h4><p>对于包含select语句的循环，如果不希望每次循环都等待select所涉及的所有通道，那么可以先将某些channel设置为nil，等到发送值准备就绪之后，再将channel变成一个非nil值并执行发送操作；</p>
<h2 id="21-阻塞和死锁"><a href="#21-阻塞和死锁" class="headerlink" title="21 阻塞和死锁"></a>21 阻塞和死锁</h2><p>当goroutine在等待channel的发送或接收时，我们就说它被阻塞了；</p>
<p>除了goroutine本身占用少量的内存外，被阻塞的goroutine并不消耗任何其它资源；</p>
<ul>
<li>goroutine静静地停在那里，等到导致其阻塞的事情来解除阻塞</li>
</ul>
<p>当一个或多个goroutine因为某些永远无法发生的事情被阻塞时，我们称这种情况为死锁，而出现死锁的程序通常会崩溃或挂起；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引发死锁的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"><span class="comment">// goroutine 1 [chan receive]:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用goroutine 解决死锁问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="number">2</span> &#125;()</span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-2-地鼠装配线"><a href="#21-2-地鼠装配线" class="headerlink" title="21.2 地鼠装配线"></a>21.2 地鼠装配线</h3><p>Go允许在没有值可供发送的情况下通过close函数关闭通道</p>
<ul>
<li>例如close(c)</li>
</ul>
<p>通道被关闭后无法写入任何值，如果尝试写入将引发panic</p>
<p>尝试读取被关闭的通道会获得与通道类型对应的零值；</p>
<p>注意： 如果循环里读取一个已关闭的通道，并没有检查通道是否关闭，那么该循环可能会一直运转下去，耗费大量CPU时间</p>
<p>执行以下代码可得知通道是否被关闭</p>
<p><code>v,ok := &lt;-c</code> v为通道得到的值，ok bool类型，如果ok为false，那么说明此通道已关闭；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">		downstream &lt;- v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// downstream &lt;- ""</span></span><br><span class="line">	<span class="comment">// 重构为</span></span><br><span class="line">	<span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		item, ok := &lt;-upstream</span><br><span class="line">		<span class="comment">// if item == "" &#123; 重构</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">//	downstream &lt;- ""</span></span><br><span class="line">			<span class="built_in">close</span>(downstream)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">			downstream &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		v := &lt;-upstream</span><br><span class="line">		<span class="keyword">if</span> v == <span class="string">""</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line">	<span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">	printGopher(c1)</span><br><span class="line">	<span class="comment">// 	hello, world</span></span><br><span class="line">	<span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-3-常用模式"><a href="#21-3-常用模式" class="headerlink" title="21.3 常用模式"></a>21.3 常用模式</h3><p>从通道读取值，直到它关闭为止（常用）</p>
<ul>
<li>可以使用range关键字达到该目的</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">		downstream &lt;- v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// downstream &lt;- ""</span></span><br><span class="line">	<span class="comment">// 重构为</span></span><br><span class="line">	<span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> upstream &#123;</span><br><span class="line">		<span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">			downstream &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(downstream) <span class="comment">// 关闭下游通道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> upstream &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line">	<span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">	printGopher(c1)</span><br><span class="line">	<span class="comment">// 	hello, world</span></span><br><span class="line">	<span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>homework</p>
<ol>
<li>编写一个流水线部件（一个goroutine），他需要记住前面出现的所有值，并且只有在值之前从未出现过的情况下才会将值传递至流水线的下一个阶段，假定第一个值永远不是空字符串</li>
<li>编写一个流水线部件，它接收字符串并将它们拆分成单词，然后向流水线的下一阶段一个接一个发送这些单词（可以用strings.Fields函数）</li>
</ol>
<h2 id="22-并发状态"><a href="#22-并发状态" class="headerlink" title="22 并发状态"></a>22 并发状态</h2><h3 id="22-1-共享值与竞争条件（race-condition）"><a href="#22-1-共享值与竞争条件（race-condition）" class="headerlink" title="22.1 共享值与竞争条件（race condition）"></a>22.1 共享值与竞争条件（race condition）</h3><p>工厂某些生产线出现库存不足的情况，它们需要订购更多的原材料。尽管每条生产线都有固定电话，但是工厂只有一条共享的电话路线。当一个工人拿起电话下订单的时候，另一只地鼠可能会拿起电话拨号。对正在讲话的前一个工人产生干扰，而之后可能还会有其它的工人尝试使用电话。最终就是所有工人一头雾水，订单也无法下达。</p>
<p>为了解决这个问题，工厂工人必须达成某些协议。使得同一时间之内只有一只地鼠使用电话。而go语言里共享值的概念就跟共享电话有些相似。</p>
<p>当有两个或者多个goroutine同时使用共享值的时候，程序可能出错。把这种多个goroutine争相使用值的情况称之为竞争条件或者竞争状态（race condition）而go的compiler实际上包含了尝试在代码里发现静态条件这个功能。</p>
<p>两个goroutine同时读取，并不会产生 race condition。</p>
<h3 id="22-2-Go的互斥锁-mutex"><a href="#22-2-Go的互斥锁-mutex" class="headerlink" title="22.2 Go的互斥锁(mutex)"></a>22.2 Go的互斥锁(mutex)</h3><p>Mutex= mutual exclusive</p>
<p>​                相互的  独占的</p>
<p>一个工厂想出一个很好的主意，在工厂地板中间放置一个玻璃罐，并在玻璃罐中放置了一个金属令牌。每次想要打电话的地鼠都需要从罐子里面取出令牌。然后在打电话的过程中一直持有它。然后打完电话再把它放回到罐子里面。如果有一只地鼠想打电话，但是没有在罐子里面发现令牌。就需要轮训等待直到令牌归还为止。go语言的互斥锁就相当于此玻璃罐。goroutine就可以通过互斥锁阻止其它的goroutine在同一时间进行某些事情。为了保护互斥锁的互斥性质，程序在访问被保护的东西的时候必须得非常的小心。互斥锁有两个方法 <code>Lock</code> 和 <code>Unlock</code>, Lock相当于从金属罐里面取出令牌，Unlock相当于把令牌放回玻璃罐；</p>
<p>如果有goroutine尝试在互斥锁已经锁定的情况下，再调用lock方法，那么它就需要等待解锁之后再次上锁。为了正确使用互斥锁，就要确保锁访问共享值的代码必须先锁定互斥锁，然后才能执行所需的操作。并且在操作完成之后必须解除互斥锁，任何不遵循这一模式的代码都可能引发竞争条件。基于此原因，互斥锁在绝大多数情况下，只会在包内进行使用；这个包会通过互斥锁保护自定义的内容，并将相应的lock和unlock调用，巧妙的隐藏在函数和方法的背后。和channel不一样，互斥锁并未内置在go语言中。而是通过sync包来引入的；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	<span class="comment">// the lock is held until we return from the function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>互斥锁定义在被保护的变量之上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line">1. 当两个goroutine同时修改一个值的时候，会发生什么</span><br><span class="line">2. 尝试对一个已经被锁定的互斥锁进行锁定操作，会发生什么</span><br><span class="line">3. 尝试多一个未被锁定的互斥锁进行解锁操作，会发生什么</span><br><span class="line">4. 同时在多个不同的goroutine里面调用相同类型的方法是安全的吗</span><br></pre></td></tr></table></figure>



<h3 id="22-3-互斥锁的隐患"><a href="#22-3-互斥锁的隐患" class="headerlink" title="22.3 互斥锁的隐患"></a>22.3 互斥锁的隐患</h3><h4 id="22-3-1-死锁"><a href="#22-3-1-死锁" class="headerlink" title="22.3.1  死锁"></a>22.3.1  死锁</h4><p> 如果一个程序锁定之后，它执行的操作很多。就需要越来越加的小心。</p>
<p>如果一个goroutine在锁定互斥锁之后，因为某些事情而被阻塞。那么将要取得互斥锁的其它goroutine就可能会被耽搁很长时间。更严重的是，如果持有互斥锁的goroutine因为某些原因尝试锁定同一个互斥锁就会引发死锁（正在尝试加锁操作的goroutine将永远无法解除已经被锁定的互斥锁，最终导致这个lock调用被永久的阻塞）。</p>
<p>所以为了保证这个互斥锁的使用安全，遵守以下两个原则</p>
<ol>
<li>尽可能的简化互斥锁保护的代码</li>
<li>对每一份共享状态只使用一个互斥锁</li>
</ol>
<h3 id="22-4-长时间运行的工作进程"><a href="#22-4-长时间运行的工作进程" class="headerlink" title="22.4 长时间运行的工作进程"></a>22.4 长时间运行的工作进程</h3><p>工作进程（worker）</p>
<p>把一直存在并且独立运行的goroutine称作为 工作进程</p>
<p>而工作进程通常被写成包含select语句的for循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// wait for channels here.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="22-5-事件循环和goroutine"><a href="#22-5-事件循环和goroutine" class="headerlink" title="22.5 事件循环和goroutine"></a>22.5 事件循环和goroutine</h3><p>事件循环（event loop）</p>
<p>中心循环（central loop）</p>
<p>Go通过提供groutine作为核心概念，消除了对中心循环的需求；</p>
<p>某些编程语言会用事件循环的中心循环来等待时间，并在这个事件发生时调用相应的已注册函数。而go语言则是通过提供goroutine作为核心概念，消除对中心循环的需求。</p>
<p>我们可以把任何工作进程goroutine都看做是独立运行的事件循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"image"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos := image.Point&#123;X: <span class="number">10</span>, Y: <span class="number">10</span>&#125;</span><br><span class="line">	direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">	next := time.After(time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-next:</span><br><span class="line">			pos = pos.Add(direction)</span><br><span class="line">			fmt.Println(<span class="string">"current position is"</span>, pos)</span><br><span class="line">			next = time.After(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	right = command(<span class="number">0</span>)</span><br><span class="line">	left  = command(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoverDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">	commandc <span class="keyword">chan</span> command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoverDriver</span><span class="params">()</span> *<span class="title">RoverDriver</span></span> &#123;</span><br><span class="line">	r := &amp;RoverDriver&#123;</span><br><span class="line">		commandc: <span class="built_in">make</span>(<span class="keyword">chan</span> command),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> r.drive()</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos := image.Point&#123;X: <span class="number">0</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">	direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">	updateInterval := <span class="number">250</span> * time.Millisecond</span><br><span class="line">	nextMove := time.After(updateInterval)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c := &lt;-r.commandc:</span><br><span class="line">			<span class="keyword">switch</span> c &#123;</span><br><span class="line">			<span class="keyword">case</span> right:</span><br><span class="line">				direction = image.Point&#123;X: -direction.Y, Y: direction.X&#125;</span><br><span class="line">			<span class="keyword">case</span> left:</span><br><span class="line">				direction = image.Point&#123;X: direction.Y, Y: -direction.X&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			log.Printf(<span class="string">"new direction %v"</span>, direction)</span><br><span class="line">		<span class="keyword">case</span> &lt;-nextMove:</span><br><span class="line">			pos = pos.Add(direction)</span><br><span class="line">			log.Printf(<span class="string">"moved to %v"</span>, pos)</span><br><span class="line">			nextMove = time.After(updateInterval)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Left</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.commandc &lt;- left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Right</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.commandc &lt;- right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := NewRoverDriver()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	r.Left()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	r.Right()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改代码使得每次移动之间的间隔增加半秒</p>
<p>以RoverDriver类型为基础，定义start方法·stop方法和对应的命令，然后修改代码使得探测器可以接受这两个新命令</p>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2021/03/09/go1/>http://yoursite.com/2021/03/09/go1/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-03-23T17:11:20+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Mar 23, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/doc/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>doc</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2021/03/09/go1/&title=go1 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2021/03/09/go1/&title=go1 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2021/03/09/go1/&title=go1 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2021/03/16/rust/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>rust</p>
                <p class='content'>1. rust123rustc --versionrustup doc # 离线文档rustc main.rs # 编译main.rs  c为compiler

2. cargo12cargo ...</p>
              </a>
            
            
              <a class='next' href='/2021/02/23/webpack5-1/'>
                <p class='title'>webpack5_1<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>Webpack5 boilerplate1. Common2.1 initinstall webpack5 
1npm install webpack webpack-cli --save-de...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'go1',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-编译型语言"><span class="toc-text">1. 编译型语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-install-go"><span class="toc-text">2. install go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-const-var"><span class="toc-text">3. const var</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-短声明"><span class="toc-text">3.1 短声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-运算符"><span class="toc-text">4. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-逻辑运算符"><span class="toc-text">4.1 逻辑运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-包"><span class="toc-text">5. 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-包路径管理"><span class="toc-text">5.1 包路径管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-匿名导包"><span class="toc-text">5.2 匿名导包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-取别名"><span class="toc-text">5.3 取别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Go-modules"><span class="toc-text">5.4 Go modules</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-Go-mod-命令"><span class="toc-text">5.4.1 Go mod 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-Go-mod环境变量"><span class="toc-text">5.4.2 Go mod环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-go-mod-初始化项"><span class="toc-text">5.4.3 go mod  初始化项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-修改项目模块的版本依赖关系"><span class="toc-text">5.4.4 修改项目模块的版本依赖关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-循环-分支"><span class="toc-text">6 循环 分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Boolean类型"><span class="toc-text">6.1 Boolean类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-strings-Contains"><span class="toc-text">6.2 strings.Contains</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-compare"><span class="toc-text">6.3 compare</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-if"><span class="toc-text">6.4 if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-swtch"><span class="toc-text">6.6 swtch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-循环"><span class="toc-text">6.7 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-变量的作用域"><span class="toc-text">6.8 变量的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-数据类型"><span class="toc-text">7. 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-声明浮点型变量"><span class="toc-text">7.1 声明浮点型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-单精度浮点数类型"><span class="toc-text">7.2 单精度浮点数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-单双精度的使用场景"><span class="toc-text">7.3 单双精度的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-零值"><span class="toc-text">7.4 零值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-显示浮点类型"><span class="toc-text">7.5 显示浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-整数类型"><span class="toc-text">7.6 整数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-int-和-uint"><span class="toc-text">7.6.1 int 和 uint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2-uint8"><span class="toc-text">7.6.2 uint8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-输出数据类型"><span class="toc-text">7.7 输出数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-文本"><span class="toc-text">7.8 文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-1-声明字符串"><span class="toc-text">7.8.1 声明字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-类型转换"><span class="toc-text">7.9 类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-函数"><span class="toc-text">8. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-函数声明"><span class="toc-text">8.1 函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-方法"><span class="toc-text">8.2 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-通过方法添加行为"><span class="toc-text">8.2.1 通过方法添加行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-方法调用"><span class="toc-text">8.2.2 方法调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-一等函数"><span class="toc-text">8.3 一等函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-多返回值"><span class="toc-text">8.4 多返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-数组"><span class="toc-text">9 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-数组的复制"><span class="toc-text">9.1 数组的复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-slice"><span class="toc-text">10 slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-slice的字面值"><span class="toc-text">10.1 slice的字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-声明slice"><span class="toc-text">10.2 声明slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-带有方法的切片"><span class="toc-text">10.3 带有方法的切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-append函数"><span class="toc-text">10.4 append函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-长度和容量"><span class="toc-text">10.5 长度和容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-三个索引的切分操作"><span class="toc-text">10.6 三个索引的切分操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-使用make函数对slice进行预分配"><span class="toc-text">10.7 使用make函数对slice进行预分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-声明可变参数的函数"><span class="toc-text">10.8 声明可变参数的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-map"><span class="toc-text">11. map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-声明"><span class="toc-text">11.1 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-map不会被复制"><span class="toc-text">11.2 map不会被复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-使用make对map进行预分配"><span class="toc-text">11.3 使用make对map进行预分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-struct"><span class="toc-text">12. struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-声明"><span class="toc-text">12.1 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-将struct编码为JSON"><span class="toc-text">12.2 将struct编码为JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-使用struct标签来自定义JSON"><span class="toc-text">12.3 使用struct标签来自定义JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1-结构体标签在json中的应用"><span class="toc-text">12.3.1 结构体标签在json中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-将方法关联到struct"><span class="toc-text">12.4 将方法关联到struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-构造函数"><span class="toc-text">12.4.1 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2-New函数"><span class="toc-text">12.4.2 New函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-class的替代方案"><span class="toc-text">12.5 class的替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-反射"><span class="toc-text">12.6 反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-组合和转发"><span class="toc-text">13. 组合和转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-组合"><span class="toc-text">13.1 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-转发方法"><span class="toc-text">13.2 转发方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-命名冲突"><span class="toc-text">13.3 命名冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-继承还是组合"><span class="toc-text">13.4 继承还是组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-接口"><span class="toc-text">14. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-接口类型"><span class="toc-text">14.1 接口类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-探索接口"><span class="toc-text">14.2 探索接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-满足接口"><span class="toc-text">14.3 满足接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-指针"><span class="toc-text">15 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-amp-和"><span class="toc-text">15.1 &amp; 和 *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-指针类型"><span class="toc-text">15.2 指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-指针就是用来指向的"><span class="toc-text">15.3 指针就是用来指向的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-指向结构的指针"><span class="toc-text">15.4 指向结构的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-指向数组的指针"><span class="toc-text">15.5 指向数组的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-1-修改数组"><span class="toc-text">15.5.1  修改数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-2-什么情况下应该使用指向数组的指针"><span class="toc-text">15.5.2 什么情况下应该使用指向数组的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-3-slice指向数组"><span class="toc-text">15.5.3 slice指向数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-4-指针和接口"><span class="toc-text">15.5.4 指针和接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-6-实现修改"><span class="toc-text">15.6 实现修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-7-指针接收者"><span class="toc-text">15.7 指针接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-内部指针"><span class="toc-text">15.8 内部指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9-小结"><span class="toc-text">15.9 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-nil"><span class="toc-text">16. nil</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-nil会导致panic"><span class="toc-text">16.1 nil会导致panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-nil函数值"><span class="toc-text">16.2 nil函数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-nil-slice"><span class="toc-text">16.3 nil slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-nil-map"><span class="toc-text">16.4 nil map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-nil接口"><span class="toc-text">16.5 nil接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-nil之外的另一个选择"><span class="toc-text">16.6 nil之外的另一个选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-处理错误"><span class="toc-text">17 处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-优雅的错误处理"><span class="toc-text">17.1 优雅的错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-go的谚语"><span class="toc-text">17.2 go的谚语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-文件写入"><span class="toc-text">17.3 文件写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-内置类型-error"><span class="toc-text">17.4 内置类型 error</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-defer关键字"><span class="toc-text">18 defer关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-defer的动作什么时候会被执行"><span class="toc-text">18.1 defer的动作什么时候会被执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-New-error"><span class="toc-text">18.2 New error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-按需返回错误"><span class="toc-text">18.3 按需返回错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-自定义错误类型"><span class="toc-text">18.4 自定义错误类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-类型断言"><span class="toc-text">18.5 类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-do-not-panic（不要恐慌）"><span class="toc-text">18.6 do not panic（不要恐慌）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-7-其它语言的异常-vs-Go的错误值"><span class="toc-text">18.7 其它语言的异常 vs Go的错误值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-8-如何panic"><span class="toc-text">18.8 如何panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-9-错误值、panic、os-Exit"><span class="toc-text">18.9 错误值、panic、os.Exit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-goroutine和并发（concurrent）"><span class="toc-text">19 goroutine和并发（concurrent）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-goroutine"><span class="toc-text">19.1 goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-启动goroutine"><span class="toc-text">19.2 启动goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-不止一个goroutine"><span class="toc-text">19.3 不止一个goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#19-3-1-goroutine的参数"><span class="toc-text">19.3.1 goroutine的参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-channel"><span class="toc-text">20. channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-channel（通道）发送、接收"><span class="toc-text">20.1 channel（通道）发送、接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-使用select处理多个通道"><span class="toc-text">20.2 使用select处理多个通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-nil通道"><span class="toc-text">20.3 nil通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-1-nil通道的用处："><span class="toc-text">20.3.1 nil通道的用处：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-阻塞和死锁"><span class="toc-text">21 阻塞和死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-2-地鼠装配线"><span class="toc-text">21.2 地鼠装配线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-3-常用模式"><span class="toc-text">21.3 常用模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-并发状态"><span class="toc-text">22 并发状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-1-共享值与竞争条件（race-condition）"><span class="toc-text">22.1 共享值与竞争条件（race condition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-2-Go的互斥锁-mutex"><span class="toc-text">22.2 Go的互斥锁(mutex)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-互斥锁的隐患"><span class="toc-text">22.3 互斥锁的隐患</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#22-3-1-死锁"><span class="toc-text">22.3.1  死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-4-长时间运行的工作进程"><span class="toc-text">22.4 长时间运行的工作进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-事件循环和goroutine"><span class="toc-text">22.5 事件循环和goroutine</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
