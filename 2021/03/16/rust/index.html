<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>rust - Hexo</title>
  
    <meta name="keywords" content="doc">
  
  
    <meta name="description" content="rust语法">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2021/03/16/rust/">
      rust
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/rust/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>rust</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Mar 16, 2021</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="1-rust"><a href="#1-rust" class="headerlink" title="1. rust"></a>1. rust</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br><span class="line">rustup doc <span class="comment"># 离线文档</span></span><br><span class="line">rustc main.rs <span class="comment"># 编译main.rs  c为compiler</span></span><br></pre></td></tr></table></figure>

<h2 id="2-cargo"><a href="#2-cargo" class="headerlink" title="2. cargo"></a>2. cargo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo --version</span><br><span class="line">cargo new hello_cargo <span class="comment"># 创建一个 hello_cargo的项目</span></span><br></pre></td></tr></table></figure>



<h3 id="2-1-cargo-toml"><a href="#2-1-cargo-toml" class="headerlink" title="2.1 cargo.toml"></a>2.1 cargo.toml</h3><blockquote>
<p>TOML (Tom’s Obvious Minimal Language) 格式，是Cargo是配置格式</p>
</blockquote>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span>  <span class="comment"># 区域标题，表示下方内容是用来配置包（package）的</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"hello_cargo"</span>  <span class="comment"># 项目名</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"ruanhan1988 &lt;2856197796@qq.com&gt;"</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">"2018"</span> <span class="comment"># 使用的rust版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> <span class="comment"># 区域标题， 另一个区域的开始，它会列出项目的依赖项</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-crate"><a href="#2-2-crate" class="headerlink" title="2.2 crate"></a>2.2 crate</h3><blockquote>
<p>在rust里面， 代码的包称为crate</p>
</blockquote>
<h3 id="2-3-非cargo创建的项目"><a href="#2-3-非cargo创建的项目" class="headerlink" title="2.3 非cargo创建的项目"></a>2.3 非cargo创建的项目</h3><blockquote>
<p>非cargo创建的项目，转化为使用cargo</p>
</blockquote>
<ol>
<li>把源代码文件移动到src下</li>
<li>创建Cargo.html并填写相应的配置</li>
</ol>
<h3 id="2-4-Cargo-构建项目"><a href="#2-4-Cargo-构建项目" class="headerlink" title="2.4 Cargo 构建项目"></a>2.4 Cargo 构建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build <span class="comment"># 构建</span></span><br><span class="line"><span class="comment"># 会创建出来一个可执行文件: target/debug/hello_cargo 或 target\debug\hello_cargo.exe</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-cargo-lock"><a href="#2-4-1-cargo-lock" class="headerlink" title="2.4.1 cargo.lock"></a>2.4.1 cargo.lock</h4><blockquote>
<p>第一次运行 cargo build会在项目目录生成 cargo.lock文件</p>
</blockquote>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is automatically @generated by Cargo.</span></span><br><span class="line"><span class="comment"># It is not intended for manual editing.</span></span><br><span class="line"><span class="section">[[package]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"hello_cargo"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br></pre></td></tr></table></figure>

<p>该文件负责追踪项目以来的精确版本</p>
<p>不需要手动修改该文件</p>
<h3 id="2-5-构建和运行cargo项目"><a href="#2-5-构建和运行cargo项目" class="headerlink" title="2.5 构建和运行cargo项目"></a>2.5 构建和运行cargo项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p>如果源代码没有更改，直接运行上次生成的二进制文件；</p>
<h3 id="2-6-cargo-check"><a href="#2-6-cargo-check" class="headerlink" title="2.6 cargo check"></a>2.6 cargo check</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check <span class="comment"># 检查代码，确保能通过编译，但是不产生任何可执行文件；</span></span><br></pre></td></tr></table></figure>

<p>cargo check效率较build命令高很多，编写代码时，可反复使用cargo check检查代码，提高效率；</p>
<h3 id="2-7-发布"><a href="#2-7-发布" class="headerlink" title="2.7 发布"></a>2.7 发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br><span class="line"><span class="comment"># 编译时会进行优化, 代码会运行更快，但是编译时间更长</span></span><br><span class="line"><span class="comment"># 会在 target/release 而不是 target/debug 生成可执行文件</span></span><br></pre></td></tr></table></figure>



<h3 id="2-8-添加依赖包"><a href="#2-8-添加依赖包" class="headerlink" title="2.8 添加依赖包"></a>2.8 添加依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.html</span></span><br><span class="line">[package]</span><br><span class="line">name = <span class="string">"guessing_number"</span></span><br><span class="line">version = <span class="string">"0.1.0"</span></span><br><span class="line">authors = [<span class="string">"ruanhan1988 &lt;2856197796@qq.com&gt;"</span>]</span><br><span class="line">edition = <span class="string">"2018"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">rand = <span class="string">"0.3.14"</span>   <span class="comment"># 添加依赖包</span></span><br></pre></td></tr></table></figure>

<p>在dependencies区域下，直接填写 rand = “0.3.14”即可；</p>
<h2 id="3-guess-number-pro"><a href="#3-guess-number-pro" class="headerlink" title="3. guess number-pro"></a>3. guess number-pro</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess number"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess a number"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> guess =  <span class="built_in">String</span>::new(); <span class="comment">// 创建一个可变的变量，rust中变量默认是 immutable的</span></span><br><span class="line">    <span class="comment">// String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码</span></span><br><span class="line">    <span class="comment">// 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数</span></span><br><span class="line">    <span class="comment">// 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法</span></span><br><span class="line">    </span><br><span class="line">    io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br><span class="line">    <span class="comment">// rust中，引用默认也是不可变的，添加mut关键字，使其变为可变</span></span><br><span class="line">    <span class="comment">// &amp;mut guess 即指guess的引用  .expect 如果读取发生错误，程序崩溃退出；</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"you guess the number is: &#123;&#125;"</span>, guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-read-line"><a href="#3-1-read-line" class="headerlink" title="3.1 read_line"></a>3.1 read_line</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_line</span></span>(&amp;<span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">usize</span>&gt;</span><br><span class="line"><span class="comment">// read_line 有一个叫 io::Result 类型的返回值，在rust标准库中，有很多类型都叫做Result。既有通用的result（范型的result），也有特定版本，子模块的Result，比如io::Result, Result类型实际上枚举类型，一个枚举类型有几个固定的值，这些值称做是这些枚举类型的变体。而io::Result枚举类型一共两个变体，Ok和Err</span></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-完整代码"><a href="#3-2-完整代码" class="headerlink" title="3.2 完整代码"></a>3.2 完整代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering; <span class="comment">// Ording 枚举类型</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="comment">// 默认情况下，rust会将 一个叫 prelude的模块 导入到每个程序的作用域中，</span></span><br><span class="line"><span class="comment">// 如果需要使用的类型不在 prelude里面，就需要显式的导入 比如 use std::io</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess number"</span>);</span><br><span class="line">    <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// loop 添加一个无限循环</span></span><br><span class="line">    <span class="keyword">loop</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"guess a number"</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guess =  <span class="built_in">String</span>::new(); <span class="comment">// 创建一个可变的变量，rust中变量默认是 immutable的</span></span><br><span class="line">        <span class="comment">// String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码</span></span><br><span class="line">        <span class="comment">// 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数</span></span><br><span class="line">        <span class="comment">// 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br><span class="line">        <span class="comment">// rust中，引用默认也是不可变的，添加mut关键字，使其变为可变</span></span><br><span class="line">        <span class="comment">// &amp;mut guess 即指guess的引用  .expect 如果读取发生错误，程序崩溃退出；</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"you guess the number is: &#123;&#125;"</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在rust中允许使用同名的新变量来 shadow原来同名的旧变量，也就是说从声明新guess之后，</span></span><br><span class="line">        <span class="comment">// 代码中出现的guess变量都将是这个 u32类型的变量；这种用法通常使用在需要有类型转换的场景</span></span><br><span class="line">        <span class="comment">// 中，我们复用guess这个名而无需创建新的变量名；</span></span><br><span class="line">       <span class="comment">// let guess:u32 = guess.trim().parse().expect("plase type a number"); // parse返回值是Result，所以可以使用expect处理未来可能存在的异常</span></span><br><span class="line">       <span class="keyword">let</span> guess:<span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse()&#123;<span class="comment">// 使用match 提高程序健壮性</span></span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"valid number"</span>);</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="comment">// 非合法数字，直接continue</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match关键字， 根据cmp返回的Ordering 这个枚举类型的值来决定下一步来做什么。</span></span><br><span class="line">        <span class="comment">// 而match表达式 是有多个 arm /分支 组成的；</span></span><br><span class="line">        <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123; <span class="comment">// cmp  compare 返回值 Ordering</span></span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"Too small!"</span>), <span class="comment">// arm</span></span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"To big!"</span>), <span class="comment">// arm</span></span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"you win"</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出 match</span></span><br><span class="line">            &#125;, <span class="comment">// arm</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-通用编程概念"><a href="#4-通用编程概念" class="headerlink" title="4. 通用编程概念"></a>4. 通用编程概念</h2><h3 id="4-1-变量与可变性"><a href="#4-1-变量与可变性" class="headerlink" title="4.1 变量与可变性"></a>4.1 变量与可变性</h3><p>声明变量用let</p>
<p>默认情况，变量是immutable</p>
<p>声明变量，在变量前面加上mut，就可以使变量可变；</p>
<h4 id="4-1-1-变量与常量"><a href="#4-1-1-变量与常量" class="headerlink" title="4.1.1 变量与常量"></a>4.1.1 变量与常量</h4><blockquote>
<p>常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别：</p>
</blockquote>
<p>不可以使用mut，常量永远都是不可变的；</p>
<p>声明变量使用const关键字，它的类型必须被标注；</p>
<p>常量可以在任何作用域内进行声明，包括全局作用域</p>
<p>常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值；</p>
<p>在程序运行期间，常量在其声明的作用域内一直有效</p>
<p>命名规范： Rust里常量使用全大写字母，每个单词之间用下划线分开；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_POINTS:<span class="built_in">u32</span> = <span class="number">100_00</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-Shadowing-隐藏"><a href="#4-1-2-Shadowing-隐藏" class="headerlink" title="4.1.2 Shadowing(隐藏)"></a>4.1.2 Shadowing(隐藏)</h4><blockquote>
<p> 可以使用相同的名字声明新的变量，新的变量就会shadow（隐藏）之前声明的同名变量</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> x = x+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> x = x*<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 在后续的代码中这个变量名代表的就是新的变量；</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"value is &#123;&#125;"</span>, x); <span class="comment">// 12  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-shadow与mut"><a href="#4-1-3-shadow与mut" class="headerlink" title="4.1.3 shadow与mut"></a>4.1.3 shadow与mut</h4><blockquote>
<p> Shadow和把变量标记为mut是不一样的，</p>
</blockquote>
<p>如果不使用let关键字，那么重新给非mut的变量赋值会导致编译时错误</p>
<p>而使用let声明的同名新变量，也是不可变的；</p>
<p>使用let声明的同名新变量，它的类型可以与之前不同；</p>
<h3 id="4-2-数据类型"><a href="#4-2-数据类型" class="headerlink" title="4.2 数据类型"></a>4.2 数据类型</h3><p>Rust是静态编译语言，在编译时必须知道所有变量的类型；</p>
<p>基于使用的值，编译器通常能够推断出它的具体类型；</p>
<p>但如果可能的类型比较多（例如把String转为整数的parse方法），就必须添加类型的</p>
<p>标注，否则编译会报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = '<span class="number">42</span>'.parse(); <span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> num:<span class="built_in">u32</span> = '<span class="number">42</span>'.parse <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>



<h4 id="4-2-1-标量类型"><a href="#4-2-1-标量类型" class="headerlink" title="4.2.1 标量类型"></a>4.2.1 标量类型</h4><blockquote>
<p>一个标量类型代表一个单个的值；</p>
</blockquote>
<p>Rust有四个主要的标量类型：</p>
<h5 id="4-2-1-1-整数类型"><a href="#4-2-1-1-整数类型" class="headerlink" title="4.2.1.1 整数类型"></a>4.2.1.1 整数类型</h5><p>整数类型没有小数部分</p>
<p>例如u32就是一个无符号的整数类型，占据32位的空间</p>
<p>无符号 以u开头</p>
<p>有符号 以i开头</p>
<p><strong>Rust的整数类型列表如图</strong></p>
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p><strong>isize 和 usize类型</strong></p>
<p>isize 和 usize类型的位数由程序运行的计算机的架构所决定</p>
<p>如果是64位计算机，那就是64位，如果32位计算机，就是32位；</p>
<p>使用isize和usize 的主要场景是针对某中集合进行索引操作；</p>
<h5 id="4-2-1-2-浮点类型"><a href="#4-2-1-2-浮点类型" class="headerlink" title="4.2.1.2 浮点类型"></a>4.2.1.2 浮点类型</h5><p>f32</p>
<p>f64</p>
<h5 id="4-2-1-3-布尔类型"><a href="#4-2-1-3-布尔类型" class="headerlink" title="4.2.1.3 布尔类型"></a>4.2.1.3 布尔类型</h5><p>true</p>
<p>false</p>
<h5 id="4-2-1-4-字符类型"><a href="#4-2-1-4-字符类型" class="headerlink" title="4.2.1.4 字符类型"></a>4.2.1.4 字符类型</h5><p>char 4个字节</p>
<h4 id="4-2-2-复合类型"><a href="#4-2-2-复合类型" class="headerlink" title="4.2.2 复合类型"></a>4.2.2 复合类型</h4><blockquote>
<p>复合类型可以将多个值放在一个类型里</p>
</blockquote>
<p>Rust提供了两种基础的复合类型： 元祖（Tuple）、数组</p>
<h5 id="4-2-2-1-Tuple"><a href="#4-2-2-1-Tuple" class="headerlink" title="4.2.2.1 Tuple"></a>4.2.2.1 Tuple</h5><p>Tuple可以将多个类型的多个值放在一个类型里</p>
<p>Tuple的长度是固定的：一旦声明就无法改变</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;, &#123;&#125;"</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h5 id="4-2-2-2-数组"><a href="#4-2-2-2-数组" class="headerlink" title="4.2.2.2 数组"></a>4.2.2.2 数组</h5><p>数组中每个元素的类型必须相同</p>
<p>数组的长度也是固定的</p>
<p><strong>数组的用处</strong></p>
<p>如果想让你的数据存放在stack上而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处；</p>
<p><strong>数组的类型</strong></p>
<p>[类型;  长度]</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>另一种声明数组的方法</p>
<p>如果数组的每个元素都相同，那么可以在：</p>
<p>在中括号里制定初始值；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>;<span class="number">5</span>]; </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<p><strong>访问数组的元素</strong></p>
<p>数组是stack上分配的单个块的内存</p>
<p>可以使用索引来访问数组的元素（例子）</p>
<p>如果访问的索引超出了数组的范围，那么；</p>
<ul>
<li>编译会通过</li>
<li>运行会报错（runtime时会panic）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> mouths = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">let</span> index = [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">let</span> month = months[index[<span class="number">1</span>]]; <span class="comment">// 编译时不会报错，只有运行时才会检测</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, month); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Rust不会允许其继续访问相应的地址的内存；</p>
<h3 id="4-3-函数"><a href="#4-3-函数" class="headerlink" title="4.3 函数"></a>4.3 函数</h3><p>函数名  多个单词用下划线连接；</p>
<p>parameter 行参</p>
<p>arguments 实参</p>
<h4 id="4-3-1-函数的返回值"><a href="#4-3-1-函数的返回值" class="headerlink" title="4.3.1 函数的返回值"></a>4.3.1 函数的返回值</h4><p>在-&gt; 符号后边声明函数返回值的类型，但是不可以为返回值命名；</p>
<p>在rust里面，返回值</p>
<h3 id="4-4-注释"><a href="#4-4-注释" class="headerlink" title="4.4 注释"></a>4.4 注释</h3><h3 id="4-5-控制流"><a href="#4-5-控制流" class="headerlink" title="4.5 控制流"></a>4.5 控制流</h3><h4 id="4-5-1-if-else"><a href="#4-5-1-if-else" class="headerlink" title="4.5.1 if else"></a>4.5.1 if else</h4><p>match 重构多重if else语句</p>
<h4 id="4-5-2-循环"><a href="#4-5-2-循环" class="headerlink" title="4.5.2 循环"></a>4.5.2 循环</h4><p>Rust 提供了三种循环： loop， while 和 for</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">loop</span>&#123; <span class="comment">// 无限循环；</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">   <span class="keyword">while</span> number !== <span class="number">0</span> &#123;</span><br><span class="line">     <span class="comment">///</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-5-2-1-使用for循环遍历集合"><a href="#4-5-2-1-使用for循环遍历集合" class="headerlink" title="4.5.2.1 使用for循环遍历集合"></a>4.5.2.1 使用for循环遍历集合</h5><p>由于for循环的安全，简洁性，所以它在Rust里用的最多；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>例子： 用for循环显示倒计时的例子</strong></p>
<p>载入标准库</p>
<p>Range</p>
<p>指定一个开始数字和一个结束数字，Range可以生成它们之间的数字（不含结束）</p>
<p>rev方法可以反转Range</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"LIFTOFF!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-所有权"><a href="#5-所有权" class="headerlink" title="5. 所有权"></a>5. 所有权</h2><p>所有权是Rust最独特的特性，它让Rust无需GC就可以保证内存安全；</p>
<p>所有程序在运行时都必须管理它们使用计算机内存的方式</p>
<ul>
<li>有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存</li>
<li>在其他语言中，程序员必须显式地分配和释放内存；</li>
</ul>
<p>Rust采用了第三种方式</p>
<ul>
<li>内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则；</li>
<li>当程序运行时，所有权特性不会减慢程序的运行速度；</li>
</ul>
<h3 id="5-1-stack-vs-heap"><a href="#5-1-stack-vs-heap" class="headerlink" title="5.1 stack vs heap"></a>5.1 stack vs heap</h3><p>在像Rust这样的系统级编程语言里，一个值是在stack上还是在heap上对语言的行为和你为什么要做某些决定是有更大的影响的；</p>
<p>在你的代码运行的时候，stack 和 heap都是你可用的内存，但他们的结构很不相同；</p>
<p><strong>存储数据</strong></p>
<p>stack按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO）</p>
<ul>
<li>添加数据叫做压入栈</li>
<li>移除数据叫做弹出栈</li>
</ul>
<p>所有存储在Stack上的数据必须拥有已知的固定的大小；</p>
<ul>
<li>编译时大小未知的数据或运行时大小可能发生变化的数据必须存在heap上</li>
</ul>
<p>heap内存组织性差一点；</p>
<ul>
<li>当你把数据放入heap时，你会请求一定数量的空间</li>
<li>操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址</li>
<li>这个过程叫做heap上进行分配，有时仅仅称为“分配”</li>
</ul>
<p>把值压到stack上不叫分配</p>
<p>因为指针是已知固定大小的，可以把指针存放在stack上。</p>
<ul>
<li>但如果想要实际数据，你必须使用指针来定位；</li>
</ul>
<p>把数据压到stack上要比在heap上分配快得多：</p>
<ul>
<li>因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在stack的顶端</li>
</ul>
<p>在heap上分配空间需要做更多的工作：</p>
<ul>
<li>操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配；</li>
</ul>
<p><strong>访问数据</strong></p>
<p>访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据；</p>
<ul>
<li>对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快</li>
<li>如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack上）</li>
<li>如果数据之间的距离比较远，那么处理速度就会慢一些（heap上）<ul>
<li>在heap上分配大量的空间也是需要时间的；</li>
</ul>
</li>
</ul>
<p><strong>函数调用</strong></p>
<p>调用函数时，值被传入到函数（也包括指向heap的指针），函数本地的变量被压到stack上，当函数结束后，这些值会从stack上弹出；</p>
<h3 id="5-2-所有权存在的原因"><a href="#5-2-所有权存在的原因" class="headerlink" title="5.2 所有权存在的原因"></a>5.2 所有权存在的原因</h3><h4 id="5-2-1-所有权解决的问题"><a href="#5-2-1-所有权解决的问题" class="headerlink" title="5.2.1 所有权解决的问题"></a>5.2.1 所有权解决的问题</h4><p>跟踪代码的哪些部分正在使用heap的哪些数据；</p>
<p>最小化heap上的重复数据量</p>
<p>情理heap上未使用的数据以避免空间不足</p>
<p>一旦懂得所有权，那么就不需要经常去想stack或heap了；</p>
<p>但是知道管理heap数据是所有权存在的原因，这有助于理解它为什么会这样工作；</p>
<h3 id="5-3-所有权规则"><a href="#5-3-所有权规则" class="headerlink" title="5.3 所有权规则"></a>5.3 所有权规则</h3><p>每个值都有一个变量，这个变量是该值的所有者；</p>
<p>每个值同时只能有一个所有者；</p>
<p>当所有者超出作用域（scope）时，该值将被删除；</p>
<h4 id="5-3-1-变量作用域"><a href="#5-3-1-变量作用域" class="headerlink" title="5.3.1 变量作用域"></a>5.3.1 变量作用域</h4><p>scope就是程序中一个项目的有效范围</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="comment">// s不可用</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">"hello"</span>; <span class="comment">// s 可用</span></span><br><span class="line">  <span class="comment">// 可以对s进行相关操作</span></span><br><span class="line">&#125; <span class="comment">// s作用域到此结束， s不再可用；</span></span><br></pre></td></tr></table></figure>



<h4 id="5-3-2-String类型"><a href="#5-3-2-String类型" class="headerlink" title="5.3.2 String类型"></a>5.3.2 String类型</h4><p>Rust还有第二种字符串类型： String</p>
<ul>
<li>在heap上分配，能够存储在编译时未知数量的文本；</li>
</ul>
<h5 id="5-3-2-1-创建String类型的值"><a href="#5-3-2-1-创建String类型的值" class="headerlink" title="5.3.2.1 创建String类型的值"></a>5.3.2.1 创建String类型的值</h5><blockquote>
<p>可以使用from函数从字符串字面值创建出String类型</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">// :: 表示from是String类型下的函数</span></span><br><span class="line"><span class="comment">// 这类字符串是可以被修改的；</span></span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">  s.push_str(<span class="string">", world"</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s); <span class="comment">// hi, world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-3-2-2-内存和分配"><a href="#5-3-2-2-内存和分配" class="headerlink" title="5.3.2.2 内存和分配"></a>5.3.2.2 内存和分配</h5><p><strong>为什么string类型的值可以修改，而字符串字面值不能修改</strong></p>
<ul>
<li>因为它们处理内存的方式不同；</li>
</ul>
<p>字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里；</p>
<ul>
<li>速度快、高效，是因为其不可变性；</li>
</ul>
<p>String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容：</p>
<ul>
<li><p>操作系统必须在运行时来请求内存，</p>
<ul>
<li>这步通过调用String::from来实现</li>
</ul>
</li>
<li><p>当用完String之后，需要使用某种方式将内存返回给操作系统</p>
<ul>
<li><p>这步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存</p>
</li>
<li><p>没有GC，就需要我们去识别内存何时不再使用，并调用代码将它返回；</p>
<ul>
<li>如果忘了，那就浪费内存</li>
<li>如果提前做了，变量就会非法</li>
<li>如果做了两次，就是Bug，必须一次分配对应一次释放；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Rust采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统；</p>
<ul>
<li>drop函数</li>
</ul>
<p>当变量走出作用域的时候，会调用drop函数</p>
<h3 id="5-4-变量和数据交互的方式"><a href="#5-4-变量和数据交互的方式" class="headerlink" title="5.4 变量和数据交互的方式"></a>5.4 变量和数据交互的方式</h3><h4 id="5-4-1-移动（Move）"><a href="#5-4-1-移动（Move）" class="headerlink" title="5.4.1 移动（Move）"></a>5.4.1 移动（Move）</h4><blockquote>
<p>多个变量可以与同一个数据使用一种独特的方式来交互；</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// borrow of moved value: `s`</span></span><br><span class="line">    <span class="keyword">let</span> s2 = s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s2); <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个String由3部分组成：<ul>
<li>一个指向存放字符串内容的内存的指针 ptr</li>
<li>一个长度 len</li>
<li>一个容量 capacity</li>
</ul>
</li>
</ul>
<p><img src="heap01.png" alt="image-20210302114049906"></p>
<ul>
<li>上面这些东西放在stack上</li>
<li>存放字符串内容的部分在heap上</li>
<li>长度len，就是存放字符串内容所需的字节数；</li>
</ul>
<p><img src="heap02.png" alt="image-20210302130115114"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>



<p>当把s1赋给s2，String的数据被复制了一份：</p>
<ul>
<li>在stack上复制了一份指针、长度、容量</li>
<li>并没有复制指针所指向的heap上的数据</li>
</ul>
<p>当变量离开作用域时，Rust会自动调用drop函数，并将变量使用的heap内存释放；</p>
<p>当s1、s2离开作用域时，它们都会尝试释放相同的内存</p>
<ul>
<li>会引起二次释放（double free）的bug</li>
</ul>
<p>rust为了保证内存安全：</p>
<ul>
<li>Rust没有尝试复制被分配的内存</li>
<li>Rust让s1失效<ul>
<li>当s1离开作用域的时候，rust不需要释放任何东西；</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// borrow of moved value: `s`</span></span><br><span class="line">    <span class="keyword">let</span> s2 = s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s2); <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-4-2-浅拷贝和深拷贝"><a href="#5-4-2-浅拷贝和深拷贝" class="headerlink" title="5.4.2 浅拷贝和深拷贝"></a>5.4.2 浅拷贝和深拷贝</h4><p>浅拷贝</p>
<p>深拷贝</p>
<p>你也许会将复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以我们用一个新的术语：移动（Move）</p>
<p>隐含的一个设计原则： Rust不会自动创建数据的深拷贝</p>
<ul>
<li>就运行时性能而言，任何自动赋值的操作都是廉价的；</li>
</ul>
<h4 id="5-4-3-变量和数据交互的方式：克隆（Clone）"><a href="#5-4-3-变量和数据交互的方式：克隆（Clone）" class="headerlink" title="5.4.3 变量和数据交互的方式：克隆（Clone）"></a>5.4.3 变量和数据交互的方式：克隆（Clone）</h4><p>如果真想对heap上面的String数据进行深度拷贝，而不仅仅是Stack上的数据，可以使用clone方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; borrow of moved value: &#96;s&#96;</span><br><span class="line">    let s2 &#x3D; s;</span><br><span class="line">    let s3 &#x3D; s2.clone();</span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, s2, s3); &#x2F;&#x2F; hello hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Clone 相当于无论是Stack上还是heap上的数据，都统统复制一遍</p>
<p><img src="heap03.png" alt="image-20210302131623712"></p>
<h4 id="5-4-4-复制"><a href="#5-4-4-复制" class="headerlink" title="5.4.4 复制"></a>5.4.4 复制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Clone 比较消耗资源；主要还是针对heap上的数据操作。</p>
<p>而针对Stack上的数据，只需要复制就好了；</p>
<h5 id="5-4-4-1-Copy-trait"><a href="#5-4-4-1-Copy-trait" class="headerlink" title="5.4.4.1 Copy trait"></a>5.4.4.1 Copy trait</h5><p>Rust 提供了一个名为Copy的 trait，trait简单理解为接口</p>
<p>Copy trait，可以用于像整数这样完全存放在stack上面的类型；</p>
<p>如果一个类型实现了Copy这个trait，那么旧的变量在赋值后仍然可用；</p>
<p>如果一个类型或者该类型的一部分实现了Drop trait，那么Rust不允许让它再实现Copy trait了</p>
<h5 id="5-4-4-2-一些拥有Copy-trait的类型"><a href="#5-4-4-2-一些拥有Copy-trait的类型" class="headerlink" title="5.4.4.2 一些拥有Copy trait的类型"></a>5.4.4.2 一些拥有Copy trait的类型</h5><p>任何简单标量的组合类型都可以是Copy的</p>
<p>任何需要分配内存或某种资源的都不是Copy的</p>
<p>一些拥有Copy trait的类型</p>
<ul>
<li>所有整数类型，例如 u32</li>
<li>bool</li>
<li>char</li>
<li>所有浮点类型 例如f64</li>
<li>Tuple（元组），如果其所有的字段都是Copy的<ul>
<li>(i32,i32)是</li>
<li>(I32, String) 不是</li>
</ul>
</li>
</ul>
<h3 id="5-5-所有权与函数"><a href="#5-5-所有权与函数" class="headerlink" title="5.5 所有权与函数"></a>5.5 所有权与函数</h3><p>在语义上，将值传递给函数和把值赋给变量是类似的：</p>
<h4 id="5-5-1-将值传递给函数将发生移动或复制"><a href="#5-5-1-将值传递给函数将发生移动或复制" class="headerlink" title="5.5.1 将值传递给函数将发生移动或复制"></a>5.5.1 将值传递给函数将发生移动或复制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"alex"</span>);</span><br><span class="line">    take_ownership(s);</span><br><span class="line">    <span class="comment">// 从这里之后，s的值被移动到函数里面；</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    makes_copy(x);</span><br><span class="line">    <span class="comment">// x值是被拷贝到函数里面</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;"</span>, x);</span><br><span class="line">    <span class="comment">// x 被回收；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_ownership</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125; <span class="comment">// rust会调用drop ，str占用的内存会被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">makes_copy</span></span>(<span class="built_in">str</span>: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125; <span class="comment">// 对于i32这种基础类型，不会有额外的事情发生</span></span><br></pre></td></tr></table></figure>

<h4 id="5-5-2-返回值与作用域"><a href="#5-5-2-返回值与作用域" class="headerlink" title="5.5.2 返回值与作用域"></a>5.5.2 返回值与作用域</h4><p>函数在返回值的过程中同样也会发生所有权的转移</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个变量的所有权总是遵循同样的模式：</p>
<ul>
<li>把一个值赋给其它变量时就会发生移动</li>
<li>当一个包含heap数据的变量离开作用域时，它的值就会被drop函数清理，除非数据的所有权移动到另一个变量上了；</li>
</ul>
<h3 id="5-6-引用"><a href="#5-6-引用" class="headerlink" title="5.6 引用"></a>5.6 引用</h3><p>如果让函数使用某个值，但不获得其所有权？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"alex"</span>);</span><br><span class="line">  <span class="keyword">let</span> (s2, len) = calculate_length(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;"</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;<span class="comment">// usize 跟架构有关的无符号整数类型</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">str</span>.len();</span><br><span class="line">  (<span class="built_in">str</span>, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust有一个特性叫做 <code>引用（Reference)</code></p>
<h4 id="5-6-1-引用"><a href="#5-6-1-引用" class="headerlink" title="5.6.1 引用"></a>5.6.1 引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="symbol">'hi</span>');</span><br><span class="line">  <span class="keyword">let</span> len = calcuate_length(&amp;s1); <span class="comment">//&amp;s1并不拥有s1，所有不会转移s1的所有权，而是将s1的引用传给了 函数， 当作用域结束之后，s1并不会被清理掉</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calcuate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125; <span class="comment">// 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，</span></span><br><span class="line"><span class="comment">// 所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权</span></span><br><span class="line"><span class="comment">// 这种将引用作为函数参数的行为，我们就将其称为借用；</span></span><br></pre></td></tr></table></figure>



<p><img src="yinyong01.png" alt="image-20210303150138448"></p>
<p>如上图，s就是s1的引用，</p>
<p>s实际上是一个指针，它指向s1。</p>
<p>s1也是一个指针，它指向存在heap上的真实的内容；</p>
<p><code>calcuate_length</code> 参数的类型是 &amp; String而不是String， &amp;符号就表示引用：允许你引用某些值而不取得其所有权</p>
<h4 id="5-6-2-借用"><a href="#5-6-2-借用" class="headerlink" title="5.6.2 借用"></a>5.6.2 借用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calcuate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125; <span class="comment">// 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权</li>
<li>这种将引用作为函数参数的行为，我们就将其称为借用；</li>
</ul>
<p><strong>是否可以修改借用的东西？</strong></p>
<ul>
<li>不行</li>
<li>和变量一样，引用默认也是不可变的</li>
<li>只要设置mut，就可以修改借用的东西</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// 设置为可变的</span></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-3-可变引用"><a href="#5-6-3-可变引用" class="headerlink" title="5.6.3 可变引用"></a>5.6.3 可变引用</h4><p>可变引用有一个重要的限制： 在特定作用域内，对某一块数据，只能有一个可变的引用；</p>
<p>这样做的好处是可在编译时防止数据竞争；</p>
<p><strong>数据竞争是如何发生的</strong></p>
<ul>
<li>两个或多个指针同时访问同一个数据</li>
<li>至少有一个指针用于写入数据</li>
<li>没有使用任何机制来同步对数据的访问</li>
</ul>
<p><strong>可以通过创建新的作用域，来允许非同时的创建多个可变引用（例子）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="symbol">'alex</span>');</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> s2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不可以同时拥有一个可变引用和一个不变的引用</strong></p>
<ul>
<li>多个不变的引用是可以的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="symbol">'alex</span>');</span><br><span class="line">  <span class="keyword">let</span> r1 = &amp;s;</span><br><span class="line">  <span class="keyword">let</span> r2 = &amp;s;</span><br><span class="line">  <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s; <span class="comment">// error! 不可以同时拥有可变引用和不可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-4-悬垂引用-Dangling-References"><a href="#5-6-4-悬垂引用-Dangling-References" class="headerlink" title="5.6.4 悬垂引用 Dangling References"></a>5.6.4 悬垂引用 Dangling References</h4><blockquote>
<p>一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了；</p>
</blockquote>
<p>Rust里，编译器可保证引用永远都不是悬空引用；</p>
<ul>
<li>如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> r = dangle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// compiler error：</span></span><br><span class="line">  <span class="keyword">let</span> s = Sring::from(<span class="symbol">'alex</span>');</span><br><span class="line">  &amp;s</span><br><span class="line">&#125;<span class="comment">// 随着s离开作用域，会调用drop释放内存，而对它的引用 &amp;s 却继续返回了。所以这个引用指向了一个被释放掉了的内存地址；即悬空指针，但Rust在编译阶段就规避掉了；</span></span><br></pre></td></tr></table></figure>



<h4 id="5-6-5-引用的规则"><a href="#5-6-5-引用的规则" class="headerlink" title="5.6.5 引用的规则"></a>5.6.5 引用的规则</h4><p>在任何给定的时刻，只能满足下列条件之一：</p>
<ul>
<li>一个可变的引用</li>
<li>任意数量不可变的引用</li>
</ul>
<p>引用必须一直有效</p>
<h3 id="5-7-切片-slice"><a href="#5-7-切片-slice" class="headerlink" title="5.7 切片 slice"></a>5.7 切片 slice</h3><blockquote>
<p>Rust的另外一种不持有所有权的数据类型：切片（slice）</p>
</blockquote>
<p>编写一个函数：</p>
<ul>
<li>它接收字符串作为参数</li>
<li>返回它在这个字符串里找到的第一个单词</li>
<li>如果函数没找到任何空格，那么整个字符串就被返回；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello alex"</span>);</span><br><span class="line">    <span class="keyword">let</span> name_index = first_world(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, name_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes(); <span class="comment">// 转成字节数组</span></span><br><span class="line">  <span class="comment">// iter 方法为bytes创建一个迭代器，这个方法依次返回集合中的每个元素。然后</span></span><br><span class="line">  <span class="comment">// 调用的enumerate方法，它会将iter方法的结果进行包装，并把结果作为tuple的一部分进行返回。</span></span><br><span class="line">  <span class="comment">// 元祖的第一个元素，就是enumerate遍历的索引 i，第二个元素就是引用 item。</span></span><br><span class="line">  <span class="comment">// (i, &amp;item) 实际上是模式匹配之后的解构</span></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然而上面的函数设计是有问题的， name_index 和 s 太过耦合了。当s被清空之后，name_index的值就不再有意义了；</p>
<p>那如何确保 s 和 name_index 之间的同步性呢；</p>
<p><strong>解决方案： 字符串切片</strong></p>
<h4 id="5-7-1-字符串切片"><a href="#5-7-1-字符串切片" class="headerlink" title="5.7.1 字符串切片"></a>5.7.1 字符串切片</h4><blockquote>
<p>字符串切片是指向字符串中一部分内容的引用</p>
</blockquote>
<p>形式： [开始索引…结束索引]</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>几个语法糖</p>
<p>注意：</p>
<ul>
<li>字符串切片的范围索引必须发生在有效的UTF-8字符边界内；</li>
<li>如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello alex"</span>);</span><br><span class="line">    <span class="keyword">let</span> name_index = first_world(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, name_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;str 字符串切片</span></span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-7-2-字符串字面值是切片"><a href="#5-7-2-字符串字面值是切片" class="headerlink" title="5.7.2 字符串字面值是切片"></a>5.7.2 字符串字面值是切片</h4><p>字符串字面值被直接存储在二进制程序中；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"he"</span> <span class="comment">// s 为 &amp;str类型，即字符串切片</span></span><br><span class="line"><span class="comment">// s就是一个指向二进制程序 特定位置的切片，而&amp;str是不可变的引用；</span></span><br></pre></td></tr></table></figure>

<p>变量s的类型是&amp;str， 它是一个指向二进制程序特定位置的切片</p>
<ul>
<li>&amp;str是不可变引用，所以字符串字面值也是不可变的；</li>
</ul>
<h4 id="5-7-3-将字符串切片作为参数传递"><a href="#5-7-3-将字符串切片作为参数传递" class="headerlink" title="5.7.3 将字符串切片作为参数传递"></a>5.7.3 将字符串切片作为参数传递</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_string = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> my_string_literal = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入字符串字面值的 slice</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值 **就是** 字符串 slice，</span></span><br><span class="line">    <span class="comment">// 这样写也可以，即不使用 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(my_string_literal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;str 字符串切片</span></span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能；</p>
<h2 id="6-struct"><a href="#6-struct" class="headerlink" title="6. struct"></a>6. struct</h2><h3 id="6-1-定义并实例化struct"><a href="#6-1-定义并实例化struct" class="headerlink" title="6.1 定义并实例化struct"></a>6.1 定义并实例化struct</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    emila: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"alex"</span>),</span><br><span class="line">        emila: <span class="built_in">String</span>::from(<span class="string">"123@qq.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">12</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦struct的实例是可变的，那么实例中所有的字段都是可变的。不允许部分可变，部分不可变</p>
<h4 id="6-1-1-tuple-struct"><a href="#6-1-1-tuple-struct" class="headerlink" title="6.1.1 tuple struct"></a>6.1.1 tuple struct</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>black和origin是不同的类型，是不同tuple struct的实例</p>
<h4 id="6-1-2-Unit-Like-Struct（没有任何字段）"><a href="#6-1-2-Unit-Like-Struct（没有任何字段）" class="headerlink" title="6.1.2 Unit-Like Struct（没有任何字段）"></a>6.1.2 Unit-Like Struct（没有任何字段）</h4><ul>
<li>可以定义没有任何字段的struct，叫做Unit-Like Struct（因为与（），单元类型类似）</li>
<li>适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据</li>
</ul>
<h4 id="6-1-3-struct-数据的所有权"><a href="#6-1-3-struct-数据的所有权" class="headerlink" title="6.1.3 struct 数据的所有权"></a>6.1.3 struct 数据的所有权</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    emila: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的字段使用了String 而不是 &amp;str<ul>
<li>该struct实例拥有其所有的数据</li>
<li>只要struct实例是有效的，那么里面的字段数据也是有效的</li>
</ul>
</li>
<li>struct里也可以存放引用，但这需要使用生命周期；<ul>
<li>声明周期保证只要struct实例是有效的，那么里面的引用也是有效的；</li>
<li>如果struct里面存储引用，而不使用生命周期，就会报错</li>
</ul>
</li>
</ul>
<h4 id="6-1-4-计算面积的例子"><a href="#6-1-4-计算面积的例子" class="headerlink" title="6.1.4 计算面积的例子"></a>6.1.4 计算面积的例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rect: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rect.height * rect.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, area(&amp;rect));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-1-5-几种模式"><a href="#6-1-5-几种模式" class="headerlink" title="6.1.5 几种模式"></a>6.1.5 几种模式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::fmt::Display</span><br><span class="line">std::fmt::<span class="built_in">Debug</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line">&#123;:?&#125;</span><br><span class="line">&#123;:#?&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-2-struct的方法"><a href="#6-2-struct的方法" class="headerlink" title="6.2 struct的方法"></a>6.2 struct的方法</h3><p>方法和函数类似： fn关键字、名称、参数、返回值</p>
<p>方法与函数不同之处：</p>
<ul>
<li>方法是在struct（或enum、trait对象）的上下文中定义</li>
<li>第一个参数是self，表示方法被调用的struct实例</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123; <span class="comment">// impl块中定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 方法第一个参数可以是 &amp;self</span></span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-1-方法调用的运算符"><a href="#6-2-1-方法调用的运算符" class="headerlink" title="6.2.1 方法调用的运算符"></a>6.2.1 方法调用的运算符</h4><p>在调用方法时， Rust根据情况自动添加 &amp;、 &amp;mut 或 *， 以便object可以匹配方法的签名；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两行代码效果相同：</span></span><br><span class="line">p1.dis(&amp;p2);</span><br><span class="line">(&amp;p1).dis(&amp;p2);</span><br></pre></td></tr></table></figure>



<h4 id="6-2-2-方法参数"><a href="#6-2-2-方法参数" class="headerlink" title="6.2.2 方法参数"></a>6.2.2 方法参数</h4><p>方法可以有多个参数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hole</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height &gt; other.height &amp;&amp; <span class="keyword">self</span>.width &gt; other.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect.area());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect1.can_hole(&amp;rect1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-关联函数"><a href="#6-3-关联函数" class="headerlink" title="6.3 关联函数"></a>6.3 关联函数</h3><p>可以在impl块里定义不把self作为第一个参数的函数，它们叫关联函数（不是方法）</p>
<ul>
<li>例如： String::from()</li>
</ul>
<p>关联函数通常用于构造器</p>
<ul>
<li>::符号<ul>
<li>关联函数</li>
<li>模块创建的命名空间</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = Rectangle::square(<span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-枚举与模式匹配"><a href="#7-枚举与模式匹配" class="headerlink" title="7. 枚举与模式匹配"></a>7. 枚举与模式匹配</h2><h3 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ip</span></span> &#123;</span><br><span class="line">	V4,V6</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Ip::V4;</span><br><span class="line"><span class="keyword">let</span> b = Ip::V6;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"::1"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-1-将数据附加到枚举的变体中"><a href="#7-1-1-将数据附加到枚举的变体中" class="headerlink" title="7.1.1 将数据附加到枚举的变体中"></a>7.1.1 将数据附加到枚举的变体中</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure>

<p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p>
<p>优点：</p>
<ul>
<li>不需要额外使用struct</li>
<li>每个变体可以拥有不同的类型以及关联的数据量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ip</span></span> &#123;</span><br><span class="line">	V4(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>),</span><br><span class="line">	V6(<span class="built_in">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-option枚举"><a href="#7-2-option枚举" class="headerlink" title="7.2 option枚举"></a>7.2 option枚举</h3><p>定义于标准库中</p>
<p>在Prelude中</p>
<p>描述了： 某个值可能存在（某种类型）或不存在的情况</p>
<h4 id="7-2-1-Option"><a href="#7-2-1-Option" class="headerlink" title="7.2.1 Option"></a>7.2.1 Option<T></h4><p>Rust中类似Null概念的枚举 - Option<T></p>
<p>Rust没有Null</p>
<p>其它语言中：</p>
<ul>
<li>Null是一个值，它表示“没有值”</li>
<li>一个变量可以处于两种状态： 空值（null）、非空</li>
</ul>
<p>Null引用： Billion Dollar Mistake</p>
<p>Null的问题在于： 当你尝试像使用非Null值那样使用Null值的时候，就会引起某种错误</p>
<p>Null的概念还是有用的：因某种原因而变为无效或缺失的值；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库中的定义：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它包含在Prelude（预导入模块）中，可直接使用；</p>
<ul>
<li>Option<T></li>
<li>Some<T></li>
<li>None</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>



<p><strong>Option<T>比Null好在哪？</strong></p>
<p>Option<T>和T是不同的类型，不可以把Option<T>直接当成T</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x:<span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">let</span> sum = x + y; <span class="comment">// error: cannot add Option&lt;i8&gt; to i8;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若想使用Option<T>中的 T，必须将它转换为 T；</p>
<p>这就避免了其它语言中最常见的那个错误；那就是假设某个值存在，但它实际上为Null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比如在C#</span><br><span class="line">string a &#x3D; null;</span><br><span class="line">string b &#x3D; a + &quot;12345&quot;; &#x2F;&#x2F; error</span><br></pre></td></tr></table></figure>

<h3 id="7-3-match"><a href="#7-3-match" class="headerlink" title="7.3 match"></a>7.3 match</h3><p>控制流运算符 - match</p>
<ul>
<li>match允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码；</li>
<li>模式可以是字面量、变量名、通配符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-1-绑定值的模式"><a href="#7-3-1-绑定值的模式" class="headerlink" title="7.3.1 绑定值的模式"></a>7.3.1 绑定值的模式</h4><p>匹配的分支可以绑定到被匹配对象的部分值</p>
<ul>
<li>因此，可以从enum变体中提取值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"penny"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = Coin::Quarter(UsState::Alabama);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value_in_cents(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-3-2-匹配Option"><a href="#7-3-2-匹配Option" class="headerlink" title="7.3.2 匹配Option"></a>7.3.2 匹配Option<T></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">  <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-3-3-match必须穷举所有可能"><a href="#7-3-3-match必须穷举所有可能" class="headerlink" title="7.3.3 match必须穷举所有可能"></a>7.3.3 match必须穷举所有可能</h4><p>_ 通配符： 替代其余没有列出的值；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-if-let"><a href="#7-4-if-let" class="headerlink" title="7.4 if let"></a>7.4 if let</h3><p>处理只关心一种匹配而忽略其它匹配的情况</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="comment">// match 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if let 相当于只处理一种匹配的情况，其它的分支就不关心了</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>if let 优缺点</strong></p>
<p>更少的代码，更少的锁紧，更少的模版代码</p>
<p>放弃了穷举的可能</p>
<p>可以把 if let 看作是 match的语法糖</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if let 搭配 else</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"others"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-Package-Crate-和-Module"><a href="#8-Package-Crate-和-Module" class="headerlink" title="8. Package, Crate 和 Module"></a>8. Package, Crate 和 Module</h2><p>模块系统：</p>
<ul>
<li>Package（包）， Cargo的特性，让你构建、测试、共享crate；</li>
<li>Crate（单元包）， 一个模块树，它可产生一个library或执行文件；</li>
<li>Module（模块）， use： 让你控制代码的组织、作用域、私有路径；</li>
<li>path（路径）： 为struct、function 或module 等项命名的方式；</li>
</ul>
<h3 id="8-1-Package-和-Crate"><a href="#8-1-Package-和-Crate" class="headerlink" title="8.1 Package 和 Crate"></a>8.1 Package 和 Crate</h3><p>crate上面是package，</p>
<p><strong>Crate的类型</strong></p>
<ul>
<li>binary</li>
<li>library</li>
</ul>
<p><strong>Crate Root</strong></p>
<ul>
<li>是源代码文件</li>
<li>Rust编译器从这里开始，组成你的Crate的根Module</li>
</ul>
<p><strong>一个Package</strong></p>
<ul>
<li>包含1个Cargo.toml, 它描述了如何构建这些Crates；</li>
<li>只能包含0-1个library crate；</li>
<li>可以包含任意数量的binary crate；</li>
<li>必须至少包含一个crate（library或binary）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; cargo new my-pro</span><br><span class="line"><span class="comment"># create binary (application) `my-pro` package</span></span><br></pre></td></tr></table></figure>

<h4 id="8-1-1-Cargo的惯例"><a href="#8-1-1-Cargo的惯例" class="headerlink" title="8.1.1 Cargo的惯例"></a>8.1.1 Cargo的惯例</h4><p>src/main.rs</p>
<ul>
<li>src/main.rs    // package 的入口文件<ul>
<li>Binary crate 的 crate root （cargo会默认让 main.rs做为crate的根）</li>
<li>crate名与package名相同 （也是指这个binary crate的名和包名相同，都是my-pro）</li>
</ul>
</li>
<li>src/lib.rs<ul>
<li>Package 包含一个library crate</li>
<li>library crate 的 crate root</li>
<li>crate名与package名相同 （也都是my-pro）</li>
</ul>
</li>
</ul>
<p>复习：</p>
<p>如果有main.rs,就说明有一个 binary crate。</p>
<p>如果有lib.rs , 就说明有一个library crate。</p>
<p>两个都是入口文件，都是crate的根。而crate名都与package名相同。</p>
<p>cargo会把crate root文件交给rustc 来构建library 或 binary</p>
<p>一个Package可以同时包含main.rs 和 lib.rs, </p>
<ul>
<li>表明，这个package含有一个 binary crate，一个library crate。名称都与package名相同</li>
<li>一个package可以有多个binary crate<ul>
<li>文件都放在src/bin</li>
<li>每个文件是单独的binary crate</li>
</ul>
</li>
</ul>
<h3 id="8-2-Crate的作用"><a href="#8-2-Crate的作用" class="headerlink" title="8.2 Crate的作用"></a>8.2 Crate的作用</h3><blockquote>
<p>将相关功能组合到一个作用域内，便于在项目间进行共享，也能防止命名冲突</p>
</blockquote>
<p>例如： rand crate，访问它的功能需要通过它的名字： rand</p>
<h3 id="8-3-定义module来控制作用域和私有性"><a href="#8-3-定义module来控制作用域和私有性" class="headerlink" title="8.3 定义module来控制作用域和私有性"></a>8.3 定义module来控制作用域和私有性</h3><p><strong>Module</strong></p>
<p>在一个crate内，将代码进行分组；</p>
<p>增加可读性，易于复用；</p>
<p>控制项目（item）的私有性，public、private</p>
<h4 id="8-3-1-建立module"><a href="#8-3-1-建立module" class="headerlink" title="8.3.1 建立module"></a>8.3.1 建立module</h4><ul>
<li>mod 关键字{}</li>
<li>可嵌套</li>
<li>可包含其它项（struct、enum、常量、trait、函数等）的定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cargo new my-pro</span></span><br><span class="line">|- crate</span><br><span class="line">	|- front_of_house</span><br><span class="line">		|- hosting</span><br><span class="line">			|- add_to_waitlist</span><br><span class="line">			|- seat_at_table</span><br><span class="line">		|- serving</span><br><span class="line">			|- take_over</span><br><span class="line">			|- serve_order</span><br><span class="line">			|- take_payment</span><br></pre></td></tr></table></figure>

<p>main.rs   lib.rs 都叫crate roots；</p>
<ul>
<li>这两个文件（任意一个）的内容形成了名为crate的模块，位于整个模块树的根部；</li>
<li>整个模块树在隐式的crate模块下</li>
</ul>
<h3 id="8-4-path"><a href="#8-4-path" class="headerlink" title="8.4 path"></a>8.4 path</h3><p>根其它语言里面的命名空间有点类似</p>
<ul>
<li>为了在Rust的模块中找到某个条目，需要使用路径</li>
<li>路径的两种形式<ul>
<li>绝对路径： 从crate root开始，使用crate名或字面值crate</li>
<li>相对路径： 从当前模块开始，使用self，super或当前模块的标识符；</li>
</ul>
</li>
<li>路径至少由一个标识符组成，标识符之间使用::</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟级别可以不加 pub 互相调用</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pub 关键字 设置该module为公共的</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Absolute path</span></span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Relative path</span></span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-4-1-私有边界（private-boundary）"><a href="#8-4-1-私有边界（private-boundary）" class="headerlink" title="8.4.1 私有边界（private boundary）"></a>8.4.1 私有边界（private boundary）</h4><p>模块不仅可以组织代码，还可以定义私有边界</p>
<p>如果想把 函数 或 struct 等设为私有，可以将它放到某个模块中；</p>
<p>Rust中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的；</p>
<ul>
<li>父级模块无法访问子模块中的私有条目<ul>
<li>私有条目都是隐藏实现细节，不允许其它模块进行访问。</li>
<li>子模块里可以使用所有祖先模块中的条目</li>
</ul>
</li>
</ul>
<h4 id="8-4-2-super关键字"><a href="#8-4-2-super关键字" class="headerlink" title="8.4.2 super关键字"></a>8.4.2 super关键字</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ls..</span><br><span class="line">$&gt; hello hello.c</span><br><span class="line">$&gt; ../hello <span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li>super关键字</li>
</ul>
<p>在Rust中，用来访问父级模块路径中的内容，类似文件系统中的..</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fix_incorrect_order</span></span>()&#123;</span><br><span class="line">    cook_order();</span><br><span class="line">    super::serve_order(); <span class="comment">// 上一级模块的 serve_order 方法</span></span><br><span class="line">    crate::serve_order(); <span class="comment">// 绝对路径的写法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">cook_order</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-3-use关键字"><a href="#8-4-3-use关键字" class="headerlink" title="8.4.3 use关键字"></a>8.4.3 use关键字</h4><p>可以使用use关键字将路径导入到作用域内</p>
<ul>
<li>仍遵循私有性规则</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用use来指定相对路径</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 函数 指定到父级模块； hosting</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用use来指定绝对路径</span></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct, enum 其它： 指定完整路径（指定到本身）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"> map.insert(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同名条目： 指定到父级</li>
</ul>
<h5 id="8-4-3-1-使用pub-use重新导出名称"><a href="#8-4-3-1-使用pub-use重新导出名称" class="headerlink" title="8.4.3.1 使用pub use重新导出名称"></a>8.4.3.1 使用pub use重新导出名称</h5><p>使用use将路径（名称）导入到作用域内后，该名称在此作用域内是私有的；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting; <span class="comment">// 从此，外部模块也能访问 hosting了</span></span><br><span class="line"><span class="comment">// 函数 指定到父级模块； hosting</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-4-3-2-使用嵌套路径清理大量的use语句"><a href="#8-4-3-2-使用嵌套路径清理大量的use语句" class="headerlink" title="8.4.3.2 使用嵌套路径清理大量的use语句"></a>8.4.3.2 使用嵌套路径清理大量的use语句</h5><p>如果使用同一个包或模块下的多个条目（例子）</p>
<p>可使用嵌套路径在同一行内将上述条目进行引入：</p>
<ul>
<li>路径相同的部分::{路径差异的部分}</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use std::cmp::Ordering;</span></span><br><span class="line"><span class="comment">// use std::io;</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use std::io;</span></span><br><span class="line"><span class="comment">// use std::io::Write</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="8-4-4-通配符"><a href="#8-4-4-通配符" class="headerlink" title="8.4.4 通配符 *"></a>8.4.4 通配符 *</h4><p>使用 * 可以把路径中所有的公共条目都引入到作用域</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*</span><br></pre></td></tr></table></figure>

<p>谨慎使用</p>
<p>应用场景：</p>
<ul>
<li>测试，将所有被测试代码引入到tests模块</li>
<li>有时被用于预导入（prelude）模块</li>
</ul>
<h4 id="8-4-5-as关键字"><a href="#8-4-5-as关键字" class="headerlink" title="8.4.5  as关键字"></a>8.4.5  as关键字</h4><p>as关键字可以为引入的路径指定本地的别名</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f2</span></span>() -&gt; IoResult&#123;&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="8-4-6-使用外部包（package）"><a href="#8-4-6-使用外部包（package）" class="headerlink" title="8.4.6 使用外部包（package）"></a>8.4.6 使用外部包（package）</h4><ol>
<li>cargo.toml 添加依赖的包（package）</li>
<li>use将特定条目引入作用域；</li>
</ol>
<h5 id="8-4-6-1-切换国内镜像"><a href="#8-4-6-1-切换国内镜像" class="headerlink" title="8.4.6.1 切换国内镜像"></a>8.4.6.1 切换国内镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">where</span> cargo</span><br><span class="line">$&gt; <span class="built_in">cd</span> /Users/xx/.cargo/</span><br><span class="line">$&gt; ls -a</span><br><span class="line">$&gt; vim config</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = <span class="string">"https://github.com/rust-lang/crates.io-index"</span></span><br><span class="line"></span><br><span class="line">replace-with = <span class="string">'tuna'</span></span><br><span class="line">[source.tuna]</span><br><span class="line">registry = <span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"</span></span><br><span class="line"></span><br><span class="line">[net]</span><br><span class="line">git-fetch-with-cli = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="8-5-将模块拆分为不同文件"><a href="#8-5-将模块拆分为不同文件" class="headerlink" title="8.5 将模块拆分为不同文件"></a>8.5 将模块拆分为不同文件</h3><p>将模块内容移动到其它文件</p>
<p>模块定义时，如果模块名后边是； ，而不是代码块</p>
<ul>
<li>Rust 会从与模块同名的文件中加载内容</li>
<li>模块树的结构不会变化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- src</span><br><span class="line">	|- /front_of_house</span><br><span class="line">		|- hosting.rs</span><br><span class="line">	|- front_of_houre.rs</span><br><span class="line">	|- lib.rs</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"><span class="comment">// hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>随着模块逐渐变大，该技术让你可以把模块的内容移动到其它文件中；</p>
<h2 id="9-集合"><a href="#9-集合" class="headerlink" title="9. 集合"></a>9. 集合</h2><h3 id="9-1-Vector"><a href="#9-1-Vector" class="headerlink" title="9.1 Vector"></a>9.1 Vector</h3><p> Vec<T>,叫作vector</p>
<ul>
<li>由标准库提供</li>
<li>可存储多个值</li>
<li>只能存储相同类型的数据</li>
<li>值在内存中连续存放</li>
</ul>
<h4 id="9-1-1-创建"><a href="#9-1-1-创建" class="headerlink" title="9.1.1 创建"></a>9.1.1 创建</h4><p>Vec<T>  使用 vec! 宏</p>
<h4 id="9-1-2-所有权和借用规则"><a href="#9-1-2-所有权和借用规则" class="headerlink" title="9.1.2 所有权和借用规则"></a>9.1.2 所有权和借用规则</h4><p>不能在同一作用域内同时拥有可变和不可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line">  <span class="keyword">let</span> first = &amp;v[<span class="number">0</span>]; <span class="comment">// 不可变借用</span></span><br><span class="line">  v.push(<span class="number">6</span>); <span class="comment">// 可变的借用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector的工作原理： vec里面的元素在内存中的摆放是连续的，所以再往vec中添加一个元素的时候，在内存中就没有这么大的连续内存块。就可能将内存重新分配一下了，再找一个足够大的内存来放置这些添加了元素之后的vector，原来那块内存可能被释放掉或者重新分配，而first变量仍然指向原来的内存地址，这样的话，程序必然出现问题了；所以，借用规则防止类似的情况发生</p>
<h4 id="9-1-3-遍历"><a href="#9-1-3-遍历" class="headerlink" title="9.1.3 遍历"></a>9.1.3 遍历</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-1-4-vector-enum"><a href="#9-1-4-vector-enum" class="headerlink" title="9.1.4 vector+enum"></a>9.1.4 vector+enum</h4><p>使用enum来存储多种数据类型</p>
<ul>
<li>enum的变体可以附加不同类型的数据</li>
<li>enum的变体定义在同一个enum类型下</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>



<h3 id="9-2-String"><a href="#9-2-String" class="headerlink" title="9.2 String"></a>9.2 String</h3><p>字符串困扰</p>
<ul>
<li>Rust倾向于暴露可能的错误</li>
<li>字符串数据结构复杂</li>
<li>UTF-8</li>
</ul>
<h4 id="9-2-1-定义"><a href="#9-2-1-定义" class="headerlink" title="9.2.1 定义"></a>9.2.1 定义</h4><p>Rust的核心语言层面，只有字符串类型：字符串切片 str （&amp;str）</p>
<ul>
<li>字符串切片： 对存储在其它地方、utf-8编码的字符串引用<ul>
<li>字符串字面值： 存储在二进制文件中，也是字符串切片</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-String类型"><a href="#9-2-2-String类型" class="headerlink" title="9.2.2 String类型"></a>9.2.2 String类型</h4><p>来自标准库 而不是核心语言</p>
<ul>
<li>可增长，可修改，可拥有</li>
<li>UTF-8 编码</li>
</ul>
<h4 id="9-2-3-其它类型的字符串"><a href="#9-2-3-其它类型的字符串" class="headerlink" title="9.2.3 其它类型的字符串"></a>9.2.3 其它类型的字符串</h4><p>Rust标准库还包含了很多其它的字符串类型， OsString、OsStr、CString、CStr</p>
<ul>
<li>String vs Str后缀： 拥有或借用的变体</li>
<li>可存储不同编码的文本或在内存中以不同的形式展现</li>
</ul>
<h4 id="9-2-4-使用初始值创建String"><a href="#9-2-4-使用初始值创建String" class="headerlink" title="9.2.4 使用初始值创建String"></a>9.2.4 使用初始值创建String</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">"initial contents"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = data.to_string();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">"initial contents"</span>.to_string();</span><br><span class="line"><span class="comment">// 字符串字面值创建String</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"initial contents"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="9-2-5-更新"><a href="#9-2-5-更新" class="headerlink" title="9.2.5 更新"></a>9.2.5 更新</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"bar"</span>);</span><br><span class="line">  s.push_str(&amp;s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">   <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"bar"</span>);</span><br><span class="line">   <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">   <span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// // 注意 s1 被移动了，不能继续使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为在使用了 +，实际上使用了类似 下面 add这样的方法,当然标准库里面是泛型方法，这里为了理解，给替换成string类型先</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, s:&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span>&#123;...&#125; <span class="comment">// 参数1是 String，而不是切片，所以s1失去了所有权；</span></span><br></pre></td></tr></table></figure>

<p>标准库中的add使用了泛型</p>
<p>只能把&amp;str添加到String</p>
<p>解引用强制转换（deref coercion）</p>
<h4 id="9-2-6-format-连接多个字符串"><a href="#9-2-6-format-连接多个字符串" class="headerlink" title="9.2.6 format! 连接多个字符串"></a>9.2.6 format! 连接多个字符串</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="symbol">'tic</span>');</span><br><span class="line">  <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="symbol">'tac</span>');</span><br><span class="line">  <span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="symbol">'toe</span>');</span><br><span class="line">  <span class="keyword">let</span> s3 = s1 + <span class="string">"-"</span> + &amp;s2 + <span class="string">"-"</span> + &amp;s3;</span><br><span class="line">  <span class="comment">// 类似于</span></span><br><span class="line">  <span class="built_in">format!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3); <span class="comment">// format! 宏不会取得后续所有参数的所有权</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>format! 宏不会取得后续所有参数的所有权</p>
<h4 id="9-2-7-索引字符串"><a href="#9-2-7-索引字符串" class="headerlink" title="9.2.7 索引字符串"></a>9.2.7 索引字符串</h4><p>Rust字符串不支持索引；</p>
<h4 id="9-2-8-bytes，scalar-Values，-Grapheme-Clusters-字节、标量值、字形簇"><a href="#9-2-8-bytes，scalar-Values，-Grapheme-Clusters-字节、标量值、字形簇" class="headerlink" title="9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇"></a>9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> w = <span class="string">"नमस्ते"</span>;</span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> w.bytes()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    <span class="comment">// [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> w.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    <span class="comment">// ['न', 'म', 'स', '्', 'त', 'े']</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-9-Rust不允许对String进行索引最后一个原因"><a href="#9-2-9-Rust不允许对String进行索引最后一个原因" class="headerlink" title="9.2.9 Rust不允许对String进行索引最后一个原因"></a>9.2.9 Rust不允许对String进行索引最后一个原因</h4><ul>
<li>索引操作应消耗一个常量时间（O（1））</li>
<li>而String无法保证，需要遍历所有内容，来确定有多少个合法的字符</li>
</ul>
<h4 id="9-2-10-字符串切割"><a href="#9-2-10-字符串切割" class="headerlink" title="9.2.10 字符串切割"></a>9.2.10 字符串切割</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>



<h3 id="9-3-HashMap"><a href="#9-3-HashMap" class="headerlink" title="9.3 HashMap"></a>9.3 HashMap</h3><p>对于实现Copy trait的类型（i32），值会被复制到HashMap中</p>
<p>对于拥有所有权的值（String），值会被移动，所有权会转移给HashMap</p>
<p>如果将值的引用插入到HashMap，值本身就不会移动</p>
<ul>
<li>在hashMap有效的期间，被引用的值必须保持有效</li>
</ul>
<h4 id="9-3-1-get"><a href="#9-3-1-get" class="headerlink" title="9.3.1 get"></a>9.3.1 get</h4><p>可以通过get方法并提供对应的键来从哈希map中获取值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">  scores.insert(<span class="built_in">String</span>::from(<span class="string">"blue"</span>), <span class="number">10</span>);</span><br><span class="line">  scores.insert(<span class="built_in">String</span>::from(<span class="string">"yellow"</span>), <span class="number">50</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"blue"</span>);</span><br><span class="line">  <span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">match</span> score &#123;</span><br><span class="line">    <span class="literal">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s), <span class="comment">// 10</span></span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"team not exist"</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-2-更新HashMap"><a href="#9-3-2-更新HashMap" class="headerlink" title="9.3.2 更新HashMap"></a>9.3.2 更新HashMap</h3><ul>
<li><p>K已经存在，对应一个V</p>
<ul>
<li>替换现有的V</li>
<li>保留现有的V，忽略新的V</li>
<li>合并现有的V和新的V</li>
</ul>
</li>
<li><p>K不存在</p>
<ul>
<li>添加一对K，V</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure>



<h5 id="9-3-2-1-entry"><a href="#9-3-2-1-entry" class="headerlink" title="9.3.2.1 entry"></a>9.3.2.1 entry</h5><p>entry方法： 检查指定的K是否对应一个V</p>
<ul>
<li>参数为K</li>
<li>返回enum Entry：代表值是否存在</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure>

<p>Entry的 or_insert 方法</p>
<ul>
<li>返回<ul>
<li>如果K存在，返回到对应的V的一个可变引用</li>
<li>如果K不存在，将方法参数作为K的新值插进去，返回到这个值的可变引用；</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据旧值更新一个值</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, map);</span><br></pre></td></tr></table></figure>



<h2 id="10-panic"><a href="#10-panic" class="headerlink" title="10. panic"></a>10. panic</h2><p>  Rust错误分类</p>
<ul>
<li>可恢复<ul>
<li>例如文件未找到，可再次尝试</li>
</ul>
</li>
<li>不可恢复<ul>
<li>bug，例如访问的索引超出范围</li>
</ul>
</li>
</ul>
<p>Rust没有类似异常的机制</p>
<ul>
<li>可恢复错误： Result&lt;T,E&gt;</li>
<li>不可恢复： painc！</li>
</ul>
<p>当执行painc！时，程序立即结束执行</p>
<p>不可恢复的错误与panic！</p>
<p>当panic！宏执行：</p>
<ul>
<li><p>你的程序会打印一个错误信息</p>
</li>
<li><p>展开（unwind）、清理调用栈（Stack）</p>
</li>
<li><p>退出程序</p>
</li>
</ul>
<p>为应对panic，展开或中止（abort）调用栈</p>
<ul>
<li><p>默认情况下，当panic发生：</p>
<ul>
<li>-程序展开调用栈（工作量大）<ul>
<li>rust沿着调用栈往回走</li>
<li>清理每个遇到的函数中的数据</li>
</ul>
</li>
<li>或立即中止调用栈：<ul>
<li>不进行清理，直接停止程序</li>
<li>内存需要OS进行清理</li>
</ul>
</li>
</ul>
</li>
<li><p>想让二进制文件更小，把设置从“展开”改为“中止”：</p>
<ul>
<li>在Cargo.toml中适当的profile部分设置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = <span class="string">'abort'</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可恢复的错误与panic！</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">"crash and burn"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-1-Result-与可恢复的错误"><a href="#10-1-Result-与可恢复的错误" class="headerlink" title="10.1 Result 与可恢复的错误"></a>10.1 Result 与可恢复的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="literal">Ok</span>(T),</span><br><span class="line">  <span class="literal">Err</span>(E)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T: 操作成功情况下，Ok变体里返回的数据的类型</p>
<p>E： 操作失败情况下，Err变体里返回的错误的类型</p>
<p>处理Result的一种方式： match表达式</p>
<p>和Option枚举一样，Result及其变体也是有prelude带入作用域</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"./0.txt"</span>);</span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Error opening file &#123;:?&#125;"</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-匹配不同的错误"><a href="#10-2-匹配不同的错误" class="headerlink" title="10.2 匹配不同的错误"></a>10.2 匹配不同的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">"hello.txt"</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: &#123;:?&#125;"</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: &#123;:?&#125;"</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例使用了很多match</p>
<p>match很有用，但是很原始</p>
<p>闭包（closure）。Result&lt;T,E&gt;有很多方法</p>
<ul>
<li>它们接收闭包作为参数</li>
<li>使用match实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(<span class="string">"hello.txt"</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: &#123;:?&#125;"</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: &#123;:?&#125;"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2-1-unwrap"><a href="#10-2-1-unwrap" class="headerlink" title="10.2.1 unwrap"></a>10.2.1 unwrap</h4><p>unwrap： match表达式的一个快捷方法；</p>
<ul>
<li>如果Result结果是Ok，返回Ok里面的值</li>
<li>如果Result结果是Err，调用panic！宏</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"0.txt"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Error opening file &#123;:?&#125;"</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">let</span> f = File::open(<span class="string">"0.txt"</span>).unwrap(); <span class="comment">// 相当于上面的match表达式</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2-2-expect"><a href="#10-2-2-expect" class="headerlink" title="10.2.2 expect"></a>10.2.2 expect</h4><p>expect： 和unwrap类似，但可指定错误信息</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-传播错误"><a href="#10-3-传播错误" class="headerlink" title="10.3 传播错误"></a>10.3 传播错误</h3><p>当编写一个其实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 <strong>传播</strong>（<em>propagating</em>）错误，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">match</span> f.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="literal">Ok</span>(s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>?运算符</p>
<p>?运算符： 传播错误的一种快捷方式</p>
<p>？与from函数</p>
<ul>
<li>Trait std::convert::From 上的from函数：<ul>
<li>用于错误之间的转换</li>
</ul>
</li>
<li>被？所应用的错误，会隐士的被from函数处理</li>
<li>当？调用from函数时：<ul>
<li>它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</li>
</ul>
</li>
</ul>
<p>用于： 针对不同错误的原因，返回同一种错误类型</p>
<ul>
<li>只要每个错误类型实现了转换为所返回的错误类型的from函数</li>
</ul>
<p>链式操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    File::open(<span class="string">"hello.txt"</span>)?.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>?运算符只能用于返回Result的函数</p>
<p>?运算符与main函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main中使用？</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()-&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">  <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数返回类型是：()</p>
<p>main函数的返回类型也可以是： Result&lt;T,E&gt;</p>
<p>Box<dyn Error>是trait对象</p>
<ul>
<li>简单理解： “任何可能的错误类型”</li>
</ul>
<h3 id="10-4-什么时候应该用panic"><a href="#10-4-什么时候应该用panic" class="headerlink" title="10.4 什么时候应该用panic!"></a>10.4 什么时候应该用panic!</h3><p>见示例</p>
<h2 id="11-泛型，Trait-生命周期"><a href="#11-泛型，Trait-生命周期" class="headerlink" title="11. 泛型，Trait 生命周期"></a>11. 泛型，Trait 生命周期</h2><h3 id="11-1-泛型"><a href="#11-1-泛型" class="headerlink" title="11.1 泛型"></a>11.1 泛型</h3><p>你编些的代码不是最终的代码，而是一种模版，里面有一些“占位符”；</p>
<p>编译器在编译时将“占位符”替换为具体的类型；</p>
<p>在编译的时候，会将泛型的类型参数编译成具体的类型。这个过程叫单态化；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> char_list = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-2-Trait"><a href="#11-2-Trait" class="headerlink" title="11.2 Trait"></a>11.2 Trait</h3><ul>
<li>Trait告诉rust编译器：<ul>
<li>某种类型具有哪些并且可以与其它类型共享的功能</li>
</ul>
</li>
<li>Trait：抽象的定义共享行为</li>
<li>Trait bounds（约束）泛型类型参数指定为实现了特定行为的类型；</li>
<li>Trait 与其它语言的接口（interface）类似，但有些区别；</li>
</ul>
<h4 id="11-2-1-如何定义一个trait"><a href="#11-2-1-如何定义一个trait" class="headerlink" title="11.2.1 如何定义一个trait"></a>11.2.1 如何定义一个trait</h4><p>类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。</p>
<p>trait 定义： 是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p>
<ul>
<li>关键字： trait</li>
<li>只有方法签名，没有具体实现</li>
<li>trait可以有多个方法： 每个方法签名占一行，以；结尾</li>
<li>实现该trait的类型必须提供具体的方法实现；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123; <span class="comment">// 一个trait， 可以有多个方法的签名 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sunmmary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-2-2-在类型上实现trait"><a href="#11-2-2-在类型上实现trait" class="headerlink" title="11.2.2 在类型上实现trait"></a>11.2.2 在类型上实现trait</h4><p>与为类型实现方法类似</p>
<p>不同之处：</p>
<ul>
<li>impl  类型  for  trait名{}  // 为类型实现方法则是   <code>impl 类型 {...}</code></li>
<li>在impl的块里，需要对Trait里的方法签名进行具体的实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123; <span class="comment">// 一个trait， 可以有多个方法的签名 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-2-3-实现trait的约束"><a href="#11-2-3-实现trait的约束" class="headerlink" title="11.2.3 实现trait的约束"></a>11.2.3 实现trait的约束</h4><p>可以在某个类型上实现某个trait的前提条件是：</p>
<ul>
<li>这个类型或这个trait是在本地crate里定义的</li>
</ul>
<p>无法为外部类型来实现外部的trait；</p>
<ul>
<li>这个限制是程序属性的一部分（也就是一致性）</li>
<li>更具体地说是孤儿规则： 之所以这样命名是因为父类型不存在；</li>
<li>此规则确保其它人的代码不能破坏您的代码，反之亦然；</li>
<li>如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了；</li>
</ul>
<h4 id="11-2-4-默认实现"><a href="#11-2-4-默认实现" class="headerlink" title="11.2.4 默认实现"></a>11.2.4 默认实现</h4><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123;</span><br><span class="line">  <span class="comment">// 一个trait， 可以有多个方法的签名</span></span><br><span class="line">  <span class="comment">// fn summarize(&amp;self) -&gt; String;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize1</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">"(...)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Sunmmary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">  <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Sunmmary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认实现的方法可以调用trait中其它的方法，即使这些方法没有默认实现</p>
<p>注意： 无法从方法的重写实现里面调用默认的实现</p>
<h4 id="11-2-5-Trait作为参数"><a href="#11-2-5-Trait作为参数" class="headerlink" title="11.2.5 Trait作为参数"></a>11.2.5 Trait作为参数</h4><p><strong>impl Trait语法</strong></p>
<p>适用于简单情况</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123;</span><br><span class="line">  <span class="comment">// 一个trait， 可以有多个方法的签名</span></span><br><span class="line">  <span class="comment">// fn summarize(&amp;self) -&gt; String;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize1</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">"(...)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123; <span class="comment">// 类型区域 添加 impl Summary</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Trait bound语法</strong></p>
<p>可用于复杂情况</p>
<ul>
<li>impl Trait 语法是 Trait bound的语法糖</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用  +  ，指定多个 Trait bound</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display) &#123; <span class="comment">// 类型区域 添加 impl Summary</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item1: T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Trait bound 使用where子句</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T, U&gt;(a: T, b: U) -&gt; <span class="built_in">String</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, a.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Trait作为返回类型</li>
</ul>
<p>impl Trait 语法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify1</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">  NewsArticle &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>::from(<span class="string">""</span>),</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错</p>
<p>使用Trait Bound的例子</p>
<ul>
<li>例子： 使用Trait Bound修复largest函数</li>
</ul>
<ul>
<li>使用Trait Bound有条件的实现方法<ul>
<li>在使用泛型类型参数的impl块上使用 Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>可以为实现了其它Trait的任意类型有条件的实现某个Trait</li>
<li>为满足Trait Bound 的所有类型上实现Trait叫做覆盖实现；</li>
</ul>
<h3 id="11-3-生命周期"><a href="#11-3-生命周期" class="headerlink" title="11.3 生命周期"></a>11.3 生命周期</h3><p>Rust的每个引用都有自己的生命周期</p>
<p>声明周期： 引用保持有效的作用域</p>
<p>大多数情况： 声明周期是隐式的、可被推断的</p>
<p>当引用的声明周期可能以不同的方式互相关联时： 手动标注声明周期</p>
<h4 id="11-3-1-生命周期——避免悬垂引用"><a href="#11-3-1-生命周期——避免悬垂引用" class="headerlink" title="11.3.1 生命周期——避免悬垂引用"></a>11.3.1 生命周期——避免悬垂引用</h4><p>生命周期的主要目标： 避免悬垂引用（dangling reference）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> r;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    r = &amp;x; <span class="comment">// error , x走出作用域之后被释放掉了；</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"r: &#123;&#125;"</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rust如何识别上面代码不合法呢？答案是 借用检查器</p>
<h4 id="11-3-2-借用检查器"><a href="#11-3-2-借用检查器" class="headerlink" title="11.3.2 借用检查器"></a>11.3.2 借用检查器</h4><p>Rust编译器的借用检查器： 比较作用域来判断所有的借用是否合法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r;                <span class="comment">// ---------+-- 'a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">5</span>;        <span class="comment">// -+-- 'b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r: &#123;&#125;"</span>, r); <span class="comment">// ---------+         </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-3-函数中的泛型生命周期"><a href="#11-3-3-函数中的泛型生命周期" class="headerlink" title="11.3.3 函数中的泛型生命周期"></a>11.3.3 函数中的泛型生命周期</h4><h5 id="11-3-3-1-生命周期标注"><a href="#11-3-3-1-生命周期标注" class="headerlink" title="11.3.3.1 生命周期标注"></a>11.3.3.1 生命周期标注</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"abc"</span>; <span class="comment">// 字符串字面量，也就是字符串切片类型</span></span><br><span class="line">    <span class="keyword">let</span> result = longest(&amp;string1, string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"longest -&gt; &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要让参数 x，y 和 返回值 做生命周期的关联</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-3-3-2-生命周期标注"><a href="#11-3-3-2-生命周期标注" class="headerlink" title="11.3.3.2 生命周期标注"></a>11.3.3.2 生命周期标注</h5><p>生命周期标注语法</p>
<ul>
<li>生命周期的标注不会改变引用的生命周期长度</li>
<li>当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用</li>
<li>生命周期的标注： 描述了多个引用的生命周期间的关系，但不影响生命周期</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"abc"</span>; <span class="comment">// 字符串字面量，也就是字符串切片类型</span></span><br><span class="line">    <span class="keyword">let</span> result = longest(&amp;string1, string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"longest -&gt; &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要让参数 x，y 和 返回值 做生命周期的关联</span></span><br><span class="line"><span class="comment">// 'a 为生命周期的标注： 描述了多个引用的生命周期的关系</span></span><br><span class="line"><span class="comment">// 不影响生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>生命周期参数名：</p>
<ul>
<li>以 单引号 开头</li>
<li>通常全小写非常短</li>
<li>很多使用’a</li>
</ul>
<p>生命周期标注的位置</p>
<ul>
<li>在引用的 &amp; 符号后</li>
<li>使用空格将标注 和 引用类型 分开</li>
</ul>
<p>生命周期的标注</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span> <span class="comment">// 一个引用</span></span><br><span class="line">&amp; <span class="symbol">'a</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp; <span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>



<p>单个生命周期标注本身没有意义</p>
<p>标注之所以存在，是为了向rust描述多个泛型生命周期参数之间的关系</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  'a 生命周期取决于 x 和 y中 存活时间较短的那个</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-4-深入理解生命周期"><a href="#11-3-4-深入理解生命周期" class="headerlink" title="11.3.4 深入理解生命周期"></a>11.3.4 深入理解生命周期</h4><p>指定生命周期参数的方式依赖于函数所做的事情</p>
<p>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配；</p>
<p>如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值：</p>
<ul>
<li>这就是悬垂引用，该值在函数结束时就走出了作用域</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">  <span class="keyword">let</span> string2 = <span class="string">"xyz"</span>;</span><br><span class="line">  <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"the longest string is&#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp; <span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"abc"</span>);</span><br><span class="line"> <span class="comment">// result.as_str() // 报错，字符串切片引用会随着函数执行完毕被释放，所以会导致 悬垂引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>解决方法一：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp; <span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"abc"</span>);</span><br><span class="line"> 	result <span class="comment">// 把函数所有权移交给调用者；然后这块内存清理就交由调用者来清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个例子看出，生命周期语法就是用来关联函数的不同参数以及返回值之间生命周期的。一旦它们取得某种联系，rust就获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其它违反内存安全的行为；</p>
<h5 id="11-3-4-1-Struct定义中的生命周期标注"><a href="#11-3-4-1-Struct定义中的生命周期标注" class="headerlink" title="11.3.4.1 Struct定义中的生命周期标注"></a>11.3.4.1 Struct定义中的生命周期标注</h5><p>Struct里可包括：</p>
<ul>
<li>自持有的类型 </li>
<li>引用： 需要在每个引用上添加生命周期标注</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"call me inhmael, Some years age..."</span>);</span><br><span class="line">  <span class="comment">// first_sentence 的生命周期反问大于 结构体内的 first_sentence；所以此段代码可以编译通过</span></span><br><span class="line">  <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not found a '.'"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> i = ImportantExcerpt&#123;</span><br><span class="line">    part: first_sentence</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-3-4-2-生命周期的省略"><a href="#11-3-4-2-生命周期的省略" class="headerlink" title="11.3.4.2 生命周期的省略"></a>11.3.4.2 生命周期的省略</h5><p>每个引用都有生命周期</p>
<p>需要为使用生命周期的函数或struct指定生命周期参数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有指定生命周期参数却通过编译</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">  <span class="keyword">for</span>(i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而之前的例子告诫我们应该写成下面这种才能编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s : &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp; <span class="symbol">'a</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure>

<p> Rust发现，在某些特定情况下。程序员总是一遍又一遍编写同样的生命周期标注。而且这种场景是可预测的。它有一些明确的模式</p>
<p>于是，rust团队就将这些模式写入了编译器代码。就使得借用检查器在这些情况下可以自动的对生命周期进行推导，而无需显式的标注。</p>
<p>了解这段历史是有必要的，因为在未来可能会有更多的特定模式被直接添加到编译器当中；也就是说在未来需要手动标注生命周期的地方可能会越来越少；</p>
<h5 id="11-3-4-3-生命周期省略规则"><a href="#11-3-4-3-生命周期省略规则" class="headerlink" title="11.3.4.3 生命周期省略规则"></a>11.3.4.3 生命周期省略规则</h5><p>这个在Rust引用分析中所编入的模式就称为生命周期省略规则；</p>
<ul>
<li>这些规则无需开发者来遵守</li>
<li>它们是一些特殊情况，由编译器来考虑</li>
<li>如果你的代码复合这些情况，那么久无需显式标注生命周期</li>
</ul>
<p>生命周期省略规则不会提供完整的推断：</p>
<p>如果应用规则后，引用的生命周期仍然模糊不清-&gt; 编译错误</p>
<p>解决方法： 添加生命周期标注，表明引用间的相互关系</p>
<h5 id="11-3-4-4-输入、输出生命周期"><a href="#11-3-4-4-输入、输出生命周期" class="headerlink" title="11.3.4.4 输入、输出生命周期"></a>11.3.4.4 输入、输出生命周期</h5><p>生命周期在</p>
<ul>
<li>函数/方法的参数： 输入生命周期</li>
<li>函数/方法的返回值： 输出生命周期</li>
</ul>
<h5 id="11-3-4-5-生命周期省略的三个规则"><a href="#11-3-4-5-生命周期省略的三个规则" class="headerlink" title="11.3.4.5 生命周期省略的三个规则"></a>11.3.4.5 生命周期省略的三个规则</h5><p>编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期；</p>
<ul>
<li>规则1 应用于输入生命周期</li>
<li>规则2、3 应用于输出生命周期</li>
<li>如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用 -&gt; 报错</li>
<li>这些规则适用于fn定义 和 impl块</li>
</ul>
<p><strong>规则1: 每个引用类型的参数都有自己的生命周期</strong></p>
<p>换句话说，单参数的函数它就拥有一个生命周期参数，而拥有两个参数的函数就拥有两个不同的生命周期参数。</p>
<p><strong>规则2: 如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数</strong></p>
<p><strong>规则3： 如果有多个输入生命周期参数，但其中一个是 &amp;self 或者 &amp; mut self（是方法），那么self的生命周期会被赋给所有的输出生命周期参数</strong></p>
<p>demo1</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 首先适用第一条规则，单参数函数它拥有一个生命周期参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 第二条规则，如果只有1个输入生命周期参数，该生命周期被赋给所有输出生命周期参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp; <span class="symbol">'a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure>



<p>demo2</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">//首先应用规则1，两个参数都有自己的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>,<span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>)-&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 因为有两个参数，所以第二条规则已经不适用了</span></span><br><span class="line"><span class="comment">// 没有self，所有第三条也不适用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在应用完三条规则之后，依然无法计算出返回类型的生命周期。所以编译器报错。</span></span><br></pre></td></tr></table></figure>



<h4 id="11-3-5-方法定义中的生命周期标注"><a href="#11-3-5-方法定义中的生命周期标注" class="headerlink" title="11.3.5 方法定义中的生命周期标注"></a>11.3.5 方法定义中的生命周期标注</h4><p>在struct上使用生命周期实现方法，语法和泛型参数的语法一样</p>
<ul>
<li>在哪儿声明和使用生命周期参数 依赖于<ul>
<li>生命周期参数是否和字段、方法的参数或返回值有关</li>
</ul>
</li>
</ul>
<p>struct字段的生命周期名：</p>
<ul>
<li>在impl后声明</li>
<li>在struct名后使用</li>
<li>这些生命周期是struct类型的一部分</li>
</ul>
<p>impl块内的方法签名中：</p>
<ul>
<li><p>引用必须绑定于struct字段引用的生命周期，或者引用是独立的也可以</p>
</li>
<li><p>生命周期省略规则经常使用方法中的生命周期标注不是必须的；</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// impl 后面 和结构体后面 的生命周期参数不能省略</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"Call me Ishmael,Some..."</span>);</span><br><span class="line">  <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not found a '.'"</span>);</span><br><span class="line">  <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">    part: first_sentence</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-6-静态生命周期"><a href="#11-3-6-静态生命周期" class="headerlink" title="11.3.6 静态生命周期"></a>11.3.6 静态生命周期</h4><p>‘static 是一个特殊的生命周期： 整个程序的持续时间；</p>
<ul>
<li>例如： 所有的字符串字面值都拥有 ‘static 生命周期</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"i have a static lifetime"</span></span><br><span class="line"><span class="comment">// 这个字符串字面值，它是被直接存储在二进制程序里面。所以它总是可用的。所以所有字符串字面值的生命周期都是 'static</span></span><br></pre></td></tr></table></figure>

<p>为引用指定 ‘static 生命周期前要三思</p>
<ul>
<li>是否需要引用在程序整个生命周期内都存活</li>
</ul>
<p>因为在大部分情况下，错误的原因都在于尝试创建一个悬垂引用或者是可用生命周期不匹配。这个时候应该去尝试解决这些问题，而不是指定一个 ‘static </p>
<p><strong>一个涉及泛型参数类型、Trait Bound、生命周期的例子</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_announcement</span></span>&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line">(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, ann: T) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">where</span> T: Display,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"Announcement! &#123;&#125;"</span>, ann);</span><br><span class="line">  <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-编写自动化测试"><a href="#12-编写自动化测试" class="headerlink" title="12 编写自动化测试"></a>12 编写自动化测试</h2><h3 id="12-1-编写和运行测试"><a href="#12-1-编写和运行测试" class="headerlink" title="12.1 编写和运行测试"></a>12.1 编写和运行测试</h3><p>测试</p>
<ul>
<li>函数</li>
<li>验证非测试代码的功能是否和预期一致</li>
</ul>
<p>测试函数体（通常）执行的3个操作 （3A操作）</p>
<ul>
<li>准备数据/状态 Arrange</li>
<li>运行被测试的代码  Act</li>
<li>断言（Assert）结果 Assert</li>
</ul>
<p>解剖测试函数</p>
<p>测试函数需要使用test属性（attribute）进行标注</p>
<ul>
<li>Attribute 就是一段Rust代码的元数据，它不会被改变被它修饰代码的逻辑，它只是被代码进行修饰或标注</li>
<li>在函数上面一行加上 #[test]，可以函数变为测试函数</li>
</ul>
<p>运行测试</p>
<ul>
<li>使用cargo test命令运行所有测试函数<ul>
<li>Rust会构建一个Test Runner可执行文件<ul>
<li>它会运行标注了test的函数，并报错其运行是否成功</li>
</ul>
</li>
</ul>
</li>
<li>当使用cargo 创建library项目的时候，会生成一个test module，里面有一个test函数；<ul>
<li>你可以添加任意数量的test module或函数</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$&gt; cargo new adder --lib <span class="comment"># 创建一个库项目 adder</span></span><br><span class="line">$&gt; <span class="built_in">cd</span> adder &amp;&amp; cargo <span class="built_in">test</span> <span class="comment"># 运行测试</span></span><br><span class="line"></span><br><span class="line">$&gt; Compiling adder v0.1.0 (/Users/ruanhan/rust_pro/adder)</span><br><span class="line"></span><br><span class="line">Finished <span class="built_in">test</span> [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 1.25s</span><br><span class="line"></span><br><span class="line">Running target/debug/deps/adder-710a662a5bf33e5e</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 tests::it_works </span></span><br><span class="line"><span class="built_in">test</span> tests::it_works ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br><span class="line"></span><br><span class="line">Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br></pre></td></tr></table></figure>



<p>测试失败</p>
<ul>
<li>测试函数panic就表示失败</li>
<li>每个测试运行在一个新线程</li>
<li>当主线程看见某个测试线程挂掉了，那个测试标记为失败了；</li>
</ul>
<h3 id="12-2-断言宏（Assert）"><a href="#12-2-断言宏（Assert）" class="headerlink" title="12.2 断言宏（Assert）"></a>12.2 断言宏（Assert）</h3><p>使用assert! 宏检查测试结果</p>
<p>assert！ 宏，来自标准库，用来确定某个状态是否为true</p>
<ul>
<li>true 测试通过</li>
<li>false 调用panic！，测试失败</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">larger_can_hold_smaller</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> larger = Rectangle &#123;</span><br><span class="line">            width: <span class="number">8</span>,</span><br><span class="line">            height: <span class="number">7</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> smaller = Rectangle &#123;</span><br><span class="line">            width: <span class="number">5</span>,</span><br><span class="line">            height: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(larger.can_hold(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用assert_eq! 和 assert_ne! 测试相等性</strong></p>
<p>都来自标准库</p>
<p>判断两个参数是否 相等或不等；</p>
<p>实际上，它们使用的就是 == 和 != 运算符</p>
<p>断言失败： 自动打印出两个参数的值；</p>
<ul>
<li>使用debug格式打印参数<ul>
<li>要求参数实现了 PartiaEq 和 Debug Traits（所有的基本类型和标准库里大部分类型都实现了）</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests1 &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, add_two(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3-自定义错误信息"><a href="#12-3-自定义错误信息" class="headerlink" title="12.3 自定义错误信息"></a>12.3 自定义错误信息</h3><p>可以向 assert!    assert_eq!   assert_ne! 添加可选的自定义信息</p>
<ul>
<li>这些自定义消息和失败消息都会打印出来</li>
<li>assert!: 第1参数必填，自定义消息作为第2个参数</li>
<li>assert_eq!   assert_ne! ： 前2个参数必填，自定义消息作为第3个参数；</li>
<li>自定义消息参数会被传递给 format!  宏，可以使用{} 占位符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">greeting</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Hello &#123;&#125;!"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greeting_contain_name</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = greeting(<span class="string">"Carol"</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(result.contains(<span class="string">"Caro1l"</span>), <span class="string">"错误信息是 '&#123;&#125;'"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-用should-panic检查恐慌"><a href="#12-4-用should-panic检查恐慌" class="headerlink" title="12.4 用should_panic检查恐慌"></a>12.4 用should_panic检查恐慌</h3><p>验证错误处理的情况</p>
<ul>
<li>测试除了验证代码的返回值是否正确，还需验证代码是否如预期的处理了发生错误的情况；</li>
<li>可验证代码在特定情况下是否发生了panic</li>
<li>这种测试需要添加 should_panic 属性</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be between 1 and 100, got &#123;&#125;."</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为should_panic 属性添加一个可选的expected参数，让should_panic更精确；将检查失败信息中是否包含所指定文字；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[should_panic(expected=<span class="meta-string">"guess value must be less than ..."</span>)]</span></span><br></pre></td></tr></table></figure>



<h3 id="12-5-在测试中使用Result-lt-T-E-gt"><a href="#12-5-在测试中使用Result-lt-T-E-gt" class="headerlink" title="12.5 在测试中使用Result&lt;T,E&gt;"></a>12.5 在测试中使用Result&lt;T,E&gt;</h3><p>无需panic，可使用Result&lt;T,E&gt; 作为返回类型编写测试：</p>
<ul>
<li>返回Ok： 测试通过</li>
<li>返回Err： 测试失败</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line">mode test &#123;</span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span> -&gt; <span class="title">Result</span></span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>+<span class="number">2</span> ==<span class="number">4</span> &#123;</span><br><span class="line">      <span class="literal">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">"not equal"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： 不要在使用Result&lt;T,E&gt; 编写的测试上标注</p>
<p>#[should_panic]</p>
<h3 id="12-6-控制测试如何运行"><a href="#12-6-控制测试如何运行" class="headerlink" title="12.6 控制测试如何运行"></a>12.6 控制测试如何运行</h3><p>改变cargo test的行为： 添加命令行参数</p>
<p>不添加任何参数就是默认行为</p>
<ul>
<li>并行运行</li>
<li>所有测试</li>
<li>捕获（不显示）所有输出，使读取与测试结果相关的输出更容易</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示cargo test命令 所用的参数有哪些</span></span><br><span class="line">cargo <span class="built_in">test</span> --<span class="built_in">help</span> </span><br><span class="line"><span class="comment"># 显示出所有可以用在-- 后的参数，给二进制程序添加的参数</span></span><br><span class="line">cargo <span class="built_in">test</span> -- --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>



<h3 id="12-7-并行-连续运行测试"><a href="#12-7-并行-连续运行测试" class="headerlink" title="12.7 并行/连续运行测试"></a>12.7 并行/连续运行测试</h3><p>运行多个测试： 默认使用多个线程并行运行；</p>
<ul>
<li>运行快</li>
</ul>
<p>确保测试之间</p>
<ul>
<li>不会互相依赖</li>
<li>不依赖于某个共享状态（环境、工作目录、环境变量等）</li>
</ul>
<p>显式函数输出</p>
<p>默认，如测试通过，rust的test库会捕获所有打印到标准输出的内容</p>
<p>例如： 如果被测试代码中用到了println!</p>
<ul>
<li>如果测试通过： 不会在终端看到println! 打印的内容</li>
<li>如果测试失败： 会看到println! 打印的内容和失败信息</li>
</ul>
<p>如果想在成功的测试中看到打印的内容： –show-output</p>
<h3 id="12-8-按名称运行测试"><a href="#12-8-按名称运行测试" class="headerlink" title="12.8 按名称运行测试"></a>12.8 按名称运行测试</h3><p>运行单个测试： 指定测试名</p>
<p>运行多个测试： 指定测试名的一部分（模块名也可以）</p>
<h3 id="12-9-忽略测试"><a href="#12-9-忽略测试" class="headerlink" title="12.9 忽略测试"></a>12.9 忽略测试</h3><p>忽略某些测试，运行剩余测试</p>
<ul>
<li>ignore属性（attribute）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="meta">#[ignore]</span> <span class="comment">// 忽略 expensive_test这个测试</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>cargo test – –ignore  单独执行此忽略的测试</p>
<h3 id="12-10-测试的分类"><a href="#12-10-测试的分类" class="headerlink" title="12.10 测试的分类"></a>12.10 测试的分类</h3><p>Rust对测试的分类</p>
<ul>
<li>单元测试</li>
<li>集成测试</li>
</ul>
<p>单元测试</p>
<ul>
<li>小、专注</li>
<li>一次对一个模块进行隔离的测试</li>
<li>可测试private接口</li>
</ul>
<p>集成测试：</p>
<p>在库外部，和其它外部代码一样使用你的代码</p>
<p>只能使用public接口</p>
<p>可能在每个测试中使用多个模块</p>
<p>#[cfg(test)] 标注</p>
<p>test 模块上的 #[cfg(test)]标注</p>
<ul>
<li>只有运行 cargo test 才编译和运行代码</li>
<li>运行cargo build则不会</li>
</ul>
<p>集成测试在不同的目录，它不需要 #[cfg(test)] 标注</p>
<p>cfg：configuration</p>
<ul>
<li>告诉rust下面的条目只有在特定的配置选项下才被包含</li>
<li>配置选项test： 由Rust提供，用来编译和运行测试<ul>
<li>只有cargo test才会编译代码，包括模块中的helper函数和 #[test]标注的函数</li>
</ul>
</li>
</ul>
<p>测试私有函数</p>
<ul>
<li>rust允许测试私有函数</li>
</ul>
<h3 id="12-11-集成测试"><a href="#12-11-集成测试" class="headerlink" title="12.11 集成测试"></a>12.11 集成测试</h3><p>在Rust里，集成测试完全位于被测试库的外部</p>
<p>目的：是测试被测试库的多个部分是否能正确在一起工作</p>
<p>集成测试的覆盖率很重要；</p>
<h2 id="13-rustlings"><a href="#13-rustlings" class="headerlink" title="13 rustlings"></a>13 rustlings</h2><p>Thanks for installing Rustlings!</p>
<p>Is this your first time? Don’t worry, Rustlings was made for beginners! We are<br>going to teach you a lot of things about Rust, but before we can get<br>started, here’s a couple of notes about how Rustlings operates:</p>
<ol>
<li>The central concept behind Rustlings is that you solve exercises. These<br>exercises usually have some sort of syntax error in them, which will cause<br>them to fail compliation or testing. Sometimes there’s a logic error instead<br>of a syntax error. No matter what error, it’s your job to find it and fix it!<br>You’ll know when you fixed it because then, the exercise will compile and<br>Rustlings will be able to move on to the next exercise.</li>
<li>If you run Rustlings in watch mode (which we recommend), it’ll automatically<br>start with the first exercise. Don’t get confused by an error message popping<br>up as soon as you run Rustlings! This is part of the exercise that you’re<br>supposed to solve, so open the exercise file in an editor and start your<br>detective work!</li>
<li>If you’re stuck on an exercise, there is a helpful hint you can view by typing<br>‘hint’ (in watch mode), or running <code>rustlings hint myexercise</code>.</li>
<li>If an exercise doesn’t make sense to you, feel free to open an issue on GitHub!<br>(<a href="https://github.com/rust-lang/rustlings/issues/new" target="_blank" rel="noopener">https://github.com/rust-lang/rustlings/issues/new</a>). We look at every issue,<br>and sometimes, other learners do too so you can help each other out!</li>
</ol>
<p>Got all that? Great! To get started, run <code>rustlings watch</code> in order to get the first<br>exercise. Make sure to have your editor open!</p>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2021/03/16/rust/>http://yoursite.com/2021/03/16/rust/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-03-16T14:12:42+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Mar 16, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/doc/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>doc</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2021/03/16/rust/&title=rust - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2021/03/16/rust/&title=rust - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2021/03/16/rust/&title=rust - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
            
              <a class='next' href='/2021/03/09/go1/'>
                <p class='title'>go1<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>1. 编译型语言Go 语言是一门编译语言

在运行程序之前，GO首先使用编译器把代码编译成机器可以识别的1和0
它会把代码编译成一个可执行文件，在编译的过程中，编译器能捕获一些错误；

解释型语...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'rust',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-rust"><span class="toc-text">1. rust</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-cargo"><span class="toc-text">2. cargo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-cargo-toml"><span class="toc-text">2.1 cargo.toml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-crate"><span class="toc-text">2.2 crate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-非cargo创建的项目"><span class="toc-text">2.3 非cargo创建的项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Cargo-构建项目"><span class="toc-text">2.4 Cargo 构建项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-cargo-lock"><span class="toc-text">2.4.1 cargo.lock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-构建和运行cargo项目"><span class="toc-text">2.5 构建和运行cargo项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-cargo-check"><span class="toc-text">2.6 cargo check</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-发布"><span class="toc-text">2.7 发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-添加依赖包"><span class="toc-text">2.8 添加依赖包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-guess-number-pro"><span class="toc-text">3. guess number-pro</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-read-line"><span class="toc-text">3.1 read_line</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-完整代码"><span class="toc-text">3.2 完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-通用编程概念"><span class="toc-text">4. 通用编程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-变量与可变性"><span class="toc-text">4.1 变量与可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-变量与常量"><span class="toc-text">4.1.1 变量与常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-Shadowing-隐藏"><span class="toc-text">4.1.2 Shadowing(隐藏)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-shadow与mut"><span class="toc-text">4.1.3 shadow与mut</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-数据类型"><span class="toc-text">4.2 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-标量类型"><span class="toc-text">4.2.1 标量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-1-整数类型"><span class="toc-text">4.2.1.1 整数类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-2-浮点类型"><span class="toc-text">4.2.1.2 浮点类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-3-布尔类型"><span class="toc-text">4.2.1.3 布尔类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-4-字符类型"><span class="toc-text">4.2.1.4 字符类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-复合类型"><span class="toc-text">4.2.2 复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-1-Tuple"><span class="toc-text">4.2.2.1 Tuple</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-2-数组"><span class="toc-text">4.2.2.2 数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-函数"><span class="toc-text">4.3 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-函数的返回值"><span class="toc-text">4.3.1 函数的返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-注释"><span class="toc-text">4.4 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-控制流"><span class="toc-text">4.5 控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-if-else"><span class="toc-text">4.5.1 if else</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-循环"><span class="toc-text">4.5.2 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2-1-使用for循环遍历集合"><span class="toc-text">4.5.2.1 使用for循环遍历集合</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-所有权"><span class="toc-text">5. 所有权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-stack-vs-heap"><span class="toc-text">5.1 stack vs heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-所有权存在的原因"><span class="toc-text">5.2 所有权存在的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-所有权解决的问题"><span class="toc-text">5.2.1 所有权解决的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-所有权规则"><span class="toc-text">5.3 所有权规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-变量作用域"><span class="toc-text">5.3.1 变量作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-String类型"><span class="toc-text">5.3.2 String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-1-创建String类型的值"><span class="toc-text">5.3.2.1 创建String类型的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-2-内存和分配"><span class="toc-text">5.3.2.2 内存和分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-变量和数据交互的方式"><span class="toc-text">5.4 变量和数据交互的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-移动（Move）"><span class="toc-text">5.4.1 移动（Move）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-浅拷贝和深拷贝"><span class="toc-text">5.4.2 浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-变量和数据交互的方式：克隆（Clone）"><span class="toc-text">5.4.3 变量和数据交互的方式：克隆（Clone）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-复制"><span class="toc-text">5.4.4 复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-1-Copy-trait"><span class="toc-text">5.4.4.1 Copy trait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-2-一些拥有Copy-trait的类型"><span class="toc-text">5.4.4.2 一些拥有Copy trait的类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-所有权与函数"><span class="toc-text">5.5 所有权与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-将值传递给函数将发生移动或复制"><span class="toc-text">5.5.1 将值传递给函数将发生移动或复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-返回值与作用域"><span class="toc-text">5.5.2 返回值与作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-引用"><span class="toc-text">5.6 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-引用"><span class="toc-text">5.6.1 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-2-借用"><span class="toc-text">5.6.2 借用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-3-可变引用"><span class="toc-text">5.6.3 可变引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-4-悬垂引用-Dangling-References"><span class="toc-text">5.6.4 悬垂引用 Dangling References</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-5-引用的规则"><span class="toc-text">5.6.5 引用的规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-切片-slice"><span class="toc-text">5.7 切片 slice</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-字符串切片"><span class="toc-text">5.7.1 字符串切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-字符串字面值是切片"><span class="toc-text">5.7.2 字符串字面值是切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-3-将字符串切片作为参数传递"><span class="toc-text">5.7.3 将字符串切片作为参数传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-struct"><span class="toc-text">6. struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-定义并实例化struct"><span class="toc-text">6.1 定义并实例化struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-tuple-struct"><span class="toc-text">6.1.1 tuple struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-Unit-Like-Struct（没有任何字段）"><span class="toc-text">6.1.2 Unit-Like Struct（没有任何字段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-struct-数据的所有权"><span class="toc-text">6.1.3 struct 数据的所有权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-计算面积的例子"><span class="toc-text">6.1.4 计算面积的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-5-几种模式"><span class="toc-text">6.1.5 几种模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-struct的方法"><span class="toc-text">6.2 struct的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-方法调用的运算符"><span class="toc-text">6.2.1 方法调用的运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-方法参数"><span class="toc-text">6.2.2 方法参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-关联函数"><span class="toc-text">6.3 关联函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-枚举与模式匹配"><span class="toc-text">7. 枚举与模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-定义"><span class="toc-text">7.1 定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-将数据附加到枚举的变体中"><span class="toc-text">7.1.1 将数据附加到枚举的变体中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-option枚举"><span class="toc-text">7.2 option枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-Option"><span class="toc-text">7.2.1 Option</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-match"><span class="toc-text">7.3 match</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-绑定值的模式"><span class="toc-text">7.3.1 绑定值的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-匹配Option"><span class="toc-text">7.3.2 匹配Option</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-match必须穷举所有可能"><span class="toc-text">7.3.3 match必须穷举所有可能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-if-let"><span class="toc-text">7.4 if let</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Package-Crate-和-Module"><span class="toc-text">8. Package, Crate 和 Module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Package-和-Crate"><span class="toc-text">8.1 Package 和 Crate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-Cargo的惯例"><span class="toc-text">8.1.1 Cargo的惯例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Crate的作用"><span class="toc-text">8.2 Crate的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-定义module来控制作用域和私有性"><span class="toc-text">8.3 定义module来控制作用域和私有性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-建立module"><span class="toc-text">8.3.1 建立module</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-path"><span class="toc-text">8.4 path</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-私有边界（private-boundary）"><span class="toc-text">8.4.1 私有边界（private boundary）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-super关键字"><span class="toc-text">8.4.2 super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-use关键字"><span class="toc-text">8.4.3 use关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-3-1-使用pub-use重新导出名称"><span class="toc-text">8.4.3.1 使用pub use重新导出名称</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-3-2-使用嵌套路径清理大量的use语句"><span class="toc-text">8.4.3.2 使用嵌套路径清理大量的use语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-4-通配符"><span class="toc-text">8.4.4 通配符 *</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-5-as关键字"><span class="toc-text">8.4.5  as关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-6-使用外部包（package）"><span class="toc-text">8.4.6 使用外部包（package）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-6-1-切换国内镜像"><span class="toc-text">8.4.6.1 切换国内镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-将模块拆分为不同文件"><span class="toc-text">8.5 将模块拆分为不同文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-集合"><span class="toc-text">9. 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Vector"><span class="toc-text">9.1 Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-创建"><span class="toc-text">9.1.1 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-所有权和借用规则"><span class="toc-text">9.1.2 所有权和借用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-遍历"><span class="toc-text">9.1.3 遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-vector-enum"><span class="toc-text">9.1.4 vector+enum</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-String"><span class="toc-text">9.2 String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-定义"><span class="toc-text">9.2.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-String类型"><span class="toc-text">9.2.2 String类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3-其它类型的字符串"><span class="toc-text">9.2.3 其它类型的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4-使用初始值创建String"><span class="toc-text">9.2.4 使用初始值创建String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-5-更新"><span class="toc-text">9.2.5 更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-6-format-连接多个字符串"><span class="toc-text">9.2.6 format! 连接多个字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-7-索引字符串"><span class="toc-text">9.2.7 索引字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-8-bytes，scalar-Values，-Grapheme-Clusters-字节、标量值、字形簇"><span class="toc-text">9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-9-Rust不允许对String进行索引最后一个原因"><span class="toc-text">9.2.9 Rust不允许对String进行索引最后一个原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-10-字符串切割"><span class="toc-text">9.2.10 字符串切割</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-HashMap"><span class="toc-text">9.3 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-get"><span class="toc-text">9.3.1 get</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-更新HashMap"><span class="toc-text">9.3.2 更新HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-2-1-entry"><span class="toc-text">9.3.2.1 entry</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-panic"><span class="toc-text">10. panic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-Result-与可恢复的错误"><span class="toc-text">10.1 Result 与可恢复的错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-匹配不同的错误"><span class="toc-text">10.2 匹配不同的错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-unwrap"><span class="toc-text">10.2.1 unwrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-expect"><span class="toc-text">10.2.2 expect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-传播错误"><span class="toc-text">10.3 传播错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-什么时候应该用panic"><span class="toc-text">10.4 什么时候应该用panic!</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-泛型，Trait-生命周期"><span class="toc-text">11. 泛型，Trait 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-泛型"><span class="toc-text">11.1 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-Trait"><span class="toc-text">11.2 Trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-如何定义一个trait"><span class="toc-text">11.2.1 如何定义一个trait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2-在类型上实现trait"><span class="toc-text">11.2.2 在类型上实现trait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-3-实现trait的约束"><span class="toc-text">11.2.3 实现trait的约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-4-默认实现"><span class="toc-text">11.2.4 默认实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-5-Trait作为参数"><span class="toc-text">11.2.5 Trait作为参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-生命周期"><span class="toc-text">11.3 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-生命周期——避免悬垂引用"><span class="toc-text">11.3.1 生命周期——避免悬垂引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-借用检查器"><span class="toc-text">11.3.2 借用检查器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-3-函数中的泛型生命周期"><span class="toc-text">11.3.3 函数中的泛型生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-3-1-生命周期标注"><span class="toc-text">11.3.3.1 生命周期标注</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-3-2-生命周期标注"><span class="toc-text">11.3.3.2 生命周期标注</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-4-深入理解生命周期"><span class="toc-text">11.3.4 深入理解生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-4-1-Struct定义中的生命周期标注"><span class="toc-text">11.3.4.1 Struct定义中的生命周期标注</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-4-2-生命周期的省略"><span class="toc-text">11.3.4.2 生命周期的省略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-4-3-生命周期省略规则"><span class="toc-text">11.3.4.3 生命周期省略规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-4-4-输入、输出生命周期"><span class="toc-text">11.3.4.4 输入、输出生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-4-5-生命周期省略的三个规则"><span class="toc-text">11.3.4.5 生命周期省略的三个规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-5-方法定义中的生命周期标注"><span class="toc-text">11.3.5 方法定义中的生命周期标注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-6-静态生命周期"><span class="toc-text">11.3.6 静态生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-编写自动化测试"><span class="toc-text">12 编写自动化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-编写和运行测试"><span class="toc-text">12.1 编写和运行测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-断言宏（Assert）"><span class="toc-text">12.2 断言宏（Assert）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-自定义错误信息"><span class="toc-text">12.3 自定义错误信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-用should-panic检查恐慌"><span class="toc-text">12.4 用should_panic检查恐慌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-在测试中使用Result-lt-T-E-gt"><span class="toc-text">12.5 在测试中使用Result&lt;T,E&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-控制测试如何运行"><span class="toc-text">12.6 控制测试如何运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-并行-连续运行测试"><span class="toc-text">12.7 并行&#x2F;连续运行测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8-按名称运行测试"><span class="toc-text">12.8 按名称运行测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9-忽略测试"><span class="toc-text">12.9 忽略测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-10-测试的分类"><span class="toc-text">12.10 测试的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-11-集成测试"><span class="toc-text">12.11 集成测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-rustlings"><span class="toc-text">13 rustlings</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
