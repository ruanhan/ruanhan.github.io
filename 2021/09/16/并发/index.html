<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#1.0.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>并发 - Hexo</title>
  
    <meta name="keywords" content="guide">
  
  
    <meta name="description" content="并发详解">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            BELIEF <b><sup style='color:#3AA757'>1.0.0</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2021/09/16/%E5%B9%B6%E5%8F%91/">
      并发
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://xaoxuu.com" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>Mr. X</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/C/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>C</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Sep 16, 2021</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <blockquote>
<p>多线程应用程序，每个thread都像在这个程序中运行的独立代理程序，代表程序做事。但是这些线程访问内存，每个内存节点对于它们来说都像是个桃子。如果我们不协调线程之间的内存访问，程序将无法按预期工作；</p>
<p>操作系统必须用锁(lock)和条件变量(condition variable)这样的原语’来支持多线程应用程序。操作系统本身是 第一个并发程序-—它必须非常小心地访问自己的内存’否则会发生许多奇怪而可怕的事 情。</p>
</blockquote>
<h2 id="26-并发：介绍"><a href="#26-并发：介绍" class="headerlink" title="26 并发：介绍"></a>26 并发：介绍</h2><h3 id="实例：-线程创建"><a href="#实例：-线程创建" class="headerlink" title="实例： 线程创建"></a>实例： 线程创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (<span class="keyword">char</span> *) arg);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line">  <span class="keyword">int</span> rc;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main:begin\n"</span>);</span><br><span class="line">  <span class="comment">// pthread_create 创建线程</span></span><br><span class="line">  rc = pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"A"</span>);</span><br><span class="line">  assert(rc == <span class="number">0</span>);</span><br><span class="line">  rc = pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">"B"</span>);</span><br><span class="line">  assert(rc ==<span class="number">0</span> );</span><br><span class="line">  <span class="comment">// pthread_join 给线程收尸</span></span><br><span class="line">  rc = pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">  assert(rc == <span class="number">0</span>);</span><br><span class="line">  rc = pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">  assert(rc ==<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的结论： 我们甚至可以在“A”之前看到“B”’即使先前创建了线程1。 线程的执行顺序跟书写代码的顺序无关，跟操作系统的调度有关；</p>
<h3 id="为什么更糟糕：-共享数据"><a href="#为什么更糟糕：-共享数据" class="headerlink" title="为什么更糟糕： 共享数据"></a>为什么更糟糕： 共享数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mythreads.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// volatile </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s: begin\n"</span>, (<span class="keyword">char</span> *)arg);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1e7</span>; i++) &#123;</span><br><span class="line">    counter = counter +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:done\n"</span>,(<span class="keyword">char</span> *)arg);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main: begin(counter=%d)\n"</span>, counter);</span><br><span class="line">  Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"A"</span>);</span><br><span class="line">  Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">  pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main: done with both (counter=%d)\n"</span>, counter);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mythreads.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = pthread_create(thread, attr, start_routine, arg);</span><br><span class="line">    assert(rc == <span class="number">0</span>); <span class="comment">// check线程创建是否失败</span></span><br><span class="line">  <span class="comment">// Pthread_create 只需调用pthread_create，并确保返回值为0.如果不是，返回异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main: begin(counter=0)</span><br><span class="line">A: begin</span><br><span class="line">B: begin</span><br><span class="line">B:<span class="keyword">done</span></span><br><span class="line">main: <span class="keyword">done</span> with both (counter=10684672)</span><br><span class="line"></span><br><span class="line">main: begin(counter=0)</span><br><span class="line">A: begin</span><br><span class="line">B: begin</span><br><span class="line">A:<span class="keyword">done</span></span><br><span class="line">B:<span class="keyword">done</span></span><br><span class="line">main: <span class="keyword">done</span> with both (counter=10720004)</span><br><span class="line"></span><br><span class="line">main: begin(counter=0)</span><br><span class="line">A: begin</span><br><span class="line">B: begin</span><br><span class="line">B:<span class="keyword">done</span></span><br><span class="line">main: <span class="keyword">done</span> with both (counter=9683130)</span><br><span class="line"></span><br><span class="line">main: begin(counter=0)</span><br><span class="line">B: begin</span><br><span class="line">A: begin</span><br><span class="line">A:<span class="keyword">done</span></span><br><span class="line">B:<span class="keyword">done</span></span><br><span class="line">main: <span class="keyword">done</span> with both (counter=10439829)</span><br></pre></td></tr></table></figure>

<p>两个线程尝试向共享变量添加一个数字，并在循环中执行1000万（10^7）次。因此，预期的最终结果是：20000000. 但是显然，多次执行的结果均未达到目标值；</p>
<h3 id="核心问题：-不可控的调度"><a href="#核心问题：-不可控的调度" class="headerlink" title="核心问题： 不可控的调度"></a>核心问题： 不可控的调度</h3><p>counter加上1的汇编代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 0x80491a, %eax</span><br><span class="line">add <span class="variable">$0x1</span>, %eax</span><br><span class="line">mov %eax, 0x8049a1c</span><br></pre></td></tr></table></figure>

<p>变量counter 位于地址 0x80491a，</p>
<p>mov指令，从内存地址取出值，放入 eax；</p>
<p>给eax寄存器的值 加1 (0x1)；</p>
<p>eax的值被存回内存中相同的地址；</p>
<ul>
<li>竞态条件（race condition）</li>
</ul>
<p>因为这段程序并不原子，。执行这段代码的多个线程可能导致竞争状态，因此将此段代码称为临界区。(critical section) 。<strong>临界区是访问共享变量（共享资源）的代码片段，一定不能由多个线程同时执行；</strong></p>
<p>我们真正想要的代码就是所谓的互斥(mutual exclusion)。这个属性保证了如果一个线程在临界区内执行，其他线程将被阻止进入临界区；</p>
<h3 id="原子性愿望"><a href="#原子性愿望" class="headerlink" title="原子性愿望"></a>原子性愿望</h3><blockquote>
<p>解决这个问题的一种途径是拥有更强大的指令；单步就能完成要做的事情，从而消除不合时宜的中断的可能性。比如</p>
</blockquote>
<p><code>memory-add 0x8049a1c, $0x1</code></p>
<p>假设上面这条指令将一个值添加到内存位置，并且硬件保证它以原子(atomically)执行。当指令执行时，它会像期望那样执行更新。它不能在指令中间中断，因为这正是我们从硬件获得的保证：<strong>发生中断时，指令根本没有运行，或者运行完成，没有中间状态。</strong>但是在一般情况下，不会有这样的指令。</p>
<p>因此，我们要做的是要求硬件提供一些有用的指令，可以在这些指令上构建一个通用的集合，即所谓的 <strong>“同步原语”（synchronization primitive）</strong>通过使用这些硬件同步原语，加上操作系统的一些帮助，我们将能够构建多线程代码，以同步和受控的方式访问临界区，从而可靠地产生正确的结果——尽管有并发执行的挑战。</p>
<ul>
<li>临界区（critical section），是访问共享资源的一段代码，资源通常是一个变量或数据结构；</li>
<li>竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果</li>
<li>不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确定的结果。</li>
<li>为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出；</li>
</ul>
<p><strong>关键条件：为了构建有用的同步原语，需要从硬件中获得哪些支持？需要从操作系统中获得什么支持？如何正确有效地构建这些原语？程序如何使用它们来获得期望的结果？</strong></p>
<h3 id="还有一个问题：等待另一个线程"><a href="#还有一个问题：等待另一个线程" class="headerlink" title="还有一个问题：等待另一个线程"></a>还有一个问题：等待另一个线程</h3><blockquote>
<p>线程之间除了有一种交互，即访问共享变量，因此需要为临界区支持原子性；</p>
<p>另一种常见的交互，即一个线程在继续之前必须等待另一个线程完成某些操作。例如，当进程执行磁盘I/O并进入睡眠状态时，会产生这种交互。当I/O完成时，该进程需要从睡眠中唤醒，以便继续进行；</p>
</blockquote>
<p>因此，接下来我们不仅要研究如何构建对同步原语的支持来支持原子性，还要研究支持在多线程程序中常见的睡眠/唤醒交互的机制。</p>
<p>条件变量(condition variable)会解释这些问题</p>
<h3 id="小结：-为什么操作系统课要研究并发"><a href="#小结：-为什么操作系统课要研究并发" class="headerlink" title="小结： 为什么操作系统课要研究并发"></a>小结： 为什么操作系统课要研究并发</h3><blockquote>
<p>操作系统是第一个并发程序，许多技术都是在操作系统内部使用的。后来，在多线程的进程中，应用程序员也必须考虑这些事情。</p>
</blockquote>
<p>设想有两个进程在运行。假设它们都在调用write()来写入文件，并且都希望将数据追加到文件中（即将数据添加到文件的末尾，从而增加文件的长度）。为此，这两个进程都必须分配一个新块，记录在该块所在文件的inode中，并更改文件的大小以反映新的、增加的大小。因为中断可能随时发生，所以更新这些共享结构的代码（例如，分配的位图或文件的inode）是临界区。因此，从引入中断的一开始，OS设计人员就不得不担心操作系统如何更新内部结构。不合时宜的中断会导致上述所有问题。毫不奇怪，页表、进程列表、文件系统结构以及几乎每个内核数据结构都必须小心地访问，并使用正确的同步原语才能正常工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原子操作是构建计算机系统的最强大的基础技术之一，从计算机体系结构到并行代码、文件系统、数据库管理系统，甚至分布式系统。</span><br><span class="line">将一系列动作原子化（atomic）背后的想法可以简单用一个短语来表达：“全部或没有”， 看上去，要么你希望组合在一起的所有活动都发生了，要么它们都没发生。不会看到中间状态。有时，将许多行为组合为单个原子动作称为事务（transaction），这是一个在数据库和事务处理世界中非常详细发展地发展的概念；</span><br><span class="line">在探讨并发的主题中，我们将使用同步原语，将指令的短序列变成原子性的执行块。但是我们会看到，原子性的想法远不止这些。例如，文件系统使用诸如日志记录或写入时复制等技术来自动转换其磁盘状态，这对于在系统故障时正确运行至关重要。</span><br></pre></td></tr></table></figure>



<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h2 id="27-插叙：线程API"><a href="#27-插叙：线程API" class="headerlink" title="27 插叙：线程API"></a>27 插叙：线程API</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myarg_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125; <span class="keyword">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">myarg_t</span> *m = (<span class="keyword">myarg_t</span> *)arg;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, m-&gt;a, m-&gt;b);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> p;</span><br><span class="line">  <span class="keyword">int</span> rc;</span><br><span class="line">  <span class="keyword">myarg_t</span> args;</span><br><span class="line">  args.a = <span class="number">10</span>;</span><br><span class="line">  args.b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  rc = pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line"></span><br><span class="line">  pthread_join(p, <span class="literal">NULL</span>); <span class="comment">// 阻塞收尸线程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程完成"><a href="#线程完成" class="headerlink" title="线程完成"></a>线程完成</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> pthread_join(&amp;p, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 参数一，用于指定要等待的线程</span></span><br></pre></td></tr></table></figure>

<p>使用pthread_create 创建线程，然后立即调用pthread_join()， 这是创建线程的一种非常奇怪的方式。事实上，有一个更简单的方法来完成这个任务，它被称为过程调用（procedure call）显然，我们通常会创建不止一个线程并等待它完成，否则根本没有太多的用途；</p>
<p>我们应该注意并非所有多线程代码都使用join函数，例如，多线程web服务器可能会创建大量工作线程，然后使用主线程接受请求，并将其无限期地传递给工作线程。因此这样的长期程序可能不需要join，然而， 创建线程来 （并行）执行特定任务的并行程序，很可能会使用join来确保在退出或进入下一阶段计算之前完成所有这些工作；</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = k≡PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">// 初始化锁方法二</span></span><br><span class="line"><span class="keyword">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">pthread_mutex_destroy();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果锁已被占用，则trylock版本将失败。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 获取锁的 timedlock 版本会在超时或获取锁后返回，以先发生者为准。因此，具有零超时的timedlock退化为trylock的情况；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, struct timespec *abs_timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通常避免使用这两种版本，但有些情况下，避免卡在（可能无限期的）获取锁的函数中会很有用；</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><blockquote>
<p>当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用。希望以这种方式进行交互的程序使用两个主要函数：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cond_wait 使调用线程进入休眠状态，因此等地其他线程发出信号，通常当程序中某些内容发生变化时，现在正在休眠的线程可能会关心它</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要使用条件变量，必须另外有一个与此条件相关的锁。在调用上述任何一个函数时，应该持有这个锁；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 一个线程检查变量ready是否已经被设置为0以外的值，如果没有，那么线程只是简单地调用等待函数以便休眠；直到其他线程唤醒它；</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">ready</span> == <span class="number">0</span>) &#123; <span class="comment">// 用while而不是 if 更安全；</span></span><br><span class="line">  <span class="comment">// 等待调用将锁作为其第二个参数，原因在于，等待调用除了使调用线程进入睡眠状态外，还会让调用者睡眠时释放锁。（如果不是这样，其他线程如何获得锁并将其唤醒？）但是，在被唤醒之后返回之前，pthread_cond_wait 会重新获取该锁，从而确保等待线程在等待序列开始时获取锁与结束时释放锁之间运行的任何时间，它持有锁；</span></span><br><span class="line">  pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒线程的代码运行在另外某个线程中；</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 修改全局变量 和 发信号必须在锁内部；</span></span><br><span class="line"><span class="built_in">ready</span>= <span class="number">1</span>;</span><br><span class="line">pthread_cond_singnal(&amp;cond); <span class="comment">// 信用调用不需要传入 锁参数</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>有时候线程之间不用条件变量和锁，用一个普通变量看起来很简单；如下代码</p>
<p>但千万不要这么做，长时间自旋浪费CPU，其次，容易出错。所以还是用条件变量吧；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">ready</span> == <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// spin</span></span><br><span class="line">	<span class="built_in">ready</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p><code>gcc -o main main.c -Wa;; -pthread</code></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p> 线程难的部分不是API，线程难的部分是如何构建并发程序的棘手逻辑</p>
</blockquote>
<p>使用线程库的一些tips</p>
<ul>
<li><strong>保持简洁</strong>， 线程之间的锁和信号的代码应该尽可能简洁，复杂的线程交互容易产生缺陷；</li>
<li><strong>让线程交互减到最少</strong></li>
<li><strong>初始化锁和条件变量</strong></li>
<li><strong>检查返回值</strong></li>
<li><strong>注意传给线程的参数和返回值</strong>， 如果传递在栈上分配的变量的引用，可能就是在犯错误；</li>
<li><strong>每个线程都有自己的栈</strong>， 类似于上一条，记住每一个线程都有自己IDE栈。因此，线程局部变量应该是线程私有的，其他线程不应该访问。线程之间共享数据，值要在堆（heap）或者其他全局可访问的位置；</li>
<li><strong>线程之间总是通过条件变量发送信号</strong></li>
<li>查手册</li>
</ul>
<h2 id="28-锁"><a href="#28-锁" class="headerlink" title="28 锁"></a>28 锁</h2><blockquote>
<p>我们希望原子式执行一系列指令，但由于多个线程在多处理器上并发，做不到这一点；</p>
<p>锁解决了这个问题，程序员在临界区周围加锁，保证临界区能够像单条原子指令一样执行；</p>
</blockquote>
<h3 id="锁的基本思想"><a href="#锁的基本思想" class="headerlink" title="锁的基本思想"></a>锁的基本思想</h3><p>锁就是一个变量，需要声明才能用</p>
<p>锁保存了锁在某一时刻的状态，它要么是可用的（available，unlocked或free）表示没有线程持有锁，要么被占用的（acquired，locked，或held）表示有一个线程持有锁，正处于临界区；</p>
<p>锁也可以保存其他信息，比如持有锁的线程，或者请求获取锁的线程队列，但这些信息会隐藏起来，锁的使用者不会发现；</p>
<p><strong>锁为程序员提供了最小程度的调度控制，我们把线程视为程序员创建的实体，但是被操作系统调度，具体方式由操作系统选择。锁让程序员获得一些控制权，通过给临界区加锁，可以保证临界区内只有一个线程活跃。锁将原来由操作系统调度的混乱状态变得更为可控</strong></p>
<h3 id="Pthread锁"><a href="#Pthread锁" class="headerlink" title="Pthread锁"></a>Pthread锁</h3><p>通常大家会用不同的锁保护不同的数据和结构，从而允许更多的线程进入临界区（细粒度的方案）</p>
<h3 id="实现一个锁"><a href="#实现一个锁" class="headerlink" title="实现一个锁"></a>实现一个锁</h3><blockquote>
<p>如何实现一个锁，需要什么硬件支持？需要什么操作系统的支持？我们需要硬件和操作系统帮助来实现一个可用的锁</p>
<p>近些年，计算机体系结构的指令集增加了一些不同的硬件原语，我们不研究这些指令是如何实现的，只研究如何使用它们来实现像锁这样的互斥原语。我们研究操作系统如何发展完善，支持实现成熟复杂的锁库；</p>
</blockquote>
<h3 id="评价锁"><a href="#评价锁" class="headerlink" title="评价锁"></a>评价锁</h3><blockquote>
<p>为了评价锁是否能工作（并工作的很好）我们应该先设立一些标准。</p>
</blockquote>
<p>第一是锁是否能完成它的基本任务，即提供互斥（mutual exclusion）。最基本的，<strong>锁是否有效；能够阻止多个线程进入临界区</strong>？</p>
<p>第二是公平性（fairness）当锁可用时，<strong>是否每一个竞争线程有公平的机会抢到锁？</strong>用另一个方式来看这个问题是检查更极端的情况：<strong>是否有竞争锁的线程会饿死</strong>（starve），一直无法获得锁？</p>
<p>最后是性能（performance），具体来说，是使用锁之后增加的时间开销。有几种场景需要考虑，<strong>一种是没有竞争的情况，即只有一个线程抢锁·释放锁的开支如何</strong>？另外一种是<strong>一个CPU上多个线程竞争，性能如何</strong>？最后<strong>一种是多个CPU·多个线程竞争时的性能</strong>。通过比较不同的场景，我们能够更好地理解不同的锁技术对性能的影响；</p>
<h3 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h3><p>最早提供的互斥解决方案之一，就是在临界区关闭中断(使用特殊的硬件指令)，这个解决方案是为单处理器系统开发的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：简单</p>
<p>缺点：中断这个硬件指令权限过大，开放给程序本身滥用会导致程序独占处理器；</p>
<p>第二，不支持多CPU，第三，关闭中断可能会导致中断丢失，可能会导致严重系统问题，假如磁盘设备完成了读取请求，但是CPU错失了这一事实，那么，操作系统如何知道去唤醒等待读取的进程？第四，效率低，现在CPU对于关闭和打开中断的代码执行比较慢；</p>
<h3 id="测试并设置指令（原子交换）"><a href="#测试并设置指令（原子交换）" class="headerlink" title="测试并设置指令（原子交换）"></a>测试并设置指令（原子交换）</h3><blockquote>
<p>因为关闭中断的方法无法工作在多处理器上，所以系统设计者开始让硬件支持锁。最早的处理器系统，像20世界60年代早期的。。。 今天所有系统都支持，甚至包括单CPU的系统；</p>
</blockquote>
<p>最简单的硬件支持是 测试并设置指令（test-and-set-instruction），也叫做原子交换（atomic exchange），为了理解test and set如何工作，首先实现一个不依赖它的锁，用一个变量标记锁是否被持有；</p>
<p>第一次尝试，用一个变量来标志锁是否被某些线程占用，第一个线程进入临界区，调用lock，检查标志是否为1，然后设置标志为1，表明线程持有该锁。结束临界区时，线程调用unlock，消除标志，表示锁未被持有；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0 -&gt; lock is available, 1-&gt;held</span></span><br><span class="line">  mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// test flag</span></span><br><span class="line">    ; <span class="comment">// spin-wait (do noting)</span></span><br><span class="line">  mutex-&gt;flag = <span class="number">1</span>; <span class="comment">// now set it;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">  mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个线程正处于临界区时，如果另一个线程调用lock，它会在while循环中自旋等待（spin-wait），直到第一个线程调用unlock 清空标志，然后等待的线程会退出while循环，设置标志，执行临界区代码；</p>
<p>遗憾的是，这段代码有两个问题，正确性和性能。这个正确性问题在并发编程中很常见。</p>
<table>
<thead>
<tr>
<th>thread1</th>
<th>thread2</th>
</tr>
</thead>
<tbody><tr>
<td>call lock()</td>
<td></td>
</tr>
<tr>
<td>While(flag == 1)</td>
<td></td>
</tr>
<tr>
<td>Interrupt: switch to Thread 2</td>
<td></td>
</tr>
<tr>
<td></td>
<td>call lock()</td>
</tr>
<tr>
<td></td>
<td>while(flag ==1)</td>
</tr>
<tr>
<td></td>
<td>Flag = 1;</td>
</tr>
<tr>
<td></td>
<td>Interrupt: switch to Thread 1</td>
</tr>
<tr>
<td>Flag =1; // set flag to 1 (too!)</td>
<td></td>
</tr>
</tbody></table>
<p>从这种交替执行可以看出，通过适时（不合时宜）中断，我们很容易构造出两个线程都将进入临界区的场景，这种行为就是专家所说的“不好”，我们显然没有满足最基本得要求：互斥；</p>
<p>性能问题 主要是线程在等待已经被持有的锁时，采用了自旋等待（spin-waiting）的技术，就是不停地检查标志的值。自旋等待在等待其他线程释放锁的时候会浪费时间。尤其是在单处理器上，一个等待线程等待的目标线程甚至无法运行（至少在上下文切换之前！）我们要开发出更成熟的解决方案，也应该考虑避免这种浪费；</p>
<h3 id="实现可用的自旋锁"><a href="#实现可用的自旋锁" class="headerlink" title="实现可用的自旋锁"></a>实现可用的自旋锁</h3><p>没有硬件的支持是无法实现的，一些系统提供了这一指令，支持基于这种概念创建简单的锁，在x86上，<strong>是xchg（atomic exchange，原子交换）指令</strong>。但它们基本上在不同的平台上做同样的事，通常称为测试并设置指令（test-and-set）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old = *old_ptr;</span><br><span class="line">  *old_ptr = <span class="keyword">new</span>;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试并设置指令做了下述事情，它返回old_ptr指向的旧值，同时更新为new的新值。当然，关键是这些代码是原子地执行。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫做“测试并设置”。这一条指令完全可以实现一个简单的自旋锁（spin lock）</p>
<p>我们来确保理解为什么这个锁能工作。首先假设一个线程在运行，调用lock，没有其他线程持有锁，所以flag是0，当调用TestAndSet(flag,1)方法，返回0，线程会跳出while循环，获取锁。同时也会原子的设置flag为1，标志锁已经被持有，当线程离开临界区，调用unlock将flag清理为0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">&#125;<span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 0 indicates that lock is available, 1 that it is held</span></span><br><span class="line">  lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">// spin-wait(do nothing)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种场景是，当某一个线程已经持有锁（flag为1）。本线程调用lock，然后调用TestAndSet（flag，1），这一次返回1. 只要另一个线程一直持有锁，TestAndSet会重复返回1，本线程会一直自旋，当flag终于被改为0， 本线程会调用TestAndSet，返回0 并且原子地设置为1，从而获得锁，进入临界区；</p>
<p>将测试（test旧的锁值）和设置（set 新的值）合并为一个原子操作之后，我们保证了只有一个线程能获取锁，这就实现了一个有效的互斥原语！</p>
<p>一直自旋，利用CPU周期，直到锁可用，在CPU上，需要抢占式的调度器（preemptive scheduler）即不断通过时钟中断一个线程，运行其他线程。否则，自旋锁在单CPU上无法使用，因为一个自旋的线程永远不会放弃CPU；</p>
<h3 id="评价自旋锁"><a href="#评价自旋锁" class="headerlink" title="评价自旋锁"></a>评价自旋锁</h3><p>评价基本自旋锁</p>
<p>正确</p>
<p>自旋在竞争条件下可能会永远自旋，自旋锁没有公平性，可能会导致饿死；</p>
<p>最后一个标准是性能，对于自旋锁，在单cpu下，性能开销相当大，假设一个线程持有锁进入临界区时被抢占，调度器可能会运行其他每一个线程（假设有N-1个这种线程）而其他线程都在竞争锁，都会在放弃CPU之前，自旋一个时间片，浪费CPU周期；</p>
<p>多CPU上，自旋锁性能不错（如果线程数大致等于CPU数）。假设线程A在CPU1，线程B在CPU2竞争同一个锁。线程A（CPU1）占有锁时，线程B竞争锁就会自旋（在CPU2）然而，临界区一般都很短，因此很快锁就可用，然后线程B获得锁。自旋等待其他处理器上的锁，并没有浪费很多CPU周期，因此效果不错；</p>
<h3 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h3><blockquote>
<p>Compare-and-exchange硬件原语</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> actual = *ptr;</span><br><span class="line">  <span class="keyword">if</span>(actual == expected)</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">  <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思路是 检测ptr 指向的值 是否和 expected相等；如果是，更新ptr所指的值为新值。否则，什么也不做。不论哪种情况，都返回该内存地址的实际值，让调用者能够知道执行是否成功；</p>
<p>基于这个指令 实现一个锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">&#125;<span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 0 indicates that lock is available, 1 that it is held</span></span><br><span class="line">  lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag,<span class="number">0</span>, <span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">// spin-wait(do nothing)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码工作方式和 TestAndSet 类似，检查标志是否为0， 如果是，原子地交换为1，从而获得锁，锁被持有时，竞争锁的线程会自旋；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> old, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> ret;</span><br><span class="line">  <span class="comment">// Note that sete sets a 'byte' not the word</span></span><br><span class="line">  _asm_ _volatile_ (</span><br><span class="line">  	<span class="string">"lock\n"</span></span><br><span class="line">    <span class="string">"cmpxchg1 %2,%1\n"</span></span><br><span class="line">    <span class="string">"sete %s\n"</span></span><br><span class="line">    : <span class="string">"=q"</span>(ret),<span class="string">"=m"</span>(*ptr	)</span><br><span class="line">    :<span class="string">"r"</span> (<span class="keyword">new</span>), <span class="string">"m"</span>(*ptr), <span class="string">"a"</span>(old)</span><br><span class="line">    :<span class="string">"memory"</span>);</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompareAndSwap 比TestAndSet 更强大， 后面无等待同步（wait-free synchronization）机制， 会用到这条指令的强大之处；</p>
<h3 id="链接的加载和条件式存储指令"><a href="#链接的加载和条件式存储指令" class="headerlink" title="链接的加载和条件式存储指令"></a>链接的加载和条件式存储指令</h3><p>一些平台提供了实现临界区的一对指令，例如MIPS架构中，链接的加载（load-linked）和条件式存储（store-conditional）可以用来配合使用，实现其他并发结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="keyword">int</span> *ptr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StoreConditional</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(no one has updated *ptr since the LoadLinked to <span class="keyword">this</span> address) &#123;</span><br><span class="line">    *ptr = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接的加载指令和典型加载指令类似，都是从内存中取出值存入一个寄存器，关键区别来自条件式存储（store-conditional）指令，只有上一次加载的地址在期间都没有更新时，才会成功，（同时更新刚才链接的加载的地址的值）成功时，条件存储返回1，并将ptr指的值更新为value，失败时，返回0，并且不会更新值；</p>
<p>lock()代码是唯一有趣的代码。首先，一个线程自旋等待标志被设置为0（因此表明锁没有被保持），一旦如此，线程尝试通过条件存储获取锁。如果成功，则线程自动将标志值更改为1，从而可以进入临界区；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(LoadedLinked(&amp;lock-&gt;flag) == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// spin until it's zero</span></span><br><span class="line">      <span class="keyword">if</span>(StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// if set-it-to-1 was a success: all done</span></span><br><span class="line">      					<span class="comment">// otherwise: try it all over again</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意条件式存储失败是如何发生的，一个线程调用lock，执行了链接的加载指令，返回0，在执行条件式存储之前，中断产生了，另一个线程进入lock的代码，也执行链接式加载指令，同样返回0.现在，两个线程都执行了链接式加载指令，将要执行条件存储。重点是只有一个线程能够成功更新标志位1，从而获得锁；第二个执行条件存储的线程会失败（因为另一个线程已经成功执行了条件更新，）必须重新尝试获取锁。</p>
<p>另一种实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(LoadLinked(&amp;lock-&gt;flag)||!StoreConditional(&amp;lock-&gt;flag,<span class="number">1</span>))</span><br><span class="line">	<span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取并增加"><a href="#获取并增加" class="headerlink" title="获取并增加"></a>获取并增加</h3><blockquote>
<p>这个硬件原语是获取并增加指令（fetch-and-add），它能原子地返回指定地址的旧值，并且让该值自增一。获取并增加的C语言伪代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old = *ptr;</span><br><span class="line">  *ptr = old +<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ticket;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line">&#125;<span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_int</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">  lock-&gt;<span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">  <span class="keyword">while</span>(lock-&gt;<span class="built_in">turn</span> != myturn)</span><br><span class="line">  ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> * lock)</span></span>&#123;</span><br><span class="line">  FetchAndAdd(&amp;lock-&gt;<span class="built_in">turn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不是一个值，解决方案用了ticket 和 turn变量来构建锁，基本操作也很简单：如果线程希望获取锁，首先对一个ticket值执行一个原子的获取并相加指令。这个值作为该线程的“turn”（顺位，即myturn）。根据全局共享的lock-&gt;turn变量，当某一个线程的（myturn == turn）时，则轮到这个线程进入临界区，unlock则是增加turn，从而下一个等待线程可以进入临界区；</p>
<p>不同于之前的方法：本方法能够保证所有线程都能抢到锁，只要一个线程获得了ticket值，它最终会被调度。之前的方法则不会保证，比如基于测试并设置的方法，一个线程有可能自旋，即使其他线程在获取和释放锁；</p>
<h3 id="自旋过多：怎么办"><a href="#自旋过多：怎么办" class="headerlink" title="自旋过多：怎么办"></a>自旋过多：怎么办</h3><blockquote>
<p>基于硬件的锁简单（只有几行代码）而且有效，这也是任何好的系统或者代码的特点。但是，某些场景下，这些解决方案会效率低下。以两个线程运行在单处理器上为例，当一个线程（线程0）持有锁时，被中断。第二个线程（线程1）去获取锁，发现锁已经被持有。因此，它就开始自旋，接着自旋。</p>
<p>然后它继续自旋。最后，时钟中断产生，线程0重新运行，它释放锁。最后（比如下次它运行时）线程1不需要继续自旋了，它获取了锁。因此，类似的场景下，一个线程会一直自旋检查一个不会改变的值，浪费掉整个时间片！如果有N个线程去竞争一个锁，情况会更糟糕。同样的场景下，会浪费N-1个时间片，只是自旋并等待一个线程释放该锁。</p>
</blockquote>
<p><code>如何让锁不会不必要自旋，浪费CPU时间？</code></p>
<p>只有硬件支持是不够的，我们还需要操作系统支持！接下来看一看怎么解决这个问题；</p>
<h3 id="简单方法：-让出来吧，宝贝"><a href="#简单方法：-让出来吧，宝贝" class="headerlink" title="简单方法： 让出来吧，宝贝"></a>简单方法： 让出来吧，宝贝</h3><blockquote>
<p>硬件支持让我们有了很大的进展：我们已经实现了有效、公平的锁。但是硬件问题一直存在：如果临界区的线程发生上下文切换，其他线程只能一直自旋，等待被中断（持有锁的）进程重新运行。有什么好方法？</p>
</blockquote>
<p>第一种简单友好的方法就是，在要自旋的时候，放弃CPU，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line">  flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TestAndSet(&amp;flag, <span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">yield</span>(); <span class="comment">//give up the CPU</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假定操作系统提供原语yield，线程可以调用它主动放弃CPU，让其他线程运行。线程可以处于3种状态之一（运行，就绪和阻塞）yield系统调用能够让运行（running）态变为就绪（ready）态，从而允许其他线程运行，因此，让出线程本质上取消调度（deschedules）了它自己；</p>
<p>考虑在单CPU上运行两个线程，在这个例子中，基于yield的方法十分有效。一个线程调用lock（）, 发现锁被占用时，让出CPU，另外一个线程运行，完成临界区。在这个简单的例子中，让出方法工作得非常好。</p>
<p>现在来考虑许多线程（例如100个）反复竞争一把锁的情况。在这种情况下，一个线程持有锁，在释放锁之前被抢占，其他99个线程分别调用lock（），发现锁被抢占，然后让出CPU。假定采用某种轮转调度程序，这99个线程会一直处于运行——让出这种模式，直到持有锁的线程再次运行。虽然比原来的浪费99个时间片的自旋方案要好，但这种方法仍然成本很高，上下文切换的成本是实实在在的，因此浪费很大。</p>
<p>更糟糕的是，还没有考虑饿死的问题。一个线程可能一直处于让出的循环，而其他线程反复进出临界区，很显然，我们需要一种方法来解决这个问题；</p>
<h3 id="使用队列：休眠替代自旋"><a href="#使用队列：休眠替代自旋" class="headerlink" title="使用队列：休眠替代自旋"></a>使用队列：休眠替代自旋</h3><blockquote>
<p>调度程序决定如何调度，如果调度不合理，线程或者一直自旋，或者立刻让出CPU，无论哪种方法，都可能造成浪费，也能防止饿死；</p>
<p>因此，需要显式施加某种控制，决定锁释放时，谁能抢到锁。为了能做到这一点，需要操作系统更多支持，并需要一个队列来保存等待锁的线程。</p>
</blockquote>
<p>简单起见，使用Solaris提供的支持，它提供两个调用，park能够让调用线程休眠，unpark(threadId)则会唤醒threadId标识的线程。可以用这两个调用来实现锁，让调用者在获取不到锁时睡眠，在锁可用时被唤醒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">  <span class="keyword">int</span> guard;</span><br><span class="line">  <span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">  m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">  m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">  queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="comment">// 通过旋转获得保护锁</span></span><br><span class="line">    <span class="keyword">if</span>(m-&gt;flag == <span class="number">0</span>)&#123;</span><br><span class="line">      m-&gt;flag = <span class="number">1</span>;</span><br><span class="line">      m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue_add(m-&gt;q, gettid());</span><br><span class="line">      m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">      park()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TestAndSet(&amp;m-&gt;guard,<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ;<span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span>(queue_empty(m-&gt;q))</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock(for next thread!)</span></span><br><span class="line">  m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子</p>
<p>首先，将之前TestAndSet 和 等待队列结合，实现一个更高性能的锁。</p>
<p>其次，通过队列来控制谁会获得锁，避免饿死；</p>
<h3 id="不同操作系统，不同实现"><a href="#不同操作系统，不同实现" class="headerlink" title="不同操作系统，不同实现"></a>不同操作系统，不同实现</h3><h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><p>最后一点：linux采用的是一种古老的锁方案，现在也称为两阶段锁（two-phase lock），两阶段锁意识到自旋可能很有用，尤其是在很快就要释放锁的场景。因此，两阶段锁的第一个阶段会先自旋一段时间，希望它可以获取锁；</p>
<p>但是，如果第一个自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用。上文的linux锁就是这种锁，不过只自旋一次，更常见的方式是在循环中自旋固定的次数，然后使用futex睡眠。</p>
<p>两阶段锁是一个杂合（hybrid）方案的例子，即结合两种好想法得到更好的想法，当然，硬件环境，线程数，其他负载等这些因素，都会影响锁的效果，事情纵使这样，让单个通用目标的锁，在所有可能的场景下都友好，这是巨大的挑战；</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上的方法展示了如今真实的锁是如何实现的： 一些硬件支持（更加强大的指令）和一些操作系统支持（例如Solaris的 park 和 unpark原语，Linux的futex）当然，细节有所不同，执行这些锁操作的代码通常是高度优化的。</p>
<p>Solaris或者Linux的代码以了解更多信息，David等人关于现代多处理器的锁策略的对比也值得一看；</p>
<h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h2 id="29-基于锁的并发数据结构"><a href="#29-基于锁的并发数据结构" class="headerlink" title="29 基于锁的并发数据结构"></a>29 基于锁的并发数据结构</h2><blockquote>
<p>如何在常见数据结构中使用锁，通过锁可以使数据结构线程安全（thread safe）。对于特定数据结构，如何加锁才能让该结构功能正确？进一步，如何对该数据结构加锁，能够保证高性能，让许多线程同时访问该结构，即并发访问（concurrently）</p>
</blockquote>
<p>很难介绍所有数据结构，或实现并发的所有方法，只能够提供这类思考方式的足够介绍，同时提供一些好的资料，Moir 和 Shavit的调查就是最好的资料</p>
<h3 id="并发计算器"><a href="#并发计算器" class="headerlink" title="并发计算器"></a>并发计算器</h3><h3 id="并发链表"><a href="#并发链表" class="headerlink" title="并发链表"></a>并发链表</h3><h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><h3 id="并发散列表"><a href="#并发散列表" class="headerlink" title="并发散列表"></a>并发散列表</h3><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h2 id="30-条件变量"><a href="#30-条件变量" class="headerlink" title="30 条件变量"></a>30 条件变量</h2><blockquote>
<p>锁并不是并发程序设计所需要的唯一原语；</p>
<p>在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕【这种被称为join】这种等待如何实现呢？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">  <span class="comment">// how to indicate we are done?</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent:begin\n"</span>);</span><br><span class="line">  <span class="keyword">pthread_t</span> c;</span><br><span class="line">  pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// how to wait for child?</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent:end\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 期望这样的结果</span></span><br><span class="line">parent:begin</span><br><span class="line">child</span><br><span class="line">parent:end</span><br><span class="line"><span class="comment"># 很显然不会，而是</span></span><br><span class="line">parent:begin</span><br><span class="line">parent:end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以自旋搞定</span><br><span class="line">volatile int done &#x3D; 0;</span><br><span class="line">void *child(void *arg)&#123;</span><br><span class="line">  printf(&quot;child\n&quot;);</span><br><span class="line">  &#x2F;&#x2F; how to indicate we are done?</span><br><span class="line">  done &#x3D; 1;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">  printf(&quot;parent:begin\n&quot;);</span><br><span class="line">  pthread_t c;</span><br><span class="line">  pthread_create(&amp;c, NULL, child, NULL);</span><br><span class="line">  &#x2F;&#x2F; how to wait for child?</span><br><span class="line">  while(done &#x3D;&#x3D; 0)</span><br><span class="line">  ;&#x2F;&#x2F; spin</span><br><span class="line">  printf(&quot;parent:end\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程程序，一个线程等待某些条件是很常见的，简单的方案是自旋直到条件满足，这是极其低效的，某些情况下甚至是错误，那么线程应该如何等待一个条件呢？</p>
<h3 id="定义和程序"><a href="#定义和程序" class="headerlink" title="定义和程序"></a>定义和程序</h3><p>线程可以使用条件变量（condition variable），来等待一个条件变成真。</p>
<p>条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号，让它们继续执行）Dijkstra最早在“私有信息量”中提出这种思想，Hoare后来在关于观察者的工作中，将类似的思想称为条件变量；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *c,<span class="keyword">pthread_mutex_t</span> *m);</span><br><span class="line">pthread_cond_signal(<span class="keyword">pthread_cond_t</span> *c);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;m);</span><br><span class="line">  done =<span class="number">1</span>;</span><br><span class="line">  pthread_cond_signal(&amp;c);</span><br><span class="line">  pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">  thr_exit();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;m);</span><br><span class="line">  <span class="keyword">while</span>(done == <span class="number">0</span>)</span><br><span class="line">    pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">  pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent:begin\n"</span>);</span><br><span class="line">  <span class="keyword">pthread_t</span> p;</span><br><span class="line">  pthread_create(&amp;p, <span class="literal">NULL</span>,child,<span class="literal">NULL</span>);</span><br><span class="line">  thr_join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent:end\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait调用有一个参数，它是互斥量，它假定在wait调用时，这个互斥量已是上锁状态。wait的职责是释放锁，并让调用线程休眠（原子地）。当线程被唤醒时（在另外某个线程发信息给它后），它必须重新获取锁，再返回调用者。这样复杂的步骤也是为了避免在线程陷入休眠时，产生一些竞态条件。</p>
<p>有两种情况需要考虑，第一种情况是父线程创建出子线程，但自己继续运行（假设只有一个处理器），然后马上调用thr_join等待子线程。在这种情况下，它会先获取锁，检查子进程是否完成（还没有完成），然后调用wait()，让自己休眠。子线程最终得以运行，打印出“child”,并调用thr_exit()函数唤醒父进程，这段代码会在获取锁后设置变量done，然后向父线程发信号唤醒它，最后，父线程会运行（从wait()调用返回并持有锁）释放锁，打印出“parent:end”。</p>
<p>第二种情况是，子线程在创建后，立刻运行，设置变量done为1，调用signal函数唤醒其他线程（这里没有其他线程），然后结束，父线程运行后，调用thr_join时，发现done已经是1了，就直接返回；</p>
<ul>
<li>灵魂拷问，不要这个变量done会怎样</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;m);</span><br><span class="line">  pthread_cond_signal(&amp;c);</span><br><span class="line">  pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;m);</span><br><span class="line">  pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">  pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">  thr_exit();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent:begin\n"</span>);</span><br><span class="line">  <span class="keyword">pthread_t</span> p;</span><br><span class="line">  pthread_create(&amp;p, <span class="literal">NULL</span>,child,<span class="literal">NULL</span>);</span><br><span class="line">  thr_join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent:end\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设子线程立刻运行，并调用thr_exit，这种情况下，子线程发送信号，但此时却没有在条件变量上睡眠等待的线程。父线程运行时，就会调用wait并卡在那里，没有其他线程会唤醒它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  done = <span class="number">1</span>;</span><br><span class="line">  pthread_cond_signal(&amp;c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(done == <span class="number">0</span>)</span><br><span class="line">    pthread_cond_wait(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个微妙的竞态条件，如果父进程调用thr_join，然后检查完done为0，然后试图睡眠，但在调用wait进入睡眠之前，父进程被中断，子线程修改完变量done为1，发出信号，同样没有等待线程，父线程再次运行时，就会长眠不醒；</p>
<p><strong>发信号时总是持有锁</strong></p>
<p>尽管并不是所有情况下都严格需要，但有效且简单的做法，还是在使用条件变量发送信号时持有锁。虽然上面的例子是必须加锁的情况，但也有一些情况可以不加锁，而这可能是你应该避免的，因此，为了简单，请在调用signal时持有锁，（hold the lock when calling signal）</p>
<p>这个提示的反面，即调用wait时持有锁，不只是建议，而是wait的语义强制要求的，因为wait调用总是假设你调用它时已经持有锁，调用者睡眠之前会释放锁以及返回前重新持有锁，因此，这个提示的一般化形式是正确的，调用signal和wait时要持有锁（hold the lock when calling signal or wait）</p>
<h3 id="生产者、消费者（有界缓冲区）"><a href="#生产者、消费者（有界缓冲区）" class="headerlink" title="生产者、消费者（有界缓冲区）"></a>生产者、消费者（有界缓冲区）</h3><blockquote>
<p>生产者、消费者问题，也叫做有界缓冲区问题。这一问题最早由Dijkstra提出，实际上也正是通过研究这一问题，Dijkstra和她的同事们发明了通用的信号量（它可用作锁或条件变量）</p>
</blockquote>
<p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区，消费者从缓冲区取走数据项，以某种方式消费</p>
<p>很多实际场景，如 多线程的网络服务器中，一个生产者将HTTP请求放入工作队列（即有界缓冲区），消费者线程从队列中取走请求并处理；</p>
<p>因为有界缓冲区是共享资源，所以必须同步访问，以免产生竞态条件，为了更好理解这个问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">buffer</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">put函数会假设缓冲区是空的，把一个值存在缓冲区，然后把count设置为1表示缓冲区满了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  assert(count == <span class="number">0</span>);</span><br><span class="line">  count = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">buffer</span> = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">get函数刚好相反，把缓冲区清空后（即将count设置为0），并返回该值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">  assert(count ==<span class="number">1</span>);</span><br><span class="line">  count =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写一些函数，知道何时可以访问缓冲区，以便将数据放入缓冲区或从缓冲区取出数据。</span></span><br><span class="line"><span class="comment">条件是 当count为0时（即缓冲区为空时），才将数据放入缓冲器中，</span></span><br><span class="line"><span class="comment">仅在count为1（即缓冲区满），才从缓冲区获得数据，如果我们编写同步代码，让生产者将数据放入已满的缓冲区</span></span><br><span class="line"><span class="comment">让消费者从空的数据获取数据，就做错了；assert(count == 0)阻止这一点；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这项工作由两种类型的线程完成，其中一类为生产者线程，另一类消费者线程</span></span><br><span class="line"><span class="comment">生产者，将整数放入共享缓冲区</span></span><br><span class="line"><span class="comment">消费者，从共享缓存中获取数据（永远不停）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> loops = (<span class="keyword">int</span>)arg;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)&#123;</span><br><span class="line">    <span class="built_in">put</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">while</span>(i)&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终方案</li>
</ul>
<p>假设只有一个生产者和一个消费者。显然，put()和get() 函数之中会有临界区，因为put更新缓冲区，get读取缓冲区，但是，给代码加锁没有用，我们还需要别的东西，不奇怪，别的东西就是某些条件变量。在这个（有问题的）首次尝试中，使用了条件变量cond和相关的锁mutex</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">buffer</span>[MAX];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">fill</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">put函数会假设缓冲区是空的，把一个值存在缓冲区，然后把count设置为1表示缓冲区满了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="built_in">fill</span>] = value;</span><br><span class="line">  <span class="built_in">fill</span> = (<span class="built_in">fill</span> + <span class="number">1</span>)%MAX;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">get函数刚好相反，把缓冲区清空后（即将count设置为0），并返回该值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = <span class="built_in">buffer</span>[use];</span><br><span class="line">  use = (use+<span class="number">1</span>)%MAX;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">cond_t</span> empty, <span class="built_in">fill</span>;</span><br><span class="line"><span class="keyword">mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(count == MAX)</span><br><span class="line">      pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line"> <span class="comment">// 当生产者想要填充缓冲区时，它等待缓冲区变空</span></span><br><span class="line">    <span class="built_in">put</span>(i);</span><br><span class="line">    pthread_cond_signal(&amp;<span class="built_in">fill</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;loops;i++)&#123;</span><br><span class="line">     	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">      <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">        pthread_cond_wait(&amp;<span class="built_in">fill</span>,&amp;mutex);</span><br><span class="line"><span class="comment">// 当消费者想要消费缓冲区内容时，它等待缓冲区变满；    </span></span><br><span class="line">      <span class="keyword">int</span> tem = <span class="built_in">get</span>();</span><br><span class="line">      pthread_cond_signal(&amp;empty);</span><br><span class="line">      pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对条件变量使用while（不是if）</li>
</ul>
<p>多线程程序在检查条件变量时，使用while循环总是对的，if语句可能会对，这取决于发信号的语义，因此，总是使用while，代码就会符合预期；</p>
<p>对条件变量使用while循环，这也解决了假唤醒的情况。某些线程库中，由于实现的细节，有可能出现一个信号唤醒两个线程的情况，再次检查线程的等待条件，假唤醒是另一个原因；</p>
<h3 id="覆盖条件"><a href="#覆盖条件" class="headerlink" title="覆盖条件"></a>覆盖条件</h3><p>一个简单的多线程内存分配库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// how many bytes of the heap are free?</span></span><br><span class="line"><span class="keyword">int</span> bytesLeft = MAX_HEAP_SIZE;</span><br><span class="line"><span class="comment">// need lock and condition too;</span></span><br><span class="line"><span class="keyword">cond_t</span> c;</span><br><span class="line"><span class="keyword">mutex_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;m);</span><br><span class="line">  <span class="keyword">while</span>(bytesLeft &lt; <span class="built_in">size</span>)</span><br><span class="line">    pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">  <span class="keyword">void</span> *ptr = .... <span class="comment">// get mem from heap</span></span><br><span class="line">  bytesLeft -= <span class="built_in">size</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;m);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;m);</span><br><span class="line">  bytesLeft+= <span class="built_in">size</span>;</span><br><span class="line">  pthread_cond_signal(&amp;c); <span class="comment">// whom to signal??</span></span><br><span class="line">  pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中看出，当线程调用进入内存分配代码时，它可能会因为内存不足而等待，相应的，线程释放内存时，会发信号说有更多内存空闲。但是，代码中有一个问题，应该唤醒哪个等待线程（可能有多个线程）？</p>
<p>考虑以下场景，假设目前没有空闲内存，线程Ta调用allocate(100)，接着线程Tb请求较少的内存，调用allocate(10)。Ta和Tb都等待在条件上并睡眠，没有足够的空闲内存来满足它们的请求</p>
<p>这时，假定第三个线程Tc调用了free(50)，遗憾的是，当它发信号唤醒等待线程时，可能不会唤醒申请10字节的Tb线程。而Ta线程由于内存不够，仍然等待。因为不知道唤醒哪个（或哪些）线程，所以图中代码无法正常工作</p>
<p>解决方案也很直接，用pthread_con_broadcast 代替上述代码中的pthread_cond_signal(), 唤醒所有的等待线程。这样做，确保了所有应该唤醒的线程都被唤醒。当然，不利的一面试可能会影响性能，因为不必要地唤醒了其他等待的线程，它们本来（还）不应该被唤醒。这些线程被唤醒后，重新检查条件，马上再次睡眠；</p>
<p>把这种条件变量叫做覆盖条件（covering condition），因为它能覆盖所有需要唤醒线程的场景，成本如上所述，就是太多线程被唤醒。聪明的读者可能发现，我们有更好的方法，因此用了它。一般来说，如果你发现程序只有改成广播信号时才能工作（但你认为不需要），可能是程序有缺陷，修复它，但在上述内存分配的例子中，广播可能是最直接有效的方案；</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>条件变量，当某些程序状态不符合要求时，通过允许线程进入休眠状态，条件变量使我们能够漂亮地解决许多重要的同步问题，包括注明生产者/消费者问题，以及覆盖条件；</p>
<h2 id="31-信号量"><a href="#31-信号量" class="headerlink" title="31 信号量"></a>31 信号量</h2><blockquote>
<p>如何使用信号量代替锁和条件变量? 设么是 信号量？什么是二值信号量？用锁和条件变量来实现信号量是否简单？不用锁和条件变量，如何实现信号量？</p>
</blockquote>
<h3 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h3><blockquote>
<p>信号量是有一个整数值的对象，可以用两个函数来操作它，在POSIX标准中，是sem_wait() sem_post, 因为信号量的初始值能够决定其行为，所以首先要初始化信号量，才能调用其他函数与之交互；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line">sem_int(&amp;s, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h3 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h3><h3 id="信号量用作条件变量"><a href="#信号量用作条件变量" class="headerlink" title="信号量用作条件变量"></a>信号量用作条件变量</h3><h3 id="生产者、消费者（有界缓冲区）-1"><a href="#生产者、消费者（有界缓冲区）-1" class="headerlink" title="生产者、消费者（有界缓冲区）"></a>生产者、消费者（有界缓冲区）</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><h3 id="如何实现信号量"><a href="#如何实现信号量" class="headerlink" title="如何实现信号量"></a>如何实现信号量</h3><blockquote>
<p>用底层同步原语（锁和条件变量）,来实现信号量；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125;Zem_t;</span><br><span class="line"><span class="comment">// only one thread can call this</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_init</span><span class="params">(Zem_t *s, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  s-&gt;value = value;</span><br><span class="line">  Cond_init(&amp;s-&gt;cond);</span><br><span class="line">  Mutex_init(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_wait</span><span class="params">(Zem_t *s)</span></span>&#123;</span><br><span class="line">  Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(s-&gt;value&lt;=<span class="number">0</span>)</span><br><span class="line">    Cond_wait(&amp;s-&gt;cond,&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;value--;</span><br><span class="line">  Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_post</span><span class="params">(Zem_t *s)</span></span>&#123;</span><br><span class="line">  Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;value++;</span><br><span class="line">  Cond_signal(&amp;s-&gt;cond);</span><br><span class="line">  Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>信号量是编写并发程序的强大而灵活的原语，有程序员会因为简单实用，只用信号量，不用锁和条件变量；</p>
<h2 id="32-常见并发问题"><a href="#32-常见并发问题" class="headerlink" title="32 常见并发问题"></a>32 常见并发问题</h2><h3 id="有哪些类型的缺陷"><a href="#有哪些类型的缺陷" class="headerlink" title="有哪些类型的缺陷"></a>有哪些类型的缺陷</h3><h3 id="非死锁缺陷"><a href="#非死锁缺陷" class="headerlink" title="非死锁缺陷"></a>非死锁缺陷</h3><h3 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h3><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><h2 id="33-基于事件的并发（进阶）"><a href="#33-基于事件的并发（进阶）" class="headerlink" title="33 基于事件的并发（进阶）"></a>33 基于事件的并发（进阶）</h2><blockquote>
<p>之前提到的并发，似乎只能用线程来实现，就像生活中许多事，这部完全对，具体来说，一些基于图形用户界面，或者某些类型的网络服务器，常常采用另一种并发方式，这种方式称为基于事件的并发（event-based concurrentcy），比如Nodejs</p>
</blockquote>
<p>基于事件的并发针对两方面的问题，一方面是多线程应用中，正确处理并发很有难度。忘记加锁，死锁，和其他烦人问题。</p>
<p>另一方面，无法控制多线程在某一时刻的调度。程序员只能创建了线程，然后就依赖操作系统能够合理调度线程。要实现一个在各种不同负载下，都能良好运行的通过调度程序，是极有难度的，因此，某些时候操作系统的调度并不是最优的，关键问题如下；</p>
<p><strong>不用线程，如何构建并发服务器</strong>，不用线程，同时保证对并发的控制，避免多线程应用中出现的问题，我们应该如何构建一个并发服务器。</p>
<h3 id="基本想法：事件循环"><a href="#基本想法：事件循环" class="headerlink" title="基本想法：事件循环"></a>基本想法：事件循环</h3><h3 id="重要API：-select，-poll"><a href="#重要API：-select，-poll" class="headerlink" title="重要API： select， poll"></a>重要API： select， poll</h3><h3 id="使用select"><a href="#使用select" class="headerlink" title="使用select"></a>使用select</h3><h3 id="为何更简单？无须锁"><a href="#为何更简单？无须锁" class="headerlink" title="为何更简单？无须锁"></a>为何更简单？无须锁</h3><h3 id="一个问题：阻塞系统调用"><a href="#一个问题：阻塞系统调用" class="headerlink" title="一个问题：阻塞系统调用"></a>一个问题：阻塞系统调用</h3><h3 id="解决方案：异步I-O"><a href="#解决方案：异步I-O" class="headerlink" title="解决方案：异步I/O"></a>解决方案：异步I/O</h3><h3 id="另一个问题：状态管理"><a href="#另一个问题：状态管理" class="headerlink" title="另一个问题：状态管理"></a>另一个问题：状态管理</h3><h3 id="什么事情仍然很难"><a href="#什么事情仍然很难" class="headerlink" title="什么事情仍然很难"></a>什么事情仍然很难</h3><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><h3 id="作业-2"><a href="#作业-2" class="headerlink" title="作业"></a>作业</h3><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><h2 id="34-并发的总结"><a href="#34-并发的总结" class="headerlink" title="34 并发的总结"></a>34 并发的总结</h2><h3 id="作业-3"><a href="#作业-3" class="headerlink" title="作业"></a>作业</h3><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3>
          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://yoursite.com/2021/09/16/%E5%B9%B6%E5%8F%91/>http://yoursite.com/2021/09/16/%E5%B9%B6%E5%8F%91/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-09-26T22:12:26+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Sep 26, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/guide/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>guide</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2021/09/16/%E5%B9%B6%E5%8F%91/&title=并发 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2021/09/16/%E5%B9%B6%E5%8F%91/&title=并发 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2021/09/16/%E5%B9%B6%E5%8F%91/&title=并发 - Hexo&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2021/09/16/superset/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>superset</p>
                <p class='content'>sz下载
rz上载
supersetinstallConda, 管理python多版本，superset是python3.7

下载Miniconda（python3版本）

下载地址https...</p>
              </a>
            
            
              <a class='next' href='/2021/09/09/dataVisualization/'>
                <p class='title'>dataVisualization<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>
我们要的不是数据，而是数据告诉我们的事实.
使用太多的幻灯片，与其说是展示数据，不如说是展示自己的工作量。
这个世界上的一个大误会就在于，太多人把掌握一个工具软件的操作等同于掌握某个领域需要的...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '并发',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-并发：介绍"><span class="toc-text">26 并发：介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实例：-线程创建"><span class="toc-text">实例： 线程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么更糟糕：-共享数据"><span class="toc-text">为什么更糟糕： 共享数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心问题：-不可控的调度"><span class="toc-text">核心问题： 不可控的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性愿望"><span class="toc-text">原子性愿望</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#还有一个问题：等待另一个线程"><span class="toc-text">还有一个问题：等待另一个线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结：-为什么操作系统课要研究并发"><span class="toc-text">小结： 为什么操作系统课要研究并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作业"><span class="toc-text">作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-插叙：线程API"><span class="toc-text">27 插叙：线程API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程创建"><span class="toc-text">线程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程完成"><span class="toc-text">线程完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件变量"><span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译和运行"><span class="toc-text">编译和运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-锁"><span class="toc-text">28 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的基本思想"><span class="toc-text">锁的基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthread锁"><span class="toc-text">Pthread锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现一个锁"><span class="toc-text">实现一个锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价锁"><span class="toc-text">评价锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制中断"><span class="toc-text">控制中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试并设置指令（原子交换）"><span class="toc-text">测试并设置指令（原子交换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现可用的自旋锁"><span class="toc-text">实现可用的自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价自旋锁"><span class="toc-text">评价自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#比较并交换"><span class="toc-text">比较并交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接的加载和条件式存储指令"><span class="toc-text">链接的加载和条件式存储指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取并增加"><span class="toc-text">获取并增加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋过多：怎么办"><span class="toc-text">自旋过多：怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单方法：-让出来吧，宝贝"><span class="toc-text">简单方法： 让出来吧，宝贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用队列：休眠替代自旋"><span class="toc-text">使用队列：休眠替代自旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同操作系统，不同实现"><span class="toc-text">不同操作系统，不同实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两阶段锁"><span class="toc-text">两阶段锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-1"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作业-1"><span class="toc-text">作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题-1"><span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-基于锁的并发数据结构"><span class="toc-text">29 基于锁的并发数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发计算器"><span class="toc-text">并发计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发链表"><span class="toc-text">并发链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发队列"><span class="toc-text">并发队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发散列表"><span class="toc-text">并发散列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-条件变量"><span class="toc-text">30 条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义和程序"><span class="toc-text">定义和程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者、消费者（有界缓冲区）"><span class="toc-text">生产者、消费者（有界缓冲区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#覆盖条件"><span class="toc-text">覆盖条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-3"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-信号量"><span class="toc-text">31 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量的定义"><span class="toc-text">信号量的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二值信号量（锁）"><span class="toc-text">二值信号量（锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量用作条件变量"><span class="toc-text">信号量用作条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者、消费者（有界缓冲区）-1"><span class="toc-text">生产者、消费者（有界缓冲区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁"><span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哲学家就餐问题"><span class="toc-text">哲学家就餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现信号量"><span class="toc-text">如何实现信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-4"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-常见并发问题"><span class="toc-text">32 常见并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有哪些类型的缺陷"><span class="toc-text">有哪些类型的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非死锁缺陷"><span class="toc-text">非死锁缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁缺陷"><span class="toc-text">死锁缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-5"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-基于事件的并发（进阶）"><span class="toc-text">33 基于事件的并发（进阶）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本想法：事件循环"><span class="toc-text">基本想法：事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重要API：-select，-poll"><span class="toc-text">重要API： select， poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用select"><span class="toc-text">使用select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为何更简单？无须锁"><span class="toc-text">为何更简单？无须锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个问题：阻塞系统调用"><span class="toc-text">一个问题：阻塞系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方案：异步I-O"><span class="toc-text">解决方案：异步I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#另一个问题：状态管理"><span class="toc-text">另一个问题：状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么事情仍然很难"><span class="toc-text">什么事情仍然很难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-6"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作业-2"><span class="toc-text">作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题-2"><span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-并发的总结"><span class="toc-text">34 并发的总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作业-3"><span class="toc-text">作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题-3"><span class="toc-text">问题</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">belief</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>




  <script>setLoadingBarProgress(100);</script>
</body>
</html>
