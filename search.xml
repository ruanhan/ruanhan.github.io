<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>patten</title>
      <link href="2021/06/18/patten/"/>
      <url>2021/06/18/patten/</url>
      
        <content type="html"><![CDATA[<h2 id="焦虑"><a href="#焦虑" class="headerlink" title="焦虑"></a>焦虑</h2><blockquote><p>所有的渴望，在内心的投射其实都是焦虑。任何一个渴望成长的人，不管处于什么阶段，一线工程师，架构师，还是总监，副总裁，其实内心中都是充满了焦虑的，无一例外。</p><p>对于这种焦虑，我们所要做的是接纳，而不需要过度担忧。这种焦虑并不是说，想明白如何成长了就会没有了，到了某个阶段就会没有了的。成长的脚步和期待一刻不止，内心的焦虑也一刻不会停歇。正是这种焦虑感，驱使你写代码追查问题到星夜，驱使你牺牲休息娱乐的时间和一本本厚厚枯燥的书作伴，驱使你不断努力向前，不舍昼夜。</p></blockquote><h3 id="35危机"><a href="#35危机" class="headerlink" title="35危机"></a>35危机</h3><p>背后的根本原因是，太多太多的人在工作几年以后，就觉得自己什么都会了，之后的十几年工作只不过是头2-3年的简单重复而已。在我们这样一个行业里面，在照片的时候，如果摆在管理面前的两个人， 一个刚出校园工作2-3年，充满对成长的渴望，另一个工作十多年但水平和工作2-3年的人差不多，只是更熟练一些，不过在舒适区已经躺了十年了。如果你负责招聘，那么招谁进来再显然不过了；</p><p>另一方面，高端人才在行业内极度极度稀缺，这在行业是非常普遍的现象，真正的大牛太稀缺了。在这样一个行业里面，如果一个人能够持续成长，能力和工作年限成正比的持续提升，这样的人，任何时候在行业里都是被疯抢，不可能遇到所谓年龄危机；</p><h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><h3 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h3><ol><li><p>找到你要学习这个领域体系的范式（patten）；梳理这个领域的技术栈</p></li><li><p>针对每个范式，技术栈 反复学习和练习</p></li><li><p>及时反馈</p></li></ol><p>当学习方法不正确的时候，刻苦的学习常常只是看起来很勤奋。</p><p>当接触一个陌生领域的时候，错误的学习方法是不带目的性，上来就找一堆相关的大部头开始啃。</p><p>而正确的学习方法应该是快速梳理该领域的知识点，形成框架体系（寻找pattern），这里有些小窍门可以快速构建起一个领域的知识点体系，</p><p>例如看一些该领域的综述性或开创性的文章（看论文，别瞎看网上的文章），或者找本该领域综述性的教科书看它的目录（注意，好的教科书的目录往往就是这个领域的知识框架，内容倒不一定非要看下去）。</p><p>然后，针对每个知识点，找书里的相关章节，该领域相关paper里的相关section深入学习，建立起自己对这个知识点的理解（刻意练习）。</p><p>最后，再把知识点和现实工作中的情况（自己工作，或其他公司相关的工作）进行对照（及时反馈），从而建立对一个知识点的深度理解，最后融会贯通建立对一个领域的理解。</p><ul><li>拿打羽毛球举例</li></ul><p>把打羽毛球拆解成步法和手上动作，小碎步，米字步，正反手挑球，。。。（拆解，寻找范式）</p><p>然后针对每个动作反复练习，（反复学习）</p><p>请教练或者录下来看视频纠正自己的动作（及时反馈）</p><p>错误示范： 上来就盲目找人打比赛，以赛代练，这样的进步是很慢的，而且错误动作形成习惯以后未来反而很难纠正；</p><p>类比编程：一上来，找框架撸业务代码，快速crud。不追求最佳实践。无脑一把梭，正确的做法，应该是先弄明白底层原理 linux（内存管理/工程化/编程语言范式/设计模式/高质量代码/数据结构）/浏览器（浏览器架构/渲染进程原理/网络/v8机制/css，html，js/DOM/BOM/vue，react，angular等）然后针对开发框架，最好先弄懂实现原理以及该框架在开发中的最佳实践。真正做到 做一个项目之后就能成为 该框架的专家级玩家； 至于反馈就是找更高水平的人讨论。</p><ul><li>学习分布式存储的例子</li></ul><p>先结合自己的工作内容梳理出需要深入了解的知识点（例如，元信息组织，Meta Server设计和HA，副本组织和管理，Recovery，Rebalance，单机存储引擎，数据/元信息流，纠删码，一致性，多租户，存储介质，网络环境和IDC等等），</p><p>同时看很多综述性的材料，梳理分布式存储的知识点（有网上各种整理的比较好的文章，也有从各种系统实现的paper里抽出），不断迭代构建分布式存储领域的知识点（寻找pattern，这是最难的一个过程）；</p><p>然后针对每一个知识点，找相关材料进行深度学习，例如，对于分布式一致性，需要阅读CAP理论，Paxos的论文，Raft的论文等等以及周边的很多材料（刻意练习）；</p><p>然后找各种系统实现的论文或文章，比如GFS，Dynamo，Aurora，OceanBase，Ceph，Spanner等等，看看和对比它们在一致性上是如何考虑和取舍的，当然，最重要的是结合自己工作中的反复实践和所学知识点进行比对（及时反馈）。</p><p>这三个阶段并不是割裂的，而是周而复始的，经常会在刻意练习和及时反馈的学习过程中，发现自己遗漏的知识点，或者发现自己梳理的两个知识点其实是重合的。通过这种交叉比对，以及在实践中不断检验的方式建立的知识点是非常可落地的，而不会看了几篇论文以后就人云亦云。拿分布式存储的一致性举例子，如果不是反复对比、思考和反复实践，你不会发现GFS论文里最难的一段，多个Writer对一个文件进行append的逻辑，在实践中根本没用；你也不会发现看起来优雅而学术的CAP三选二的理论，实践中压根不是这么完美，很多时候只能三选一；你也不会发现Dynamo论文里的Vector Clock，网上有无数文章摇头晃脑的解读，但在Amazon的应用场景里是个典型的over design，Cassandra在这点就务实很多。</p><h3 id="忙碌的工作如何抽时间来学习"><a href="#忙碌的工作如何抽时间来学习" class="headerlink" title="忙碌的工作如何抽时间来学习"></a>忙碌的工作如何抽时间来学习</h3><p>工作和学习是不应该割裂的，工作本来就应该是学习的一部分，是学习中的实践和及时反馈的部分。学习如果脱离工作的实践，其实是非常低效的；每个同学都应该对自己工作所在 的这个技术和业务领域进行系统性的学习，并在工作中反复实践和验证；不同的领域之间其实是融会贯通的；</p><p>当你对一个领域精通并总结出方法论的时候，很容易就能上手别的领域了。因为花几年实践彻底研究透一个领域，对于刚工作几年的同学来说，是非常重要的，甚至是必须的，也只有在一个领域打透之后才谈得上跨领域迁移，去拓展自己的知识面，更直接的说，对于一个领域还未完全掌握的同学，深度是最重要的，不用像广度的事情，等掌握了一个领域之后，再去拓展广度就变得很容易了；</p><p><strong>一个常见的误区就是学习的内容和工作的领域没有太多直接的关系</strong><br>软件工程是一门实践科学，从书本上得到的知识如果没有在实践中应用和检验，基本上是没有用处的。举一个例子，很多优秀的架构师，尽管日常工作中可能反复在用，但未必说得出开闭原则，里氏替换原则，迪米特法则等等，反过来，对面向对象设计这7大原则出口成章的人，很多其实离真正的架构师还远得很，有些甚至只是博客架构师而已。实践远远比看书，看文章重要得多，上文所述的我构建自己分布式存储知识体系的过程，看起来好像都是看材料，看论文，而实际上80%的收获都来源于带着理论的实践，和从实践中总结沉淀的理论。因此，彻底搞明白自己工作所在的技术和业务领域，是最务实高效的做法，工作和学习割裂，会导致工作和学习都没做好。</p><h3 id="感觉日常工作非常琐碎，学不到什么东西，怎么办？"><a href="#感觉日常工作非常琐碎，学不到什么东西，怎么办？" class="headerlink" title="感觉日常工作非常琐碎，学不到什么东西，怎么办？"></a>感觉日常工作非常琐碎，学不到什么东西，怎么办？</h3><p>如果把学习分成从书本中学，和从工作中学这两种的话，那毫无疑问，工作中的“知识密度”，比起书本的“知识密度”，肯定是要低很多的，因为书本里的知识，那都是人家从他们的工作中抽象总结出来的。这也是为什么大家普遍觉得日常工作“琐碎”。然而工作中每个点滴的琐事与平凡，都是可以抽象总结成为方法论的，更别说工作所在的领域自身的博大精深了。从日常工作中学习的秘诀，就是“行动中思考”。</p><p>对于每一个软件工程师，最重要的两个能力，<br>是写代码的能力和trouble shooting的能力。</p><h4 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h4><p>并且，要成为优秀的架构师，出色的开发能力和追查问题的能力是一切的基础。<br>提高写代码的能力的核心，首先在于坚持不断的写，但更重要的，在于每天，每周，持续不断的review自己之前的代码；同时，多review牛人写的代码，比如是团队里你觉得代码写的比你好的同事，比如社区里以代码漂亮著称的开源代码（作为一个C++程序员，当年我的榜样之一是boost库）。</p><p>一旦觉得自己之前的代码不够好，就立刻复盘，立刻重构。更重要的是，多思考自己代码和好的代码之间不同之处背后的为什么，通常这就是为什么这些代码更好的背后的秘密。</p><p>特别要说明的是，代码规范除了知道是什么外，要格外重视思考每一个代码规范背后的为什么。代码规范的每一句话，背后无一例外都是一片江湖上的血泪史。</p><h4 id="trouble-shooting"><a href="#trouble-shooting" class="headerlink" title="trouble shooting"></a>trouble shooting</h4><p>要提高trouble shooting的能力，关键在于要深度复盘自己遇到的每一个问题，包括线上的，包括测试发现的，寻找每一个问题，每一次事故背后的root cause，并且思考后续如何避免同类问题，如何更快的发现同类问题。<br><em>要对团队内外遇到的所有问题都要保持好奇心，关注一下周边的事故、问题背后的root cause。</em></p><p>Trouble shooting能力的提高是几乎无法从书本上得到的，完全来源于对每一个问题的深度思考，以及广泛积累每一个问题。对于架构师而言，可能未必在一线写代码了，但看团队中一个架构师是否真正牛逼的一个很重要标准，就是看他是否能够追查出团队其他同学查不出来的问题。我见过的一个真正牛的架构师，对于系统中疑难杂症，通常问几个问题，就能大致猜出是哪里出的问题，以及可能的原因是什么，准确程度如同算命，屡试不爽，令人叹为观止。</p><h4 id="构建完整的当前技术领域的知识体系"><a href="#构建完整的当前技术领域的知识体系" class="headerlink" title="构建完整的当前技术领域的知识体系"></a>构建完整的当前技术领域的知识体系</h4><p>对于一个架构师，除了更加优秀的代码能力和trouble shooting能力外，需要构建相对完整的当前技术领域的知识体系，需要有体系化的思维能力，需要对技术所服务的业务有非常深入的了解。体系化的思维能力，来源于两个方面。一方面是在日常工作中，对每一个接口设计，每一个逻辑，每一个模块、子系统的拆分和组织方式，每一个需求的技术方案，每一个系统的顶层设计，都要反复思考和推敲，不断地复盘。另一方面，需要大量广泛地学习行业内相似系统的架构设计，这其实就是开天眼，只是技术相对来说，行业内的交流更加频繁。淘宝、美团、百度、Google、Facebook、Amazon等各个公司介绍系统架构的论文和PPT铺天盖地，需要带着问题持续学习。除了技术领域本身外，架构师需要非常了解业务上是如何使用我们的系统的，否则非常容易over design，陷入技术的自嗨中，这也是为什么我说Amazon Dynamo论文里讲的Vector Clock是个over design的原因。</p><p>另一方面，很多时候技术上绕不过去的坎，可能非常复杂的实现，往往只需要上层业务稍微变通一下，就完全可以绕过去，这也是为什么我说GFS论文里，多个Writer同时Append同一个文件是个根本没用的设计（实际上Google内部也把这个功能去掉了）。只有真正知道上层业务是如何使用系统的，才可能真正做好架构。深入了解业务并不难，对于每个同学，只要对于每一个接到的需求，对于每一个需求评审中的需求，对于周边同学或团队要做的需求，都深入思考为什么业务要提出这个需求，这个需求解决了业务的什么问题，有没有更好的方案。遇到不明白的多和周边同学、产品、运营同学请教。最怕的是自己把自己限定为纯粹的研发，接到需求就无脑做，这等于放弃了主动思考。衡量一个人是不是好的架构师，也有一个方法。对于一个需求，如果他给出了好几个可行的方案，说这些方案也可以，那些方案也可以，往往说明他在架构师的路上还没有完全入门。架构师的难点不在于给出方案，而在于找到唯一的那一个最简单优雅的方案。</p><ul><li>总结</li></ul><p>行动中思考，就是始终保持好奇，不断从工作中发现问题，不断带着问题回到工作中去；不断思考，不断在工作中验证思考；不断从工作中总结抽象，不断对工作进行复盘，持续不断把工作内容和全领域的知识交叉验证，反复实践的过程。</p><p>在工作所在的技术和业务领域中刻意练习，加上行动中思考，就是成为技术大牛的秘诀。</p><ul><li>看起来方法也不复杂，为什么大牛还是非常稀少？</li></ul><p>尽管我们通篇都在讲方法，但其实在成为技术大牛的路上，方法反而是没那么重要的。</p><blockquote><p>真正困难的，在于数年，数十年如一日的坚持。太多人遇到挫折，遇到瓶颈，就觉得手头的事情太乏味枯燥，就想要换一个方向，换一个领域，去学新的技术，新的东西。而真正能够成为大牛的，必须是能够青灯古佛，熬得住突破瓶颈前长时间的寂寞的，必须是肯下笨功夫的聪明人。因此，和坚持相比，方法其实并没有那么重要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>microservice</title>
      <link href="2021/06/09/microservice/"/>
      <url>2021/06/09/microservice/</url>
      
        <content type="html"><![CDATA[<p>微服务绪论</p><p>工程方法论，方法， 理念；</p><p>抛出一个实际问题是如何解答；</p><h2 id="1-微服务概览"><a href="#1-微服务概览" class="headerlink" title="1. 微服务概览"></a>1. 微服务概览</h2><h3 id="1-1-组件服务化"><a href="#1-1-组件服务化" class="headerlink" title="1.1 组件服务化"></a>1.1 组件服务化</h3><blockquote><p>传统实现组件的方式是通过库，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署；</p><p>通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程；</p></blockquote><ul><li>kit： 一个微服务的基础库（框架）如spring cloud</li><li>service： 业务代码 + kit依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue： 轻量级通讯 （服务与服务之间的通讯）message queue 如kafka</li></ul><p>本质上等同于，多个微服务组合（compose）完成了一个完整的用户场景（usecase）；</p><p>多个微服务之间做数据的组装； 面向场景的api设计；</p><h3 id="1-2-康威定律"><a href="#1-2-康威定律" class="headerlink" title="1.2 康威定律"></a>1.2 康威定律</h3><blockquote><p>“设计系统的架构受制于产生这些设计的组织的沟通结构。”</p></blockquote><p>微服务鼓励闭环团队；</p><p>Ownership 意识，全栈工程师。自己写的代码，自己测试，自己搞定线上问题；</p><p>you build it，you fix it</p><p>那测试和运维干什么？他们提供好用的测试平台，运维平台，指标采集体系，日志平台，让你去很方便的定位到问题；</p><p>运维全部转开发来做平台，</p><p>测试转开发做CI/CD，devops之类的工具；还有一些用户场景的测试；</p><p>大前端（移动/Web） =&gt; 网关接入 =&gt; 业务服务 =&gt; 平台服务  =&gt; 基础设施（Paas/Saas）</p><p>网关做什么： 所有流量要经过网关，网关对移动端API设计比较熟悉，协议也比较熟悉。网关和移动端同学沟通无成本形成闭环；（暂时就理解为给搞静态页面那个组前端 提供 组装接口的人）网关同事总归要聚合各种业务数据，服务端天然沟通无障碍（API契约之间的沟通），又形成了闭环；</p><p>服务端怎么和运维沟通，扔过来一个工具和文档，自己学习怎么用；</p><p><strong>开发团队对软件在生产环境的运行负全部责任！</strong></p><p>类似传统模式，想zz那样</p><p>程序在线上怎么跑的，开发完全不晓得；日志都不让看</p><h3 id="1-3-按业务组织服务"><a href="#1-3-按业务组织服务" class="headerlink" title="1.3 按业务组织服务"></a>1.3 按业务组织服务</h3><blockquote><p>服务提供的能力和业务功能对应，比如订单服务和数据访问服务，前者反应真实的订单相关业务，后者是一种技术抽象服务；按微服务架构理念来划分服务时，是不应该存在数据访问服务这样的一个服务的；</p><p>微服务下每个服务背后的小团队，要包含实现业务所需的全面的技能；</p></blockquote><h3 id="1-4-去中心化"><a href="#1-4-去中心化" class="headerlink" title="1.4 去中心化"></a>1.4 去中心化</h3><p>核心是数据去中心化和治理去中心化；</p><ul><li><p>数据去中心化：</p><p>​     每一个微服务独占一个DB，独占一个redis，服务与服务之间rpc</p></li><li><p>治理去中心化</p><p>​    流量变大了之后，服务与服务之间很多环节会出现流量热点。比如账号服务是所有微服务都要依赖的服务，如果所有的流量入口都要先走nginx的话，是否能改成直连账号服务；</p></li><li><p>技术去中心化</p><p>​    比较理想，选择最合适的语言来做不同的事情。 技术栈还是尽量统一的好；</p></li></ul><h3 id="1-5-基础设施自动化"><a href="#1-5-基础设施自动化" class="headerlink" title="1.5 基础设施自动化"></a>1.5 基础设施自动化</h3><p>无自动化不微服务，拆分微服务之后，意味着开发，调试，测试，监控和部署的复杂度都会响应增大；必须要有合适的自动化基础设施来支持微服务架构模式；</p><ul><li>CICD： </li><li>Testing</li><li>在线运行时： k8s</li></ul><h3 id="1-6-可用性-amp-兼容性设计"><a href="#1-6-可用性-amp-兼容性设计" class="headerlink" title="1.6 可用性&amp;兼容性设计"></a>1.6 可用性&amp;兼容性设计</h3><blockquote><p>Design For Failure， 所以依赖的东西都会炸；每一行代码都可能painc</p><p>微服务架构采用粗粒度的进程间通信，</p></blockquote><ul><li><p>隔离</p></li><li><p>超时控制</p></li><li><p>负载保护</p></li><li><p>限流</p></li><li><p>降级</p></li><li><p>重试</p></li><li><p>负载均衡</p></li></ul><p>一旦采用微服务架构模式，那么在服务需要变更时要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性；</p><p>发送时要保守，（发送时，要最小化发送必要的信息）</p><p>接收时要开放 （接收时最大限度容忍冗余数据，保证兼容性）</p><h2 id="2-微服务设计"><a href="#2-微服务设计" class="headerlink" title="2. 微服务设计"></a>2. 微服务设计</h2><h3 id="2-1-网关"><a href="#2-1-网关" class="headerlink" title="2.1 网关"></a>2.1 网关</h3><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/00.png" alt="1.0"></p><p>1.0版本，外网通过 AWS（ngix）可以直连到 提供的所有服务（用户，稿件，推荐，广告）。</p><p>对外暴露了一批微服务，缺乏统一的出口；</p><p>用户等于是直连了 某个微服务；</p><p><strong>坑</strong></p><ol><li>客户端到微服务直接通信，强耦合。移动端的版本是可以不升级的。这导致后续服务端重构是要兼容老版本的。如果移动端直连微服务。那服务端也是无法随心所欲重构的；很难大规模重构；</li><li>客户端需要多次请求，客户端需要自己聚合数据，工作量巨大不谈，主要延迟高；各服务之间接口的协议有时候还特么不一样；就没法降级；客户端是Landing Page，很重要；要讲究效率； 重的数据聚合最好在服务端全部做掉；面向资源的API是屁，面向用户业务场景的API才是王道；</li><li>面向“端”的API适配，耦合到了内部服务；（不同的机型/终端要的字段不一样，得适配）</li><li>统一逻辑无法收敛，比如安全认证、限流（每一个微服务做安全认证，token验证之类的）</li></ol><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/01.png" alt="image-20210609152717655"></p><p>2.0版本，新增了一个 app-interface用于统一的协议出口，在服务内进行大量的dataset join，按照业务场景来设计粗粒度的API，给后续服务的演进带来很多优势：这个所谓的app-interface就是BFF层；</p><p>传说中的BFF，Backend for Frontend （面前前端业务场景的后端）</p><p>现在BFF负责跟微服务对接，BFF跟客户端对接；然后说白了，垃圾代码，耦合代码就写进BFF了； </p><p>BFF可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务；</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/02.png" alt="image-20210609153326572"></p><p>3.0版本，解决2.0单个 BFF会造成的单点故障；严重代码缺陷或流量洪峰可能引发集群宕机；</p><p>按照业务域将 BFF拆分成几个大的BFF，如app-interface,  app-view,  account-interface；随着拆分的越来越多，变得越来越难以维护。基础库更新，意味着所有BFF都需要更新；</p><p>很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多；</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/03.png" alt="image-20210609153910073"></p><p>4.0版本，网关选手出场；</p><p>跨横切面（Cross-Cutting Concerns）的功能，需要协调更新框架升级发版（路由，认证，限流，安全），因此全部上沉，引入API Gateway， 把业务及程度高的BFF层和通用功能服务层API Gateway进行了分层处理；</p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器，在网关的配合下，单块BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升，另外，把跨横切面逻辑从BFF剥离到网关上去之后，BFF的开发人员可以更加专注业务逻辑交付，实现架构上的关注分离</p><p>移动端-&gt;API Gateway -&gt; BFF -&gt; Mircoservice</p><p>在FE Web业务中，BFF可以是nodejs来做服务端渲染（SSR，Server-Side Rendering）</p><h3 id="2-2-Mircoservice-划分"><a href="#2-2-Mircoservice-划分" class="headerlink" title="2.2 Mircoservice 划分"></a>2.2 Mircoservice 划分</h3><blockquote><p>在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能或是DDD</p></blockquote><p>一般还没搞清楚公司业务的时候，划分微服务的依据即业务职能</p><ul><li><p>业务职能</p><p>根据部门处理业务不同，拆分。比如稿件 和 视频拆分开来</p></li><li><p>DDD</p><p>面向业务场景，比如一个用户在创作的时候，他的制作流程是先稿件后视频，那么就将稿件和视频放在一起，作为一个业务场景的服务组合；</p></li></ul><h4 id="2-2-1-微服务到底要拆多细"><a href="#2-2-1-微服务到底要拆多细" class="headerlink" title="2.2.1 微服务到底要拆多细"></a>2.2.1 微服务到底要拆多细</h4><p>两个角度：</p><ol><li>从组合结构来讲， 是否能形成业务闭环。如果能够闭环，那么闭环的团队own一个服务，不要一个功能散在好几个职能部门当中；（会带来沟通不畅）</li><li>拆的比较细，需要请求比较多的时候，再考虑整合；</li></ol><h4 id="2-2-2-CQRS"><a href="#2-2-2-CQRS" class="headerlink" title="2.2.2 CQRS"></a>2.2.2 CQRS</h4><h3 id="2-3-mircoservice安全"><a href="#2-3-mircoservice安全" class="headerlink" title="2.3 mircoservice安全"></a>2.3 mircoservice安全</h3><ul><li>外网安全</li></ul><p>对于外网请求，通常在API Gateway进行统一的认证拦截，一旦认证成功，会使用JWT方法通过RPC原数据传递的方式带到BFF层，BFF层校验Token完整性后把身份信息注入到应用的Context中，BFF到其他下层的微服务，建议是直接在RPC Request中带入用户身份信息（UserID）请求服务；</p><p>​    网关 到 BFF 是token传递，BFF到service是 用户id传递；</p><ul><li>内网安全</li></ul><p>对于服务内部，一般要区分身份认证和授权；先做身份认证，再做授权；</p><p>​    身份认证： 谁来连我，我就知道你是谁，grpc基于证书判断是谁。知道对方是谁之后很容易利用配置中心来做一个RBAC服务，做一个微服务控制面板来配置哪些服务对你有权限，这些数据可以写到配置中心，然后下推到服务；在服务加载的时候，构建RBAC序列的权限认证，判定这个人对这个接口有无权限；</p><p>有些严格内网微服务，服务与服务之间的通信都需要加解密；避免有人抓包嗅探，它的等级分为</p><ul><li>Full Trust      完整的tls</li><li>Half Trust     知道你是谁，但通讯不加密</li><li>Zero Trust    裸奔</li></ul><h2 id="3-gRPC和服务发现"><a href="#3-gRPC和服务发现" class="headerlink" title="3. gRPC和服务发现"></a>3. gRPC和服务发现</h2><h3 id="3-1-gRPC"><a href="#3-1-gRPC" class="headerlink" title="3.1 gRPC"></a>3.1 gRPC</h3><h4 id="3-1-1-HealthCheck"><a href="#3-1-1-HealthCheck" class="headerlink" title="3.1.1 HealthCheck"></a>3.1.1 HealthCheck</h4><p> <img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/04.png" alt="image-20210609173458932"></p><p>Discovery ：服务发现</p><p>Provider： 生产者要定时注册（发送心跳）给服务发现，注册rpc协议，协议端口（rpc://ip:port）</p><p>假设Provider和Consumer之间发生网络抖动，这个只能通过healthCheck来解决了。</p><ul><li>平滑发布</li></ul><p>一个应用上线，什么时候要往 服务发现注册。一种做法就是 外挂探测，就是在容器外边有一个脚本去check 服务发现，去判断当前服务是否可用（一个服务启动之后往往不能立即提供服务，因为需要加载DAO，service以及缓存等等。最终才能产生正常的服务，然后需要有一种外挂方式让外面的人知道当前能够提供服务了）</p><ul><li>平滑下线</li></ul><p>版本滚动 升级，先下线1.0，然后上线1.1；</p><p>k8s向APP发送sigterm信号，进入优雅退出过程；go的main 函数会拦截到这个信号，这个时候进程还在跑。还有大量数据进出；</p><p>第一步，收到sigterm信号， </p><p>第二步， 先告诉注册中心，服务提供者收到一个信号之后。告诉服务注册中心，注销掉自己，然后其他节点都会收到这个消息，其他节点陆陆续续要下线了；</p><p>第三步，把自己health check接口也标记为待下线，自己进入一个优雅退出的状态。</p><p>（基本两个心跳周期之内，所有的消费者节点均能收到该服务要下线的通知；）</p><p>第四步：用http或者rpc的 shut down接口。</p><p>第五步： 如果发现此进程一直退出不了，就要kill -9了</p><h3 id="3-2-服务发现"><a href="#3-2-服务发现" class="headerlink" title="3.2 服务发现"></a>3.2 服务发现</h3><p>客户端发现</p><p>服务端发现</p><h4 id="3-2-1-CAP"><a href="#3-2-1-CAP" class="headerlink" title="3.2.1 CAP"></a>3.2.1 CAP</h4><blockquote><p>一个分布式系统最多只能同时满足一致性(<strong>Consistency</strong>)，可用性(<strong>Availability</strong>)，分区容错性(<strong>Partition</strong> <strong>tolerance</strong>)这三项中的两项;</p></blockquote><p>分布式数据存储不可能同时满足以下三个条件：</p><p>一致性：每次读取要么获得最近写入的数据，要么获得一个错误；</p><p>可用性：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据；</p><p>分区容错性：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行</p><p>核心理解：</p><p>在出现网络分区的时候，</p><ul><li>如果系统不允许写入，那么意味着降低了系统的可用性，但不同分区的数据能够保持一致，即选择了一致性；</li><li>如果系统允许写入，那么意味着不同分区之间的数据产生不一致，系统可用性得到保障，即选择可用性；</li></ul><p>分区容忍：</p><p>分区容忍就是指分布式系统在出现网络分区的时候，仍然能够继续运行，对外提供服务；</p><p>可用性范围：</p><p>对于分布式系统中每个节点，都能够对外部请求作出响应，但不要求一致性；</p><p>衡量系统可用性的标准是什么？ 关键点在于可用性的范围。讨论可用性要有具体场景来划分边界；</p><p>举例子： 谷歌文档就是非常典型的AP系统，它在网络断了的情况下也能够使用。诀窍在于它发现网络断掉之后会进入离线模式。允许用户继续进行编辑，然后在网络恢复之后再对修改的内容进行合并处理。</p><p>可以发现对于谷歌文档来说，用户的浏览器也是系统的一个节点，当出现网络分区时，它仍然能够为用户提供服务，代价是放弃一致性（离线用户编辑了啥，服务器并不知道）。在这个例子里面，可用性的范围是包括了用户浏览器在内的，不是常规理解的分布式系统节点一定就是服务端的机器；</p><p>一致性的范围：</p><p>讨论一致性的时候必须要明确一致性的范围，即在一定的边界内状态是一致的，超出边界之外的一致性是无从谈起的；</p><p>管理分区：</p><p>网络分区是分布式系统中必然发生的事情，经典的CAP理论是忽略网络延迟的，但是在现实世界中，网络延迟跟分区密切相关，也就是说当系统在有限的时间内无法通信达成一致（网络延迟很高），就意味着发生了分区。此时就需要在一致性和可用性之间作出选择：选择继续重试就意味着选择一致性，放弃可用性；放弃数据一致性让操作完成就意味着选择了可用性。值得注意的是在分区的时候放弃数据一致性并不是意味着完全不管，一般工程实现会采用重试的方式达到最终的一致性；</p><p><strong>结论</strong></p><p><strong>分析：平衡分区期间的可用性和一致性的影响是分布式系统设计中的关键问题。因此，管理分区不仅是需要主动发现分区，还需要针对分区期间产生的影响准备恢复过程。</strong> 可以从另外一个角度来应用CAP理论：系统进入分区模式的时候，如何在一致性和可用性之间作出选择；</p><p>管理分区的三个步骤：</p><ul><li>检测到分区开始</li><li>明确进入分区模式，限制某些操作</li><li>当通信恢复后启动分区恢复过程</li></ul><p>当系统进入分区模式之后，有两种选择：</p><ul><li>选择一致性：例如Paxos算法，只有大多数的主分区能够进行操作，其他分区不可用，当网络恢复之后少数节点跟多数节点同步数据；</li><li>选择可用性： 例如谷歌文档，出现分区进入离线模式，等网络恢复了客户端跟服务端数据进行合并恢复；</li></ul><h3 id="3-3-euerka实现原理"><a href="#3-3-euerka实现原理" class="headerlink" title="3.3 euerka实现原理"></a>3.3 euerka实现原理</h3><blockquote><p>AP服务发现，牺牲一致性； 采用的异步复制机制；</p></blockquote><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/05.png" alt="image-20210610171716748"></p><h3 id="3-4-多集群-amp-多租户"><a href="#3-4-多集群-amp-多租户" class="headerlink" title="3.4 多集群&amp;多租户"></a>3.4 多集群&amp;多租户</h3><h4 id="3-4-1-多集群"><a href="#3-4-1-多集群" class="headerlink" title="3.4.1 多集群"></a>3.4.1 多集群</h4><p>统一为一套逻辑集群（物理上多套资源池），即gRPC客户端默认忽略服务发现中的cluster信息，按照全部节点，全部连接。能不能找到一种算法从全集群中选取一批节点（子集），利用划分子集限制连接池大小；</p><ul><li>长连接导致的内存和CPU开销，HealthCheck可以高达30%。</li><li>短连接极大的资源成本和延迟；</li></ul><p>合适的子集大小和选择算法；</p><ul><li>通常20-100个后端，部分场景需要大子集，比如大批量读写操作；</li><li>后端平均分给客户端</li><li>客户端重启，保持重新均衡，同时对后端重启保持透明，同时连接的变动最小；</li></ul><h4 id="3-4-2-多租户"><a href="#3-4-2-多租户" class="headerlink" title="3.4.2 多租户"></a>3.4.2 多租户</h4><p>在一个微服务架构中， 允许多系统共存 是利用微服务稳定性以及模块化最有效的方式之一，</p><p>这种方式一般被称为多租户，</p><p>租户可以是测试，金丝雀发布，影子系统（shadow system），甚至服务层或者产品线，使用租户能够保证代码的隔离性 并且能够基于 流量租户做路由决策；</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/06.png" alt="image-20210615112159601"></p><p>对于传输的数据，以及静态数据，租户都能够保证隔离性和公平性，以及基于租户的路由机会；</p><p>如上图所示，如果对服务B作出改变，我们需要确保它仍然能够和服务A，C，D正常交互在微服务架构中，我们需要做这些集成测试场景，也就是测试和该系统中其他服务的交互。通常来说，微服务架构有两种基本的集成测试方法：并行测试 和 生产环境测试；</p><p>具体一个场景，分布式的测试环境上，一个用户正在测试很容易因为别人一套push操作，把自身的环境给冲掉了；就像当时在zz，你push一个版本侧着侧着，别人push一套代码把你的环境污染了；尽管zz那个不一定是分布式系统；</p><ul><li>混用环境导致的不可靠测试；</li><li>多套环境带来的硬件成本；</li><li>难以做负载测试，仿真线上真实流量情况；</li></ul><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/microservice/07.png" alt="image-20210615113448439"></p><p>把待测试的服务B在一个隔离的沙盒环境中启动，并且在沙盒环境下可以访问集成环境（UAT）C和D。我们把测试流量路由到服务B，同时保持生产流量正常流入到集成服务。服务B仅仅处理测试流量而不处理生产流量。另外要确保集成流量不要被测试流量影响。生产中的测试提出了两个基本要求，它们也构成了多租户体系结构的基础：</p><ul><li>流量路由：能够基于流入栈中的流量类型做路由</li><li>隔离性：能够可靠的隔离测试和生产中的资源，这样可以保证对于关键业务微服务没有副作用；</li></ul><p>灰度测试成本代价很大，影响1/N的用户。其中N为节点数量；</p><p> 当测试完毕之后，将B`的代码推到 集成测试中B的位置做回归测试（回跑一些历史的case，不会做功能测试）。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goparallel</title>
      <link href="2021/06/01/goparallel/"/>
      <url>2021/06/01/goparallel/</url>
      
        <content type="html"><![CDATA[<h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><h2 id="2-并行与并发"><a href="#2-并行与并发" class="headerlink" title="2. 并行与并发"></a>2. 并行与并发</h2><h3 id="2-1-并行（parallel）"><a href="#2-1-并行（parallel）" class="headerlink" title="2.1 并行（parallel）"></a>2.1 并行（parallel）</h3><blockquote><p>并行，同一时刻，有多条指令在多个处理器上同时执行。并行需要借助多核cpu实现。</p></blockquote><h3 id="2-2-并发"><a href="#2-2-并发" class="headerlink" title="2.2 并发"></a>2.2 并发</h3><p>宏观：在用户体验上，程序在并行执行</p><p>微观：多个计划任务，顺序执行。在飞快的切换，轮换使用cpu时间轮片；（cpu时间调度算法）</p><p>进程状态：</p><p>初始态、 就绪态、 运行态、 挂起（阻塞）态、终止（停止）态</p><p>线程并发：</p><p>什么是线程</p><p>Lwp（light weight process）轻量级进程，本质上仍是进程（Linux下）</p><p>进程： 独立地址空间，拥有PCB</p><p>线程： 有独立的PCB，但没有独立的地址空间（共享）</p><p>区别： 在于是否共享地址空间，独居（进程）； 合租（线程）</p><p>线程： 最小的执行单位</p><p>进程： 最小分配资源单位，可看成是只有一个线程的进程；</p><h3 id="2-3-线程同步"><a href="#2-3-线程同步" class="headerlink" title="2.3 线程同步"></a>2.3 线程同步</h3><p>同步即协同步调，按预定的先后次序运行。</p><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回，同时其它线程为保证数据一致性，不能调用该功能；</p><p>举例：A，B两张银行卡取钱。当两个线程访问共享资源时，如果没有协调机制，会产生与时间有关的错误。—— 锁</p><p>因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</p><h4 id="2-3-1-线程同步机制："><a href="#2-3-1-线程同步机制：" class="headerlink" title="2.3.1 线程同步机制："></a>2.3.1 线程同步机制：</h4><p>互斥锁（互斥量）：建议锁，拿到锁以后，才能访问数据，没有拿到锁的线程，阻塞等待。等到拿锁的线程释放锁。</p><p>读写锁： 一把锁（读属性、写属性），写独占，读共享，写锁优先级高 </p><p>信号量：</p><p>条件变量：</p><h3 id="2-4-协程并发"><a href="#2-4-协程并发" class="headerlink" title="2.4 协程并发"></a>2.4 协程并发</h3><p>协程： coroutine，也叫轻量级线程。</p><p>与传统系统级线程和进程相比，协程最大优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源崩溃。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。</p><p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行。多个协程分享该线程分配到的计算机资源。</p><p>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</p><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>在一次并发任务中，进程、线程、协程都可以实现，从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。</p><p>进程并发：优点是稳定性强，开销较线程大。</p><p>线程并发：优点是节省资源，尤其是调度时，线程与线程之间切换的时候。而进程间切换的开销就比较大一些。</p><p>协程并发： 效率高，系统利用率高</p><h2 id="3-goroutine"><a href="#3-goroutine" class="headerlink" title="3. goroutine"></a>3. goroutine</h2><p>Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP（communicating sequential processes）。这就意味着显式锁都是可以避免的。因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p><p>Go语言中的并发程序主要是用两种手段来实现。goroutine 和 channel</p><h3 id="3-1-概论"><a href="#3-1-概论" class="headerlink" title="3.1 概论"></a>3.1 概论</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> sing()</span><br><span class="line">  <span class="keyword">go</span> dance()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="goroutine1.png" alt="image-20210325101308012"></p><p>Goroutine 的并发机制；main goroutine中的for{} 占据较长的时间。可以确保两个goroutine能执行完毕；</p><p><strong>Goroutine的特性：</strong></p><p>主go程结束，子go程随之退出；</p><h3 id="1-1-goroutine"><a href="#1-1-goroutine" class="headerlink" title="1.1 goroutine"></a>1.1 goroutine</h3><p>在Go中，独立的任务叫做goroutine</p><ul><li>虽然goroutine与其它语言中的协程、进程、线程都有相似之处，但goroutine和它们并不完全相同</li><li>goroutine和它们并不完全相同，</li><li>Goroutine创建效率非常高</li><li>Go能直截了当的协同多个并发（concurrent）操作</li></ul><p>在某些语言中，将顺序式代码转化为并发式代码需要做大量修改。</p><p>在Go里，无需修改现有顺序式的代码，就可以通过goroutine以并发的方式运行任意数量的任务；</p><h3 id="1-2-启动goroutine"><a href="#1-2-启动goroutine" class="headerlink" title="1.2 启动goroutine"></a>1.2 启动goroutine</h3><p>只需在调用前面加一个go关键字；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher() <span class="comment">// go 关键字相当于启动一个 goroutine,另开辟了一条道路，在那条道路里面执行。然后main函数是一条主干道。主干道继续往下执行，当main函数返回的时候，该程序运行的所有goroutine都会立即停止，无论有没有走完。所以想在main函数返回之前让 sleepGopher 函数输出 ...snore... 的话，就需要多等待一段时间，已知 sleepGopher sleep了3秒，所以选择让main函数sleep了4秒</span></span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">// 3*time.Second = 3s</span></span><br><span class="line">fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-不止一个goroutine"><a href="#1-3-不止一个goroutine" class="headerlink" title="1.3 不止一个goroutine"></a>1.3 不止一个goroutine</h3><p>每次使用go关键字都会产生一个新的goroutine</p><p>表面上看，goroutine似乎在同时运行，但由于计算机处理单元有限，其实技术上来说，这些goroutine不是真的在同时运行；</p><ul><li>计算机处理器会使用“分时”技术，在多个goroutine上轮流花费一些时间；</li><li>在使用goroutine时，各个goroutine的执行顺序无法确定；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-1-goroutine的参数"><a href="#1-3-1-goroutine的参数" class="headerlink" title="1.3.1 goroutine的参数"></a>1.3.1 goroutine的参数</h4><p>向goroutine传递参数就根向函数传递参数一样，参数都是按值传递的（传入的是副本）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"...snore..."</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...snore... 2</span></span><br><span class="line"><span class="comment">// ...snore... 3</span></span><br><span class="line"><span class="comment">// ...snore... 0</span></span><br><span class="line"><span class="comment">// ...snore... 1</span></span><br><span class="line"><span class="comment">// ...snore... 4</span></span><br></pre></td></tr></table></figure><p>在使用goroutine时，各个goroutine的执行顺序无法确定；</p><h3 id="3-2-runtime包"><a href="#3-2-runtime包" class="headerlink" title="3.2 runtime包"></a>3.2 runtime包</h3><h4 id="3-2-1-Gosched"><a href="#3-2-1-Gosched" class="headerlink" title="3.2.1 Gosched"></a>3.2.1 Gosched</h4><p>runtime.Gosched() 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次再获得cpu时间轮片的时候，从该让cpu的位置恢复执行。</p><p>当再次获得cpu时，从出让位置继续回复执行；</p><p>—— 时间片轮转调度算法；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"this is goroutine"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    runtime.Gosched() <span class="comment">// </span></span><br><span class="line">fmt.Println(<span class="string">"this is main test"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-Goexit"><a href="#3-2-2-Goexit" class="headerlink" title="3.2.2 Goexit"></a>3.2.2 Goexit</h4><p>调用runtime.Goexit(), 将立即终止 当前goroutine执行，调度器确保所有已注册defer延迟调用被执行；</p><p>return和Goexit之间的差异</p><p>return：返回当前函数调用给调用者；后续语句不糊执行了。return之前的defer生效，之后的defer不生效了；</p><p>Goexit：结束调用该函数的当前goroutine，Goexit()之前注册的defer都生效；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">"ccc"</span>)</span><br><span class="line">  runtime.Goexit();</span><br><span class="line">  fmt.Println(<span class="string">"ddd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"aaa"</span>)</span><br><span class="line">    test()</span><br><span class="line">    fmt.Println(<span class="string">"bbb"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">for</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// aaa</span></span><br><span class="line"><span class="comment">// ccc</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3-runtime-GOMAXPROCS"><a href="#3-2-3-runtime-GOMAXPROCS" class="headerlink" title="3.2.3 runtime.GOMAXPROCS()"></a>3.2.3 runtime.GOMAXPROCS()</h4><p>调用runtime.GOMAXPROCS() 设置可以并行计算的CPU核数最大值，并返回之前的值；</p><p>返回值：上一次设置的核心数</p><h2 id="4-channel"><a href="#4-channel" class="headerlink" title="4. channel"></a>4. channel</h2><p>channel是Go语言中的一个核心类型，可以把它看成管道（FIFO，first in ，first out）。并发核心单元通过它就可以发送或接收数据进行通讯，这在一定程度上又进一步降低了编程难度；</p><p>channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享的问题</p><p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步，<code>goroutine奉行通过通信来共享内存，而不是共享内存来通信；</code></p><p>引用类型channel可用于多个gouroutine通讯，其内部实现了同步，确保并发安全；</p><p>CSP是Communicating Sequential Process的简称，直译为通讯顺序进程，或者叫做交换信息的循序进程，是用来描述并发系统中进行交互的一种模式；</p><p>csp允许使用进程组件来描述系统，它们独立运行，并且只通过消息传递的方式通信；go通过引入Channel这个新的类型，来实现CSP的思想；</p><p>Don‘t  communicate by sharing memory, share memory by communication; (执行业务处理的goroutine不要通过共享内存的方式通信，而是要通过Channel通信的方式分享数据)</p><p>Don‘t  communicate by sharing memory:  是传统的并发编程处理方式，就是指，共享的数据需要锁保护，goroutine需要获取到锁，才能并发访问数据；</p><p> share memory by communication：类似CSP模型的方式，通过通信的方式，一个goroutine可以把数据“所有权”交给另外一个goroutine；</p><ul><li>啥时候用channel</li></ul><p>Go开发者极力推荐使用channel，不过，这两年，大家意识到，channel并不是处理并发问题的“银弹”，有时候使用并发原语更简单，并且不容易出错。</p><ol><li>共享资源的并发访问使用传统并发原语；</li><li>复杂的任务编排和消息传递使用channel；</li><li>消息通知机制使用channel，除非只想signal一个goroutine，才使用Cond；</li><li>简单等待所有任务的完成用WaitGroup，也有Channel的推崇者用Channel，都可以；</li><li>需要和Select语句结合，使用Channel；</li><li>需要和超时配合时，使用Channel和Context；</li></ol><h3 id="4-0-channel应用场景的五种类型"><a href="#4-0-channel应用场景的五种类型" class="headerlink" title="4.0 channel应用场景的五种类型"></a>4.0 channel应用场景的五种类型</h3><h4 id="4-0-1-数据交流"><a href="#4-0-1-数据交流" class="headerlink" title="4.0.1 数据交流"></a>4.0.1 数据交流</h4><blockquote><p>当作并发的buffer或者queue，解决生产者 - 消费者问题。多个goroutine可以并发当作生产者（producer）和消费者(Consumer)</p></blockquote><h4 id="4-0-2-数据传递"><a href="#4-0-2-数据传递" class="headerlink" title="4.0.2 数据传递"></a>4.0.2 数据传递</h4><blockquote><p>一个goroutine将数据交给另一个goroutine，相当于把数据的拥有权（引用）托付出去；</p></blockquote><ul><li><p>例题：有4个goroutine，编号为，1，2，3，4 没秒会有一个goroutine打印出它自己的编号，要求你编写程序，让输出的编号总是按照1，2，3，4，1，2，3，4.。。 这个顺序打印出来；</p><p>为了实现顺序的数据传递，可以定一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌传递给下一个goroutine，我们尝试使用chan来实现；</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// select，通过select 可以监听channel上的数据流动</span></span><br><span class="line"><span class="comment">// 如果给出default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复</span></span><br><span class="line"><span class="comment">// 如果没有default语句，那么select语句将会被阻塞，直到至少有一个通信可以进行下去</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWorker</span><span class="params">(id <span class="keyword">int</span>, ch <span class="keyword">chan</span> Token, nextCh <span class="keyword">chan</span> Token)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">token := &lt;-ch       <span class="comment">// 从自己的chan 中读取令牌</span></span><br><span class="line">fmt.Println(id + <span class="number">1</span>) <span class="comment">// id 从1开始</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">nextCh &lt;- token</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for &#123;</span></span><br><span class="line"><span class="comment">//token := &lt;- chs[0]</span></span><br><span class="line"><span class="comment">//fmt.Println(0 + 1)</span></span><br><span class="line"><span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line"><span class="comment">//chs[1] &lt;- token</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//for &#123;</span></span><br><span class="line"><span class="comment">//token := &lt;-chs[1]</span></span><br><span class="line"><span class="comment">//fmt.Println(1 + 1)</span></span><br><span class="line"><span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line"><span class="comment">//chs[2] &lt;- token</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//for &#123;</span></span><br><span class="line"><span class="comment">//token := &lt;- chs[2]</span></span><br><span class="line"><span class="comment">//fmt.Println(2 + 1)</span></span><br><span class="line"><span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line"><span class="comment">//chs[3] &lt;- token</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//for &#123;</span></span><br><span class="line"><span class="comment">//token := &lt;-chs[3]</span></span><br><span class="line"><span class="comment">//fmt.Println(3 + 1)</span></span><br><span class="line"><span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line"><span class="comment">//chs[0] &lt;- token</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">chs := []<span class="keyword">chan</span> Token&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token)&#125;</span><br><span class="line"><span class="comment">// 创建4个worker</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> newWorker(i, chs[i], chs[(i+<span class="number">1</span>)%<span class="number">4</span>]) <span class="comment">// 启动每个worker的goroutine</span></span><br><span class="line"><span class="comment">//newWorker(0, chs[0], chs[1])</span></span><br><span class="line"><span class="comment">//newWorker(1, chs[1], chs[2])</span></span><br><span class="line"><span class="comment">//newWorker(2, chs[2], chs[3])</span></span><br><span class="line"><span class="comment">//newWorker(3, chs[3], chs[0])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先把令牌交给第一个worker</span></span><br><span class="line">chs[<span class="number">0</span>] &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面注释代码所示，channel实现顺序打印1，2，3，4.实际上就是利用token的，来将多个channel串联；因为每个for循环中的channel如果在读写两端没有数据写入或读取的话。channel是被阻塞挂起的；</p><p>这类场景有一个特点，就是当前持有数据的goroutine都有一个信箱，信箱使用chan实现，goroutine只需要关注自己的信箱中的数据，处理完毕后，就把结果发送到下一家的信箱中；</p><h4 id="4-0-3-信号通知"><a href="#4-0-3-信号通知" class="headerlink" title="4.0.3 信号通知"></a>4.0.3 信号通知</h4><blockquote><p>一个goroutine可以将信号（closing，closed, data ready等）传递给另一个或者另一组goroutine</p><p>chan类型有这样一个特点，chan如果为空，那么receiver接收数据的时候就会阻塞等待，直刀chan被关闭或者有新的数据到来，利用这个机制，我们可以实现wait/notify的设计模式；</p></blockquote><p>除了正常业务处理时的wait/notify，经常碰到的一个场景，就是程序关闭的时候，我们需要在退出之前做一些清理，这个时候，经常用到chan</p><ul><li>退出的时候分为两个阶段</li></ul><ol><li>closing，代表程序退出，但是清理工作还没做</li><li>closed，代表清理工作已经做完；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/signal"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> closing = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> closed = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-closing:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// .... 业务计算</span></span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 ctrl+c 等中断信号</span></span><br><span class="line">termChan := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">&lt;-termChan</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(closing)</span><br><span class="line"><span class="comment">// 执行退出之前的清理动作</span></span><br><span class="line"><span class="keyword">go</span> doCleanup(closed)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-closed:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">fmt.Println(<span class="string">"清理超时，不等了"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"优雅退出"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCleanup</span><span class="params">(closed <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Minute)</span><br><span class="line"><span class="built_in">close</span>(closed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-0-4-任务编排"><a href="#4-0-4-任务编排" class="headerlink" title="4.0.4 任务编排"></a>4.0.4 任务编排</h4><blockquote><p>可以让一组goroutine按照一定的顺序并发或者串行的执行，这就是编排的功能；</p></blockquote><p>多个chan的编排方式，共5种</p><h5 id="4-0-4-1-Or-Done模式"><a href="#4-0-4-1-Or-Done模式" class="headerlink" title="4.0.4.1 Or-Done模式"></a>4.0.4.1 Or-Done模式</h5><blockquote><p>使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义一个类型为chan struct{}类型的done变量，等通知任务结束后，我们就可以close这个变量，然后，其他receiver就会收到这个通知；</p><p>这是有一个任务的情况，如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是Or-Done模式</p><p>比如，你发送同一个请求到多个微服务节点，只要任意一个微服务节点返回结果，就算成功，实现如下</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">// 特殊情况，只有0个或者1个chan</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 2也是一种特殊情况</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line"><span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 超过2个，二分递归处理</span></span><br><span class="line">m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-or(channels[:m]...):</span><br><span class="line"><span class="keyword">case</span> &lt;-or(channels[m:]...):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sig</span><span class="params">(after time.Duration)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">time.Sleep(after)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">&lt;-or(</span><br><span class="line">sig(<span class="number">10</span>*time.Second),</span><br><span class="line">sig(<span class="number">20</span>*time.Second),</span><br><span class="line">sig(<span class="number">30</span>*time.Second),</span><br><span class="line">sig(<span class="number">40</span>*time.Second),</span><br><span class="line">sig(<span class="number">50</span>*time.Second),</span><br><span class="line">sig(<span class="number">01</span>*time.Minute),</span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">"done after %v"</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-0-4-2-扇入模式"><a href="#4-0-4-2-扇入模式" class="headerlink" title="4.0.4.2 扇入模式"></a>4.0.4.2 扇入模式</h5><h5 id="4-0-4-3-扇出模式"><a href="#4-0-4-3-扇出模式" class="headerlink" title="4.0.4.3 扇出模式"></a>4.0.4.3 扇出模式</h5><h5 id="4-0-4-4-Stream"><a href="#4-0-4-4-Stream" class="headerlink" title="4.0.4.4 Stream"></a>4.0.4.4 Stream</h5><blockquote><p>介绍一种把Channel当作流式管道使用的方式，也就是把Channel看作流（Stream）,提供跳过几个元素，或者是只取其中几个元素等方法</p></blockquote><p>下面这个方法一个数据slice转换成流</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asStream</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, values ...<span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(s)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123; <span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> s &lt;- v: <span class="comment">// 将数组元素塞入chan中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流创建好之后，下面介绍实现流的方法</p><ol><li>takeN: 只取流中前n个数据</li><li>takeFn: 筛选流中数据，只保留满足条件的数据：</li><li>takeWhile: 只取前面满足条件的数据，一旦不满足条件，就不再取：</li><li>skipN: 跳过流中前几个数据；</li><li>skipFn: 跳过满足条件的数据；</li><li>skipWhile: 跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给Channel的receiver</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takeN</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, num <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- &lt;-valueStream: <span class="comment">// 从输入流中读取元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-0-4-5-Map-Reduce"><a href="#4-0-4-5-Map-Reduce" class="headerlink" title="4.0.4.5 Map-Reduce"></a>4.0.4.5 Map-Reduce</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapChan</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> in == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 启动一个goroutine，实现map的主要逻辑</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> in &#123; <span class="comment">// 从输入chan读取数据，执行业务操作，也就是map操作</span></span><br><span class="line">out &lt;- fn(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(r, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> in == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">out := &lt;-in         <span class="comment">// 先读取第一个元素</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> in &#123; <span class="comment">// 实现reduce 主要逻辑</span></span><br><span class="line">out = fn(out, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个程序，这个程序使用 map-reduce 模式处理一组整数，map函数就是为每个整数乘以10， reduce函数就是把map处理的结果累加起来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个数据流</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsStream</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(s)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123; <span class="comment">// 从数组生成</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> s &lt;- v:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := AsStream(<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// map *10</span></span><br><span class="line">mapFn := <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> v.(<span class="keyword">int</span>) * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reduce 累加</span></span><br><span class="line">reduceFn := <span class="function"><span class="keyword">func</span><span class="params">(r, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> r.(<span class="keyword">int</span>) + v.(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum := reduce(mapChan(in, mapFn), reduceFn) <span class="comment">// 返回累加结果</span></span><br><span class="line">fmt.Println(sum)                            <span class="comment">// 150</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-0-5-锁"><a href="#4-0-5-锁" class="headerlink" title="4.0.5 锁"></a>4.0.5 锁</h4><blockquote><p>利用Channel也可以实现互斥锁的机制；</p><p>要想使用chan实现互斥锁，至少有两种方法，</p><p>一种方式是先初始化一个capacity等于1的channel，然后再放入一个元素。这个元素就代表锁，谁取得了这个元素，就相当于获取了这把锁。</p><p>另一种方式是，先初始化一个capacity等于1的channel，它的空槽代表锁，谁能成功把元素发送这个Channel，谁就获取了这把锁；</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用锁需要初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutex</span><span class="params">()</span> *<span class="title">Mutex</span></span> &#123;</span><br><span class="line">mu := &amp;Mutex&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)&#125;</span><br><span class="line">mu.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> mu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求锁，直到获取</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-m.ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">TryLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.ch:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入一个超时的设置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">LockTimeout</span><span class="params">(timeout time.Duration)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">timer := time.NewTimer(timeout)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.ch:</span><br><span class="line">timer.Stop()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁四否已被持有</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">IsLocked</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(m.ch) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := NewMutex()</span><br><span class="line">ok := m.TryLock()</span><br><span class="line">fmt.Printf(<span class="string">"locked v %v\n"</span>, ok)</span><br><span class="line">ok = m.TryLock()</span><br><span class="line">fmt.Printf(<span class="string">"locked %v\n"</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//locked v true</span></span><br><span class="line"><span class="comment">//locked false</span></span><br></pre></td></tr></table></figure><p>用buffer等于1的chan实现互斥锁，在初始化这个锁的时候往Channel中先塞入一个元素，谁把这个元素取走，谁就获取这把锁，把元素放回去，就是释放了锁。元素在放回chan之前，不会有goroutine能从chan中取出元素的，这就保证了互斥性；</p><p>利用select+chan的方式，很容易实现TryLock，Timeout的功能。具体来说就是，在select语句中，我们可以使用default实现TryLock，使用一个Timer来实现Timeout的功能；</p><h3 id="4-1-channel语法"><a href="#4-1-channel语法" class="headerlink" title="4.1 channel语法"></a>4.1 channel语法</h3><p>channel可以在多个goroutine之间安全的传值；</p><p>通道可以用作变量、函数参数、结构体字段。。。</p><p>创建通道用make函数，并指定其传递数据的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>Channel类型分为 只能接收，只能发送，既可以接收又可以发送三种类型；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelType=(<span class="string">"chan"</span> | <span class="string">"chan"</span> <span class="string">"&lt;-"</span> | <span class="string">"&lt;-"</span> <span class="string">"chan"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> <span class="keyword">string</span>     <span class="comment">// 可以发送接收string</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 只能发送struct&#123;&#125;</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>       <span class="comment">// 只能从chan接收int</span></span><br></pre></td></tr></table></figure><p>channel是一个对应make创建的底层数据结构的引用；</p><p>当复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和 其它的引用类型一样，channel的零值也是nil</p><p>定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的make函数来创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type 指定channel收发数据的类型；</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type) <span class="comment">// 等价于 make(chan Type, 0) 容量为0 称为 unbuffered chan</span></span><br><span class="line"><span class="comment">// capacity 容量 </span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity)   <span class="comment">// 称为 buffered chan</span></span><br></pre></td></tr></table></figure><p>当参数 capacity=0 时，channel是无缓冲阻塞读写的，当capacity&gt;0 时，channel有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入；</p><p>channel一边可以存东西，另一边可以取东西。channel通过 &lt;- 来接收和发送数据，发送和接收数据语法；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel &lt;- value <span class="comment">// 发送value到channel</span></span><br><span class="line">&lt;- channel       <span class="comment">// 接收并将其丢弃</span></span><br><span class="line">x := &lt;-channel   <span class="comment">// 从channel中接收数据，并赋值给x</span></span><br><span class="line">x, ok:= &lt;-channel <span class="comment">// 功能同上，同时检查通道是否已经关闭或者是否为空</span></span><br></pre></td></tr></table></figure><p>nil是 chan的零值，是一种特殊的chan，对值是nil的chan的发送接收调用者总是会阻塞；</p><p>go内建的函数 close，cap，len都可以操作chan类型： close会把chan关闭掉，cap返回chan的容量，len返回chan中缓存的还未被取走的元素数量；</p><p><code>for range ch{}</code> 用于清空chan</p><h3 id="4-2-channel实现原理"><a href="#4-2-channel实现原理" class="headerlink" title="4.2 channel实现原理"></a>4.2 channel实现原理</h3><h4 id="4-2-1-channel的数据结构"><a href="#4-2-1-channel的数据结构" class="headerlink" title="4.2.1 channel的数据结构"></a>4.2.1 channel的数据结构</h4><p><img src="chan1.jpg" alt=""></p><ul><li>qcount ：代表chan中已经接收但还没被取走的元素的个数，内建函数len可以返回这个字段的值；</li><li>dataqsiz： 队列的大小，chan使用一个循环队列存放元素，循环队列很适合这种生产者 - 消费者的场景；</li><li>buf： 存放元素的循环队列的buffer</li><li>elemtype 和elemsize： chan中元素的类型和size，因为chan一旦声明，它的元素类型是固定的，即普通类型或者指针类型，所以元素大小也是固定的；</li><li>sendx： 处理发送数据的指针在buf中的位置，一旦接收了新的数据，指针就会加上elemsize，移向了下一个位置。buf的总大小是elemsize的整数倍，而且buf是一个循环列表</li><li>recvx： 处理接收请求时的指针在buf中的位置，一旦取出数据，此指针会移动到下一个位置</li><li>recvq： chan是多生产者多消费者的模式，如果消费者因为没有数据可读而被阻塞了，就会被加入到recvq队列中；</li><li>sendq：如果生产者因为buf满了而阻塞，会被加入到sendq队列中； </li></ul><h3 id="4-2-groutine-通信"><a href="#4-2-groutine-通信" class="headerlink" title="4.2 groutine 通信"></a>4.2 groutine 通信</h3><p>每当一个进程启动时，系统会自动打开三个文件，标准输入·标准输出·标准错误 —— 对应三个文件：stdin、 stdout、 stderr</p><p>stdin对应的硬件 ——硬盘</p><p>stdout对应的硬件—— 屏幕</p><p>stderr对应的硬件——屏幕</p><p>当进程圆形结束，操作系统会自动关闭三个文件；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, ch)</span><br><span class="line">time.Sleep(<span class="number">300</span>* time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define tow people use printer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">printer(<span class="string">"person1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span>&#123;</span><br><span class="line">printer(<span class="string">"person2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">go</span> person1()</span><br><span class="line"><span class="keyword">go</span> person2()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ppeerrssoonn21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  channel&lt;<span class="number">-891</span></span><br><span class="line">printer(<span class="string">"person1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span>&#123;</span><br><span class="line">printer(<span class="string">"person2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">go</span> person1()</span><br><span class="line"><span class="keyword">go</span> person2()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// person2</span></span><br><span class="line">  <span class="comment">// 因为channel不设置容量是 无缓冲阻塞读写的；所以go程person1的printer方法没发输出数据了；只能是go程序2 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>channel有两个端：</strong></p><p>一端：    写端（传入端） chan &lt;- </p><p>另一端： 读端（传出端）&lt;- chan</p><p>要求： 读端和写端必须同时满足条件，才能在chan上进行数据流动。否则，则阻塞；</p><p>（读端去读了，chan没有，就是读端阻塞。写端写了，但是chan没有读，就是写端阻塞。总之就是谁操作了，阻塞谁。）</p><h3 id="4-3-无缓冲的channel"><a href="#4-3-无缓冲的channel" class="headerlink" title="4.3 无缓冲的channel"></a>4.3 无缓冲的channel</h3><p>无缓冲的channel(unbuffered channel)是指在接收前没有能力保存任何值的通道；</p><p>这种类型的通道要求发送goroutine 和接收 goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的goroutinue阻塞。</p><p>这种对通道进行发送和接收的交互行为本身就是同步的，其中任意一个操作都无法离开另一个操作单独存在。</p><p><strong>阻塞</strong>：由于某种原因数据没有到达，当前协程持续处于等待状态，直到条件满足，才解除阻塞。</p><p><strong>同步</strong>： 在两个或多个协程（线程）间，保持数据内容一致性的机制；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写端</span></span><br><span class="line">ch &lt;- <span class="string">"he"</span> <span class="comment">// 写端写数据，读端不在读，阻塞</span></span><br><span class="line"><span class="comment">// 读端</span></span><br><span class="line">str:=&lt;-ch  <span class="comment">// 读端读数据，同时写端不在写，读端阻塞</span></span><br></pre></td></tr></table></figure><h4 id="4-3-1-channel同步，数据传递"><a href="#4-3-1-channel同步，数据传递" class="headerlink" title="4.3.1 channel同步，数据传递"></a>4.3.1 channel同步，数据传递</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"i="</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">channel &lt;- <span class="string">"123"</span></span><br><span class="line">&#125;()</span><br><span class="line">str := &lt;-channel <span class="comment">// 阻塞写，上面的go程才有机会执行；</span></span><br><span class="line">fmt.Println(str) </span><br><span class="line">  </span><br><span class="line"><span class="comment">//  i= 0</span></span><br><span class="line"><span class="comment">//  i= 1</span></span><br><span class="line"><span class="comment">//  123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="channel.png" alt="image-20210325154035381"></p><p>第1步，两个goroutine都到达通道，但哪个都没有开始执行发送或接收</p><p>第2步，左侧的goroutine将它的手伸进了通道，这模拟了向通道发送数据的行为，这时，这个goroutine会在通道中被锁住，直到交换完成；</p><p>第3步，右侧的goroutine将它的手放入通道，这模拟了从通道里接收数据，这个goroutine一样也会在通道中被锁住，直到交换完成</p><p>在第4步和第5步，进行交换，并最终，在第6步，两个goroutine都将它们的手从通道里面拿出来，这模拟了被锁住的goroutine得到释放，两个goroutine现在都可以去做其他事情了；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"子go程 i="</span>, i)</span><br><span class="line">ch &lt;- i <span class="comment">// // 1.当程序一个值往ch中写入时，由于channel中读的goroutine未就位，当前goroutine阻塞，下一个goroutine得以执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">num := &lt;-ch <span class="comment">// // 2. 当执行到这里，读gorutine就位；上面的`ch&lt;-i` gorouine立即被唤醒并继续执行。执行之后，读gorouine也脱离channel，开始往下继续执行；</span></span><br><span class="line">fmt.Println(<span class="string">"主go程读"</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">0</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">1</span> <span class="comment">// 这里为什么不是 主go程读 0</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">0</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">1</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">2</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">3</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">2</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">3</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">4</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">4</span></span><br></pre></td></tr></table></figure><p> *<em>为什么第二行不是 “子go程 i= 1” *</em></p><p>因为<code>fmt.Println(&quot;主go程读&quot;, num)</code>是IO操作，耗时（访问硬件）可能需要等待；</p><p>channel应用与 两个goroutine中，一个读，一个写；</p><p>具备同步的能力，读、写同步</p><p><strong>有缓冲channel</strong></p><h4 id="4-3-2-channel的len和cap"><a href="#4-3-2-channel的len和cap" class="headerlink" title="4.3.2 channel的len和cap"></a>4.3.2 channel的len和cap</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">len</span>(channel) <span class="comment">// 0 channel中剩余未读取数据个数</span></span><br><span class="line"><span class="built_in">cap</span>(channel) <span class="comment">// 0 channel的容量</span></span><br></pre></td></tr></table></figure><p><strong>有缓冲channel</strong></p><p>通道容量为非0， len(ch): channel中剩余未读取数据个数。cap(ch): 通道容量</p><p>channel应用于两个go程中，一个读，另一个写</p><p>缓冲区可以进行数据存储，存储至容量上限，阻塞，具备异步能力，不需要同时操作channel缓冲区（发短信）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">// 存满3个元素之前不会阻塞</span></span><br><span class="line">fmt.Println(<span class="string">"len="</span>, <span class="built_in">len</span>(ch), <span class="string">"cap="</span>, <span class="built_in">cap</span>(ch))</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">fmt.Println(<span class="string">"子go程 i="</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// time.Sleep(300 * time.Millisecond)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">num := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">"主go程读"</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>= <span class="number">0</span> <span class="built_in">cap</span>= <span class="number">2</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">0</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">1</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">2</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">0</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">1</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">2</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">3</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">3</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">4</span></span><br><span class="line">子<span class="keyword">go</span>程 i= <span class="number">5</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">4</span></span><br><span class="line">主<span class="keyword">go</span>程读 <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="4-4-关闭channel"><a href="#4-4-关闭channel" class="headerlink" title="4.4 关闭channel"></a>4.4 关闭channel</h3><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现；</p><p>确定不再向对端发送接收数据时，使用close关闭channel</p><p>对端可以判断channel是否关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> num, ok:= &lt;-ch; ok == <span class="literal">true</span> &#123;</span><br><span class="line">  <span class="comment">// 如果对端已经关闭， ok--&gt;false, num无数据</span></span><br><span class="line">  <span class="comment">// 如果对端没有关闭，ok--&gt; true，num保存读到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 不再需要指定循环次数</span></span><br><span class="line"><span class="keyword">if</span> num, ok := &lt;-ch; ok == <span class="literal">true</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"读取数据"</span>, num)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">读取数据 <span class="number">0</span></span><br><span class="line">读取数据 <span class="number">1</span></span><br><span class="line">读取数据 <span class="number">2</span></span><br><span class="line">读取数据 <span class="number">3</span></span><br><span class="line">读取数据 <span class="number">4</span></span><br></pre></td></tr></table></figure><p>总结</p><p>1:数据没发送完，不应该关闭。</p><p>2 已经关闭的channel，不能再写入数据</p><p>3 写端已经关闭的channel，可以从中读取数据，</p><p>​            读无缓冲channel 读到0， —— 说明写端关闭</p><p>​            读有缓冲channel，如果缓冲区有数据，先读数据。读完数据可以无限读，读到0</p><h3 id="4-5-单向channel"><a href="#4-5-单向channel" class="headerlink" title="4.5 单向channel"></a>4.5 单向channel</h3><p>默认的channel是双向的， var ch chan int            ch:=make(chan int)</p><p>单向写channel：    var sendCh chan &lt;- int           sendCh = make(chan &lt;- int)</p><p>单向读channel：    var recvCh &lt;- chan int            recvCh = make(&lt;- chan int)</p><p>转换：</p><ol><li>双向channel 可以隐士转换为任意一种单向channel</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendCh = ch</span><br></pre></td></tr></table></figure><ol start="2"><li>单向channel不能转换为双向channel</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = sendCH/recvCh <span class="comment">// error!!!</span></span><br></pre></td></tr></table></figure><p>传参：传【引用】</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> sendCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = ch <span class="comment">// 双向channel赋值给写channel</span></span><br><span class="line">sendCh &lt;- <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recvCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = ch <span class="comment">// 双向channel赋值给读channel</span></span><br><span class="line">num := &lt;-recvCh</span><br><span class="line">fmt.Println(<span class="string">"num"</span>, num)</span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">int</span> = sendCh <span class="comment">//compiler error 单向channel无法赋值给双向channel</span></span><br></pre></td></tr></table></figure><p>单向channel的好处，约束子函数行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">out &lt;- <span class="number">123</span> <span class="comment">// 只能往channel写，无法做读取操作</span></span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(into &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">n := &lt;-into <span class="comment">// 只能从channel读，无法做写入操作</span></span><br><span class="line">fmt.Println(<span class="string">"into="</span>, n) <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">send(ch)</span><br><span class="line">&#125;()</span><br><span class="line">recv(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-生产者消费者模型"><a href="#4-6-生产者消费者模型" class="headerlink" title="4.6 生产者消费者模型"></a>4.6 生产者消费者模型</h3><p>单向channel最典型的应用是“生产者消费者模型”</p><p>所谓“生产者消费者模型”： 某个模块（函数等）负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、协程、线程、进程等）产生数据的模块，就形象地成为生产者，而处理数据的模块，就称为消费者。</p><p>单单抽象出生产者和消费者，还够不上是生产者/消费者模型。改模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者——》缓冲区——》消费者</span><br></pre></td></tr></table></figure><p>举例，假如需要寄出一封信，大致流程如下：</p><ol><li>把信写好——相当于生产者制造数据</li><li>把信放入油桶——相当于生产者把数据放入缓冲区</li><li>邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区</li></ol><p>生产者：发送数据端</p><p>消费者：接收数据端</p><p><strong>缓冲区的好处</strong></p><ol><li>解耦（降低生产者和消费者之间耦合度）</li><li>生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据了；（生产者和消费者数量不对等时，能保持正常通信）基本不需要依赖消费者的处理速度；</li><li>缓存，生产者和消费者处理数据速度不一致时，暂存数据（如果生产者制造数据时快时慢，缓冲区的好处就提体现出来了。当数据制造快消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉）</li></ol><p><img src="buffer.png" alt="image-20210325223551771"></p><p>Channel 实现缓冲区</p><p>有缓冲channel和无缓冲channel都能实现缓冲区</p><p>有缓冲channel 异步通信 用于对实时不敏感的需求；</p><p>无缓冲channel 同步通信，用于实时需求；</p><h3 id="4-7-channel作为参数传递，是引用传递"><a href="#4-7-channel作为参数传递，是引用传递" class="headerlink" title="4.7 channel作为参数传递，是引用传递"></a>4.7 channel作为参数传递，是引用传递</h3><h3 id="4-8-模拟订单"><a href="#4-8-模拟订单" class="headerlink" title="4.8 模拟订单"></a>4.8 模拟订单</h3><p>订单处理就是典型的生产消费模式</p><p>当很多用户单击下订单按钮后，订单生产的数据全部放到缓冲区，然后消费者将队列中的数据取出来发送到管理系统</p><p>通过生产者消费模式，将订单系统与仓库管理系统隔离开，且用户可以随时下单。如果订单系统直接调用仓库系统，那么用户单击下订单按钮后，要等到仓库系统的结果返回，这样速度会很慢；</p><h3 id="4-9-定时器"><a href="#4-9-定时器" class="headerlink" title="4.9 定时器"></a>4.9 定时器</h3><p>time.Timer</p><p>Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">C &lt;- <span class="keyword">chan</span> Time</span><br><span class="line">  r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统自动向timer.C这个channel中写入当前时间，阻塞即被解除；</p><h3 id="2-1-channel（通道）发送、接收"><a href="#2-1-channel（通道）发送、接收" class="headerlink" title="2.1 channel（通道）发送、接收"></a>2.1 channel（通道）发送、接收</h3><p>使用左箭头操作符 <code>&lt;-</code> 向channel发送值或从channel接收值；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- <span class="number">99</span> <span class="comment">// 向通道发送值， 把值为 99 的值 发送给通道c</span></span><br><span class="line">r:= &lt;- c <span class="comment">// 从通道接收值  从通道c接收一个值，并将此值赋给 r变量</span></span><br></pre></td></tr></table></figure><p>发送操作会等待直到另一个goroutine尝试对该channel进行接收操作为止；</p><ul><li>执行发送操作的goroutine在等待期间将无法执行其它操作</li><li>未在等待channel操作的goroutine仍然可以继续自由的运行</li></ul><p>执行接收操作的goroutine将等待直到另一个goroutine尝试向该channel进行发送操作为止；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 一共有5个 </span></span><br><span class="line">    <span class="comment">//gopher会往此通道发送值；</span></span><br><span class="line">gopherID := &lt;-c <span class="comment">// 当i=0时，等待大约3s之后，有其它gopher给它发送值了。</span></span><br><span class="line"><span class="comment">// 可能是 0 1 2 3 4 任意一个值，因为goroutine的顺序无法确定</span></span><br><span class="line">fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"..."</span>, id, <span class="string">"snore ..."</span>)</span><br><span class="line">c &lt;- id <span class="comment">// 向通道发送值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用select处理多个通道"><a href="#2-2-使用select处理多个通道" class="headerlink" title="2.2 使用select处理多个通道"></a>2.2 使用select处理多个通道</h3><p>前面的例子中是使用一个channel来等待多个 goroutine，这种做法在所有goroutine都产生相同类型值的时候是好用的。但实际开发中，情况并不只是如此；程序通常需要等待不同类型的值；</p><p>当等待通道中某些值的时候，不想等太久。或者想在网络请求等待数秒之后就将其设置为超时而不是白白等待好几分钟。go标准库提供了一个time.After函数，该函数返回一个channel，该channel在指定时间后会接收到一个值（这个值是由go运行时的一个goroutine发送的 ）；</p><p>如果程序想继续从goroutine接收值，那必须等到所有goroutine都结束睡眠或我们耐心耗尽为止。这意味着程序必须同时等到time.After这个计时器channel 和其它channel。这个时候就能使用select语句。select语句能做到这一点。</p><p>select语句与switch有点像</p><ul><li>该语句包含的每个case都持有一个通道，用来发送或接收数据；</li><li>select会等待直到某个case分支的操作就绪，然后就会执行该case 分支；</li><li>select语句不包含任何case的情况下将永远等下去</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">&#125;</span><br><span class="line">timeout := time.After(<span class="number">2</span> * time.Second) </span><br><span class="line">  <span class="comment">// 创建一个超时时间2s 的 channel</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> gopherID := &lt;-c: <span class="comment">// 从通道接收值</span></span><br><span class="line">fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout: <span class="comment">//等2s 超时 还未接收到</span></span><br><span class="line">fmt.Println(<span class="string">"my patience ran out"</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="comment">// return 会跳出select</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">4000</span>)) * time.Millisecond) <span class="comment">// 生成一个0-4s的随机时间</span></span><br><span class="line">c &lt;- id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 即使已经停止等待goroutine，但只要main函数还没返回，仍在运行的goroutine将会继续占用内存；（有条件，尽量清理掉）</p><h3 id="2-3-nil通道"><a href="#2-3-nil通道" class="headerlink" title="2.3 nil通道"></a>2.3 nil通道</h3><blockquote><p>值为nil的通道</p></blockquote><p>如果不使用make初始化channel，那么channel变量的值就是nil(零值)</p><p>对nil通道进行发送或接收不会引起panic，但会导致永久阻塞；</p><p>对nil通道执行close函数，那么会引起panic</p><h4 id="2-3-1-nil通道的用处："><a href="#2-3-1-nil通道的用处：" class="headerlink" title="2.3.1 nil通道的用处："></a>2.3.1 nil通道的用处：</h4><p>对于包含select语句的循环，如果不希望每次循环都等待select所涉及的所有通道，那么可以先将某些channel设置为nil，等到发送值准备就绪之后，再将channel变成一个非nil值并执行发送操作；</p><h2 id="3-阻塞和死锁"><a href="#3-阻塞和死锁" class="headerlink" title="3 阻塞和死锁"></a>3 阻塞和死锁</h2><p>当goroutine在等待channel的发送或接收时，我们就说它被阻塞了；</p><p>除了goroutine本身占用少量的内存外，被阻塞的goroutine并不消耗任何其它资源；</p><ul><li>goroutine静静地停在那里，等到导致其阻塞的事情来解除阻塞</li></ul><p>当一个或多个goroutine因为某些永远无法发生的事情被阻塞时，我们称这种情况为死锁，而出现死锁的程序通常会崩溃或挂起；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引发死锁的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"><span class="comment">// goroutine 1 [chan receive]:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用goroutine 解决死锁问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="number">2</span> &#125;()</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-地鼠装配线"><a href="#3-1-地鼠装配线" class="headerlink" title="3.1 地鼠装配线"></a>3.1 地鼠装配线</h3><p>Go允许在没有值可供发送的情况下通过close函数关闭通道</p><ul><li>例如close(c)</li></ul><p>通道被关闭后无法写入任何值，如果尝试写入将引发panic</p><p>尝试读取被关闭的通道会获得与通道类型对应的零值；</p><p>注意： 如果循环里读取一个已关闭的通道，并没有检查通道是否关闭，那么该循环可能会一直运转下去，耗费大量CPU时间</p><p>执行以下代码可得知通道是否被关闭</p><p><code>v,ok := &lt;-c</code> v为通道得到的值，ok bool类型，如果ok为false，那么说明此通道已关闭；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">downstream &lt;- v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// downstream &lt;- ""</span></span><br><span class="line"><span class="comment">// 重构为</span></span><br><span class="line"><span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">item, ok := &lt;-upstream</span><br><span class="line"><span class="comment">// if item == "" &#123; 重构</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">//downstream &lt;- ""</span></span><br><span class="line"><span class="built_in">close</span>(downstream)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">downstream &lt;- item</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v := &lt;-upstream</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line"><span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">printGopher(c1)</span><br><span class="line"><span class="comment">// hello, world</span></span><br><span class="line"><span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-常用模式"><a href="#3-2-常用模式" class="headerlink" title="3.2 常用模式"></a>3.2 常用模式</h3><p>从通道读取值，直到它关闭为止（常用）</p><ul><li>可以使用range关键字达到该目的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">downstream &lt;- v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// downstream &lt;- ""</span></span><br><span class="line"><span class="comment">// 重构为</span></span><br><span class="line"><span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> upstream &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">downstream &lt;- item</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(downstream) <span class="comment">// 关闭下游通道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> upstream &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line"><span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">printGopher(c1)</span><br><span class="line"><span class="comment">// hello, world</span></span><br><span class="line"><span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>homework</p><ol><li>编写一个流水线部件（一个goroutine），他需要记住前面出现的所有值，并且只有在值之前从未出现过的情况下才会将值传递至流水线的下一个阶段，假定第一个值永远不是空字符串</li><li>编写一个流水线部件，它接收字符串并将它们拆分成单词，然后向流水线的下一阶段一个接一个发送这些单词（可以用strings.Fields函数）</li></ol><h2 id="4-并发状态"><a href="#4-并发状态" class="headerlink" title="4 并发状态"></a>4 并发状态</h2><h3 id="4-1-共享值与竞争条件（race-condition）"><a href="#4-1-共享值与竞争条件（race-condition）" class="headerlink" title="4.1 共享值与竞争条件（race condition）"></a>4.1 共享值与竞争条件（race condition）</h3><p>工厂某些生产线出现库存不足的情况，它们需要订购更多的原材料。尽管每条生产线都有固定电话，但是工厂只有一条共享的电话路线。当一个工人拿起电话下订单的时候，另一只地鼠可能会拿起电话拨号。对正在讲话的前一个工人产生干扰，而之后可能还会有其它的工人尝试使用电话。最终就是所有工人一头雾水，订单也无法下达。</p><p>为了解决这个问题，工厂工人必须达成某些协议。使得同一时间之内只有一只地鼠使用电话。而go语言里共享值的概念就跟共享电话有些相似。</p><p>当有两个或者多个goroutine同时使用共享值的时候，程序可能出错。把这种多个goroutine争相使用值的情况称之为竞争条件或者竞争状态（race condition）而go的compiler实际上包含了尝试在代码里发现静态条件这个功能。</p><p>两个goroutine同时读取，并不会产生 race condition。</p><h3 id="4-2-Go的互斥锁-mutex"><a href="#4-2-Go的互斥锁-mutex" class="headerlink" title="4.2 Go的互斥锁(mutex)"></a>4.2 Go的互斥锁(mutex)</h3><p>Mutex= mutual exclusive</p><p>​                相互的  独占的</p><p>一个工厂想出一个很好的主意，在工厂地板中间放置一个玻璃罐，并在玻璃罐中放置了一个金属令牌。每次想要打电话的地鼠都需要从罐子里面取出令牌。然后在打电话的过程中一直持有它。然后打完电话再把它放回到罐子里面。如果有一只地鼠想打电话，但是没有在罐子里面发现令牌。就需要轮训等待直到令牌归还为止。go语言的互斥锁就相当于此玻璃罐。goroutine就可以通过互斥锁阻止其它的goroutine在同一时间进行某些事情。为了保护互斥锁的互斥性质，程序在访问被保护的东西的时候必须得非常的小心。互斥锁有两个方法 <code>Lock</code> 和 <code>Unlock</code>, Lock相当于从金属罐里面取出令牌，Unlock相当于把令牌放回玻璃罐；</p><p>如果有goroutine尝试在互斥锁已经锁定的情况下，再调用lock方法，那么它就需要等待解锁之后再次上锁。为了正确使用互斥锁，就要确保锁访问共享值的代码必须先锁定互斥锁，然后才能执行所需的操作。并且在操作完成之后必须解除互斥锁，任何不遵循这一模式的代码都可能引发竞争条件。基于此原因，互斥锁在绝大多数情况下，只会在包内进行使用；这个包会通过互斥锁保护自定义的内容，并将相应的lock和unlock调用，巧妙的隐藏在函数和方法的背后。和channel不一样，互斥锁并未内置在go语言中。而是通过sync包来引入的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="comment">// the lock is held until we return from the function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁定义在被保护的变量之上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line">1. 当两个goroutine同时修改一个值的时候，会发生什么</span><br><span class="line">2. 尝试对一个已经被锁定的互斥锁进行锁定操作，会发生什么</span><br><span class="line">3. 尝试多一个未被锁定的互斥锁进行解锁操作，会发生什么</span><br><span class="line">4. 同时在多个不同的goroutine里面调用相同类型的方法是安全的吗</span><br></pre></td></tr></table></figure><h3 id="4-2-互斥锁的实现机制"><a href="#4-2-互斥锁的实现机制" class="headerlink" title="4.2 互斥锁的实现机制"></a>4.2 互斥锁的实现机制</h3><p>互斥锁是并发控制的一个基本手段；是为了避免竞争二建立的一种并发控制机制；</p><p>临界区：</p><p>​    临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作，对一个IO设备的使用；对一个连接池中的连接的调用；</p><p>使用互斥锁，限定临界区只能同时由一个线程持有；互斥锁又名排他锁</p><p>Mutex是使用最广泛的同步原语，有人也叫做并发原语；</p><h4 id="4-2-1-同步并发原语"><a href="#4-2-1-同步并发原语" class="headerlink" title="4.2.1 同步并发原语"></a>4.2.1 同步并发原语</h4><blockquote><p>mutex是使用最广泛的同步原语；</p></blockquote><ul><li>同步原语</li></ul><p>互斥锁Mutex</p><p>读写锁RWMutex</p><p>并发编排WaitGroup</p><p>条件变量Cond</p><p>Channel</p><ul><li>同步原语适应的场景</li></ul><p>共享资源：</p><p>​    并发读写共享资源，会引发数据竞争，所以需要Mutex，RWMutex这样的并发原语来保护</p><p>任务编排：</p><p>​    需要goroutine按照一定的规律执行，而goroutine之间有相互等待或者依赖的顺序关系，常常使用WaitGroup或Channel来实现；</p><p>消息传递：</p><p>​    信息交流以及不同的goroutine之间的线程安全的数据交流，常常使用channel；</p><h4 id="4-2-2-Locker-接口"><a href="#4-2-2-Locker-接口" class="headerlink" title="4.2.2 Locker 接口"></a>4.2.2 Locker 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">Lock()</span><br><span class="line">Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutex 和 RWMutex都实现了Locker接口；</p><h4 id="4-2-3-sync-Mutex"><a href="#4-2-3-sync-Mutex" class="headerlink" title="4.2.3 sync.Mutex"></a>4.2.3 sync.Mutex</h4><blockquote><p>控制等待一组goroutine全部做完任务；</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex <span class="comment">// mutex的零值是还没有goroutine等待的未加锁的状态，不需要额外初始化；</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 对变量count执行10次加1</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span> ;j&lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">mutex.Lock()</span><br><span class="line">count++</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待10个goroutine完成</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面如果不加 mutex.Lock，我们发现最终结果得不到100000， 说明count++ 不是个原子操作；因为操作不原子，所以就可能有并发问题；</p><h4 id="4-2-4-go-race-detector"><a href="#4-2-4-go-race-detector" class="headerlink" title="4.2.4 go race detector"></a>4.2.4 go race detector</h4><p><code>go run -race atomic.go</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read at 0x00c0000bc008 by goroutine 8:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:20 +0x78</span><br><span class="line"></span><br><span class="line">Previous write at 0x00c0000bc008 by goroutine 7:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:20 +0x91</span><br><span class="line"></span><br><span class="line">Goroutine 8 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:15 +0xe4</span><br><span class="line"></span><br><span class="line">Goroutine 7 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:15 +0xe4</span><br><span class="line">==================</span><br><span class="line">365768</span><br><span class="line">Found 1 data race(s)</span><br><span class="line"><span class="built_in">exit</span> status 66</span><br></pre></td></tr></table></figure><h4 id="4-2-5-mutex的用法"><a href="#4-2-5-mutex的用法" class="headerlink" title="4.2.5 mutex的用法"></a>4.2.5 mutex的用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很多情况，mutex会嵌入到其他struct中使用；mutex不会因为没有初始化出现空指针或者是无法获取到锁的情况；</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">Count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把获取锁，释放锁，计数加一的逻辑封装程一个方法，对外不需要暴露锁等逻辑</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> count Counter</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 对变量count执行10次加1</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span> ;j&lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">count.Incr()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待10个goroutine完成</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(count.Count())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">CounterType <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span> <span class="params">()</span></span>&#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">c.count++</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span>&#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-互斥锁的隐患和易错点"><a href="#4-3-互斥锁的隐患和易错点" class="headerlink" title="4.3 互斥锁的隐患和易错点"></a>4.3 互斥锁的隐患和易错点</h3><h4 id="4-3-1-死锁"><a href="#4-3-1-死锁" class="headerlink" title="4.3.1  死锁"></a>4.3.1  死锁</h4><blockquote><p>两个或者两个以上的进程（线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或者系统产生了死锁；</p></blockquote><p>如果你想避免死锁，只要破坏这四个条件中的一个或者几个就可以了</p><ol><li>互斥；</li><li>持有和等待   goroutine持有一个资源，并且还在请求其他goroutine持有的资源；</li><li>不可剥夺  资源只能有持有它的goroutine来释放；</li><li>环路等待 存在一组等待的进程，p={p1,p2,…pn},p1等待p2, p2等待 pn, pn等待 p1，这就形成了一个环路等待的死结； </li></ol><p>环路等待； 物业需要派出所证明，派出所需要物业证明。结果就陷入死锁状态。派出所和物业是两个goroutine，派出所证明和物业证明是两个资源，双方都持有自己的资源而要求对方的资源；而且自己的资源自己持有，不可剥夺；</p><p>所以为了保证这个互斥锁的使用安全，遵守以下两个原则</p><ol><li>尽可能的简化互斥锁保护的代码</li><li>对每一份共享状态只使用一个互斥锁</li></ol><h4 id="4-3-2-Lock-Unlock不成对出现"><a href="#4-3-2-Lock-Unlock不成对出现" class="headerlink" title="4.3.2 Lock/Unlock不成对出现"></a>4.3.2 Lock/Unlock不成对出现</h4><h4 id="4-3-3-Copy已使用的Mutex"><a href="#4-3-3-Copy已使用的Mutex" class="headerlink" title="4.3.3 Copy已使用的Mutex"></a>4.3.3 Copy已使用的Mutex</h4><p>package sync的同步原语在使用后是不能复制的，Mutex是最常用的一个同步原语，它也是不能复制的；原因在于Mutex是一个有状态的对象，它的state字段记录这个锁的状态； </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line">  Count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c Counter</span><br><span class="line">  c.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">  c.Count++</span><br><span class="line">  foo(c) <span class="comment">// 复制锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c Counter)</span></span>&#123;</span><br><span class="line">  c.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">  fmt.Println(<span class="string">"in foo"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-重入"><a href="#4-3-4-重入" class="headerlink" title="4.3.4 重入"></a>4.3.4 重入</h4><p>可重入锁：</p><p>​    当一线程获取锁时，如果没有其他线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其他线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时也叫做递归锁）。只要你拥有这把锁，你可以一直调用，比如通过递归实现一些算法，调用者不会阻塞或死锁</p><p><strong>mutex不是可重入锁</strong></p><p>因为mutex的实现中没有记录哪个goroutine拥有这把锁，理论上，任何goroutine都可以随意地Unlock这把锁，所以没办法计算重入条件；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(l sync.Locker)</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"in foo"</span>)</span><br><span class="line">  l.Lock()</span><br><span class="line">  bar(l)</span><br><span class="line">  l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(l sync.Locker)</span></span>&#123;</span><br><span class="line">  l.Lock()</span><br><span class="line">  fmt.Println(<span class="string">"in bar"</span>)</span><br><span class="line">  l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  l:=&amp;sync.Mutex&#123;&#125;</span><br><span class="line">  foo(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现一个可重入锁，实现锁的关键点要记住当前是哪个goroutine持有这个锁；</p><h3 id="4-4-WaitGroup"><a href="#4-4-WaitGroup" class="headerlink" title="4.4 WaitGroup"></a>4.4 WaitGroup</h3><blockquote><p>WaitGroup很简单，就是package sync用来做任务编排的一个并发原语，它要解决的就是并发-等待的问题；现在有一个goroutine A在检查点（checkpoint）等待一组goroutine全部完成，如果在执行任务的这些goroutine还没全部完成，那么goroutine A就会阻塞在检查点，直到所有goroutine都完成后才能继续执行；</p><p>很多操作系统和编程语言都提供了类型的并发原语，比如Linux的barrier，Pthread(POSIX线程)中的barrier;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span> // 设置计数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span> // 将计数减1，其实就是<span class="title">Add</span><span class="params">(-1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span> // 调用这个方法的<span class="title">goroutine</span>会一直阻塞，直到<span class="title">WaitGroup</span>计数值为0；</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span>&#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">c.count++</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span>&#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c *Counter, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// 计数减1， 当有一个goroutine完成了就减1</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">c.Incr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> counter Counter</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">10</span>) <span class="comment">// 设置计数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line"><span class="keyword">go</span> worker(&amp;counter, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 阻塞 main goroutine 等待waitGroup计数归0</span></span><br><span class="line">fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-Cond"><a href="#4-5-Cond" class="headerlink" title="4.5 Cond"></a>4.5 Cond</h3><blockquote><p>go标准库提供Cond的原语的目的是，为等待/通知场景下的并发问题提供支持，Cond通常应用于等待某个条件的一组goroutine，等条件变为true的时候，其中一个goroutine或者所有的goroutine都会呗唤醒执行；</p></blockquote><p>真正使用Cond的场景比较少，一旦遇到需要使用Cond的场景，更多地会使用Channel的方式去实现；</p><ul><li>Cond的基本用法</li></ul><p>Cond关联的Locker实例可以通过c.L访问，它内部维护着一个先入先出的等待队列；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // 会把调用者<span class="title">Caller</span> 放入<span class="title">Cond</span>的等待队列中并阻塞，直到<span class="title">Signal</span>或者广播方法从等待队列中移除并唤醒；</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">c:= sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>))*time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁更改等待条件</span></span><br><span class="line">c.L.Lock()</span><br><span class="line">ready++</span><br><span class="line">c.L.Unlock()</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"player #%d is ready\n"</span>, i)</span><br><span class="line"><span class="comment">//broadcast</span></span><br><span class="line"></span><br><span class="line">c.Broadcast()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> ready != <span class="number">10</span>&#123;</span><br><span class="line">c.Wait() <span class="comment">// 把调用者放入cond队列中并阻塞，等待被唤醒；</span></span><br><span class="line">log.Println(<span class="string">"裁判员被唤醒一次"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有运动员是否准备就绪</span></span><br><span class="line">log.Println(<span class="string">"所有运动员都准备就绪，game start,3,2,1..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-once"><a href="#4-6-once" class="headerlink" title="4.6 once"></a>4.6 once</h3><blockquote><p>once可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure><p>sync.Once只暴露了一个方法Do，你可以多次调用Do方法，但是只有第一次调用Do方法时f参数才会执行，这里的f是一个无参无返回值的函数；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">f1:= <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"in f1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">once.Do(f1) <span class="comment">// 输出 in f1</span></span><br><span class="line"></span><br><span class="line">f2:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"in f2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">once.Do(f2) <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-context"><a href="#4-7-context" class="headerlink" title="4.7 context"></a>4.7 context</h3><blockquote><p>在API之间或者方法调用之间，所传递的除了业务参数之外的额外信息；</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span>&#123;</span><br><span class="line">  Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  Err() error</span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-atomic"><a href="#4-8-atomic" class="headerlink" title="4.8 atomic"></a>4.8 atomic</h3><blockquote><p>原子操作，一个原子在执行的时候，其他线程不会看到执行一半的操作结果；在其他线程看来，原子操作要么执行完了，要么还在执行；就像一个最小的例子-原子一样，不可分割;</p></blockquote><p>再来看一个例子，假设你在开发应用程序的时候，需要从配置服务器中读取一个节点的配置信息。而且，在这个节点的配置发生变更的时候，你需要重新从配置服务器中拉去一个份新的配置并更新。你的程序中可能有多个goroutine都依赖这份配置，涉及到对这个配置对象的并发读写，你可以使用读写锁实现对配置对象的保护，在大部分情况下，你也可以利用atomic实现配置对象的更新和加载；</p><p>atomic原子操作还是实现lock-free数据结构的基石</p><p>在实现lock-free的数据结构时，我们可以不使用互斥锁，这样就不会让线程因为等待互斥锁阻塞休眠，而是让线程保持继续处理的状态。另外，不使用互斥锁的话，lock-free的数据结构还可以提供并发的性能；</p><h4 id="4-8-1-atomic提供的方法"><a href="#4-8-1-atomic提供的方法" class="headerlink" title="4.8.1 atomic提供的方法"></a>4.8.1 atomic提供的方法</h4><blockquote><p>atomic操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法；</p></blockquote><ul><li>Add</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="keyword">uint32</span>, delta <span class="keyword">uint32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="comment">// Add方法就是给第一个参数地址中的值增加一个delta值；</span></span><br></pre></td></tr></table></figure><ul><li>CAS(compareAndSwap)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要操作的地址，原数据值，新值；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 这个方法会比较当前addr地址里面的值是不是old，如果不等于old，就返回false；如果等于old，就把此地址的值替换成new值，返回true，这就相当于“判断相等才替换”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *addr == old &#123;</span><br><span class="line">  *addr = <span class="built_in">new</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>Swap</li></ul><p>如果不需要比较旧值，只是比较粗暴地替换的话，就可以使用Swap方法，它替换后还可以返回旧值，伪代码如下；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old= *addr</span><br><span class="line">*addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> old</span><br></pre></td></tr></table></figure><ul><li>Load</li></ul><p>Load方法会取出addr地址中的值，即使在多处理器、多核、有cpu cache的情况下，这个操作也能保证Load是一个原子操作；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="keyword">int32</span>)</span><span class="params">(val <span class="keyword">int32</span>)</span></span></span><br></pre></td></tr></table></figure><ul><li>Store</li></ul><p>Store方法会把一个值存入到指定的addr地址中，即使在多处理器、多核、有cpu cache的情况下，这个操作也能保证Store是一个原子操作。别的goroutine通过Load读取出来，不会看到存取了一半的值；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func StoreInt32(addr *int32, val int32)</span><br></pre></td></tr></table></figure><h4 id="4-8-2-Value类型"><a href="#4-8-2-Value类型" class="headerlink" title="4.8.2 Value类型"></a>4.8.2 Value类型</h4><blockquote><p>Value类型，可以原子地存取对象类型，但也只能存取，不能CAS和Swap，常常用在配置变更等场景中</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(v *Value)</span> <span class="title">Load</span><span class="params">()</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(v *Value)</span> <span class="title">Store</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">NodeName <span class="keyword">string</span></span><br><span class="line">Addr     <span class="keyword">string</span></span><br><span class="line">Count    <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadNewConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Config&#123;</span><br><span class="line">NodeName: <span class="string">"beijing"</span>,</span><br><span class="line">Addr:     <span class="string">"10.13.12.88"</span>,</span><br><span class="line">Count:    rand.Int31(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> config atomic.Value</span><br><span class="line">config.Store(loadNewConfig())</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新config</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Duration(<span class="number">5</span>+rand.Int63n(<span class="number">5</span>)) * time.Second)</span><br><span class="line">config.Store(loadNewConfig())</span><br><span class="line">cond.Broadcast() <span class="comment">// 通知等待着配置已变更</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Wait()                 <span class="comment">// 阻塞等待变更信号</span></span><br><span class="line">c := config.Load().(Config) <span class="comment">// 读取新的配置</span></span><br><span class="line">fmt.Printf(<span class="string">"new config:%+v\n"</span>, c)</span><br><span class="line">cond.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-map"><a href="#4-9-map" class="headerlink" title="4.9 map"></a>4.9 map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[k]v</span><br></pre></td></tr></table></figure><p>key类型的k必须是可比较的（comparable），也就是可以通过 == 和 != 操作符进行比较： value的值和类型无所谓，可以是任意类型，或者是nil</p><p>go内建的 map对象不是线程（goroutine）安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      m[<span class="number">1</span>] = <span class="number">1</span> <span class="comment">// 设置key</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">      _ = m[<span class="number">2</span>] <span class="comment">// 访问这个map</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// panic</span></span><br></pre></td></tr></table></figure><h4 id="4-9-1-实现线程安全的map类型"><a href="#4-9-1-实现线程安全的map类型" class="headerlink" title="4.9.1 实现线程安全的map类型"></a>4.9.1 实现线程安全的map类型</h4><p>加读写锁；</p><h4 id="4-9-2-应对特殊场景的sync-Map"><a href="#4-9-2-应对特殊场景的sync-Map" class="headerlink" title="4.9.2 应对特殊场景的sync.Map"></a>4.9.2 应对特殊场景的sync.Map</h4><p>sync.Map是线程安全的；</p><p>在以下两个场景中使用sync.Map ，会比使用map.RWMutex的方式，性能要好得多；</p><ol><li>只会增长的缓存系统中，一个key只写入一次而被读很多次；</li><li>多个goroutine为不相交的键集读、写和重写键值对；</li></ol><p>sync.Map很少使用，我们可以把sync.Map看成一个生产环境中很少使用的同步原语；</p><h3 id="4-10-pool"><a href="#4-10-pool" class="headerlink" title="4.10 pool"></a>4.10 pool</h3><blockquote><p>如果你想使用go开发一个高性能的应用程序时，就必须考虑垃圾回收给性能带来的影响；毕竟Go的自动垃圾回收机制还是有一个STW（stop-the-world，程序暂停）的时间，而且，大量地创建在堆上的对象，也会影响垃圾回收标记的时间；</p></blockquote><p>所以，一般做性能优化的时候，会采用对象池的方法，把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必在堆上重新创建了；</p><p>像数据库连接，TCP长连接，这些连接在创建的时候是一个非常耗时的操作，如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上；</p><p>Go标准库提供了sync.Pool，使用它可以创建池化的对象；</p><h3 id="4-4-长时间运行的工作进程"><a href="#4-4-长时间运行的工作进程" class="headerlink" title="4.4 长时间运行的工作进程"></a>4.4 长时间运行的工作进程</h3><p>工作进程（worker）</p><p>把一直存在并且独立运行的goroutine称作为 工作进程</p><p>而工作进程通常被写成包含select语句的for循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// wait for channels here.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-事件循环和goroutine"><a href="#4-5-事件循环和goroutine" class="headerlink" title="4.5 事件循环和goroutine"></a>4.5 事件循环和goroutine</h3><p>事件循环（event loop）</p><p>中心循环（central loop）</p><p>Go通过提供groutine作为核心概念，消除了对中心循环的需求；</p><p>某些编程语言会用事件循环的中心循环来等待时间，并在这个事件发生时调用相应的已注册函数。而go语言则是通过提供goroutine作为核心概念，消除对中心循环的需求。</p><p>我们可以把任何工作进程goroutine都看做是独立运行的事件循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"image"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos := image.Point&#123;X: <span class="number">10</span>, Y: <span class="number">10</span>&#125;</span><br><span class="line">direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">next := time.After(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-next:</span><br><span class="line">pos = pos.Add(direction)</span><br><span class="line">fmt.Println(<span class="string">"current position is"</span>, pos)</span><br><span class="line">next = time.After(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">right = command(<span class="number">0</span>)</span><br><span class="line">left  = command(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoverDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">commandc <span class="keyword">chan</span> command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoverDriver</span><span class="params">()</span> *<span class="title">RoverDriver</span></span> &#123;</span><br><span class="line">r := &amp;RoverDriver&#123;</span><br><span class="line">commandc: <span class="built_in">make</span>(<span class="keyword">chan</span> command),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> r.drive()</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos := image.Point&#123;X: <span class="number">0</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">updateInterval := <span class="number">250</span> * time.Millisecond</span><br><span class="line">nextMove := time.After(updateInterval)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c := &lt;-r.commandc:</span><br><span class="line"><span class="keyword">switch</span> c &#123;</span><br><span class="line"><span class="keyword">case</span> right:</span><br><span class="line">direction = image.Point&#123;X: -direction.Y, Y: direction.X&#125;</span><br><span class="line"><span class="keyword">case</span> left:</span><br><span class="line">direction = image.Point&#123;X: direction.Y, Y: -direction.X&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"new direction %v"</span>, direction)</span><br><span class="line"><span class="keyword">case</span> &lt;-nextMove:</span><br><span class="line">pos = pos.Add(direction)</span><br><span class="line">log.Printf(<span class="string">"moved to %v"</span>, pos)</span><br><span class="line">nextMove = time.After(updateInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Left</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.commandc &lt;- left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Right</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.commandc &lt;- right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := NewRoverDriver()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">r.Left()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">r.Right()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改代码使得每次移动之间的间隔增加半秒</p><p>以RoverDriver类型为基础，定义start方法·stop方法和对应的命令，然后修改代码使得探测器可以接受这两个新命令</p><h3 id="4-6-互斥锁的实现"><a href="#4-6-互斥锁的实现" class="headerlink" title="4.6 互斥锁的实现"></a>4.6 互斥锁的实现</h3><h4 id="4-6-1-初版mutex实现"><a href="#4-6-1-初版mutex实现" class="headerlink" title="4.6.1 初版mutex实现"></a>4.6.1 初版mutex实现</h4><ul><li>CAS</li></ul><p>CAS指令是将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的；<em>原子性保证这个指令总是基于最新的值进行计算，如果同时有其他线程已经修改了这个值，那么CAS会返回失败</em></p><p>CAS是实现互斥锁和同步原语的基础；</p><p>mutex结构包含两个字段：</p><ul><li><p>字段key:</p><p>​    一个flag，用来标识这个排外锁是否被某个goroutine所持有，如果key大于1，说明这个排外锁已经被持有；</p></li><li><p>字段sema:</p><p>​    是个信号量变量，用来控制等待goroutine的阻塞休眠和唤醒；</p></li></ul><p><strong>Unlock方法可以被任意的goroutine调用释放锁，即使是没有持有这个互斥锁的goroutine，也可以进行这个操作，这是因为，Mutex本身并没有包含持有这把锁的goroutine的信息，所以，Unlock也不会对此进行检查，Mutex的这个和手机一直保持至今；</strong> 因此写代码时要遵循谁申请谁释放，以防造成死锁；</p><h2 id="5-select"><a href="#5-select" class="headerlink" title="5. select"></a>5. select</h2><h3 id="5-1-select的作用"><a href="#5-1-select的作用" class="headerlink" title="5.1 select的作用"></a>5.1 select的作用</h3><p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动</p><p>select与switch相似，但select有比较多的限制，其中最大的一条限制就是每个<strong>case语句里必须是一个IO操作</strong>（读写操作，读channel写channel也是一种IO操作）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- chan1:</span><br><span class="line">  <span class="comment">// 如果chan1成功读取到数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">case</span> chan2 &lt;<span class="number">-1</span>:</span><br><span class="line">  <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句；</p><p>如果其中的任意一语句可以继续执行（即没有被阻塞）那么就从那些可以执行的语句中任意选择一条来使用。</p><p>如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况</p><ul><li>如果给出default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复</li><li>如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> &lt;- chan1:</span><br><span class="line">    <span class="comment">// 如果chan1成功读取到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;<span class="number">-1</span>:</span><br><span class="line">    <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果需要轮训select监听channel数据流向的话，那么需要加上for语句。但是这样每次循环进来都需要default:这样就形成忙轮询死循环了。CPU一致被占用。所以一般在for的时候 不写default。这样的话select语句就会因为阻塞而挂起。挂起会出让cpu时间片。这样会提升计算机的效率</span></span><br></pre></td></tr></table></figure><h3 id="5-2-select基本使用"><a href="#5-2-select基本使用" class="headerlink" title="5.2 select基本使用"></a>5.2 select基本使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select </span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// 用来进行数据通信的channel</span></span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">// 用来判断是否退出的channel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 写数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">quit &lt;- <span class="literal">true</span> <span class="comment">// 通知主goroutine退出</span></span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 主goroutine 读数据</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num := &lt;-ch:</span><br><span class="line">fmt.Println(num)</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 终止进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>select总结：</p><p>作用： 用来监听channel上的数据流动方向。读？写？</p><p>用法： 参考switch case语句，但！ case后面必须是IO操作，不可以任意写判别表达式</p><p>注意事项：</p><ol><li>监听的case中，没有满足监听条件，阻塞</li><li>监听的case中，有多个满足监听条件，任选一个执行</li><li>可以使用default来处理所有case都不满足监听条件的状况，通常不同（会产生忙轮训）</li><li>select自身不带有循环机制，需要借助外层for来循环监听</li><li>break只能跳出select，类似swtich中的用法</li></ol><h3 id="5-3-select实现斐波那契数列"><a href="#5-3-select实现斐波那契数列" class="headerlink" title="5.3 select实现斐波那契数列"></a>5.3 select实现斐波那契数列</h3><h3 id="5-4-超时"><a href="#5-4-超时" class="headerlink" title="5.4 超时"></a>5.4 超时</h3><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  c:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  quit:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> v:= &lt;-c:</span><br><span class="line">      <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span>*time.Second): <span class="comment">// 设置超时</span></span><br><span class="line">        quit&lt;-<span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ &#123;</span><br><span class="line">    ch &lt;- i;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;-quit <span class="comment">// 主go程，阻塞等待子go程通知，退出</span></span><br><span class="line">  fmt.Println(<span class="string">"finish!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select超时处理：</p><p>select监听time.After中channel的读事件，如果定时时间到，系统会向该channel中写入系统当前时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- time.After(time.Second*<span class="number">5</span>)</span><br><span class="line">  <span class="comment">// 定时到达后，要处理的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Lock"><a href="#6-Lock" class="headerlink" title="6. Lock"></a>6. Lock</h2><p>什么是锁，就是某个协程（线程）在访问某个资源的时候先锁住，防止其他协程的访问，等访问完毕解锁后其他协程再来加锁访问。</p><h3 id="6-1-死锁"><a href="#6-1-死锁" class="headerlink" title="6.1 死锁"></a>6.1 死锁</h3><blockquote><p>不是锁的一种！！！ 是一种错误使用锁导致的现象</p></blockquote><p>死锁是指两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁；</p><ul><li>单go程死锁,（channel应该至少2个以上的go程中进行通信，否则死锁！）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch&lt;<span class="number">-789</span> <span class="comment">// 阻塞</span></span><br><span class="line">num:=&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>go程间channel访问顺序导致死锁</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">num := &lt;-ch</span><br><span class="line"></span><br><span class="line">fmt.Println(num)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="number">123</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用channel一端读（写），要保证另一端写（读）操作，同时有机会执行。否则死锁；</p><ul><li>多go程，多channel交叉死锁 （日常编程当中，逻辑控制不严谨。出现频率比较高）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 子</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num := &lt;-ch1:</span><br><span class="line">ch2 &lt;- num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num := &lt;-ch2:</span><br><span class="line">ch1 &lt;- num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在go语言中，尽量不要将互斥锁，读写锁与channel混用，—— 隐形死锁</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> rwlock sync.RWMutex <span class="comment">// 锁只有1把</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readGo</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rwlock.RLock() <span class="comment">// 以读模式枷锁</span></span><br><span class="line">num := &lt;-in</span><br><span class="line">fmt.Printf(<span class="string">"-----%dth 读go程，读出：%d\n"</span>, idx, num)</span><br><span class="line">rwlock.RUnlock() <span class="comment">// 以读模式解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeGo</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line">num := rand.Intn(<span class="number">1000</span>)</span><br><span class="line">rwlock.Lock() <span class="comment">//以写模式枷锁</span></span><br><span class="line">out &lt;- num</span><br><span class="line">fmt.Printf(<span class="string">"%dth 写go程,写入：%d\n"</span>, idx, num)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">300</span>)</span><br><span class="line">rwlock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 播种随机种子</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 用于数据传递的channel</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> readGo(ch, i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> writeGo(ch, i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-互斥锁"><a href="#6-2-互斥锁" class="headerlink" title="6.2 互斥锁"></a>6.2 互斥锁</h3><p>每个资源都对应一个可称为“互斥锁”的标记，这个标记是用来保证在任意时刻，只能有一个协程（线程）访问该资源，其他的协程只能等待；</p><p>互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock，Lock锁定当前的共享资源，Unlock进行解锁；</p><p>在使用互斥锁时，一定要注意：对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用channel完成同步</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, ch)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">300</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="number">98</span></span><br><span class="line">printer(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">printer(<span class="string">"mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> person1()</span><br><span class="line"><span class="keyword">go</span> person2()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁：<br>强制锁<br>建议锁</p><p>建议锁和强制锁并不是真正存在的锁，而是一种能对诸如记录锁、文件锁产生影响的两种机制；</p><p>这里的互斥锁是属于建议锁，操作系统不强制提供；（建议锁只是建议性存在的，并不强制执行，内核和系统总体上都坚持不使用建议性锁机制，它们依靠程序猿遵守这个规定，Linux默认是采用建议性锁）</p><p>建议锁只在合作进程（cooperating precess）之间才有效。破坏性的IO操作会成功</p><p>合作进程： 考虑数据库访问例程库，如果该库中所有函数都以一致性的方法处理记录锁，责成使用这些函数访问数据库的任何进程集为合作进程</p><p><strong>上层应用使用的锁全部都是建议锁</strong></p><p>强制锁机制是这样规定的：所有记录或文件锁功能内核执行的。破坏性的IO操作会被内核禁止。被锁的文件，内核会强制阻止任何对该文件的读或写违规访问。每次读或写访问都得检查锁是否存在。也就是强制性锁机制。</p><p><strong>强制锁只在操作系统底层它自己会用到，编程用不上</strong></p><p><img src="metux.png" alt="阻塞在锁上"><br>阻塞在锁上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用互斥锁完成同步</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">mutex.Lock() <span class="comment">// 访问共享数据之前，</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, ch)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">300</span>)</span><br><span class="line">&#125;</span><br><span class="line">mutex.Unlock() <span class="comment">// 访问共享数据之后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person1</span><span class="params">()</span></span> &#123;</span><br><span class="line">printer(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">person2</span><span class="params">()</span></span> &#123;</span><br><span class="line">printer(<span class="string">"mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> person1()</span><br><span class="line"><span class="keyword">go</span> person2()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-读写锁"><a href="#6-3-读写锁" class="headerlink" title="6.3 读写锁"></a>6.3 读写锁</h3><p>互斥锁的本质是当一个goroutine访问的时候，其他goroutinue都不能 访问，这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。</p><p>其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在竞争的问题的。因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的；</p><p>所以问题不是出在读上，主要是修改，也就是“写”，修改的数据要同步，这样其他goroutinue才可以感知到。所以真正的互斥应该是读取和修改、修改和修改之间，读和读是没有互斥操作的必要的；</p><p>因此，衍生出另外一种锁，叫做读写锁。</p><p>读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutinue既不能进行读操作，也不能进行写操作。</p><p>Go中的读写锁由结构体类型sync.RWMutex表示，此类型的方法集合中包含两对方法：</p><p>一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span><span class="title">RLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span><span class="title">RUlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>数据同步</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> rwlock sync.RWMutex <span class="comment">// 锁只有1把</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readGo</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rwlock.RLock() <span class="comment">// 以读模式枷锁</span></span><br><span class="line">num := count</span><br><span class="line">fmt.Printf(<span class="string">"-----%dth 读go程，读出：%d\n"</span>, idx, num)</span><br><span class="line">rwlock.RUnlock() <span class="comment">// 以读模式解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeGo</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line">num := rand.Intn(<span class="number">1000</span>)</span><br><span class="line">rwlock.Lock() <span class="comment">//以写模式枷锁</span></span><br><span class="line">count = num</span><br><span class="line">fmt.Printf(<span class="string">"%dth 写go程,写入：%d\n"</span>, idx, num)</span><br><span class="line">rwlock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 播种随机种子</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> readGo(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> writeGo(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1th 写go程,写入：42</span></span><br><span class="line"><span class="comment">//-----1th 读go程，读出：42</span></span><br><span class="line"><span class="comment">//-----1th 读go程，读出：42</span></span><br><span class="line"><span class="comment">//-----3th 读go程，读出：42</span></span><br><span class="line"><span class="comment">//1th 写go程,写入：86</span></span><br><span class="line"><span class="comment">//-----2th 读go程，读出：86</span></span><br><span class="line"><span class="comment">//-----2th 读go程，读出：86</span></span><br><span class="line"><span class="comment">//-----1th 读go程，读出：86</span></span><br></pre></td></tr></table></figure><p>总结</p><p>读时共享，写时独占。写锁优先级比读锁高</p><h3 id="6-4-条件变量"><a href="#6-4-条件变量" class="headerlink" title="6.4 条件变量"></a>6.4 条件变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引出问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">num := rand.Intn(<span class="number">800</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%dth:product -&gt; %d,\n "</span>, idx, num)</span><br><span class="line">out &lt;- num</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> in &#123;</span><br><span class="line">fmt.Printf(<span class="string">"-----%dth:consum -&gt; %d,\n "</span>, idx, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> consumer(product, i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> producer(product, i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>th:product -&gt; <span class="number">15</span>,</span><br><span class="line"> <span class="number">3</span>th:product -&gt; <span class="number">481</span>,</span><br><span class="line"> <span class="number">2</span>th:product -&gt; <span class="number">546</span>,</span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">15</span>,</span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">481</span>,</span><br><span class="line"> <span class="number">1</span>th:product -&gt; <span class="number">790</span>,</span><br><span class="line"> <span class="number">1</span>th:product -&gt; <span class="number">738</span>,</span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">790</span>, <span class="comment">// 546 空过去了</span></span><br><span class="line"> ----<span class="number">-4</span>th:consum -&gt; <span class="number">738</span>,</span><br></pre></td></tr></table></figure><p>本身不是锁！！但条件变量总是与锁一起使用</p><p>条件变量的作用并不保证在同一时刻仅有一个协程访问某个共享的数据资源，而是在对应的共享数据的状态发生变化时，通知阻塞在某个条件上的协程（线程）。条件变量不是锁，在并发中不能达到同步的目的，因此条件变量总是与锁一块使用</p><p>例如，如果仓库队列满了，我们可以使用条件变量让生产者对应的go程暂停（阻塞），但是当消费者消费了某个产品后，仓库就不再满了，应该唤醒（发送通知给）阻塞的生产者go程继续生产产品</p><p><img src="cond.png" alt="image-20210329110413577"></p><p>在抢锁之前，咨询条件变量。是否有必要抢锁（如果缓冲区满或空的时候）</p><p><strong>以前的顺序</strong></p><ol><li>抢锁</li><li>访问公共区</li><li>解锁</li></ol><p><strong>条件变量版本的顺序</strong></p><ol><li>判断条件变量</li><li>抢锁</li><li>访问公共区</li><li>解锁</li><li>唤醒阻塞在条件变量上的对端</li></ol><p>go标准库中的sync.Cond类型代表了条件变量，条件变量要与锁（互斥锁，或者读写锁）一起使用。成员变量L代表与条件变量搭配使用的锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line">  L Locker  <span class="comment">// 创建条件变量的时候，要指定其用的是什么锁</span></span><br><span class="line">  notify notifyList</span><br><span class="line">  checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的有3个常用方法，Wait，Signal，Broadcase</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(C *Cond)</span><span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">该函数的作用（一旦调用，会做下面三件事）</span></span><br><span class="line"><span class="comment">1. 阻塞等待条件变量满足</span></span><br><span class="line"><span class="comment">2. 释放已掌握的互斥锁相当于cond.L.Unlock() // 注意，1，2 两步为一个原子操作</span></span><br><span class="line"><span class="comment">3. 当被唤醒，Wait()函数返回时，解除阻塞并重新获取互斥锁，相当于cond.L.Lock()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 下面两个函数为 唤醒操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span><span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 单发通知，给一个正等待（阻塞）在该条件变量上的goroutinue 发送通知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span><span class="title">Broadcase</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 广播通知，给正在等待（阻塞）在该条件变量上的所有goroutinue发送通知 // 惊群效应</span></span><br></pre></td></tr></table></figure><p>使用条件变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义条件变量cond</span><br><span class="line"><span class="number">2.</span> cond.L--&gt;mutex ,指定一把锁</span><br><span class="line"><span class="number">3.</span> cond.L.lock() </span><br><span class="line"><span class="number">4</span> <span class="keyword">if</span> xxxx</span><br><span class="line">wait() <span class="comment">// 如果满足条件，做wait操作， wait包含3件事（一段时间的阻塞，解锁，加锁）</span></span><br></pre></td></tr></table></figure><p>一段时间的阻塞，解锁，加锁</p><p>为什么在等待的时候，要解开锁，一会儿又加上呢？</p><p>因为针对的对象是公共区（有缓冲channel），执行wait函数说明公共区达到了容器设定的条件。没办法继续往公共区读（写）数据。所以，当挂起等待的过程当中需要将锁让给对端。当对端写（读）数据之后，容器出现富余，它再唤醒对端，对端重新加上锁从而来访问公共区；</p><h2 id="7-定时器"><a href="#7-定时器" class="headerlink" title="7.  定时器"></a>7.  定时器</h2><p>time.Timer</p><p>Timer是一个定时器，代表未来的一个单一时间，你可以告诉timer你要等待多长时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">C &lt;- <span class="keyword">chan</span> Time</span><br><span class="line">r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统会自动向timer.C这个channel中写入当前时间，阻塞即被解除；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"current time"</span>, time.Now())</span><br><span class="line">mytimer := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 定时时间到，系统会自动向timer.C这个channel写入了当前时间； </span></span><br><span class="line">currentTime := &lt;-mytimer.C</span><br><span class="line">fmt.Println(<span class="string">"currentTime is:"</span>, currentTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//current time 2021-03-28 19:27:55.330078 +0800 CST m=+0.000082012</span></span><br><span class="line"><span class="comment">//currentTime is: 2021-03-28 19:27:57.330273 +0800 CST m=+2.000328165</span></span><br></pre></td></tr></table></figure><h3 id="7-1-三种定时方法"><a href="#7-1-三种定时方法" class="headerlink" title="7.1 三种定时方法"></a>7.1 三种定时方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 1. sleep</span></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  <span class="comment">// 2. Timer.C</span></span><br><span class="line">  myTimer:= time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 定时器慢，系统自动写入系统时间</span></span><br><span class="line">  currentTime := &lt;-mytimer.C</span><br><span class="line">fmt.Println(<span class="string">"currentTime is:"</span>, currentTime)</span><br><span class="line">  <span class="comment">// 3. time.After</span></span><br><span class="line">  nowTimer2 := time.After(time.Second*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time.After定时：</p><p>指定定时时长，定时到达后，系统会自定向定时器的成员写入 系统当前时间。</p><p>返回可读 chan，读取，可获得系统写入时间；</p><p>总结： Sleep NewTimer， After 都是 time包的</p><h3 id="7-2-定时器的停止和重置"><a href="#7-2-定时器的停止和重置" class="headerlink" title="7.2 定时器的停止和重置"></a>7.2 定时器的停止和重置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  myTimer := time.NewTimer(time.Second * <span class="number">3</span>) <span class="comment">// 创建定时器</span></span><br><span class="line">  myTimer.Reset(<span class="number">1</span> *time.Second) <span class="comment">//重置定时器时长为1</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &lt;- myTimer.C</span><br><span class="line">    fmt.Println(<span class="string">"子go程，定时完毕"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  myTimer.Stop() <span class="comment">//设置定时器停止</span></span><br><span class="line">  <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-定时器周期定时"><a href="#7-3-定时器周期定时" class="headerlink" title="7.3 定时器周期定时"></a>7.3 定时器周期定时</h3><p>周一到周五每天早上8点起床上班</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"startTime:"</span>, time.Now())</span><br><span class="line">myTicker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">nowTime := &lt;-myTicker.C</span><br><span class="line">fmt.Println(<span class="string">"nowTime:"</span>, nowTime)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startTime: 2021-03-28 20:47:03.563903 +0800 CST m=+0.000099792</span></span><br><span class="line"><span class="comment">//nowTime: 2021-03-28 20:47:04.575006 +0800 CST m=+1.011228039</span></span><br><span class="line"><span class="comment">//nowTime: 2021-03-28 20:47:05.579668 +0800 CST m=+2.015915392</span></span><br><span class="line"><span class="comment">//nowTime: 2021-03-28 20:47:06.577759 +0800 CST m=+3.014031618</span></span><br></pre></td></tr></table></figure><p>可控的周期性定时器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">myTimer := time.NewTicker(time.Second)</span><br><span class="line">fmt.Println(<span class="string">"now Time:="</span>, time.Now())</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">currentTime := &lt;-myTimer.C</span><br><span class="line">i++</span><br><span class="line">fmt.Println(<span class="string">"current Time:= "</span>, currentTime)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">quit &lt;- <span class="literal">true</span></span><br><span class="line">        runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个周期定时器 time.NewTicker，定时时长到达后，系统会自动向Ticker的C中写入系统当前时间，并且，每隔一个定时时长后，循环写入系统当前时间；</li><li>在子go程中循环读取C，获取系统写入的时间</li></ol><h2 id="8-内存模型：Go如何保证并发读写的顺序"><a href="#8-内存模型：Go如何保证并发读写的顺序" class="headerlink" title="8. 内存模型：Go如何保证并发读写的顺序"></a>8. 内存模型：Go如何保证并发读写的顺序</h2><h3 id="8-1-重排和可见性"><a href="#8-1-重排和可见性" class="headerlink" title="8.1 重排和可见性"></a>8.1 重排和可见性</h3><blockquote><p>由于指令重排，代码并不一定会按照你写的顺序执行</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello world"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">// 这里未见一定输出 hello world，尽管你运行了100次都打印出来了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-happens-before"><a href="#8-2-happens-before" class="headerlink" title="8.2 happens-before"></a>8.2 happens-before</h3><blockquote><p>在一个goroutine内部，程序的执行顺序和它们的代码指定的顺序是一样的，即时编译器或者CPU重排了读写顺序，从行为上来看，也和代码指定的顺序一样；</p></blockquote><p>但是对于另一个goroutine来说，重排却产生非常大的影响。因为Go只保证goroutine内部重排对读写的顺序没有影响；</p><p>如果两个action（read或write）有明确的happens-before关系，你就可以确定它们之间的执行顺序（或者是行为表现上的顺序）</p><p>Go内存模型通过happens-before定义两个事件（读、写action）的顺序：</p><ul><li>如果事件e1 <code>happens before</code> 事件 e2，那么，我们就可以说事件e2在事件e1之后发生（happens after）</li><li>如果e1不是<code>happens before</code> e2，同时也不<code>happens after</code> e2，那么，我们就可以说事件 e1 和 e2 是同时发生的；</li></ul><p>如果要保证对 “变量v 的 读操作r” 能够观察到一个对 ”变量v 的 写操作w“， 并且r只能观察到w对变量v的写，没有其他对v的写操作，也就是说，我们要保证r绝对能观察到w操作的结果，那么就需要同时满足两个条件：</p><ol><li>w happens before r；</li><li>其他对v的写操作（w2，w3，w4，。。。）要么happens before w，要么happens after r， 绝对不和w、r同时发生，或者是在它们之间发生；</li></ol><p>在goroutine内部对一个局部变量v的读，一定能观察到最近一次对这个局部变量v的写。如果要保证多个goroutine之间对一个共享变量的读写顺序，在Go语言中，可以使用并发原语为读写操作建立happens-before关系；这样就可以保证顺序了；</p><ul><li>在Go语言中，对变量进行零值的初始化就是一个写操作；</li><li>如果对超过机器word（64bit，32bit或者其它）大小值进行读写，那么，就可以看作是对拆成word大小的几个读写无序进行；</li><li>Go并不提供直接的CPU屏障（CPU fence）来提示编译器或者CPU保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语；</li></ul><h3 id="8-3-Go语言中保证happens-before关系"><a href="#8-3-Go语言中保证happens-before关系" class="headerlink" title="8.3 Go语言中保证happens-before关系"></a>8.3 Go语言中保证happens-before关系</h3><h4 id="8-3-1-init函数"><a href="#8-3-1-init函数" class="headerlink" title="8.3.1 init函数"></a>8.3.1 init函数</h4><p>应用程序的初始化是在单一的goroutine执行，如果包p导入了包q， 那么，q的init函数的执行一定happens before p的任何初始化代码；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="keyword">import</span> <span class="string">"q"</span> <span class="comment">// q的init函数执行一定 happens before p的任何代码；</span></span><br></pre></td></tr></table></figure><p><em>main函数一定在导入包的init函数之后执行</em></p><h4 id="8-3-2-goroutine"><a href="#8-3-2-goroutine" class="headerlink" title="8.3.2 goroutine"></a>8.3.2 goroutine</h4><p><em>启动goroutine的go语句的执行，一定happens before此goroutine内的代码执行；</em></p><p>根据上面的规则，我们知道，如果go语句传入的参数是一个函数执行的结果，那么，这个函数一定先于goroutine内部的代码被执行；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">3</span>   <span class="built_in">print</span>(a)</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">6</span>   a = <span class="string">"hello,world"</span></span><br><span class="line"><span class="number">7</span>   <span class="keyword">go</span> f()</span><br><span class="line"><span class="number">8</span> &#125;</span><br></pre></td></tr></table></figure><p>第6 和 第7 在同一个goroutine执行，在main goroutine看来， 6 happens before 7.</p><p>7 子gouroutine happens before 第3行的变量输出，那么，可以推断出，第6行 happens before 第3行。</p><p>也就是说，在第3行 打印a的值的时候，肯定会打印出“hello world”；</p><p>启动goroutine的情况，goroutine退出的时候，是没有任何happens-before保证的。所以，如果你想观察某个goroutine的执行效果，你需要使用同步机制建立happens-before关系，比如Mutex或者Channel。</p><h4 id="8-3-3-channel"><a href="#8-3-3-channel" class="headerlink" title="8.3.3 channel"></a>8.3.3 channel</h4><p>通用的Channel happens-before关系保证有4条规则</p><ol><li>第一条规则</li></ol><p>往Channel中的发送操作，happens before 从该channel接收相应数据的动作完成之前；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  s= <span class="string">"hello,go"</span> <span class="comment">// 赋值</span></span><br><span class="line">  ch&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="comment">//  写channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> f()</span><br><span class="line">  &lt;-ch    <span class="comment">// 读channel</span></span><br><span class="line">  <span class="built_in">print</span>(s) <span class="comment">// 打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先‘赋值’  happens before ‘写channel’， ‘写channel’ happens before ‘读channel’；</p><p>‘打印’happens after ‘读channel’； 所以 ‘打印’必然输出 hello，go</p><ol start="2"><li>第二条规则</li></ol><p>close一个channel的调用，肯定 happens before 从关闭的Channel中读取出一个零值；</p><ol start="3"><li>第三条规则</li></ol><p>对于unbuffered的channel，读取channel数据的调用 一定 happens before  写入channel数据的调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">5</span>  s = <span class="string">"hello, go"</span></span><br><span class="line"><span class="number">6</span>  &lt;-ch</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">10</span>  <span class="keyword">go</span> f()</span><br><span class="line"><span class="number">11</span>  ch&lt;-<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="number">12</span>  <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure><p>如果第11行发送语句执行成功，那么根据这个规则，第6行（接收）的调用肯定发生了，（执行完成不完成不重要，重要的是这一句“肯定执行了”），那么s也肯定初始化了，所以一定会打印出“hello ，go”</p><p>因为channel是unbuffered的Channel，所以这个规则也成立</p><ol start="4"><li>第四条规则</li></ol><p>如果Channel的容量是m（m&gt;0），那么第n个 receive 一定 happens before 第 n+m 个 send 的完成；</p><h4 id="8-3-4-Mutex-RWMutex"><a href="#8-3-4-Mutex-RWMutex" class="headerlink" title="8.3.4 Mutex/RWMutex"></a>8.3.4 Mutex/RWMutex</h4><ol><li>第n次的m.Unlock 一定happens before第n+1 m.Lock方法的返回；</li><li>对于读写锁 RWMutex m，如果它的第 n 个 m.Lock 方法的调用已返回，那么它的第 n 个 m.Unlock 的方法调用一定 happens before 任何一个 m.RLock 方法调用的返回，只要这些 m.RLock 方法调用 happens after 第 n 次 m.Lock 的调用的返回。这就可以保证，只有释放了持有的写锁，那些等待的读请求才能请求到读锁。</li><li>对于读写锁 RWMutex m，如果它的第 n 个 m.RLock 方法的调用已返回，那么它的第 k （k&lt;=n）个成功的 m.RUnlock 方法的返回一定 happens before 任意的 m.RUnlockLock 方法调用，只要这些 m.Lock 方法调用 happens after 第 n 次 m.RLock。</li></ol><p>对于读写锁 i 的i.RLock方法调用，如果存在一个n，这次的 l.RLock 调用 happens after 第 n 次的 l.Unlock，那么，和这个 RLock 相对应的 l.RUnlock 一定 happens before 第 n+1 次 l.Lock。意思是，读写锁的 Lock 必须等待既有的读锁释放后才能获取到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">5</span>  s = <span class="string">"go"</span></span><br><span class="line"><span class="number">6</span>  mu.Unlock()</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">10</span>  mu.Lock()</span><br><span class="line"><span class="number">11</span>  <span class="keyword">go</span> foo()</span><br><span class="line"><span class="number">12</span>  m.Lock()</span><br><span class="line"><span class="number">13</span>  <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure><p>第6行第一次unLock 一定happens before第二次的Lock（第12行），所以这也能保证正确输出“go”</p><h4 id="8-3-5-WaitGroup"><a href="#8-3-5-WaitGroup" class="headerlink" title="8.3.5 WaitGroup"></a>8.3.5 WaitGroup</h4><p>Wait方法等到计数值归零之后才返回</p><h4 id="8-3-6-Once"><a href="#8-3-6-Once" class="headerlink" title="8.3.6 Once"></a>8.3.6 Once</h4><p>对于once.Do(f) 调用，f函数的那个单次调用一定happens before任何once.Do(f)调用的返回。换句话说，就是函数f一定会在Do方法返回之前执行；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">5</span>  s = <span class="string">"go"</span></span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">9</span>  once.Do(foo)</span><br><span class="line"><span class="number">10</span>  <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure><p>第5行的执行一定happens before第9行的返回，所以执行到第10行的时候，s已经初始化了，所以会正确打印“go”</p><h4 id="8-3-7-atomic"><a href="#8-3-7-atomic" class="headerlink" title="8.3.7 atomic"></a>8.3.7 atomic</h4><p>现阶段还是不要使用atomic来保证顺序性；</p><h2 id="9-信号量"><a href="#9-信号量" class="headerlink" title="9. 信号量"></a>9. 信号量</h2><blockquote><p>信号量 是用来控制多个goroutine同时访问多个资源的并发原语；</p><p>信号量的概念是1963年提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等到可以继续进行的信号到来</p></blockquote><p>最简单的信号量就是一个变量加一些并发控制的能力，这个变量是 0 到 n 之间的一个数值。当 goroutine 完成对此信号量的等待（wait）时，该计数值就减 1，当 goroutine 完成对此信号量的释放（release）时，该计数值就加 1。当计数值为 0 的时候，goroutine 调用 wait 等待该信号量是不会成功的，除非计数器又大于 0，等待的 goroutine 才有可能成功返回。</p><ul><li>举例</li></ul><p>举个例子，图书馆新购买了 10 本《Go 并发编程的独家秘籍》，有 1 万个学生都想读这本书，“僧多粥少”。所以，图书馆管理员先会让这 1 万个同学进行登记，按照登记的顺序，借阅此书。如果书全部被借走，那么，其他想看此书的同学就需要等待，如果有人还书了，图书馆管理员就会通知下一位同学来借阅这本书。这里的资源是10本《Go 并发编程的独家秘籍》，想读此书的同学就是 goroutine，图书管理员就是信号量。</p><h3 id="9-1-P-V操作"><a href="#9-1-P-V操作" class="headerlink" title="9.1 P/V操作"></a>9.1 P/V操作</h3><p>P操作（descrease, wait, acquire） 减少信号量的计数值</p><p>V操作（increase, signal, release） 增加信号量的计数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">V</span><span class="params">(semaphore S, integer I)</span>:</span></span><br><span class="line">[S &lt;- S + I]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">P</span><span class="params">(semaphore S, integer I)</span>:</span></span><br><span class="line">repeat:</span><br><span class="line">    [<span class="keyword">if</span> S&gt;= I:</span><br><span class="line">    S &lt;- S-I</span><br><span class="line">    <span class="keyword">break</span>]</span><br></pre></td></tr></table></figure><p>初始化信号量S有一个指定数量（n）的资源，它就像是一个有n个资源的池子。P操作相当于请求资源，如果资源可用，就立即返回； 如果没有资源或者不够，那么，它可以不断尝试或阻塞等待。</p><p>V操作会释放自己持有的资源，把资源返还给信号量，信号量的值除了初始化的操作以外，只能由P/V操作改变；</p><p>信号量的实现</p><ul><li>初始化信号量：设定初始的资源的数量</li><li>P操作： 将信号量的计数值减去1，如果新值已经为负，那么调用者会被阻塞并加入到等待队列中。否则，调用者会继续执行，并且获得一个资源；</li><li>V操作：将信号量的计数值加1，如果先前的计数值为负，就说明有等待的P操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行；</li></ul><p>其实，信号量可以分为计数信号量（counting semaphre）和二进位信号量（binary semaphore）。刚刚所说的图书馆借书的例子就是一个计数信号量，它的计数可以是任意一个整数。在特殊的情况下，如果计数值只能是 0 或者 1，那么，这个信号量就是二进位信号量，提供了互斥的功能（要么是 0，要么是 1），所以，有时候互斥锁也会使用二进位信号量来实现。</p><p>我们一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接，几个打印机资源，等等。如果信号量蜕变成二进位的信号量，那么，它的P/V就和互斥锁的Lock/Unlock一样了；</p><h3 id="9-2-官方扩展库实现"><a href="#9-2-官方扩展库实现" class="headerlink" title="9.2 官方扩展库实现"></a>9.2 官方扩展库实现</h3><p>在运行时，Go内部使用信号量来控制goroutine的阻塞和唤醒。</p><p>信号量的p/V操作是通过函数实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semacquire</span><span class="params">(s *<span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_SemacquireMutex</span><span class="params">(s *<span class="keyword">uint32</span>, lifo <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semrelease</span><span class="params">(s *<span class="keyword">uint32</span>, handoff <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>信号量的几个实现方法</p><ol><li>Acquire</li></ol><p>相当于 P 操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是 Context，这就意味着，你可以通过 Context 增加超时或者 cancel 的机制。如果是正常获取了资源，就返回 nil；否则，就返回 ctx.Err()，信号量不改变。</p><ol start="2"><li>Release</li></ol><p>相当于V操作，可以将n个资源释放，返还给信号量。</p><ol start="3"><li>TryAcquire</li></ol><p>尝试获取n个资源，但是它不会阻塞，要么成功获取n个资源，返回true，要么一个也不获取。返回false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/sync/semaphore"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">maxWorkers = runtime.GOMAXPROCS(<span class="number">0</span>)                    <span class="comment">// worker 数量</span></span><br><span class="line">sema       = semaphore.NewWeighted(<span class="keyword">int64</span>(maxWorkers)) <span class="comment">// 信号量</span></span><br><span class="line">task       = <span class="built_in">make</span>([]<span class="keyword">int</span>, maxWorkers*<span class="number">4</span>)                <span class="comment">// 任务数，是worker的四倍</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">main goroutine 相当于一个dispatcher，负责任务的分发，它先请求信号量，如果获取成功，就会启动一个goroutine去处理计算，然后</span></span><br><span class="line"><span class="comment">这个 goroutine会释放这个信号量（信号量的获取是在main goroutine，释放是在worker goroutine），如果获取不成功，就等到</span></span><br><span class="line"><span class="comment">信号量可以使用的时候，再去获取；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> task &#123;</span><br><span class="line"><span class="comment">// 如果没有worker可用，会阻塞在这里，直到某个worker被释放</span></span><br><span class="line"><span class="keyword">if</span> err := sema.Acquire(ctx, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动worker goroutine</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> sema.Release(<span class="number">1</span>)</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">task[i] = i + <span class="number">1</span></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求所有worker，这样能确保前面的worker都执行完 （想等所有的Worker都执行完，就可以获取最大计数值的信号量）</span></span><br><span class="line"><span class="keyword">if</span> err := sema.Acquire(ctx, <span class="keyword">int64</span>(maxWorkers)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"获取所有worder失败: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-SingeFlight-和-SyclicBarrier"><a href="#10-SingeFlight-和-SyclicBarrier" class="headerlink" title="10. SingeFlight 和 SyclicBarrier"></a>10. SingeFlight 和 SyclicBarrier</h2><blockquote><p>SingeFlight将并发请求合并成一个请求， SyclicBarrier是一个可重用的栅栏并发原语，用来控制一组请求同时执行的数据结构</p></blockquote><h2 id="11-分组操作"><a href="#11-分组操作" class="headerlink" title="11 分组操作"></a>11 分组操作</h2><blockquote><p>共享资源保护、任务编排和消息传递是Go并发编程中常见的场景，而分组执行一批相同的或类似的任务则是任务编排中一类情形，分组编排的一些常用场景和并发原语，ErrGroup，gollback，Hunch和schedgroup</p></blockquote><h3 id="11-1-ErrGroup"><a href="#11-1-ErrGroup" class="headerlink" title="11.1 ErrGroup"></a>11.1 ErrGroup</h3><p>经常会碰到将一个通用的父任务拆成几个小任务并发执行的场景，其实，将一个大的任务拆成几个小任务并发执行。可以有效地提高程序的并发度，</p><p>ErrGroup就是用来应对这种场景的，它和WaitGroup有些类似，但是它提供功能更加丰富：</p><ul><li>和Context集成</li><li>error向上传播，可以把子任务的错误传递给Wait的调用者</li></ul><p>Api</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span><span class="params">(*Group, context.Context)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Go</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Wait</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><h4 id="11-1-1-ErrGroup使用例子"><a href="#11-1-1-ErrGroup使用例子" class="headerlink" title="11.1.1 ErrGroup使用例子"></a>11.1.1 ErrGroup使用例子</h4><ul><li>返回第一个错误</li></ul><p>启动三个子任务，其中，子任务2会返回执行失败，其他两个执行成功。在三个子任务都执行后，group.Wait</p><p> 才会返回第2个子任务的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"exec #1"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"exec #2"</span>)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"failed to exec #2"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"exec #3"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待第三个任务都完成</span></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"successfully exec all"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"failed:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec #1<br>exec #2<br>exec #3<br>failed: failed to exec #2</p><ul><li>返回所有子任务的错误</li></ul><p>Group只能返回子任务的第一个错误，后续的错误都会被丢弃，但是，有时候我们需要知道每个任务的执行情况，</p><p>我们使用一个result slice保存子任务的执行结果，这样，通过查询result，就可以知道每一个子任务的结果了；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">make</span>([]error, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"exec #1"</span>)</span><br><span class="line">result[<span class="number">0</span>] = <span class="literal">nil</span> <span class="comment">//保存成功或者失败的结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"exec #2"</span>)</span><br><span class="line">result[<span class="number">1</span>] = errors.New(<span class="string">"failed to exec #2"</span>)</span><br><span class="line"><span class="keyword">return</span> result[<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"exec #3"</span>)</span><br><span class="line">result[<span class="number">2</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待第三个任务都完成</span></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"successfully exec all. result:%v\n"</span>, result)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"failed: %v\n"</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec #1<br>exec #2<br>exec #3<br>failed: [<nil> failed to exec #2 <nil>]</p><h2 id="12-goroutine"><a href="#12-goroutine" class="headerlink" title="12. goroutine"></a>12. goroutine</h2><blockquote><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。</p></blockquote><p>并发不是并行，并行是指两个或者多个线程同时在不同的处理器执行代码，如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配goroutine，这将导致goroutine在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutine将针对单个物理处理器并发运行，即时Go运行时使用多个逻辑处理器；</p><h3 id="12-1-keep-yourself-busy-or-do-the-work-yourself"><a href="#12-1-keep-yourself-busy-or-do-the-work-yourself" class="headerlink" title="12.1 keep yourself busy or do the work yourself"></a>12.1 keep yourself busy or do the work yourself</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 不推荐的写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="comment">// main goroutine无法感知a goroutine什么时候取得进展；</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err) <span class="comment">// 会导致goroutine的defer 无法正常执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">  <span class="comment">// 空的select 语句将永远阻塞</span></span><br><span class="line">  <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的goroutine在从另一个goroutine获得结果之前无法取得进展，那么通常情况下，你自己去做这项工作比委托它（go func()）更简单；</p><h3 id="12-2-不要启动一个goroutine如果你不知道它什么时候结束"><a href="#12-2-不要启动一个goroutine如果你不知道它什么时候结束" class="headerlink" title="12.2 不要启动一个goroutine如果你不知道它什么时候结束"></a>12.2 不要启动一个goroutine如果你不知道它什么时候结束</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span>&#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux)<span class="comment">// debug</span></span><br><span class="line">  http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux) <span class="comment">// app traffic </span></span><br><span class="line">  <span class="comment">// 上面debug服务 挂掉，main是感知不到的；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何时候在启动一个goroutine的时候都需要考虑两个问题</p><ol><li>它什么时候结束</li><li>如何能够让它结束</li></ol><p>通过将serveApp 和 serveDebug 处理程序分解为各自的函数，我们将它们与main.main解耦，确保serveApp 和 serveDebug将它们的并发性留给调用者</p><p>如果serveApp返回，则main.main 将返回导致程序关闭，只能靠类似supervisor进程管理来重新启动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span>&#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span>&#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span>&#123;</span><br><span class="line">  http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> serveDebug() <span class="comment">// 如果退出，main依然感知不到</span></span><br><span class="line">  serveApp() <span class="comment">// 如果退出，main就退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span>&#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span>&#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux); err != <span class="literal">nil</span>&#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依旧有问题</span></span><br><span class="line"><span class="comment">// ListenAndServer 返回nil error，最终main.main无法退出</span></span><br><span class="line"><span class="comment">// log.Fatal 调用了os.Exit， 会无条件终止程序； defers不会被调用到；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> serveDebug() </span><br><span class="line">  <span class="keyword">go</span> serveApp() </span><br><span class="line">  <span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Memory-model"><a href="#Memory-model" class="headerlink" title="Memory model"></a>Memory model</h2><h2 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package sync</h2><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h2 id="Package-context"><a href="#Package-context" class="headerlink" title="Package context"></a>Package context</h2>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMP</title>
      <link href="2021/05/28/GMP/"/>
      <url>2021/05/28/GMP/</url>
      
        <content type="html"><![CDATA[<ul><li><blockquote><p>本节为<strong>重点</strong>章节<br>本章节含视频版:</p></blockquote></li></ul><p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx" target="_blank" rel="noopener"><img src="https://img.kancloud.cn/8c/36/8c367cb1f4ce2839f6ebc2f909372eba_1362x692.png" alt="img"></a></p><hr><h2 id="一、Golang“调度器”的由来？"><a href="#一、Golang“调度器”的由来？" class="headerlink" title="一、Golang“调度器”的由来？"></a>一、Golang“调度器”的由来？</h2><h3 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代”</p><p>一切的程序只能串行发生。</p><p><img src="https://img.kancloud.cn/30/f7/30f77ecceb7ae3b3f0911bf7c8904599_1586x1184.png" alt="img"></p><p>早期的单进程操作系统，面临2个问题：</p><p>1.单一的执行流程，计算机只能一个任务一个任务处理。</p><p>2.进程阻塞所带来的CPU时间浪费。</p><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了<strong>最早的并发能力：多进程并发</strong>，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p><h3 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)多进程/线程时代有了调度器需求"></a>(2)多进程/线程时代有了调度器需求</h3><p><img src="https://img.kancloud.cn/de/49/de49ef2a1ef0fc553754b5ea87e133a6_1522x1332.png" alt="img"></p><p>在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p><p><strong>怎么才能提高CPU的利用率呢？</strong></p><p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p><p><img src="https://img.kancloud.cn/b1/d1/b1d10153ae6c22754d38328379fa395f_1442x976.png" alt="img"></p><p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p><h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3)协程来提高CPU利用率"></a>(3)协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</p><p>大量的进程/线程出现了新的问题</p><ul><li>高内存占用</li><li>调度的高消耗CPU</li></ul><p>好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。</p><p>一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。</p><p><img src="https://img.kancloud.cn/47/e3/47e396eea8f0e71532356197412d52f1_1294x1106.png" alt="img"></p><p> 这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”.</p><p><img src="https://img.kancloud.cn/45/9d/459db145d4e702994548a1757238946f_1248x1064.png" alt="img"></p><p> 看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p><p> 之后，我们就看到了有3中协程和线程的映射关系：</p><blockquote><h4 id="N-1关系"><a href="#N-1关系" class="headerlink" title="N:1关系"></a>N:1关系</h4></blockquote><p>N个协程绑定1个线程，优点就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</p><p>缺点：</p><ul><li>某个程序用不了硬件的多核加速能力</li><li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li></ul><p><img src="https://img.kancloud.cn/f8/d7/f8d715899f6db333d37f2bf738116bfd_1352x1092.png" alt="img"></p><blockquote><h4 id="1-1-关系"><a href="#1-1-关系" class="headerlink" title="1:1 关系"></a>1:1 关系</h4></blockquote><p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</p><p>缺点：</p><ul><li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li></ul><p><img src="https://img.kancloud.cn/cf/9a/cf9a59f9776bf4c9cbbad6103b6c5e5a_1322x1112.png" alt="img"></p><blockquote><h4 id="M-N关系"><a href="#M-N关系" class="headerlink" title="M:N关系"></a>M:N关系</h4></blockquote><p>M个协程绑定1个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p><p><img src="https://img.kancloud.cn/00/37/0037f6c2e12ad82a912990bba3e0085c_1336x1112.png" alt="img"></p><p> 协程跟线程是有区别的，线程由CPU调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出CPU后，才执行下一个协程。</p><p>瓶颈就在协程调度器上了，协程调度器做的越好，整个架构性能越好；因为这个架构底层的线程涉及的CPU调度器是内核级别，是无法改变的；</p><h3 id="4-Go语言的协程goroutine"><a href="#4-Go语言的协程goroutine" class="headerlink" title="(4)Go语言的协程goroutine"></a>(4)Go语言的协程goroutine</h3><p><strong>Go为了提供更容易使用的并发方法，使用了goroutine和channel</strong>。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。</p><p>Goroutine特点：</p><ul><li>占用内存更小（几kb）</li><li>调度更灵活(runtime调度)</li></ul><h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5)被废弃的goroutine调度器"></a>(5)被废弃的goroutine调度器</h3><p> 好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p><p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p><blockquote><p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p></blockquote><p><img src="https://img.kancloud.cn/e1/49/e1499cd06be0cdbee19ac4ada8537326_984x738.png" alt="img"></p><p> 下面我们来看看被废弃的golang调度器是如何实现的？</p><p><img src="https://img.kancloud.cn/bd/cd/bdcdc5e6fcb03244a9843333cca62378_1292x860.png" alt="img"></p><p> M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。</p><p>老调度器有几个缺点：</p><ol><li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li><li>M转移G会造成<strong>延迟和额外的系统负载</strong>。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了<strong>很差的局部性</strong>，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p><p>在新调度器中，出列M(thread)和G(goroutine)，又引进了P(Processor)。</p><p><img src="https://img.kancloud.cn/6b/db/6bdb04101cc63565c17cd8fcaba17321_1068x876.png" alt="img"></p><p><strong>Processor，处理器，它是用来处理goroutine的，它包含了运行每一个goroutine的资源</strong>，</p><p>如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p><h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1)GMP模型"></a>(1)GMP模型</h3><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。</p><p><img src="https://img.kancloud.cn/eb/fe/ebfe3e28315f12a08fbb4ffaee32e046_1024x768.png" alt="img"></p><ol><li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li><li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li><strong>P列表</strong>：所有的P都在“程序启动时”创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。可通过环境变量$GOMAXPROCS或者在程序中通过runtime.GOMAXPROCS来设置；</li><li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。</p><blockquote><h4 id="有关P和M的个数问题"><a href="#有关P和M的个数问题" class="headerlink" title="有关P和M的个数问题"></a>有关P和M的个数问题</h4></blockquote><p>1、P的数量：</p><ul><li>由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS</code>个goroutine在同时运行。</li></ul><p>2、M的数量:</p><ul><li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li><li>runtime/debug中的SetMaxThreads函数，设置M的最大数量</li><li>一个M阻塞了，会创建新的M。</li></ul><p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p><blockquote><h4 id="P和M何时会被创建"><a href="#P和M何时会被创建" class="headerlink" title="P和M何时会被创建"></a>P和M何时会被创建</h4></blockquote><p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p><p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p><h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2)调度器的设计策略"></a>(2)调度器的设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p><p>1）work stealing机制</p><p> 当本线程（本P）无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p><p>2）hand off机制</p><p> 当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p><p><strong>利用并行</strong>：<code>GOMAXPROCS</code>设置P的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的CPU核进行并行。</p><p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p><p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p><h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func() 调度流程"></a>(3) go func() 调度流程</h3><p><img src="https://img.kancloud.cn/76/4f/764f7be119026cc16314e87628e4013f_1920x1080.jpeg" alt="img"></p><p>从上图我们可以分析出几个结论：</p><p> 1、我们通过 go func()来创建一个goroutine；</p><p> 2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p><p> 3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p><p> 4、一个M调度G执行的过程是一个循环机制；</p><p> 5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p><p> 6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4)调度器的生命周期"></a>(4)调度器的生命周期</h3><blockquote><p>当启动一个go进程的时候，它是如何创建初始化这些线程和协程的。包括是如何启动main函数这么样的一个过程。调度器是如何完成的；</p><p>M0和G0: 一个特殊的线程和协程</p></blockquote><p><img src="https://img.kancloud.cn/b3/10/b31027eeb493fa86654b41d46f34a98b_439x872.png" alt="img"></p><p>特殊的M0和G0</p><p><strong>M0</strong></p><p><code>M0</code>是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p><p>(M0跟进程数量绑定，1比1的关系)</p><p><strong>G0</strong></p><p>每次启动一个M，都会第一个创建的goroutine，就是G0. <code>G0</code>是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G（保存一个调度，栈的信息，它来提供环境，来去调度其他的G），G0不指向任何可执行的函数,（当一个M从G1切换到G2，首先要先切换到G0，然后通过G0把G1干掉，然后把G2再加过来。G0是中间的桥梁） 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p><p>（G0根M绑定，每个M都会有第一个G）</p><p>我们来跟踪一段代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p><p>也会经历如上图所示的过程：</p><ol><li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li><li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li><li>示例代码中的main函数是<code>main.main</code>，<code>runtime</code>中也有1个main函数——<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li><li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li><li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li><li>M运行G</li><li>G退出，再次回到M获取可运行的G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。</li></ol><p>调度器的生命周期几乎占满了一个Go程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p><h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5)可视化GMP编程"></a>(5)可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据。</p><p><strong>方式1：go tool trace</strong></p><p>trace记录了运行时的信息，能提供可视化的Web页面。</p><p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p><blockquote><p>trace.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run trace.go </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>会得到一个<code>trace.out</code>文件，然后我们可以用一个工具打开，来分析这个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go tool trace trace.out </span><br><span class="line">2020&#x2F;02&#x2F;23 10:44:11 Parsing trace...</span><br><span class="line">2020&#x2F;02&#x2F;23 10:44:11 Splitting trace...</span><br><span class="line">2020&#x2F;02&#x2F;23 10:44:11 Opening browser. Trace viewer is listening on http:&#x2F;&#x2F;127.0.0.1:33479</span><br></pre></td></tr></table></figure><p>我们可以通过浏览器打开<code>http://127.0.0.1:33479</code>网址，点击<code>view trace</code> 能够看见可视化的调度流程。</p><p><img src="https://img.kancloud.cn/ee/e8/eee828bc698d074e439f3e6929be74ef_2724x546.png" alt="img"></p><p><img src="https://img.kancloud.cn/25/ed/25ede16ec870076f211f8924c2c2bf6f_492x556.png" alt="img"></p><p><strong>G信息</strong></p><p>点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="https://img.kancloud.cn/87/e3/87e3994fbda4e883a8c51bea20dba91a_1168x372.png" alt="img"></p><p> 一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p><p>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p><p><strong>M信息</strong></p><p>点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="https://img.kancloud.cn/88/4f/884f6aa775a4596d3c8d4f9451d55e9b_1146x248.png" alt="img"></p><p> 一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</p><p><strong>P信息</strong></p><p><img src="https://img.kancloud.cn/5e/07/5e07a8515a023fcd10fbd8cf328b5d64_2736x224.png" alt="img"></p><p>G1中调用了<code>main.main</code>，创建了<code>trace goroutine g18</code>。G1运行在P1上，G18运行在P0上。</p><p>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</p><p>我们在来看看上面的M信息。</p><p><img src="https://img.kancloud.cn/6e/14/6e145c4c49656b77f9f2006733b88859_2142x466.png" alt="img"></p><p>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：<br><img src="https://img.kancloud.cn/19/60/19602c163ecfe63706e10cdc90e43794_1086x298.png" alt="img"></p><p>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p><p><strong>方式2：Debug trace</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build trace2.go</span><br></pre></td></tr></table></figure><p>通过Debug方式运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG&#x3D;schedtrace&#x3D;1000 .&#x2F;trace2 </span><br><span class="line">SCHED 0ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;1 idlethreads&#x3D;1 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><ul><li><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</li><li><code>0ms</code>：即从程序启动到输出这行日志的时间；</li><li><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</li><li><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</li><li>t<code>hreads: os threads/M</code>的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</li><li><code>spinningthreads</code>: 处于自旋状态的os thread数量；</li><li><code>idlethread</code>: 处于idle状态的os thread的数量；</li><li><code>runqueue=0</code>： Scheduler全局队列中G的数量；</li><li><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</li></ul><p>下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</p><h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><h3 id="1-场景1"><a href="#1-场景1" class="headerlink" title="(1)场景1"></a>(1)场景1</h3><p>P拥有G1，M1获取P后开始运行G1，G1使用<code>go func()</code>创建了G2，为了局部性G2优先加入到P1的本地队列。<br><img src="https://img.kancloud.cn/2d/eb/2debce43683adca1acb5ca5210057232_1074x900.png" alt="img"></p><hr><h3 id="2-场景2"><a href="#2-场景2" class="headerlink" title="(2)场景2"></a>(2)场景2</h3><blockquote><p>M1优先从本地队列取G，并且切换G时，通过G0来调度；</p></blockquote><p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。<br><img src="https://img.kancloud.cn/93/65/93658da22081d52ed1caf32f42145e5a_1624x984.png" alt="img"></p><hr><p>场景3，场景4，场景5是相连的；</p><h3 id="3-场景3"><a href="#3-场景3" class="headerlink" title="(3)场景3"></a>(3)场景3</h3><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。<br><img src="https://img.kancloud.cn/64/15/6415bfab3595fc22090595acc7c1b4b1_1104x1030.png" alt="img"></p><hr><h3 id="4-场景4"><a href="#4-场景4" class="headerlink" title="(4)场景4"></a>(4)场景4</h3><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行<strong>负载均衡</strong>(把P1中本地队列中前一半的G，还有新创建G<strong>转移</strong>到全局队列)</p><blockquote><p>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）<br><img src="https://img.kancloud.cn/d1/27/d12776bfd5cd10f8c1979c61d467499c_1120x1068.png" alt="img"></p></blockquote><p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p><hr><h3 id="5-场景5"><a href="#5-场景5" class="headerlink" title="(5)场景5"></a>(5)场景5</h3><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p><p><img src="https://img.kancloud.cn/7a/01/7a01ac7a3a4fd14493224827409f77f8_1036x1048.png" alt="img"></p><p> G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p><hr><h3 id="6-场景6"><a href="#6-场景6" class="headerlink" title="(6)场景6"></a>(6)场景6</h3><p>规定：<strong>在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行</strong>。</p><p><img src="https://img.kancloud.cn/60/6a/606acb1e4bf6b85c352b213744771601_1976x1098.png" alt="img"></p><p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程<strong>（没有G但为运行状态的线程，不断寻找G）</strong>。</p><hr><h3 id="7-场景7"><a href="#7-场景7" class="headerlink" title="(7)场景7"></a>(7)场景7</h3><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：<code>findrunnable()</code>）。M2从全局队列取的G数量符合下面的公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; min(len(GQ)&#x2F;GOMAXPROCS + 1, len(GQ&#x2F;2))</span><br></pre></td></tr></table></figure><p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。</p><p><img src="https://img.kancloud.cn/d6/46/d646d4d213d7b603f211cd74ba0dd391_1920x1080.jpeg" alt="img"></p><p> 假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p><hr><h3 id="8-场景8"><a href="#8-场景8" class="headerlink" title="(8)场景8"></a>(8)场景8</h3><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p><p><img src="https://img.kancloud.cn/8a/bf/8abf6b47b0871011b6f18f55365c1774_1632x1130.png" alt="img"></p><p> <strong>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列</strong>。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p><hr><h3 id="9-场景9"><a href="#9-场景9" class="headerlink" title="(9)场景9"></a>(9)场景9</h3><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于<strong>自旋状态</strong>，它们不断寻找goroutine。</p><p><img src="https://img.kancloud.cn/10/b4/10b49d04c42c3d688986ff41005ee63b_1682x1084.png" alt="img"></p><p> 为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU. 为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们<strong>希望当有新goroutine创建时，立刻能有M运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>GOMAXPROCS</code>个自旋的线程(当前例子中的<code>GOMAXPROCS</code>=4，所以一共4个P)，多余的没事做线程会让他们休眠。</p><hr><h3 id="10-场景10"><a href="#10-场景10" class="headerlink" title="(10)场景10"></a>(10)场景10</h3><p> 假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了<strong>阻塞的系统调用</strong>，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。<br><img src="https://img.kancloud.cn/54/9a/549aa458fab4c3e7cac5086d9326c1d2_2642x1494.png" alt="img"></p><hr><h3 id="11-场景11"><a href="#11-场景11" class="headerlink" title="(11)场景11"></a>(11)场景11</h3><p>G8创建了G9，假如G8进行了<strong>非阻塞系统调用</strong>。</p><p><img src="https://img.kancloud.cn/24/6c/246c03cdf1eb8307b70865d0debaa1f0_2678x1466.png" alt="img"></p><p> M2和P2会解绑，但M2会记住P2，然后G8和M2进入<strong>系统调用</strong>状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p><hr><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go_pro</title>
      <link href="2021/05/15/go-pro/"/>
      <url>2021/05/15/go-pro/</url>
      
        <content type="html"><![CDATA[<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-pro/01.png" alt="image-20210515221447881"></p><p>协议处理层： 支持各种协议</p><p>Controller： 服务入口，负责处理路由，参数校验，请求转发</p><p>Logic/Service: 逻辑（服务）层，负责处理业务逻辑</p><p>DAO/Repository: 负责数据与存储相关功能；（和数据库和缓存打交道）</p><h2 id="搭建通用脚手架模版"><a href="#搭建通用脚手架模版" class="headerlink" title="搭建通用脚手架模版"></a>搭建通用脚手架模版</h2><blockquote><p>一个通用的脚手架模版需要做那些年事情呢？</p></blockquote><ol><li><p>加载配置</p></li><li><p>初始化日志</p></li><li><p>初始化mysql</p></li><li><p>初始化redis</p></li><li><p>注册路由</p></li><li><p>启动服务 （优雅关机）</p></li></ol><h3 id="1-加载配置"><a href="#1-加载配置" class="headerlink" title="1. 加载配置"></a>1. 加载配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mkdir settings &amp;&amp; <span class="built_in">cd</span> settings &amp;&amp; touch settings.go</span><br><span class="line">$&gt; <span class="built_in">cd</span> settings &amp;&amp; touch config.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">"web_app"</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">"dev"</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">"debug"</span> <span class="comment"># 日志的级别</span></span><br><span class="line">  <span class="attr">filename:</span> <span class="string">"web_app.log"</span></span><br><span class="line">  <span class="attr">max_size:</span> <span class="number">200</span> <span class="comment"># 默认大小</span></span><br><span class="line">  <span class="attr">max_age:</span> <span class="number">30</span> <span class="comment"># 默认存储30天</span></span><br><span class="line">  <span class="attr">max_backups:</span> <span class="number">7</span></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">"3306"</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">dbname:</span> <span class="string">"pro"</span></span><br><span class="line">  <span class="attr">max_open_conns:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">max_idle_conns:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">"6379"</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">db:</span> <span class="number">0</span> <span class="comment"># 默认连0</span></span><br><span class="line">  <span class="attr">pool_size:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="2-初始化日志"><a href="#2-初始化日志" class="headerlink" title="2. 初始化日志"></a>2. 初始化日志</h3><h3 id="3-初始化mysql"><a href="#3-初始化mysql" class="headerlink" title="3. 初始化mysql"></a>3. 初始化mysql</h3><h4 id="3-1-建表语句"><a href="#3-1-建表语句" class="headerlink" title="3.1 建表语句"></a>3.1 建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>          <span class="built_in">bigint</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    user_id     <span class="built_in">bigint</span>                              <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    username    <span class="built_in">varchar</span>(<span class="number">64</span>)                         <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">password</span>    <span class="built_in">varchar</span>(<span class="number">64</span>)                         <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    email       <span class="built_in">varchar</span>(<span class="number">64</span>)                         <span class="literal">null</span>,</span><br><span class="line">    gender      <span class="built_in">tinyint</span>   <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    create_time <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="literal">null</span>,</span><br><span class="line">    update_time <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="literal">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">constraint</span> idx_user_id</span><br><span class="line">        <span class="keyword">unique</span> (user_id),</span><br><span class="line">    <span class="keyword">constraint</span> idx_username</span><br><span class="line">        <span class="keyword">unique</span> (username)</span><br><span class="line">)</span><br><span class="line">    <span class="keyword">collate</span> = utf8mb4_general_ci;</span><br></pre></td></tr></table></figure><h2 id="4-用户认证"><a href="#4-用户认证" class="headerlink" title="4. 用户认证"></a>4. 用户认证</h2><blockquote><p>http是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个IP不代表同一个用户），在web应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋；</p></blockquote><h3 id="4-1-Cookie-Session认证模式"><a href="#4-1-Cookie-Session认证模式" class="headerlink" title="4.1 Cookie-Session认证模式"></a>4.1 Cookie-Session认证模式</h3><blockquote><p>在web应用发展初期，大部分采用基于Cookie-Session的会话管理方式，逻辑如下</p></blockquote><ul><li>客户端使用用户名、密码进行认证</li><li>服务端验证用户名·密码正确后生成并存储session，将sessionID通过Cookie返回给客户端</li><li>客户端访问需要认证的接口时在Cookie中携带SessionID</li><li>服务端通过SessionID查找Session并进行鉴权，返回给客户端需要的数据</li></ul><p>基于Session方式存在多种问题</p><ul><li>服务端需要存储Session，并且由于Session需要经常快速查找，通常存储在内存或内存数据库中，同时在线用户较多时需要占用大量的服务器资源；</li><li>当需要扩展时，创建Session的服务器可能不是验证Session的服务器，所以还需要将所有Session单独存储并共享</li><li>由于客户端使用Cookie存储SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范CSRF攻击</li></ul><h3 id="4-2-Token认证模式"><a href="#4-2-Token认证模式" class="headerlink" title="4.2 Token认证模式"></a>4.2 Token认证模式</h3><blockquote><p>鉴于基于Session的会话管理方式存在上述多个缺点，基于Token的无状态会话管理方式诞生了，所谓无状态，就是服务端可以不再存储信息，甚至是不再存储Session，逻辑如下</p></blockquote><ul><li>客户端使用用户名， 密码进行认证</li><li>服务端验证username password正确后生成Token返回客户端</li><li>客户端保存Token，访问需要认证的接口时在URL参数或HTTP Header中加入Token</li><li>服务端通过解码Token进行鉴权，返回给客户端需要的数据</li></ul><p>基于Token的会话管理模式有效解决了基于Session的会话管理方式带来的问题</p><ul><li>服务端不需要存储和用户鉴权有关的信息，鉴权信息会被加密到Token中，服务端只需要读取Token中包含的鉴权信息即可</li><li>避免了共享Session导致的不易扩展的问题</li><li>不需要依赖Cookie，有效避免了Cookie带来的CSRF攻击问题</li><li>使用CORS可以快速解决跨域问题</li></ul><h3 id="4-3-JWT"><a href="#4-3-JWT" class="headerlink" title="4.3 JWT"></a>4.3 JWT</h3><blockquote><p> JWT是JSON Web Token的缩写，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准</p><p>JWT本身没有定义任何技术实现，它只是定义了一种基于Token的会话管理的规则，涵盖Token需要包含的标准内容和Token的生成过程，特别适用于分布式站点的单点登录（SSO）场景</p></blockquote><p>一个JWT Token就像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考davinci</span></span><br><span class="line">ey......</span><br></pre></td></tr></table></figure><p>它由 . 分隔的三部分组成，这三部分依次是</p><ul><li>头部（Header）</li><li>负载（Payload）</li><li>签名（Signature）</li></ul><p>头部和负载以JSON形式存在，这就是JWT中的JSON，三部分的内容都分别单独经过base64编码，以 . 拼接成一个JWT ；</p><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><blockquote><p>JWT的Header中存储了所使用的加密算法和Token类型</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><blockquote><p>Payload表示负载，也是一个JSON对象，JWT规定了7个官方字段供选用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss(issuer): 签发人</span><br><span class="line">exp(expiration time): 过期时间</span><br><span class="line">sub(subject): 主题</span><br><span class="line">aud (audience)： 受众</span><br><span class="line">nbf(Not Before)： 生效时间</span><br><span class="line">iat(Issued At)： 签发时间</span><br><span class="line">jti(JWT ID)： 编号</span><br></pre></td></tr></table></figure><p>除了官方字段，开发者也可以自己制定字段和内容，例如下面的内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"alex"</span>,</span><br><span class="line"><span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个JSON对象也要使用Base64URL算法转成字符串；</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><blockquote><p>Signature 部分好似对前两部分的签名，防止数据篡改</p></blockquote><p>首先，需要制定一个密钥（secret）这个密钥只有服务器才知道，不能泄漏给用户。然后，使用Header里面制定的签名算法（默认是HMAC SHA256），按照下面的共识产生签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header)+<span class="string">"."</span>+base64UrlEncode(payload),secret)</span><br></pre></td></tr></table></figure><h4 id="JWT优缺点"><a href="#JWT优缺点" class="headerlink" title="JWT优缺点"></a>JWT优缺点</h4><p>JWT拥有基于Token的会话管理方式所拥有的一切优势，不依赖Cookie，使其可以防止CSRF攻击，也能在禁用Cookie的浏览器环境中正常运行</p><p>而JWT的最大优势是服务端不再需要存储Session，使得服务端认证鉴权业务方便扩展，避免存储Session所需要引入的Redis等组件，降低了系统架构的复杂度，但也是JWT最大的劣势，由于有效期存储在Token中，JWT Token一旦签发，就会在有效期内一直可用，无法在服务端废止，当用户进行登出操作，只能依赖客户端删除本地存储的JWT Token，如果需要禁用用户，单纯使用JWT就无法做到了；</p><h4 id="基于JWT实现认证实践"><a href="#基于JWT实现认证实践" class="headerlink" title="基于JWT实现认证实践"></a>基于JWT实现认证实践</h4><blockquote><p>前面讲的Token，都是Access Token，也就是访问资源接口时所需要的Token，还有另外一种Token，Refresh Token，通常情况下，Refresh Token的有效期会比较长，而Access Token的有效期比较短，当Access Token由于过期而生效时，使用Refresh Token就可以获取新的Access Token，如果Refresh Token也失效了，用户就只能重新登录了；</p></blockquote><p>在JWT的实践中，引入Refresh Token，将会话管理流程改进如下</p><p>Access Token(访问token，客户端访问服务时需要携带)</p><ul><li>客户端使用用户名密码进行认证</li><li>服务端生成有效时间较短的Access Token（例如10分钟），和有效时间较长的Refresh Token（例如7天）</li><li>客户端访问需要认证的接口时，携带Access Token</li><li>如果Access Token没有过期，服务端鉴权后返回给客户端需要的数据</li><li>如果携带Access Token访问需要认证的接口时鉴权失败（例如返回401错误），则客户端使用Refresh Token向刷新接口申请新的Access Token</li><li>如果Refresh Token没有过期，服务端向客户端下发新的Access Token</li><li>客户端使用新的Access Token，访问需要认证的接口</li></ul><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-pro/03.png" alt="image-20210518143029179"></p><p>后端需要对外提供一个刷新Token的接口，前端需要实现一个当Access Token过期时自动请求刷新Token接口获取新Access Token的拦截器</p><h3 id="4-4-实践"><a href="#4-4-实践" class="headerlink" title="4.4 实践"></a>4.4 实践</h3><p>jwt-go这个库来实现生成JWT和解析JWT的功能；</p><p>基于Token的会话管理方式有效解决了基于Session的会话管理方式带来的问题；</p><h4 id="4-4-1-限制同一账号同一时间只能登录一个"><a href="#4-4-1-限制同一账号同一时间只能登录一个" class="headerlink" title="4.4.1 限制同一账号同一时间只能登录一个"></a>4.4.1 限制同一账号同一时间只能登录一个</h4><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-pro/04.png" alt="image-20210518144456976"></p><p>jwt方案的引入就是不想在服务端存储token，但一些需求比如限制同一账号同一时间只能登录一个的问题，既有的jwt方案就无法满足了；</p><p>它的实现规则是，在用户登录成功之后，服务端正常生成token，并做userid和token的关联。</p><p>等待后续，在下一个地点重新登录的时候，旧的userid 和 token关联就失效了；会建立新的userid和token关联；</p><h3 id="4-5-循环引用问题"><a href="#4-5-循环引用问题" class="headerlink" title="4.5 循环引用问题"></a>4.5 循环引用问题</h3><blockquote><p>什么时候会出现循环引用问题， import cycle not allowed</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> pro/controller </span><br><span class="line"><span class="keyword">import</span> pro/middlewares </span><br><span class="line"><span class="keyword">import</span> pro/controller</span><br></pre></td></tr></table></figure><p>middlewares 调用了 controller</p><p>在controller里面又调用了middlewares</p><p>a导入 b, b导入 a 就形成 循环引用 </p><h3 id="4-6"><a href="#4-6" class="headerlink" title="4.6"></a>4.6</h3><p>拿 前端处理大数字失真的问题</p><p>操作json的技巧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="keyword">int64</span> <span class="string">`json: "id,string"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知其然，知其所以然。 js的number是双精度的，取值范围在</p><p>-(2^52-1) 和 2^52-1 之间。服务端一旦超过，需要转string</p><p>然后更高级的操作，是顺带查资料总结一下go操作 json所有的用法；求知欲；</p><h2 id="5-makefile"><a href="#5-makefile" class="headerlink" title="5. makefile"></a>5. makefile</h2><blockquote><p>借助makefile，我们可以在编译过程中不再需要每次手动输入编译的命令和编译的参数，可以极大简化项目编译过程；</p></blockquote><p>make是一个构建自动化工具，会在当前目录下寻找makefile或Makefile文件，如果存在相应的文件，它就会依据其中定义好的规则完成构建任务；</p><h2 id="6-使用Air实现gin框架实时重新加载"><a href="#6-使用Air实现gin框架实时重新加载" class="headerlink" title="6. 使用Air实现gin框架实时重新加载"></a>6. 使用Air实现gin框架实时重新加载</h2><blockquote><p>Air能够实时监听项目的代码文件，在代码发生变更之后自动重新编译并执行，大大提高gin框架项目的开发效率</p></blockquote><h2 id="7-vote"><a href="#7-vote" class="headerlink" title="7 vote"></a>7 vote</h2><p>功能提炼： 谁给哪个帖子投了什么票</p><p>谁 -&gt; userID  （登陆到系统的当前用户）</p><p>哪个帖子 -&gt; postID (帖子ID)</p><p>什么票 -&gt; 1/-1 (赞/踩)</p><p>zset：有序的集合，给key存值的时候，可以给值指定分数。届时根据值的大小从高到低或者从低到高去查询；</p><p>这里用两个zset来存储相关数据，实现vote功能；</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-pro/05.png" alt="image-20210519222022418"></p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-pro/06.png" alt="image-20210519222038734"></p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-pro/07.png" alt="image-20210519224933315"></p><p>给某个帖子投票的用户有哪些？</p><p>设计redis key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  KeyPrefix = <span class="string">"pro:"</span></span><br><span class="line">  KeyPostTimeZSet = <span class="string">"pro:time"</span> <span class="comment">// zset 帖子以及发帖时间</span></span><br><span class="line">  KeyPostScoreZSet = <span class="string">"pro:score"</span> <span class="comment">// zset 帖子以及投票的分数</span></span><br><span class="line">  KeyPostVotedPrefix = <span class="string">"pro:voted:"</span> <span class="comment">//zset 记录用户以及投票类型，参数是post_id</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hooks</title>
      <link href="2021/05/12/hooks/"/>
      <url>2021/05/12/hooks/</url>
      
        <content type="html"><![CDATA[<h2 id="简版hooks实现"><a href="#简版hooks实现" class="headerlink" title="简版hooks实现"></a>简版hooks实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TEXT_ELEMENT = <span class="string">"TEXT_ELEMENT"</span>;</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 定义一个引用用来保存最近一次commit给DOM时的fiber tree并且当此fiber tree在完成commit之后。</span></span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 定义一个数组来跟踪要删除的节点</span></span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDOM</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type === TEXT_ELEMENT</span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">""</span>) <span class="comment">// nodeValue 可以直接赋值</span></span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type);</span><br><span class="line"></span><br><span class="line">  updateDOM(dom, &#123;&#125;, fiber.props);</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// alternate 连接 上个阶段 commit 给DOM 的 fiber，</span></span><br><span class="line">    alternate: currentRoot,</span><br><span class="line">  &#125;;</span><br><span class="line">  deletions = [];</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we recursively append all the nodes to the dom.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  deletions.forEach(commitWork);</span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  <span class="comment">// 当最近一次fiber tree完成commit之后, 保存该fiber tree的引用</span></span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">dom</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>alternateProps 上一次commit的fiber</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">props</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event 类型的props，需要以不同的方式处理他们；</span></span><br><span class="line"><span class="keyword">const</span> isEvent = <span class="function">(<span class="params">key</span>) =&gt;</span> key.startsWith(<span class="string">"on"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isProperty</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key !== <span class="string">"children"</span> &amp;&amp; !isEvent(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个updateDOM的作用在于，比较新旧两次fiber， 删除已经移除的props，</span></span><br><span class="line"><span class="comment">// set新的props或者更新的props</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOM</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Remove old or changed event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps)(key))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove old properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">""</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set new or changed properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// commitWork 需要重构，重构的根据就是 fiber上面的 effectTag</span></span><br><span class="line">  <span class="comment">// 而不在是全部不分青红皂白，domParent.appendChild(fiber.dom) 了</span></span><br><span class="line">  <span class="comment">// 'UPDATE' | 'PLACEMENT' | 'DELETION'</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> domParentFiber = fiber.parent;</span><br><span class="line">  <span class="comment">// 因为有function 组件的存在，比如App，App就不是一个合法的tag</span></span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent; <span class="comment">// 如果App节点没有dom，那么就递归网上找</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.dom;</span><br><span class="line">  <span class="comment">// 新增没什么好说的，add</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">"PLACEMENT"</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">"DELETION"</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除也没什么好说的</span></span><br><span class="line">    domParent.removeChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">"UPDATE"</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// update 操作</span></span><br><span class="line">    updateDOM(fiber.dom, fiber.alternate.props, fiber.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfwork(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// And once we finish all the work</span></span><br><span class="line">  <span class="comment">//(we know it because there isn’t a next unit of work)</span></span><br><span class="line">  <span class="comment">// we commit the whole fiber tree to the DOM.</span></span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    commitRoot();</span><br><span class="line">  &#125;</span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动任务</span></span><br><span class="line">requestIdleCallback(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfwork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加处理原生节点和function component的逻辑判断</span></span><br><span class="line">  <span class="keyword">const</span> isFunctionComponent = fiber.type <span class="keyword">instanceof</span> <span class="built_in">Function</span>;</span><br><span class="line">  <span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fiber);</span><br><span class="line">    updateFunctionComponent(fiber);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们还向fiber 添加了一个hooks数组，以支持在同一</span></span><br><span class="line">  <span class="comment">// 组件中多次调用useState。并且我们跟踪当前的 hookIndex。</span></span><br><span class="line">  wipFiber = fiber;</span><br><span class="line">  hookIndex = <span class="number">0</span>;</span><br><span class="line">  wipFiber.hooks = [];</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)];</span><br><span class="line">  reconcileChildren(fiber, children);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当函数组件调用useState，</span></span><br><span class="line"><span class="comment">// 检查是否有 old hook</span></span><br><span class="line"><span class="comment">// 依据hookIndex 检查 fiber的 alternate</span></span><br><span class="line"><span class="comment">// 如果有old hook，复制其state到新hook中， 如果没初始化state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex];</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    state: oldHook ? oldHook.state : initial,</span><br><span class="line">    queue: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> actions = oldHook ? oldHook.queue : [];</span><br><span class="line">  actions.forEach(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    hook.state = action(hook.state);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    hook.queue.push(action);</span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      dom: currentRoot.dom,</span><br><span class="line">      props: currentRoot.props,</span><br><span class="line">      alternate: currentRoot,</span><br><span class="line">    &#125;;</span><br><span class="line">    nextUnitOfWork = wipRoot;</span><br><span class="line">    deletions = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  wipFiber.hooks.push(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.state, setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDOM(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  reconcileChildren(fiber, elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  reconcile old fiber and new elements</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// element 是需要渲染到DOM的东西，而oldFiber是上次渲染的东西</span></span><br><span class="line">    <span class="comment">// 需要比较 element 和 oldFiber的差异来决定是否需要对DOM进行修改</span></span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type;</span><br><span class="line">    <span class="comment">// 如果oldFiber 和 element 拥有同样的type，保持这个DOM 节点，仅仅更新props即可</span></span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      <span class="comment">// update the node</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="comment">// type: element.type,</span></span><br><span class="line">        type: oldFiber.type, <span class="comment">// 既然是更新，那type不用改</span></span><br><span class="line">        props: element.props, <span class="comment">// props用 新的</span></span><br><span class="line">        dom: oldFiber.dom,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: oldFiber, <span class="comment">// newFiber alternate 指回 oldFiber</span></span><br><span class="line">        effectTag: <span class="string">"UPDATE"</span>, <span class="comment">// 在commit阶段需要使用的属性，</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果type不同，是个新的element，</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// add this node</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: element.type,</span><br><span class="line">        props: element.props, <span class="comment">// props用 新的</span></span><br><span class="line">        dom: <span class="literal">null</span>,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: <span class="literal">null</span>,</span><br><span class="line">        effectTag: <span class="string">"PLACEMENT"</span>, <span class="comment">// 在commit阶段需要使用的属性，</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果type不同，old filber存在</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// delete the oldFiber's node</span></span><br><span class="line">      <span class="comment">// delete的时候，是没有 element的，只有oldFiber,所以标记需要加到oldFiber上</span></span><br><span class="line">      oldFiber.effectTag = <span class="string">"DELETION"</span>;</span><br><span class="line">      deletions.push(oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// react用 key属性体现在这里，就是为了更好的reconciliation，比如子节点</span></span><br><span class="line">    <span class="comment">// 只是在element array中改变位置；如果没有key，那便意味着当child只是移动位置</span></span><br><span class="line">    <span class="comment">// 但在diff时候无法判断，就只能 做update node的操作；</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      wipFiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">  useState,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: children.map(<span class="function">(<span class="params">child</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">"object"</span> ? child : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: TEXT_ELEMENT,</span><br><span class="line">    props: &#123;</span><br><span class="line">      nodeValue: text, <span class="comment">// 只能给createTextNode 创建的节点赋值</span></span><br><span class="line">      children: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> Didact.createElement(</span><br><span class="line">    <span class="string">"h1"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      onClick: <span class="function"><span class="params">()</span> =&gt;</span> setState(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"Count: "</span>,</span><br><span class="line">    state</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(Counter, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">Didact.render(element, container);</span><br></pre></td></tr></table></figure><h2 id="hook代码组织构成"><a href="#hook代码组织构成" class="headerlink" title="hook代码组织构成"></a>hook代码组织构成</h2><p>UI = fn(state)</p><p>fn接受全局状态，这个函数调用的结果就是视图的UI</p><p>this.setState的调用就是这个函数的快门</p><p>state：Reconciler</p><p>计算出状态变化；</p><p>在Reconciler中会执行一个被称为reconcile的算法，也就是常说的diff算法；</p><p>fn：Renderer</p><p>将状态变化渲染在视图中；</p><p>用户调用this.setState =&gt; 进入reconcile部分计算出状态变化 =&gt; 将状态变化渲染在视图中；</p><p>状态变化会进入渲染器并被渲染在视图中；</p><p>代码在reconcile中被称render阶段，组件的render函数就是在这个阶段被调用</p><p>代码在Renderer中执行时，被称为commit阶段；是因为可以将状态变化的提交类比于代码提交的git commit命令；</p><h2 id="生命周期函数调用过程"><a href="#生命周期函数调用过程" class="headerlink" title="生命周期函数调用过程"></a>生命周期函数调用过程</h2><p><img src="1.png" alt="image-20210513153515363"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root = App</span><br><span class="line">App.child = P1</span><br><span class="line">P1.sbling = P2</span><br><span class="line">P1.child = C1</span><br><span class="line">C1.sbling = C2</span><br></pre></td></tr></table></figure><ol><li>调用ReactDOM.render，</li><li>进入render阶段，</li><li>采用深度优先遍历创建fiber树，即虚拟DOM树</li><li>在深度遍历时，会针对每个fiber进行执行声明周期函数（constructor，getDerivedStateFromProp/componentWillMount/render）</li><li>render阶段完成进入commit阶段，首先会将fiber树对应的DOM渲染到视图中；渲染完成后，我们会从子节点开始执行对应的生命周期函数componentDidMount,顺着子节点依次回溯到根节点；</li><li>这次交互会调用this.setState，交互结果是将C2从蓝色变为绿色,此时重新进入render阶段</li><li>依旧是深度优先遍历的方式，创建一个fiber树，首先创建App节点，然后是P1，C1。 每次调用setState时都会创建一课完整的fiber树，接着是兄弟节点C2，此时reconcile算法发现了C2存在更新的副作用， reconcile算法标记变化；然后调用C2的生命周期函数(getDerivedStateFromProps/render),当render完成之后，再次进入commit阶段</li><li>执行reconcile算法标记的变化对应的视图操作，即DOM操作，然后执行此节点对应的生命周期函数。</li><li>执行完毕之后，这颗fiber树又会替换掉之前的那一颗fiber树；等待下一次调用this.setState再生成一颗新的fiber树；</li></ol><h2 id="this-setState同步还是异步"><a href="#this-setState同步还是异步" class="headerlink" title="this.setState同步还是异步"></a>this.setState同步还是异步</h2><p>react的三种不同模式</p><p>legacy模式：<code>ReactDOM.render(&lt;App/&gt;, rootNode)</code> ,当前React app使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能</p><p>blocking模式：<code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App/&gt;)</code>实验中，作为迁移到concurrent模式的第一个步骤</p><p>concurrent模式：<code>ReactDOM.createRoot(rootNode).render(&lt;App/&gt;)</code>实验中，未来稳定之后，打算作为React默认开发模式，这个模式开启了所有的新功能；</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">updateNum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'before setState'</span>, <span class="keyword">this</span>.state.num);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after setState'</span>, <span class="keyword">this</span>.state.num);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"AppClass render "</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;this.updateNum&#125;</span>&gt;</span>hello &#123;num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AppClass render 0</span></span><br><span class="line"><span class="comment">// before setState 0</span></span><br><span class="line"><span class="comment">// after setState 0</span></span><br><span class="line"><span class="comment">// AppClass render 1</span></span><br></pre></td></tr></table></figure><p>从这个demo可以看出，setState是异步的。造成这个结果的原因是，react中对setState有一个优化措施，即batchedUpstates(批处理) 如果当前触发了多个setState，但也会触发一次render，这是因为react将多次setState合并成了一次更新。这样就能提高react的性能；</p><p><strong>批处理的实现</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># react/ReactFiberWorkLoop.js</span></span><br><span class="line">一个函数调用栈周期内的 作用域会有一个BatchedContext flag，此时，该调用栈中所有setState会被合并成一个；</span><br><span class="line">因此，当切换函数调用栈的时候，作用域中自然不会有同一个BatchedContext flag；当不存在此flag时，react中有一个源码叫scheduleUpdateOnFiber，</span><br><span class="line"><span class="keyword">if</span>(executionContext === NoContext) &#123;</span><br><span class="line">resetRenderTimer();</span><br><span class="line">flushSyncCallbackQueue(); <span class="comment"># 同步直接更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">updateNum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'before setState'</span>, <span class="keyword">this</span>.state.num);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'after setState'</span>, <span class="keyword">this</span>.state.num);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"AppClass render "</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;this.updateNum&#125;</span>&gt;</span>hello &#123;num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AppClass render 0</span></span><br><span class="line"><span class="comment">// before setState 0</span></span><br><span class="line"><span class="comment">// AppClass render 1</span></span><br><span class="line"><span class="comment">// after setState 1</span></span><br></pre></td></tr></table></figure><p>总结，不同模式。setState是不同的，legacy模式下，当代码命中batchedUpdates时是异步，没命中便是同步；</p><p>对于Concurrent模式来说，都是异步的；</p><h2 id="useEffect-fn-与-componentDidMount-的区别"><a href="#useEffect-fn-与-componentDidMount-的区别" class="headerlink" title="useEffect(fn, []) 与 componentDidMount 的区别"></a>useEffect(fn, []) 与 componentDidMount 的区别</h2><p>探讨的其实是fn与componentDidMount的执行时机有什么不同，对于useEffect的回调函数来说，他的执行是依赖于他的第二个参数也就是他的依赖项的。</p><p>所以，此问题可以概括为</p><ol><li><p>useEffect 第二个参数[] 是如何影响fn的执行？</p><p>第二个参数是如何影响对应的fiber创建Passive effect的呢？</p><p>第一种情况，不包含第二个参数，他会在mount时以及update时创建对应的Passive effect，也就是说，如果一个函数组件使用了第一种情况。每次render时都会创建一个Passive effect。</p><p>第二种情况，包含一个空数组作一个依赖项。那么他会在mount时创建Passive effect；</p><p>第三种情况，那么他会在mount时以及依赖项发生变化时创建， </p></li><li><p>fn和component的执行时机</p></li></ol><p>回顾上面生命周期，react中render阶段是如何将状态变化传递给commit阶段的呢？</p><p>是通过在fiber上搭载被叫做effect（新版叫flags）的数据结构，</p><ul><li>插入DOM     Placement</li><li>更新DOM    Update</li><li>删除DOM     Deletion</li><li>更新Ref        Ref</li><li>useEffect     Passive</li></ul><p><img src="2.png" alt="image-20210513191829800"></p><p>左边是更新前的fiber树，右边是更新后的fiber树；</p><p>我们从最后一个字节点开始C2，代表有DOM属性变化，标记Update effect，P2之前不存在，标记Placement，</p><p>App这个节点，它在之后的fiber上包含了useEffect的执行。所以它会被标记Passive effect，这些不同fiber节点的effect会通过一条链条连接在一起；</p><ul><li>所以render阶段与commit阶段之间，传递的是什么</li></ul><p>传递的是一条包含了不同fiber节点的effect的链表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Passive ---&gt; Placement ---&gt; Update</span><br></pre></td></tr></table></figure><p>之后进入commit阶段，是如何处理这条链表上的每个effect的呢？</p><p>commit阶段要做的事将effect渲染到视图中</p><p>简单将commit阶段分为三个子阶段</p><ol><li>渲染视图前（beforeMutation）</li><li>渲染视图 （mutation）</li><li>渲染视图后 （layout）</li></ol><p>对于placement来说，它会在mutation阶段执行对应DOM节点appendChild操作。这样DOM节点就会被插入到视图中。接下来会在layout阶段调用componentDIdMount。</p><p>而对于我们的Passive effect来说，它会在commit阶段的三个子阶段执行完成之后。异步调用useEffect回调。</p><p>所以对于开篇的疑问，useEffect和componentDidMount有什么区别？</p><p>​    首先useEffect会在commit节点执行完之后，异步的调用回调函数。而componentDidMount则会在layout这个子阶段同步的调用；可见他们的调用时机是完全不同的。那么有没有什么hook它的调用时机和componentDidMount是一致呢？</p><p>这就是useLayoutEffect它也会在layout阶段同步调用；</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js_async</title>
      <link href="2021/05/10/js-async/"/>
      <url>2021/05/10/js-async/</url>
      
        <content type="html"><![CDATA[<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>从一个例子开始</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop0</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  loop0()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(loop1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout(loop2, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">loop0()</span><br><span class="line">loop1()</span><br><span class="line">loop2()</span><br></pre></td></tr></table></figure><p>在浏览器那个章节，我们已经提到过这三个function在渲染进程的执行情况；</p><p>首先loop0函数会栈溢出，这个几乎任何编程语言都会如此；</p><p>其次loop1，因为在切换下一个宏任务之前，要清空当前宏任务的微任务队列。由于loop1函数不断的产生微任务，导致当前宏任务的调用栈无法释放。下一个宏任务永远无法得到调用；所以在浏览器上的表现是block渲染进程，页面进入假死状态</p><p>最后loop2函数，该函数的执行会创造新的宏任务，由于宏任务的切换是根消息队列有关系的。此消息队列有一定的事件优先级。所以loop2这种代码从形式上来讲是合法的代码，只是0毫秒的间隔时间，js引擎并不会严格执行，这个还需要参考当前消息队列实际情况来定；</p><p>众所周知，js是单线程的语言。它原生不支持多线程并发。这与当初js的定位有关系，决定了它单线程的特性；</p><p>但就算是单线程的环境，依然存在异步任务的需求，比如我要在三秒之后执行弹窗脚本，或者我需要用户第一个请求的结果信息作为第二个请求的headers，这些都是异步的需求；</p><p>那根据js提供的消息队列机制；</p><p>宏任务有着强制性的优先级；</p><p>微任务，更细粒度的调度，在当前宏任务执行完毕之前全部执行完毕；</p><p>开发者，只有这两把武器，那么该如何使用好这两把武器来组织好代码；</p><h2 id="如何组织异步代码"><a href="#如何组织异步代码" class="headerlink" title="如何组织异步代码"></a>如何组织异步代码</h2><h3 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a>1. 回调函数</h3><p>提到回到函数，上面的loop0，loop1, loop2。loop2是最安全的回调方式。因为我们并不能控制使用者在回调函数中传回来什么，调用者可以清晰堵死当前调用栈；</p><p>如果我们在回调函数的外层，加上setTimeout等将任务放入消息队列。那么我们便可以实现异步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数解决了异步问题，但是有一个问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">ball, act, cb</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> left = <span class="built_in">parseInt</span>(ball.style.marginLeft);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; act) &#123;</span><br><span class="line">      ball.style.marginLeft = (left + <span class="number">1</span>)+<span class="string">'px'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearInterval(Timer);</span><br><span class="line">      cb();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(ball1, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  move(ball2, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    move(ball3, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'over'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的代码，明显就不太合理了。我相信大多数开发者都不想自己的工程上充斥这样的代码；</p><h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h3><p>结合上面的代码，setTimeout既然给的0毫秒，那么调用者肯定是希望立即执行的；那样的话，其实使用微任务做异步也是可以的。这里便引入promise</p><p>Promise在最新版本的chrome浏览器已经被实现了。我们先来看一下Promise异步代码的写法；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">ball, act</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> Timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index++ &lt; act) &#123;</span><br><span class="line">        ball.style.transform = <span class="string">`translateX(<span class="subst">$&#123;index&#125;</span>px)`</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearInterval(Timer);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(ball1, <span class="number">500</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> move(ball2, <span class="number">500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> move(ball3, <span class="number">500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"over"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>Promise的then方法的写法比回调嵌套地狱要好上很多；</p><p>下面探讨一下Promise的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>; <span class="comment">//初始状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>; <span class="comment">// 缓存</span></span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  <span class="comment">// 定义存放成功的回调的数组</span></span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line">  <span class="comment">// 定义存放失败的回调的数组</span></span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line">  <span class="comment">// 当调用此方法的时候，如果promise状态为pending的话，可以转成成功态， 如果已经是成功态或者失败态了，则什么都不做；</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 2.1.1</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是初始态，则转成成功态</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === PENDING) &#123;</span><br><span class="line">      self.status = FULFILLED;</span><br><span class="line">      self.value = value <span class="comment">// 成功后会得到一个值，这个值不能改</span></span><br><span class="line">      <span class="comment">// 调用所有成功的回调</span></span><br><span class="line">      self.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123; <span class="comment">// 2.1.2</span></span><br><span class="line">    <span class="comment">// 初始态变失败态</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      self.status = REJECTED;</span><br><span class="line">      self.value = reason; <span class="comment">// 失败的原因给了value</span></span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 因为 此函数执行可能会异常，所以需要捕获，如果出错了，需要用错误对象 reject；</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 如果这函数执行失败了，则用失败的原因 reject这个promise</span></span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(promise2 === x) <span class="comment">// 如果promise2 和 x指向了相同的对象， reject promise with a TypeError as the reason.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// promise2 是否已经 resolve 或者 reject</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(x!= <span class="literal">null</span> &amp;&amp; ((<span class="keyword">typeof</span> x === <span class="string">'object'</span>) || (<span class="keyword">typeof</span> x === <span class="string">'function'</span>)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 当我们的promise 和别的promise 进行交互；编写这段代码的时候尽量的考虑兼容性，允许别人瞎写</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="comment">// 有些promise 会同时执行成功和失败的回调</span></span><br><span class="line">        then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 如果promise2 已经成功或失败了，则不会再处理了</span></span><br><span class="line">          <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          resolvePromise(promise2, y, resolve, reject); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 到此的话，x不是一个thenable 对象，那直接把它当成值 resolve promise2 就可以了</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);  <span class="comment">// 如果x是一个普通的值，则用x的值去 resolve promise2 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果成功和失败的回调没有传，则表示这个then 没有任何逻辑，只会把值往后抛；</span></span><br><span class="line">  <span class="comment">// 2.2.1</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected: <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2.3.1  it must be called after promise is rejected, with promise’s reason as its first argument.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === FULFILLED) &#123; <span class="comment">// 如果当前promise 状态已经是成功态了， onFulfilled直接取值；</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 因为onFulfilled 有可能 异常，所以这里需要 trycatch</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">          <span class="comment">// 如果获取到了 返回值，会走解析promise的过程。 因为x可能是个普通值，也可能是个promise对象，也可能是个thenable对象（别人的写的promise），最终需要实现各种不同的promise实现之间的交互。</span></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// 如果执行成功的回调 过程中出错了，用错误原因把promise2 reject掉</span></span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">      self.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch 原理就是只传失败的回调</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onReject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(<span class="literal">null</span>, onReject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defer = &#123;&#125;; <span class="comment">// 延迟对象，Q  angular 里面用的多</span></span><br><span class="line">  defer.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    defer.resolve = resolve;</span><br><span class="line">    defer.reject = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> defer;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">times, cb</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result=  [], count =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">i, data</span>)</span>&#123;</span><br><span class="line">    result[i] = data;</span><br><span class="line">    <span class="keyword">if</span> (++count === times)&#123;</span><br><span class="line">      cb(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> done = gen(promises.length, resolve)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        done(i, data);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race =<span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个立即成功的promise对象</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个立即失败的promise对象</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试脚本</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * promises-aplus-tests Promise.js</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-gen-promise"><a href="#3-gen-promise" class="headerlink" title="3. gen+promise"></a>3. gen+promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">ball, act</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> Timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(index++ &lt; act) &#123;</span><br><span class="line">        ball.style.transform = <span class="string">`translateX(<span class="subst">$&#123;index&#125;</span>px)`</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearInterval(Timer);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">4</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> move(ball1, <span class="number">500</span>);</span><br><span class="line">  <span class="keyword">yield</span> move(ball2, <span class="number">500</span>);</span><br><span class="line">  <span class="keyword">yield</span> move(ball3, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run 即 co库的核心实现，因为gen不会自己执行，所以需要有一个迭代器帮它执行完毕；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> it = gen(); <span class="comment">// 让生成器持续自执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    !<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">lastVal</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;value, done&#125; = it.next(lastVal);</span><br><span class="line">      <span class="keyword">if</span>(done) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value.then(next, reject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(go)</span><br></pre></td></tr></table></figure><h3 id="4-async-await"><a href="#4-async-await" class="headerlink" title="4. async+await"></a>4. async+await</h3><blockquote><p>Async await 是 gen+promise的语法糖</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">ball, act</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> Timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(index++ &lt; act) &#123;</span><br><span class="line">        ball.style.transform = <span class="string">`translateX(<span class="subst">$&#123;index&#125;</span>px)`</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearInterval(Timer);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">4</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> move(ball1, <span class="number">500</span>);</span><br><span class="line">  <span class="keyword">await</span> move(ball2, <span class="number">500</span>);</span><br><span class="line">  <span class="keyword">await</span> move(ball3, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go()</span><br></pre></td></tr></table></figure><p>至此，单线程JavaScript的异步代码组织方式就告一段落了。相比回调地狱，async+await的方式在组织代码的方式上好了太多；</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="2021/05/10/mysql/"/>
      <url>2021/05/10/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库能够做什么"><a href="#1-数据库能够做什么" class="headerlink" title="1. 数据库能够做什么"></a>1. 数据库能够做什么</h2><ul><li>存储大量数据，方便检索和访问</li><li>保持数据信息的一致、完整</li><li>共享和安全</li><li>通过组合分析，产生新的有用信息</li></ul><h2 id="2-数据库的基本概念"><a href="#2-数据库的基本概念" class="headerlink" title="2. 数据库的基本概念"></a>2. 数据库的基本概念</h2><h3 id="2-1-实体"><a href="#2-1-实体" class="headerlink" title="2.1 实体"></a>2.1 实体</h3><p>只要是在客观世界存在的、可以被描述出来的都是实体</p><h3 id="2-2-数据库-DB"><a href="#2-2-数据库-DB" class="headerlink" title="2.2 数据库(DB)"></a>2.2 数据库(DB)</h3><ul><li>数据库就是数据的仓库，可以存放结构化的数据</li></ul><h3 id="2-3-数据库管理系统-DBMS"><a href="#2-3-数据库管理系统-DBMS" class="headerlink" title="2.3 数据库管理系统(DBMS)"></a>2.3 数据库管理系统(DBMS)</h3><p>是一种系统软件，提供操作数据库的环境，可以通过数据库管理系统对数据进行插入、修改、删除和查询等操作。</p><h3 id="2-4-SQL"><a href="#2-4-SQL" class="headerlink" title="2.4 SQL"></a>2.4 SQL</h3><p>结构化查询语言 专门用来和数据库进行交流的语言,几乎所有的DBMS都支持SQL</p><p><img src="1.png" alt="dbms"></p><h3 id="2-5-SQL规范"><a href="#2-5-SQL规范" class="headerlink" title="2.5 SQL规范"></a>2.5 SQL规范</h3><ol><li>SQL语句不区分大小写，建议SQL关键字大写，表名和列表小写</li><li>命令用分号结尾</li><li>命令可以缩进和换行，一种类型的关键字放在一行</li><li>可以写单行和多行注释 , #和–是单行注释，/***/多行注释</li></ol><h2 id="3-数据表"><a href="#3-数据表" class="headerlink" title="3. 数据表"></a>3. 数据表</h2><ul><li>表是数据库中包含所有数据的数据库对象，也是其它对象的基础。</li><li>表定义是一个列的集合，数据在表中是按行和列的格式组织的，用来存放数据</li><li>行也称为记录用来存放一个个实体，列称为字段用来描述实体的某一个属性 学生管理系统2</li></ul><h2 id="4-MYSQL简介"><a href="#4-MYSQL简介" class="headerlink" title="4.MYSQL简介"></a>4.MYSQL简介</h2><h3 id="4-1-MYSQL特点"><a href="#4-1-MYSQL特点" class="headerlink" title="4.1 MYSQL特点"></a>4.1 MYSQL特点</h3><ul><li>开源免费</li><li>性能高</li><li>安装使用都简单</li></ul><h3 id="4-2-MYSQL安装"><a href="#4-2-MYSQL安装" class="headerlink" title="4.2 MYSQL安装"></a>4.2 MYSQL安装</h3><ul><li><a href="https://dev.mysql.com/downloads/mysql/5.5.html" target="_blank" rel="noopener">mysql下载</a></li><li>安装MYSQL</li></ul><h3 id="4-3-MYSQL配置"><a href="#4-3-MYSQL配置" class="headerlink" title="4.3 MYSQL配置"></a>4.3 MYSQL配置</h3><p>C:\Program Files\MySQL\MySQL Server 5.5\my.ini</p><ul><li>port 端口号</li><li>basedir 安装目录</li><li>datadir 数据存放访目录</li><li>character_set_server 字符集</li><li>default-storage-engine 存储引擎</li><li>sql-mode 语法模式</li><li>max-connections 最大连接数</li></ul><h3 id="4-4-MYSQL启动和停止"><a href="#4-4-MYSQL启动和停止" class="headerlink" title="4.4 MYSQL启动和停止"></a>4.4 MYSQL启动和停止</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start MySQL</span><br><span class="line">net stop MySQL</span><br></pre></td></tr></table></figure><h3 id="4-5-通过命令行连接MYSQL"><a href="#4-5-通过命令行连接MYSQL" class="headerlink" title="4.5 通过命令行连接MYSQL"></a>4.5 通过命令行连接MYSQL</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -P <span class="number">3306</span> -uroot -p123456</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="4-6-切换数据库"><a href="#4-6-切换数据库" class="headerlink" title="4.6 切换数据库"></a>4.6 切换数据库</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br></pre></td></tr></table></figure><h3 id="4-7-显示有哪些表"><a href="#4-7-显示有哪些表" class="headerlink" title="4.7 显示有哪些表"></a>4.7 显示有哪些表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br><span class="line">show tables <span class="keyword">from</span> mysql;</span><br></pre></td></tr></table></figure><h3 id="4-8-显示当前数据库"><a href="#4-8-显示当前数据库" class="headerlink" title="4.8 显示当前数据库"></a>4.8 显示当前数据库</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><h3 id="4-9-查询表结构"><a href="#4-9-查询表结构" class="headerlink" title="4.9 查询表结构"></a>4.9 查询表结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC user;</span><br></pre></td></tr></table></figure><h2 id="5-创建表"><a href="#5-创建表" class="headerlink" title="5. 创建表"></a>5. 创建表</h2><p><img src="2.png" alt="student"> <img src="3.png" alt="course"> <img src="4.png" alt="score"></p><h2 id="6-数据完整性"><a href="#6-数据完整性" class="headerlink" title="6. 数据完整性"></a>6. 数据完整性</h2><ul><li>为了实现数据完整性，需要检验数据库表中的每行和每列数据是否符合要求</li><li>在创建表的时候，应该保证以后的数据输入是正确的，错误的数据不允许输入</li></ul><h3 id="6-1-域完整性"><a href="#6-1-域完整性" class="headerlink" title="6.1 域完整性"></a>6.1 域完整性</h3><p>不同的字段需要设置为各种合适的类型，比如年龄就是整数类型</p><p><img src="5.jpeg" alt="datatype"></p><p><img src="6.jpeg" alt="mysqlint"></p><p><img src="7.jpeg" alt="mysqlnumber"></p><h3 id="6-2-默认值"><a href="#6-2-默认值" class="headerlink" title="6.2 默认值"></a>6.2 默认值</h3><p>默认值是指如果用户没有指定值的情况下会记录的此字段指定一个提供一个预先设定的值</p><blockquote><p>可以把居住地默认值设置为北京</p></blockquote><h3 id="6-3-非空约束"><a href="#6-3-非空约束" class="headerlink" title="6.3 非空约束"></a>6.3 非空约束</h3><p>我们可以指定某个字段不能不输入，必须提供一个非空的值</p><blockquote><p>姓名字段不能为空</p></blockquote><h2 id="7-实体完整性"><a href="#7-实体完整性" class="headerlink" title="7.实体完整性"></a>7.实体完整性</h2><h3 id="7-1-主键约束"><a href="#7-1-主键约束" class="headerlink" title="7.1 主键约束"></a>7.1 主键约束</h3><ul><li>表中一列或者几列组合的值能用来唯一标识表中的每一行，这样的列或者列组合称为表的主键，主键表的数据不同重复。</li><li>如果两列或者多列组合起来唯一标识表中的每一行，则该主键又称为”组合键”</li></ul><p><strong>主键的选择标准</strong></p><ol><li>最少性 尽量选择单个键作为主键</li><li>稳定性 ，由于主键是用来在两个表间建立联接的，所以不能经常更新，最好就不更新</li></ol><h3 id="7-2-外键"><a href="#7-2-外键" class="headerlink" title="7.2 外键"></a>7.2 外键</h3><p>成绩表中的学生ID应该在学生表中是存在的 我们应该让成绩表中的ID只能引用学生表中的ID，它们的值应该是一一对应的，也就是说成绩表中的ID是成绩表中的外键，对应学生表的主键 ，这样就可以保证数据的引用完整性</p><h3 id="7-3-唯一约束"><a href="#7-3-唯一约束" class="headerlink" title="7.3 唯一约束"></a>7.3 唯一约束</h3><p>唯一约束是指某个字段值是唯一的，在所有的记录中不能有重复的值.</p><blockquote><p>学生的身份证号可以设置为唯一约束</p></blockquote><h3 id="7-4-标识列"><a href="#7-4-标识列" class="headerlink" title="7.4 标识列"></a>7.4 标识列</h3><ul><li>当表中没有合适的列作为主键时可以考虑增加标识列，标识列是一个无实际业务含义的列，仅仅用来区分每条记录。</li><li>标识列的值是自动生成的，不能在该列上输入数据</li></ul><h3 id="7-5-外键约束"><a href="#7-5-外键约束" class="headerlink" title="7.5 外键约束"></a>7.5 外键约束</h3><p>一个表的外键必须引用另一个表的主键,比如成绩表中的学生ID会引用学生表的主键，课程ID会引用成绩表的主键</p><ul><li>主表没有记录，子表中不能添加相应的记录</li><li>修改和删除主表记录不能让子表记录孤立，必须相应修改和删除</li></ul><h2 id="8-数据操作"><a href="#8-数据操作" class="headerlink" title="8. 数据操作"></a>8. 数据操作</h2><h3 id="8-1-创建学生表"><a href="#8-1-创建学生表" class="headerlink" title="8.1 创建学生表"></a>8.1 创建学生表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line"><span class="string">`id`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT   ,</span><br><span class="line"><span class="string">`name`</span>  <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`age`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`city`</span>  <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">'北京'</span> ,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="8-2-增加身份证号字段"><a href="#8-2-增加身份证号字段" class="headerlink" title="8.2 增加身份证号字段"></a>8.2 增加身份证号字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`idcard`</span>  <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="literal">NULL</span> <span class="keyword">AFTER</span> <span class="string">`city`</span>; <span class="comment">--增加身份证字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="string">`idcard`</span>  <span class="built_in">varchar</span>(<span class="number">18</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">AFTER</span> <span class="string">`name`</span>; <span class="comment">--修改身份证字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="string">`idcard`</span>; <span class="comment">--删除身份证字段</span></span><br></pre></td></tr></table></figure><h3 id="8-3-添加约束"><a href="#8-3-添加约束" class="headerlink" title="8.3 添加约束"></a>8.3 添加约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="comment">-- 唯一约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`uq_idcard`</span> (<span class="string">`idcard`</span>) ;</span><br><span class="line"><span class="comment">-- 默认约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="string">`city`</span>  <span class="built_in">varchar</span>(<span class="number">50</span>)  <span class="keyword">DEFAULT</span> <span class="string">'北京'</span> <span class="keyword">AFTER</span> <span class="string">`age`</span>;</span><br><span class="line"><span class="comment">-- 外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_stuid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`student_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`student`</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="comment">-- 删除约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_stuid`</span>;</span><br></pre></td></tr></table></figure><h3 id="8-4-准备数据"><a href="#8-4-准备数据" class="headerlink" title="8.4 准备数据"></a>8.4 准备数据</h3><p><img src="8.png" alt="relations"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`idcard`</span> <span class="built_in">varchar</span>(<span class="number">18</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`grade`</span> <span class="built_in">float</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>,<span class="string">`course_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_courseid`</span> (<span class="string">`course_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_courseid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`course_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`course`</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_stuid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`student_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`student`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h2 id="9-SQL"><a href="#9-SQL" class="headerlink" title="9. SQL"></a>9. SQL</h2><h3 id="9-1-SQL是什么"><a href="#9-1-SQL是什么" class="headerlink" title="9.1 SQL是什么"></a>9.1 SQL是什么</h3><p>Structured Query Language：结构化查询语言</p><h3 id="9-2-为什么要用SQL"><a href="#9-2-为什么要用SQL" class="headerlink" title="9.2 为什么要用SQL"></a>9.2 为什么要用SQL</h3><ol><li>使用界面操作数据库不方便</li><li>我们需要通过应用程序去操作数据库</li></ol><h3 id="9-3-SQL组成"><a href="#9-3-SQL组成" class="headerlink" title="9.3 SQL组成"></a>9.3 SQL组成</h3><h4 id="9-3-1-DDL（data-definition-language）是数据定义语言"><a href="#9-3-1-DDL（data-definition-language）是数据定义语言" class="headerlink" title="9.3.1 DDL（data definition language）是数据定义语言"></a>9.3.1 DDL（data definition language）是数据定义语言</h4><p>主要的命令有<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等，<strong>DDL</strong>主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用</p><h4 id="9-3-2-DML（data-manipulation-language）是数据操纵语言"><a href="#9-3-2-DML（data-manipulation-language）是数据操纵语言" class="headerlink" title="9.3.2 DML（data manipulation language）是数据操纵语言"></a>9.3.2 DML（data manipulation language）是数据操纵语言</h4><p>它们是<code>SELECT</code>、<code>UPDATE、</code>INSERT<code>、</code>DELETE`，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</p><h4 id="9-3-3-DCL（DataControlLanguage）是数据库控制语言"><a href="#9-3-3-DCL（DataControlLanguage）是数据库控制语言" class="headerlink" title="9.3.3 DCL（DataControlLanguage）是数据库控制语言"></a>9.3.3 DCL（DataControlLanguage）是数据库控制语言</h4><p>是用来设置或更改数据库用户或角色权限的语句，包括（<code>grant</code>,<code>revoke</code>等）语句</p><h3 id="9-4-SQL运算符"><a href="#9-4-SQL运算符" class="headerlink" title="9.4 SQL运算符"></a>9.4 SQL运算符</h3><p>是一种符号，它是用来进行列间或者变量之间的比较和数学运算的</p><h3 id="9-4-1-算术运算符"><a href="#9-4-1-算术运算符" class="headerlink" title="9.4.1 算术运算符"></a>9.4.1 算术运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加运算，求两个数或表达式相加的和，如1+1</td></tr><tr><td align="left">-</td><td align="left">减少减运算，求两个数或表达式相减的差，如4-1</td></tr><tr><td align="left">*</td><td align="left">乘运算，求两个数或表达式相乘的积，如2*2</td></tr><tr><td align="left">/</td><td align="left">除运算，求两个数或表达式相除的商，如6/4的值为1</td></tr><tr><td align="left">%</td><td align="left">取模运算，求两个数或表达式相除的余数，如：6%4的值为2</td></tr></tbody></table><ul><li>查询姓名全称</li></ul><h3 id="9-4-2-逻辑运算符"><a href="#9-4-2-逻辑运算符" class="headerlink" title="9.4.2 逻辑运算符"></a>9.4.2 逻辑运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">AND</td><td align="left">当且仅当两个布尔表达式都为true时，返回TRUE</td></tr><tr><td align="left">OR</td><td align="left">当且仅当两个布尔表达式都为false，返回FALSE</td></tr><tr><td align="left">NOT</td><td align="left">布尔表达式的值取反</td></tr></tbody></table><h3 id="9-4-3-比较运算符"><a href="#9-4-3-比较运算符" class="headerlink" title="9.4.3 比较运算符"></a>9.4.3 比较运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等于</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">!=</td><td align="left">不等于</td></tr></tbody></table><h2 id="9-5-查询窗口"><a href="#9-5-查询窗口" class="headerlink" title="9.5 查询窗口"></a>9.5 查询窗口</h2><p><img src="9.png" alt="query"></p><h2 id="9-6-数据操作语言"><a href="#9-6-数据操作语言" class="headerlink" title="9.6 数据操作语言"></a>9.6 数据操作语言</h2><h3 id="9-6-1-插入数据行"><a href="#9-6-1-插入数据行" class="headerlink" title="9.6.1 插入数据行"></a>9.6.1 插入数据行</h3><h4 id="9-6-1-1-语法"><a href="#9-6-1-1-语法" class="headerlink" title="9.6.1.1 语法"></a>9.6.1.1 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>  [<span class="keyword">INTO</span>]  表名  [(列名)] <span class="keyword">VALUES</span>  (值列表)</span><br></pre></td></tr></table></figure><h4 id="9-6-1-2-插入记录"><a href="#9-6-1-2-插入记录" class="headerlink" title="9.6.1.2 插入记录"></a>9.6.1.2 插入记录</h4><p>向学生表插入一条记录, 姓名张三,身份证号123456,年龄30,城市北京</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [school].[student]</span><br><span class="line">(<span class="keyword">name</span>,idcard,age,city)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'张三'</span>,<span class="string">'123456'</span>,<span class="number">30</span>,<span class="string">'北京'</span>)</span><br></pre></td></tr></table></figure><h4 id="9-6-1-3-注意事项"><a href="#9-6-1-3-注意事项" class="headerlink" title="9.6.1.3 注意事项"></a>9.6.1.3 注意事项</h4><ul><li>每次插入一行数据，不能只插入一部分数据，插入的数据是否有效将按照整行的完整性要求来检验</li><li>每个数据值的数据类型、精度、位数必须与要应的列名精确匹配</li><li>不能为标识符指定值</li><li>如果某字段设置为不能为空，则必须插入数据</li><li>插入数据时还要符合检查性约束的要求</li><li>有缺省值的列，可以使用DEFAULT关键字来代替插入实际的值</li></ul><h3 id="9-6-2-更新数据行"><a href="#9-6-2-更新数据行" class="headerlink" title="9.6.2 更新数据行"></a>9.6.2 更新数据行</h3><h4 id="9-6-2-1-语法"><a href="#9-6-2-1-语法" class="headerlink" title="9.6.2.1 语法"></a>9.6.2.1 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名 = 更新值 [<span class="keyword">WHERE</span> 更新条件]</span><br></pre></td></tr></table></figure><h4 id="9-6-2-2-更新记录"><a href="#9-6-2-2-更新记录" class="headerlink" title="9.6.2.2 更新记录"></a>9.6.2.2 更新记录</h4><ul><li><p>更新ID等于7的学生年龄改为40，城市改为上海</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [school].[student]</span><br><span class="line"> <span class="keyword">SET</span> age = <span class="number">40</span>,city = <span class="string">'上海'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-6-2-3-注意"><a href="#9-6-2-3-注意" class="headerlink" title="9.6.2.3 注意"></a>9.6.2.3 注意</h4><ul><li>多列时用逗号隔开，一定要加更新条件以免错误更新</li><li>多个联合条件使用 AND <code>id=7 and idcard=&#39;410787&#39;</code></li><li>判断某字段是否为空 <code>email is null or email = &#39;&#39;</code></li></ul><h3 id="9-6-3-删除数据"><a href="#9-6-3-删除数据" class="headerlink" title="9.6.3 删除数据"></a>9.6.3 删除数据</h3><h4 id="9-6-3-1-语法"><a href="#9-6-3-1-语法" class="headerlink" title="9.6.3.1 语法"></a>9.6.3.1 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> [<span class="keyword">FROM</span>]  表名 [<span class="keyword">WHERE</span> &lt;删除条件&gt;]</span><br></pre></td></tr></table></figure><h4 id="9-6-3-2-删除记录"><a href="#9-6-3-2-删除记录" class="headerlink" title="9.6.3.2 删除记录"></a>9.6.3.2 删除记录</h4><ul><li><p>删除ID=7的学生记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [school].[student] <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-6-3-3-注意"><a href="#9-6-3-3-注意" class="headerlink" title="9.6.3.3 注意"></a>9.6.3.3 注意</h4><ul><li>Delete语句是对整行进行操作，因此不需要提供列名</li><li>如果要删除主表数据，则要先删除子表记录</li></ul><h3 id="9-6-4-TRUNCATE-截断表"><a href="#9-6-4-TRUNCATE-截断表" class="headerlink" title="9.6.4 TRUNCATE 截断表"></a>9.6.4 TRUNCATE 截断表</h3><p>截断整个表中的数据</p><h4 id="9-6-4-1-语法"><a href="#9-6-4-1-语法" class="headerlink" title="9.6.4.1 语法"></a>9.6.4.1 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span>  <span class="keyword">TABLE</span>  表名</span><br></pre></td></tr></table></figure><h4 id="9-6-4-2-截断学生表"><a href="#9-6-4-2-截断学生表" class="headerlink" title="9.6.4.2 截断学生表"></a>9.6.4.2 截断学生表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> student</span><br></pre></td></tr></table></figure><blockquote><p>数据全部清空,但表结构、列、约束等不被改动 不能用于有外键约束引用的表 标识列重新开始编号 因为要删除的数据不会写入日志，数据也不能恢复，所以工作中请尽量不要使用此命令</p></blockquote><h2 id="9-7-数据查询"><a href="#9-7-数据查询" class="headerlink" title="9.7 数据查询"></a>9.7 数据查询</h2><ul><li>查询就是从客户端 发出查询请求数据库服务器，并从数据库返回查询结果的过程</li><li>每次执行查询只是从数据表中提取数据，并按表的方式呈现出来</li><li>查询产生的是虚拟表,并不会保存起来</li></ul><h3 id="9-7-1-查询"><a href="#9-7-1-查询" class="headerlink" title="9.7.1 查询"></a>9.7.1 查询</h3><h4 id="9-7-1-1-语法"><a href="#9-7-1-1-语法" class="headerlink" title="9.7.1.1 语法"></a>9.7.1.1 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>    &lt;列名&gt; </span><br><span class="line"><span class="keyword">FROM</span>      &lt;表名&gt; </span><br><span class="line">[<span class="keyword">WHERE</span>    &lt;查询条件表达式&gt;] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序的列名&gt;[<span class="keyword">ASC</span>或<span class="keyword">DESC</span>]]</span><br></pre></td></tr></table></figure><h4 id="9-7-1-2-排序"><a href="#9-7-1-2-排序" class="headerlink" title="9.7.1.2 排序"></a>9.7.1.2 排序</h4><ul><li><p>查询北京的学生信息，并按ID正序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,idcard,age,city</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> home= <span class="string">'北京'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">asc</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="10.png" alt=""></p><h4 id="9-7-1-3-别名"><a href="#9-7-1-3-别名" class="headerlink" title="9.7.1.3 别名"></a>9.7.1.3 别名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,idcard,age,city <span class="keyword">AS</span> home</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> city= <span class="string">'山东'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><h4 id="9-7-1-4-查询空行"><a href="#9-7-1-4-查询空行" class="headerlink" title="9.7.1.4 查询空行"></a>9.7.1.4 查询空行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age,city</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> city <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> city =<span class="string">''</span></span><br></pre></td></tr></table></figure><h4 id="9-7-1-5-常量列"><a href="#9-7-1-5-常量列" class="headerlink" title="9.7.1.5 常量列"></a>9.7.1.5 常量列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age,city,<span class="string">'中国'</span> <span class="keyword">as</span> country</span><br><span class="line"><span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure><h4 id="9-7-1-6-限制返回的行数"><a href="#9-7-1-6-限制返回的行数" class="headerlink" title="9.7.1.6 限制返回的行数"></a>9.7.1.6 限制返回的行数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age,city,<span class="string">'中国'</span> <span class="keyword">as</span> country</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">limit</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="9-7-1-7-DISTINCT"><a href="#9-7-1-7-DISTINCT" class="headerlink" title="9.7.1.7 DISTINCT"></a>9.7.1.7 DISTINCT</h4><ul><li><p>查询同学们一共来自哪些不同的城市</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age,<span class="keyword">DISTINCT</span> city,<span class="string">'中国'</span> <span class="keyword">as</span> country</span><br><span class="line"><span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-7-1-8"><a href="#9-7-1-8" class="headerlink" title="9.7.1.8 +"></a>9.7.1.8 +</h4><ul><li><p>在MYSQL中+号只能用作于数字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>+<span class="string">'1'</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>+<span class="string">'zfpx'</span>  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>+<span class="literal">null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(last_name,first_name) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-7-1-7-练习"><a href="#9-7-1-7-练习" class="headerlink" title="9.7.1.7 练习"></a>9.7.1.7 练习</h3><h4 id="9-7-1-7-1-准备数据"><a href="#9-7-1-7-1-准备数据" class="headerlink" title="9.7.1.7.1 准备数据"></a>9.7.1.7.1 准备数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`province`</span>  <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">AFTER</span> <span class="string">`city`</span>,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`birthday`</span>  <span class="built_in">date</span> <span class="literal">NULL</span> <span class="keyword">AFTER</span> <span class="string">`province`</span>,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`gender`</span>   <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">AFTER</span> <span class="string">`birthday`</span>,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`email`</span>  <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">AFTER</span> <span class="string">`gender`</span>;</span><br></pre></td></tr></table></figure><p><img src="11.png" alt="studenttable"> <img src="12.png" alt="coursetable"> <img src="13.png" alt="scoretable"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,gender,age,city,province,birthday,idcard,email) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'郭靖'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'济南'</span>, <span class="string">'山东省'</span>, <span class="string">'1982-09-03'</span>, <span class="number">1</span>, <span class="string">'1@qq.com'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,gender,age,city,province,birthday,idcard,email) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'黄蓉'</span>, <span class="string">'2'</span>, <span class="string">'2'</span>, <span class="string">'济南'</span>, <span class="string">'山东省'</span>, <span class="string">'1982-09-03'</span>, <span class="number">0</span>, <span class="string">'2@qq.com'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,gender,age,city,province,birthday,idcard,email) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'杨过'</span>, <span class="string">'3'</span>, <span class="string">'3'</span>, <span class="string">'终南山'</span>, <span class="string">'陕西省'</span>, <span class="string">'1979-09-03'</span>, <span class="number">1</span>, <span class="string">'3@qq.com'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,gender,age,city,province,birthday,idcard,email) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'小龙女'</span>, <span class="string">'4'</span>, <span class="string">'4'</span>, <span class="string">'终南山'</span>, <span class="string">'陕西省'</span>, <span class="string">'1970-09-03'</span>, <span class="number">0</span>, <span class="string">'4@qq.com'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,gender,age,city,province,birthday,idcard,email) <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'欧阳锋'</span>, <span class="string">'5'</span>, <span class="string">'5'</span>, <span class="string">'白驼山'</span>, <span class="string">'新疆'</span>, <span class="string">'1989-09-09'</span>, <span class="number">1</span>, <span class="string">'5@qq.com'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'语文'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'数学'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'英语'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'100'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'90'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'70'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'100'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'2'</span>, <span class="string">'90'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'80'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="string">'100'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="string">'90'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'3'</span>, <span class="string">'80'</span>);</span><br></pre></td></tr></table></figure><h4 id="9-7-1-7-2-查询山东省的同学全部信息"><a href="#9-7-1-7-2-查询山东省的同学全部信息" class="headerlink" title="9.7.1.7.2 查询山东省的同学全部信息"></a>9.7.1.7.2 查询山东省的同学全部信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> province = <span class="string">'山东'</span>;</span><br></pre></td></tr></table></figure><h4 id="9-7-1-7-3-查询山东省的男同学的全部信息"><a href="#9-7-1-7-3-查询山东省的男同学的全部信息" class="headerlink" title="9.7.1.7.3 查询山东省的男同学的全部信息"></a>9.7.1.7.3 查询山东省的男同学的全部信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> province = <span class="string">'山东'</span> <span class="keyword">and</span> gender=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="9-7-1-7-4-查询没有填写电子邮箱的同学的姓名和身份证号"><a href="#9-7-1-7-4-查询没有填写电子邮箱的同学的姓名和身份证号" class="headerlink" title="9.7.1.7.4 查询没有填写电子邮箱的同学的姓名和身份证号"></a>9.7.1.7.4 查询没有填写电子邮箱的同学的姓名和身份证号</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,idcard <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h3 id="9-7-1-8-排序"><a href="#9-7-1-8-排序" class="headerlink" title="9.7.1.8 排序"></a>9.7.1.8 排序</h3><h4 id="9-7-1-8-1-把学生的分数按升序排列"><a href="#9-7-1-8-1-把学生的分数按升序排列" class="headerlink" title="9.7.1.8.1 把学生的分数按升序排列"></a>9.7.1.8.1 把学生的分数按升序排列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> grade <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><h4 id="9-7-1-8-2-把学生的分数按降序排列"><a href="#9-7-1-8-2-把学生的分数按降序排列" class="headerlink" title="9.7.1.8.2 把学生的分数按降序排列"></a>9.7.1.8.2 把学生的分数按降序排列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> grade <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h4 id="9-7-1-8-3-课程编号按升序，成绩按降序"><a href="#9-7-1-8-3-课程编号按升序，成绩按降序" class="headerlink" title="9.7.1.8.3 课程编号按升序，成绩按降序"></a>9.7.1.8.3 课程编号按升序，成绩按降序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> course_id <span class="keyword">asc</span>, grade <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h2 id="9-8-函数"><a href="#9-8-函数" class="headerlink" title="9.8 函数"></a>9.8 函数</h2><h3 id="9-8-1-字符函数"><a href="#9-8-1-字符函数" class="headerlink" title="9.8.1 字符函数"></a>9.8.1 字符函数</h3><table><thead><tr><th align="left">函数名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">CONCAT</td><td align="left">字符串连接</td></tr><tr><td align="left">CONCAT_WS</td><td align="left">使用指定的分隔符进行字符连接</td></tr><tr><td align="left">FORMAT</td><td align="left">数字格式化</td></tr><tr><td align="left">LOWER</td><td align="left">转小写字母</td></tr><tr><td align="left">UPPER</td><td align="left">转大写字母</td></tr><tr><td align="left">LEFT</td><td align="left">返回字符串s开始的最左边n个字符</td></tr><tr><td align="left">RIGHT</td><td align="left">返回字符串s开始的最左边n个字符</td></tr></tbody></table><h4 id="9-8-1-1-LENGTH"><a href="#9-8-1-1-LENGTH" class="headerlink" title="9.8.1.1 LENGTH"></a>9.8.1.1 LENGTH</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">'zfpx'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">'珠峰培训'</span>);</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'%char%'</span>;</span><br></pre></td></tr></table></figure><h4 id="9-8-1-2-拼接字符串-CONCAT"><a href="#9-8-1-2-拼接字符串-CONCAT" class="headerlink" title="9.8.1.2 拼接字符串 [CONCAT]"></a>9.8.1.2 拼接字符串 [CONCAT]</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(last_name,<span class="string">'_'</span>,first_name) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h4 id="9-8-1-3-拼接字符串-UPPER"><a href="#9-8-1-3-拼接字符串-UPPER" class="headerlink" title="9.8.1.3 拼接字符串 [UPPER]"></a>9.8.1.3 拼接字符串 [UPPER]</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UPPER</span>(<span class="string">'zfpx'</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h4 id="9-8-1-4-拼接字符串-LOWER"><a href="#9-8-1-4-拼接字符串-LOWER" class="headerlink" title="9.8.1.4 拼接字符串 [LOWER]"></a>9.8.1.4 拼接字符串 [LOWER]</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LOWER</span>(<span class="string">'ZFPX'</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h4 id="9-8-1-5-截取字符串-SUBSTR"><a href="#9-8-1-5-截取字符串-SUBSTR" class="headerlink" title="9.8.1.5 截取字符串 [SUBSTR]"></a>9.8.1.5 截取字符串 [SUBSTR]</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">'zfpx'</span>,<span class="number">2</span>);<span class="comment">-- 截取从指定索引处开始的所有的字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">'zfpx'</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">--截取从指定索引处开始的指定数量的字符</span></span><br></pre></td></tr></table></figure><h4 id="9-8-1-6-姓名的首字符大写，其它字符小写然后用-拼接"><a href="#9-8-1-6-姓名的首字符大写，其它字符小写然后用-拼接" class="headerlink" title="9.8.1.6 姓名的首字符大写，其它字符小写然后用_拼接"></a>9.8.1.6 姓名的首字符大写，其它字符小写然后用_拼接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">UPPER</span>(<span class="keyword">SUBSTR</span>(last_name,<span class="number">1</span>,<span class="number">1</span>)),<span class="string">'_'</span>,<span class="keyword">LOWER</span>(<span class="keyword">SUBSTR</span>(last_name,<span class="number">2</span>)));</span><br></pre></td></tr></table></figure><h4 id="9-8-1-7-返回子串在原始字符串的起始索引"><a href="#9-8-1-7-返回子串在原始字符串的起始索引" class="headerlink" title="9.8.1.7 返回子串在原始字符串的起始索引"></a>9.8.1.7 返回子串在原始字符串的起始索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSTR</span>(<span class="string">'zfpx'</span>,<span class="string">'f'</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-1-8-去掉左右空格-TRIM"><a href="#9-8-1-8-去掉左右空格-TRIM" class="headerlink" title="9.8.1.8 去掉左右空格[TRIM]"></a>9.8.1.8 去掉左右空格[TRIM]</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">'  zfpx  '</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LTRIM</span>(<span class="string">'  zfpx  '</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RTRIM</span>(<span class="string">'  zfpx  '</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">'x'</span> <span class="keyword">FROM</span> <span class="string">'xxzfpxxx'</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-1-9-用空格补齐-LPAD"><a href="#9-8-1-9-用空格补齐-LPAD" class="headerlink" title="9.8.1.9 用空格补齐[LPAD]"></a>9.8.1.9 用空格补齐[LPAD]</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">'zfpx'</span>,<span class="number">10</span>,<span class="string">'@'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">'1'</span>,<span class="number">8</span>,<span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">'1'</span>,<span class="number">8</span>,<span class="string">'0'</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-1-10-替换"><a href="#9-8-1-10-替换" class="headerlink" title="9.8.1.10 替换"></a>9.8.1.10 替换</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">REPLACE</span>(<span class="string">'zfpx'</span>,<span class="string">'f'</span>,<span class="string">'q'</span>)</span><br></pre></td></tr></table></figure><h4 id="9-8-1-11-FORMAT"><a href="#9-8-1-11-FORMAT" class="headerlink" title="9.8.1.11 FORMAT"></a>9.8.1.11 FORMAT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">100000</span>,<span class="number">2</span>); 100,000.00</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">format</span>(<span class="number">100.31111</span>,<span class="number">2</span>) <span class="number">100.31</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">format</span>(<span class="number">100.31111</span>,<span class="number">0</span>); 100</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">423423234.65534453</span>,<span class="number">2</span>); 423,423,234.66</span><br></pre></td></tr></table></figure><h4 id="9-8-1-12-LEFT-RIGHT"><a href="#9-8-1-12-LEFT-RIGHT" class="headerlink" title="9.8.1.12 LEFT RIGHT"></a>9.8.1.12 LEFT RIGHT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(<span class="string">'abcde12345'</span>,<span class="number">5</span>);   //abcde</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(<span class="string">'abcde12345'</span>,<span class="number">5</span>);   //12345</span><br></pre></td></tr></table></figure><h3 id="9-8-2-数学函数"><a href="#9-8-2-数学函数" class="headerlink" title="9.8.2 数学函数"></a>9.8.2 数学函数</h3><table><thead><tr><th align="left">函数名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">CEIL</td><td align="left">向上取整</td></tr><tr><td align="left">FLOOR</td><td align="left">向下取整数</td></tr><tr><td align="left">DIV</td><td align="left">整数取</td></tr><tr><td align="left">MOD</td><td align="left">取余(取模)</td></tr><tr><td align="left">POWER</td><td align="left">幂运算</td></tr><tr><td align="left">ROUND</td><td align="left">四舍五入</td></tr><tr><td align="left">TRUNCATE</td><td align="left">数字截取</td></tr></tbody></table><h4 id="9-8-2-1-四舍五入"><a href="#9-8-2-1-四舍五入" class="headerlink" title="9.8.2.1 四舍五入"></a>9.8.2.1 四舍五入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">2.5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">2.555</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-2-2-向上取整"><a href="#9-8-2-2-向上取整" class="headerlink" title="9.8.2.2 向上取整"></a>9.8.2.2 向上取整</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">1.00</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-2-3-向下取整"><a href="#9-8-2-3-向下取整" class="headerlink" title="9.8.2.3 向下取整"></a>9.8.2.3 向下取整</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">1.00</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-2-4-截断"><a href="#9-8-2-4-截断" class="headerlink" title="9.8.2.4 截断"></a>9.8.2.4 截断</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-2-5-取余"><a href="#9-8-2-5-取余" class="headerlink" title="9.8.2.5 取余"></a>9.8.2.5 取余</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">mod</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="9-8-3-日期函数"><a href="#9-8-3-日期函数" class="headerlink" title="9.8.3 日期函数"></a>9.8.3 日期函数</h3><table><thead><tr><th align="left">函数名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">NOW</td><td align="left">当前日期和时间</td></tr><tr><td align="left">CURDATE</td><td align="left">当前日期</td></tr><tr><td align="left">CURTIME</td><td align="left">当前时间</td></tr><tr><td align="left">DATE_ADD</td><td align="left">日期变化</td></tr><tr><td align="left">DATEDIFF</td><td align="left">计算日期差</td></tr><tr><td align="left">DATE_FORMAT</td><td align="left">日期格式化</td></tr></tbody></table><h4 id="9-8-3-1-返回日期时间"><a href="#9-8-3-1-返回日期时间" class="headerlink" title="9.8.3.1 返回日期时间"></a>9.8.3.1 返回日期时间</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>():</span><br></pre></td></tr></table></figure><h4 id="9-8-3-2-返回日期"><a href="#9-8-3-2-返回日期" class="headerlink" title="9.8.3.2 返回日期"></a>9.8.3.2 返回日期</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURDATE</span>():</span><br></pre></td></tr></table></figure><h4 id="9-8-3-3-返回日期"><a href="#9-8-3-3-返回日期" class="headerlink" title="9.8.3.3 返回日期"></a>9.8.3.3 返回日期</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURTIME</span>():</span><br></pre></td></tr></table></figure><h4 id="9-8-3-4-返回日期中指定的部分"><a href="#9-8-3-4-返回日期中指定的部分" class="headerlink" title="9.8.3.4 返回日期中指定的部分"></a>9.8.3.4 返回日期中指定的部分</h4><p>年 月 日 小时 分钟 秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure><h4 id="9-8-3-5-str-to-date"><a href="#9-8-3-5-str-to-date" class="headerlink" title="9.8.3.5 str_to_date"></a>9.8.3.5 str_to_date</h4><p>将日期格式的字符串转成指定格式的日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">'2018-09-09'</span>,<span class="string">'%Y-%m-%d'</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">序号</th><th align="left">格式符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">%Y</td><td align="left">4位的年份</td></tr><tr><td align="left">2</td><td align="left">%y</td><td align="left">2位的年份</td></tr><tr><td align="left">3</td><td align="left">%m</td><td align="left">月份(01,02)</td></tr><tr><td align="left">4</td><td align="left">%c</td><td align="left">月份(1,2)</td></tr><tr><td align="left">5</td><td align="left">%d</td><td align="left">日(01,02)</td></tr><tr><td align="left">6</td><td align="left">%H</td><td align="left">小时(24小时制)</td></tr><tr><td align="left">7</td><td align="left">%h</td><td align="left">小时(12小时制)</td></tr><tr><td align="left">8</td><td align="left">%i</td><td align="left">分钟(00,01)</td></tr><tr><td align="left">9</td><td align="left">%s</td><td align="left">秒(00,01)</td></tr></tbody></table><h4 id="9-8-3-6"><a href="#9-8-3-6" class="headerlink" title="9.8.3.6"></a>9.8.3.6</h4><p>查询入职日期为1984-8-4的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> hiredate = <span class="keyword">STR_TO_DATE</span>(<span class="string">'12-30 1984'</span>,<span class="string">'%m-%d %Y'</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-3-7-DATE-FORMAT"><a href="#9-8-3-7-DATE-FORMAT" class="headerlink" title="9.8.3.7 DATE_FORMAT"></a>9.8.3.7 DATE_FORMAT</h4><p>将日期转换成指定字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y年%m月%d日'</span>)</span><br></pre></td></tr></table></figure><h4 id="9-8-3-8-DATE-ADD"><a href="#9-8-3-8-DATE-ADD" class="headerlink" title="9.8.3.8 DATE_ADD"></a>9.8.3.8 DATE_ADD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(),<span class="built_in">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(),<span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(),<span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-3-9-DATEDIFF"><a href="#9-8-3-9-DATEDIFF" class="headerlink" title="9.8.3.9 DATEDIFF"></a>9.8.3.9 DATEDIFF</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(<span class="string">'2019-1-1'</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure><h3 id="9-8-4-其它函数"><a href="#9-8-4-其它函数" class="headerlink" title="9.8.4 其它函数"></a>9.8.4 其它函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONNECTION_ID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">LAST_INSERT_ID</span>();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MD5</span>(<span class="string">'123456'</span>);//摘要算法</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">PASSWORD</span>(<span class="string">'123456'</span>);//修改当前用户的密码</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span>,<span class="keyword">Password</span> <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure><h3 id="9-8-5-流程控制函数"><a href="#9-8-5-流程控制函数" class="headerlink" title="9.8.5 流程控制函数"></a>9.8.5 流程控制函数</h3><h4 id="9-8-5-1-IF"><a href="#9-8-5-1-IF" class="headerlink" title="9.8.5.1 IF"></a>9.8.5.1 IF</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="number">1</span>&gt;<span class="number">0</span>,<span class="string">'A'</span>,<span class="string">'B'</span>);</span><br></pre></td></tr></table></figure><h4 id="9-8-5-2-CASE函数"><a href="#9-8-5-2-CASE函数" class="headerlink" title="9.8.5.2 CASE函数"></a>9.8.5.2 CASE函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CASE 要判断的字段和表达式</span><br><span class="line">WHEN 常量1 then 要显示的值或语句1</span><br><span class="line">WHEN 常量2 then 要显示的值或语句2</span><br><span class="line">ELSE 要显示的值</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> grade&lt;<span class="number">60</span> <span class="keyword">then</span> <span class="string">'不及格'</span></span><br><span class="line"><span class="keyword">WHEN</span> grade&gt;=<span class="number">60</span> <span class="keyword">then</span> <span class="string">'及格'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'未知'</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span> score;</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">level</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'A'</span> <span class="keyword">then</span> <span class="string">'优秀'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'B'</span> <span class="keyword">then</span> <span class="string">'良好'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'未知'</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span> score;</span><br></pre></td></tr></table></figure><h3 id="9-9-自定义函数"><a href="#9-9-自定义函数" class="headerlink" title="9.9 自定义函数"></a>9.9 自定义函数</h3><ul><li>自定义函数是对MySQL的扩展，使用方式和内置函数相同</li><li>函数必须要有参数和返回值</li><li>函数可以接收任意类型的值，也可以接收这些类型的参数</li><li>函数体由合法的SQL语句组成</li><li>函数体可以是简单的SELECT语句或INSERT语句，如果是复合结构要用BEGIN…END</li><li>函数体也可以包含声明，循环和流程控制</li><li>返回值只能有一个</li></ul><h4 id="9-9-1-语法"><a href="#9-9-1-语法" class="headerlink" title="9.9.1 语法"></a>9.9.1 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> func_name() <span class="keyword">RETURNS</span>  <span class="built_in">VARCHAR</span>(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">body</span></span><br></pre></td></tr></table></figure><h4 id="9-9-2-znow"><a href="#9-9-2-znow" class="headerlink" title="9.9.2 znow"></a>9.9.2 znow</h4><ul><li>注意函数名一定要跟着小括号表示参数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> znow() <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y年%m月%d日 %H点:%i分%s秒'</span>);</span><br></pre></td></tr></table></figure><h4 id="9-9-3-zadd"><a href="#9-9-3-zadd" class="headerlink" title="9.9.3 zadd"></a>9.9.3 zadd</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> zadd(num1 <span class="built_in">INT</span>,num2 <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">RETURN</span> num1+num2;</span><br></pre></td></tr></table></figure><h4 id="9-9-4-addUser"><a href="#9-9-4-addUser" class="headerlink" title="9.9.4 addUser"></a>9.9.4 addUser</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(<span class="keyword">id</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> addUser(<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu(<span class="keyword">name</span>) <span class="keyword">VALUES</span>(<span class="keyword">name</span>);</span><br><span class="line">  RETURN LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> addUser(<span class="string">'zfpx'</span>);</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> addUser</span><br></pre></td></tr></table></figure><h3 id="9-10-模糊查询"><a href="#9-10-模糊查询" class="headerlink" title="9.10 模糊查询"></a>9.10 模糊查询</h3><p>就是查询的条件是模糊的，不是特别明确的</p><h4 id="9-10-1-通配符"><a href="#9-10-1-通配符" class="headerlink" title="9.10.1 通配符"></a>9.10.1 通配符</h4><p>代替一个或多个真正的字符，与LIKE 关键字一起使用</p><ul><li><code>_</code>表示一个任意字符</li><li><code>%</code>表示任意长度的字符串</li></ul><h4 id="9-10-2-BETWEEN-AND"><a href="#9-10-2-BETWEEN-AND" class="headerlink" title="9.10.2 BETWEEN AND"></a>9.10.2 BETWEEN AND</h4><p>查询某一列在指定的规范内的记录，包括两个边界</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> grade <span class="keyword">between</span> <span class="number">80</span> <span class="keyword">and</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="9-10-3-IN"><a href="#9-10-3-IN" class="headerlink" title="9.10.3 IN"></a>9.10.3 IN</h4><p>查询某一列中的值在列出的内容列表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> city <span class="keyword">in</span> (<span class="string">'北京'</span>,<span class="string">'上海'</span>,<span class="string">'广东'</span>)</span><br></pre></td></tr></table></figure><h4 id="9-10-4-IS-NUL"><a href="#9-10-4-IS-NUL" class="headerlink" title="9.10.4 IS NUL"></a>9.10.4 IS NUL</h4><ul><li>查询没有邮箱的 IS NUL</li><li>查询有邮箱的 IS NOT NULL</li></ul><h2 id="10-DCL"><a href="#10-DCL" class="headerlink" title="10. DCL"></a>10. DCL</h2><h3 id="10-1-创建用户"><a href="#10-1-创建用户" class="headerlink" title="10.1 创建用户"></a>10.1 创建用户</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER 用户名@访问地址 IDENTIFIED BY <span class="string">'密码'</span></span><br><span class="line">CREATE USER user1@localhost IDENTIFIED BY <span class="string">'123456'</span></span><br></pre></td></tr></table></figure><h3 id="10-2-授予权限"><a href="#10-2-授予权限" class="headerlink" title="10.2 授予权限"></a>10.2 授予权限</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限<span class="number">1</span>,权限<span class="number">2</span>,,, ON 数据库.* TO 用户名</span><br><span class="line"></span><br><span class="line">GRANT CREATE,DROP ON db1.* TO user1@localhost;</span><br></pre></td></tr></table></figure><h3 id="10-3-授予权限"><a href="#10-3-授予权限" class="headerlink" title="10.3 授予权限"></a>10.3 授予权限</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限<span class="number">1</span>，权限<span class="number">2</span>，，，ON 数据库.* FROM 用户名;</span><br><span class="line">REVOKE CREATE,DROP ONT db1.* FROM user1@localhost;</span><br></pre></td></tr></table></figure><h3 id="10-4-查看用户权限"><a href="#10-4-查看用户权限" class="headerlink" title="10.4 查看用户权限"></a>10.4 查看用户权限</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FROM 用户名</span><br><span class="line">SHOW GRANTS FROM user1@localhost;</span><br></pre></td></tr></table></figure><h3 id="10-5-删除用户"><a href="#10-5-删除用户" class="headerlink" title="10.5 删除用户"></a>10.5 删除用户</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP USER 用户名</span><br><span class="line">DROP USER user1@localhost;</span><br></pre></td></tr></table></figure><h3 id="10-6-修改密码"><a href="#10-6-修改密码" class="headerlink" title="10.6 修改密码"></a>10.6 修改密码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE USER SET PASSWORD=PASSWORD(<span class="string">'password'</span>) WHERE User=<span class="string">'username'</span> and Host=<span class="string">'localhost'</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h2 id="11-存储过程"><a href="#11-存储过程" class="headerlink" title="11. 存储过程"></a>11. 存储过程</h2><ul><li>大多数SQL语句都是针对一个或多个表的单条语句。但是并不是所有的操作都是可以用一条语句来完成的，经常有一些操作是需要多条语句配合才能完成。我们引入的存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它</li></ul><h3 id="11-1-语法"><a href="#11-1-语法" class="headerlink" title="11.1 语法"></a>11.1 语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE([[IN |OUT |INOUT ] 参数名 数据类形...])</span><br></pre></td></tr></table></figure><h3 id="11-2-调用"><a href="#11-2-调用" class="headerlink" title="11.2 调用"></a>11.2 调用</h3><ul><li><p>因为存储过程实际上是一种函数,所以存储过程名后需要有 () 符号(即使不传递参数也需要)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL Avg_Price()</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-3-删除"><a href="#11-3-删除" class="headerlink" title="11.3 删除"></a>11.3 删除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS Avg_Price;</span><br></pre></td></tr></table></figure><h3 id="11-4-参数"><a href="#11-4-参数" class="headerlink" title="11.4 参数"></a>11.4 参数</h3><ul><li>存储过程并不显示结果，而是把结果返回给你指定的变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create procedure sum (<span class="keyword">in</span> a int,<span class="keyword">in</span> b int,out result int)</span><br><span class="line">begin</span><br><span class="line">select a+b INTO result;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">call sum5(<span class="number">1</span>,<span class="number">2</span>,@result);</span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure><h2 id="12-索引"><a href="#12-索引" class="headerlink" title="12. 索引"></a>12. 索引</h2><ul><li>索引可以提高数据库的查询速度</li></ul><p><img src="14.jpeg" alt="treeindex"></p><h3 id="12-1-准备数据"><a href="#12-1-准备数据" class="headerlink" title="12.1 准备数据"></a>12.1 准备数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-- 构建一个<span class="number">8388608</span>条记录的数据 </span><br><span class="line"></span><br><span class="line">-- 创建用户表</span><br><span class="line">create table user(</span><br><span class="line">  id int,</span><br><span class="line">    username varchar(<span class="number">64</span>),</span><br><span class="line">    userno int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 创建生成随机字符串的函数</span><br><span class="line">CREATE FUNCTION <span class="string">`rand_string`</span>(n INT) RETURNS varchar(<span class="number">255</span>)</span><br><span class="line">BEGIN </span><br><span class="line">DECLARE chars_str varchar(<span class="number">100</span>) DEFAULT <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'</span>; </span><br><span class="line">DECLARE return_str varchar(<span class="number">255</span>) DEFAULT <span class="string">''</span>; </span><br><span class="line">DECLARE i INT DEFAULT <span class="number">0</span>; </span><br><span class="line">WHILE i &lt; n DO </span><br><span class="line">SET return_str = concat(return_str,substring(chars_str , FLOOR(<span class="number">1</span> + RAND()*<span class="number">62</span> ),<span class="number">1</span>)); </span><br><span class="line">SET i = i +<span class="number">1</span>; </span><br><span class="line">END WHILE; </span><br><span class="line">RETURN return_str; </span><br><span class="line">END; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 产生随机数字 </span><br><span class="line">create <span class="function"><span class="keyword">function</span> <span class="title">rand_num</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"><span class="title">returns</span> <span class="title">int</span>(<span class="params"><span class="number">5</span></span>) </span></span><br><span class="line"><span class="function"><span class="title">begin</span>  </span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">i</span> <span class="title">int</span> <span class="title">default</span> 0; </span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">i</span> = <span class="title">floor</span>(<span class="params"><span class="number">10</span>+rand(</span>)*500); </span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">i</span>; </span></span><br><span class="line"><span class="function"><span class="title">end</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- 创建存储过程，向用户表添加海量数据 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span> <span class="title">procedure</span> <span class="title">insert_user</span>(<span class="params">in start int(<span class="number">10</span></span>),<span class="title">in</span> <span class="title">max_num</span> <span class="title">int</span>(<span class="params"><span class="number">10</span></span>))</span></span><br><span class="line"><span class="function"> <span class="title">begin</span></span></span><br><span class="line"><span class="function">   <span class="title">declare</span> <span class="title">i</span> <span class="title">int</span>;</span></span><br><span class="line"><span class="function">   <span class="title">set</span> <span class="title">i</span>=0;</span></span><br><span class="line"><span class="function">   <span class="title">while</span> <span class="title">i</span>&lt;<span class="title">max_num</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">     <span class="title">set</span> <span class="title">i</span>=<span class="title">i</span>+1;</span></span><br><span class="line"><span class="function">         <span class="title">insert</span> <span class="title">into</span> <span class="title">user</span>(<span class="params">id,username,userno</span>) <span class="title">values</span>(<span class="params">(start+i</span>),<span class="title">rand_string</span>(<span class="params"><span class="number">6</span></span>),<span class="title">rand_num</span>(<span class="params"></span>));</span></span><br><span class="line"><span class="function">   <span class="title">end</span> <span class="title">while</span>;</span></span><br><span class="line"><span class="function"> <span class="title">end</span>;</span></span><br><span class="line"><span class="function"><span class="title">call</span> <span class="title">insert_user</span>(<span class="params"><span class="number">1</span>,<span class="number">8388608</span></span>);</span></span><br></pre></td></tr></table></figure><h3 id="12-2-创建普通索引"><a href="#12-2-创建普通索引" class="headerlink" title="12.2 创建普通索引"></a>12.2 创建普通索引</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user(id int primary key,name varchar(<span class="number">32</span>),email varchar(<span class="number">32</span>));</span><br><span class="line">alter table user add index(name);</span><br><span class="line">create index idx_name on  user(name);</span><br></pre></td></tr></table></figure><h3 id="12-3-查看索引"><a href="#12-3-查看索引" class="headerlink" title="12.3 查看索引"></a>12.3 查看索引</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show index <span class="keyword">from</span> 表名;</span><br><span class="line">show index <span class="keyword">from</span> user</span><br></pre></td></tr></table></figure><h3 id="12-4-删除索引"><a href="#12-4-删除索引" class="headerlink" title="12.4 删除索引"></a>12.4 删除索引</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop primary;</span><br><span class="line">alter table 表名 drop index 索引名;</span><br><span class="line">drop index 索引名 on 表名;</span><br></pre></td></tr></table></figure><h3 id="12-5-慢查询"><a href="#12-5-慢查询" class="headerlink" title="12.5 慢查询"></a>12.5 慢查询</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select * <span class="keyword">from</span> users where userno=<span class="number">4593</span>;</span><br><span class="line">alter table users add index(userno);</span><br></pre></td></tr></table></figure><p><img src="15.jpeg" alt="mysqlexplain"></p><h3 id="12-6-索引创建的原则"><a href="#12-6-索引创建的原则" class="headerlink" title="12.6 索引创建的原则"></a>12.6 索引创建的原则</h3><ul><li>比较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合作创建索引</li><li>不会出现在where子句中的字段不该创建索引</li></ul><h2 id="13-什么是聚合函数"><a href="#13-什么是聚合函数" class="headerlink" title="13. 什么是聚合函数"></a>13. 什么是聚合函数</h2><p>对一组值进行计算，并返回计算后的值，一般用来统计数据</p><h3 id="1-1-SUM"><a href="#1-1-SUM" class="headerlink" title="1.1 SUM"></a>1.1 SUM</h3><p>累加所有行的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算ID=1的学生的的总分</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SUM</span>(grade)  <span class="keyword">as</span> <span class="string">'总分'</span> <span class="keyword">from</span> score <span class="keyword">where</span> student_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-2-AVG"><a href="#1-2-AVG" class="headerlink" title="1.2 AVG"></a>1.2 AVG</h3><p>计算所有行的平均值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算ID=1的学生的的平均分</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">AVG</span>(grade) <span class="keyword">as</span> <span class="string">'平均分'</span> <span class="keyword">from</span> score <span class="keyword">where</span> student_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-MAX、MIN"><a href="#1-3-MAX、MIN" class="headerlink" title="1.3 MAX、MIN"></a>1.3 MAX、MIN</h3><ul><li>计算所有行的最大值和最小值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">MAX</span>(grade) 最高分,<span class="keyword">MIN</span>(grade) 最低分 <span class="keyword">from</span> score <span class="keyword">where</span> student_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-4-AVG"><a href="#1-4-AVG" class="headerlink" title="1.4 AVG"></a>1.4 AVG</h3><ul><li>计算所有行的平均值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">AVG</span>(grade) <span class="keyword">as</span> <span class="string">'平均分'</span> 最低分 <span class="keyword">from</span> score <span class="keyword">where</span> student_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-5-COUNT"><a href="#1-5-COUNT" class="headerlink" title="1.5 COUNT"></a>1.5 COUNT</h3><ul><li>计算值不为NULL的行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(*) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(<span class="keyword">name</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(<span class="literal">NULL</span>) <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h2 id="14-分组"><a href="#14-分组" class="headerlink" title="14. 分组"></a>14. 分组</h2><p>分组查询就是按某列的值进行分组，相同的值分成一组，然后可以对此组内进行求平均、求和等计算</p><p><img src="16.png" alt="splitgroup"></p><h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名,查询表达式</span><br><span class="line"><span class="keyword">FROM</span>  &lt;表名&gt;  </span><br><span class="line"><span class="keyword">WHERE</span>  &lt;条件&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组字段&gt;</span><br><span class="line"><span class="keyword">HAVING</span> 分组后的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 [<span class="keyword">ASC</span>,<span class="keyword">DESC</span>]</span><br><span class="line"><span class="keyword">LIMIT</span> 偏移量,条数</span><br></pre></td></tr></table></figure><p>SELECT列表中只能包含：</p><ul><li>被分组的列</li><li>为每个分组返回一个值的表达式，如聚合函数</li></ul><h3 id="2-2-练习"><a href="#2-2-练习" class="headerlink" title="2.2 练习"></a>2.2 练习</h3><ul><li><p>统计每位同学的平均成绩-单列分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id,<span class="keyword">avg</span>(grade) <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> student_id;</span><br></pre></td></tr></table></figure></li><li><p>统计每门课程的最高分，并按分数从高到低排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id,<span class="keyword">max</span>(grade) 平均分 <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> course_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">max</span>(grade) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></li><li><p>统计各省的男女同学人数-多列分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> province,gender,<span class="keyword">COUNT</span>(*) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> province,gender</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-分组筛选"><a href="#2-3-分组筛选" class="headerlink" title="2.3 分组筛选"></a>2.3 分组筛选</h3><h4 id="2-3-1-语法"><a href="#2-3-1-语法" class="headerlink" title="2.3.1 语法"></a>2.3.1 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">FROM</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name|expr|<span class="keyword">position</span>&#125;</span><br><span class="line"><span class="keyword">HAVING</span>  &#123;col_name|expr|<span class="keyword">position</span>&#125;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name|expr|<span class="keyword">position</span>&#125; [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>]</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="keyword">offset</span>,<span class="keyword">row_count</span></span><br></pre></td></tr></table></figure><ol><li>WHERE用于过滤掉不符合条件的记录</li><li>HAVING 用于过滤分组后的记录</li><li>GROUP BY用于对筛选后的结果进行分组</li></ol><h4 id="2-3-2-练习"><a href="#2-3-2-练习" class="headerlink" title="2.3.2 练习"></a>2.3.2 练习</h4><ul><li><p>统计学生人数超过1人的省份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> province,<span class="keyword">COUNT</span>(*) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> province <span class="keyword">having</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>不及格次数大于1次的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id,<span class="keyword">COUNT</span>(*) 不及格次数 <span class="keyword">from</span> score <span class="keyword">where</span> grade &lt;<span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> student_id <span class="keyword">having</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="15-子查询"><a href="#15-子查询" class="headerlink" title="15. 子查询"></a>15. 子查询</h2><ul><li>子查询就是指出现在其它SQL语句中的SELECT语句,必须始终出现在圆括号中</li><li>子查询可以包含多个关键字或条件</li><li>子查询的外层查询可以是: SELECT、INSERT、UPDATE、SET等</li><li>子查询可以返回常量、一行数据、一列数据或其它子查询</li></ul><h3 id="3-1-比较运算符的子查询"><a href="#3-1-比较运算符的子查询" class="headerlink" title="3.1 比较运算符的子查询"></a>3.1 比较运算符的子查询</h3><ul><li>= 等于</li><li><code>&gt;</code> 大于</li><li>&lt; 小于</li><li><code>&gt;</code>= 大于等于</li><li>&lt;= 小于等于</li><li>&lt;&gt; 不等于</li><li>!= 不等于</li><li>&lt;=&gt; 安全不等于</li></ul><h3 id="3-2-查询年龄大于平均年龄的学生"><a href="#3-2-查询年龄大于平均年龄的学生" class="headerlink" title="3.2 查询年龄大于平均年龄的学生"></a>3.2 查询年龄大于平均年龄的学生</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(age),<span class="number">2</span>) <span class="keyword">FROM</span> student; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">WHERE</span> age &gt; (<span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(age),<span class="number">2</span>) <span class="keyword">FROM</span> student)</span><br></pre></td></tr></table></figure><h3 id="3-2-ANY-SOME-ALL"><a href="#3-2-ANY-SOME-ALL" class="headerlink" title="3.2 ANY SOME ALL"></a>3.2 ANY SOME ALL</h3><ul><li><blockquote><blockquote><p>= &lt; &lt;= = &lt;&gt; !=</p></blockquote></blockquote></li><li><p>ANY 任何一个</p></li><li><p>SOME 某些</p></li><li><p>ALL 全部</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">年龄大于陕西省任何一位同学</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">WHERE</span> age &gt; <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> age  <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> province = <span class="string">'陕西省'</span>);</span><br><span class="line">年龄大于陕西省某些同学</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">WHERE</span> age &gt; <span class="keyword">SOME</span> (<span class="keyword">SELECT</span> age  <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> province = <span class="string">'陕西省'</span>);</span><br><span class="line">年龄大于陕西省所有同学</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">WHERE</span> age &gt; <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> age  <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> province = <span class="string">'陕西省'</span>);</span><br></pre></td></tr></table></figure><h3 id="3-3-查询一下有考试成绩的学生信息"><a href="#3-3-查询一下有考试成绩的学生信息" class="headerlink" title="3.3 查询一下有考试成绩的学生信息"></a>3.3 查询一下有考试成绩的学生信息</h3><ul><li>[IN]</li><li>[NOT IN]</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">distinct</span> student_id <span class="keyword">from</span> score);</span><br></pre></td></tr></table></figure><ul><li><p>[EXISTS]</p></li><li><p>[NOTEXISTS]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">where</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="keyword">distinct</span> student_id <span class="keyword">from</span> score <span class="keyword">where</span> student.id = score.student_id  )</span><br></pre></td></tr></table></figure></li></ul><h2 id="16-表连接"><a href="#16-表连接" class="headerlink" title="16. 表连接"></a>16. 表连接</h2><h3 id="4-1-连接类型"><a href="#4-1-连接类型" class="headerlink" title="4.1　连接类型"></a>4.1　连接类型</h3><ul><li>INNER JOIN 内连接</li><li>LEFT JOIN 左外连接</li><li>RIGHT JOIN 右外连接</li><li>ON 连接条件</li></ul><p><img src="17.jpeg" alt="tablejoin"></p><h3 id="4-2-连接条件"><a href="#4-2-连接条件" class="headerlink" title="4.2　连接条件"></a>4.2　连接条件</h3><p>使用ON关键字来设定连接条件，也可以使用WHERE来代替</p><ul><li>ON来设定连接条件</li><li>也可以使用WHERE来对结果进行过滤</li></ul><h3 id="4-3-内连接"><a href="#4-3-内连接" class="headerlink" title="4.3　内连接"></a>4.3　内连接</h3><p>显示左表和右表中符合条件的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> score <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><h3 id="4-4-左外连接"><a href="#4-4-左外连接" class="headerlink" title="4.4　左外连接"></a>4.4　左外连接</h3><p>显示左表的全部和右表符合条件的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><h3 id="4-5-右外连接"><a href="#4-5-右外连接" class="headerlink" title="4.5　右外连接"></a>4.5　右外连接</h3><p>显示右表的全部和左表符合条件的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> score <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><h3 id="4-6-多表连接"><a href="#4-6-多表连接" class="headerlink" title="4.6　多表连接"></a>4.6　多表连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student.name,course.name,score.grade <span class="keyword">FROM</span> score </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> student.id = score.student_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> course <span class="keyword">ON</span> course.id = score.course_id;</span><br></pre></td></tr></table></figure><h3 id="4-7-无限分类-自身连接"><a href="#4-7-无限分类-自身连接" class="headerlink" title="4.7　无限分类[自身连接]"></a>4.7　无限分类[自身连接]</h3><h4 id="4-7-1-建表"><a href="#4-7-1-建表" class="headerlink" title="4.7.1 建表"></a>4.7.1 建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> <span class="keyword">category</span>(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line"> parent_id <span class="built_in">int</span>(<span class="number">11</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="4-7-2-插入语句"><a href="#4-7-2-插入语句" class="headerlink" title="4.7.2 插入语句"></a>4.7.2 插入语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">category</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,parent_id)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'数码产品'</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="string">'服装'</span>,<span class="number">0</span>),(<span class="number">3</span>,<span class="string">'食品'</span>,<span class="number">0</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">'iPad'</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="string">'李宁'</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="string">'康师傅'</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="4-7-3-查询所有的顶级分类下面分类的数量"><a href="#4-7-3-查询所有的顶级分类下面分类的数量" class="headerlink" title="4.7.3 查询所有的顶级分类下面分类的数量"></a>4.7.3 查询所有的顶级分类下面分类的数量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1.id,c1.name,<span class="keyword">COUNT</span>(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">category</span> c1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">category</span> c2 <span class="keyword">ON</span> c1.id = c2.parent_id</span><br><span class="line"><span class="keyword">WHERE</span> c1.parent_id = <span class="number">0</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c1.id;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-父类变成名称"><a href="#4-7-4-父类变成名称" class="headerlink" title="4.7.4 父类变成名称"></a>4.7.4 父类变成名称</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1.id,c1.name,p.name</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">category</span> c1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">category</span> p <span class="keyword">ON</span> c1.parent_id = p.id</span><br></pre></td></tr></table></figure><h3 id="4-8-删除重复记录-多表删除"><a href="#4-8-删除重复记录-多表删除" class="headerlink" title="4.8 删除重复记录[多表删除]"></a>4.8 删除重复记录[多表删除]</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">category</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,parent_id)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">7</span>,<span class="string">'iPad'</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">8</span>,<span class="string">'李宁'</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">9</span>,<span class="string">'康师傅'</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="4-8-1-子查询找要删除的ID"><a href="#4-8-1-子查询找要删除的ID" class="headerlink" title="4.8.1 子查询找要删除的ID"></a>4.8.1 子查询找要删除的ID</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">category</span> c1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span>) c2</span><br><span class="line"><span class="keyword">ON</span> c1.name = c2.name <span class="keyword">WHERE</span> c1.id != c2.id</span><br></pre></td></tr></table></figure><h4 id="4-8-2-通过IN找要删除的ID"><a href="#4-8-2-通过IN找要删除的ID" class="headerlink" title="4.8.2 通过IN找要删除的ID"></a>4.8.2 通过IN找要删除的ID</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">category</span> c1 </span><br><span class="line"><span class="keyword">WHERE</span> c1.name <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">AND</span> c1.id <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="4-8-3-删除重复记录"><a href="#4-8-3-删除重复记录" class="headerlink" title="4.8.3 删除重复记录"></a>4.8.3 删除重复记录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">category</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">NAME</span> <span class="keyword">FROM</span> ( <span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span>) <span class="keyword">AS</span> T1 )</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span>) <span class="keyword">AS</span> T2)</span><br></pre></td></tr></table></figure><h3 id="4-9-多表更新"><a href="#4-9-多表更新" class="headerlink" title="4.9 多表更新"></a>4.9 多表更新</h3><h4 id="4-9-1-插入省份-INSERT-SELECT"><a href="#4-9-1-插入省份-INSERT-SELECT" class="headerlink" title="4.9.1 (插入省份)INSERT SELECT"></a>4.9.1 (插入省份)INSERT SELECT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> province(<span class="keyword">id</span> <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> province(<span class="keyword">name</span>) <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> province <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><h4 id="4-9-2-更新省份"><a href="#4-9-2-更新省份" class="headerlink" title="4.9.2　更新省份"></a>4.9.2　更新省份</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> province <span class="keyword">ON</span> student.province=province.name</span><br><span class="line"> <span class="keyword">SET</span> student.province=province.id</span><br></pre></td></tr></table></figure><h4 id="4-9-3-修改字段"><a href="#4-9-3-修改字段" class="headerlink" title="4.9.3 修改字段"></a>4.9.3 修改字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student </span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> <span class="string">`province`</span> <span class="string">`province_id`</span> <span class="built_in">int</span>(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><h2 id="17-为什么需要设计数据库"><a href="#17-为什么需要设计数据库" class="headerlink" title="17. 为什么需要设计数据库"></a>17. 为什么需要设计数据库</h2><h3 id="1-1-良好的数据库设计"><a href="#1-1-良好的数据库设计" class="headerlink" title="1.1 良好的数据库设计"></a>1.1 良好的数据库设计</h3><ul><li>节省数据的存储空间</li><li>能够保证数据的完整性</li><li>方便进行数据库系统的开发</li></ul><h3 id="1-2-糟糕的数据库设计"><a href="#1-2-糟糕的数据库设计" class="headerlink" title="1.2 糟糕的数据库设计"></a>1.2 糟糕的数据库设计</h3><ul><li>数据冗余，存储空间浪费</li><li>内存空间浪费</li><li>数据和更新插入异常</li></ul><h2 id="18-软件项目开发周期中的数据库设计"><a href="#18-软件项目开发周期中的数据库设计" class="headerlink" title="18. 软件项目开发周期中的数据库设计"></a>18. 软件项目开发周期中的数据库设计</h2><ul><li>需求分析阶段: 分析客户的业务和数据处理需求</li><li>概要设计阶段： 设计数据库的E-R模型图，确认需求的正确和完整性</li><li>详细设计阶段： 应用三大范式审核数据库</li><li>代码编写阶段： 物理实现数据库，编码实现应用</li><li>软件测试阶段</li><li>安装部署</li></ul><blockquote><p>现实世界-&gt;信息世界-&gt;数据库模型图-&gt;数据库</p></blockquote><h2 id="19-设计数据库的步骤"><a href="#19-设计数据库的步骤" class="headerlink" title="19.设计数据库的步骤"></a>19.设计数据库的步骤</h2><h3 id="3-1-收集信息"><a href="#3-1-收集信息" class="headerlink" title="3.1 收集信息"></a>3.1 收集信息</h3><p>与相关人员进行交流、访谈充分了解用户需求，理解数据库需要完成的任务</p><h3 id="3-2-标示实体-Entity"><a href="#3-2-标示实体-Entity" class="headerlink" title="3.2 标示实体(Entity)"></a>3.2 标示实体(Entity)</h3><p>标识数据库要管理的关键对象或者实体，实体一般是名词</p><h3 id="3-3-标示实体的属性-Attribute"><a href="#3-3-标示实体的属性-Attribute" class="headerlink" title="3.3 标示实体的属性(Attribute)"></a>3.3 标示实体的属性(Attribute)</h3><h3 id="3-4-标示实体之间的关系-RelationShip"><a href="#3-4-标示实体之间的关系-RelationShip" class="headerlink" title="3.4 标示实体之间的关系(RelationShip)"></a>3.4 标示实体之间的关系(RelationShip)</h3><h2 id="20-数据库ER图"><a href="#20-数据库ER图" class="headerlink" title="20. 数据库ER图"></a>20. 数据库ER图</h2><p>ER图：实体关系图，简记E-R图，是指以实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据结构的概念模式</p><p><img src="18.png" alt="er"></p><h3 id="4-1-ER图的实体（entity）"><a href="#4-1-ER图的实体（entity）" class="headerlink" title="4.1 ER图的实体（entity）"></a>4.1 ER图的实体（entity）</h3><ul><li>ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示</li></ul><h3 id="4-2-ER图的属性（attribute）"><a href="#4-2-ER图的属性（attribute）" class="headerlink" title="4.2 ER图的属性（attribute）"></a>4.2 ER图的属性（attribute）</h3><ul><li>ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示</li><li>属性分为唯一属性（ unique attribute）和非唯一属性</li><li>唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。</li></ul><h3 id="4-3-ER图的关系（relationship）"><a href="#4-3-ER图的关系（relationship）" class="headerlink" title="4.3 ER图的关系（relationship）"></a>4.3 ER图的关系（relationship）</h3><ul><li>ER图的关系（relationship）用来表现数据对象与数据对象之间的联系</li><li>例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。</li></ul><h3 id="4-4-ER图中关联关系"><a href="#4-4-ER图中关联关系" class="headerlink" title="4.4 ER图中关联关系"></a>4.4 ER图中关联关系</h3><h4 id="4-4-1-1对1-1-1"><a href="#4-4-1-1对1-1-1" class="headerlink" title="4.4.1 1对1 (1:1)"></a>4.4.1 1对1 (1:1)</h4><p>1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。</p><h4 id="4-4-2-1对多（1-N）"><a href="#4-4-2-1对多（1-N）" class="headerlink" title="4.4.2 1对多（1:N）"></a>4.4.2 1对多（1:N）</h4><p>1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。</p><p><img src="19.png" alt="er"></p><h4 id="4-4-3-多对多（M-N）"><a href="#4-4-3-多对多（M-N）" class="headerlink" title="4.4.3 多对多（M:N）"></a>4.4.3 多对多（M:N）</h4><p>多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。</p><p><img src="20.png" alt="er"></p><h2 id="21-数据库设计三大范式"><a href="#21-数据库设计三大范式" class="headerlink" title="21. 数据库设计三大范式"></a>21. 数据库设计三大范式</h2><h3 id="5-1-不合理的表设计"><a href="#5-1-不合理的表设计" class="headerlink" title="5.1 不合理的表设计"></a>5.1 不合理的表设计</h3><ul><li>信息重复</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><h3 id="5-2-三大范式"><a href="#5-2-三大范式" class="headerlink" title="5.2 三大范式"></a>5.2 三大范式</h3><h4 id="5-2-1-第一范式（1NF）"><a href="#5-2-1-第一范式（1NF）" class="headerlink" title="5.2.1 第一范式（1NF）"></a>5.2.1 第一范式（1NF）</h4><ul><li>数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li></ul><p><img src="21.png" alt="firstpattern"></p><h4 id="5-2-2-第二范式（2NF）"><a href="#5-2-2-第二范式（2NF）" class="headerlink" title="5.2.2 第二范式（2NF）"></a>5.2.2 第二范式（2NF）</h4><ul><li>满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情</li></ul><p><img src="22.png" alt="image-20210510105807457"></p><p><img src="23.jpeg" alt="2th2"></p><p><img src="24.jpg" alt="2th3"></p><blockquote><p>一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余</p></blockquote><h4 id="5-2-3-第三范式（3NF）"><a href="#5-2-3-第三范式（3NF）" class="headerlink" title="5.2.3 第三范式（3NF）"></a>5.2.3 第三范式（3NF）</h4><ul><li>必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，(表中的每一列只能依赖于主键)</li><li>数据不能存在传递关系,即每个属性都跟主键有直接关系而不是间接关系</li></ul><p><img src="25.png" alt="thirdpattern"></p><h4 id="5-2-4-如何更好的区分三大范式"><a href="#5-2-4-如何更好的区分三大范式" class="headerlink" title="5.2.4 如何更好的区分三大范式"></a>5.2.4 如何更好的区分三大范式</h4><ul><li>第一范式和第二范式的区别在于有没有分出两张表,第二范式是说一张表中包含了所种不同的实体属性，那么要必须分成多张表</li><li>第三范式是要求已经分成了多张表，那么一张表中只能有另一张表中的id（主键），而不能有其他的任何信息（其他的信息一律用外键在另一表的主键看查询）。</li></ul><h2 id="22-RBAC"><a href="#22-RBAC" class="headerlink" title="22.RBAC"></a>22.RBAC</h2><ul><li><p>基于角色的权限访问控制（Role-Based Access Control）</p></li><li><p>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联</p></li><li><p>简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限-资源”的授权模型</p></li><li><p>在这种模型中，用户与角色之间，角色与权限之间，权限与资源之间一般是多对多的关系。</p></li><li><p>在RBAC中最重要的概念包括：用户(User)，角色(Role)，权限(Permission)，资源(Resource)</p><h3 id="5-1-安全原则"><a href="#5-1-安全原则" class="headerlink" title="5.1 安全原则"></a>5.1 安全原则</h3></li><li><p>最小权限原则之所以被RBAC所支持，是因为RBAC可以将其角色配置成其完成任务所需要的最小的权限集</p></li><li><p>责任分离原则可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐。</p></li><li><p>数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限</p></li></ul><h3 id="5-2-ER图"><a href="#5-2-ER图" class="headerlink" title="5.2 ER图"></a>5.2 ER图</h3><p><img src="26.png" alt="er"></p><h3 id="5-2-1-用户表"><a href="#5-2-1-用户表" class="headerlink" title="5.2.1 用户表"></a>5.2.1 用户表</h3><table><thead><tr><th align="left">字段</th><th align="left">字段名</th><th align="left">类型</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">ID</td><td align="left">int(11)</td><td align="left"></td></tr><tr><td align="left">username</td><td align="left">用户名</td><td align="left">varchar(255)</td><td align="left"></td></tr><tr><td align="left">password</td><td align="left">密码</td><td align="left">varchar(255)</td><td align="left"></td></tr><tr><td align="left">email</td><td align="left">邮箱</td><td align="left">varchar(255)</td><td align="left"></td></tr><tr><td align="left">phone</td><td align="left">手机号</td><td align="left">varchar(255)</td><td align="left"></td></tr><tr><td align="left">gender</td><td align="left">性别</td><td align="left">tinyint</td><td align="left"></td></tr><tr><td align="left">birthday</td><td align="left">生日</td><td align="left">datetime</td><td align="left"></td></tr><tr><td align="left">addresss</td><td align="left">地址</td><td align="left">varchar(255)</td><td align="left"></td></tr><tr><td align="left">create_time</td><td align="left">创建时间</td><td align="left">datetime</td><td align="left">CURRENT_TIMESTAMP</td></tr><tr><td align="left">last_login</td><td align="left">上次登录时间</td><td align="left">datetime</td><td align="left"></td></tr><tr><td align="left">status</td><td align="left">状态</td><td align="left">tinyint</td><td align="left">1</td></tr></tbody></table><h3 id="5-2-2-角色表"><a href="#5-2-2-角色表" class="headerlink" title="5.2.2 角色表"></a>5.2.2 角色表</h3><table><thead><tr><th align="left">字段</th><th align="left">字段名</th><th align="left">类型</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">ID</td><td align="left">int(11)</td><td align="left"></td></tr><tr><td align="left">name</td><td align="left">名称</td><td align="left">varchar(255)</td><td align="left"></td></tr><tr><td align="left">create_time</td><td align="left">创建时间</td><td align="left">datetime</td><td align="left">CURRENT_TIMESTAMP</td></tr><tr><td align="left">status</td><td align="left">状态</td><td align="left">tinyint</td><td align="left">1</td></tr></tbody></table><h3 id="5-2-3-资源表"><a href="#5-2-3-资源表" class="headerlink" title="5.2.3 资源表"></a>5.2.3 资源表</h3><table><thead><tr><th align="left">字段</th><th align="left">字段名</th><th align="left">类型</th><th align="left">默认</th><th></th></tr></thead><tbody><tr><td align="left">id</td><td align="left">ID</td><td align="left">int(11)</td><td align="left"></td><td></td></tr><tr><td align="left">name</td><td align="left">名称</td><td align="left">varchar(255)</td><td align="left"></td><td></td></tr><tr><td align="left">key</td><td align="left">路径</td><td align="left">varchar(255)</td><td align="left"></td><td></td></tr><tr><td align="left">create_time</td><td align="left">创建时间</td><td align="left">datetime</td><td align="left">CURRENT_TIMESTAMP</td><td></td></tr><tr><td align="left">status</td><td align="left">状态</td><td align="left">tinyint</td><td align="left">1</td><td></td></tr></tbody></table><h3 id="5-2-4-用户角色表"><a href="#5-2-4-用户角色表" class="headerlink" title="5.2.4 用户角色表"></a>5.2.4 用户角色表</h3><table><thead><tr><th align="left">字段</th><th align="left">字段名</th><th align="left">类型</th></tr></thead><tbody><tr><td align="left">user_id</td><td align="left">用户ID</td><td align="left">int(11)</td></tr><tr><td align="left">role_id</td><td align="left">角色ID</td><td align="left">int(11)</td></tr></tbody></table><h3 id="5-2-5-角色资源"><a href="#5-2-5-角色资源" class="headerlink" title="5.2.5 角色资源"></a>5.2.5 角色资源</h3><table><thead><tr><th align="left">字段</th><th align="left">字段名</th><th align="left">类型</th></tr></thead><tbody><tr><td align="left">role_id</td><td align="left">角色ID</td><td align="left">int(11)</td></tr><tr><td align="left">resource_id</td><td align="left">资源ID</td><td align="left">int(11)</td></tr></tbody></table><h3 id="5-3-数据库脚本"><a href="#5-3-数据库脚本" class="headerlink" title="5.3 数据库脚本"></a>5.3 数据库脚本</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`categories`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_category_parent_id`</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`articles`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_article_category_id`</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_user_role_user_id`</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_user_role_role_id`</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`role_resource`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_role_resource_role_id`</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`role_resource`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_role_resource_resource_id`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`users`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`carousels`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`categories`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`articles`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`navigations`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`links`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`config`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`roles`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`resources`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`role_resource`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`last_login`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line"><span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`gender`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`birthday`</span> datetime <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`carousels`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`categories`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`description`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`keywords`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line"><span class="string">`parent_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`articles`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`category_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`content`</span> <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`keywords`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line"><span class="string">`pv`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`navigations`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`links`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`logo`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`config`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`logo`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line"><span class="string">`keywords`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`description`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`icp`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`about`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`roles`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> (</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`user_id`</span>, <span class="string">`role_id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`resources`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`key`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">255</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role_resource`</span> (</span><br><span class="line"><span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`resource_id`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`role_id`</span>, <span class="string">`resource_id`</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`categories`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_category_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`categories`</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`articles`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_article_category_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`category_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`categories`</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_user_role_user_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`user_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`users`</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_user_role_role_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`role_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`roles`</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`role_resource`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_role_resource_role_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`role_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`roles`</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`role_resource`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_role_resource_resource_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`resource_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`resources`</span> (<span class="string">`id`</span>);</span><br></pre></td></tr></table></figure><h2 id="23-事务"><a href="#23-事务" class="headerlink" title="23.事务"></a>23.事务</h2><h3 id="6-1-为什么需要事务"><a href="#6-1-为什么需要事务" class="headerlink" title="6.1 为什么需要事务"></a>6.1 为什么需要事务</h3><ul><li>银行转账问题</li><li>A账户资金减少</li><li>B账户资金增加</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> bank;</span><br><span class="line"><span class="keyword">use</span> bank;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    balance <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>,balance) <span class="keyword">values</span>(<span class="string">'张三'</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>,balance) <span class="keyword">values</span>(<span class="string">'李四'</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance + <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'李四'</span>;</span><br></pre></td></tr></table></figure><h3 id="6-2-什么是事务"><a href="#6-2-什么是事务" class="headerlink" title="6.2 什么是事务"></a>6.2 什么是事务</h3><ul><li>事务是作为单个逻辑工作单元执行的一系列操作</li><li>多个操作作为一个整体向系统提交，要么都执行，要么都不执行</li><li>事务是一个不可分割的工作逻辑单元</li></ul><blockquote><p>转账过程就是一个整体，它需要两条UPDATE语句，如果任何一个出错，则整个转账业务取消，两个账户的余额都恢复到原来的数据，确保总余额不变</p></blockquote><h3 id="6-3-事务的特性"><a href="#6-3-事务的特性" class="headerlink" title="6.3 事务的特性"></a>6.3 事务的特性</h3><ul><li>原子性(Atomicity) 事务是一个完整的操作，事务各个部分是不可分的，要么都执行，要么都不执行</li><li>一致性(Consistency) 当事务完成后，数据必须处理完整的状态</li><li>隔离性(Isolation) 并发事务彼此隔离、独立，它不应该以任何方式依赖于其它事务</li><li>持久性(Durability) 事务完成后，它对数据库的修改被永久保持</li></ul><h3 id="6-4-如何创建事务"><a href="#6-4-如何创建事务" class="headerlink" title="6.4 如何创建事务"></a>6.4 如何创建事务</h3><ul><li>开始事务 <code>START TRANSACTION</code> 或者 <code>BEGIN</code></li><li>提交事务 <code>COMMIT</code></li><li>回滚或者说撤销事务 <code>ROLLBACK</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，每条单独的SQL语句视为一个事务</li><li>关闭默认提交状态后，可手动开启、关闭事务</li><li>关闭/开启自动提交状态 <code>SET autocommit=0|1</code> 0关闭 1开启</li></ul><blockquote><p>关闭自动提交后，从下一条SQL语句开始开启新的事务，需要使用COMMIT或ROLLBACK结束该事务</p></blockquote><h2 id="24-在node中使用mysql"><a href="#24-在node中使用mysql" class="headerlink" title="24.在node中使用mysql"></a>24.在node中使用mysql</h2><ul><li><a href="https://www.npmjs.com/package/mysql" target="_blank" rel="noopener">mysql</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure><h3 id="7-1-使用mysql"><a href="#7-1-使用mysql" class="headerlink" title="7.1 使用mysql"></a>7.1 使用mysql</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql      = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : <span class="string">'localhost'</span>,</span><br><span class="line">  user     : <span class="string">'me'</span>,</span><br><span class="line">  password : <span class="string">'secret'</span>,</span><br><span class="line">  database : <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">connection.query(<span class="string">'SELECT 1 + 1 AS solution'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The solution is: '</span>, results[<span class="number">0</span>].solution);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure><h3 id="7-2-使用mysql连接池"><a href="#7-2-使用mysql连接池" class="headerlink" title="7.2 使用mysql连接池"></a>7.2 使用mysql连接池</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> pool  = mysql.createPool(&#123;</span><br><span class="line">  connectionLimit : <span class="number">10</span>,</span><br><span class="line">  host            : <span class="string">'example.org'</span>,</span><br><span class="line">  user            : <span class="string">'bob'</span>,</span><br><span class="line">  password        : <span class="string">'secret'</span>,</span><br><span class="line">  database        : <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.query(<span class="string">'SELECT 1 + 1 AS solution'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The solution is: '</span>, results[<span class="number">0</span>].solution);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-3-使用mysql事务"><a href="#7-3-使用mysql事务" class="headerlink" title="7.3 使用mysql事务"></a>7.3 使用mysql事务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">connection.beginTransaction(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err; &#125;</span><br><span class="line">  connection.query(<span class="string">'INSERT INTO posts SET title=?'</span>, title, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.rollback(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> log = <span class="string">'Post '</span> + results.insertId + <span class="string">' added'</span>;</span><br><span class="line"></span><br><span class="line">    connection.query(<span class="string">'INSERT INTO log SET data=?'</span>, log, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.rollback(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      connection.commit(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> connection.rollback(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success!'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="25-锁"><a href="#25-锁" class="headerlink" title="25.锁"></a>25.锁</h2><ul><li>锁时计算机协调多个进程或线程并发访问某一资源的机制</li></ul><h3 id="8-1-锁的分类"><a href="#8-1-锁的分类" class="headerlink" title="8.1 锁的分类"></a>8.1 锁的分类</h3><ul><li>从对数据库操作的类型分，分为读锁和写锁<ul><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</li><li>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ul></li><li>从对数据操作的粒度分，分为<ul><li>表锁</li><li>行锁</li></ul></li></ul><h3 id="8-2-表锁"><a href="#8-2-表锁" class="headerlink" title="8.2 表锁"></a>8.2 表锁</h3><ul><li>表锁偏向<code>MyISAM</code>存储引擎，开销小，加锁快，锁定粒度大，发生锁冲突的概率最高，并发度最低</li></ul><h4 id="8-2-1-准备数据"><a href="#8-2-1-准备数据" class="headerlink" title="8.2.1 准备数据"></a>8.2.1 准备数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">`users`</span> (</span><br><span class="line">  <span class="string">`id`</span> int(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`NAME`</span> varchar(<span class="number">20</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (<span class="string">`id`</span>)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO <span class="string">`users`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) VALUES (<span class="string">'1'</span>, <span class="string">'a'</span>);</span><br><span class="line">INSERT INTO <span class="string">`users`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) VALUES (<span class="string">'2'</span>, <span class="string">'b'</span>);</span><br><span class="line">INSERT INTO <span class="string">`users`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) VALUES (<span class="string">'3'</span>, <span class="string">'c'</span>);</span><br><span class="line">INSERT INTO <span class="string">`users`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) VALUES (<span class="string">'4'</span>, <span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock table 表名称 read(write),表名称<span class="number">2</span> read(write);</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-加读锁"><a href="#8-2-2-加读锁" class="headerlink" title="8.2.2 加读锁"></a>8.2.2 加读锁</h4><table><thead><tr><th align="left">会话1</th><th align="left">会话2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">lock table users read;</td><td align="left">连接数据库</td><td align="left"></td></tr><tr><td align="left">select * from users;</td><td align="left">select * from users;</td><td align="left">都可以查询</td></tr><tr><td align="left">select * from role;</td><td align="left">select * from role;</td><td align="left">会话1不能查询没有锁定的表，会话2可以查询没有锁定的表或更新未锁定的表</td></tr><tr><td align="left">INSERT INTO <code>users</code> (<code>id</code>, <code>NAME</code>) VALUES (‘5’, ‘e’);</td><td align="left">INSERT INTO <code>users</code> (<code>id</code>, <code>NAME</code>) VALUES (‘5’, ‘e’);</td><td align="left">会话1插入或更新会提示错误，会话2插入或更新会提示等待</td></tr><tr><td align="left">unlock tables;</td><td align="left">INSERT INTO <code>users</code> (<code>id</code>, <code>NAME</code>) VALUES (‘5’, ‘e’);</td><td align="left">会话1释放锁后，会话2完成插入操作</td></tr></tbody></table><h4 id="8-2-3-加写锁"><a href="#8-2-3-加写锁" class="headerlink" title="8.2.3 加写锁"></a>8.2.3 加写锁</h4><table><thead><tr><th align="left">会话1</th><th align="left">会话2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">lock table users write;</td><td align="left">连接数据库</td><td align="left"></td></tr><tr><td align="left">select * from users;</td><td align="left">select * from users;</td><td align="left">会话1可以对锁定表进行插入更新和删除操作,会话2的查询操作也会被阻塞</td></tr><tr><td align="left">unlock tables;</td><td align="left"></td><td align="left">会话1释放锁，会话2返回结果</td></tr></tbody></table><blockquote><p>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</p></blockquote><h3 id="8-3-行锁"><a href="#8-3-行锁" class="headerlink" title="8.3 行锁"></a>8.3 行锁</h3><ul><li>行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高</li><li>InnoDB与MYISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</li></ul><h4 id="8-3-1-行锁支持事务"><a href="#8-3-1-行锁支持事务" class="headerlink" title="8.3.1 行锁支持事务"></a>8.3.1 行锁支持事务</h4><h5 id="8-3-1-1-并发事务处理带来的问题"><a href="#8-3-1-1-并发事务处理带来的问题" class="headerlink" title="8.3.1.1 并发事务处理带来的问题"></a>8.3.1.1 并发事务处理带来的问题</h5><h6 id="8-3-1-1-1-更新丢失（Lost-Update）"><a href="#8-3-1-1-1-更新丢失（Lost-Update）" class="headerlink" title="8.3.1.1.1 更新丢失（Lost Update）"></a>8.3.1.1.1 更新丢失（Lost Update）</h6><ul><li>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</li><li>后面的事务覆盖了前面的值,这是正常现象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table account3 (id int,balance int) ENGINE=InnoDB;</span><br><span class="line">insert into account3(id,balance) values(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">insert into account3(id,balance) values(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">set</span> autocommit=0;</span><br><span class="line">begin;</span><br><span class="line">update account3 <span class="keyword">set</span> balance=90 where id=1;</span><br><span class="line">commit;</span><br><span class="line"><span class="keyword">set</span> autocommit=0;</span><br><span class="line">begin;</span><br><span class="line">update account3 <span class="keyword">set</span> balance=80 where id=1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>　　</p><h6 id="8-3-1-1-2-脏读（Dirty-Reads）"><a href="#8-3-1-1-2-脏读（Dirty-Reads）" class="headerlink" title="8.3.1.1.2 脏读（Dirty Reads）"></a>8.3.1.1.2 脏读（Dirty Reads）</h6><ul><li>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些<code>脏</code>数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做<code>脏读</code>。</li><li>一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</li><li>脏读是事务B里面修改了数据 ,这是不正常的</li><li>解决办法：如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可 以避免该问题。</li></ul><p>修改日志的隔离级别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 支持的存储引擎</span><br><span class="line">SHOW ENGINES;</span><br><span class="line">-- 当前的数据库默认引擎</span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'storage_engine'</span>;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">SELECT @@global.tx_isolation;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">SELECT @@tx_isolation;</span><br><span class="line">start TRANSACTION;</span><br><span class="line">insert into account3(id,balance) values(<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">start TRANSACTION;</span><br><span class="line">select * <span class="keyword">from</span> account3;</span><br></pre></td></tr></table></figure><h6 id="8-3-1-1-3-不可重复读（Non-Repeatable-Reads）"><a href="#8-3-1-1-3-不可重复读（Non-Repeatable-Reads）" class="headerlink" title="8.3.1.1.3 不可重复读（Non-Repeatable Reads）"></a>8.3.1.1.3 不可重复读（Non-Repeatable Reads）</h6><ul><li>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做”不可重复读”。</li><li>一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性,这是不正常的</li><li>解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题</li><li>针对的是update或delete</li></ul><p>修改日志级别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL read committed;</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL read committed;</span><br><span class="line">SELECT @@global.tx_isolation;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure><p>会话2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start TRANSACTION;</span><br><span class="line">select * <span class="keyword">from</span> account3;</span><br></pre></td></tr></table></figure><p>会话2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start TRANSACTION;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> account3 where id=<span class="number">1</span>;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h6 id="8-3-1-1-4-幻读（Phantom-Reads）"><a href="#8-3-1-1-4-幻读（Phantom-Reads）" class="headerlink" title="8.3.1.1.4 幻读（Phantom Reads）"></a>8.3.1.1.4 幻读（Phantom Reads）</h6><ul><li>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为”幻读”。</li><li>一句话：事务A读取到了事务B提交的新增数据，不符合隔离性</li><li>幻读是事务B里面新增了数据,这是不正常的</li><li>解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题</li><li>针对的是 <code>insert</code></li><li>要更新隐藏的行之后才能看到幻读现象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL repeatable read;</span><br><span class="line">SELECT @@global.tx_isolation;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">SELECT @@tx_isolation;</span><br><span class="line">start TRANSACTION;</span><br><span class="line">insert into account3(id,balance) values(<span class="number">5</span>,<span class="number">100</span>);</span><br><span class="line">commit;</span><br><span class="line">start TRANSACTION;</span><br><span class="line">select * <span class="keyword">from</span> account3;</span><br><span class="line">update account3 <span class="keyword">set</span> balance =balance-10;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h5 id="8-3-1-2-事务隔离五种级别"><a href="#8-3-1-2-事务隔离五种级别" class="headerlink" title="8.3.1.2 事务隔离五种级别"></a>8.3.1.2 事务隔离五种级别</h5><ul><li>read uncommitted : 读取尚未提交的数据 ：就是脏读</li><li>read committed：读取已经提交的数据 ：可以解决脏读</li><li>repeatable read：可重读读取：可以解决脏读和不可重复读 —mysql默认的</li><li>serializable：串行化：可以解决 脏读、不可重复读和幻读—相当于锁表</li><li>Innodb的默认事务隔离级别是重复读 <code>repeatable read</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br><span class="line"><span class="keyword">set</span> session transaction isolation level</span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">非重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">read uncommitted</td><td align="left">允许</td><td align="left">允许</td><td align="left">允许</td></tr><tr><td align="left">read committed</td><td align="left"></td><td align="left">允许</td><td align="left">允许</td></tr><tr><td align="left">repeatable read</td><td align="left"></td><td align="left"></td><td align="left">允许</td></tr><tr><td align="left">serializable</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h5 id="8-3-2-死锁"><a href="#8-3-2-死锁" class="headerlink" title="8.3.2 死锁"></a>8.3.2 死锁</h5><ul><li>只有在INNODB引擎上的索引键上才会启用行级锁</li><li>Deadlock found when trying to get lock; try restarting transaction</li></ul><table><thead><tr><th align="left">会话1</th><th align="left">会话2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">set autocommit=0</td><td align="left">set autocommit=0</td><td align="left">都关闭默认提交</td></tr><tr><td align="left">update account set balance = balance -10 where name = ‘张三’</td><td align="left">update account2 set balance = balance -10 where name = ‘李四’</td><td align="left"></td></tr><tr><td align="left">update account2 set balance = balance -10 where name = ‘李四’;</td><td align="left">update account2 set balance = balance -10 where name = ‘张三’;</td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>davinci dev</title>
      <link href="2021/05/08/davinci-dev/"/>
      <url>2021/05/08/davinci-dev/</url>
      
        <content type="html"><![CDATA[<ol><li><p>先安装maven</p></li><li><p>点击idea编辑器的Projects Structure 配置两个jar包；（在Libray中的java目录中）</p></li><li><p>打zip包至target</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="4"><li>解压zip，打包davinci-ui，</li><li>启动服务</li></ol><p>Wh</p>]]></content>
      
      
      <categories>
          
          <category> davinci </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browser</title>
      <link href="2021/04/28/browser/"/>
      <url>2021/04/28/browser/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        就像一个服务端开发程序员需要掌握操作系统运行机制一样，前端开发程序员必须对浏览器的运行机制清晰掌握。了解释浏览器的机制是做出高性能web页面的基础。</p><p>​        同样浏览器也是运行在操作系统之上的软件，科技发展到今天。用户对web服务的质量要求越来越高。表现在软件的UI界面，需要首屏更早的显示，页面交互更加的人性化和智能化。浏览器也在日益完善这些需求之中不断进化，软件架构日趋完善。截止到现在，一个浏览器的构架越来越复杂，其复杂程度也越来越趋向操作系统内核。</p><p>​        </p><h2 id="1-现代浏览器架构概述"><a href="#1-现代浏览器架构概述" class="headerlink" title="1. 现代浏览器架构概述"></a>1. 现代浏览器架构概述</h2><blockquote><p>以chrome浏览器为例</p></blockquote><p><img src="jincheng.png" alt="image-20210429100836681"></p><p>浏览器是个多进程的架构，但启动chrome，打开一个web页面的时候。我们通过chrome的任务管理器能准确看到，尽管只启动一个页面，浏览器多出了8个进程。</p><h3 id="1-1-浏览器进程架构"><a href="#1-1-浏览器进程架构" class="headerlink" title="1.1 浏览器进程架构"></a>1.1 浏览器进程架构</h3><h4 id="1-1-1-浏览器进程"><a href="#1-1-1-浏览器进程" class="headerlink" title="1.1.1 浏览器进程"></a>1.1.1 浏览器进程</h4><p>浏览器主进程，主要负责界面显示，用户交互，子进程管理，同时提供存储等功能；</p><h4 id="1-2-渲染进程（标签页：chrome-storage-Chrome）"><a href="#1-2-渲染进程（标签页：chrome-storage-Chrome）" class="headerlink" title="1.2 渲染进程（标签页：chrome.storage-Chrome）"></a>1.2 渲染进程（标签页：chrome.storage-Chrome）</h4><p>核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中；</p><p>默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。值得注意的是，如果页面有iframe，那么iframe的页面也会运行在单独的进程中！</p><p>出于安全考虑，渲染进程都是运行在沙箱模式下。</p><h4 id="1-3-GPU进程"><a href="#1-3-GPU进程" class="headerlink" title="1.3 GPU进程"></a>1.3 GPU进程</h4><p>绘制UI界面</p><h4 id="1-4-Network-Service"><a href="#1-4-Network-Service" class="headerlink" title="1.4 Network Service"></a>1.4 Network Service</h4><p>单拎出来一个进程，管理整个浏览器的网络资源加载；</p><h4 id="1-5-备用渲染程序"><a href="#1-5-备用渲染程序" class="headerlink" title="1.5 备用渲染程序"></a>1.5 备用渲染程序</h4><h4 id="1-6-Storage-Service"><a href="#1-6-Storage-Service" class="headerlink" title="1.6 Storage Service"></a>1.6 Storage Service</h4><p>使用chrome.storage API可以存储，检索和跟踪对用户数据的更改</p><h4 id="1-7-扩展程序（插件进程）"><a href="#1-7-扩展程序（插件进程）" class="headerlink" title="1.7 扩展程序（插件进程）"></a>1.7 扩展程序（插件进程）</h4><p>负责插件的运行，因插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响；</p><h3 id="1-2-多进程架构的好处"><a href="#1-2-多进程架构的好处" class="headerlink" title="1.2 多进程架构的好处"></a>1.2 多进程架构的好处</h3><p>浏览器并非一开始就是多进程架构，软件之所以革新，主要的原因无非是，现有的软件功能和使用体验跟不上用户需求，远远落后于竞争对手。 源代码变💩山迭代功能困难。</p><p><strong>早期的浏览器（为IE6）为例。</strong></p><p>IE6是单进程的也是单标签的，也就是说一个页面一个窗口。所有页面运行在一个主线程中的，意味着，所有的页面都共享着同一套JavaScript运行环境，同样，对于存储Cookie也都是在一个线程里面操作的。</p><p>早期浏览器厂商基于IE6开发多标签的形式，发现其中的一个标签页面的卡顿都会影响到整个浏览器。</p><p>基于卡顿的原因，浏览器厂商就开始尝试支持页面多线程，也就是让部分页面运行在单独的线程之中，运行在单独的线程之中，意味着每个线程拥有单独的JavaScript执行环境，和Cookie环境，这时候问题就来了：</p><p>比如A站点页面登陆一个网站，保存了一些Cookie数据到磁盘上，再在当前线程环境中保存部分Session数据，由于Session是不需要保存到硬盘上的，所以Session只会保存在当前的线程环境中。这时候再打开另外一个A站点的页面，假设这个页面在另外一个线程中里面，那么它首先读取硬盘上的Cookie信息，但是，由于Session信息是保存在另外一个线程里面的，无法直接读取，这样就要实现一个Session同步的问题，由于IE并没有源代码，所以需要自己实现这部分功能。</p><p>Session问题解决了，但是假死的问题依然有，因为进程内使用了一个窗口，这个窗口是依附到浏览器主窗口之上的，所以他们公用一套消息循环机制，这也就意味这一个窗口如果卡死了。也会导致整个浏览器的卡死。</p><p>这里还要提一下为什么Chrome中的一个页面假死不会影响到主窗口呢？<br>这是因为chrome输出的实际上图片，然后浏览器端把图片贴到自己的窗口上去，在Chrome的渲染进程内，并没有一个渲染窗口，输出的只是图片，如果卡住了，顶多图片不更新了。</p><p>一些基于IE6开发的浏览器厂商实现这一套技术花了四五年时间，等这套技术差不多成熟时，Chrome发布了。</p><p>诚然，我们看到了历史进程。但很多东西依然需要结合时代背景去看。硬件设备近二十年更新实在太快，IE6被发明的那个时代，电脑多是单核架构的。不像现在的电脑，几乎都是4核起步， 有条件的大多数都是8核的机器。所以，IE6在那个时候直接开发多进程的浏览器模型且不说当时的电脑带不带的动，怕是能给喷死。</p><p>所以结合历史来看，从单进程架构升级到多进程架构也是自然而然的事情</p><p>多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><p>因为每个渲染进程都需要加载js运行环境，这就意味着浏览器总体上更消耗内存资源，</p><p>第二就是架构复杂度高，等前面的各种之父老去，后生接手困难。</p><p>但总体来说，chrome还是以一个非常快的速度在迭代，现在的普通软件应用开发中，前端也越来越重。因此，对于一个开发来说，能跟还是一定得跟住的；</p><h2 id="2-HTML，CSS，Js等文件是如何变成页面的"><a href="#2-HTML，CSS，Js等文件是如何变成页面的" class="headerlink" title="2. HTML，CSS，Js等文件是如何变成页面的"></a>2. HTML，CSS，Js等文件是如何变成页面的</h2><blockquote><p>当用户键入一个url之后，数据包通过漫长的运输跑到目标服务器，再返回到浏览器客户端，直到收到第一个html文件开始。浏览器做了哪些操作才能呈现出页面的呢？</p><p>我人为的将它们拆分为两个阶段，第一个阶段是创建阶段，第二个阶段为等待更新阶段，第三个阶段为消亡阶段；</p></blockquote><p>之所以人为区分三个阶段，是因为浏览器在每个阶段所做的事情，并不尽相同。尤其是第一阶段和第二阶段，第一阶段的优化重点是如何尽早获取到服务端的相关资源；</p><p>第二阶段则需要了然页面的循环机理，优化的重心是不要写出死循环代码，从而卡住页面，还要知道内存是如何管理，不能写出需要频繁GC的页面，造成页面卡顿。</p><p>第三阶段，要关注的地方虽然不多，但是在一些实际开发场景中，比如对于关闭页面之后如何有效进程数据提交；</p><h3 id="2-1-创建阶段"><a href="#2-1-创建阶段" class="headerlink" title="2. 1 创建阶段"></a>2. 1 创建阶段</h3><blockquote><p> 创建阶段指的是，浏览器将请求过来的html 代码字符串， css代码字符串，js代码字符串解析之后，然后首次绘制出第一帧并呈现到显示器上的这一过程。</p><p> 创建阶段同样可以理解为页面加载阶段的场景，在这个阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于招呼和合成并不是这个阶段的核心诉求，因此我们需要调整策略，在加载阶段将页面解析，js脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级；</p></blockquote><p>上面架构的章节有提到，每个标签页都是一个渲染进程，那每个渲染进程中也分别对应一个呈现引擎实例。所谓呈现引擎，功能诸多，下面将几种介绍其主要用途，即显示使用css格式化的HTML内容和图片；</p><h4 id="2-1-1-呈现流程的基本流程"><a href="#2-1-1-呈现流程的基本流程" class="headerlink" title="2.1.1 呈现流程的基本流程"></a>2.1.1 呈现流程的基本流程</h4><p>渲染流水线</p><p><img src="webkit.png" alt="image-20210429131859115"></p><p>按照渲染的时间顺序，流水线可分为如下几个子阶段： 构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</p><h5 id="2-1-1-1-构建DOM树"><a href="#2-1-1-1-构建DOM树" class="headerlink" title="2.1.1.1 构建DOM树"></a>2.1.1.1 构建DOM树</h5><p>将html代码字符串转化为计算浏览器方便读取的对象结构，这部分就涉及词法分析和语法分析的内容了。最终生成的DOM树形结构就存到当前渲染进程的内存当中了。</p><p>通过DOM编程提供的API接口，就能访问到对应的DOM节点对象了。</p><p><strong>浏览器的容错机制</strong></p><p>在浏览HTML网页时从来不会看到html语法无效的错误，这是因为浏览器会纠正任何无效的内容，然后继续工作；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mytag</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mytag</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- mytag 是无效的tagName，但是浏览器不会报错，而是默默修复它们并继续往下解析--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    Really lousy HTML</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>截止到这里，浏览器已经生成DOM树了，但是DOM节点的样式我们依然不知道，让DOM节点拥有正确的样式，这就需要样式计算了；</p><p><strong>HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</strong></p><p>HTML 解析器并不是等整个文档加载完成之后再解析的，而是<strong>网络进程加载了多少数据，HTML 解析器便解析多少数据</strong>。</p><p>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，<strong>网络进程和渲染进程之间会建立一个共享数据的管道</strong>，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p><h5 id="2-1-1-2-样式计算（Recalculate-Style）"><a href="#2-1-1-2-样式计算（Recalculate-Style）" class="headerlink" title="2.1.1.2 样式计算（Recalculate Style）"></a>2.1.1.2 样式计算（Recalculate Style）</h5><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p><h6 id="2-1-1-2-1-样式计算的步骤"><a href="#2-1-1-2-1-样式计算的步骤" class="headerlink" title="2.1.1.2.1 样式计算的步骤"></a>2.1.1.2.1 样式计算的步骤</h6><p><strong>把 CSS 转换为浏览器能够理解的结构</strong></p><p>首先css代码可以写在页面的各个地方</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"theme.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>/&gt;</span> <span class="tag">&lt;<span class="name">!-内联的方式---</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      body &#123;</span><br><span class="line">        background: red;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: red"</span>&gt;</span> <span class="comment">&lt;!--行内式--&gt;</span></span><br><span class="line">      123</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets</strong></p><p>类似DOM树，styleSheets在内存中也可以查询和修改，这为后面的样式操作提供基础；</p><p><strong>转换样式表中的属性值，使其标准化</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">2em</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">span</span>  &#123;<span class="attribute">display</span>: none&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font-weight</span>: bold&#125;</span><br><span class="line"><span class="selector-tag">div</span>  <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">color</span>:red; &#125;</span><br></pre></td></tr></table></figure><p>转化后为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">32px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);&#125;</span><br><span class="line"><span class="selector-tag">span</span>  &#123;<span class="attribute">display</span>: none&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font-weight</span>: <span class="number">700</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span>  <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure><p>将属性值标准化，有利于后续进一步操作的便捷度；这点类似软件分层机制；</p><p> <strong>计算出 DOM 树中每个节点的具体样式</strong></p><p>接下来就需要计算 DOM 树中每个节点的样式属性</p><p>这就涉及CSS继承的规则和层叠规则了；</p><p><strong>CSS继承，CSS继承就是每个 DOM节点都包含有父节点的样式。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">20px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">span</span>  &#123;<span class="attribute">display</span>: none&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font-weight</span>: bold;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="selector-tag">div</span>  <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure><p><img src="extend.png" alt=""></p><p>从图上可以看出，所有子节点都继承了父节点样式。</p><p><strong>样式计算过程中的第二个规则是样式层叠，样式层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法，它在CSS处于核心位置</strong></p><p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p><h6 id="2-1-1-2-2-the-order-of-processing-scripts-and-styles-sheets"><a href="#2-1-1-2-2-the-order-of-processing-scripts-and-styles-sheets" class="headerlink" title="2.1.1.2.2 the order of processing scripts and styles sheets"></a>2.1.1.2.2 the order of processing scripts and styles sheets</h6><p>在研究一个网页的中所有元素加载顺序的时候，我们不妨去想一个问题。我们如何保证一个页面的一致性。</p><p>浏览器是一个多进程的结构，为提高机器的使用率，我们可以在每个进程中可以创建多个线程。结合到页面的时候，我们能不能让多个线程来操作页面元素或者绘制页面呢？</p><p>答案显然是不行，在上层文档 我们总能看到DOM文档渲染是同步的，是按着顺序执行。多线程的不稳定让我们在执行同样代码的时候可能产生出不同的视图。比如两个线程同时操作一个DOM节点，其中一个线程给字体变成红色，两一个线程给字体变成黄色。那么最终的结果，这个元素的字体颜色会时而红，时而黄的。</p><p>这显然是不能接受，<strong>因此渲染进程在渲染页面的时候，一定是运行在一个单线程上的；</strong></p><p>第二，浏览器能识别HTML，CSS，JS代码。但也并不意味着浏览器是由js语言开发的。（这么说可能有点蠢，但对于初次了解浏览器机制的非科班开发者并非一无是处），我们明确一个事实，浏览器是运行在操作系统上的，我们的mac os windows 有无界面的linux均能安装浏览器比如chrome。</p><p>nodejs程序，浏览器都是直接运行在操作系统上，但我们的前端页面却是运行在浏览器上面的。像浏览器这种容器应用，必然需要追求极致性能。那GC类语言（GC类语言在进行垃圾回收的时候，会全停顿，那对跑在浏览器上面的web页面是致命的）自然是不能用了。主流的非GC语言就C/C++了。C/C++是原生的系统级语言，可以直接调用操作系统原生API，性能最强。</p><p>那既然如此，为何页面还要用发明一种js语言去开发网页呢？为何不直接用C/C++去开发网页。这就要追溯当时那个时期，开发者也就只想在html页面操作个表单罢了。C/C++语言学习曲线陡峭，哪怕直到今天依然是难学难用的计算机语言。</p><p>那最终便设计出了诸如 html，css，js这几种标记和脚本语言来进行页面的开发，html描述一个界面的骨架，css绘制这个骨架的样式，js负责定义这个骨架的行为。</p><p>这里面牵涉到一个问题，生成DOM树，生成CSSOM是C++干的，可不是js干的，这一定需要明确。我们先不提解释器，也不提V8 jsbinding等，我们先粗暴的理解，html，css，js翻译成C++语言，然后统一在渲染进程的某一个固定的线程去执行。单线程环境里面不存在插队，大家在个什么位置他就是个什么位置。人家在执行的时候，你就乖乖等着，同样，你执行的时候，别人也坐着没动弹。就便是传说中的</p><p><strong>js引擎和渲染线程互斥</strong>。</p><p>如果对js语言底层的实现以及浏览器的架构模型没有概念的话，是很难理解这句话的意思。</p><p>我们结合上面说的，可以粗暴的先理解为，翻译成C++的那部分html，css代码跟翻译成C++的那部分js代码在运行引擎上是互斥的。是不能同时运行的。</p><p>为啥，我们想一个页面。html是DOM结构对吧。js可以操作DOM对吧。那这两个必然不能一直执行吧。一起执行遇到冲突听谁的，那不乱套了吗？</p><p>html和css能不能一起执行？为什么不能呢？html生成的DOM结构是主体，css生成样式，css就是装修，装修刷墙粉面又不会改变主体，那一起呗。</p><p>那css和js能不能一直执行？这个就不能了，因为js能改变css样式啊，那两个一起执行遇到冲突听谁的？</p><p>那问题就清晰了,以下面这段代码为例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>渲染进程<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>red<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span>&gt;</span>green<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从html标签开始，C++代码开始解析这个html代码字符串生成DOM，到<code>head标签</code>之后碰到一个script标签，这个时候生成DOM的程序就停了。</p><p>执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为<strong>JavaScript 文件的下载过程会阻塞 DOM 解析</strong>，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p><p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是<strong>预解析操作</strong>。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p><p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。等index.js执行完，这个时候js引擎就停了，就又开始执行生成DOM的程序了。就便是互斥；</p><p>另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里不得不提到 defer和async，defer是让浏览器别管我，你自己先解析你的DOM吧。我会在你解析完整个页面的时候才执行。那这就很高效了。我的首屏可以不受加载js脚本的影响了；</p><p>async是异步脚本，就比较自由。加载完了就立即执行，这种脚本必然就不会轮到主渲染线程来执行了。它应该是渲染进程创建出来的其他线程来执行的；</p><p>而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p><p>我们上面提到css和js，这个当然css会阻塞js的执行。chrome表现的要优秀一些，它的机制是，只有当脚本尝试访问样式属性可能尚未加载的样式表影响时，它才会禁止该脚本。</p><p>一句话总结就是说，DOM的生成会被js脚本阻塞，css的解析同样有几率阻塞js脚本的执行（当js中存在访问未加载充分的样式表的时候，也就是说js依赖该样式表）。所以CSS优先级是最高的，其次是js，DOM碰到js要等等，当然html css一对好基友彼此不耽误，可以同时解析；</p><h6 id="2-1-1-2-3-白屏优化"><a href="#2-1-1-2-3-白屏优化" class="headerlink" title="2.1.1.2.3 白屏优化"></a>2.1.1.2.3 白屏优化</h6><p>通常情况下的瓶颈主要体现在<strong>下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript</strong>。</p><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。</li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li></ul><h5 id="2-1-1-3-布局树构建（layout）"><a href="#2-1-1-3-布局树构建（layout）" class="headerlink" title="2.1.1.3 布局树构建（layout）"></a>2.1.1.3 布局树构建（layout）</h5><blockquote><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局</strong>。</p></blockquote><h6 id="2-1-1-3-1-创建呈现树"><a href="#2-1-1-3-1-创建呈现树" class="headerlink" title="2.1.1.3.1 创建呈现树"></a>2.1.1.3.1 创建呈现树</h6><p>就是结合DOM和CSSOM，将需要隐藏的节点，隐藏掉。把每个节点的样式信息写进去。</p><h6 id="2-1-1-3-2-布局计算"><a href="#2-1-1-3-2-布局计算" class="headerlink" title="2.1.1.3.2 布局计算"></a>2.1.1.3.2 布局计算</h6><p>布局计算就是把每个节点的信息计算出来并写到该节点中，比如每个节点的宽高位置，计算每个布局点的节点坐标；这个过程就相对复杂了；</p><h5 id="2-1-1-4-分层"><a href="#2-1-1-4-分层" class="headerlink" title="2.1.1.4 分层"></a>2.1.1.4 分层</h5><p>我们知道CSS代码里面有个z-index,<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）,然后绘制图层</p><h5 id="2-1-1-5-绘制（paint）"><a href="#2-1-1-5-绘制（paint）" class="headerlink" title="2.1.1.5 绘制（paint）"></a>2.1.1.5 绘制（paint）</h5><blockquote><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p></blockquote><p><strong>全量绘制和增量绘制</strong></p><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其children）。</p><p><strong>绘制顺序</strong></p><ol><li>background color</li><li>background image</li><li>border</li><li>children</li><li>outline</li></ol><h5 id="2-1-1-6-重排（relayout）与重绘（replaint）"><a href="#2-1-1-6-重排（relayout）与重绘（replaint）" class="headerlink" title="2.1.1.6 重排（relayout）与重绘（replaint）"></a>2.1.1.6 重排（relayout）与重绘（replaint）</h5><p>简单列出渲染流水线的核心步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM -&gt; Style -&gt; Layout -&gt; Layer -&gt; Paint</span><br></pre></td></tr></table></figure><p>重排就是更新几何属性吧，比如改变了位置，大小，布局等等。重排需要重新走一遍，Layout -&gt; Layer -&gt; Paint</p><p>重绘就是改变某些元素的颜色，这样只需要 Paint就行了；</p><p>当然你改一个既不会改变布局，又不会改变颜色的属性，那流水线会跳过这些步骤，直接走合成阶段；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tiles -&gt; raster -&gt; draw quad -&gt; display</span><br></pre></td></tr></table></figure><h3 id="2-2-等待更新阶段"><a href="#2-2-等待更新阶段" class="headerlink" title="2.2 等待更新阶段"></a>2.2 等待更新阶段</h3><blockquote><p>等待更新阶段，指的是在创建阶段之后（首次渲染之后）用户可以自由操作页面，页面上也可能自由自由请求服务端，或者服务端定时推送数据给页面做呈现。直到用户使用完之后关掉当前标签页的这个过程。这个阶段同样也可以理解为交互阶段。</p></blockquote><p>这里需要陈述一下，等待更新阶段是杜撰的一个概念，可能在其他资料上面也不会查得到。基于web页面的生命周期，我将其人为割裂为，页面首次显示到浏览器视口中，接下来在用户关闭此标签页的时候，浏览器程序并不是静止不动，而是一直在运行中的，大概是怎么运行的呢？代码大概就像下面这个样子；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个近乎无限的循环。</span></span><br><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure><p>为了解释清楚这个阶段，我先聊聊显示器和渲染帧；</p><h4 id="2-2-1-渲染帧"><a href="#2-2-1-渲染帧" class="headerlink" title="2.2.1 渲染帧"></a>2.2.1 渲染帧</h4><p>提到帧数，思绪回到十年前，去网吧玩玩魔兽世界的时候。我第一在乎的是机器能达到多少帧？尽管那时候不知道帧数到底是什么意思，但是明白帧数越高越好，而帧数一旦低于多少，说明机器很卡。也会经常听到网吧有人抱歉，“我的机器卡成幻灯片了”</p><p>幻灯片有什么特征？幻灯片在切换时候会有一个明显的缓动动画，比如淡入淡出啊 缓动啊之类的。</p><p>我们再说显示器，为何显示器能呈现页面啊。首先，显示器是由一个一个很小的晶体管组合而成，每个晶体管是一个像素点，像素点能显示所有不同的颜色。当所有像素点同时点亮的时候，就形成了一幅画面。</p><p>结合本能，我们应该知道。决定游戏界面质量的无非是显卡，GPU，显示器这些关键字了；</p><p>在显卡中有一块叫做前缓冲区的地方，这里存放着显示器要显示的图像，显示器回按照一定的频率来读取前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是60HZ，也就是说显示器会每间隔1/60秒就读取一次前缓冲区； 为何是60HZ，因为当一个显示器达到60HZ的时候，人眼就很难觉察页面显示器在跳动，而是精致的画面了。那么动画效果将会特别流畅，我们说动画不过就是一张张有差异的图片在高速的切换，这个高速有多高。就是1/60秒次切换一次就可以了。达到这个帧率，足够欺骗人眼了；</p><p>接着说GPU，如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的后缓冲区中，提交完成之后，GPU会将缓冲区和前缓冲区交换位置，也就是前缓冲区变成后缓冲区，后缓冲区变成前缓冲区，这就保证了显示器下次能读取到GPU中最新的图片；</p><p>这时候我们会发现，显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的；</p><p><img src="vsync.png" alt=""></p><p>这种显示器读取图片和浏览器生成图片不同步，容易造成诸多问题，</p><p>比如丢帧，或者卡顿。为了解决这个问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来；</p><p><strong>当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号给GPU，简称VSync</strong></p><p>具体来讲就是，当GPU接收到Vsync信号后，会将该信号同步给浏览器，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到该信号，就可以准备绘制新的一帧；</p><p>接下来，我们思考一个问题。我们说一个流畅的页面的最好满足60帧，每帧的时间大概是16.67毫秒。</p><p>不知道我们是否还记得页面创建阶段的渲染流水线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM -&gt; Style -&gt; Layout -&gt; Layer -&gt; Paint</span><br></pre></td></tr></table></figure><p>也就是说DOM解析也好，style解析也好。最终都是为了Paint，</p><p>那么在交互阶段，当有js脚本改变DOM的时候。页面同样需要重新走一遍Layout 之后的渲染流水线；而且这一遍最好在16.66毫秒之内完成。不然，会跨帧，频繁跨帧的话，那必然导致页面帧数极速下跌，页面将变得卡顿或者丢帧；</p><p>ok，那既然在16.66毫秒之内完成。那我们来继续盘点一下这16.66毫秒之内都要执行哪些东西呢？</p><h4 id="2-2-2-schedule"><a href="#2-2-2-schedule" class="headerlink" title="2.2.2 schedule"></a>2.2.2 schedule</h4><p>我们前面说，渲染进程是用一个单线程来执行js脚本和页面绘制的。js引擎和页面绘制单元是互斥的。</p><p>那既然是单线程的，这条生产线又有那么多的事情要干。那具体谁先谁后呢？比如用户的event，js引擎的异步代码，web api（比如requestAnimateFrame，requestIdleCallback等等） </p><p><img src="task.png" alt=""></p><p>解释这张图之前，我先强调一下，前端领域经常提的宏队列 微队列。跟这张图没直接关系啊。这张图是整个浏览器渲染线程做的事情，而宏队列和微队列只是js引擎里面调度，js是单线程的和渲染进程这个单线程不是一码事儿；</p><p>说回，这个渲染帧的调度，</p><ul><li>首先最高优先级是用户事件；</li><li>其次会去检查js引擎中定时器相关的程序，有没有已经到点了的。当然如果该任务中含有micro的任务，也一并执行了</li><li>接下来是BOM事件；</li><li>再然后是requestAnimationFrame</li><li>layout</li><li>paint</li><li>requestIdleCallback</li></ul><p>遇事不决直接上代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(animation);</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(animation);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"requestAnimationFrame"</span>, num);</span><br><span class="line">  <span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise----"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// eventType &#123;mouseEvent: 鼠标事件，Event： 自定义事件&#125;</span></span><br><span class="line"><span class="comment">// eventName 事件名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imitatEvent</span>(<span class="params">EventType, EventName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> event = <span class="built_in">document</span>.createEvent(EventType);</span><br><span class="line">  event.initEvent(EventName, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2222</span>, event1.type);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> event1 = imitatEvent(<span class="string">"MouseEvents"</span>, <span class="string">"click"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// element2 为任何dom元素</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(event1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestIdleCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"requestIdleCallback"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="task2.png" alt="image-20210430165400190"></p><p>当然细心的小朋友会发现，有的时候，requestAnimationFrame会跑到setTimout之前，有的时候 requestIdleCallback会执行的更加靠后；</p><p>首先，rAf的执行时机是尽可能的接近帧头。而setTimeout虽然给定了一个0毫秒，但还是取决于当时轮训消息队列的时候，是否有取到这个任务，有取到就有机会执行，没取到就先执行rAf了。再说rIC，rIC的执行时机尽可能放在每一帧的末尾去执行。当然前提是该帧有空余时间，没有空余时间也不行。如果什么时候那一帧有空闲，就有机会执行了。</p><p>好了，到这里我们知道每个渲染帧在干着哪些事情了。</p><p>我们再review一下这些阶段，我们发现我们不能在rAf里面做复杂计算，这种每一帧都需要执行的函数，如果回调过于复杂，那带来的结果就是一些耗时长的任务会横穿一个或多个帧，导致掉帧，页面卡顿；</p><p>这里提一嘴react fiber架构，react fiber架构解决什么问题？ 为什么需要重构到react fiber架构，为什么react15的架构不能满足需求了；</p><p>这是因为 react 在更新的时候需要做diff运算，react的diff是从根节点diff的。这种diff的运算量大，长时间占据渲染帧。导致性能瓶颈。</p><p>后期react fiber架构的出现，主要解决两个问题，首先引进了链表式的数据结构，可以随时存储当前diff的状态，这就解决了单次diff长期占据渲染帧的问题，其次，让每个fiber节点的运算时机尽量在帧尾做，避开渲染帧的正常渲染周期。这样就在维持页面性能的同时，也给足了react节点的计算时间；总体而言，fiber更加的细粒度化了；对资源的使用也更加细粒度化了；</p><h3 id="2-3-消亡阶段"><a href="#2-3-消亡阶段" class="headerlink" title="2.3 消亡阶段"></a>2.3 消亡阶段</h3><blockquote><p>消亡阶段很好理解，就是点击浏览器标签页的关闭按钮，或者在任务管理器中选择某个页面渲染进程，点右下角的结束进程按钮；当执行这些操作之后，浏览器通过操作系统释放相关渲染进程的所有资源；</p></blockquote><h2 id="3-浏览器中的V8引擎"><a href="#3-浏览器中的V8引擎" class="headerlink" title="3. 浏览器中的V8引擎"></a>3. 浏览器中的V8引擎</h2><p>通过上面的阐述，我们大概知道了js引擎在整个浏览器渲染进程中的位置。它的使命和它的能力范围；</p><h3 id="3-1-单线程的js是如何实现异步的"><a href="#3-1-单线程的js是如何实现异步的" class="headerlink" title="3.1 单线程的js是如何实现异步的"></a>3.1 单线程的js是如何实现异步的</h3><p>首先，灵魂拷问，什么是异步？</p><p>在计算机系统中，有一些任务一旦执行，比如socket编程。鬼都不晓得啥时候能执行完。所以我不能一直死等着吧。</p><p>那我能不能先干点别的事儿。好在，计算机系统设计的足够健壮。支持多任务并行；</p><p>表现在实际编程中就是——多线程编程。当一个socket请求进来，要求去读取数据库10万条数据，那我当前进程环境中，创建一个子线程（更高级一点，我会在进程中维护一个线程池。如果有空闲线程，我会让空闲的线程去承接时间未知的IO任务。如果没有空闲，再新建不迟。当然这个线程池上限还取决于硬件环境以及，当前和数据库那边的连接情况来设定，并不是随便给的一个值。），用来处理这条请求，并注册一个回调，如果你10万条数据拿到手了，你告诉我一声。</p><p>然后主进程接着迎接下一个socket请求。</p><p>这个时候10万条好了，主线程拿着10万条数据，然后告诉该子线程去线程池候命。自己唤醒当初客户端connection对象，然后将字节写入该connction。此时，如无后续连接进来，free掉该connection。</p><p>在上面这个事例中，多线程模型就是对异步支持的一种具体表现。用线程池的设计思路去解决IO任务耗时不稳定的问题；</p><p>那我们js引擎怎么弄呢？众所周知，js是单线程的。单线程怎么支持异步呢。</p><p>那就是第二种方案了 <strong>进入队列排队</strong></p><p>在一个单线程环境调度，本来就不是一件容易的事情。</p><p>js引擎将 js代码人为分成拆分成不同的任务</p><h4 id="3-1-1-script"><a href="#3-1-1-script" class="headerlink" title="3.1.1 script"></a>3.1.1 script</h4><p>首先，每个script标签包裹的是一个任务, 当解析到script标签的时候，js引擎会将两个script包裹的代码依次放入队列当中；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"script1"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"script2"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在另一端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(isHasTask) &#123;</span><br><span class="line">next = <span class="built_in">queue</span>.pop() &amp;&amp; next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个死循环会一直试图从队列中读取任务，然后执行。直到队列中所有任务执行殆尽，然后挂起出让调度器等待。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">script1</span><br><span class="line">script2</span><br><span class="line"> 1</span><br><span class="line">promise1</span><br><span class="line"> 2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><p>上面代码执行出这个结果，我们得出结论，除了script标签，setTimeout这种定时器代码也会被当作一个任务放在队列当中。然后Promise这种微任务会在当前任务执行完毕并释放之前全部执行完毕。</p><p>为什么有了任务队列，还要弄个微任务呢。这其实是调度器的一个取舍问题。简单说 就是任务队列颗粒度太大了。</p><h4 id="3-1-2-其他宏任务"><a href="#3-1-2-其他宏任务" class="headerlink" title="3.1.2 其他宏任务"></a>3.1.2 其他宏任务</h4><ul><li>渲染事件（如解析 DOM、计算布局、绘制）；</li><li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li><li>JavaScript 脚本执行事件；</li><li>网络请求完成、文件读写完成事件。</li></ul><h4 id="3-1-3-其他微任务"><a href="#3-1-3-其他微任务" class="headerlink" title="3.1.3  其他微任务"></a>3.1.3  其他微任务</h4><p>第一种方式是使用 MutationObserver 监控某个 DOM 节点</p><h3 id="3-2-任务队列与阻塞"><a href="#3-2-任务队列与阻塞" class="headerlink" title="3.2 任务队列与阻塞"></a>3.2 任务队列与阻塞</h3><p>直接上代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"console.log('click me')"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.resolve().then(loop);</span></span><br><span class="line">    &#125;</span><br><span class="line">    loop();</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们发现，button点击无效。页面一直转圈状态卡死</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"console.log('click me')"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      setTimeout(loop, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    loop();</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跟上面代码类似，但是button点击依然可以输出click me；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"console.log('click me')"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">     <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">       loop()</span><br><span class="line">     &#125;</span><br><span class="line">     loop();</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>迅速栈溢出；</p><p>分别来陈述一下原因；</p><p>首先，说最后一个同步操作，这个很好理解。大部分编程语言的内存模型都存在堆栈结构，栈上存放着函数作用域的执行语句。这个栈虽然足够深，但也不是深到无限。一次同步任务会一次性在一个栈空间的生命周期执行到结束。当执行结束后，栈被回收，操作系统释放栈上内存。直到任务队列下一个任务拿出来，才重新将其函数语句拉入栈中来计算。这个loop函数属于一个任务。所以，栈空间没理由中途释放。那无限递增必然造成栈溢出。</p><p>说中间这个setTimeout，setTimeout会创建一个新任务，当前任务执行完毕之后，栈空间会被释放。所以，这段代码虽然很蠢。但并不是错误代码。早年前，很多人用这种方式做动画。它做动画的坏处在于定时器的间隔无法根渲染帧同步。所以效果肯定不如每一帧都会执行的rAf。</p><p>setTimeout的诸多问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(bar, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">5</span>+<span class="number">8</span>+<span class="number">8</span>+<span class="number">8</span></span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><ol><li>如果当前任务执行时间过久，会影响延迟到期定时器任务的执行</li></ol><p>在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。</p><ol start="2"><li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxTimerNestingLevel = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Chromium uses a minimum timer interval of 4ms. We'd like to go</span></span><br><span class="line"><span class="comment">// lower; however, there are poorly coded websites out there which do</span></span><br><span class="line"><span class="comment">// create CPU-spinning loops.  Using 4ms prevents the CPU from</span></span><br><span class="line"><span class="comment">// spinning too busily and provides a balance between CPU spinning and</span></span><br><span class="line"><span class="comment">// the smallest possible interval timer.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</li></ol><p>如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。</p><ol start="4"><li>延时执行时间有最大值</li></ol><p>Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(showName,<span class="number">2147483648</span>);<span class="comment">// 会被理解立即调用执行</span></span><br></pre></td></tr></table></figure><p>最后说Promise，为什么会卡死。是因为Promise产生的是当前任务的微任务，这里强调一个重点是，微任务和宏任务一样，不会公共栈的同一个生命周期。什么意思呢？就是说，当前一个微任务回调执行完了，会释放栈空间，然后再从栈中取任务拉过来执行；届时又是一个全新的栈环境。所以，当前这个宏任务被永远夯住。任务队列的其他任务，任何优先级很高的 user events都休想执行。</p><p>所以，这也是为什么微任务会像同步函数一样 有阻塞线程的能力；</p><p>说到阻塞，我们需要明晰一个知识细节。js引擎的阻塞 根操作系统维度上的阻塞差不多是一码事儿。</p><p>操作系统的阻塞，只是某个线程阻塞，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面这句代码，它阻塞了当前线程。但是这并不影响进程内其他线程的运行。kernel会将当前阻塞的线程挂起。在调度的时候也不会想起他；</p><p>而在js环境中的阻塞，比如下面这段代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"console.log('click me')"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们发现界面的button都渲染不出来，页面也一直在无限加载。其实这也是一种挂起。也能从侧面渲染线程和js的执行确实是在一个单线程的环境中的。</p><h2 id="4-浏览器缓存"><a href="#4-浏览器缓存" class="headerlink" title="4. 浏览器缓存"></a>4. 浏览器缓存</h2><h3 id="4-1-HTTP缓存"><a href="#4-1-HTTP缓存" class="headerlink" title="4.1 HTTP缓存"></a>4.1 HTTP缓存</h3><blockquote><p>减少不必要的网络传输，缓解服务器压力</p></blockquote><h4 id="4-1-1-强缓存"><a href="#4-1-1-强缓存" class="headerlink" title="4.1.1 强缓存"></a>4.1.1 强缓存</h4><p><img src="cache1.webp" alt=""></p><p>不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache（存放在硬盘中）和 Memory Cache（存放在内存中），存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。</p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>Cache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p><ul><li>max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li><li>no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜</li><li>no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li><li>private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li><li>public：响应可以被中间代理、CDN 等缓存</li><li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li></ul><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。</p><p>本地通过 express 起一个服务来验证强缓存的 3 个属性，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();<span class="keyword">var</span> options = &#123;  </span><br><span class="line">  etag: <span class="literal">false</span>, <span class="comment">// 禁用协商缓存  </span></span><br><span class="line">  lastModified: <span class="literal">false</span>, <span class="comment">// 禁用协商缓存  </span></span><br><span class="line">  setHeaders: <span class="function">(<span class="params">res, path, stat</span>) =&gt;</span> &#123;  </span><br><span class="line">    res.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=10'</span>); <span class="comment">// 强缓存超时时间为10秒  </span></span><br><span class="line">  &#125;,&#125;;</span><br><span class="line">app.use(express.static((__dirname +<span class="string">'/public'</span>), options));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>第一次加载，页面会向服务器请求数据，并在 Response Header 中添加 Cache-Control ，过期时间为 10 秒。</p><p><img src="cache2.png" alt="img"></p><p>第二次加载，Date 头属性未更新，可以看到浏览器直接使用了强缓存，实际没有发送请求。</p><p><img src="cache3.png" alt="img"></p><p>过了 10 秒的超时时间之后，再次请求资源：</p><p><img src="cache17.png" alt="img"></p><p>当 Pragma 和 Cache-Control 同时存在的时候，Pragma 的优先级高于 Cache-Control。</p><p><img src="cache4.png" alt="img"></p><h4 id="4-1-2-协商缓存"><a href="#4-1-2-协商缓存" class="headerlink" title="4.1.2 协商缓存"></a>4.1.2 协商缓存</h4><p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p><h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h5><p>ETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash 码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p>Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。</p><p>本地通过 express 起一个服务来验证协商缓存，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  etag: <span class="literal">true</span>, <span class="comment">// 开启协商缓存 </span></span><br><span class="line">  lastModified: <span class="literal">true</span>, <span class="comment">// 开启协商缓存  </span></span><br><span class="line">  setHeaders: <span class="function">(<span class="params">res, path, stat</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 浏览器不走强缓存   </span></span><br><span class="line">    res.set(&#123;<span class="string">'Cache-Control'</span>:<span class="string">'max-age=00'</span>,</span><br><span class="line">             <span class="string">'Pragma'</span>: <span class="string">'no-cache'</span>, <span class="comment">// 浏览器不走强缓存  </span></span><br><span class="line">            &#125;);  </span><br><span class="line">  &#125;,&#125;;</span><br><span class="line">app.use(express.static((__dirname + <span class="string">'/public'</span>), options));</span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure><p>第一次请求资源:</p><p><img src="cache5.png" alt="img"></p><p>第二次请求资源，服务端根据请求头中的 If-Modified-Since 和 If-None-Match 验证文件是否修改。</p><p><img src="cache6.png" alt="img"></p><p>我们再来验证一下 ETag 在强校验的情况下，只增加一行空格，hash 值如何变化，在代码中，我采用的是对文件进行 MD5 加密来计算其 hash 值。</p><p>注：只是为了演示用，实际计算不是通过 MD5 加密的，Apache 默认通过 FileEtag 中 FileEtag INode Mtime Size 的配置自动生成 ETag，用户可以通过自定义的方式来修改文件生成 ETag 的方式。</p><p>为了保证 lastModified 不影响缓存，我把通过 Last-Modified/If-Modified-Since 请求头删除了，源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> CryptoJS = <span class="built_in">require</span>(<span class="string">'crypto-js/crypto-js'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">var</span> options = &#123;   <span class="attr">etag</span>: <span class="literal">true</span>, <span class="comment">// 只通过Etag来判断</span></span><br><span class="line">               lastModified: <span class="literal">false</span>, <span class="comment">// 关闭另一种协商缓存</span></span><br><span class="line">               setHeaders: <span class="function">(<span class="params">res, path, stat</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">const</span> data = fs.readFileSync(path, <span class="string">'utf-8'</span>); <span class="comment">// 读取文件 </span></span><br><span class="line">           <span class="keyword">const</span> hash = CryptoJS.MD5((<span class="built_in">JSON</span>.stringify(data))); <span class="comment">// MD5加密   </span></span><br><span class="line">           res.set(&#123;<span class="string">'Cache-Control'</span>: <span class="string">'max-age=00'</span>, </span><br><span class="line">                          <span class="comment">// 浏览器不走强缓存     </span></span><br><span class="line">                          <span class="string">'Pragma'</span>: <span class="string">'no-cache'</span>, </span><br><span class="line">                          <span class="comment">// 浏览器不走强缓存      </span></span><br><span class="line">                          <span class="string">'ETag'</span>: hash, </span><br><span class="line">                          <span class="comment">// 手动设置Etag值为MD5加密后的hash值   </span></span><br><span class="line">                         &#125;);  &#125;,&#125;;</span><br><span class="line">app.use(express.static((__dirname + <span class="string">'/public'</span>), options));</span><br><span class="line">app.listen(<span class="number">4000</span>); <span class="comment">// 使用新端口号，否则上面验证的协商缓存会一直存在</span></span><br></pre></td></tr></table></figure><p>第一次和第二次请求如下：</p><p><img src="cache7.png" alt="img"></p><p><img src="cache8.png" alt="img"></p><p>然后我修改了 test.js ，增加一个空格后再删除一个空格，保持文件内容不变，但文件的修改时间改变，发起第三次请求，由于我生成 ETag 的方式是通过对文件内容进行 MD5 加密生成，所以虽然修改时间变化了，但请求依然返回了 304，读取浏览器缓存。</p><p><img src="cache9.png" alt="img"></p><p>ETag/If-None-Match 的出现主要解决了 Last-Modified/If-Modified-Since 所解决不了的问题：</p><ul><li>如果文件的修改频率在秒级以下，Last-Modified/If-Modified-Since 会错误地返回 304</li><li>如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304，上面的例子就说明了这个问题</li></ul><p>在实际使用场景中，图片、不常变化的 JS 等静态资源都会使用缓存来提高页面的加载速度</p><h3 id="4-2-浏览器缓存"><a href="#4-2-浏览器缓存" class="headerlink" title="4.2 浏览器缓存"></a>4.2 浏览器缓存</h3><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p><h4 id="from-disk-cache和from-memory-cache"><a href="#from-disk-cache和from-memory-cache" class="headerlink" title="from disk cache和from memory cache"></a>from disk cache和from memory cache</h4><p>Chrome的网络请求的Size会出现三种情况<code>from disk cache(磁盘缓存)</code>、<code>from memory cache(内存缓存)</code>、以及资源大小数值。</p><p><img src="https://pic1.zhimg.com/80/v2-fa21b4ae1b1c2ff3f696256684880864_1440w.jpg" alt="img"></p><p>浏览器读取缓存的顺序为memory –&gt; disk。 以访问<code>https://github.com/xiangxingchen/blog</code>为例 我们第一次访问时<code>https://github.com/xiangxingchen/blog</code></p><p><img src="cache10.png" alt="img"></p><p>关闭标签页，再此打开<code>https://github.com/xiangxingchen/blog</code>时</p><p><img src="cache11.png" alt="img"></p><p>F5刷新时</p><p><img src="cache12.png" alt="img"></p><p>简单的对比一下</p><p><img src="cache13.png" alt="img"></p><p>浏览器可以在内存、硬盘中开辟一个空间用于保存请求资源副本。我们经常调试时在 DevTools Network 里看到 Memory Cache（內存缓存）和 Disk Cache（硬盘缓存），指的就是缓存所在的位置。请求一个资源时，会按照优先级（Service Worker -&gt; Memory Cache -&gt; Disk Cache -&gt; Push Cache）依次查找缓存，如果命中则使用缓存，否则发起请求。这里先介绍 Memory Cache 和 Disk Cache。</p><p><strong>200 from memory cache</strong></p><p>表示不访问服务器，直接从内存中读取缓存。因为缓存的资源保存在内存中，所以读取速度较快，但是关闭进程后，缓存资源也会随之销毁，一般来说，系统不会给内存分配较大的容量，因此内存缓存一般用于存储较小文件。同时内存缓存在有时效性要求的场景下也很有用（比如浏览器的隐私模式）。</p><p><strong>200 from disk cache</strong></p><p>表示不访问服务器，直接从硬盘中读取缓存。与内存相比，硬盘的读取速度相对较慢，但硬盘缓存持续的时间更长，关闭进程之后，缓存的资源仍然存在。由于硬盘的容量较大，因此一般用于存储大文件。</p><p>下图可清晰看出差别：</p><p><img src="cache14.png" alt="img"></p><p><strong>200 from prefetch cache</strong></p><p>在 preload 或 prefetch 的资源加载时，两者也是均存储在 http cache，当资源加载完成后，如果资源是可以被缓存的，那么其被存储在 http cache 中等待后续使用；如果资源不可被缓存，那么其在被使用前均存储在 memory cache。</p><p><img src="cache15.png" alt="img"></p><p><strong>CDN Cache</strong></p><p>以腾讯 CDN 为例：X-Cache-Lookup:Hit From MemCache 表示命中 CDN 节点的内存；X-Cache-Lookup:Hit From Disktank 表示命中 CDN 节点的磁盘；X-Cache-Lookup:Hit From Upstream 表示没有命中 CDN。</p><p><img src="cache16.png" alt="img"></p><h3 id="4-3-http1，http2，http3概述"><a href="#4-3-http1，http2，http3概述" class="headerlink" title="4.3 http1，http2，http3概述"></a>4.3 http1，http2，http3概述</h3><blockquote><p>转载</p></blockquote><p>为了更好理解文章，需要解释一下什么是RTT？</p><p>RTT是Round Trip Time的缩写，通俗地说，就是通信一来一回的时间。</p><p>TCP建立连接时间</p><p>最早大家使用TCP来运输HTTP，TCP想必大家很熟悉了，需要三次握手，建立了TCP虚拟通道，那么这三次握手需要几个RTT时间呢？</p><p>一去 （SYN）</p><p>二回 （SYN+ACK）</p><p>三去 （ACK）</p><p>相当于一个半来回，故TCP连接的时间 = 1.5 RTT 。</p><p>HTTP交易时间</p><p>这意味着，用户在浏览器里输入的网址URL，直到时间流逝了1.5RTT之后，TCP才开始运输HTTP Request，浏览器收到服务器的HTTP Response，又要等待的时间为：</p><p>一去（HTTP Request）</p><p>二回 （HTTP Responses）</p><p>故HTTP的交易时间 = 1 RTT</p><p>那么基于TCP传输的HTTP通信，一共花费的时间总和：</p><p>HTTP通信时间总和 = TCP连接时间 + HTTP交易时间 = 1.5 RTT + 1 RTT = 2.5 RTT</p><p>安全加密通信</p><p>随着互联网的爆发式增长，人类发现完全明文传输的HTTP通信很不安全。做为OSI七层参考模型的现实实现的TCP/IP协议，在设计之初没有考虑安全加密的环节。</p><p>互联网先驱Netscape公司，创造性发明了SSL（Secure Socket Layer），SSL位于TCP与HTTP之间，做为HTTP的安全供应商，全权负责HTTP的安全加密工作。</p><p>IP / TCP / SSL / [HTTP]</p><p>各个通信模块之间的站位如上所示，将HTTP用[ ]括起来，表示HTTP被SSL安全加密了。</p><p>随着SSL的名气攀升，互联网标准化组织IETF，觉得SSL是一个好东西，就拿来用了。</p><p>但SSL最初只是用于加密HTTP的，IETF觉得这是一个硬伤，为什么不能用来做为所有应用层协议的安全供应商呢？来传输邮件、文件、新闻等等。实现这一点很简单，只要在协议里增加一个Application Protocol 类型字段。</p><p>在Application Protocol 有一个类型是“IP”, 意味着TLS不仅可以运输应用层协议如HTTP、FTP，还可以运输IP，这就是Cisco Any Connect的应用场景。</p><p>TLS (Transport Layer Security)</p><p>于是，IETF在SSL 3.0版本的基础上，重新设计并命名了这个协议，其全新的名字为TLS，最初的版本为1.0版本。从其名字就可以看出，其核心使命就是保证传输层的安全。各个通信部门成员的占位与SSL占位一致：</p><p>IP / TCP / TLS / [HTTP]</p><p>到目前为止，浏览器支持的TLS版本为TLS 1.0、1.1、1.2，当然版本越高越成熟、越安全。</p><p>HTTPS</p><p>通常将TLS安全保护的HTTP通信，称之为HTTPS，以区别于没有TLS安全防护的HTTP明文通信。</p><p>交待了上文的背景知识，还是要回到本文的主题，来看看自从引入了TLS安全防护，看看HTTPS通信的RTT增加到了多少？</p><p>TLS 1.2</p><p>以1.2 版本为例，看看HTTPS通信一共要消耗几个RTT时间？</p><p>\1. 浏览器给服务器发送的Client Hello消息（一去）</p><p>首长好，我支持1.2版本，加密套件列表1、2、3…，以及我的随机码N1，请出示您的证件。</p><p>\2. 服务器给浏览器发送的Server Hello消息（二回）</p><p>同志们好，那就1.2版本通信吧，加密套件我选用1，我的随机码N2，ECDHE密钥交换素材2，这是我的证件。</p><p>同志们辛苦了！</p><p>\3. 浏览器给服务器发送的Key Exchange消息（三去）</p><p>为人民服务！ 嘴里虽这么说着，私下还要偷偷验证首长的证件是否伪造的。</p><p>首长证书验证成功之后，还要给首长会话呢？会话内容如下：</p><p>首长辛苦了！ 我的ECDHE密钥交换素材1，接下来我发给您的消息都要加密了（Change Spec）。</p><p>从这以后，双方的HTTP通信将使用TLS加密了。一共花费了1.5个RTT时间。</p><p>让我们来计算一下整个HTTPS通信花费的时间总和：</p><p>HTTPS通信时间总和 = TCP连接时间 + TLS 连接时间 + HTTP交易时间 = 1.5 RTT + 1.5 RTT + 1 RTT = 4 RTT</p><p>如果浏览器与服务器物理距离很近，RTT &lt; 10 ms，即使4 RTT最大也不过40 ms的时间，用户压根感觉不到慢。</p><p>如果浏览器与服务器相隔上万公里，一个RTT时间通常在200ms以上，4RTT时间通常在1秒以上，用户会明显感觉到网速慢了。</p><p>HTTP 1.x</p><p>和很多人想象不一样的是，浏览器从服务器获取的一个页面，通常由很多资源链接所组成。</p><p>服务器给浏览器推送的第一个页面，页面里通常嵌入了图片资源文本链接、以及动态页面资源链接、或第三方网站的链接资源，还需要浏览器根据这些文本链接内容，去链接所对应的服务器，继续下载链接所对应的内容。</p><p>浏览器通常采用的流程是，重新建立一个TCP连接、TLS连接、HTTP交易。</p><p>这又是一个漫长的4RTT等待过程，用户看到浏览器完整页面的时间为</p><p>完整页面加载时间 = 4RTT *2 = 8RTT</p><p>HTTP /2</p><p>自然有人会问，既然第一次页面与第二次页面都是同一个网站服务器，为何第二次页面要重新建立一个TCP连接，一个TLS连接？</p><p>如果重用第一个TCP连接，那么就少了1.5 RTT + 1.5 RTT = 3 RTT的时间。</p><p>这是一个好主意，就是用户的多个HTTP Request请求，使用同一个逻辑通道进行运输，这样会大大减少重新建立连接所花费的时间。</p><p>但是，这样会带来一个副作用，多个HTTP流使用同一个TCP连接，遵守同一个流量状态控制。只要第一个HTTP流遭遇到拥塞，剩下的HTTP流压根没法发出去，这就是头部阻塞（Head of line Blocking）。</p><p>既然TCP不好用，那为何要吊死在TCP这一棵树上呢？</p><p>外面的世界很精彩，到外面的世界逛逛。</p><p>QUIC（Quick UDP Internet Connection）</p><p>逛下来的感受是，UDP不需要连接，不会带来附加的RTT时间，UDP是一个好的合伙人被HTTP /2拉上了贼船，各合伙人的占位如下：</p><p>IP / UDP / QUIC</p><p>这个就是Google开发QUIC协议，QUIC协议集成了TCP可靠传输机制、TLS安全加密、HTTP /2 流量复用技术，其页面的加载时间为2.5 RTT时间。</p><p>此外，完成QUIC交易的连接的Session ID会缓存在浏览器内存里，如果用户再次打开该页面，无需建立TLS连接，直接使用缓存Session ID 对应的加密参数，服务器可以根据Session ID在缓存里查找对应的加密参数，并完成加密。</p><p>换句话说，重连TLS连接是一个0 RTT 事件，用户所要等待的页面加载事件 = HTTP交易事件 = 1 RTT。</p><p>HTTP /3</p><p>这一次IETF又觉得QUIC是一个好东西，但是希望QUIC不仅可以运输HTTP，还可以运输其它协议，把QUIC与HTTP分离，最终各合伙人的占位如下所示：</p><p>IP / UDP / QUIC / HTTP</p><p>这样整体的页面加载时间为2 RTT。</p><p>TLS 1.3</p><p>IETF的QUIC标准集成了TLS 1.3版本，1.3版本更简练，建立TLS连接不再需要1.5 RTT，而只需要1 RTT，是因为浏览器第一次就把自己的密钥交换的素材发给服务器，这样就节省了第三次消息，少了0.5个RTT时间。</p><p>页面的整体加载时间 = TLS 1.3连接时间 + HTTP交易时间 = 1RTT + 1RTT = 2 RTT</p><p>重连页面的加载时间 = HTTP交易时间 = 1 RTT</p><p>上文协议的进化过程就是人类与RTT斗争史，目标是减少用户等待页面加载时间、同时保证用户看到的页面安全，没有在传输过程中被偷窥、篡改。</p><p>HTTP /3所带来的挑战</p><p>99%+以上的手机移动终端、电脑终端，都使用私有IP，都需要NAT设备来完成私有IP与全球IP的转换。这意味着NAT设备通常会记忆用户的通信状态，一旦用户完成了通信，NAT设备会释放这些记忆。</p><p>对于基于TCP的HTTP、HTTPS传输，NAT设备可以根据TCP报文头的SYN / FIN状态位，知道通信什么时候开始，什么时候结束，对应记忆的开始、记忆的结束。</p><p>但是基于UDP传输的HTTP/3，NAT设备收到流量会知道连接什么时候开始，但是却无法知道流量什么时候结束。</p><p>NAT设备的记忆如果短于用户会话时间，则用户会话会中断。</p><p>NAT设备的记忆如果大大长于用户会话时间，则意味着NAT设备的端口资源会白白被占用！</p><p>最直接的解决方案是，在QUIC的头部模仿TCP的SYN/FIN状态，让沿途的NAT设备知道会话什么时候开始、什么时候结束。但这需要升级全球所有的NAT设备的软件！</p><p>另外一个可行的方案是，让QUIC周期性地发送Keepalive消息，刷新NAT设备的记忆，避免NAT设备释放自己的记忆</p><p><strong>为何HTTP/3不直接站在IP身上，而是站在UDP身上？</strong></p><p>可以少8个字节的UDP头部开销不是很好嘛？</p><p>上文已经说了，全球的通信终端绝大多数位于NAT的身后，地球上任何NAT产品都支持TCP/UDP运输的货物，即可以根据端口号来识别不同的终端、不同终端的会话。</p><p>如果QUIC站在IP身上，如下所示：</p><p><strong>IP /QUIC / HTTP</strong></p><p>QUIC并没有端口号，意味着每一个NAT设备只能记忆一个终端的会话，一个全球IP 与一个私有IP的一一映射。</p><p>那将意味着NAT设备后只能有一个会话可以访问同一个服务器的页面，这肯定是无法接受的！</p><h2 id="5-浏览器中的网络"><a href="#5-浏览器中的网络" class="headerlink" title="5. 浏览器中的网络"></a>5. 浏览器中的网络</h2><h2 id="8-浏览器中的V8"><a href="#8-浏览器中的V8" class="headerlink" title="8. 浏览器中的V8"></a>8. 浏览器中的V8</h2><blockquote><p>在V8出现之前，所有js虚拟机所采用的都是解释执行的方式，这是js执行速度过慢的一个主要原因，而V8率先引入即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给js的执行速度带来的极大的提升；</p><p>另外，V8也早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制；进一步优化了js代码的编译执行效率；</p></blockquote><h3 id="8-1-了解V8的意义"><a href="#8-1-了解V8的意义" class="headerlink" title="8.1 了解V8的意义"></a>8.1 了解V8的意义</h3><p>单纯的使用js和调用web API，并不了解虚拟机内部是怎么工作的，在项目中遇到的很多问题都可能找不到解决的途径。</p><p>比如，有时候项目的占用内存过高，或者页面响应速度过慢，又或者使用Nodejs的时候导致任务被阻塞等问题，都与V8的基本运行机制有关，如果你熟悉V8的工作机制，就会有系统性的思路来解决这些问题；</p><h3 id="8-2-V8编译流水线概览"><a href="#8-2-V8编译流水线概览" class="headerlink" title="8.2 V8编译流水线概览"></a>8.2 V8编译流水线概览</h3><p>V8执行js代码的完整流程（V8的编译流水线）</p><p><img src="v81.jpg" alt=""></p><p>编译流水线本身并不复杂，但是其中涉及到了很多技术，JIT，延迟解析，隐藏类，内联缓存等等。这些技术决定一段js代码能否正常执行，以及代码的执行效率；</p><p>V8使用的隐藏类（Hide Class），这是将JS中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行过慢的问题，熟悉V8这一机制之后，在你编写js时，就能充分利用好隐藏类这种强大的优化特性，写出更高效的代码；</p><p>V8实现了代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，你可以优化你的代码更加适应这个机制，从而提供程序性能；</p><p>另外两个非常重要的特性需要了解，<strong>事件循环系统</strong> 和 <strong>垃圾回收机制</strong></p><p>事件循环系统和js中的难点——异步编程特性紧密相关，js是单线程的，js代码都是在一个线程上执行，如果同一时间发送了多个js执行的请求，就需要排队，也就是进行异步编程；</p><p>V8事件循环系统会调度这些排队任务，保证js代码被V8有序的执行，因此也可以说，事件循环系统就是V8的心脏，它驱动了V8持续工作；</p><p>js是一种自动垃圾回收的语言，V8在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，也是我们经常会遇到一个问题，你需要知道V8是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完成的系统，当下次遇到内存问题的，就知道如何去排查了；</p><h3 id="8-3-V8是如何执行一段js代码"><a href="#8-3-V8是如何执行一段js代码" class="headerlink" title="8.3 V8是如何执行一段js代码"></a>8.3 V8是如何执行一段js代码</h3><blockquote><p>其主要核心流程分为编译和执行两步，首先需要将js代码转换为低级中间代码或机器码，然后执行转换后的代码并输出结果；</p></blockquote><p><img src="v8_1.jpg" alt=""></p><p>可以将V8看成是一个虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的CPU，堆栈、寄存器等，虚拟机还具有它自己的一套指令系统；</p><p>对于js来说，V8就是它的一切，当V8执行js时，开发者并不需要担心不同os之间的差异，也不需要担心不同体系结构计算机的差异，你只需要按照虚拟机的规范写好代码就可以了；</p><h4 id="8-3-1-计算机语言"><a href="#8-3-1-计算机语言" class="headerlink" title="8.3.1 计算机语言"></a>8.3.1 计算机语言</h4><blockquote><p>CPU是如何执行机器代码的，你可以把CPU看成是一个非常小的运算机器，开发者可以通过二进制的指令和CPU进行沟通，当处理器执行到某条指令时，便会按照指令的意思去实现相关的操作；</p></blockquote><p>为了能够完成复杂的任务，工程师为CPU提供了一大推指令，来实现各种功能，我们就把这一大堆指令称为指令集（instructions），也就是机器语言；</p><h5 id="8-3-1-1-汇编"><a href="#8-3-1-1-汇编" class="headerlink" title="8.3.1.1 汇编"></a>8.3.1.1 汇编</h5><p>cpu只能识别二进制指令，但是对程序员来说，二进制代码难以阅读记忆，于是，先驱又将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令集；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000100111011000 # 机器指令</span><br><span class="line">mov ax,bx.       # 汇编指令</span><br></pre></td></tr></table></figure><p>CPU并不能直接识别一段汇编程序，还需要一个汇编编译器，其作用是将汇编代码编程成机器代码；</p><p><img src="asm1.jpg" alt=""></p><p>虽然汇编语言对机器语言做了一层抽象，减少了程序员理解机器语言的复杂度，但是汇编语言依然是复杂且繁琐的，即便你写了一个简单的功能，也需要大量的汇编代码，主要原因在于</p><p>首先，<strong>不同cpu有着不同的指令集，</strong>如果开发者要使用机器代码或者汇编语言来实现一个功能，需要为每种架构的CPU编写特定的汇编代码；</p><p>其次，在编写汇编代码时，还需要了解和处理器架构相关的硬件知识，比如需要使用寄存器，内存，操作CPU等；大部分程序员在编写应用的时候，只想专心处理业务逻辑，并不想要过多理会这些处理器架构相关的细节；因此需要一种屏蔽计算机架构细节的语言，能够适应多种不同CPU架构的语言，能专心处理业务逻辑的语言，如C/C++，java，js等多种“高等语言”；</p><p>和汇编语言一样，处理器不能直接识别由高级语言所编写的代码，通常，要用两种方式来执行这些代码； <strong>解释执行</strong> 和 <strong>编译执行</strong></p><h5 id="8-3-1-2-解释执行"><a href="#8-3-1-2-解释执行" class="headerlink" title="8.3.1.2 解释执行"></a>8.3.1.2 解释执行</h5><p><img src="jieshi1.jpg" alt=""></p><p>解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果；</p><h5 id="8-3-1-3-编译执行"><a href="#8-3-1-3-编译执行" class="headerlink" title="8.3.1.3 编译执行"></a>8.3.1.3 编译执行</h5><p><img src="compiler1.jpg" alt=""></p><p>编译执行，也需要先将源代码转换为中间代码，然后编译器再将中间代码编译成机器代码，通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了，还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码；</p><h5 id="8-3-1-4-总结"><a href="#8-3-1-4-总结" class="headerlink" title="8.3.1.4 总结"></a>8.3.1.4 总结</h5><p>以上就是计算机执行高级语言的两种基本方式： 解释执行和编译执行。针对不同的高级语言，这个实现方式还是有很大差异的，比如要执行C语言编写的代码，需要将其编译成二进制代码的文件；然后直接执行二进制文件，而对于像java/js 语言等，则需要不同虚拟机，模拟计算机的这个编译执行流程，执行java语言，需要经过java虚拟机的转换，执行js需要经过js虚拟机的转换；</p><h4 id="8-3-2-V8执行javascript代码"><a href="#8-3-2-V8执行javascript代码" class="headerlink" title="8.3.2 V8执行javascript代码"></a>8.3.2 V8执行javascript代码</h4><blockquote><p>实际上，V8并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为JIT（Just In Time）技术</p><p>这是一种权衡策略，因为这两种方法都有各自的优缺点，解释执行启动速度快，但是执行速度慢，而编译执行启动速度慢，但是执行时的速度快。</p></blockquote><p><img src="v8_2.jpg" alt=""></p><p>在V8启动执行js之前，它还需要准备执行js是所需要的一些基础环境；</p><p>基础环境准备之后，接下来就可以向V8提交要执行的js代码了；这时候的js代码对于V8来说只是一堆字符串，V8需要先结构化它；也就是生成AST，在生成AST的同时，V8还会生成相关的作用域；有了AST和作用域之后，接下来就可以生成字节码了；</p><p>生成字节码之后，解释器就登场了，它会按照顺序解释执行字节码，并输出执行结果；</p><h5 id="8-3-2-1-运行时-基础环境"><a href="#8-3-2-1-运行时-基础环境" class="headerlink" title="8.3.2.1  运行时(基础环境)"></a>8.3.2.1  运行时(基础环境)</h5><blockquote><p>在V8启动执行js之前，它还需要准备执行js时所需要的一些基础环境，这些基础环境包括了“堆空间”，“栈空间”， “全局执行上下文”，“全局作用域”，“消息循环系统”，“内置函数”等，这些内容都是在执行js过程中需要使用到的；准备好运行时环境之后，V8才可以执行js代码，这包括解析源码，生成字节码，解释执行或者编译执行等一系列操作；</p></blockquote><ul><li>js全局执行上下文就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息；</li><li>全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；</li><li>V8采用经典的堆栈的管理内存管理模式，所以V8还需要初始化内存中的堆栈结构；</li><li>V8系统活起来，还需要初始化消息循环系统，消息循环系统包含了消息驱动器和消息队列，它如同V8的心脏，不断接受消息并决策如何处理消息；</li></ul><p>对运行时足够理解，能够帮助我们更好理解V8的执行流程，比如事件循环系统可以让你清楚各种回调函数是怎么被执行的，栈空间可以让你了解函数是怎么被调用的，堆空间和栈空间让你了解为什么要有传值和传引用，等等；</p><p><img src="v8_3.jpg" alt=""></p><h5 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a><strong>宿主环境</strong></h5><p>宿主是指为寄生物提供生存环境的生物，V8和浏览器的渲染进程就是 寄生物和宿主细胞的关系，<strong>浏览器为V8提供基础的消息循环系统，全局变量，web API</strong>，而V8的核心是实现了ECMAScript标准；这相当于病毒自己的DNA，V8只提供了ECMAScript定义的一些对象和一些核心的函数，还包括了Object，Function，String，除此之外，V8还提供了垃圾回收器、协程等基础内容，不过这些功能依然需要宿主环境的配合才能完整执行；</p><p>如果V8使用不当，比如不规范的代码触发了频繁的垃圾回收，或者某个函数执行时间过久，这些都会占用宿主环境的主线程，从而影响到程序的执行效率，甚至导致宿主环境的卡死；</p><p>同样，除了浏览器，Nodejs也算是V8的宿主环境之一，它提供了不同的宿主对象和宿主的API，但是整个流程依然是相同的，比如Node.js也会提供一套消息循环系统，也会提供一个运行时的主线程；</p><p><img src="v8_4.jpg" alt=""></p><p>Ok,我们知道，要执行V8，则需要有一个宿主环境，宿主环境可以是浏览器中的渲染进程，可以是Nodejs进程，也可以是其他的定制开发的环境，而这些宿主则提供了很多V8执行js时所需的基础功能部件；比如</p><h5 id="构造数据存储空间：堆栈"><a href="#构造数据存储空间：堆栈" class="headerlink" title="构造数据存储空间：堆栈"></a><strong>构造数据存储空间：堆栈</strong></h5><p>V8是寄生在浏览器或者Nodejs这些宿主中的，V8也是被这些宿主启动的，在Chrome中，只要打开了一个渲染进程，渲染进程便会初始化V8，同时初始化堆空间和栈空间；</p><p>栈空间主要是用来管理js函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略，在函数调用过程中，涉及到上下文相关的内容都会存放栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this值等都会存在在栈上，当一个函数执行结束，那么该函数的执行上下文便会被销毁掉；</p><p>栈空间的最大特点是空间连续，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8对栈空间的大小做了限制，如果函数调用层过深，那么V8就有可能抛出栈溢出的错误，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">50000</span>) <span class="comment">// maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><p>如果有一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，使用栈空间就显得不合适了，而且栈上分配的数据过大，也会导致栈溢出，基于栈不方便存储大的数据，所以有了堆空间；</p><p>堆空间是一种树形存储结构，用来存储对象类型的离散的数据，存放在堆空间中的数据是不要求连续存放的，从堆上分配内存没有固定模式的，可以在任何时候分配和释放它。js中除了原生类型的数据，其他的都是对象类型，诸如函数，数组，在浏览器中还有window对象，document对象都是存在堆空间的；</p><p>另外</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *z = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">Point *pp = <span class="keyword">new</span> Point()</span><br></pre></td></tr></table></figure><p>诸如 new int, new Point这些语句，当执行这些语句时，表示要在堆中分配一块内存，然后返回指针，通常返回的指针会被保存到栈中，</p><p><img src="v8_12.jpg" alt=""></p><p>如上图，当使用new时，会在堆中分配一块空间，在堆中分配空间之后，会返回分配后的地址，我们会把改地址保存在栈中，如上图中p和pp都是地址，它们保存在栈中，指向了在堆中分配的空间；当栈中的函数调用执行完毕，栈中的指针地址 也被清理掉了；因此c语言中函数返回指针地址的操作，通常都是不合法的。而且在函数执行完毕之后，没有及时 free掉堆上数据的话，那么造成的影响就是内存泄漏了；</p><p>宿主在启动V8的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中；</p><p>（这里会有一个问题，这个堆栈空间到底是V8创建的还是宿主环境（浏览器渲染进程）创建的？<br>其实这个问题不用太过纠结，因为v8和宿主同在一个进程，那必然是共用一套内存空间，通常在启动V8过程中，宿主会创建好堆栈空间，在V8里面叫solate，然后V8利用创建好的堆和栈）</p><p><strong>为什么使用栈结构来管理函数调用</strong></p><blockquote><p>大部分高级语言都不约而同地采用栈这种结构来管理函数调用</p></blockquote><p>函数通常有两个主要特征</p><ol><li>函数可以被调用，你可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制权将从父函数转移到子函数，子函数执行结束之后，又会将代码执行控制权返还给父函数；</li><li>函数具有作用域机制，所谓作用域机制，是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量我们称为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> z = getZ();</span><br><span class="line">  <span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = add(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当main函数调用add函数时，需要将代码执行控制权给add；</li><li>add函数又调用了getZ函数，于是又将代码控制权交给getZ函数；</li><li>接下来getZ执行完毕，需要将控制权返回给add函数；</li><li>同样当add函数执行结束之后，需要将控制权返还给main函数；</li><li>然后main函数继续向下执行；</li></ul><p><img src="v8_6.jpg" alt=""></p><p><em>函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者的生命周期结束（先出）</em></p><p><em>站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数（后进），而函数资源的释放则总是先于调用函数（先出）</em></p><p><strong>栈如何管理函数调用</strong></p><p><img src="v8_7.jpg" alt=""></p><p>如图所示，<em>函数在执行过程中，其内部的临时变量会按照执行顺序被压入到栈中的</em></p><p><img src="v8_8.jpg" alt=""></p><p>当执行到add函数时，会先把num1和num2压栈，接着再把x，y，ret的值依次压栈，但是当add函数执行完毕之后，需要将执行代码的控制权转交给main函数，这意味着需要将栈的状态恢复到main函数上次执行时的状态，我们将这个过程叫做恢复现场，那么应该怎么恢复main函数的执行现场呢？</p><p><em>答案是，在寄存器中保存一个永远指向当前栈顶的指针，栈顶指针的作用就是告诉你应该往哪个位置添加新元素，这个指针通常存放在esp寄存器中。然后增删元素都要实时将地址值更新esp寄存器中的这个值，恢复现场，只需要将栈顶指针向下移动就可以了</em></p><p>如上图所示，从100000f97 -&gt; 100000f92就可以了；</p><p>但问题是，我怎么知道要移动到 f92，而不是f90或者其他什么位置；解决这个问题的操作是，CPU增加了一个ebp寄存器保存当前函数的开始位置；我们把一个函数的起始位置也称为栈帧指针；</p><p><img src="v8_9.jpg" alt=""></p><p>如上图所示，在main函数调用add函数的时候，main函数的栈顶指针 100000f93就变成了add函数的栈帧指针（ebp）了，所以需要将main函数的栈顶指针保存到ebp中，</p><p>当add函数执行结束之后，我需要销毁add函数的栈帧，并恢复main函数的栈帧，那么只需要取出main函数的栈顶指针写到esp中即可（main函数的栈顶指针是保存在ebp中的），这就相当于将栈顶指针移动到main函数的区域；</p><p>那main函数的ebp中的值写到esp了。那main函数的ebp怎么处理？</p><p>通常的做法是，CPU在调用add函数时，会将当前main函数的栈帧指针保存在栈中；</p><p><img src="v8_11.jpg" alt=""></p><p>当函数调用结束之后，就需要恢复main函数的执行现场了，首先取出ebp中的指针，写入esp中，然后从栈中取出之前保留的main的栈帧地址，将其写入ebp中，到了这里ebp和exp就都恢复了，可以继续执行main函数了；</p><p><strong>栈帧</strong></p><p>每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数返回地址和局部变量，如果调用一个新函数，那么V8会为该函数创建栈帧，等函数执行结束之后，销毁该栈帧，而帧结构的容量是固定的，所有如果重复嵌套执行一个函数，那么就会导致栈会栈溢出；</p><h5 id="全局执行上下文和全局作用域"><a href="#全局执行上下文和全局作用域" class="headerlink" title="全局执行上下文和全局作用域"></a><strong>全局执行上下文和全局作用域</strong></h5><p>V8初始化了基础的存储空间之后，接下来就需要初始化全局执行上下文和全局作用域了。这两个内容是V8执行后续流程的基础；</p><p>当V8开始执行一段可执行代码时，会生成一个执行上下文，V8用执行上下文来维护执行当前代码所需要的变量声明，this指向等；</p><p>执行上下文主要包含了“<strong>变量环境，词法环境，this关键字</strong>”等，比如在浏览器的环境中，全局执行上下文就包括了window对象，还是默认指向window的this关键字，另外还有一些web API函数，诸如setTimeout，XMLHttpRequest等内容；</p><p>而词法环境中，则包含了使用let，const等变量的内容</p><p><img src="v8_5.jpg" alt=""></p><p>全局执行上下文在V8的生存周期内是不会被销毁的，它会一直保存在堆中，这样当下次在需要使用函数或者全局变量时，就不需要重新创建了，另外，当执行一段全局代码时，如果全局代码中有声明的函数或定义的变量，那么函数对象和声明的变量都会被添加到全局执行上下文中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_x</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v8在执行这段代码中，会在全局执行上下文中添加变量x和函数show_x;这里需要提示一个消息就是，浏览器环境下，全局中使用var声明的对象或者变量都会被写入window对象，这带来的坑就是gc不会主动去收集这部分内存空间；</p><p>当V8调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈结构，比如执行下面这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  show_x()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>当执行到show_x()，其栈的状态如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- show_x 执行上下文</span><br><span class="line">|- bar执行上下文</span><br><span class="line">| 全局执行上下文</span><br></pre></td></tr></table></figure><h5 id="构造事件循环系统"><a href="#构造事件循环系统" class="headerlink" title="构造事件循环系统"></a><strong>构造事件循环系统</strong></h5><p>有了堆空间和栈空间，生成全局执行上下文和全局作用域，接下来还不能执行js代码；</p><p>因为V8还需要一个主线程，用来执行js和执行垃圾回收等工作，V8是寄生在宿主环境中的，它并没有自己的主线程，而是使用宿主所提供的主线程，V8所执行的代码都是在宿主的主线程上执行的；</p><p>只有一个主线程依然不行，因为如果你开启了一个线程，在该线程执行一段代码，那么当该线程执行完这段代码之后，就会自动退出了；执行过程中的一些栈上的数据也随之被销毁，下次再执行另外一个段代码时，你还需要重新启动一个线程，重新初始化栈数据，这会严重影响到程序执行时的性能；</p><p>为了在执行完代码之后，让线程继续运行，通常的做法是在代码中添加一个循环语句，在循环语句中监听下个事件，这在一个http服务器程序中会被经常使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  Task task = GetNewTask();</span><br><span class="line">  RunTask(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果主线程正在执行一个任务，这时候又进来一个新任务，比如V8正在操作DOM，这时候浏览器的网络线程完成了一个页面下载的任务，而且V8注册监听下载完成的事件，那么这种情况下就需要引入一个消息机制，让下载完成的事件暂存到消息队列中，等当前的任务（DOM操作）执行结束之后，再从消息队列中取出正在排队的任务。当执行完一个任务之后。事件循环系统会重复这个过程，继续从消息队列中取出并执行下个任务；</p><p>因为所有的任务都是运行在主线程的，在浏览器的页面中，<em>V8会和页面共用主线程，共用消息队列，所以如果V8执行一个函数过久，会影响到浏览器页面的交互性能；</em></p><h5 id="8-3-2-2-AST和作用域"><a href="#8-3-2-2-AST和作用域" class="headerlink" title="8.3.2.2  AST和作用域"></a>8.3.2.2  AST和作用域</h5><blockquote><p>在基础环境准备好之后，接下来就可以向V8提交要执行的js代码了；</p></blockquote><p>js代码输入进来是一段字符串，需要先结构化它。也就是先生成AST，AST是便于V8理解的结构；</p><p>在生成AST的同时，V8还需要生成相关的作用域，作用域中存放相关变量；</p><p>有了AST和作用域之后，接下来就可以生成字节码了，字节码是介于AST和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行；</p><h5 id="8-3-2-2-1-V8是如何查找变量的"><a href="#8-3-2-2-1-V8是如何查找变量的" class="headerlink" title="8.3.2.2.1 V8是如何查找变量的"></a>8.3.2.2.1 V8是如何查找变量的</h5><blockquote><p>上文提到，在生成AST时，V8还需要生成相关的作用域，并在相关的作用域中存放相关变量。V8是如何查找变量的，答案是通过作用域链；</p><p>作用域就是存放变量和函数的地方，全局作用域中存放了全局环境中声明的变量和函数，函数作用域中存放了函数中声明的变量和函数，当在某个函数中使用某个变量时，V8就会去这些作用域中查找相关变量，沿着这些作用域查找的路径，就称为作用域链；</p></blockquote><p>全局作用域和函数作用域类似，也是存放变量和函数的地方，但是它们还是有点不一样： <strong>全局作用域是在V8启动过程中就创建了，且一直保存在内存中不会被销毁，直至V8推出，而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了</strong></p><p>要了解查找路径，需要明白词法作用域，词法作用域是按照代码定义时的位置决定的，而js所采用的作用域机制就是词法作用域，所以作用域链的路径就是按照词法作用域来实现的；</p><h5 id="8-3-2-2-2-V8是如何实现闭包的（延迟解析）"><a href="#8-3-2-2-2-V8是如何实现闭包的（延迟解析）" class="headerlink" title="8.3.2.2.2 V8是如何实现闭包的（延迟解析）"></a>8.3.2.2.2 V8是如何实现闭包的（延迟解析）</h5><blockquote><p>在编译js代码的过程中，V8不会一次性将所有js解析为中间代码，这主要基于以下几点；</p></blockquote><ul><li>首先，一次性解析和编译所有的js代码，过多的代码会增加编译事件，这会严重影响到首次执行js代码的速度，让用户感觉到科顿，因为有时候一个页面的js代码都有10多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</li><li>其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有js代码，那么这些中间代码和机器代码将会一直占用内存，特别是移动端普及的年代，内存是非常宝贵的资源；</li></ul><p>基于这些原因，所有主流js虚拟机都实现了惰性解析，所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成AST和字节码，而仅仅生成顶层代码的AST和字节码；</p><p><strong>惰性解析的过程</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> d+f+a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>当把这段代码交给V8处理时，V8会自上而下解析这段代码，在解析过程中首先会遇到foo函数，由于这只是一个函数声明语句，V8在这个阶段只需要将该函数转换为函数对象，如下图所示：</p><p><img src="bibao1.jpg" alt=""></p><p>注意，这里只是将该函数转换为函数对象，但是并没有解析和编译函数内部的代码，所以也不会为foo函数的内部代码生成抽象语法树；</p><p>接下来因为后续代码都是顶层代码，所以V8会为它们生成抽象语法树，最终生成的结果如下；</p><p><img src="tree1.jpg" alt=""></p><p>代码解析完成之后，V8便会按照顺序自上而下执行代码，首先会执行‘a=1’ ‘c=4’ 这两个赋值表达式；接下来执行foo函数的调用；过程是从foo函数对象中取出函数代码，然后和编译顶层代码一样，V8会先编译foo函数的代码，编译时同样需要先将其编译为抽象语法树和字节码，然后再解释执行；这便是惰性解析，也是就是除了顶层外，没真正执行的代码，先不解析。而是作为一个code属性先存入一个对象中去；</p><p>不过在V8实现惰性解析的过程中，需要支持js的闭包特性，这会使得V8的解析过程变得异常复杂；</p><p><strong>闭包——js三个特性</strong></p><p>第一，js语言允许在函数内部定义新的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  inner()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他大部分语言中，函数只能声明在顶层代码中，而js中之所以可以在函数中声明另外一个函数，主要是因为js中的函数即对象，可以在函数中声明一个变量，当然你也可以在函数中声明一个函数；</p><p>第二， 可以在内部函数中访问父函数中定义的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="number">20</span></span><br><span class="line"><span class="comment">// inner 函数的父函数，词法作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">55</span></span><br><span class="line">  <span class="comment">// foo的内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d+<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inner是foo函数的子函数，foo函数是inner函数的父函数。这里的父子关系是针对词法作用域而言的。因为词法作用域在函数声明时就决定了，比如inner函数是在foo函数内部声明的，所以inner函数可以访问foo函数内部的变量，比如inner就可以访问foo函数中的变量d</p><p>（词法作用域和词法作用域链，每个函数有自己的词法作用域，该函数中定义的变量都存在于该作用域中，然后V8会将这些作用域按照词法的位置，也就是代码位置关系，将这些作用域串成一个链，这就是词法作用域链，查找变量的时候会沿着词法作用域的途径来查找）</p><p>所以，inner函数在自己的作用域中没有查找到变量d，就接着在foo函数的作用域中查找，再查找不到才会查找顶层作用域中的变量，所以inner函数中使用的变量d就是foo函数中的变量d</p><p>第三，因为函数是一等公民，所以函数可以作为返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = a +b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo()</span><br></pre></td></tr></table></figure><p>我们将inner函数作为foo函数的返回值，也就是说，当调用foo函数时，最终会返回inner函数给调用者，比如上面我们将inner函数返回给了全局变量f，接下来就可以在外部像调用inner函数一样调用f了；</p><p>以上就是js闭包相关的三个重要特性：</p><ul><li>可以在js函数内部定义新的函数；</li><li>内部函数中访问父函数中定义的变量；</li><li>因为js中的函数是一等公民，所以函数可以作为另外一个函数的返回值；</li></ul><p><strong>闭包给惰性解析带来的问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">20</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = a+b+d</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo()</span><br></pre></td></tr></table></figure><p>上面这段代码的执行过程：</p><ul><li>当调用foo函数时，foo函数会将它的内部函数inner返回给全局变量f；</li><li>然后foo函数执行结束，执行上下文被V8销毁了；</li><li>虽然foo函数的执行上下文被销毁了，但是依然存活的inner函数引用了foo函数作用域中的变量d；</li></ul><p>按照通用的做法， d已经被V8销毁了，但是由于存活的函数inner依然引用了foo函数中的变量d，这样就会带来两个问题：</p><ul><li>当foo执行结束时，变量d该不该被销毁？ 如果不应该被销毁。那么应该采用什么策略？</li><li>如果采用了惰性解析，那么当执行到foo函数时，v8只解析foo函数，并不会解析内部的inner函数，那么这时候V8就不知道inner函数中是否引用了foo函数的变量d；</li></ul><p>那么怎么处理呢？</p><p>在执行foo函数的阶段，虽然采取了惰性解析，不会解析和执行foo函数中的inner函数，<strong>但是V8还是需要判断inner函数是否引用了foo函数中的变量</strong>，负责处理这个任务的模块叫做预解析器；</p><p>预解析器如何解决闭包所带来的问题？</p><p>V8引入预解析器，比如当解析顶层代码的时候，遇到一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个；</p><p>第一，是判断当前函数是不是存在一些语法上的错误，如下面这段代码；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>第二，除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题；</p><h5 id="8-3-2-3-解释器"><a href="#8-3-2-3-解释器" class="headerlink" title="8.3.2.3 解释器"></a>8.3.2.3 解释器</h5><p>生成字节码之后，解释器就登场了，它会按照顺序执行字节码，并输出执行结果；</p><ul><li>解释执行字节码</li><li>监听热点代码</li><li>优化热点代码为二进制的机器代码</li><li>反优化生成的二进制机器代码</li></ul><h3 id="8-4-V8异步编程"><a href="#8-4-V8异步编程" class="headerlink" title="8.4 V8异步编程"></a>8.4 V8异步编程</h3><h4 id="8-4-1-V8是怎么实现回调函数的"><a href="#8-4-1-V8是怎么实现回调函数的" class="headerlink" title="8.4.1 V8是怎么实现回调函数的"></a>8.4.1 V8是怎么实现回调函数的</h4><p>诸如setTimeout，XMLHTTPRequest来异步下载资源文件，在Node中可以使用readFile来读取文件，这些操作都有一个共同的特点，那就是需要给调用API传入回调函数，然后浏览器或者Node会将执行处理的结果通过回调函数来触发；</p><p>从内部了解回调函数，可以帮助我们梳理清楚很多问题</p><ul><li>有助于我们理解浏览器中的Web API到底是怎么工作的；</li><li>有助于我们理解宏任务和微任务到底有哪些区别；</li><li>理解回调函数，是理解异步编程模型async/await的基础；</li></ul><p><strong>只有当某个函数被作为参数，传递给另外一个函数，或者传递给宿主环境，然后该函数内部或者在宿主环境中被调用，才称为回调函数</strong></p><p><strong>回调函数有两种不同的形式，同步回调和异步回调。通常，我们需要将回调函数传入给另外一个执行函数，那么同步回调和异步回调的最大区别在于同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的</strong></p><p>同步回调无需多言，下面只说异步回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(foo, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>异步回调在什么时机和什么位置被调用呢？</p><p>要解释清楚这个问题，我们就需要了解V8在运行时的线程模型，因为这涉及到了消息队列，事件循环等概念，这些概念都和线程模型是直接相关的，所以接下来就先来分析下V8的线程架构模型；</p><p><strong>UI线程宏观架构</strong></p><p>早期浏览器的页面是运行在一个单独的UI线程中，所以要在页面中引入js，那么js也必须要运行在和页面相同的线程上，这样才能方便使用js来操纵DOM，所以从一开始，js就被设计成运行在UI线程中；</p><p>所谓UI线程，是指运行窗口的线程，当你运行一个窗口时，无论该页面是windows的窗口系统，还是android或者ios的窗口系统，它们都需要处理各种事件，诸如触发绘制页面的事件，有鼠标点击，拖拽，放大缩小的事件，有资源下载，文件读写的事件；</p><p>在页面线程中，当一个事件被触发时，比如用户使用鼠标点击了页面，系统需要将该事件提交给UI线程来处理；</p><p>在大部分情况下，UI线程并不能立即响应和处理这些事件，比如在你在移动鼠标的过程中，每移动一个像素都会产生一个事件，所以鼠标移动的事件会频繁地被触发，在这种情况下，页面线程可能正在处理前一个事件，那么最新的事件就无法被立即执行；</p><p>针对这种情况，我们为UI线程提供一个消息队列，并将这些待执行的事件添加到消息队列中，然后UI线程会不断循环地从消息队列中取出事件，执行时间，我们把UI线程每次从消息队列取出事件，执行事件的过程称为一个任务；</p><p><img src="v8_13.jpg" alt=""></p><p>这就是通用的UI线程的结构，有消息队列，通过鼠标，键盘，触控板等产生的消息都会被添加进消息队列，主线程会循环地从消息队列中取出消息并执行；</p><p><strong>异步回调函数的调用时机</strong></p><p>setTimeout(foo,3000)，在执行setTimeout函数的过程中，宿主就会将foo函数封装成一个事件，并添加到消息队列中，然后setTimeout函数执行结束；</p><p><em>通用UI线程是如何处理下载事件的</em></p><ol><li>UI线程会从消息队列中取出一个任务，并分析该任务；</li><li>分析过程中发现该任务是一个下载请求，那么主线程就会将该任务交给网络线程去执行；</li><li>网络线程接到请求之后，便会和服务端建立连接，并发出下载请求；</li><li>网络线程不断地收到服务器端传过来的数据；</li><li>网络线程每次接收到数据时，都会将设置的回调函数和返回的数据信息，如大小，返回了多少字节，返回的数据在内存中存放的位置等信息封装成一个新的事件，并将该事件放到消息队列中；</li><li>ui线程继续循环地读取消息队列中的事件，如果是下载状态的事件，那么UI线程会执行回调函数，程序员便可以在回调函数内部编写更新下载进度的状态的代码；</li><li>直到最后接收到下载结束事件，UI线程会显示该页面下载完成；</li></ol><h4 id="8-4-2-V8是如何实现微任务的"><a href="#8-4-2-V8是如何实现微任务的" class="headerlink" title="8.4.2 V8是如何实现微任务的"></a>8.4.2 V8是如何实现微任务的</h4><blockquote><p> 基于上文提到基础UI框架，js衍生出很多新技术，诸如宏任务和微任务</p></blockquote><p>宏任务： 指消息队列中的等待被主线程执行的事件；每个宏任务在执行时，V8都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务；</p><p>微任务： 微任务是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前；</p><p>之所以引入微任务，一来是因为主线程执行消息队列中宏任务的时间粒度太粗，无法胜任一些对精度和实时性要求较高的场景，那么微任务可以在实时性和效率之间做一个有效的权衡；</p><p>另外，使用微任务，可以改变现在的异步编程模型，使我们可以使用同步形式的代码来编写异步调用；</p><p><strong>微任务解决了宏任务执行时机不可控的问题</strong></p><p>虽然我们可以通过将某些函数封装成宏任务的方式来解决，但是宏任务需要先被放到消息队列中，如果某些宏任务的执行时间过久，那么就会影响到消息队列后面的宏任务的执行，而且这个影响不可控，因为你无法知道前面宏任务需要多久才能执行完毕；</p><p>V8会为每个宏任务维护一个微任务队列，当V8执行一段js时，会为这段代码创建一个环境对象，微任务队列就是存放在该环境对象中的。当你通过Promise.resolve生成一个微任务，该微任务会被V8自动添加进微任务队列，等整段代码快要执行结束时，该环境对象也随之被销毁，但是在销毁之前，V8会先处理微任务队列中的微任务；</p><p><strong>能否在微任务中循环地触发新的微任务</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(foo)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>答案必然是不能，因为函数在退出宏任务之前会检查微任务队列，如果循环创建微任务，那么导致当前宏任务永远无法被退出。那造成的结果就是后续的宏任务永远得不到执行；</p><h3 id="8-5-V8内存管理"><a href="#8-5-V8内存管理" class="headerlink" title="8.5  V8内存管理"></a>8.5  V8内存管理</h3><h4 id="8-5-1-内存模型"><a href="#8-5-1-内存模型" class="headerlink" title="8.5.1 内存模型"></a>8.5.1 内存模型</h4><p><strong>js原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的</strong></p><p>js是gc语言；开发者无需手动清理堆内存</p><p>所以<strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p><p>在 JavaScript 中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。</p><h4 id="8-5-2-垃圾回收算法"><a href="#8-5-2-垃圾回收算法" class="headerlink" title="8.5.2 垃圾回收算法"></a>8.5.2 垃圾回收算法</h4><p>第一步，通过GC Root标记空间中活动对象和非活动对象</p><p>GC Root有很多，通常包括</p><ul><li>window对象</li><li>DOM树</li><li>存放在栈上变量</li></ul><p>第二步，回收非活动对象所占据的内存，其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象</p><p>第三步，内存整理，清理之后的内存必然存在大量不连续的空间，这些不连续的内存空间称为内存碎片。出现大量内存碎片，会导致无法分配较大的连续内存，就可能出现内存不足的情况。所以最后一步需要整理这些内存碎片。但其实这步是可选的，因为有的垃圾回收器不会产生内存碎片；比如副垃圾回收（Minor GC（Scavenger））</p><h4 id="8-5-3-垃圾回收"><a href="#8-5-3-垃圾回收" class="headerlink" title="8.5.3 垃圾回收"></a>8.5.3 垃圾回收</h4><p>首先像一些没有垃圾回收机制的语言，比如C/C++。 是需要调用free函数来清楚堆内存的。</p><p>js内置的垃圾回收工具，并不需要手动去释放；</p><h5 id="8-5-2-1-栈中代码如何回收"><a href="#8-5-2-1-栈中代码如何回收" class="headerlink" title="8.5.2.1 栈中代码如何回收"></a>8.5.2.1 栈中代码如何回收</h5><p><strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p><h5 id="8-5-2-2-堆中代码如何回收"><a href="#8-5-2-2-堆中代码如何回收" class="headerlink" title="8.5.2.2 堆中代码如何回收"></a>8.5.2.2 堆中代码如何回收</h5><p>ESP能解决栈内存，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p><p><img src="stack1.png" alt=""></p><p>从图中可以看出，1003 和 1050 这两块内存依然被占用。<strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p><p>目前V8采用了两个垃圾回收器，</p><p><strong>主垃圾回收和副垃圾回收，之所以使用两个垃圾回收，主要是受到代际假说的影响</strong></p><p><strong>代际假说</strong>有以下两个特点：</p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。</li><li>第二个是不死的对象，会活得更久。</li></ul><p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p><p>V8 的垃圾回收策略，就是建立在代际假说的基础之上的。</p><p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p><p>所以，在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p><p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li><strong>副垃圾回收器  Minor GC（Scavenger ），主要负责新生代的垃圾回收。</strong></li><li><strong>主垃圾回收器 Major GC，主要负责老生代的垃圾回收。</strong></li></ul><h5 id="8-5-2-2-1-副垃圾回收器"><a href="#8-5-2-2-1-副垃圾回收器" class="headerlink" title="8.5.2.2.1 副垃圾回收器"></a>8.5.2.2.1 副垃圾回收器</h5><p>副垃圾回收器主要负责新生代垃圾回收，通常情况，大多数小的对象都被分配到新生代，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的；</p><p>新生代垃圾数据用Scavenge算法来处理，所谓Scavenge算法，是把新声代空间对半划分为两个区域，一半是对象区域（from-space），一半是空闲区域（to- space）</p><p><img src="v8_24.jpg" alt=""></p><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作；</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p><p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p><h5 id="8-5-2-2-2-主垃圾回收器"><a href="#8-5-2-2-2-主垃圾回收器" class="headerlink" title="8.5.2.2.2 主垃圾回收器"></a>8.5.2.2.2 主垃圾回收器</h5><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，</p><ul><li>一个是对象占用空间大</li><li>另一个是对象存活时间长</li></ul><p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p><p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p><p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p><p><img src="stack3.png" alt=""></p><p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p><p><img src="stack4.png" alt=""></p><p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p><p><img src="stack5.png" alt=""></p><p><strong>下面这段代码如何优化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strToArray</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> len = str.length</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(str.length)</span><br><span class="line">  <span class="keyword">for</span>(;i&lt;len;++i)&#123;</span><br><span class="line">    arr[i] = str.charCodeAt(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i =<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">"test v8 gc"</span></span><br><span class="line">  <span class="keyword">while</span>(i++ &lt; <span class="number">1e5</span>) &#123;</span><br><span class="line">    strToArray(str)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-5-2-2-3-全停顿"><a href="#8-5-2-2-3-全停顿" class="headerlink" title="8.5.2.2.3 全停顿"></a>8.5.2.2.3 全停顿</h5><p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p><p><img src="stack6.png" alt=""></p><p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p><h4 id="8-5-2-4-GC优化"><a href="#8-5-2-4-GC优化" class="headerlink" title="8.5.2.4 GC优化"></a>8.5.2.4 GC优化</h4><p>为了降低老生代的垃圾回收而造成的卡顿，V8团队向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术，这些技术主要是从两方面来解决垃圾回收效率问题的</p><p>第一， 将一个完整的垃圾回收的任务拆分成多个小的任务，这样就消灭了单个长的垃圾回收任务</p><p>第二。将标记对象，移动对象等任务转移到后台线程进行，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅；</p><h5 id="8-5-2-5-1-并行回收"><a href="#8-5-2-5-1-并行回收" class="headerlink" title="8.5.2.5.1 并行回收"></a>8.5.2.5.1 并行回收</h5><p>GC时候，引入多个辅助线程来并行处理，采用并行回收时，垃圾回收所消耗的时间，等于总体辅助线程所消耗的时间。这种方式较简单，因为在执行垃圾标记的过程中，主线程并不会同时执行js代码，因此js代码也不会改变回收的过程，所以我们可以假定内存状态是静止的，因此只要确保同时只有一个协助线程在访问对象就好了；</p><p>V8副垃圾回收器就是用的并行策略，在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针；</p><p>值得一提的事，并行策略仍然是一种全停顿的垃圾回收方式；</p><h5 id="8-5-2-5-2-增量回收"><a href="#8-5-2-5-2-增量回收" class="headerlink" title="8.5.2.5.2 增量回收"></a>8.5.2.5.2 增量回收</h5><p>V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p><p><img src="stack7.png" alt=""></p><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p><p>增量标记的算法，比全停顿要稍微复杂，这主要是因为增量回收是并发的，要实现增量执行，需要满足两点要求：</p><ol><li>垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后，才能继续启动</li><li>在暂停期间，被标记好了垃圾数据如果被js代码修改了，那么垃圾回收器需要能够正确处理</li></ol><p><strong>v8是如何实现垃圾回收器的暂停和恢复执行的</strong></p><p>在没有采用增量算法之前，V8使用黑色和白色来标记数据，在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记，然后垃圾回收器在会从GC root出发，将所有能访问到的数据标记为黑色。遍历结束之后，被标记为黑色的数据就是活动数据，那些白色数据就是垃圾数据；</p><p><img src="v8_25.jpg" alt=""></p><p>如果内存中的数据只有两种状态，非黑即白，那么当你暂停了当前的垃圾回收器之后，再次恢复垃圾回收器，那么垃圾回收器就不知道从哪个位置继续开始执行了；</p><p><img src="v8_26.jpg" alt=""></p><p>比如垃圾回收执行了一小段增量回收后，被V8暂停了，然后主线程执行了一段js代码，然后垃圾回收器又被回复了，那么回复时内存状态就如上图所示了。</p><p>那么当垃圾回收器再次被启动的时候，它到底是从A节点开始标记，还是从B节点开始执行标注过程呢？ 因为没有其他额外的信息，所以垃圾回收器也不知道该如何处理了；</p><p>为了解决这个问题，V8采用了三色标记法，除了黑色和白色，还额外引入了灰色；</p><ol><li>黑色表示这个节点被GC Root引用到了，而且该节点的字节点都已经标记完成了</li><li>灰色表示这个节点被GC Root引用到，但字节点还没有被垃圾回收器标记处理，也表明目前正在处理这个节点；</li><li>白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回；</li></ol><p>引入灰色标记之后，垃圾回收器就可以依据当前内存中有没有灰色节点，来判断整个标记是否完成，如果没有灰色节点了，就可以进行清理工作了，如果还有灰色标记，当下次回复垃圾回收器时，便从灰色的节点开始继续执行；</p><p>因此采用三色标记，可以很好地支持增量式垃圾回收</p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="built_in">Object</span>()</span><br><span class="line"><span class="built_in">window</span>.a.b = <span class="built_in">Object</span>()</span><br><span class="line"><span class="built_in">window</span>.a.b.c = <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><p><img src="v8_27.jpg" alt=""></p><p>然后又执行了另外一个代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a.b = <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><p><img src="v8_28.jpg" alt=""></p><p>由于b重新指向了d对象，所以b和c对象的连接就断开了。这时候的代码应该如上图所示</p><p>就说明一个问题，当垃圾回收器将某个节点标记成了黑色，然后这个黑色的节点被续上了一个白色节点，那么垃圾回收器就不会再次将这个白色节点标记为黑色节点，因为它已经走过这个路径了；</p><p>但是这个新的白色节点的确被引用了，所以还是需要想办法将其标记为黑色；</p><p>为了解决这个问题，增量垃圾回收器添加了一个约束条件，<strong>不能让黑色节点指向白色节点</strong></p><p>通常使用 写屏障机制 实现这个约束条件，也就是说，当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的，这样就保证了黑色节点不能指向白色节点的约束条件。这个方法也被称为强三色不变性，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时的所有白色对象，对于垃圾回收器来说，都是不可到达的，可以安全释放； </p><p>所以在V8中，每次执行window.a.b = value的写操作之后，V8会插入写屏障代码，强制将value这块内存标记为灰色；</p><h5 id="8-5-2-5-3-并发回收"><a href="#8-5-2-5-3-并发回收" class="headerlink" title="8.5.2.5.3 并发回收"></a>8.5.2.5.3 并发回收</h5><p>虽然通过三色标记法和写屏障机制很好实现增量垃圾回收，但是由于这些操作都是在主线程上执行，如果主线程繁忙的时候，增量垃圾回收操作依然会增加降低主线程处理任务的吞吐量</p><p>并发回收机制，可以在不阻塞主线程的情况下，执行垃圾回收操作；</p><p>所谓并发回收，是指主线程在执行js的过程中，辅助线程能够在后台完成执行垃圾回收的操作</p><p><img src="v8_29.jpg" alt=""></p><p>但是并发回收却是这三种技术中最难的一种，这主要由以下两个原因导致的：</p><ol><li>当主线程执行js时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全无效；</li><li>主线程和辅助线程极有可能在同一时间去更改同一对象，这就需要额外实现读写锁的一些功能了；</li></ol><p>V8的主垃圾回收器就融合了这三种机制，来实现垃圾回收。</p><p><img src="v8_30.jpg" alt=""></p><p>可以看出来，主垃圾回收器同时采用了这三种策略：</p><ul><li>首先主垃圾回收器主要使用并发标记，在主线程执行js，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的；</li><li>标记完成之后，再执行并行清理操作，主线程在执行清理操作时，多个辅助线程也在执行清理操作；</li><li>另外，主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种js任务之间执行；</li></ul><h4 id="8-5-2-5-如何判断内存泄漏"><a href="#8-5-2-5-如何判断内存泄漏" class="headerlink" title="8.5.2.5  如何判断内存泄漏"></a>8.5.2.5  如何判断内存泄漏</h4><p>使用chrome的performace面板，观察内存变化，如果多次垃圾回收后，整体趋势是向上，就存在内部泄漏的可能！</p><p><strong>闭包形成的对象刚开始是属于新声代还是老生代</strong></p><p>看对象大小，小对象一开始就会跌倒新生代中去，当GC执行多次后，会被移动到老生代中；</p><h3 id="8-6-V8内存优化"><a href="#8-6-V8内存优化" class="headerlink" title="8.6 V8内存优化"></a>8.6 V8内存优化</h3><blockquote><p>V8为了提升js的执行速度，借鉴了很多静态语言的特性，比如实现了JIT机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存</p></blockquote><h4 id="8-6-0-快慢属性"><a href="#8-6-0-快慢属性" class="headerlink" title="8.6.0 快慢属性"></a>8.6.0 快慢属性</h4><p>js在运行时，对象的属性是可以被修改的，所以当V8使用了一个对象时，比如使用了start.x的时候，它并不知道该对象中是否有x，也不知道x相对于对象的偏移量是多少，也可以说V8并不知道该对象的具体形状；</p><p>那么，当在js中要查询对象start中的x属性时，V8会按照具体的规则一步一步来查询，这个过程是非常慢且耗时；</p><p>那么，<strong>V8采用了哪些策略提升了对象属性的访问速度？</strong></p><p>从js语言的角度来看，js对象像一个字典，字符串作为键名，任意对象可以做为键值，可以通过键名读写键值；</p><p>然而在V8存储的时候，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线形表，查询效率会低于线形的数据结构；V8为了提升存储和查找效率，采用了一套复杂的存储策略；</p><p><strong>常规属性和排序属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'test-100'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">1</span>] = <span class="string">'test-1'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="string">"B"</span>] = <span class="string">'bar-B'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">50</span>] = <span class="string">'test-50'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">9</span>] = <span class="string">'test-9'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">8</span>] = <span class="string">'test-8'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">3</span>] = <span class="string">'test-3'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">5</span>] = <span class="string">'test-5'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="string">"A"</span>] = <span class="string">'bar-A'</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="string">"C"</span>] = <span class="string">'bar-C'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> bar) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`index: <span class="subst">$&#123;key&#125;</span> value: <span class="subst">$&#123;bar[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">index: 1 value: <span class="built_in">test</span>-1</span><br><span class="line">index: 3 value: <span class="built_in">test</span>-3</span><br><span class="line">index: 5 value: <span class="built_in">test</span>-5</span><br><span class="line">index: 8 value: <span class="built_in">test</span>-8</span><br><span class="line">index: 9 value: <span class="built_in">test</span>-9</span><br><span class="line">index: 50 value: <span class="built_in">test</span>-50</span><br><span class="line">index: 100 value: <span class="built_in">test</span>-100</span><br><span class="line">index: B value: bar-B</span><br><span class="line">index: A value: bar-A</span><br><span class="line">index: C value: bar-C</span><br></pre></td></tr></table></figure><p>阿拉伯数字的key 居然排序了，非阿拉伯数据的key按照定义的顺序在输出；</p><p>是因为<strong>ECMAscript规范中定义数字属性应该按照索引值大小生序排列，字符串属性根据创建时候的顺序生序排列</strong></p><ul><li>数字属性-&gt; 排序属性（element）</li><li>字符串属性 -&gt; 常规属性 （properties）</li></ul><p><img src="v8_16.jpg" alt=""></p><p>如上图所示，bar对象包含两个隐藏属性： element属性和properties属性，elements属性指向了elements对象，在elements对象中，会按照顺序存放排序属性，properties属性则指向了properties对象，在properties对象，会按照创建时候的顺序保存常规属性；值得注意的是，存储排序属性和常规的属性的容器是两个线形数据结构；</p><p><strong>快属性和慢属性</strong></p><p>将不同属性分别保存在elements和properties，简化了程序的复杂度，但是查找元素时，多了一步操作。比如执行bar.B茶渣B的属性值，那么在V8会先查找出properties属性所指向的对象properties，然后再在properties对象中查找B属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率；</p><p>基于此，V8采取一个权衡的策略，这个策略是将部分常规属性存储到对象本身，称为“对象内属性（in -object properties）”</p><p><img src="v8_17.jpg" alt=""></p><p>如上图所示，对象内属性解决了查找的问题，但是对象内属性的个数上限被限定在了10.如果超过10就被存储到properties了；虽然属性存储多了一层，但可以自由扩容；</p><p>保存在线形结构的属性，称为“快属性”。因为线形结构中只需要通过索引即可以访问到属性，缺点就是从线形结构添加删除大量属性，执行效率会非常低，这主要因为会产生大量时间和内存开销；</p><p>如果一个对象的属性过多的时候，V8会采取“慢属性”策略，慢属性的对象内部会有独立的非线性数据结构（词典）作为属性存储容器，所有的属性元信息不再是线形存储的，而是直接保存在属性字典中；</p><p><img src="v8_18.jpg" alt=""></p><ul><li>示例： chrome中查看对象布局</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">prop_num, ele_num </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt; ele_num; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>[i] = <span class="string">`elements<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt; prop_num; i++)&#123;</span><br><span class="line"><span class="keyword">let</span> ppt = <span class="string">`property<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line"><span class="keyword">this</span>[ppt] = ppt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="v8_19.png" alt="image-20210507113921394"></p><p>后面我们依次加多属性个数,来观察对象的分布</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="number">20</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="number">100</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>观察上图，除了elements和properties属性之外，V8还为每个对象实现了map属性和<code>__proto__</code>属性。 map属性就是隐藏类</p><ul><li>总结</li></ul><p>从这个快慢属性的机制来看，尽可能避免出现很大的对象；最好约束在“对象内属性”，这样在查找的时候能节约一个中间步骤。也就是尽量只有10个之内；如果大于10个，使得对象不得不启用线形表存储额外属性的时候，尽量不要动态delete和add属性，防止线形表内存反复的数据搬移；如果对象中的属性过多时，或者存在反复添加或者删除的操作，那么V8就会将线形的存储模式降级为非线形的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度；</p><p>尽可能一次性缓存对象指针，而不是在代码中频繁出现对象索引代码，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> d = a.b.c + x.y.z;</span><br><span class="line"><span class="keyword">const</span> e = a.b.c * x.y.z;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> c = a.b.c</span><br><span class="line"><span class="keyword">const</span> z = x.y.z</span><br><span class="line"><span class="keyword">const</span> d = c+z</span><br><span class="line"><span class="keyword">const</span> e = c*z</span><br></pre></td></tr></table></figure><h4 id="8-6-1-隐藏类"><a href="#8-6-1-隐藏类" class="headerlink" title="8.6.1 隐藏类"></a>8.6.1 隐藏类</h4><p><strong>为什么静态语言效率更高</strong></p><p><img src="v8_14.jpg" alt=""></p><p>首先，静态语言比如C++，在声明一个对象的时候需要定义该对象的结构，比如Point类就是一种结构；C++在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中，Point的形状是无法被改变的；</p><p>那么在C++访问一个对象的属性时，自然就知道该属性相对于该对象地址的偏移值了；比如使用start.x时，编译器直接将X相对start的地址写进汇编指令中，那么当使用对象start中的x属性时，CPU就可以直接去内存地址中找了，没有任何中间商赚差价</p><p>这便是静态语言效率高的原因</p><p>但是动态语言js没法这么做，js在声明一个对象的时候，可以在后续代码中手动增加删除属性。完全free灵动；</p><p>既然静态语言效率这么高，那么能够将这种特性引入到V8中去呢？</p><p>答案就是 <strong>隐藏类</strong></p><p>目前所采用的一个思路就是将js中的对象静态化，也就是V8在运行js的过程中，会假设js中的对象是静态的，V8对每个对象做如下两点假设；</p><ol><li>对象创建好了就不会添加新的属性</li><li>对象创建好了之后也不会删除属性</li></ol><p>然后V8就可以对js中的对象做深度优化了，</p><p>具体讲，V8会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点</p><ol><li>对象所包含的所有属性</li><li>每种类型相对于对象的偏移量</li></ol><p>有了隐藏类之后，那么当V8访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么久大大提升了V8查找对象的效率；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;<span class="attr">x</span>:<span class="number">100</span>, <span class="attr">y</span>:<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure><p>当V8执行这句代码时，会纤维point对象创建一个隐藏类，即上面提到的map属性，每个对象都有一个map属性，值都指向内存中的隐藏类</p><p>隐藏类描述了对象的属性布局，它主要包括了属性名称和每个属性所对应的偏移量，比如point对象的隐藏类久包括了x和y属性，x的偏移量是4，y的偏移量是8；</p><p><img src="v8_20.jpg" alt=""></p><p>有了map之后，当你再次使用point.x访问x属性时，v8会查询point的map中x属性相对point对象的偏移量，然后将point对象的起始位置加上偏移量，就得到了x属性的值在内存中的位置，有了这个位置也就拿到了x的值，这样就省去一个比较复杂的查找过程；</p><h5 id="8-6-1-1-多个对象共用一个隐藏类"><a href="#8-6-1-1-多个对象共用一个隐藏类" class="headerlink" title="8.6.1.1 多个对象共用一个隐藏类"></a>8.6.1.1 多个对象共用一个隐藏类</h5><p>如果两个对象的形状是相同的，v8就会为其复用同一个隐藏类。好处是</p><ol><li>减少隐藏类的创建次数，也间接加速了代码的执行速度</li><li>减少了隐藏类的存储空间</li></ol><p>那么，什么情况下两个对象的形状是相同的</p><ul><li>相同的属性名称</li><li>相等的属性个数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>:<span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> point2 = &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="v8_21.jpg" alt=""></p><h5 id="8-6-1-2-重新构建隐藏类"><a href="#8-6-1-2-重新构建隐藏类" class="headerlink" title="8.6.1.2 重新构建隐藏类"></a>8.6.1.2 重新构建隐藏类</h5><p>js是动态语言，意味着对象是可以被改变的；如果某个对象形状变了，那么隐藏类也会跟着改变。意味着V8要为新改变的对象重新构建新的隐藏类，这对于V8的执行效率来说，是一笔大的开销；</p><h5 id="8-6-1-3-最佳实践"><a href="#8-6-1-3-最佳实践" class="headerlink" title="8.6.1.3 最佳实践"></a>8.6.1.3 最佳实践</h5><p>V8为每个对象分配隐藏类的执行过程</p><ol><li>如果对象的形状没有发生改变，那么该对象就会一直使用该隐藏类</li><li>如果对象的形状发生了改变，那么V8会重建一个新的隐藏类给该对象</li></ol><p>触发V8重构该对象的隐藏类，会直接影响到程序的执行性能</p><p>尽量注意以下几点：</p><ul><li>使用字面量初始化对象时，要保证属性的顺序是一致的；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 &#x3D; &#123;a: 1,b:1&#125;;</span><br><span class="line">x2 &#x3D; &#123;b:1,a:1&#125;;</span><br></pre></td></tr></table></figure><p>虽然x1，x2属性一致，但是初始化顺序不一样，也会导致形状不同，所以尽量避免这种情况为好；</p><ul><li>尽量使用字面量一次性初始化完整对象属性；（每增加一个属性，V8都会为该对象重新设置隐藏类）</li><li>尽量避免使用delete方法；（delete破坏对象形状，同样触发V8重构该隐藏类）</li></ul><h4 id="8-6-2-内联缓存"><a href="#8-6-2-内联缓存" class="headerlink" title="8.6.2 内联缓存"></a>8.6.2 内联缓存</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o.x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">90000</span>; i++)&#123;</span><br><span class="line">  loadX(o)</span><br><span class="line">  loadX(o1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当V8调用loadX时，会先查找参数O的隐藏类，然后利用隐藏类中的x属性的偏移量查找到x的属性值，虽然利用隐藏类能够快速提升对象属性的查找速度，但是依然有一个查找隐藏类和查找隐藏类中的偏移量两个操作，如果loadX在代码中会被重复执行，依然影响到了属性的查找效率；</p><p>V8是采取什么措施来提供loadX函数的执行效率的？</p><p>答案就是内联缓存，简称IC；</p><p>什么是内联缓存？</p><p>IC原理，直观理解就是， 在V8执行函数的过程中，会观察函数中一些调用点（CallSite）上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此V8利用IC，可以有效提升一些重复代码的执行效率；</p><p>IC会为每个函数维护一个反馈向量，反馈向量记录了函数在执行过程中的一些关键的中间数据，关于函数和反馈向量的关系</p><p><img src="v8_22.jpg" alt=""></p><p>反馈向量其实就是一个表结构，由很多项组成，每一项为一个插槽（Slot），V8依次将执行loadX函数的中间数据写入到反馈向量的插槽中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">o.y = <span class="number">4</span></span><br><span class="line"><span class="keyword">return</span> o.x</span><br><span class="line">&#125;</span><br><span class="line">loadX(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>当V8执行上面语句时它会判断o.y = 4 和return o.x 这两段是调用点（CallSite），因为它们使用了对象和属性，那么V8会在loadX函数的反馈向量中为每个调用点分配一个插槽；。。。</p><p>等到反馈向量缓存了数据之后，</p><p>当V8再次调用loadX函数时，比如执行到loadX函数中的return o.x语句时，它就会在对应的插槽中查找x属性的偏移量，之后V8就能直接去内存中获取o.x的属性值了。这样就大大提升了V8的执行效率；</p><h5 id="8-6-2-1-多态和超态"><a href="#8-6-2-1-多态和超态" class="headerlink" title="8.6.2.1 多态和超态"></a>8.6.2.1 多态和超态</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o.x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">6</span>,<span class="attr">z</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">90000</span>; i++) &#123;</span><br><span class="line">  loadX(o)</span><br><span class="line">  loadX(o1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，o和o1形状不同，意味着V8为它们创建的隐藏类也是不同的；</p><p>第一次调用loadX。V8将o的隐藏类记录在反馈向量中，并记录属性x的偏移量，那么当再次调用loadX函数时，V8会取出反馈向量中记录的隐藏类，并和新的O1的隐藏类进行比较，发现不是一个隐藏类，那么此时V8就无法使用反馈向量中记录的偏移量信息了；</p><p>面对这种情况，V8会选择将新的隐藏类也记录在反馈向量中，同时记录属性值的偏移量，这时，反馈向量中的第一个槽就包含了两个隐藏类和偏移量，</p><p>现在我们知道了，一个反馈向量的一个插槽中可以包含多个隐藏的信息；那么</p><ul><li>如果一个插槽中只包含1个隐藏类，那么我们称这种状态为单态</li><li>如果一个插槽中包含了2-4个隐藏类，那我们称呼这种状体为多态</li><li>如果一个插槽中超过4个隐藏类，我们称这种状态为超态</li></ul><p><strong>尽量保持单态吧，单态的性能优于多态和超态</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如定一个loadX(o)的签名，那么当传递参数时，尽量不要使用多个不同形状的o对象；</span><br></pre></td></tr></table></figure><h4 id="8-6-3-总结"><a href="#8-6-3-总结" class="headerlink" title="8.6.3 总结"></a>8.6.3 总结</h4><p>​        虽然用了大量篇幅介绍隐藏类和内联缓存，但是说实在的，并不需要过度担忧代码是否破坏了隐藏类或者IC的机制，一个TS解决大多数问题；对于优化而言，隐藏类和IC机制对效率的影响可能是微不足道的；</p><h3 id="8-7-V8的类型系统"><a href="#8-7-V8的类型系统" class="headerlink" title="8.7 V8的类型系统"></a>8.7 V8的类型系统</h3><h4 id="8-7-1-什么是类型"><a href="#8-7-1-什么是类型" class="headerlink" title="8.7.1 什么是类型"></a>8.7.1 什么是类型</h4><p>对机器语言来说，所有的数据都是一堆二进制代码，CPU处理这些数据的时候，并没有类型的概念，CPU能做的仅仅是移动数据，比如对其进行移位，相加或者相乘；</p><p>而在高级语言中，我们都会为操作的数据赋予指定的类型，类型可以确认一个值或者一组值具有特定的意义和目的，所以，类型是高级语言中概念；</p><p>js在定义变量的时候，并需要像C++那样去指定类型，因为V8会根据数据自动推导类型；</p><p>每种语言都定义了自己的类型，还定义了如何操作这些类型，另外还定义了这些类型应该如何相互作用，我们就把这称为“<strong>类型系统</strong>”</p><p>这个定义类型应该如何相互作用，更像是一种协议，比如两种不同类型相加应该如何处理，相同类型相加又应该如何处理等等；同时还规定了各种不同类型应该如何相互转换，比如string -&gt; number</p><p>一个语言的类型系统越强大，那编译器能帮程序员检查的东西就越多，程序员定义“检查规则”的方式就越灵活；</p><h4 id="8-7-2-V8如何执行加法操作"><a href="#8-7-2-V8如何执行加法操作" class="headerlink" title="8.7.2 V8如何执行加法操作"></a>8.7.2 V8如何执行加法操作</h4><blockquote><p>V8基本照搬并实现了ECMAscript规范</p></blockquote><ul><li>AdditiveExpression : AdditiveExpression + MultiplicativeExpression</li></ul><ol><li>把第一个表达式（AdditiveExpression）的值复制给左引用（lref）</li><li>使用GetValue(lref)获取左引用（lref）的计算结果，并赋值给lval</li><li>使用ReturnlfAbrupt(lval)如果报错就返回错误</li><li>把第二个表达式（MultiplicativeExpression）的值赋值给右引用（rref）</li><li>使用GetValue(rref)获取右引用（rref）的计算结果，并赋值给rval</li><li>使用ReturnlfAbrupt(rval)如果报错就返回错误</li><li>使用ToPrimitive(lval)获取左值（lval）的计算结果，并将其赋值给左原生值（lprim）</li><li>使用ToPrimitive(rval)获取右值（rval）的计算结果，并将其赋值给右原生值（rprim）</li><li>如果Type(lprim)和Type(rprim)中有一个是String，则：<ol><li>把ToString(lprim)的结果赋给左字符串(lstr)</li><li>把ToString(rprim)的结果赋值给右字符串(rstr)</li><li>返回左字符串(lstr)和右字符串(rstr)拼接的字符串</li></ol></li><li>把ToNumber(lprim)的结果赋给左数字（lnum）</li><li>把ToNumber(rprim)的结果赋值给右数字（rnum）</li><li>返回左数字（lnum）和右数字（rnum）相加的数值；</li></ol><p>通俗的讲，V8会提供一个ToPrimitive 方法，将a和b转换为原生数据类型，其转换流程如下</p><ul><li>先检测该对象中是否存在valueOf方法，如果有并返回了原理类型，那么就使用该值进行强制类型转换；</li><li>如果valueOf没有返回原始类型，那么就使用toString方法的返回值；</li><li>如果valueOf和toString两个方法都不返回基本类型值，便会触发一个TypeError的错误；</li></ul><p><img src="v8_23.jpg" alt=""></p><p>当V8执行1+’2’时，因为这是两个原始值相加，原始值相加的时候，如果其中一项是字符串，那么V8会默认将两外一个值也转换为字符串；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="number">1</span>).toString() + <span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>这里，把数字1偷偷转换为字符串“1”的过程也称为强制类型转换，因为这种转换是隐式的；</p><h4 id="8-7-3-demo：验证流程"><a href="#8-7-3-demo：验证流程" class="headerlink" title="8.7.3 demo：验证流程"></a>8.7.3 demo：验证流程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'200'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj+<span class="number">3</span></span><br></pre></td></tr></table></figure><p>先使用ToPrimitve方法将Obj转换为原生类型，而ToPrimitve会优调用对象中的valueOf方法，由于valueOf返回了100，那么Obj就会被转换为数字100，那么数字100加数字3，就是103了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj+<span class="number">3</span></span><br><span class="line"><span class="comment">// cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure><p>错误的原因是无法将对象类型转换为原生类型</p><p>因为ToPrimitve会先调用valueOf方法，发现返回的是一个对象，并不是原生类型，当ToPrimitive继续调用toString方法时，发现toString返回的也是一个对象，都是对象，就无法执行相加运算了。</p><p>所以说，在执行加法操作时。<strong>V8会通过ToPrimitve方法将对象类型转换为原生类型，最后就是两个原生类型相加，如果其中一个值的类型是字符串时，则另一个值也需要强制转换为字符串，然后做字符串的连接运算，在其他情况时，所有的值都会转换为数字类型值，然后做数字的相加；</strong></p><h2 id="结语：-如何创建属于自己的技术栈"><a href="#结语：-如何创建属于自己的技术栈" class="headerlink" title="结语： 如何创建属于自己的技术栈"></a>结语： 如何创建属于自己的技术栈</h2><p>如果进入的是一个成熟的领域，那么一般都有比较完整的技术栈的资料，我们需要花些时间分析资料，系统性地了解这一领域知识的宏观架构、它的过往历史、它的优缺点，然后结合现在资料和我们自身的特点来建立我们自己的技术栈。如果你所在的领域还在高速发展中，并没有人总结出完成的技术栈，那么为了更好地理解技术的发展脉络，我们需要花更多一些的时间去整理出该领域的技术栈；</p><p>当你要开发一个新项目或者学习一门手艺之前，应该将其所涉及到的知识做一个全方位的了解，“技术栈”非常形象地表达了学习一门手艺所需要的是哪些知识，以及应该按照什么顺序来学。</p><p>比如学习前端这门手艺，栈底到栈顶依次是浏览器架构、web网络、事件循环机制、js core、V8内存管理，浏览器渲染流程、web安全、css、react/vue、node、构建工具链等；</p><p>学习技术栈的每一层都不难，难的是当你抛开底层栈的内容去理解上层栈的内容，那么就有可能陷入知识点的盲区；</p><p>我们在学习一门手艺的时候，即便没有完善的技术栈资料，只要肯花费更多的时间，也可以克服困难，甚至我们的学习过程可以像一个无头苍蝇，横冲直撞，某一个也会突然顿悟整个知识体系，俗话说，在一个领域耕耘十年，必定能成为该领域的专家；</p><p>但是，如果三年能搞定为何要花上10年呢；</p><p>系统性学习一门技术，花费的时间也是最短的，也可以说是最性价比的，因为系统性、循序渐进地学习，那么学习到每个知识点时，其实并没有其他的知识盲区。这样学习起来是最轻松、简单的；</p>]]></content>
      
      
      <categories>
          
          <category> browser </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go_dev</title>
      <link href="2021/04/21/go-dev/"/>
      <url>2021/04/21/go-dev/</url>
      
        <content type="html"><![CDATA[<h1 id="golang开发环境搭建"><a href="#golang开发环境搭建" class="headerlink" title="golang开发环境搭建"></a>golang开发环境搭建</h1><blockquote><p>环境搭建是开发的一部分，砍柴之前磨磨刀还是很必要的。所以，学习之前我打算在linux上搭建一套golang的开发环境；这里以某厂商的云虚拟机为例，操作系统应该是centos7</p></blockquote><h2 id="1-安装golang"><a href="#1-安装golang" class="headerlink" title="1. 安装golang"></a>1. 安装golang</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&gt; wget  https://studygolang.com/dl/golang/go1.16.3.linux-amd64.tar.gz -P  /data/ <span class="comment"># 下载并存放到跟目录的 data文件夹中</span></span><br><span class="line">$&gt; tar xzvf /data/go1.16.3.linux-amd64.tar.gz  -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="comment"># -x --extract = extract files from an archive</span></span><br><span class="line"><span class="comment"># -v, --verbose = verbosely list files processed</span></span><br><span class="line"><span class="comment"># -z, --gzip = gzipped files eg. for tar.gz packages</span></span><br><span class="line"><span class="comment"># -f, --file ARCHIVE = use archive file or device ARCHIVE</span></span><br><span class="line"><span class="comment"># -C /usr/local，tar将在执行任何操作之前将其当前目录更改为dir, 也就是将当前文件解压到 /usr/local；</span></span><br></pre></td></tr></table></figure><p><strong>配环境变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; vim ~/.profile</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPATH=/opt/go</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOROOT</span>/bin/</span><br><span class="line"><span class="built_in">export</span> GOTOOLS=<span class="variable">$GOROOT</span>/pkg/tool/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOBIN</span>:<span class="variable">$GOTOOLS</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy,direct</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/go</span><br><span class="line">$&gt; <span class="built_in">source</span> ~/.profile</span><br><span class="line">$&gt; go version</span><br><span class="line">$&gt; go1.15.5 linux/amd64  <span class="comment"># 安装成功</span></span><br></pre></td></tr></table></figure><h2 id="2-配置goland连接orgin"><a href="#2-配置goland连接orgin" class="headerlink" title="2. 配置goland连接orgin"></a>2. 配置goland连接orgin</h2><p>goland是jetbrains公司开发的IDE，开发go程序体验不错，这里以goland为例，配置一个连接origin的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preferences -&gt; Build,Execution,Deployment-&gt;Deployment</span><br></pre></td></tr></table></figure><p>点左上角 + 并选择SFTP类型</p><p><img src="01.png" alt="image-20210421130953352"></p><p> 在connection tabs上添加虚拟机地址</p><p>在mappings分别填上本地的path和远端的path</p><p>点击apply ok 即可；</p><p><img src="02.png" alt="image-20210421131425549"></p><p>选择always，保持文件更新之后往远程push</p><p><img src="03.png" alt="image-20210421131510480"></p><p>在Tools&gt;ssh configuration配置origin机器信息，这样就可以在IDE的tool工具栏中开启origin的命令行并愉快的使用了；</p><h2 id="3-安装protobuf和grpc"><a href="#3-安装protobuf和grpc" class="headerlink" title="3. 安装protobuf和grpc"></a>3. 安装protobuf和grpc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&gt; wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protobuf-all-3.13.0.tar.gz -P /data/ <span class="comment"># 将文件下载至data文件夹中</span></span><br><span class="line">$&gt; tar -zxvf protobuf-all-3.13.0.tar.gz</span><br><span class="line">$&gt; <span class="built_in">cd</span> protobuf-3.13.0/</span><br><span class="line">$&gt; ./configure --prefix=/usr/<span class="built_in">local</span>/protobuf <span class="comment"># 编译安装</span></span><br><span class="line">$&gt; make</span><br><span class="line">$&gt; make install</span><br></pre></td></tr></table></figure><p><strong>配置环境变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$&gt; vim ~/.profile</span><br><span class="line"><span class="comment">#protobuf config</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#(动态库搜索路径) 程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/lib/</span><br><span class="line"><span class="comment">#(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/lib/</span><br><span class="line"><span class="comment">#执行程序搜索路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/protobuf/bin/</span><br><span class="line"><span class="comment">#c程序头文件搜索路径</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$C_INCLUDE_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/include/</span><br><span class="line"><span class="comment">#c++程序头文件搜索路径</span></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$CPLUS_INCLUDE_PATH</span>:/usr/<span class="built_in">local</span>/protobuf/include/</span><br><span class="line"><span class="comment">#pkg-config 路径</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/usr/<span class="built_in">local</span>/protobuf/lib/pkgconfig/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.profile</span><br><span class="line">protoc --version</span><br><span class="line"><span class="comment"># libprotoc 3.13.0 install complate!</span></span><br></pre></td></tr></table></figure><p>安装go语言插件，因为protobuf并没有直接支持go语言，需要手动安装一下相关插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go get -v -u github.com/golang/protobuf/proto</span><br><span class="line">$&gt; <span class="built_in">cd</span> 到 github.com/golang/protobuf/protoc-gen-go/</span><br><span class="line">$&gt; go build <span class="comment"># 执行打包，生成 protoc-gen-go 可执行文件</span></span><br><span class="line">$&gt; sudo cp protoc-gen-go /bin/ 将可以执行命令复制到/bin中</span><br><span class="line"><span class="comment"># 尝试补全 protoc-gen-go， 如果成功，则表示ok</span></span><br></pre></td></tr></table></figure><p><strong>测试编译是否成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=./ *.proto  <span class="comment"># 在远程执行编译</span></span><br><span class="line"><span class="comment"># grpc编译</span></span><br><span class="line">protoc --go_out=plugins=grpc:./ *.proto</span><br></pre></td></tr></table></figure><p><strong>安装grpc</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v google.golang.org/grpc</span><br></pre></td></tr></table></figure><h2 id="4-安装微服务相关工具"><a href="#4-安装微服务相关工具" class="headerlink" title="4. 安装微服务相关工具"></a>4. 安装微服务相关工具</h2><h3 id="4-1-安装consul"><a href="#4-1-安装consul" class="headerlink" title="4.1 安装consul"></a>4.1 <strong>安装consul</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://releases.hashicorp.com/consul/1.5.2/consul_1.5.2_linux_amd64.zip</span><br><span class="line">$ unzip consul_1.5.2_linux_amd64.zip</span><br><span class="line">$ sudo mv consul /usr/<span class="built_in">local</span>/bin/ <span class="comment"># 将可执行目录移动到bin目录</span></span><br></pre></td></tr></table></figure><h3 id="4-2-consul测试"><a href="#4-2-consul测试" class="headerlink" title="4.2 consul测试"></a>4.2 <strong>consul测试</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -<span class="built_in">bind</span>=0.0.0.0 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure><h3 id="4-3-consul和grpc结合使用"><a href="#4-3-consul和grpc结合使用" class="headerlink" title="4.3 consul和grpc结合使用"></a>4.3 <strong>consul和grpc结合使用</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go get -u -v github.com/hashicorp/consul</span><br></pre></td></tr></table></figure><h3 id="4-4-go-micro安装"><a href="#4-4-go-micro安装" class="headerlink" title="4.4 go-micro安装"></a>4.4 go-micro安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装go-micro</span></span><br><span class="line">go get -u -v github.com/micro/go-micro</span><br><span class="line"><span class="comment">#安装工具集</span></span><br><span class="line">go get -u -v github.com/micro/micro</span><br><span class="line"><span class="comment">#安装protobuf插件</span></span><br><span class="line">go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</span><br><span class="line">go get -u github.com/micro/protoc-gen-micro</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http</title>
      <link href="2021/04/14/http/"/>
      <url>2021/04/14/http/</url>
      
        <content type="html"><![CDATA[<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><h2 id="2-搭建条件环境"><a href="#2-搭建条件环境" class="headerlink" title="2. 搭建条件环境"></a>2. 搭建条件环境</h2><p>在Mac上，</p><p>拷贝项目（需要Git）</p><ol><li>git clone <a href="https://github.com/chronolaw/http_study" target="_blank" rel="noopener">https://github.com/chronolaw/http_study</a></li></ol><p>安装OpenResty （推荐使用Homebrew）</p><ol><li>brew tap openresty/brew</li><li>brew install openresty</li></ol><p>运行项目</p><ol><li>cd http_study/www/</li><li>openresty -p <code>pwd</code> -c conf/nginx.conf</li></ol><p>停止项目</p><ol><li>openresty -s quit -p <code>pwd</code> -c conf/nginx.conf</li></ol><p>补充</p><p>遇到了访问 localhost 时，网页报 403 错误的情况，原因是没有 html/index.html 文件的访问权限。</p><p>解决方案：<br>先 ls -la html，查看文件的权限，得到 user 和 group，如果是 fstar 和 staff。</p><p>那么在 conf/nginx.conf 文件的顶部添加</p><p>user fstar staff;</p><p>然后再启动 openresty 就可以正常访问了。</p><p>启动docker</p><p>systemctl start docker</p><p>关闭docker</p><p>systemctl stop docker</p><p>查看docker的运行状态</p><p>systemctl status docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run -it --rm --user root -p  0.0.0.0:8888:80 chronolaw/http_study bash</span><br><span class="line"><span class="comment"># 访问主机的8888端口会被定向到容器的80端口</span></span><br><span class="line"></span><br><span class="line">cat ~/http_study/hosts &gt;&gt; /etc/hosts</span><br><span class="line"><span class="built_in">cd</span> ~/http_study/www</span><br><span class="line">./run.sh start</span><br></pre></td></tr></table></figure><p>解决nginx 403 Forbidden的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux|grep nginx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learn</title>
      <link href="2021/04/02/learn/"/>
      <url>2021/04/02/learn/</url>
      
        <content type="html"><![CDATA[<h2 id="1-核心算法"><a href="#1-核心算法" class="headerlink" title="1. 核心算法"></a>1. 核心算法</h2><ul><li>知道自己是如何学会的</li><li>回顾不忘、类推</li><li>学会（下）一个</li></ul><p>什么是学？</p><p><strong>学的本质是模仿</strong></p><p>冯先生学英语的秘诀：</p><ol><li>背诵好文章（例如著名的小说，百科全书）</li><li>他的背诵极其精准——只字不差（促使他跟人交流的时候，能用更高级的语言，精准的高级语言）</li><li>学语言的同时拓展了他对其他领域的知识和文化的认知</li><li>这并不需要天生的超常记忆力</li></ol><p>林语堂：</p><p>学习英语的唯一正轨，</p><p>不出仿效与熟诵。</p><p>仿效要是整句的仿效</p><p>热诵则效仿之后必回环练习</p><p>最重要的，是学时必整句吞下</p><p>再整句吐出来</p><p>每日选二三句</p><p>回环熟诵</p><p><strong>什么叫回环练习？</strong></p><p><strong>天文学著作看上去看困难，中学生想读懂大学的天文学教科书非常困难。但是你从头开始往下读，读哪卡住了，再从头开始读。原来卡住你的地方就卡不住你了；再持续推进，再从头开始读，这叫回环练习；</strong></p><p><strong>为何整句仿效，整句吐出？</strong></p><p><strong>整句会有明显的成就感和收获感，随着时间的推移。这种收获感会越来越强。会让人上瘾，这是强调整句的重要性；</strong></p><p>为什么是两三句呢？</p><p>第一就是每日选两三句，可以确保能拿下来。</p><p>另外一个随着时间的推移，一天两三句，十天就是二三十句。一百天就是二三百句。这二三百句你都要回环熟诵的。这样工作量就大了。</p><p>丘吉尔（诺贝尔文学奖）： 背诵麦考利的1200行史记</p><p>辜鸿铭（9国语言）： 德语背诵歌德的《浮士德》、英语弥尔顿的《失乐园》</p><p>阿西莫夫（最高产的科学科幻作家）： 背诵《伊利亚特》</p><p>苏轼 背诵80万字的《汉书》</p><h3 id="1-1-学习的本质"><a href="#1-1-学习的本质" class="headerlink" title="1.1 学习的本质"></a>1.1 学习的本质</h3><p>按照学习的本质定义学习就是捷径</p><p><strong>思维训练程序</strong></p><ol><li><strong>选择优秀文章背诵，具有永久价值、不枯燥、历久弥新</strong></li><li><strong>拆成单个句子，复杂句子拆分成短句</strong></li><li><strong>循环往复、循序渐进背诵、默写</strong></li><li><strong>理解文章含义</strong></li><li><strong>背诵下一句之前，把以往所学背默一遍，遇到卡顿错漏重复背默；</strong></li><li><strong>直到这些文章成为自己身体的一部分，随意调遣使用；</strong></li></ol><p>“不要为你在数学上遇到的苦难感到担忧，我可以向你保证，我遇到的困难更大”</p><p>—— 爱因斯坦</p><h4 id="1-1-1-回环练习"><a href="#1-1-1-回环练习" class="headerlink" title="1.1.1 回环练习"></a>1.1.1 回环练习</h4><p><strong>顶级数学家如何学数学</strong></p><p>“对我来说，没有比数学书更难念了，数百页的书从头到尾念至难念完。因为知道“数学”读懂了，也就是成为最简单不过的事情而已。</p><p><u>所以只念定理。努力想了解它。证明就自己想。而在一般情形之下是想不透的，只好看书上的证明。但是读一两次也不觉得懂，便把证明写在笔记上看看。</u></p><p><u>这回注意到证明有不中意的地方，就想有没有别的证明法？这样子好不容易读完一章时，前面的部分已经忘了。没法子，又从头复习。这回倒在意起整本书章节的排列方式来。”</u></p><p>这不就是林语堂说的 “回环练习”吗？</p><p><u>这回倒在意起整本书章节的排列方式来，他发现前后章节有联系的。你从后面的知识能理解前面的知识，你前面的知识可以有助于理解后面的知识。这是什么？ 这就是融会贯通。</u></p><p><strong>短期内突破的思维程序是什么？</strong></p><p><strong>第一点  基本概念基本定义一定要背熟，尤其像数理这样的学科。</strong></p><p><strong>第二点 能够独立推导出来的一切可以推导的东西，你一定要独立去推导；而且要推导得熟练。比如说课本上教科书里面有的定理公式的证明和推导，这个过程你一定要熟练的掌握。</strong></p><p><code>因为这些基本定理、基本公式的推导证明过程就是数学思维的核心</code></p><p><strong>什么是核心？</strong></p><p>就是你在所有的数学的阅读理解，读书做题的时候，你会反反复复一而再再二三地运用这些思维方式。</p><p><strong><u>数学最核心的思维操作。就是蕴含在定理公式的推导和证明里面。</u></strong></p><p>所以必须拿下，拿下就意味着，很可能你会达到一通百通的状态。<u>你不知道是第几个定理证明，你熟练之后你突然豁然开朗。</u></p><p><u>数学原来如此简单；不就是这几套思路反复用对不对？</u>一通百通，效率就大大提升。</p><p>第三， <u>当你这么去做的时候。你去抄写去背诵去默写定义概念，去尝试理解它、去尝试推导定理公式的时候。你会有很多感悟、很多感想。那你把它记下来。一定要将它记下来。这是宝贵的财富。</u>这是你付出努力的一个重要的收获就是你的感悟。你突然发现数学是怎么回事了。数学思维是怎么回事了。把它记下来；</p><p> <strong>进步本</strong></p><p><u>然后，弄懂的题目要装进进步本里面去；</u></p><p><u>你不会做的后来会做了，做错弄正确了的。你要放进进步本里面去。去反复的复习。</u></p><p><u>因为你错了，那意味着你之前的认知一定是有错的地方。</u></p><p><u>你能把它补上来，还有不会做的题目你弄懂了，为什么弄懂了，一定是之前的概念定义， 要不然忘掉了，要不然是理解错了。现在纠正过来了，为什么不要记录下来？</u></p><p><u>第四点 要反复重复做标注，达到不忘达到熟练。就是回环练习。</u>把卡住的地方弄错的地方不断标注强化它；</p><p>第四点就是回还往复的循环渐进，用前面的知识理解后面的。反之亦然，用后面的知识理解前面的。达到融会贯通。</p><p>“优秀者模仿，伟大者剽窃” —— 乔布斯</p><p><strong>牛人都来自模仿牛人</strong></p><h4 id="1-1-3-学习-模仿-刻意练习"><a href="#1-1-3-学习-模仿-刻意练习" class="headerlink" title="1.1.3 学习=模仿+刻意练习"></a>1.1.3 学习=模仿+刻意练习</h4><p>爱因斯坦： 牛顿、麦克斯韦、。。。。</p><p>巴菲特： 格雷厄姆、费雪</p><p>马斯克： 乔布斯、福特、洛克菲勒</p><p>稻盛和夫： 王阳明 松下幸之助</p><p>孙正义：坂本龙马、松下幸之助</p><p>刘强东： 沃尔玛的山姆博尔顿</p><h3 id="1-2-思考题"><a href="#1-2-思考题" class="headerlink" title="1.2 思考题"></a>1.2 思考题</h3><p>你最成功的模仿经历是什么？</p><p>这就是你迈向高效能学习的一个台阶</p><h2 id="2-让学习成为一种习惯"><a href="#2-让学习成为一种习惯" class="headerlink" title="2. 让学习成为一种习惯"></a>2. 让学习成为一种习惯</h2><p>学会一个东西有多难？</p><h3 id="2-1-康奈尔笔记法"><a href="#2-1-康奈尔笔记法" class="headerlink" title="2.1 康奈尔笔记法"></a>2.1 <strong>康奈尔笔记法</strong></h3><p><strong>记录： 在听讲或阅读过程中，在主栏尽量多记</strong></p><p><strong>简化： 课后，及早将归纳、提炼记录在副栏</strong></p><p><strong>背诵： 把主栏遮住，只用回忆栏复现所学</strong></p><p><strong>思考： 记录各种问题、感悟体会</strong></p><p><strong>复习： 每周花十分钟左右时间，快速复习笔记</strong></p><p><u>学习会产生生理变化，所以需要反复练习；</u></p><h4 id="2-1-1-康奈尔笔记法跟进步本是什么关系？"><a href="#2-1-1-康奈尔笔记法跟进步本是什么关系？" class="headerlink" title="2.1.1 康奈尔笔记法跟进步本是什么关系？"></a>2.1.1 康奈尔笔记法跟进步本是什么关系？</h4><p>进步本把记忆法则推到了极端、极致。</p><p>比如记录这个环节，把当天所有的进步，知识点、框架、框图、做错的修正过来的。不会弄懂的题目全都要记进去，而且要<strong>标注一切让你感到有收获的地方。包括思路技巧方法知识点等等</strong>。</p><p>然后第二步复习，记在本子上的东西是潜在的进步。那不是你实在的进步，除非巩固住了，那才是真实的进步。</p><p>如何巩固住。<strong>随时随地的检测式的复习</strong></p><p>康奈尔说，通过五步。后面每星期复习10分钟，那是不够的。你要产生极端的效果。你必须随时随地的复习。还要检测式的复习。自己考自己，拿什么叫做随时随地？ 当你回忆起来映像模糊了，你赶紧回去重复， 标注。 包括题目， 题目感觉已经做会了。做会了哪够啊？考试都是计时的，你必须要熟练。熟练都不行，还要高度熟练。那题目反复做做到熟练。然后知识的话就要在大脑里面反复呈现。然后知识的话就要在大脑里面反复呈现。呈现以清晰为标准。</p><p><strong>越高水平的人对细节的关注越是变态</strong></p><p>天下大事必作于细，天下难事必作于易 —— 道德经</p><ol><li><u>记录 潜在进步，记录当天所有进步，知识点、框图、做错误修正的，不会弄懂的题目</u></li><li><u>复习巩固，随时随地的检测式复习，随时随地的考自己。题目反复做直到熟练，知识反复在大脑中呈现直到清晰，过程中不断标注，丰富进步本内容</u></li><li><u>检测发现进步空间 做题，测试。模拟考试，努力去发现还有哪些不会做的题目，还有哪些模糊点，发现进步空间</u></li></ol><h4 id="2-1-2-好的进步本是什么样"><a href="#2-1-2-好的进步本是什么样" class="headerlink" title="2.1.2 好的进步本是什么样"></a>2.1.2 好的进步本是什么样</h4><ol><li><p><u>第一就是题目和答案要分离，目的是为了方便考察自己。这就叫真的学习，必须这么做。</u></p></li><li><p><u>那么第二点要分析所有选项的正误。知道正确的，但是那几个不对的选项它为何是错误的，你要去分析。一道题知道哪个对是不行，还要知道剩下的为什么不对。假学习浪费生命</u></p></li><li><p><u>分析出题人的意图，一道题目你都要整理道进步本了。目的是什么，目的是你要百分之百的把这个题目都掌握了。为什么会这么出题？这个题目为什么是合理的？它能成为一道考题。<strong>出题是很难的</strong>，<strong>题目本身的信息量是远远大于答案的。还大于解题过程。</strong>所以在抄题过程中，要分析它为什么这么出题。如果从题目到解题过程到正确答案全都分析透的话，那你就能够出一道类似的题目。那知识真的掌握透了</u></p></li></ol><p><strong>一道题，题目写得很清晰。各个选项都写的清晰。还有把这个图也配得非常好。然后正确答案写很后面不起眼的地方。这就非常有利于后面再考察自己；</strong></p><h3 id="2-2-学习的根本价值"><a href="#2-2-学习的根本价值" class="headerlink" title="2.2 学习的根本价值"></a>2.2 学习的根本价值</h3><p>学习的根本价值就是创造价值，一个人将来在社会上立足；</p><p>立足的根本就是给别人提供服务。提供有价值的作品，有价值的东西；那么你从学习的过程中就在做这件事情。你想想他的将来的前途如何？一定比好多人都光明的多； </p><h3 id="2-3-让学习成为创作艺术"><a href="#2-3-让学习成为创作艺术" class="headerlink" title="2.3 让学习成为创作艺术"></a>2.3 让学习成为创作艺术</h3><p>从一开始就按照大师的水准要求自己，想要成为顶尖学者吗？那么，<strong><u>学习的时候就要力图写成一本书。</u></strong></p><p><strong><u>想成为领域的专家，无论是什么领域。只要你想成为顶级专家。当你学习的时候，你就要力图写成一本书。</u></strong></p><h3 id="2-4-笔记的等级"><a href="#2-4-笔记的等级" class="headerlink" title="2.4 笔记的等级"></a>2.4 笔记的等级</h3><p>为什么说你从一开始就要按照顶级的水平去做呢？</p><p>因为“信念即自我预言效应”，这么去想这么去做。这么实现的可能性就大。如果你一开始笔记都记得乱七八糟的。就不要想成为哪个领域专家。</p><p>你从一开始一点一滴的就按照最高的水平去要求自己；</p><h2 id="3-极致心态"><a href="#3-极致心态" class="headerlink" title="3. 极致心态"></a>3. 极致心态</h2><p>把能把握住的点滴做到百分之百，每一块砖每一块瓦人生大厦的基础材料你做好。那么后面的各种可能性就都出来了。</p><p><code>99% is the same as zero, if you are gonna do 99, go ahead and stay home -- Will Smith</code></p><p><strong>欲求其上，必求上上；</strong></p><p>想取得很好的结果，必须要要求自己达到杰出的、顶尖的水平；你才能有更大的可能性达到你想要的非常好的结果。</p><p>能不能达到100%是第二个环节，第一个环节是力图去达到。然后才有更大的可能性达到。</p><p>各个领域的高手全都是这样子 —— 对自己要求，标准，目标是极高的；</p><p>要去淘汰自己，否则会被对手淘汰。</p><h3 id="3-1-进步回路："><a href="#3-1-进步回路：" class="headerlink" title="3.1 进步回路："></a>3.1 进步回路：</h3><ol><li><strong><u>记录潜在进步，记录当天所有的进步，知识点 框图，做错修正的，不会弄懂的题目标注一切让你感到收获的地方，包括思路，技巧方法和知识点；</u></strong></li><li><strong><u>复习巩固进步，随时随地的检测式复习，随时随地考自己，题目反复做直到熟练，知识反复在大脑中呈现直到清晰，过程中不断标注，丰富进步本内容</u></strong></li><li><strong><u>检测发现进步空间，做题，测试，模拟考试，努力去发现还有哪些不会做的题目，还有哪些模糊点，发现进步空间；</u></strong></li></ol><h3 id="3-2-思考题"><a href="#3-2-思考题" class="headerlink" title="3.2 思考题"></a>3.2 思考题</h3><ul><li>在你学业中，哪个环节做到了极致？效果如何？</li><li>哪个环节，你可以做到极致？</li></ul><h2 id="4-让成就感加快学习步伐"><a href="#4-让成就感加快学习步伐" class="headerlink" title="4. 让成就感加快学习步伐"></a>4. 让成就感加快学习步伐</h2><h3 id="4-1-聪明的目标"><a href="#4-1-聪明的目标" class="headerlink" title="4.1 聪明的目标"></a>4.1 聪明的目标</h3><p>具体</p><p>可测量</p><p>兴奋</p><p>现实</p><p>时效</p><p>当你把目标做的足够细小的时候，那么这个smart目标就容易设定了。不但容易设定，而且容易达成。不但容易达成，而且容易频繁地体验到成就感。让目标粉末化</p><p>比如一句一句学好英语，具体到几分钟之内就完成一句的目标；</p><h4 id="4-1-1-实例：-5篇文章"><a href="#4-1-1-实例：-5篇文章" class="headerlink" title="4.1.1 实例： 5篇文章"></a>4.1.1 实例： 5篇文章</h4><p>那么这5篇文章可以分成五组</p><p>5篇（为一组）是一个里程碑</p><p>第一组，已经突破，建立自信，建立方法</p><p>第二组， 挑战更大，训练元认知</p><p>第三组 ， 进入细节，整合到自己的生命</p><p>第四组， 浑然忘我，欲罢不能</p><p>第五组， 整体回顾，构建强大的知识体系</p><p>以前没有完整地熟练过一篇文章，一旦一篇文章拿下来了。那是突破的感觉就形成了，然后就建立了自信。第一篇拿下了，以此类推第二篇也可以拿下来。除了建立自信，还建立了方法。</p><p>如何将一篇文章拿下来的方法已经建立了。往后无非是重复一遍再把各个环节精致一下，精炼一下，做到更好。训练元认知；</p><p>进入细节，尝试去调用这些文章。假如写一篇新的文章。写作上你能不能用上其中的句子。你要整合到自己的生命里去。</p><p>到了第四篇的时候，那可能就是浑然忘我了。熟能生巧。不断不断体验到这种成就感，欲罢不能了。</p><p>第五组的话，就是你可以把第五章文章拿下来。五篇文章综合起来，整体回顾。那就能够帮你构建一个强大的知识体系了；</p><p>五篇长文，托福级别的长文它包含着很多知识的细节；所以这五篇文章就是一个里程碑</p><p>21篇文章200多个句子，就能产生这么大的效果吗？</p><h4 id="4-1-2-书籍推荐"><a href="#4-1-2-书籍推荐" class="headerlink" title="4.1.2 书籍推荐"></a>4.1.2 书籍推荐</h4><p>《微习惯——简单到不可能失败的自我管理法则》</p><p>从很小的小细节小单位做起，它很容易入手；那么行动又促进你的认知，行动产生效果；效果又牵引着你继续去行动逐渐养成了（习惯）</p><h4 id="4-1-3-上瘾"><a href="#4-1-3-上瘾" class="headerlink" title="4.1.3 上瘾"></a>4.1.3 上瘾</h4><p>目标粉末话=频繁体验成功=上瘾</p><p><strong>学到了什么 大于 学了什么</strong></p><p><strong>学到什么说不清</strong> = <u><strong>慢行自杀</strong></u></p><h3 id="4-2-思考题"><a href="#4-2-思考题" class="headerlink" title="4.2 思考题"></a>4.2 思考题</h3><ol><li>拟定的目标总是达不成，原因是什么？</li><li>你有哪些成功达成目标的经历？（哪些可以继承和复制）</li></ol><h2 id="5-构建学习方案，"><a href="#5-构建学习方案，" class="headerlink" title="5.构建学习方案，"></a>5.构建学习方案，</h2><blockquote><p> 构建学习方案，增幅学习效果，指数增长</p></blockquote><h3 id="5-1-方案和计划"><a href="#5-1-方案和计划" class="headerlink" title="5.1 方案和计划"></a>5.1 方案和计划</h3><p>什么是方案</p><p>所谓方，药方。能显著解决问题</p><p>所谓案， 它要极其缜密，要像破案那样子</p><p>实现指数增长的巴菲特</p><ol><li><u><strong>不要亏钱</strong></u></li><li><u><strong>永远不要忘记法则1</strong></u></li></ol><p>学习也是如此，忘掉的知识就等于亏了吗。所以需要温故。然而一旦投入学习的时候 就会忘记法则一。</p><p><u><strong>新学的东西 - 忘记的东西 = 退步</strong></u></p><p><u><strong>第一法则： 不要遗忘，就是反反复复的回环去复习。去确保已经学到的东西百分之百掌握了，然后再图进步。 （高筑墙，广积粮，缓称王）（结硬寨，打呆仗）</strong></u></p><p><u><strong>第二法则： 永远不要忘记法则1</strong></u></p><h3 id="5-2-三小时见效的数学课"><a href="#5-2-三小时见效的数学课" class="headerlink" title="5.2 三小时见效的数学课"></a>5.2 三小时见效的数学课</h3><p>你觉得数学这一科里面哪个专项或哪一章哪一节是你的弱点；别选最难的，选那些花一些力气就能够见效果的章节。</p><p>把这样的章节的题目分成5组或6组，每组5道题或者6道题。分组练习，每一组都用这个进步本的方法。6道题做下来，发现错了3道。要详细把这三道题目整理下来，你到底从这道题里面学到了什么。不管是请教同学还是老师，把题目弄懂，这些为何自己不会 以及后来听懂之后的思路原原本本记录再进步本里面。记录的过程中就是熟练的过程，加深记忆，加深理解的过程。然后这三道题整个梳理完之后，你要重新做一遍。那叫做进步本的复习和巩固环节。</p><p>虽然通过这个读答案或者听同学讲明白了，但是你独立的重新做能不能再做出来那是两回事。你必须要确认你能够做出来。这三道以前做错的题目或者不会做的题目。你真的弄懂了会做了。然后你再进行下一组的练习。下一组的五道题或六道题目去练习。那么在大多数情况下它是一定有进步的。</p><p>比如第一组只有50%的正确率，那么第二组就70%的准确率了。第二组依然按照这个回路迭代。就又掌握了一些解题技巧，方法，思路。你再巩固再把之前的你做错的部分再重新做一遍。不单要记住，而且要熟练，还要去理解，增加这个熟练度。然后你再进行第三组练习。因为题型很少。随着组数增多，正确率会可预见的提高的；</p><p><strong>内心感触是什么？</strong></p><p><em>是知识高度清晰了，而且高度熟练。然后信心油然而生就这样一个过程。</em></p><p>一天之内实现学习越迁</p><ol><li>巩固所学，永远是最重要的</li><li>划分明确的专题</li><li>分组练习，力图达到100%正确率，实现越迁</li></ol><h3 id="5-3-思考题"><a href="#5-3-思考题" class="headerlink" title="5.3 思考题"></a>5.3 思考题</h3><ol><li>如何可持续的跃迁</li><li>如何体验到熟练掌握知识的感觉？（对于没有100%掌握过一个东西的人来讲的话，他很难有学到一个东西的感觉。就学习的高级状态是什么他很难体验到，这个只能通过自己努力实现了）</li></ol><h2 id="6-构建增长引擎"><a href="#6-构建增长引擎" class="headerlink" title="6. 构建增长引擎"></a>6. 构建增长引擎</h2><p>我不断地看到有些人在生活中越过越好，他们不是最聪明的，甚至不是最勤奋的，但他们是学习机器，他们每天夜里睡觉时都比那天早晨聪明一点点；</p><p>—— 查理芒格</p><p><u><strong>机器的本质是什么？</strong></u></p><p><u>持续运转，而且可以组装和改进它；那么对于人来讲，实际上本质就是一套思维的程序。</u></p><h3 id="6-1-学习算法"><a href="#6-1-学习算法" class="headerlink" title="6.1 学习算法"></a>6.1 学习算法</h3><p>学习算法可以称得上是终极学习方法的一个算法，一旦掌握，那我们对自己的人生的发展趋势就能够有预判。</p><p>这个核心算法是什么呢？</p><p>三个环节</p><p>第一： <strong>我们每个人无论遇到多么复杂的知识和技能，一定能学到其中的一点。尤其是最开始那一点。一定能学会的。</strong></p><p>第二： <strong>我们知道如何学会，学会的过程，哪怕是一个很微小的点。要知道如何去学会，</strong></p><p><strong>然后第三个环节，是学会的东西。不要再忘了，就不断去巩固它。通过巩固，别再遗忘然后再把这个学会的过程类推到学更多的东西到下一个</strong></p><p><strong>比尔盖茨</strong></p><p><u>如果你指定一个明确的目标，并且找到一种能够朝着目标推进的计量手段。就是某种反馈回路那样的计量手段。他说： 你就可以取得不可思议的进步。</u></p><p>对应上面的内核引擎，尤其对于数学物理这种理工科的知识，它是层层递进的，是个大厦的结构。做完前一个，才可能学到后一个，那意味着什么？就是你是不是真的学到了一个东西是能够得到检验的。当你前一个东西没有把握住的时候，<u><strong>前一个知识点没有掌握的情况下，你不可能往前推进的，你只要往前推进就意味着你掌握了前面的东西。所以，这构成了一个明确的回路。</strong></u></p><p>另外 这是一个计量手段，<u><strong>一章一节你是用多长时间完成的？然后完成了多少题目？这里面含了多少个知识点，重复了多少遍？这都是可以计量的。一旦你有这个量化的形式来度量自己的学习效果和进步的速度。那你就可以去改进它，不断去改进它。这就是很多人在用的这个手段。一种工作 学习高效能的手段。</strong></u></p><p>ok 那我们看这个进步本是不是也满足这个条件？</p><p>进步本就把刚才那个核心算法把它给升级了，就在那个基础上做了一个升级。升级到我们学习过程中更宏观的三个环节。</p><p>比如记录，大家所有人都在做记录是吧？听课笔记，读书笔记等等；我们只不过是在进步本里面要求把这个环节做到极致；</p><p><strong>首先呢，就是任何一点你感到有收获的地方，把它记下来。无论是知识还是题目还是框图等等。</strong></p><p><strong>第二呢，是全部。你只要是能记下来的东西，你都要把它记下来。</strong></p><p><strong>然后是复习，所有人都在复习。只不过我们把它推到极致了。你学到的东西不要再忘记了。</strong></p><p><u>通过什么方式复习，就是检测式复习。随时随地考察自己。如果是知识的话就是大脑里面回想。如果回想不清楚的话就说明将要遗忘了。就马上要重新翻笔记。</u>如果是题目就重新做，如果说是回忆起来这个题目，有个思路，但是详细的细节想不起来了。那你原则上是要重做的，达到熟练。最后让这些知识和题目在大脑中达到清晰。这是复习</p><p>然后呢，第3个环节是检测，我们每天都在做题目，各种测试。关键是你要把那些模糊进步的空间给找出来，你下一步就可以专项突破了。专项突破的话一旦突破了就实现了一个里程碑。那么这个寻找进步空间的过程中。就又发现了一系列你学到的东西。又进行记录等等。这样的话，这三个环节就有效的首尾相连，连在一起。形成一个正反馈的回路。这里的关键是，它是可以量化的。</p><p>比如我在高中那一年，平均每天20页。按320天来算的话，就是6400页。如果说内容都掌握了。那肯定是你考试的时候是很难紧张起来的</p><p><strong><u>那这个进步本的回路呢，实际有两个回路，一个是认知回路，知道自己为何这么去做。</u></strong></p><p>原因是什么？原因呢就是你踏踏实实的这么去行动。要产生效果也只能这么做。为什么？你想想再好的效果 都是由一点一滴的那个小的成就构成的。</p><p><strong>这个进步本就是在把握一点一滴的这个小的成就。</strong>小的进步，知道它的原理是什么。知道所以然，然后就可以踏踏实实的行动了。</p><p>然后，付出行动之后又有<strong><u>行动回路</u></strong>。一旦这么去做的话，那个效果是很容易检验的。以此类推做知识管理。</p><h3 id="6-2-再说进步本"><a href="#6-2-再说进步本" class="headerlink" title="6.2 再说进步本"></a>6.2 再说进步本</h3><p>当时为什么对进步本这么有信心？</p><p>不是说，要怎么说服自己。而是直观的效果告诉我。它说一个高速进步的方法。而这个检测的时间并不长。一周的时间都可以检测出来了。拿它来攻克一章的内容。那顶多也就一周的时间，看上去以前从来没有达到过90%的正确率。</p><p>如果你的学习闭环了，你从怎么操作，怎么去认知它到产生效果，能够封闭起来。一个环节 促进另外一个环节。旋转起来，那么考试是很容易上瘾的。</p><p>能用进步本的时候，再考试的时候。一看到某些题就知道一定能拿下来 就不再有焦虑了。因为太熟练了，头脑高速清晰。能拿到的一定能拿到那个分数。拿不到的分数，那有些题目却是没思路吗。那就意味着进步空间呀。在考试结束的时候你把那几个不明确的。没把握的题目 将专题明确下来。 用专题突破的方式用进步本来突破。很快就达到90%以上的准备度和熟练度。不断扩大疆域，一个月以内就把整个心态完全扭转了。考虑不单单是衡量掌握知识程度的这么一个定量化的方法。也不仅仅是因为学习方法的选择，改进提供标准。也不仅仅是让我们学习上瘾/而且能够综合锻炼人的一系列素质。</p><p>如果你对学习的本质 有深刻的认知的话。考试实际上是一个难得的机遇。</p><p>珍惜有考试的高中啊，考试就是反馈啊。可惜，人生再也没有了；</p><p>在职场里面，你自己一旦把这个方法明确之后，那它时时刻刻也在给你提供反馈。那么学习增长引擎和企业增长引擎是同样的本质。都是正反馈回路。</p><p>比如亚马逊 增长飞轮。它核心是为了增长。为了它的价值增长，用户增长。它有几个环节构成的闭环。比如它提供了一个平台。很多商品供用户选择。然后极可能把商品介绍周全。图片评价，然后，他就再去精选供应商，稳定的供应和优质的产品。</p><p><img src="feilun.png" alt="image-20210403104949570"></p><h3 id="6-3-思考题"><a href="#6-3-思考题" class="headerlink" title="6.3 思考题"></a>6.3 思考题</h3><ol><li>你的学习增长引擎是什么？</li><li>你的人生增长引擎是什么？</li></ol><h2 id="7-费曼超级阅读法"><a href="#7-费曼超级阅读法" class="headerlink" title="7. 费曼超级阅读法"></a>7. 费曼超级阅读法</h2><p>两个基本问题</p><ol><li>掌握专业知识的最大障碍是什么？</li><li>克服障碍的方法是什么？</li></ol><p><strong>专业知识难，难学、难以掌握为什么？</strong></p><p><u>因为它的知识密度大，信息密度大；</u></p><p>随便看一篇小说，特别顺畅，特别享受，就是因为里面的知识密度、信息密度小；</p><p><u>专业知识，那里面包含着大量位置的知识；</u></p><p>杨振宁说数学包含两类，一类是你读不过第一页的，另外一类是你读不过第一行字的；</p><p>读不过第一行就是因为知识密度太大，很难理解；</p><p>而解决这个问题，就需要 <strong>费曼阅读法</strong></p><p><strong><u>“你从头读，尽量往下读。直到你一窍不通时，再从头开始。这样坚持往下读，直到你完全读懂为止。”</u></strong></p><p>这个方法有很多值得挖掘的地方</p><ol><li><strong><u>它能保证你持续的推进；</u></strong>（即使第一句就卡住，你就第一句多读几遍直到完全理解。甚至还要把它记住。概念定义这种东西，定下来的意义 就是这么定的。 大家约定俗成的 是约定下来的这么一个东西。也是经过很多检验的。）</li><li><u><strong>不断产生成就感，</strong></u>（一旦第一句理解了，后面第二句依据第一句的含义多重复几遍也能懂。 懂就是一种成就）</li></ol><p>人咸谓板桥读书善记，不只非善记，乃善诵耳。</p><p>板桥每读一书，必千万遍；</p><p>—— 郑板桥</p><p>读经有一 “耐”字决，一句不通不看下句，今天不通，明日再读，今年不精，明年再读，此所谓耐也；</p><h3 id="7-1-为学-的品质"><a href="#7-1-为学-的品质" class="headerlink" title="7.1 为学 的品质"></a>7.1 为学 的品质</h3><p>“为学” 的品质是什么呢？</p><ul><li>“<strong><u>初有决定不移之志</u></strong>”就一开始就要有决定不移之志，我不拿下它决不罢休就这种。</li></ul><p>“眼前就这本书，就一本专业的教科书。你能不能把它拿下来，彻底拿下；拿下的标志的话就是你能够从头到尾跟人家讲明白。然后题目拿到了90%以上 接近100%的正确率你能不能做到” ok 下决心做到的那就是“初有决定不移之志”</p><ul><li><u><strong>中有勇猛精进之心</strong></u></li></ul><p>就是因为你这么折腾 这么做的话，做着做着你会烦。你会觉得有点慢。尤其初期的时候这么做好慢啊。人家都读完一遍了，我10/1还没读完，你就开始焦虑了，开始着急了。开始想入非非，胡思乱想了。所以要勇猛精进。这一套方法 一套思维程序你把它贯彻下去；到了一定阶段一定的深度，才会有豁然开朗 如果你不是勇猛精进，那再好的方法，你每天就10分钟这么弄一弄 10分钟弄一弄。那你一年也拿不下这一门专业课。勇猛精进就是不但要贯彻这个方法。而且还要去推进它 不断地推进更多一点；既要巩固又要往前推进</p><ul><li><u><strong>末有坚贞永固之力</strong></u></li></ul><p>一门课，80%这么干了。但留了20%的尾巴。无论什么原因，你没做到底，你就浪费了。</p><p>“记住知识就是力量，别人不学，你要学，不要随大流。以后有能力要帮助弟妹”</p><p>背负这种重托，我在当时的环境下，将樊映川的高等数学学习题集<u><strong>从头到尾做了两遍</strong></u>，学习了逻辑、哲学。还自学了三门外语，当时已经可以阅读大学课本的程度；</p><p>—— 任正非</p><h3 id="7-2-思考题"><a href="#7-2-思考题" class="headerlink" title="7.2 思考题"></a>7.2 思考题</h3><ol><li>你是怎么读书的？</li><li>你读书的榜样是谁？</li></ol><h2 id="8-记忆任何知识"><a href="#8-记忆任何知识" class="headerlink" title="8. 记忆任何知识"></a>8. 记忆任何知识</h2><p>记忆任何知识，打造超强度记忆力</p><p>前5分钟看的知识点，后5分钟开始模糊。</p><p>欣然接受这个事实，然后采取果断的措施，去对抗住那个遗忘；</p><h3 id="8-1-记忆困难的根本原因"><a href="#8-1-记忆困难的根本原因" class="headerlink" title="8.1 记忆困难的根本原因"></a>8.1 记忆困难的根本原因</h3><ol><li>记忆困难的根本原因是什么？</li><li>如何记住一堂课的内容？</li></ol><h4 id="8-1-1-艾宾浩斯遗忘曲线"><a href="#8-1-1-艾宾浩斯遗忘曲线" class="headerlink" title="8.1.1 艾宾浩斯遗忘曲线"></a>8.1.1 艾宾浩斯遗忘曲线</h4><p>“学一个新东西 一个完全陌生的东西。20分钟之后还记得多少；”</p><p>大家都知道艾宾浩斯遗忘曲线，可是没有几个人记得住艾宾浩斯遗忘曲线的具体数据；</p><p>这就是问题所在，大家都在学习模糊的东西。谈起艾宾浩斯遗忘曲线，都说知道这个概念。<strong><u>但真正有用的知识就是一些细节，比如艾宾浩斯遗忘曲线的那些重要参数；</u></strong></p><p><img src="aibin.png" alt="image-20210403143321657"></p><p><strong>学霸</strong></p><p>他知道这个原理知识遗忘是如此残酷，20分钟接近一半都已经忘掉，那怎么办？赶紧复习，随时随地复习。</p><p><strong>没等忘了很多了就赶紧把它捡回来了，一次一次这么去做。那么他对遗忘的知识都保持着90%到100%的这种准确性 精确性，对于理解后面的知识 那就容易多了</strong></p><p><strong>随时随地，高频回顾</strong></p><p>记住任何东西，我们的神经结构都会发生改变，</p><p>想要达成这样的变化只有两个办法</p><ul><li><strong>一个是高频的刺激，</strong></li><li><strong>另外一个是增加刺激的强度</strong></li></ul><p>那么最简单的容易操作每个人都可以做到的就是增加刺激的频率；只要一模糊就开始复习；</p><p>当你一天之内要把一个东西记住的话，就是相关的这个内容会存储在同一个神经元区里面。但你如果是超过24个小时的话它放在不同的神经元区里，那样调取一定很艰难。所以结论就是如果你真的想要记住什么请在一天之内完成。复习周期绝对不要超过24小时，否则你的这个记忆的生理的效果都不一样。</p><p>原则上我们可以用无穷无尽的能量和时间都烧不开一壶水，</p><p>烧个四五十度你拔掉 凉了再烧，烧了再凉。永远烧不开。</p><p><strong>不断拔掉电源= 无穷时间和能源烧不开一壶水</strong></p><h3 id="8-2-如何记住一堂课的内容"><a href="#8-2-如何记住一堂课的内容" class="headerlink" title="8.2 如何记住一堂课的内容"></a>8.2 如何记住一堂课的内容</h3><ol><li><strong>随时随地，高频回顾</strong></li><li><strong>丰富联想，从上下文到相关知识</strong></li></ol><h3 id="8-3-思考题"><a href="#8-3-思考题" class="headerlink" title="8.3 思考题"></a>8.3 思考题</h3><ol><li>你有没有测试过你自己的遗忘速度？</li><li>你用过什么方法有效巩固自己的记忆？</li></ol><p>你要亲自发现遗忘的残酷性，光知道艾宾浩斯遗忘曲线那还是二手知识，它是第1手的科研资料对吧。可是对于你来说你真正想要把学习这件事情拿下来，真的要成为学霸、学神你必须要建立你第一手的这个切身体验。自己发现出这个事实来。而且这个很容易嘛并没有多大的障碍。</p><h2 id="9-高效提升分数"><a href="#9-高效提升分数" class="headerlink" title="9. 高效提升分数"></a>9. 高效提升分数</h2><p>经历者分享</p><p>“我必须三天内准备好个人材料和笔试考试，一天时间准备好综合面试”。</p><p>首先，拿到了近5年的真题了。她要百分之百掌握。她是这样操作的。</p><ol><li>一些看不懂的真题，短时间内无法理解。就死记硬背下来在纸上默写答案。凡是重要的，确保100%的掌握。</li><li>把这个量拿下来，她说“她曾经刻意练习过的认知能力又回来了（之前练过，怎么去100%把握一个东西，然后坚持下去）”。</li><li>2天时间掌握了整整5道题，都牢牢把握了。然后怀着淡淡的期待和自信去考试。</li></ol><p>这两天究竟发生了，为什么可以从非常焦躁转变到得心应手。</p><p><strong>终极学习法：核心算法</strong></p><p>学会（下）一个</p><p>知道如何学会</p><p>回顾不忘、类推</p><p><strong>进步本</strong></p><p>进步本要复杂一些，稍微复杂一些把这个圈画大了一些。它的原理是一摸一样的。</p><p>总之 你学到了什么东西，学的过程是怎么学到的。你要搞清楚了。无论是题目 还是知识点、文章等等。还是什么思维框架、知识回路、知识地图等等这些。弄清楚之后你就可以以此类推了。只要是能把之前学到的都巩固住，那么越推越快，触类旁通。</p><h3 id="9-1-思考题"><a href="#9-1-思考题" class="headerlink" title="9.1 思考题"></a>9.1 思考题</h3><ol><li>你的学习思维程序是什么？</li><li>如何检验自己的学习思维程序？（参考上面的23天历程，他就是在检验自己的学习思维程序。这么做究竟行不行，能不能拿下来。你最终拿下来之后思维程序究竟是什么。ok，他一旦发现那个东西是有效的。那就可以一直用，他的其他的科目也可以这么去做。按同样的套路去做，然后你心里面就踏实了。只要这么去做就能把它拿下来而且是彻底拿下来）</li></ol><h2 id="10-如何提出好问题"><a href="#10-如何提出好问题" class="headerlink" title="10 如何提出好问题"></a>10 如何提出好问题</h2><p><strong>惠勒提问法</strong></p><p>提出一个好问题，就是高效学习法的一个重要环节；</p><p>那么，如何提出一个好问题来促进自己的学习效能的跨越式提升呢？</p><h3 id="10-1-为什提问是高效学习的利器"><a href="#10-1-为什提问是高效学习的利器" class="headerlink" title="10.1 为什提问是高效学习的利器"></a>10.1 为什提问是高效学习的利器</h3><p>提出一个问题往往比解决一个问题更为重要，解决一个问题也许是一个数学上或实验上的技巧问题。而提出新的问题、新的可能性，从新的角度看旧问题，却需要创造性的想象力，而且标志着科学的真正进步。</p><p>—— 爱因斯坦《物理学的进化》</p><p>问题会让人思维集中、欲罢不能；</p><p><strong><u>解决问题，比如对抗艾宾浩斯遗忘曲线，意味着去巩固这一块的知识点需要不断重复记忆。而重复记忆相当于一个技巧；</u></strong></p><p>而提出问题，比如为什么会存在艾宾浩斯遗忘曲线这种东西。那解决这个问题，可能涉及生物学，人体，神经学等等学科。再解决这个问题的话，所需要的知识维度就远远超过艾宾浩斯遗忘曲线本身了。而此种问题的解决，可能真正的会改变现有的科学认知。</p><h3 id="10-2-什么是好问题"><a href="#10-2-什么是好问题" class="headerlink" title="10.2 什么是好问题"></a>10.2 什么是好问题</h3><ol><li><strong>能找到答案的问题</strong></li><li><strong>一旦得到解答就能扭转局面；</strong></li><li><strong>别人不曾提出，或者不曾给出好答案；</strong></li></ol><ul><li><u>学习是为了什么？</u></li></ul><p><u>进步，否则都是幻想，而且不断受挫，陷入思维混乱和负面情绪；</u></p><ul><li><u>今天进步了多少</u></li></ul><p><u>测量，（进步本里记下了多少知识、改错和弄错的题目），否则是糊涂</u></p><ul><li><u>今天哪里有进步</u></li></ul><p><u>新学的知识点，改错，原本不会弄懂的，否则就是糊涂</u></p><ul><li><u>今天的进步能不能保持住</u></li></ul><p><u>随时随地复习进步本，周期性的重做，检测性质的重做，再标注。每题完毕回顾检测，每科完毕回顾检测，每天完毕回顾检测</u></p><ul><li><u>如何加速进步</u></li></ul><p><u>更多的进步本内容，挑战更难的题目</u></p><ul><li><u>如何检验进步？</u></li></ul><p><u>回顾，做题，大量的测试，模拟考试，查缺补漏，寻找新的进步空间；</u></p><ul><li><u>进步的本质是什么</u></li></ul><p><u>一步一步的，把不可能变成可能；</u></p><ul><li><u>学习的本质是什么</u></li></ul><p><u>基于模仿的大量练习；</u></p><ul><li><u>有没有彻底掌握</u></li></ul><p><u>有，否则，重复上述过程</u></p><ul><li><u>（随时随地问自己）有没有自我欺骗？</u></li></ul><p>没有，否则，一切都是徒劳</p><p>“等你真正理解了问题，你会想出很多复杂的解决方案，因为它的确错综复杂，大多数人止步于此。但有少数人会继续在午夜冥思苦想，最终理解问题背后的深层规律，找出简洁优雅的解决方案，但是，能走到这一步的人太过罕见；”</p><p>—— 乔布斯</p><h3 id="10-3-如何提出好问题"><a href="#10-3-如何提出好问题" class="headerlink" title="10.3 如何提出好问题"></a>10.3 如何提出好问题</h3><ol><li><strong>不断提问</strong></li><li><strong>把你寻找到的答案记录下来</strong></li><li><strong>与别人的答案做比较，迭代改进</strong></li></ol><h3 id="10-3-高效学习的“天问”"><a href="#10-3-高效学习的“天问”" class="headerlink" title="10.3 高效学习的“天问”"></a>10.3 高效学习的“天问”</h3><p><strong>你究竟学到了什么？</strong></p><p>​    如果不如意，那么学习方法一定有问题，寻找方法</p><p><strong>在刚刚过去的5分钟里，你究竟学到了什么？</strong></p><p>​    如果不如意，赶紧回顾；</p><h2 id="11-费曼终极学习法"><a href="#11-费曼终极学习法" class="headerlink" title="11 .费曼终极学习法"></a>11 .费曼终极学习法</h2><p>读一本书，尤其是专业书籍。从头开始读，哪儿卡住了就从头看。再回顾从头复习，一步步向前推进。</p><h3 id="11-1-费曼技巧"><a href="#11-1-费曼技巧" class="headerlink" title="11.1 费曼技巧"></a>11.1 费曼技巧</h3><p>他怎么能够对一件事物产生深度理解的</p><p>分为四步</p><ol><li><u>凡是你想学什么，那你选定一个主题。把相关材料收集下来。</u></li><li><u>基于这个主题和这些材料，学会了。尝试要讲给外行听。严苛条件下，是要给一个孩子都讲懂</u></li><li><u>你会发现鸿沟，就是你跟别人说不清楚。你自己以为理解了一个东西。但是别人听不懂。原因是什么，原因就是你自己并没有真的掌握它。或者说理解的深度还不够。</u></li><li><u>回过头来深入研读那个材料，当你研读完毕之后，再讲给外行听。还可能 讲的过程中你又发现 做不到。你自以为这次可以给，外行讲明白了。结果发现还没想明白。那继续再研读。因为自己还是没掌握嘛。</u></li></ol><p>这个不仅是个学习的过程，更是一个创造性的过程。</p><p>讲过外行听，有几种方式，</p><p>最常见的方式，就是通过语言来说，给别人说通了，说明有超强的沟通能力，演讲能力。演讲能力这个东西， 一篇演说就是一个作品，比如乔布斯要把复杂的手机给普通消费者讲的很清楚明白，尤其是当时那个塞班主宰智能机的年代，他需要多少遍的演练呢。</p><p>另外一种方式，是写成文章，写成书，写成教科书。写成一篇说明性的文字。</p><h3 id="11-2-学习金字塔"><a href="#11-2-学习金字塔" class="headerlink" title="11.2 学习金字塔"></a>11.2 学习金字塔</h3><ul><li><strong>主动学习优于被动学习</strong></li><li><strong>教是最好的学</strong></li><li><strong>教给他人，学习效率90%</strong></li><li><strong>创造作品，效率超过100%</strong></li></ul><p><img src="style.png" alt="image-20210403224928716"></p><h2 id="12-在大脑中形成知识框架"><a href="#12-在大脑中形成知识框架" class="headerlink" title="12. 在大脑中形成知识框架"></a>12. 在大脑中形成知识框架</h2><p>它的核心操作就是在大脑中复现所学的内容，</p><p>所谓复现，就是当你第1次看到一个知识或者一幅图，一段文字的时候。你在大脑中立即是有印象的。</p><ul><li>在大脑中呈现知识为什么重要？</li><li>如何在大脑中呈现知识？</li><li>如何在大脑中实现知识进步？</li></ul><p><strong>把高效学习者分为七个阶段</strong></p><ol><li><u>如何面对“不知道”</u></li><li><u>“做”中学</u></li><li><u>意识到很多问题没有答案；</u></li><li><u>勇猛精进的行动；</u></li><li><u>知识和技能的视觉化</u></li><li><u>把知识解释给孩子听</u></li><li><u>能用一句话归纳</u></li></ol><p>在大脑中复现知识，那是一种极其高级的学习能力、学习方法、学习技巧。也是一个极其高级的学习阶段。</p><p>核潜艇之父</p><p>第一艘核潜艇是如何造出来的；</p><p>“从一无所知，到模型，到实战武器”</p><p>一个关键的转折点是什么？</p><p>就是这些老一代的科学家从六七十年代拿到了一个模型（外国的核潜艇模型），是作为玩具模型买回来的。如获至宝</p><p>为什么？<u><strong>因为这个玩具模型它是可视化的。可视化，它就包含着大量的信息在里头。</strong></u>形态啊，这些都是非常细节的信息的。</p><p>《刻意练习，如何从新手到大师》</p><p>心理表征是专家和高手的特质</p><p>当我们说心理表征是指当我们谈论XX时你心里面浮现的那副画面时，请记住： 画面完全等于心理表征，这个谈论XX，然后浮现出一副画面，以及画面的具体细节这整个呈现方式才是心理表征；</p><p>表征是知识在个体心理的反映和存在方式。按知识的种类及其提取方式，心理学家认为人类至少有四种类型的心理表征：认知地图、心像、图式和心理语言。</p><h3 id="12-1-心理语言"><a href="#12-1-心理语言" class="headerlink" title="12.1 心理语言"></a>12.1 心理语言</h3><p><u>心理语言就是你怎么把这个图像呈现出来的这个过程，你自己的一个描述方式，那叫心理语言。</u></p><p>比如说，<u>我先从哪儿想起。我想起这个东西的时候，它怎么一步一步得变清晰的。每个人都有自己的表达方式，那是心理语言。</u></p><p>我们说到咱们具体如果是应对一场考试，或者在学一个很复杂的知识<strong>。任何复杂的知识，它本身都自成体系，它是高度有序化的。我们觉得混乱，那是我们尚未把知识明晰化的一个过程。</strong></p><p>比如，数学。它有很多分支，有几何，代数还有什么方程，微积分，三角学，函数学等等。每个分支都有很多细节。</p><p>那么 你优先做的是什么呢？</p><p><strong><u>优先做的是从那个分支的核心概念出发，那个核心概念是怎么引出来一系列的子概念。一个核心命题怎么引出来的一系列的子命题。把这个一条线一条线的走清楚，一个局部，比如三角学这个局部。</u></strong>走清楚，那几条主线。（12345 五条主线就出来了）每条主线后面又增加了几个分支啊。这个细节 知识的细节 都悬挂在这个分支上。然后你就一步步形成了所谓的知识框架。</p><h3 id="12-2-知识框架"><a href="#12-2-知识框架" class="headerlink" title="12.2 知识框架"></a>12.2 知识框架</h3><p>知识框架用一个形象的类比来讲，就相当于我们家庭里面的衣架一样。它可以悬挂很多东西，（帽子，围巾，大衣等等）如果没有这个架子，那东西只能乱堆乱放了。</p><p><strong><u>知识框架所发挥的作用就是让你的知识高度有序化，使得你那些零散的知识能够被分门别类的放到大脑里面去，放进去的话。你当时就会觉得没那么混乱，不那么乱，提取的时候呢，就提取性能高 效率高。</u></strong></p><h4 id="12-2-1-知识框架的做法是什么"><a href="#12-2-1-知识框架的做法是什么" class="headerlink" title="12.2.1 知识框架的做法是什么"></a>12.2.1 知识框架的做法是什么</h4><p>第一步，优先参考已经有很好的知识框架。现在我们参考书里面很多。参考数据都已经梳理好了，树状图，概念图等等；那你就照抄。一个部分一个部分捋清楚。哪怕是默写的，也要把它记住</p><p><strong><u>然后在大脑里面，一部分一部分地清晰地去成像。 然后排列组合，最终是形成一个完整的知识结构。如果不去做，那么知识会一直处于一种混乱的状态。</u></strong></p><p>实例：一张很庞大的知识地图呈现在眼前的时候。第一眼看漂亮，很庞大。</p><p>第二眼就晕了，这么多细节 是吧？心烦意乱</p><p>心理得有一个信念，一个大概的估算。对自己能力的一个判断。一次画不出来，那就分100次去画。可能在第49次 就已经能完全能够复现了。重复直到知识在心中清晰化。</p><p><strong><u>在学习一个知识的每个章节的时候，都要去这么梳理。梳理的最终的结果是在大脑中。呈现出这个清晰的知识框架。而不仅仅是在笔记本里面捋清楚了。那等于说是没有把水烧开。不做到百分之百的精准在脑中成相，那几乎都算是半途而废的。等到每个章节都如此做了，后面系统学习就是拼接积木了。</u></strong></p><p><strong><u>最核心的那个几块板，是积木状的拼在一块。拼图装的拼一块的，它要求最简洁最高效的做法就是你每学一个知识章节的时候，就把它做精准了。呈现的清晰，然后不断的去复习巩固它。一个模块一个模块累加下去，后面就呈现出一个极为壮观的知识框架图。</u></strong>它不光光是提高成绩这么简单。你的享受远远超过了你分数成绩的提升。</p><h3 id="12-3-思考题"><a href="#12-3-思考题" class="headerlink" title="12.3 思考题"></a>12.3 思考题</h3><ol><li>你的大脑中有哪些清晰的知识？</li><li>如何让你的知识清晰化？</li><li>你的学习路径清晰吗？</li></ol><h2 id="13-案例加强理解"><a href="#13-案例加强理解" class="headerlink" title="13. 案例加强理解"></a>13. 案例加强理解</h2><p>用案例说明一个知识</p><h3 id="13-1-如何理解一个知识？"><a href="#13-1-如何理解一个知识？" class="headerlink" title="13.1 如何理解一个知识？"></a>13.1 如何理解一个知识？</h3><h3 id="13-2-什么是真知识-假知识？"><a href="#13-2-什么是真知识-假知识？" class="headerlink" title="13.2 什么是真知识/假知识？"></a>13.2 什么是真知识/假知识？</h3><p>普朗克的司机演讲普朗克最新量子物理理论研究的故事；（故事省略）</p><p>世界的知识分为两种：</p><p>一种是“普朗克”知识，它属于那种真正懂的人，他们付出了努力，他们拥有那种能力。</p><p>另外一种是司机知识，他们掌握了鹦鹉学舌的技巧；他们可能有漂亮的头发；他们的声音通常很动听；他们给人留下深刻的印象。但其他他们拥有的是伪装成真实知识的司机知识；</p><p>—— 芒格（南加州大学演讲）</p><p>关于这个故事，还会不会有一些其他的启发；</p><p><strong><u>司机为何如此有自信敢上台讲演高深的量子物理知识；他是如何做到的。这其实也是一个顶级的学习技巧；</u></strong></p><p><u><strong>第一次，可能只记住了其中的某些小片段，某些关键词 题目；其他的内容都模糊不清了。</strong></u></p><p><u><strong>第二次，再有机会陪普朗克去演讲的时候他听的更仔细了；把遗漏的，不太明白的。不断重复 中间重复多少遍我们不知道。</strong></u></p><p><u><strong>一个精深的、刻意的练习才能达到这种鹦鹉学舌的水准。然后我们就不会轻视这个司机知识了，很多人都不具备这个能力。</u></strong></p><p>我们具备哪些司机知识，你具备什么司机知识；往往一反问就把对方问住了。我们也会对这个司机刮目相看，肃然起敬。</p><ol><li>哪怕是具备的所谓“司机”知识，已经很难；</li><li>一万次练习定律</li><li>然后具备真知识</li><li>反复运用一万次练习定律</li></ol><p>另外，这个司机掌握着学习的巨大潜力。觉得这个（演讲）挺好。演讲受大家欢迎，受大家尊重就感觉不错。这满足了极难获得的高度成就感，对于此刻的这位司机学物理学理论就变得非常简单。为什么？</p><p>他可以把鹦鹉学舌的演讲这个过程，原封不动照搬从头开始学起（物理学）</p><p>诀窍：1万次练习定律</p><p><strong><u>所谓1万次练习定律不是精准非要练1万次，就是练很多次数 刻意练习。</u></strong></p><p>有意识的以提高自己的水平为目的的，练习、模仿、校对、标注、标记。在大脑里面复现这个过程。次数达到一定阈值的时候，根据个人的基础不一样，突然某一个点你对那个知识的印象，豁然开朗。所以知识是什么呢？</p><p><strong><u>就是包含了案例和里面的基本概念和基本的命题、基本的结论。</u></strong></p><p>从一个知识点可以衍生出很多知识点，从一个案例可以衍生出很多案例，很多知识出来。</p><p>所以，从普朗克司机这个故事里面能读出很多东西。真知识和假知识，联系到一个人奋斗的一个阶段。怎么去步入更高的极端。</p><p>所以用一个案例精准的去理解一个知识，这个过程可以把它扩展。如果就这个案例你记忆清楚的话，多问几个问题并设身处地的从故事的形象 这个故事在大脑里面呈现的这个清晰的形象。从形象里面一个一个的提问题。然后就引出了各种各样的可能性的解答。而这些解答就会携带出各种各样的知识出来。</p><h3 id="13-3-思考题（作业）"><a href="#13-3-思考题（作业）" class="headerlink" title="13.3 思考题（作业）"></a>13.3 思考题（作业）</h3><ol><li>你能清晰描述的案例有哪些？</li><li>根据这些案例，你还能挖掘出哪些知识？</li></ol><h2 id="14-用题目增进理解"><a href="#14-用题目增进理解" class="headerlink" title="14. 用题目增进理解"></a>14. 用题目增进理解</h2><p>从越少越好到多多益善</p><p>任何领域的高手，他的训练 一定经过两个阶段</p><p><u><strong>第1个阶段是 越少越好</strong></u></p><p><u><strong>第2个阶段是 多多益善</strong></u></p><p>好多年以来的一个核心话题</p><p><strong>题海战术到底是好还是坏？</strong></p><ol><li>为什么有人注重少而精</li><li>为什么有人注重多多益善</li><li>二者矛盾嘛？</li></ol><p>对于顶级高手而言，<strong>两者毫无矛盾。而是分不同阶段的；</strong></p><p>马太效应造就的天才——费曼</p><p>“我记得那是在中学，在第一节课的时候，有个家伙拿着一个几何难题，或者他的高等数学作业里面的什么玩意儿凑过去。我不把这个该死的东西弄出来，我是不会作罢的——这要花费我15到20分钟，</p><p>但是在一天当中，另外这些家伙拿着同样的问题来找我，那我一眨眼就给他做好。而另外五个家伙认为我是个超级天才”</p><p>因此，我得到一个虚名，在上中学的时候，人能知道的每一个难题，都一定会弄到我这儿来。人所发明的每一个该死的、疯狂的难题，我都知道；</p><p>“一开始是他也要 很费劲的把一道难题给解出来，可是后面的你，大家老问他同样的难题”</p><p>所以，天才的背后。意味着同样一道难题，他实际上已经做了6遍了。</p><p>费曼学习法精髓</p><ol><li><strong>凡我不能创造的，我就不能理解；</strong></li><li><strong>解决每一个被解决了的问题；</strong></li></ol><p>他对自己的理解，定了一个极高的标准。一个知识他要重新把它创造出来，这才能说明自己理解了。一个知识从底层逻辑到上层原理都了如指掌，甚至知识产生的逻辑都很清晰。</p><p>解决每一个被解决了的问题，你就把你要学哪个领域？他把哪个阶段所有问题穷尽了。每个问题都解决了，那这显然就是多多益善。但多多益善不是盲目，“每天都在刷题，从头到尾刷。” 不是这样的，<strong><u>他是经过了精益求精把一个知识通透了。然后自然过渡到多多益善。</u></strong></p><p>多多益善为什么是自然过渡呢？</p><p>因为那已经成了乐趣了，刷题的乐趣刷出来了。所以呢，就是好多人那种矛盾的纠结就自然而然解决了是吧？ 少而精呢？</p><p>所以说少而精和多多益善根本就不是一个选择题。</p><p>如果说你想要精通一门知识</p><p>考试要拿极高的分数，那必须经历两个阶段</p><p><strong><u>第一阶段是精做，题目要精做；题目本身你要能背下来。都能记得，就是你可以 在黑板上。不用看草稿，不用看自己的笔记，就展示一道题目。然后这个题目的解法是什么。就能通透到这种程度。</u></strong></p><p><strong><u>第二阶段就变成了乐趣了，在猎奇。看看还有什么样的题目自己没见过的。</u></strong></p><h3 id="14-1-总结"><a href="#14-1-总结" class="headerlink" title="14.1 总结"></a>14.1 总结</h3><p>首先是精做，熟悉它背后的套路。题目的套路，知识的基本逻辑。基本构造，精通了之后那后面就是玩耍。否则呢，绝大多数的情况呢，题海战术，做很多题目。你外表看起来跟那些高手一样是吧。但脑子一塌糊涂，浆糊。心乱如麻。</p><p>达不到那个效果，就为了做了很多题目要做很多题目那是不行的。</p><p>他们是为了 更加丰富的去理解，更加深刻的去认知那些数学原理。</p><p><strong>第一，质永远比量根本</strong></p><p>用了11个小时，才完全掌握了一套数学卷子。</p><p>第一遍，3小时模拟考试</p><p>第二遍，对答案然后改错</p><p>第三遍，从头到尾分析考点，自己解题的障碍，把没有记住的公式或定理，完全弄懂后整理在进步本上。</p><p>第四遍，在A4纸上重做试卷，选择和填空也写出详细解题步骤，并在要求自己的解题步骤和标准答案完全一致，书写工整干净</p><p>全身心投入11小时，才完全掌握一套卷子，但是真正学到知识的满足感和踏实感让我睡了有史以来最踏实的觉</p><p><strong>第二，保住质的前提下，多多益善。</strong></p><h3 id="14-2-思考题"><a href="#14-2-思考题" class="headerlink" title="14.2 思考题"></a>14.2 思考题</h3><ol><li>你的题海里有没有透彻掌握的题目？</li><li>你梳理那掌握的题目有多少？</li></ol><h2 id="15-从知识点到思维之面"><a href="#15-从知识点到思维之面" class="headerlink" title="15. 从知识点到思维之面"></a>15. 从知识点到思维之面</h2><blockquote><p> 大脑中的知识点零散怎么办？终极原因是你的大脑里并没有清晰的知识点</p></blockquote><h3 id="15-1-解决办法"><a href="#15-1-解决办法" class="headerlink" title="15.1 解决办法"></a>15.1 解决办法</h3><p>办法一：</p><ul><li><strong>深入挖掘一个点，挖出整个网络；</strong></li></ul><p>勾股定理现约有500种证明方法，是数学定理中证明方法最多的定理之一。当了解这些定理之后才发现。整个高等数学的知识几乎都被用上啦；</p><ul><li><strong>让知识点在大脑里面高度清晰</strong></li></ul><p>费曼爹教费曼读大英百科全书，有一次念到恐龙。书上说“恐龙身高有25英尺，头有6尺宽”父亲停顿了一下说 让我理解一下这是什么意思/ 这也就是说 要是恐龙展在门前 的院子里，那么它的身高足以使它的脑袋凑着咱们这两层楼的窗户，可它的脑袋却伸不进窗户，因为它比窗户还宽呢。</p><p><strong>他总是把所教的概念变成可触可摸，有实际意义的东西</strong></p><p>费曼从父亲那儿学会了“翻译”——学到的任何东西，我都要琢磨出它们究竟在讲什么，实际意义是什么。</p><p>费曼与欧拉公式</p><p>费曼在笔记上，把欧拉公式从各种角度，各种方法证明了一遍。后面再列举欧拉公式的运用。至此 欧拉公式在费曼眼中再无秘密；他是按写一本书的态度去做笔记的。</p><p>翻来覆去的看，对于二重积分，联合分布，联合概率分布，卷积公式等此类题型会涉及到积分上下限。下限是什么，上限是什么。总是迷糊，老师给的口诀也不是长久之道。</p><p>后来不断琢磨，从他最原始的定义出发，一遍一遍的演绎，在我重复了5遍的时候。终于有那么一刻，一切变得如此之清晰。终于不会再出错了；</p><p>以上得到的结论，他的做法分为两个阶段</p><p>第一阶段要去默写基本概念 基本定义，默写的目的是要牢记，100%精准的把它记住；这样子才能有后面的有效的应用；在默写的过程中增强记忆；</p><p>第二阶段是推导，推导的话就不是机械性的了。而是理解的过程，掌握数学思维的过程。推导多少遍呢，推导过程中反反复复琢磨了5遍以上；</p><p>如果想要在某个学科上，能快速的去学习，快速的推进。取得高分的话。没有第二条路；只能这么去做</p><p>办法二：</p><ul><li><strong>抓住核心概念主导的核心架构</strong></li></ul><p>文科学科的例子，但是对理科学科也是相通的；</p><p>《历史研究》一书提到文明兴衰的规律是 “对内外部威胁的这种应战的成败决定的”；</p><p>还有对有限之物的崇拜！</p><p>你通过一个有限的东西想要去解决那么多错综复杂的问题，还有那么多各种类型的层出不穷的危机、明显做不到嘛。你固守着一个东西做不到的话，那后面就死掉了，所以这个结论非常深刻。</p><p>因此，整本书 虽然很庞大， 但核心架构 如此之简单。你只要把握住了这个核心概念；</p><p>办法三：</p><ul><li><strong>通过模版，构建自己的思维</strong></li></ul><p>《连城诀》，《肖申克的救赎》 与《基督山伯爵 》</p><p>底层逻辑几乎一样；</p><p>越狱，财富，获得财富，获得自由</p><p>是因为有基督山伯爵这个模版的存在。这个 经典著作就成为他们写作的一个思维模版；</p><p>如果我们想让思维清晰，就必须要有这样一个模版。这个模版是什么呢？</p><p><strong><u>这个模版就是课本里面的这个公式定理的推导过程，还有例题，它就给你提供了思维模版。对于文科生而言的话就是它这种叙事的结构，一个概念提出的过程。以及概念应用的过程。</u></strong></p><p>怎么通过事件去说明；所以把一章一节的内容通透了，后面每个章节都在用同样的思维方式在演绎。</p><h3 id="15-2-思考题"><a href="#15-2-思考题" class="headerlink" title="15.2 思考题"></a>15.2 思考题</h3><ol><li>哪些知识点是你明确掌握的</li><li>这些点之间有什么关联？</li><li>你有自己的思维模版吗？</li></ol><h2 id="16-融会贯通，回顾"><a href="#16-融会贯通，回顾" class="headerlink" title="16. 融会贯通，回顾"></a>16. 融会贯通，回顾</h2><p>为什么你的知识零散，而专家可以滔滔不绝</p><p>为什么你学到的知识用不上？而专家可以学以致用</p><p>一个例子：</p><p>他问牛顿，你取得这么大的科学成就，做出了这么多的发现。有何 秘诀</p><p>牛顿曰： 秘诀就是我把问题呈现在大脑里面，持续反复的思考。反反复复的在大脑里面知行合一。</p><p>首先在大脑里面折腾那些知识，那些问题。把知识和问题之间建立链接，深度链接。这些问题有些时抽象的，有些是实用的。</p><p>秘诀很简单，但是做不到，但牛顿能做到，不但是有效果 而且奇效；</p><p>另外一个例子：</p><p>关于考试，从惧怕到期待</p><p>学习的本质就为了进步，为了变强。</p><p>踏踏实实的稳扎稳打地掌握住所学的知识，不断复习它，不断巩固它。把握住他 然后融会贯通。这个过程中对考试就会有所期待了。因为考试是一次检验的机会。它可以帮助自己知道 到底还有哪些地方是薄弱的，然后发现考试是一种非常重要的学习方法。那么甚至后来对考试居然会上瘾。</p><h3 id="16-1-测试效应"><a href="#16-1-测试效应" class="headerlink" title="16.1 测试效应"></a>16.1 测试效应</h3><p>考试测试不仅仅是检测手段，而且是正确的学习方法；</p><p><strong>测试有助于提高参与者的长期记忆力</strong></p><p>一旦想要形成长期的良好效果，光看算法的解题分析是没用的。反复看，就这种动作的效果就比较低了。更好的做法是你读一次之后立即就要做记忆默写这个测试，赶紧考试自己。学习，考证等等 只要你想取得长期的更有效的效果。那么你做完之后，立即要考自己测试自己。看自己能不能独立的推导出来，往往这个时候就卡住了。然后发现不是这里错了，就是那里漏掉了。</p><p>所以，测试不仅起到巩固效应，它对形成长期的记忆也是有帮助的。而且它可以避免假学习。</p><p><strong>如何高效运用测试效应</strong></p><p><u><strong>随时随地复习，随时随地考自己</strong></u></p><p><u><strong>考试不紧张</strong></u></p><p><u><strong>高频、高强度的刺激神经系统，加速神经系统重塑，巩固记忆，加深理解；</u></strong></p><p>测试效应的深层次原因，</p><p>我们说提升记忆，有两个点。第一 提升刺激强度，第二 提升刺激频率。这个测试对应的是 刺激强度；</p><p><strong>学习 = 重塑神经系统 = 重塑生命</strong></p><p><strong><u>学习等于重塑神经系统，等于重塑生命；</u></strong></p><p>巴菲特的投资秘诀</p><ol><li>法则一，别亏钱</li><li>永远不要忘了法则一</li></ol><h3 id="16-2-漏斗效应"><a href="#16-2-漏斗效应" class="headerlink" title="16.2 漏斗效应"></a>16.2 漏斗效应</h3><p>失败发生在每个瞬间，而非结局</p><p><img src="loudou.png" alt="image-20210406102912844"></p><p>为什么执行0%，因为记住的只能20%，他理解不了为什么要去那么做。因为80%的东西都已经忘掉了。</p><p><strong>这个问题结合自己来看，有的时候觉得我自己看这一页书看懂了，其实不然。默写看看，可能最终知道的只有很少一部分。我们不断的背视觉欺骗；</strong></p><p>那么如何遏制漏斗效应？</p><p>答案是<u>“测试效应”</u></p><h3 id="16-3-说不清学了什么"><a href="#16-3-说不清学了什么" class="headerlink" title="16.3 说不清学了什么"></a>16.3 说不清学了什么</h3><p>说不清学到了什么（而非学了什么） = 慢性自杀</p><p>我究竟学了什么（学习的终极问题 高频回顾+高频回测）</p><p>挫败，思维混乱，发现真相  ——》 把握住能把握住的点滴，循序渐进，融会贯通</p><p> 平时用习惯了，看书听讲座听课等等。我一天学了多少个小时。但是不能对学到了什么能够123456这么说，说不清楚自己究竟学到了什么。那就是在慢性自杀。看了一天的书，没学到任何东西。可不就是荒废了时间。</p><p>如何遏制？</p><p><u><strong>那就是把握住自己能把握住的点滴，循序渐进就能融会贯通。</strong></u></p><p><u><strong>把握点滴之间，你还要反反复复去想。把这些点滴凝聚在一起。再去把握新的点滴。聚点滴成江海。</strong></u></p><p><u><strong>那么它的导向的实际操作是一个严酷的操作一定是高频的回顾。高频的运用测试效应。荀子的《劝学篇》就是在讲述这个道理。他背后包含一个非常绝的学习秘诀。</u></strong></p><p>还有一个结论是</p><p><strong>平庸的人追求奇思妙想，至人只是常。（重剑无锋，大巧不工，通盘无妙手）把握命运= 把握一个个能把握住的瞬间</strong></p><h3 id="16-4-思考题"><a href="#16-4-思考题" class="headerlink" title="16.4 思考题"></a>16.4 思考题</h3><p>你在学习过程中领悟到哪些方法、原则可以用来解决人生问题？</p><h2 id="17-触类旁通，完整复现知识"><a href="#17-触类旁通，完整复现知识" class="headerlink" title="17. 触类旁通，完整复现知识"></a>17. 触类旁通，完整复现知识</h2><p>触类旁通的办法，这个办法也很简单。就是完整的复现所学的知识</p><p>触类旁通是有层次的，从举一反一，举一反三，举一反十。。。</p><p>触类旁通是可以训练的，</p><p><strong><u>最好的办法就是一遍又一遍地，试图完整复现所学的知识；</u></strong></p><p>触类旁通究竟要解决什么问题呢？</p><p>就是大家日常学习中每个人，都会遇到的非常令人反感的一种情况。</p><p>“感觉知识太多太庞杂怎么办？”</p><p>“反复呈现所学”</p><p>“想清楚的每个点滴都算数”</p><p><u>那你要一遍一遍的呈现所学的东西，你学了一章，就要呈现一章的东西。学两章，就要反复呈现这两章所学的东西。</u></p><p><u>所谓呈现，是指在大脑中能够清晰的回忆起那一章的知识内容。点点滴滴能通过逻辑串起来。为什么这个排序排下来。</u></p><p><u>那这个这反复呈现也可以简称为复现。一个是重复地在大脑中显现。哪怕不能完整把一章内容复现出来，但是点滴能复现出来也很重要的。因为一切知识都是具有高度的可压缩性的，你掌握了一个知识就等于掌握了成千上万的知识。</u>因为它会在你以后的学习过程中一次又一次地遇到。当然反之，如果你忘掉了一个知识点。那就很残酷了，那就意味着你以后成千上万次地会在那个知识点上面卡壳。这就是说这个知识的高度压缩性。另外一个就是学习的这个套路 可以复制的</p><p>拿数学举例：</p><p>把握核心逻辑</p><p>反复运用</p><p>反复呈现</p><p>在大脑中运算</p><p>自然数的四则运算</p><p>复数的四则运算</p><p>向量的四则运算</p><p>导数的四则运算</p><p>定义 推导 证明 算法 例题</p><p>数学从小学到大学都要说，知识体系很庞杂。但当从大脑中一遍遍复现时，但是它有一些内容是高度相似的，比如上面各种运算。</p><p>然后你还会发现，数学无论是什么章节，它的结构总是要先定义，先提出一个概念。通过一个具体的问题引入。或者通过特定的问题来引入。然后开始推导 证明一系列的命题， 定理。还包括这个算法。然后例题，解题。 它总是这个结构，一摸一样的结构。这是在一遍遍复现数学知识的时候，发现的。同时，这也是把一本书读薄的道理。</p><p>可惜很多人学了好久的数学，都没有发现数学的这种结构的高度的一致 性；</p><p>汤恩比《历史研究》，书虽然很厚。但通盘其实都在阐述两个道理  应战和对客观事物的盲目崇拜</p><p>1.7S就是一个世界</p><p>1.7s是不是人一跳出去之后，就已经决定当时的心态也好。状态也好。就决定了这个动作的质量，还是说1.7S之内，我还来得及调整自己，在前一个翻腾之后不行，我赶紧调整，来的及吗？</p><p>胡佳： 来得及</p><p>主持人： 来得及？</p><p>胡佳： 来得及，假如说我起跳往前顶了，或者往后倒了，那么往前顶了，可能我们就翻得速度就会慢，就是你翻腾的角度就会掉在上面。</p><p>对于运动员来说，1.7s就是一个世界。 时间仿佛凝固了。以至于他可以从容不迫的进行这个调节；</p><p>运动员赛前准备</p><p>他要对这场比赛的所有的情节进行想象，事先要想清楚，想清楚倒什么程度呢？</p><p>他闭着眼睛拿着秒表去掐时间，然后想象，从起点出发，起点的计时器，然后想象划行第一浆 第二浆，遇到水流等等，一直到他感觉到终点了。</p><p>这种虚拟的想象最终和实地的比赛，时间误差能控制在一秒以内。在他大脑里面究竟发生了什么。</p><p>当然这不是说他一下子就能达到的，他平时就在这么训练。而且到比赛的时候对于那个特殊的比赛的赛道。他要进行专门的训练。就一组一组的进行这样的模拟训练。比如第一组，他差很多，可能会差四五秒，三四秒。连续一次两次做了这三次这种模拟。平均会差三四秒。然后休息一段时间之后他再来一组。</p><p>然后我再去想象划行。1234. 到后面他想象的越来越熟练。各种细节想象的越来越逼真。到后面就想差1秒以内</p><p>这种能力和我们平时学习知识的能力，他有高度的相似性，其实统一都是一个能力。只不过是有些人刻意去训练过。而好多人没有这么去练过自己而已。甚至不知道，世界上居然存在这种训练</p><p><strong><u>这种能力，就是呈现，在大脑中复现所学知识的这种能力。</u></strong></p><p><strong>心智之眼</strong>，<u>我们能够在大脑中复现一个场景或者一个知识，一个技能以至于这个生活中的场景的这种能力。这种能力是个人变革的一个关键。这种概念，它是经过严格的科学研究的。</u></p><p>需要刻意练习</p><p>你也可以把第七感想象成一种非常特殊的镜头，透过它，我们能够比以前更清楚地感知自己的心理。</p><p>这是每个人都能拥有的镜头，一旦拥有，我们便能深深地潜入内心的那片海，探索自己以及他人的内心世界。</p><p>作为人类特有的能力，第七感使我们能够密切的、细致的、深入地捡视自己思考、感受和行为的过程，重新塑造、重新定向内在的经验，从而使我们对日常行为拥有更多的选择自由，对未来拥有更大的创造力量，使我们成为自己人生故事的创作者。</p><p>基于神经科学的研究，我们现在已经知道，通过培养第七感的技能，我们能创造心理与情绪的改变，这些改变涉及大脑的物质层面，通过发展将注意力集中在内心世界的能力，我们便拥有了重新塑造神经通路。</p><p>就是说 <strong>比如说我们学一个知识，你一闭眼的时候。你不用刻意去想象 复现。它自然地 你的大脑里就会呈现出那个图形或者那个文字的场景</strong>。 只不过有些人把这个能力他往深处用了一下。比如他读完一页的时候，而不是着急去看下一页，而是在发呆，在回忆那一页，究竟学了什么。当他自己在问自己的过程中。他不自觉的就在大脑里面回顾了那一节的内容。甚至有意识的去复现它，那么如果这样子累计下来的话。他那个复现知识的能力就越强，甚至都变成了一系列的画面。</p><p>每个人对这项训练的深度不同，差别就体现出来了。</p><h3 id="17-1-第七感"><a href="#17-1-第七感" class="headerlink" title="17.1  第七感"></a>17.1  第七感</h3><p>什么是第七感</p><p><strong><u>第七感是发展情商和社交商的重要基础，它是一种专注的注意力。使我们能看到自己的心理活动，它有助于我们感知自己的心理过程，而不会被这些过程侵袭；它使我们能够摆脱深根蒂固的行为以及习惯性的反应，远离可能会陷入其中的被动的情绪循环。它使我们能够正确理解并驯服自己的情绪，不被这些情绪压垮；</u></strong></p><p>当我们心烦意乱的时候，就去用indsight问问自己，那个画面你给呈现出来，你就发现这个发怒是不必要，这中间存在一个误会。</p><p>你和一个人交往不愉快，这个不愉快的原因是什么。好多人不知道原因是什么。就被困在里面了，那如果说你跟这个人的交往过程中，你像一部电影一样在大脑里播放各种情节播放出来之后你就会发现什么原因导致你们之间相处不愉快的。很可能就因为一个小误会，如果你发现了，那么心结不就打开了吗。</p><h3 id="17-2-思考题"><a href="#17-2-思考题" class="headerlink" title="17.2 思考题"></a>17.2 思考题</h3><ol><li>你能从一章的目录想出一章的所有知识点吗？</li><li>你能从一张白纸上，默写出一章的所有知识点吗？</li><li>你重复多少次能做到？</li></ol><h2 id="18-五分钟行动战胜拖延症"><a href="#18-五分钟行动战胜拖延症" class="headerlink" title="18 五分钟行动战胜拖延症"></a>18 五分钟行动战胜拖延症</h2><p>人类就是一个复读机，你只要战胜拖延，5分钟战胜成功了。你就复制这5分钟的过程就可以了。</p><p>拖延的本质是什么？</p><p><strong>恐惧</strong></p><p>恐惧的本质是什么？</p><p><strong>无知</strong></p><h3 id="18-1-微精通"><a href="#18-1-微精通" class="headerlink" title="18.1 微精通"></a>18.1 微精通</h3><p>轻松到不可能放弃的技能学习手册</p><p>我要把它全做了，压力很大。一拖延，半小时过去了。你不要想着这些东西全部做完，12点之前全做完不要想这个事。先去做，先把一道题做完再说。</p><p><strong>学习知识，要将知识打成粉末。</strong></p><p><u>总想一口吃成个胖子，面对一整本书，一整个知识量巨大技术栈。人当然会觉得恐惧，难以完成目标而很难立即行动。当把知识打成粉末之后，很容易去完成某个细节。行动力就没有那么难。另外粉末状的技术栈在后期还能够随意组合。架构成新的技术栈。</u></p><h3 id="18-2-实战"><a href="#18-2-实战" class="headerlink" title="18.2  实战"></a>18.2  实战</h3><p>战胜拖延的方法</p><ul><li><p>只做5分钟；</p></li><li><p>再坚持5分钟；</p></li><li><p>以此类推</p></li><li><p>休息，下一组</p></li></ul><p>学英语</p><ul><li>只背一个句子</li><li>再背一个句子</li><li>回还往复</li><li>休息，下一组</li></ul><p>做题</p><ul><li>弄懂一道题</li><li>再弄懂一道题</li><li>回还往复</li><li>休息，下一组</li></ul><p><strong><u>那如果说一件事情做的方法正确的话，做的质量最终的效果就取决于你究竟投入了多长时间。 你能多5分钟就多5分钟的胜算，就是这么简单。</u></strong></p><p>相比而言对社会竞争的残酷性、选拔性的考试的残酷性。如果方法正确的话你比其他人多了5分钟。真坚持不了就休息一下，尤其学习知识，那么熬时间就没意义了是吧。休息完毕，再来一组。或者休息期间做回顾，能想起来多少想多少。</p><p>这就是战胜拖延的方法，极简的方法就是这个。</p><h3 id="18-3-思考题"><a href="#18-3-思考题" class="headerlink" title="18.3 思考题"></a>18.3 思考题</h3><ol><li>你有过战胜拖延的经历吗</li><li>你能清晰的描述自己战胜拖延的过程吗？</li></ol><h2 id="19-把握住能掌控的点滴"><a href="#19-把握住能掌控的点滴" class="headerlink" title="19. 把握住能掌控的点滴"></a>19. 把握住能掌控的点滴</h2><p><u><strong>应对急躁和焦虑的方法</strong></u></p><p><u>就是把握住自己能把握住的点滴；</u></p><ul><li>焦虑的本质是什么？</li></ul><p>“高三的时候，手上正在做的是每天的知识点。而舆论 大环境给学生带去的是 成绩，好大学，好专业上。这些具体的东西，知识本身思维本身被忽略掉了。然后就造成这种急躁焦虑了。”</p><p><strong><u>急切得到某种抽象而难以得到的东西而不可得，根源是社会文化造就的贪婪（心理歧变）</u></strong></p><p>利用焦虑和紧张</p><p>当你紧张和焦虑的时候，去做一些可控的事情。不要去想那些什么好大学，好的成绩，排名等。这些是当下控制不了的。</p><p>能积微者，速成。 不能积微者，不成 ——荀子《强国》</p><p>皮划艇奥运冠军</p><p>“将比赛全都拆分成很小很小的细节，看自己究竟可以把握住哪些东西，一个个去把握就好了。”</p><h3 id="19-1-思考题"><a href="#19-1-思考题" class="headerlink" title="19.1 思考题"></a>19.1 思考题</h3><ol><li>面对复杂艰难的考试，究竟能把握什么</li><li>如何区分可以把握的和把握不了的</li></ol><h2 id="20-不断复现知识整体"><a href="#20-不断复现知识整体" class="headerlink" title="20. 不断复现知识整体"></a>20. 不断复现知识整体</h2><p>宁静心态： 不断复现知识整体</p><p>烦躁不安怎么办？宁静从哪里来？</p><p><strong><u>极致= 宁静</u></strong></p><p>10.31是我打卡的第一天，我到现在都能够清楚的回忆那一天的状态，特别专注。</p><p>专注到感知不到外部环境，也感受不到身体饥饿·疲惫和困倦，我完全沉浸在手中那份数学卷子里，学到停不下来；</p><p>但是如此专注的条件下，我用了11个小时，别人时间饿三倍，才完全掌握一套数学卷子</p><p>但我还是发了动态，因为只有对自己坦诚，才能真的进步</p><p>也是从这天起，我发现极度专注可以忘记饥饿，另外，饥饿感不会很久，一会儿就过去了，为了节省时间，我每天吃两顿饭，七点吃早饭，下午三四点去吃午饭。</p><p><strong>背后的本质就是一遍又一便地去复现知识的整体，然后后面就达到极致的宁静状态。因为进入到学习本身的思维中去了，而非停留在表面上。</strong></p><p><strong>其实一遍一遍复现知识的过程，大家对一个知识和技能的掌握 已经上了好多个台阶了</strong></p><p><img src="jiu.png" alt="image-20210406170302995"></p><p>具体方法，读完第一章第一节，然后把书合上，来复述一下。复述的过程，你自己给自己录音。</p><p>发现大片的文字没对上。</p><p><strong><u>所以学习的难处在于第一步就是读不懂，读不懂书。不懂的深层那是因为你根本就没看清楚，图表，图形，示意图，流程图没看清楚。文字，定义，概念，基本的定理，命题没看清楚。所以，优先过读懂这一关。</u></strong></p><p>数学的思维模式：</p><p><strong><u>反反复复的去把课本上已有的公式和定理的推导过程和证明过程一遍一遍的去独立推导，去参照 去模仿 去练习。熟练着掌握它的推导和证明过程，你会发现它的典型的逻辑思维的环节很少的。并不那么多也就10个20个。</u></strong></p><p><strong><u>你会发现它们无处不在，反反复复在用。解题过程中反反复复的在用，各个章节的过程中 知识之间都是这些逻辑环节。数学突然对你而言就变得亲切了，不再陌生了。原因就在于你把握住了它的思维模式。</u></strong></p><p>英语的思维模式：</p><p><strong><u>背文章，等到背5篇文章之后，你看了一片文章你都想读出声来。因为觉得熟悉，这里面的句式·句法·篇章和语法 好多语法都在里头了。</u></strong></p><p><strong>限时训练</strong></p><p>王阳明 龙场悟道</p><p>致良知，知行合一，此心光明。那他这个龙场悟道从外在而言的话，就是到了极苦的一个境界。人生极苦的一个境界。什么事情都不顺 命都快没了，吃穿住什么的都很苦。</p><p>那究竟我这么一个人我怎么在这个世界上安身立命呢？我凭借的是什么呢？</p><p>外在和内在都达到了极致，最后是一个宁静了。</p><p>宁静的标志是他所谓龙场悟道时悟到的这些感悟，此心光明，致良知，知行合一</p><p>学习这个事儿一摸一样的道理，</p><p>致良知，就是我们怎么学到一个东西，这个复杂吗？ 记一个单词，学会一个公式，弄懂一道题目复杂吗？不复杂</p><p>只要我们问自己 就能问得出来我们是怎么做到的。然后再致良知我们是不是真的想把这个知识学到手。如果是真的，那就一道题一道题，一个知识点一个知识点依次去重复操作，就好了吗。哪有什么复杂的对吧。致良知，知行合一，你就把学习的问题就解决了。如果这些想通了之后，你就知道了。此心光明。那还有什么可烦躁的，有什么可焦虑的。对吧。</p><p><u><strong>致虚极，守静笃 万物并作 吾以观其复 —— 《道德经》</strong></u></p><p><u><strong>如何宁静，就是虚极，致虚极。就是胡思乱想你把它去掉了就好了。</strong></u></p><p><u><strong>一个单词，一个句子能不能学会。那你就不要管那些什么名次。什么计划啊，什么时间啊都可以抛到脑后了。你就依次去执行这个程序就可以了。这最简单了，乱七八糟的想法你都可以不要了。</u></strong></p><h3 id="20-1-思考题"><a href="#20-1-思考题" class="headerlink" title="20.1 思考题"></a>20.1 思考题</h3><ol><li>你在什么时候感到宁静？</li><li>宁静的过程为什么值得回味？</li></ol><h2 id="21-在现有的条件下做到极致"><a href="#21-在现有的条件下做到极致" class="headerlink" title="21. 在现有的条件下做到极致"></a>21. 在现有的条件下做到极致</h2><p>做成一件事改写人生： 在现有的条件下做到极致</p><p>记者： 您的写作秘诀是什么？</p><p>史蒂芬.金： 一个字一个字写</p><p>威尔史密斯与墙</p><p>小时候，10多岁的时候，他爸爸 让他和弟弟在自家商店门前建一堵墙。他跟他弟弟说我们这么小的年纪，我们怎么可能造好一堵墙呢。</p><p>然后他爸爸说：他爸爸说 你不要想着要去建造世界上最大、最厉害、最宏伟壮观的墙。你不要抱着这种态度开始，你要说我要砌好这块砖，砌得尽可能完美无缺。 </p><p><strong><u>先不管墙， 砖是可以做到的。只要一块一块努力把砖砌的整整齐齐，那么最终会砌好一堵墙的。威尔史密斯就认为这是他一辈子最受用的一个人生经历。</u></strong></p><p><strong><u>学习中最大的障碍就是我们的急躁。千百种的悲剧，之源都是因为我们的思维跳跃。我们现在的能力就这些，总想要去做一些很难的题目。总要拿个 好的名字很高的分数。想入非非是吧。而应该做的是什么呢？</u></strong></p><p><img src="shushi.png" alt="image-20210406175806949"></p><p>就是在你现有的能力范围内 再往前扩展一点，往前推进。所谓的你在学习的舒适区里面 拉伸。拉伸到学习去 变成把自己的舒适区扩大。一步一步把原来的恐慌区，很难处理的那些题目。那些知识给包进来，变成你的舒适区。一步一步地、步步为营地这么去做。那么那些困扰，那些困惑，那些负面的情绪，抑郁，焦虑 。紧张啊，什么烦躁都迎刃而解了。</p><p>整个人生就是一个数学归纳法或者说人生就是加法，就是很简单的加法。比如拿学习这件事而言的话，你知道 怎么学会一个东西的。</p><p>你先学会一个东西这是每个人都实现了这个过程啊。</p><p>然后第2步 你弄明白你究竟怎么学会的；</p><p>第3步你不要把以前学到的东西忘掉了，不要忘记 你频繁回顾他别忘了。然后以此类推 从0-1，从1 到无穷；人生就是这个加法，你考试拿100分就是这个加法。</p><p>努力——&gt;焦虑  ——&gt;抑郁  ——&gt;沉思 ——&gt;认知 ——&gt;幻灭 ——&gt;觉醒 ——&gt;方法 ——&gt;进步 ——&gt;跃迁 </p><h3 id="21-1-思考题"><a href="#21-1-思考题" class="headerlink" title="21.1 思考题"></a>21.1 思考题</h3><ol><li>有哪件事情是你做到极致的？</li><li>人生中哪件事让你感到自豪？</li></ol>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux command</title>
      <link href="2021/03/30/linux-command/"/>
      <url>2021/03/30/linux-command/</url>
      
        <content type="html"><![CDATA[<h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><p>绝对路径： 从根目录开始，指定一个位置、文件</p><p>相对路径： 从当前进程工作目录位置开始，指定一个位置、文件</p><p>shell： 命令解析器，默认运行在终端当中的进程</p><p>bash： born again shell， Linux版的shell</p><h3 id="1-1-Linux目录结构"><a href="#1-1-Linux目录结构" class="headerlink" title="1.1 Linux目录结构"></a>1.1 Linux目录结构</h3><p>/  跟目录，一般根目录下只存放目录；</p><p>/home:  系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下， <del>表示当前用户的家目录，</del>edu表示用户edu的家目录</p><p>/bin: /usr/bin:  可执行的二进制文件的目录，如ls，tar，cat等                </p><p>/boot： 放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器： /boot/grub</p><p>/dev/： 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount  /dev/cdrom/mnt</p><p>/etc： 系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab, /etc/fstab, /etc/init.d, /etc/X11, /etc/sysconfig, /etc/xinetd.d</p><p>/root               系统管理员root的家目录（宿主目录）</p><p>/lib： /usr/lib: /usr/local/lib: 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</p><p>/home/username      普通用户的家</p><p>/etc                配置文件目录</p><p>/sbin               管理命令目录</p><p>/usr 应用程序存放目录，/usr/bin： 存放应用程序， /usr/share： 存放共享函数库文件。/usr/local：存放软件升级包。/usr/share/doc：系统说明文件存放目录，/usr/share/man：程序说明文件存放目录。/usr/include： 存放头文件</p><p>/tmp: 一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下；</p><h3 id="1-2-用户"><a href="#1-2-用户" class="headerlink" title="1.2 用户"></a>1.2 用户</h3><p>Linux是一款多用户多任务的分时复用操作系统</p><p><strong>家目录</strong>：宿主目录。</p><p>​               每个用户不同，cd回车所到的目录。</p><p><strong>普通用户切换至root用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure><h2 id="2-终端的使用"><a href="#2-终端的使用" class="headerlink" title="2. 终端的使用"></a>2. 终端的使用</h2><ul><li><p>图形终端</p></li><li><p>命令行终端</p></li><li><p>远程终端 （SSH、VNC）   // 工作中实际使用最多的， 通过互联网连接远程</p></li></ul><p><strong>切换至字符终端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 3</span><br></pre></td></tr></table></figure><p><strong>万能的帮助命令</strong></p><p>为什么要学习帮助命令</p><ul><li>man帮助</li></ul><ul><li><p>man是manual的缩写，</p></li><li><p>用法</p><p><strong>man ls</strong></p></li></ul><p>man 也是一条命令,分为9章，可以使用man命令获得man的帮助</p><p> <strong>man 7 man</strong></p><p> <strong>man [number] man  第几章</strong></p><p>help帮助</p><p>shell（命令解释器） 自带的命令称为内部命令，其他的是外部命令</p><ul><li>内部命令使用help帮助</li></ul><p>help cd</p><ul><li>外部命令使用help帮助</li></ul><p>ls –help</p><ul><li>info帮助</li></ul><ul><li>info帮助比help更详细，作为help的补充</li></ul><p>info ls</p><ul><li>使用网络资源（搜索引擎和官方文档）</li></ul><p>Linux 的基本操作方式是命令行</p><p>海量的命令不适合“死记硬背”</p><p>分屏读取：more， less， cat， tac</p><h2 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h2><p>linux - 一切皆文件</p><ol><li><p>文件查看</p></li><li><p>目录文件的创建与删除</p></li><li><p>通配符</p></li><li><p>文件操作</p></li><li><p>文本内容查看</p></li></ol><ul><li><p>pwd 显示当前的目录名称</p></li><li><p>cd 更改当前的操作目录</p></li></ul><p>  cd  /path/to/…      绝对路径</p><p>  cd ./path/to/…     相对路径</p><p>  cd ../path/to/…   相对路径</p><ul><li>ls  查看当前目录下的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项，选项... ] 参数...</span><br></pre></td></tr></table></figure><ul><li>常用参数：</li></ul><p>  -l 长格式显示文件</p><p>  -a 显示隐藏文件</p><p>  -r 逆序显示</p><p>  -t 按照时间顺序显示</p><p>  -R 递归显示</p><h3 id="3-0-chmod修改用户访问权限"><a href="#3-0-chmod修改用户访问权限" class="headerlink" title="3.0 chmod修改用户访问权限"></a>3.0 chmod修改用户访问权限</h3><p>chmod 修改文件权限有两种使用格式： 字母法和数字法</p><p>常用的是数字法</p><h3 id="3-1-文件的增删"><a href="#3-1-文件的增删" class="headerlink" title="3.1 文件的增删"></a>3.1 <strong>文件的增删</strong></h3><p>创建 mkdir </p><p>创建文件 touch</p><p><code>mkdir -p app/a/b/c</code> 创建递归目录</p><p><code>ls -R</code>  查看目录层级</p><p>*<em>删除 *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r [文件名1] [文件名2]</span><br></pre></td></tr></table></figure><p>rm 删除文件无法恢复；</p><p>*<em>复制 *</em></p><p><code>cp -r  /root/a  /tmp</code>   tmp在系统中是临时目录的意思</p><p>cp -v</p><p>cp -p</p><p>cp -a</p><p>移动</p><p><code>mv /file/a /file/b</code> 改名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;file&#x2F;a &#x2F;tmp</span><br></pre></td></tr></table></figure><p>通配符 * ： 表示该文件夹下所有文件</p><p><strong>复制文本/粘贴文本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+shift+c</span><br><span class="line">ctrl+shift+v</span><br></pre></td></tr></table></figure><p><strong>复制文件夹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r dir1 dir2</span><br></pre></td></tr></table></figure><p><strong>看函数源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 光标停在函数名上，</span><br><span class="line"></span><br><span class="line">2. esc退出编辑模式；</span><br><span class="line"></span><br><span class="line">3. shift+k 可以直接跳转到 man 手册</span><br></pre></td></tr></table></figure><h3 id="3-2-文本查看"><a href="#3-2-文本查看" class="headerlink" title="3.2 文本查看"></a>3.2 <strong>文本查看</strong></h3><p>cat 文本内容显示到终端</p><p>head 查看文件开头</p><p>tail 查看文件结尾</p><ul><li>常用参数 -f 文件内容更新后，显示信息同步更新</li></ul><p>wc 统计文件内容信息</p><h3 id="3-3-重定向"><a href="#3-3-重定向" class="headerlink" title="3.3 重定向"></a>3.3 重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   重定向到指定文件，文件不存在自动创建</span><br><span class="line">&gt;&gt;  将内容追加到指定文件，文件不存在自动创建，存在不覆盖</span><br></pre></td></tr></table></figure><h3 id="3-4-建立链接文件"><a href="#3-4-建立链接文件" class="headerlink" title="3.4 建立链接文件"></a>3.4 建立链接文件</h3><p><code>ln</code></p><p>linux链接文件类似于Windows下的快捷方式</p><p>链接文件分为软链接和硬链接</p><p><strong>软链接</strong>： <code>ln 源文件 连接文件</code>软链接不占用磁盘空间，源文件删除则软链接链接失效 (等同于windows下的快捷方式，建议使用 绝对路径创建软链接)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ls -s /home/xxx/file1 file.soft</span><br><span class="line">$&gt; ls</span><br><span class="line">file.soft -&gt; /home/xxx/file1</span><br></pre></td></tr></table></figure><p><strong>硬链接</strong>： <code>ln -s 源文件 链接文件</code>硬链接只能链接普通文件，不能链接目录</p><p>如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的磁盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。</p><p>注意：如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径</p><h3 id="3-5-管道"><a href="#3-5-管道" class="headerlink" title="3.5 管道"></a>3.5 管道</h3><p><code>left|right</code></p><p>管道的作用： 将管道符｜左边命令的输出传给后边的命令做为输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps  -aux | grep init</span><br><span class="line"><span class="comment"># ps 列出所有进程</span></span><br><span class="line"><span class="comment"># grep 过滤init进程</span></span><br></pre></td></tr></table></figure><p><strong>linux 备份压缩</strong></p><p>最早的linux介质是磁带，使用的命令是 tar</p><p>可以打包后的磁带文件进行压缩缓存，压缩的命令是gzip 和 bzip2</p><p>经常使用的拓展名 .tar.gz .tar.bz2 .tgz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar cf  &#x2F;tmp&#x2F;etc-backup.tar  &#x2F;etc</span><br></pre></td></tr></table></figure><h2 id="4-进程管理"><a href="#4-进程管理" class="headerlink" title="4. 进程管理"></a>4. <strong>进程管理</strong></h2><blockquote><p><em>运行中的程序程序正在运行的过程，管理程序什么时候启动，整个生命周期需要多少资源。内存资源， 运行时需要多少cpu资源，程序运行完之后把程序结束掉。还有进程之间的通讯。</em></p></blockquote><p>进程终止的方式并不唯一，分为正常终止和异常终止</p><ul><li><p>正常终止也分为main返回、调用exit等方式</p></li><li><p>异常终止分为调用abort、接受信号等</p></li></ul><ul><li>进程的概念与进程查看</li></ul><p>  查看命令</p><ul><li><p>ps</p><p><code>ps</code></p></li></ul><p>  PID      TTY    TIME        CMD</p><p>  11931    pts/1   00:11.02   su</p><p>  PID: 进程ID，唯一标识符</p><p>  CMD： 进程名称</p><p>  TTY： 当前执行程序的终端 （pts/1 虚拟终端）</p><p>  TIME： 不具备参考价值的进程时间</p><p>  pstree</p><p>  top</p><p>  结论：</p><p>​    - 进程也是树形结构</p><p>​    - 进程和权限有着密不可分的关系</p><ul><li><p>进程的控制命令</p></li><li><p>进程的通信方式 - 信号</p></li><li><p>守护进程和系统日志</p></li><li><p>服务管理工具 systemctl</p></li><li><p>SELinux简介</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps axj *<span class="comment"># 查看精确到进程信息*</span></span><br><span class="line"></span><br><span class="line">ps axm *<span class="comment"># 能查看精确到线程信息*</span></span><br><span class="line"></span><br><span class="line">ps ax -L *<span class="comment"># 以linux的方式来查看进程和线程的关系*</span></span><br></pre></td></tr></table></figure><p><strong>查看机器 TCP， udp链接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anu</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant</span><br></pre></td></tr></table></figure><p><strong>使用本机的 提供的客户端</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc ip port</span><br></pre></td></tr></table></figure><p><strong>打开一张图片</strong></p><p>eog xy.png # 打开一张图片</p><h2 id="5-os"><a href="#5-os" class="headerlink" title="5 os"></a>5 os</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free -m  <span class="comment">#内存</span></span><br><span class="line">df -h     </span><br><span class="line">cat /proc/cpuinfo <span class="comment">#cpu</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>net</title>
      <link href="2021/03/28/net/"/>
      <url>2021/03/28/net/</url>
      
        <content type="html"><![CDATA[<p><strong>网关</strong></p><ul><li><p>对于局域网来说，上网需要路由器，路由器可以被称为网关。</p></li><li><p>网关还能承载DNS服务器的作用。</p></li></ul><h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h2><blockquote><p><em><code>**Open System Interconnection**</code>**适用于所有的网络</em></p></blockquote><ul><li><p>分工带来效能</p></li><li><p>将复杂的流程分解为几个功能相对单一的子进程</p></li><li><p>整个流程更加清晰，复杂问题简单化</p></li><li><p>更容易发现问题并针对性的解决问题</p><ul><li><p>应用层(Application) 提供业务处理的，比如网络与用户应用软件之间的接口服务(HTTP)</p></li><li><p>表示层(Presentation) 内容是什么格式（英文还是中文，还是二进制等等）表示的，这一层提供格式化的表示和转换数据服务，如加密和压缩()</p></li><li><p>会话层(Session)保持会话， 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制()</p></li><li><p>传输层(Transimission) 提供建立、维护和取消传输连接功能，负责可靠地传输数据(TCP)</p></li><li><p>网络层(Network) 处理网络间路由，确保数据及时传送(路由器)</p></li><li><p>数据链路层(DataLink) 负责无错传输数据，确认帧、发错重传等(交换机)</p></li><li><p>物理层(Physics) 提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)</p></li></ul></li></ul><p>解析：</p><ol><li><p>拿张稿纸写封信 （应用层，表示层，会话层先合并为一层， 写信整体对应的是应用层，里面放的业务数据） </p></li><li><p>把信装到信封里面，写上收件人，收件人地址（地址分为两部分，第一部分，省市区地址和楼盘门牌号。第二部分是房间号） 然后给邮局，一般邮局不会只打包一封信，而是把一些相同目的地的信封打包成包裹，然后写上目标地址（这个打包的过程对应的是传输层）</p></li><li><p>邮局送信，先找到具体楼盘以及门牌号。邮局（寻址，这里对应的是网络层）知道目的地了，开始选择道路（铁路或者公路或者飞行）。</p></li><li><p>确定位置和运输方式之后，开始传输，到达目的地之后。把数据包给到收件人，收件人拆开数据包。拿到信（数据）（这个层是数据链路层和物理层负责，物理层负责实际的物理传输，就010101的传信号），万一途中把包裹丢失了怎么办，以及其他意外的处理，比如包裹的包装是否被拆过。都需要校验。（这个是数据链路层负责的事情 ）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下层是为上层提供服务的</span><br></pre></td></tr></table></figure><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><strong>物理层</strong></h3><blockquote><p><em>建立，维护，断开物理连接</em></p></blockquote><p> 数据最终还是需要物理层的硬件传输，这些硬件只能传输010101.这些01010 在网络中怎么去表示呢。不同的介质表现方式是不一样的。</p><ol><li>高电频和低电频表示，5V 和 0V分别表示 1 和 0；</li></ol><h3 id="1-1-数据链路层"><a href="#1-1-数据链路层" class="headerlink" title="1.1 数据链路层"></a>1.1 <strong>数据链路层</strong></h3><blockquote><p><em>建立逻辑连接，进行硬件地址寻址·差错校验等功能。</em></p></blockquote><p> 比如两个网卡，这两张网卡如何建立连接，如何通信。通信过程中出问题了如何解决。发送过程中丢包要重新传。链路层依赖物理层，（下层是为上层提供服务的，上层会把数据传给下层，让下层帮忙提供服务）</p><h3 id="1-2-网络层"><a href="#1-2-网络层" class="headerlink" title="1.2 网络层"></a>1.2 <strong>网络层</strong></h3><blockquote><p><em>进行逻辑地址寻址，实现不同网络之间的路径选择</em></p></blockquote><p>从一个端到另一个端，肯定不止一条路。而是有无数条路。那要如何找到最快的路呢。这个是网络层负责的</p><h3 id="1-3-传输层"><a href="#1-3-传输层" class="headerlink" title="1.3 传输层"></a>1.3 <strong>传输层</strong></h3><blockquote><p><em>定义传输数据的协议端口号，以及流控和差错校验（在不可靠的路线上做可靠的事情）</em></p></blockquote><p>从一个端向另外一个端发送数据包的时候，如何做到中间丢包了，发送端能够感知到。一般操作方式是，当发送端发送包之后，开一个定时器。一般发送一个数据包，会有一个经验的时间。比如A到B之间传数据包要2秒，那么这个定时器2秒之后还没回来，我就默认这个包丢了。那就重新传一份。直到接受端返回正确的回馈。</p><h3 id="1-4-应用层表示层会话层"><a href="#1-4-应用层表示层会话层" class="headerlink" title="1.4 应用层表示层会话层"></a>1.4 <strong>应用层表示层会话层</strong></h3><blockquote><p><em>应用层，表示层，会话层一般会打包到一层，就是实际的数据，比如发送的是文本，图片还是网页等这些东西。下层帮上层提供服务，上层给下层下发命令。下层帮忙处理。</em></p></blockquote><h3 id="1-5-分层模型"><a href="#1-5-分层模型" class="headerlink" title="1.5 分层模型"></a><strong>1.5 分层模型</strong></h3><p><img src="osi.png" alt=""></p><h3 id="1-6-封装过程"><a href="#1-6-封装过程" class="headerlink" title="1.6 封装过程"></a><strong>1.6 封装过程</strong></h3><p><img src="18.send.png" alt=""></p><p><img src="19.receive.png" alt=""></p><ul><li>数据在不同层的称谓</li></ul><ol><li><p>数据帧（Frame） 是一种信息单位，它的起点和目的点都是数据链路层</p></li><li><p>数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层</p></li><li><p>段（Segment）： 通常是指起始点和目的地都是传输层的信息单元</p></li><li><p>消息（message）： 是指起始点和目的地都在网络层以上（经常在应用层）的信息单元</p></li></ol><p>不同的层解自己的封装的数据（段，数据包，数据帧等等）</p><h2 id="2-TCP-IP参考模型"><a href="#2-TCP-IP参考模型" class="headerlink" title="2. TCP/IP参考模型"></a><strong>2. TCP/IP参考模型</strong></h2><p>TCP/IP是传输控制协议/网络互联协议的简称</p><p>早期的TCP/IP模型是一个四层结构，从下往上依次是网络接口层、互联网层、传输层和应用层</p><p>后来在使用过程中，借鉴OSI七层参考模型，将网络接口层划分为了物理层和数据链路层，形成五层结构</p><p><img src="tcpip.png" alt=""></p><ul><li>5层对应7层</li></ul><ol><li><p>应用层对应 （应用层，表示层和会话层）</p></li><li><p>传输层对应传输层</p></li><li><p>网络层对应网络层</p></li><li><p>数据链路层对应数据链路层</p></li><li><p>物理层对应物理层</p></li></ol><h3 id="2-1-协议的概念和作用"><a href="#2-1-协议的概念和作用" class="headerlink" title="2.1 协议的概念和作用"></a><strong>2.1 协议的概念和作用</strong></h3><blockquote><p><em>协议的目的为了让计算机能够通信，计算机需要定义通信规则，这些规则就是协议，信息双方都要理解，而且信息能够传输。</em></p></blockquote><p>规则是多种，协议也有多种</p><p>协议就是<code>数据封装格式+传输 的结合</code></p><h3 id="2-2-常用协议"><a href="#2-2-常用协议" class="headerlink" title="2.2 常用协议"></a><strong>2.2 常用协议</strong></h3><p>TCP/IP协议被称为传输控制协议/互联网协议，又称网络通讯协议</p><p>是由网络层的IP协议和传输层的TCP协议组成，是一个很大的协议集合</p><p>物理层和数据链路层没有定义任何特定协议，支持所有的标准和专用的协议</p><p><img src="protocal.png" alt=""></p><table><thead><tr><th>层级</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP</td><td>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议</td></tr><tr><td>应用层</td><td>FTP</td><td>文件传输协议（英文：File Transfer Protocol，缩写：FTP）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式</td></tr><tr><td>应用层</td><td>TFTP</td><td>(Trivial File Transfer Protocol,简单文件传输协议)是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议</td></tr><tr><td>应用层</td><td>SMTP</td><td>简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP) 是在Internet传输Email的事实标准</td></tr><tr><td>应用层</td><td>SNMP</td><td>简单网络管理协议（SNMP，Simple Network Management Protocol），由一组网络管理的标准组成，包含一个应用层协议（application layer protocol）、数据库模型（database schema）和一组资源对象,该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</td></tr><tr><td>应用层</td><td>DNS</td><td>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</td></tr><tr><td></td><td>TCP</td><td>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议</td></tr><tr><td>传输层</td><td>UDP</td><td>UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</td></tr><tr><td>传输层</td><td>ICMP</td><td>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息</td></tr><tr><td>网络层</td><td>IGMP</td><td>Internet 组管理协议称为IGMP协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间</td></tr><tr><td>网络层</td><td>IP</td><td>互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为IP地址（英语：IP Address），是分配给用户上网使用的网际协议（英语：Internet Protocol, IP）的设备的数字标签</td></tr><tr><td>网络层</td><td>ARP</td><td>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议</td></tr><tr><td>网络层</td><td>RARP</td><td>反向地址转换协议（RARP：Reverse Address Resolution Protocol） 反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址</td></tr></tbody></table><h2 id="以下具体讲5层协议"><a href="#以下具体讲5层协议" class="headerlink" title="以下具体讲5层协议"></a><strong>以下具体讲5层协议</strong></h2><h2 id="3-网络接口层"><a href="#3-网络接口层" class="headerlink" title="3. 网络接口层"></a><strong>3. 网络接口层</strong></h2><p>网络接口层是TCP/IP模型的最底层，负责接收从上一层交来的数据报并将数据报通过底层的物理网络发送出去，比较常见的就是设备的驱动程序，此层没有特定的协议</p><p>网络接口层又分为物理层和数据链路层</p><h3 id="3-1-物理层"><a href="#3-1-物理层" class="headerlink" title="3.1 物理层"></a><strong>3.1 物理层</strong></h3><p>计算机在传递数据的时候传递的都是0和1的数字，而物理层关心的是用什么信号来表示0和1，是否可以双向通信，最初的连接如何建立以及完成连接如何终止,物理层是为数据传输提供可靠的环境</p><p>尽可能的屏蔽掉物理设备和传输媒介，使数据链路层不考虑这些差异，只考虑本层的协议和服务</p><p>为用户提供在一条物理传输媒体上提供传送和接收比特流的能力</p><p>需要解决物理连接、维护和释放的问题</p><p><img src="2.phisical.png" alt=""></p><h3 id="3-1-1-数字信号的编码"><a href="#3-1-1-数字信号的编码" class="headerlink" title="3.1.1 数字信号的编码"></a><strong>3.1.1 数字信号的编码</strong></h3><p>数字信号的编码：用何种物理信号来表示0和1</p><h4 id="3-1-1-1-非归零编码"><a href="#3-1-1-1-非归零编码" class="headerlink" title="3.1.1.1 非归零编码"></a><strong>3.1.1.1 非归零编码</strong></h4><p><img src="1.phisical.png" alt=""></p><blockquote><p><em>缺点就是连音没法处理，是多个1 还是一个1的问题；所以需要告诉多长时间是个间隔呢。不然没法判断是几个1</em></p></blockquote><p>优点： 编/译码简单。</p><p>缺点： 内部不含时钟信号， 收/发端同步困难。</p><p>用途： 计算机内部， 或低速数据通信。</p><h4 id="3-1-1-2-曼彻斯特编码"><a href="#3-1-1-2-曼彻斯特编码" class="headerlink" title="3.1.1.2 曼彻斯特编码"></a><strong>3.1.1.2 曼彻斯特编码</strong></h4><p><img src="man.png" alt=""></p><blockquote><p><em>附加一个从低到高或者从高到低的频率</em></p></blockquote><p>优点：</p><p>内部自含时钟， 收/发端同步容易。</p><p>抗干扰能力强。</p><p>缺点：</p><p>编/译码较复杂。</p><p>占用更多的信道带宽， 在同样的波特率的情况下， 要比非归零编码多占用一倍信道带宽。</p><p>用途： 802.3局域网（以太网）使用场景更多</p><h3 id="3-2-数据链路层"><a href="#3-2-数据链路层" class="headerlink" title="3.2 数据链路层"></a><strong>3.2 数据链路层</strong></h3><p>数据链路层是OSI参考模型中的第二层，介乎于物理层和网络层之间</p><p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层</p><p>如何将数据组合成数据块，在数据链路层中称这种数据块为帧frame，帧是数据链路层的传送单位</p><p>如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配</p><p>以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理</p><h3 id="3-2-1-以太网"><a href="#3-2-1-以太网" class="headerlink" title="3.2.1 以太网"></a><strong>3.2.1 以太网</strong></h3><p>以太网（Ethernet）是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容</p><p>以太网的标准拓扑结构为总线型拓扑</p><p>以太网仍然使用总线型拓扑和CSMA/CD（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术</p><p>以太网实现了网络上无线电系统多个节点发送信息的想法，每个节点必须获取电缆或者信道的才能传送信息</p><p>每一个节点有全球唯一的48位地址也就是制造商分配给网卡的MAC地址，以保证以太网上所有节点能互相鉴别</p><h4 id="3-2-2-总线型拓扑（只用到了物理层和数据链路层）"><a href="#3-2-2-总线型拓扑（只用到了物理层和数据链路层）" class="headerlink" title="3.2.2 总线型拓扑（只用到了物理层和数据链路层）"></a><strong>3.2.2 总线型拓扑（只用到了物理层和数据链路层）</strong></h4><ul><li>网络总线，每个电脑都可以接受消息，发送消息。</li></ul><p>总线型拓扑是采用单根传输作为共用的传输介质,将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上</p><p>使用总线型拓扑结构需解决的是确保端用户使用媒体发送数据时不能出现冲突。</p><p>总线型网络采用载波监听多路访问/冲突检测协议（CSMA/CD)作为控制策略</p><p>（CSMA/CD指的是，每个电脑得监听其他电脑的状态，大家不能同时往网络总线上发消息）</p><p><img src="totalline.png" alt=""></p><h4 id="3-2-2-1-载波监听多路访问"><a href="#3-2-2-1-载波监听多路访问" class="headerlink" title="3.2.2.1 载波监听多路访问"></a><strong>3.2.2.1 载波监听多路访问</strong></h4><p>全称Carrier Sense Multiple Access (CSMA)，是一种允许多个设备在同一信道发送信号的协议，其中的设备监听其它设备是否忙碌，只有在线路空闲时才发送</p><p>在此种访问方式下，网络中的所有用户共享传输介质，信息通过广播传送到所有端口，网络中的工作站对接收到的信息进行确认，若是发给自己的便接收否则不理</p><p>从发送端情况看，当一个工作站有数据要发送时，他首先监听信道并检测网络上是否有其他的工作站正在发送DATA，如果检测到信道忙，工作站将继续WAIT若发现信道空闲，则开始发送数据，信息发送出去后，发送端还要继续对发送出去的信息进行确认，以了解接收端是否已经正确接收到数据，如果收到则发送结束，否则再次发送</p><ul><li>核心思想</li></ul><p>先听后讲 信道空闲则发送，信道忙则等待。</p><p>边听边讲 发送信号时不断检测信道是否碰撞。（发信号时即时检测）</p><p>碰撞即停 （因为网线是单向的，传输过程中发现别人也在往反方向发，那么赶紧停止发送）</p><p>退避重传 二进制指数退避重传</p><p>多次碰撞，放弃发送,最多16次 （下面这个计算退避等待时间的算法，1，2，4，8.。。64） 如果64秒还没发出去，那么就不发了。</p><h4 id="3-2-2-2-冲突检测"><a href="#3-2-2-2-冲突检测" class="headerlink" title="3.2.2.2 冲突检测"></a><strong>3.2.2.2 冲突检测</strong></h4><p>冲突检测即发送站点在发送数据时要边发送边监听信道，若监听到信道有干扰信号，则表示产生了冲突，于是就要停止发送数据，计算出退避等待时间，然后使用CSMA方法继续尝试发送</p><p>计算退避等待时间采用的是二进制指数退避算法 （发消息的时候，检测别的电脑是否也在发，如果有就等1秒，1秒后继续校验，如果阻塞继续等2秒，后面依次类推 等 2的次方倍）</p><h4 id="3-2-2-3-总线拓扑的缺点"><a href="#3-2-2-3-总线拓扑的缺点" class="headerlink" title="3.2.2.3 总线拓扑的缺点"></a><strong>3.2.2.3 总线拓扑的缺点</strong></h4><ol><li>不安全，发送出去的包连接总线的所有电脑都能劫持到。本来不该他收的信息他也可以收。</li></ol><h4 id="3-2-2-4-交换机"><a href="#3-2-2-4-交换机" class="headerlink" title="3.2.2.4 交换机"></a><strong>3.2.2.4 交换机</strong></h4><blockquote><p><em>后来出现了交换机，交换机是一个二层的设备，在物理链路层上工作。比如A电脑发送消息给B电脑，直接连接交换机即可。就不同通知同样连接交换机的C电脑</em></p></blockquote><p><img src="jiaohuanji.png" alt=""></p><ul><li>交换机和路由器的区别</li></ul><ol><li><p>首先交换机是一个数据链路层的设备，只是传输数据包。数据包里面肯定有原地址和目标地址（比如A电脑 -&gt; B电脑）这个地址就是 MAC地址。</p></li><li><p>路由处理ip地址，主要作用是网络层的寻址</p></li></ol><h3 id="3-2-3-MAC地址"><a href="#3-2-3-MAC地址" class="headerlink" title="3.2.3 MAC地址"></a><strong>3.2.3 MAC地址</strong></h3><blockquote><p><em>在通信过程中是用内置在网卡内的地址来标识计算机身份的</em></p></blockquote><p>每个网卡都有一个全球唯一的地址来标识自己，不会重复(保证局域网之内不重复就行了)。MAC地址48位的二进制组成，通常分为6段，用16进制表示</p><p><img src="8.mac.png" alt=""></p><h3 id="3-2-4-以太网帧格式"><a href="#3-2-4-以太网帧格式" class="headerlink" title="3.2.4 以太网帧格式"></a><strong>3.2.4 以太网帧格式</strong></h3><ul><li><p>在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。</p></li><li><p>后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址</p></li><li><p>帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议)</p></li><li><p>以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏</p></li></ul><p><img src="802.3frame.png" alt=""></p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">前导符(Preamble)</td><td align="left">由1和0交互构成(10101010…..)，共占7个字节，用于使PLS子层电路与收到的帧达成时钟同步</td></tr><tr><td align="left">帧起始(Start-of-Frame Delimiter, SFD)</td><td align="left">为10101011，共占1个字节，表示一个帧的开始。它和前导符共同使接收方能根据1、0交替来迅速实现比特同步，当检测到连续的两位1时，将后续信息交给MAC子层。通常来说，Pre和SFD这两个字段只用于提醒接收端新帧到达，并不计入MAC帧大小，也不算作是MAC帧头的组成部分</td></tr><tr><td align="left">目的MAC(Destination Address, DA)/源MAC(Source Address, SA)</td><td align="left">分别用于标识目的MAC地址和源MAC地址，两个字段各占6个字节。它们可以是单播地址也可以是广播地址。当地址的最高位为0时表示单播，最高位为1时为组播，全为1时为广播</td></tr><tr><td align="left">长度(Length)/类型(Type)</td><td align="left">这是一个二选一的字段，共占2个字节，对于不同的网络协议，它有不同的含义。但是，作为类型使用时，如上表所示，最小值也总是大于1536（十六进制0x600）；所以不会产生冲突。另外，在IEEE 802.3中，数据字段的长度为38~1500个字节</td></tr><tr><td align="left">数据(Data)</td><td align="left">该字段对于不同的以太网帧包含的内容不一，对于较老的以太网标准，它是网络层来的数据报；而较新的标准，则是一个LLC帧的全部内容</td></tr><tr><td align="left">帧校验序列(FCS)</td><td align="left">它是一个包含32位CRC校验值的字段，一共占4个字节。由发送端对MAC帧的DA字段到Data字段间（不包含前导符和帧起始）的二进制序列进行计算</td></tr></tbody></table><h3 id="3-2-5-ARP协议"><a href="#3-2-5-ARP协议" class="headerlink" title="3.2.5 ARP协议"></a><strong>3.2.5 ARP协议</strong></h3><ul><li><p>地址解析协议，即ARP（Address Resolution Protocol），<code>是根据IP地址获取物理地址(MAC地址)的一个TCP/IP协议</code></p></li><li><p>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源</p></li><li><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存</p></li><li><p>由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗</p></li></ul><h4 id="3-2-5-1-ARP协议报文"><a href="#3-2-5-1-ARP协议报文" class="headerlink" title="3.2.5.1 ARP协议报文"></a><strong>3.2.5.1 ARP协议报文</strong></h4><p><img src="arppackage.jpg" alt=""></p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">硬件类型</td><td align="left">表示硬件地址的类型，值为1表示以太网地址</td></tr><tr><td align="left">协议类型</td><td align="left">表示要映射的协议地址类型。它的值为0x0800表示IP地址类型</td></tr><tr><td align="left">硬件地址长度和协议长度</td><td align="left">以字节为单位，对于以太网上的IP地址的ARP请求或应答来说，他们的值分别为6和4</td></tr><tr><td align="left">操作类型</td><td align="left">用来表示这个报文的类型，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4</td></tr><tr><td align="left">发送端MAC地址</td><td align="left">发送方设备的硬件地址</td></tr><tr><td align="left">发送端IP地址</td><td align="left">发送方设备的IP地址</td></tr><tr><td align="left">目标MAC地址</td><td align="left">接收方设备的硬件地址</td></tr><tr><td align="left">目标IP地址</td><td align="left">接收方设备的IP地址</td></tr></tbody></table><p><img src="arpwireshark.png" alt=""></p><h4 id="3-2-5-2-ARP地址解析过程"><a href="#3-2-5-2-ARP地址解析过程" class="headerlink" title="3.2.5.2 ARP地址解析过程"></a><strong>3.2.5.2 ARP地址解析过程</strong></h4><p><img src="arpflow.jpg" alt=""></p><p>主机A和B在同一个网段，主机A要向主机B发送信息</p><p>主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</p><p>如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</p><p>主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p><p>主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</p><h2 id="4-互联网层-网络层"><a href="#4-互联网层-网络层" class="headerlink" title="4. 互联网层(网络层)"></a><strong>4. 互联网层(网络层)</strong></h2><p>位于传输层和网络接口层之间,用于把数据从源主机经过若干个中间节点传送到目标主机,并向传输层提供最基础的数据传输服务,它要提供路由和选址的工作</p><p><img src="8.iplayer.png" alt=""></p><h3 id="4-1-选址"><a href="#4-1-选址" class="headerlink" title="4.1 选址"></a><strong>4.1 选址</strong></h3><p>交换机是靠MAC来寻址的，而因为MAC地址是无层次的,所以要靠IP地址来确认计算机的位置,这就是选址</p><p><img src="8.address.png" alt=""></p><p><img src="t0123c4234759d969dc.jpg" alt=""></p><h3 id="4-2-路由"><a href="#4-2-路由" class="headerlink" title="4.2 路由"></a><strong>4.2 路由</strong></h3><blockquote><p><em>寻址</em></p></blockquote><p>在能够选择的多条道路之间选择一条最短的路径就是路由的工作</p><p><img src="8.router.png" alt=""></p><h3 id="4-3-IP"><a href="#4-3-IP" class="headerlink" title="4.3 IP"></a><strong>4.3 IP</strong></h3><p>在网络中，每台计算机都有一个唯一的地址，方便别人找到它，这个地址称为IP地址。</p><h3 id="4-3-1-IP头部"><a href="#4-3-1-IP头部" class="headerlink" title="4.3.1 IP头部"></a><strong>4.3.1 IP头部</strong></h3><p><img src="ipheader.png" alt=""></p><p><img src="ip_header.png" alt=""></p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">版本</td><td align="left">Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100</td></tr><tr><td align="left">首部长部</td><td align="left">报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节</td></tr><tr><td align="left">优先级与服务类型</td><td align="left">占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0</td></tr><tr><td align="left">总长度</td><td align="left">占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节</td></tr><tr><td align="left">标识符</td><td align="left">占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1</td></tr><tr><td align="left">标志</td><td align="left">分为3个字段，依次为保留位、不分片位和更多片位</td></tr><tr><td align="left">标志</td><td align="left">保留位：一般被置为0</td></tr><tr><td align="left">标志</td><td align="left">不分片位：表示该数据报是否被分片，如果被置为1，则不能对数据报进行分片，如果要对其进行分片处理，就应将其置为0</td></tr><tr><td align="left">标志</td><td align="left">更多片位：除了最后一个分片，其他每个组成数据报的片都要将该位置设置为1.</td></tr><tr><td align="left">段偏移量</td><td align="left">占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置</td></tr><tr><td align="left">TTL(Time to Live生存时间)</td><td align="left">该字段用于表示IP数据包的生命周期，可以防止一个数据包在网络中无限循环地发下去。TTL的意思是一个数据包在被丢弃之前在网络中的最大周转时间。该数据包经过的每一个路由器都会检查该字段中的值，当TTL的值为0时此数据包会被丢弃。TTL对应于一个数据包通过路由器的数目，一个数据包每经过一个路由器，TTL将减去1</td></tr><tr><td align="left">协议号</td><td align="left">占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等</td></tr><tr><td align="left">首部校验和</td><td align="left">检验和是16位的错误检测字段。目的主机和网络中的每个网关都要重新计算报头的校验和，一样表示没有改动过,计算方法是：对头部中每个16比特进行二进制反码求和</td></tr><tr><td align="left">源IP地址</td><td align="left">该字段用于表示数据包的源地址，指的是发送该数据包的设备的网络地址</td></tr><tr><td align="left">目标IP地址</td><td align="left">该字段用于表示数据包的目标的地址，指的是接收节点的网络地址</td></tr></tbody></table><p><img src="ipwireshark.png" alt=""></p><h3 id="4-3-2-IP地址格式"><a href="#4-3-2-IP地址格式" class="headerlink" title="4.3.2 IP地址格式"></a><strong>4.3.2 IP地址格式</strong></h3><p>IP地址是一个网络编码，用来确定网络中的一个节点。</p><p>IP地址是由32位二进制(32bit)组成</p><p><img src="9.ip.png" alt=""></p><h3 id="4-3-3-IP地址组成"><a href="#4-3-3-IP地址组成" class="headerlink" title="4.3.3 IP地址组成"></a><strong>4.3.3 IP地址组成</strong></h3><p>网络部分(NETWORK), 网络部分表示不同的网络</p><p>主机部分(HOST) ，主机部分标示在一个网络中特定的主机</p><p><img src="ippart.png" alt=""></p><h3 id="4-3-4-IP地址表示"><a href="#4-3-4-IP地址表示" class="headerlink" title="4.3.4 IP地址表示"></a><strong>4.3.4 IP地址表示</strong></h3><p><img src="9.ip.png" alt=""></p><h3 id="4-3-5-IP地址的分类"><a href="#4-3-5-IP地址的分类" class="headerlink" title="4.3.5 IP地址的分类"></a><strong>4.3.5 IP地址的分类</strong></h3><ol><li><p>IP地址的网络部分是由Internet地址分配机构来统一分配的，这样可以保证IP的唯一性。</p></li><li><p>ip地址中全为1的ip即255.255.255.255，它称为限制广播地址，如果将其作为数据包的目标地址可以理解为发送到所有网络的所有主机</p></li><li><p>ip地址中全为0的ip即0.0.0.0，它表示启动时的ip地址，其含义就是尚未未分配时的ip地址</p></li><li><p>127是用来进行本机测试的，除了127.255.255.255外，其它的127开头的地址都代表本机</p></li></ol><p><img src="10.ipclass.png" alt=""></p><ul><li>ip地址有5种</li></ul><ol><li><p>A类：1.0.0.0~126.255.255.255</p></li><li><p>B类：128.0.0.0~191.255.255.255</p></li><li><p>C类：192.0.0.0~223.255.255.255</p></li><li><p>D类：224.0.0.0~239.255.255.255 （用于组播）</p></li><li><p>E类：240.0.0.0~254.255.255.255 （用于科研）</p></li></ol><p>其中127.0.0.0~127.255.255.255用于环回测试</p><ul><li><p>A类网络，第一个字节是网络，另外三个字节是host地址，</p></li><li><p>B类网络，网络有两个字节，另外两个字节是host地址</p></li><li><p>C类网络，网络有三个字节，另外1个字节是host地址</p></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h4><p><img src="classabc.png" alt=""></p><p>如上图所示，保留地址中第二行 <code>172.12.0.0/12</code>描述为16个连续的B段，</p><p><code>192.168.0.0/16</code>描述为256个连续的C段，如何理解</p><p><code>172.16.0.0~172.31.255.255</code>, 因为B类网络的host只占最后两个字节，172.16～172.31 就代表了16个连续的B类网络可用</p><p><code>192.168.0.0~192.168.255.255</code>，因为C类网络的host只占最后一个字节，所以从192.168.0 到 192.168.255， 就有256个连续的C类网络可用</p><p>服务器可以监听的端口从0到65535，理论上这台服务器的这个端口只要没被占用，你都可以给服务器绑定。如果是一些默认的服务，服务器绑的也是默认的端口，那么客户端是可以知道的。比如：80是给http服务，443是给htts服务，21是给ftp服务等，否则的话，就需要服务器开发者告诉客户端应该连接哪个端口。</p><h4 id="192-168-0-1-27表示什么-（理解子网，网段-和子网掩码）"><a href="#192-168-0-1-27表示什么-（理解子网，网段-和子网掩码）" class="headerlink" title="192.168.0.1/27表示什么 （理解子网，网段 和子网掩码）"></a><strong>192.168.0.1/27表示什么 （理解子网，网段 和子网掩码）</strong></h4><p>首先 192.168.0.1 是个IP地址，更细一点的话，属于C类型的，后面的/27 则表示网络号的长度，也叫VLSM（Variable Length Subnet Mask，可变长子网掩码），192.168.0.1/27 属于CIDR（无类别域间路由，Classless Inter-Domain Routing）表述形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP&#96; 地址是以点分割为四部分，每部分 &#96;8bit&#96; （位）也就是一个 &#96;byte&#96;（字节）。在C类地址中，网络号占 &#96;24bit&#96;，主机号占 &#96;8bit</span><br></pre></td></tr></table></figure><table><thead><tr><th>网络号</th><th>主机号</th></tr></thead><tbody><tr><td>11111111 11111111 11111111</td><td>00000000</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.1&#x2F;27 说明网络号占了27bit， 27个1表示网络号， 后面5个0表示主机号</span><br></pre></td></tr></table></figure><table><thead><tr><th>网络号</th><th>主机号</th></tr></thead><tbody><tr><td>11111111 11111111 11111111</td><td>11100000</td></tr></tbody></table><p>网络号向主机借了<code>3bit</code>,说明有<code>2^3=8</code>个子网，每个子网可用主机数为 <code>2^5-2=30</code>, 这里 <code>-2</code> 是因为头尾的<code>网络地址</code>（全0的部分）和<code>广播地址</code>（全1的部分）是不可用的。 <code>11111111 11111111 11111111 11100000</code> 11100000 转为十进制即 <code>2**7+2**6+2**5</code> 即224。所以子网掩码为<code>255.255.255.224</code>。</p><table><thead><tr><th>IP 地址</th><th>11000000</th><th>10101000</th><th>00000000</th><th>00000001</th></tr></thead><tbody><tr><td>子网掩码</td><td>11111111</td><td>11111111</td><td>11111111</td><td>11100000</td></tr><tr><td>网络地址</td><td>11000000</td><td>10101000</td><td>00000000</td><td>00000000</td></tr><tr><td>广播地址</td><td>11000000</td><td>10101000</td><td>00000000</td><td>00011111</td></tr></tbody></table><p>网络地址是IP地址<code>192.168.0.1</code> 和 子网掩码 <code>255.255.255.224</code>的二进制 做 与运算，结果为 <code>192.168.0.0</code>, 广播地址则是在 网络地址的基础上把主机号从右往左数5位置为1而得到 <code>192.168.0.31</code>。 有效的主机IP地址为 <code>192.168.0.1</code> 到 <code>192.168.0.30</code>。 </p><p>结合上面计算出有8个子网，那么<code>192.168.0.1</code>则落在第一个可用子网内 <code>192.168.0.1~192.168.0.30</code>，子网分布如下</p><table><thead><tr><th>子网</th><th>IP 网段</th><th>可用主机</th></tr></thead><tbody><tr><td>一</td><td>192.168.0.0 ~ 192.168.0.31</td><td>192.168.0.1 ~ 192.168.0.30</td></tr><tr><td>二</td><td>192.168.0.32 ~ 192.168.0.63</td><td>192.168.0.33 ~ 192.168.0.62</td></tr><tr><td>三</td><td>192.168.0.64 ~ 192.168.0.95</td><td>192.168.0.65 ~ 192.168.0.94</td></tr><tr><td>四</td><td>192.168.0.96 ~ 192.168.0.127</td><td>192.168.0.97 ~ 192.168.0.126</td></tr><tr><td>五</td><td>192.168.0.128 ~ 192.168.0.159</td><td>192.168.0.129 ~ 192.168.0.158</td></tr><tr><td>六</td><td>192.168.0.160 ~ 192.168.0.191</td><td>192.168.0.161 ~ 192.168.0.190</td></tr><tr><td>七</td><td>192.168.0.192 ~ 192.168.0.223</td><td>192.168.0.193 ~ 192.168.0.222</td></tr><tr><td>八</td><td>192.168.0.224 ~ 192.168.0.255</td><td>192.168.0.225 ~ 192.168.0.254</td></tr></tbody></table><ul><li>每个子网中全0网络地址和全1广播地址不能作为主机ip来使用（这里的全0和全1，指的是二进制的全0 全1）</li></ul><h3 id="4-3-6-公有地址和私有地址"><a href="#4-3-6-公有地址和私有地址" class="headerlink" title="4.3.6 公有地址和私有地址"></a><strong>4.3.6 公有地址和私有地址</strong></h3><blockquote><p><em>从上面所示，ip地址共有2的32次方减2个，总共不到43亿个ip地址。，上面提到过全球的网卡300多亿张，所以必然没办法每张网卡都能对应一个ip地址。然后有一些ip出于某种原因，还被保留下来了。所以可以提供使用的ip很少很少。那为啥这么多年过去了，IP还没用完呢。原因就是</em> <em><code>**子网**</code></em> <em>的存在；</em></p></blockquote><ul><li>保留网段（私有IP）</li></ul><blockquote><p><em>一个常见的现象，我们所在的单位或者组织，普遍会使用诸如10.0.x.x 或者192.168.x.x这样的ip地址，这样的ip到底代表了什么？ 不同的组织使用同样的ip会不会导致冲突呢？</em></p></blockquote><blockquote><p><em>背后的原因是，国际标准组织在IPV4 地址空间里面，专门划分出了一些网段，这些网段不会用做公网上的IP，而是仅仅保留作内部使用。这些地址称作保留网段；</em></p></blockquote><p>| 分类  | IP地址范围                | 私有IP地址范围                | 最大主机个数 |<br>| —– | ————————- | —————————– |<br>| A类IP | 1.0.0.0<del>126.255.255.255   | 10.0.0.0 ~ 10.255.255.255     | 2**24-2      |<br>| B类IP | 128.0.0.0</del>191.255.255.255 | 172.16.0.0 ~ 172.31.255.255   | 2<strong>16-2      |<br>| C类IP | 192.0.0.0~223.255.255.255 | 192.168.0.0 ~ 192.168.255.255 | 2</strong>8-2       |</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他范围的IP均为公有IP地址</span><br></pre></td></tr></table></figure><h3 id="网段与子网掩码"><a href="#网段与子网掩码" class="headerlink" title="网段与子网掩码"></a><strong>网段与子网掩码</strong></h3><p>在网络IP划分的时候，需要区分两个概念</p><p>第一是网络（network）的概念，直观点说，它表示的是这组IP共用的部分，比如在192.168.1.1～192.168.1.255这个区间里，它们共同的部分是192.168.1.0</p><p>第二是主机（host）的概念，它表示的是这组IP不同的部分，上面的例子中1～255就是不同的那些部分，表示有255个可用的不同IP</p><p>例如IPv4 地址，<code>192.0.2.12</code>，我们可以说前面三个字节是子网， 即（<code>192.0.2.12</code>），最后一个字节是host，或者换个方式，我们能说host为8位，子网掩码为<code>192.0.2.0/24</code> （即24个1，8个0   255.255.255.0）</p><p>网络地址位数由子网掩码决定，你可以将IP地址与子网掩码进行“位与”操作，就能得到网络的值。子网掩码一般看起来像是<code>255.255.255.0</code>（二进制为 11111111.11111111.11111111.00000000），这里需要强调的是，A，B，C三类地址都有自己默认的子网掩码，A类为<code>255.0.0.0</code>, B类为<code>255.255.0.0</code>, C类为<code>255.255.255.0</code></p><p>比如你的ip地址是<code>192.0.2.12</code>， 使用这个子网掩码时，你的网络地址就会是<code>192.0.2.12</code>与<code>255.255.255.0</code> 所得到的值： <code>192.0.2.0</code>, <code>192.0.2.0</code>就是这个网络的值；</p><p>子网掩码能接受任意个位，而不单纯是上面讨论的8，16或24个比特而已，所以你可以有一个子网掩码<code>255.255.255.252</code>(二进制位 11111111.11111111.11111100),这个子网掩码能切出一个30个位的网络以及2个位的主机，这个网络最多有四台host，因为最后一个位有两个0，（11111111，11111110，11111101，11111100）四种情况。</p><p>子网掩码只有一个作用，就是将某个IP地址划分为网络地址和主机地址两个部分。</p><p>子网掩码的格式永远都是二进制格式：前面一连串1，后面一连串的0</p><p>不过一大串的数字会有点不好用，比如像<code>255.192.0.0</code>这样的子网掩码，无法直观看到多少个，多个0，后来发明了新的办法，只需要将一个斜线放在ip地址后面，接着用一个十进制的数组用以表示网络的位数，类似这样：<code>192.0.2.12/30</code>,这样就很容易知道有30个1，2个0， 所以主机个数为4；</p><h3 id="4-3-7-子网掩码"><a href="#4-3-7-子网掩码" class="headerlink" title="4.3.7 子网掩码"></a><strong>4.3.7 子网掩码</strong></h3><blockquote><p><em>为什么一个职场1000多人只靠着一个ip就能满足，靠的就是子网掩码</em></p></blockquote><ul><li><p>子网掩码(subnet mask)又叫子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位的掩码。</p></li><li><p>子网掩码不能单独存在，它必须结合IP地址一起使用。</p></li><li><p>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p></li><li><p>子网掩码也是32个二进制位</p></li><li><p>对应IP的网络部分用1表示</p></li><li><p>对应IP地址的主机部分用0表示</p></li><li><p>IP地址和子网掩码做逻辑与运算得到网络地址</p><ul><li><p>0和任何数相与都是0</p></li><li><p>1和任何数相与都等于任何数本身</p></li></ul></li></ul><ul><li><p>A B C 三类地址都有自己默认的子网掩码</p><ul><li><p>A类 255.0.0.0</p></li><li><p>B类 255.255.0.0</p></li><li><p>C类 255.255.255.0</p></li></ul></li></ul><ul><li>子网掩码可以自己设置也可以自动获取</li></ul><p><img src="dividesubnet.jpg" alt=""></p><p>子网的第一个ip 是 <code>192.168.5.129</code></p><p>最后一台主机ip是 <code>192.168.5.158</code></p><p>定向广播 <code>192.168.5.159</code></p><p>下一个子网 <code>192.168.5.160</code></p><p><img src="10.mask.png" alt=""></p><ul><li>判断两个ip地址在不在一个子网之内</li></ul><p>IP地址和子网掩码的二进制 做与运算之后得到子网的二进制网络地址，判断两个网络地址在不在一个子网之内，把它们根子网掩码做与运算。如果与的结果是一致的，那说明在一个子网之内。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">// 判断两个ip地址在不在一个子网之内*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ip1 = <span class="string">"192.168.0.1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ip2 = <span class="string">"192.168.0.4"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mask = <span class="string">"255.255.255.0"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">same</span>(<span class="params">ip1, ip2, mask</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ip1s = ip1</span><br><span class="line"></span><br><span class="line">​    .split(<span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">​    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> (+item).toString(<span class="number">2</span>).padStart(<span class="number">8</span>, <span class="string">"0"</span>))</span><br><span class="line"></span><br><span class="line">​    .join(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ip2s = ip2</span><br><span class="line"></span><br><span class="line">​    .split(<span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">​    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> (+item).toString(<span class="number">2</span>).padStart(<span class="number">8</span>, <span class="string">"0"</span>))</span><br><span class="line"></span><br><span class="line">​    .join(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> masks = mask</span><br><span class="line"></span><br><span class="line">​    .split(<span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">​    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> (+item).toString(<span class="number">2</span>).padStart(<span class="number">8</span>, <span class="string">"0"</span>))</span><br><span class="line"></span><br><span class="line">​    .join(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">​    (<span class="built_in">parseInt</span>(ip1s, <span class="number">2</span>) &amp; <span class="built_in">parseInt</span>(masks, <span class="number">2</span>)) ===</span><br><span class="line"></span><br><span class="line">​    (<span class="built_in">parseInt</span>(ip2s, <span class="number">2</span>) &amp; <span class="built_in">parseInt</span>(masks, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = same(ip1, ip2, mask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h4 id="子网掩码解决什么问题"><a href="#子网掩码解决什么问题" class="headerlink" title="子网掩码解决什么问题"></a><strong>子网掩码解决什么问题</strong></h4><p>子网掩码所做的是将网络划分出子网，解决网段的问题。私有ip才是解决ip不够用的问题</p><h4 id="子网掩码划分子网"><a href="#子网掩码划分子网" class="headerlink" title="子网掩码划分子网"></a><strong>子网掩码划分子网</strong></h4><ul><li>一个实际的场景， 比如一个公司有两个部门，财务部和hr部，每个部分都有四台电脑，网络要部署到两个部门，但是两个部门需要独立的局域网。我们知道一个C类ip地址可以有254个主机地址。所以，需要通过子网掩码的方式来把一个ip地址拆分给连个部门使用。</li></ul><p>比如ip为 <code>10011111 11111111 11111111 11000000</code></p><p>子网掩码1 为 <code>10011111 11111111 11111111 11100000</code></p><p>子网掩码2 为 <code>10011111 11111111 11111111 11110000</code></p><p>子网掩码可以是多个</p><p>子网掩码将不在一个子网之内的网络调整到一个子网内，即往左边移位</p><p>比如 <code>255.255.255.0</code> =&gt; <code>255.255.0.0</code> =&gt; <code>255.0.0.0</code></p><h4 id="划分局域网需要物理划分的同时还要通过子网掩码划分吗？"><a href="#划分局域网需要物理划分的同时还要通过子网掩码划分吗？" class="headerlink" title="划分局域网需要物理划分的同时还要通过子网掩码划分吗？"></a><strong>划分局域网需要物理划分的同时还要通过子网掩码划分吗？</strong></h4><blockquote><p><em>是的，首先把一些电脑划分到一个子网之内。它们需要在一个物理网络内。它们必须连上路由器，交换机等等。另外还得看子网掩码，看看ip地址在不在一个局域网之内。</em></p></blockquote><h2 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a><strong>5. 传输层</strong></h2><ul><li><p>位于应用层和网络接口层之间</p></li><li><p>是面向连接的、可靠的的进程到进程通信的协议</p></li><li><p>TCP提供全双工服务，即数据可在同一时间双向传播</p></li><li><p>TCP将若干个字节构成一个分组，此分组称为报文段(Segment)</p></li><li><p>对可靠性要求高的上层协议，实现可靠性的保证,如果数据丢失、损坏的情况下如何保证可靠性,网络层只管传递数据，成功与否并不关心</p></li></ul><p><img src="11.transfer.png" alt=""></p><h3 id="5-1-传输层的功能"><a href="#5-1-传输层的功能" class="headerlink" title="5.1 传输层的功能"></a><strong>5.1 传输层的功能</strong></h3><p>提供了一种端到端的连接</p><p><img src="11.connect.png" alt=""></p><h3 id="5-2-协议分类"><a href="#5-2-协议分类" class="headerlink" title="5.2 协议分类"></a><strong>5.2 协议分类</strong></h3><h4 id="TCP-Transimision-Control-Protocal"><a href="#TCP-Transimision-Control-Protocal" class="headerlink" title="TCP(Transimision Control Protocal)"></a><strong>TCP(Transimision Control Protocal)</strong></h4><ul><li><p>传输控制协议</p></li><li><p>可靠的、面向连接的协议</p></li><li><p>传输效率低</p></li></ul><h4 id="UDP-User-Datagram-Protocal"><a href="#UDP-User-Datagram-Protocal" class="headerlink" title="UDP(User Datagram Protocal)"></a><strong>UDP(User Datagram Protocal)</strong></h4><ul><li><p>用户数据报协议</p></li><li><p>不可靠的、无连接的服务</p></li><li><p>传输效率高</p></li></ul><h3 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a><strong>5.3 TCP协议</strong></h3><ul><li><p>将数据进行分段打包传输</p></li><li><p>对每个数据包编号控制顺序</p></li><li><p>运输中丢失、重发和丢弃处理</p></li><li><p>流量控制避免拥塞</p></li></ul><h3 id="5-3-1-TCP数据包封装"><a href="#5-3-1-TCP数据包封装" class="headerlink" title="5.3.1 TCP数据包封装"></a><strong>5.3.1 TCP数据包封装</strong></h3><h4 id="5-3-1-1-格式"><a href="#5-3-1-1-格式" class="headerlink" title="5.3.1.1 格式"></a><strong>5.3.1.1 格式</strong></h4><blockquote><p><em>源端口号和目标端口号，计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收</em></p></blockquote><p><img src="tcpport.png" alt=""></p><h4 id="5-3-1-2-32位序列号"><a href="#5-3-1-2-32位序列号" class="headerlink" title="5.3.1.2 32位序列号"></a><strong>5.3.1.2 32位序列号</strong></h4><blockquote><p><em>32位序列号 TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值</em></p></blockquote><p><img src="tcpsequence.png" alt=""></p><h4 id="5-3-1-3-确认应答号"><a href="#5-3-1-3-确认应答号" class="headerlink" title="5.3.1.3 确认应答号"></a><strong>5.3.1.3 确认应答号</strong></h4><blockquote><p><em>确认应答号 它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</em></p></blockquote><p><img src="tcpconfirm.png" alt=""></p><p>1,2,3,4  包到达目的地的时机不一样；当3先到。接收端并不会立即通知发送端已经收到3. 而是会等待一段时间之后，如果依然没有响应。则告知发送端，已经收到了3. 请把1，2重新发一下。因为已经收到了3.所以必然有1，2.等到最终1和2都到了。那再告知发送端，已经收到1，2，3</p><h4 id="5-3-1-4-首部长度"><a href="#5-3-1-4-首部长度" class="headerlink" title="5.3.1.4 首部长度"></a><strong>5.3.1.4 首部长度</strong></h4><blockquote><p><em>首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。</em></p></blockquote><p><img src="tcpcontrolpng.png" alt=""></p><h4 id="5-3-1-5-控制位"><a href="#5-3-1-5-控制位" class="headerlink" title="5.3.1.5 控制位"></a><strong>5.3.1.5 控制位</strong></h4><blockquote><p><em>控制位 TCP的连接、传输和断开都受这六个控制位的指挥</em></p></blockquote><ul><li><p>URG(urgent紧急位) 紧急信号</p></li><li><p>ACK（响应位）</p></li><li><p>PSH(push急迫位) 缓存区将满，立刻传输速度</p></li><li><p>RST(reset重置位) 连接断了重新连接</p></li><li><p>SYN（sync同步）TCP基于链接的，想根对方建立链接，勇敢伸出一只手。发送SYN标识位</p></li><li><p>FIN（finish完成）发送端完成位，提出断开链接的一方把FIN置为1表示要断开连接</p></li></ul><ul><li>紧急指针：仅在 URG(urgent紧急) 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。</li></ul><h4 id="5-3-1-5-1-SYN"><a href="#5-3-1-5-1-SYN" class="headerlink" title="5.3.1.5.1 SYN"></a><strong>5.3.1.5.1 SYN</strong></h4><p>SYN(synchronous建立联机) 同步序号位 TCP建立连接时要将这个值设为1</p><p><img src="tcpsyn.png" alt=""></p><h4 id="5-3-1-5-2-ACK"><a href="#5-3-1-5-2-ACK" class="headerlink" title="5.3.1.5.2 ACK"></a><strong>5.3.1.5.2 ACK</strong></h4><p>ACK(acknowledgement 确认)为1表示确认号</p><p><img src="tcpack.png" alt=""></p><h4 id="5-3-1-5-3-FIN"><a href="#5-3-1-5-3-FIN" class="headerlink" title="5.3.1.5.3 FIN"></a><strong>5.3.1.5.3 FIN</strong></h4><p>FIN发送端完成位，提出断开连接的一方把FIN置为1表示要断开连接</p><p><img src="tcpfin.png" alt=""></p><h4 id="5-3-1-6-窗口值"><a href="#5-3-1-6-窗口值" class="headerlink" title="5.3.1.6 窗口值"></a><strong>5.3.1.6 窗口值</strong></h4><blockquote><p><em>窗口值 说明接收端可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。它是来在TCP传输中进行流量控制的</em></p></blockquote><blockquote><p><em>窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测（每隔一段时间，发送端主动发送一个问询，窗口大小有没有改变）</em></p></blockquote><p><img src="tcpwindow.png" alt=""></p><h4 id="5-3-1-7-差错控制"><a href="#5-3-1-7-差错控制" class="headerlink" title="5.3.1.7 差错控制"></a><strong>5.3.1.7 差错控制</strong></h4><p>校验和用来做差错控制，TCP校验和的计算包括TCP首部、数据和其它填充字节。在发送TCP数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验 和一致说明数据是正确的，否则 将认为数据被破坏，接收端将丢弃该数据</p><p><img src="tcpcheck.png" alt=""></p><h3 id="5-3-2-握手和断开（三次握手，四次挥手）"><a href="#5-3-2-握手和断开（三次握手，四次挥手）" class="headerlink" title="5.3.2 握手和断开（三次握手，四次挥手）"></a><strong>5.3.2 握手和断开（三次握手，四次挥手）</strong></h3><ul><li><p>TCP是面向连接的协议，它在源点和终点之间建立虚拟连接，而不是物理连接</p></li><li><p>在数据通信之前，发送端与接收端要先建立连接，等数据发送结束后，双方再断开连接</p></li><li><p>TCP连接的每一方都是由一个IP地址和一个端口组成</p></li></ul><p><img src="sequencenumber.jpg" alt=""></p><p><img src="tcpflow.png" alt=""></p><h3 id="5-3-2-1-tcp服务器"><a href="#5-3-2-1-tcp服务器" class="headerlink" title="5.3.2.1 tcp服务器"></a><strong>5.3.2.1 tcp服务器</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">// tcp_server.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> net.Server();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"connection"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"connected"</span>);</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line"></span><br><span class="line">        socket.write(<span class="string">"server:"</span>+data);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line">    socket.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"listening"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Created server on http://127.0.0.1:8000/"</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server closed!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">//tcp_client.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> socket = net.Socket();</span><br><span class="line"></span><br><span class="line">socket.connect(<span class="number">8000</span>, <span class="string">'127.0.0.1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"connect the server"</span>);</span><br><span class="line"></span><br><span class="line">    socket.write(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line"></span><br><span class="line">    socket.destroy();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"data end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-3-2-1-三次握手"><a href="#5-3-2-1-三次握手" class="headerlink" title="5.3.2.1 三次握手"></a><strong>5.3.2.1 三次握手</strong></h3><ol><li><p>第一次握手主机A通过一个标识为SYN标识位的数据段发送给主机B请求连接，通过该数据段告诉主机B希望建立连接，需要B应答，并告诉主机B传输的起始序列号</p></li><li><p>第二次握手是主机B用一个确认应答ACK和同步序列号SYNC标志位的数据段来响应主机A，一是发送ACK告诉主机A收到了数据段，二是通知主机A从哪个序列号做标记。</p></li><li><p>第三次握手是主机A确认收到了主机B的数据段并可以开始传输实际数据。</p></li></ol><p><img src="handshake1.png" alt=""></p><p><img src="handshake2.png" alt=""></p><p><img src="handshake3.png" alt=""></p><ol><li><p><code>SYN_SENT(connect())</code> 握手请求 <code>SYN seq=x</code> (x为一个32位的随机数)</p></li><li><p><code>LISTEN(listen()) SYN_RCVD</code> 发送 <code>SYN seq=y, ACK = x+1</code> (此时客户端宣布 established)</p></li><li><p>客户端发送 <code>ACK=y+1</code> (此时服务端感知 established)</p></li></ol><p>sep的作用是给数据包标住序号，用于后面确认，重传等。seq是一个<code>2**32</code>的数字seq如果越界，会重置为0.</p><h3 id="5-3-2-2-收发数据"><a href="#5-3-2-2-收发数据" class="headerlink" title="5.3.2.2 收发数据"></a><strong>5.3.2.2 收发数据</strong></h3><p><img src="sendhello.png" alt=""></p><p><img src="ackhello.png" alt=""></p><p><img src="serverhello.png" alt=""></p><p><img src="ackserverhello.png" alt=""></p><h3 id="5-3-2-3-四次断开"><a href="#5-3-2-3-四次断开" class="headerlink" title="5.3.2.3 四次断开"></a><strong>5.3.2.3 四次断开</strong></h3><ul><li><p>主机A发送FIN控制位发出断开连接的请求</p></li><li><p>主机B进行响应，确认收到断开连接请求</p></li><li><p>主机B提出反方向的关闭要求</p></li><li><p>主机A确认收到的主机B的关闭连接请求</p></li></ul><p><img src="goodbye1.png" alt=""></p><p><img src="goodbye2.png" alt=""></p><p><img src="goodbye3.png" alt=""></p><p><img src="goodbye4.png" alt=""></p><ul><li>为什么挥手会有四次，在客户端发送断开链接指令的时候， 服务端发送了一次 ACK 和一次ACK/FIN指令。为何这两次指令不能合并在一起呢？</li></ul><blockquote><p><em>因为收到关闭请求和真正关闭只有一段时间差的，这段时间差当中可能还有传输的数据包。所以服务端没办法第一时间返回finsh。只有等数据包情况处理好之后，才能返回finsh请求；</em></p></blockquote><h3 id="5-3-3-滑动窗口"><a href="#5-3-3-滑动窗口" class="headerlink" title="5.3.3 滑动窗口"></a><strong>5.3.3 滑动窗口</strong></h3><ul><li><p>滑动窗口（Sliding window）是一种流量控制技术</p></li><li><p>早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题</p></li><li><p>TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据</p></li><li><p>当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小</p></li></ul><ul><li><p>发送方和接收方各维护一个窗口长度，接收方会把窗口大小发给发送方。发送方设置一个小于或者等于接收窗口大小的值。</p></li><li><p>窗口大小 = 缓存区大小 - 缓存字节数</p></li></ul><h3 id="5-3-3-1-窗口机制"><a href="#5-3-3-1-窗口机制" class="headerlink" title="5.3.3.1 窗口机制"></a><strong>5.3.3.1 窗口机制</strong></h3><ul><li><p>滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口</p></li><li><p>发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同</p></li><li><p>不同的滑动窗口协议窗口大小一般不同</p></li><li><p>发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧</p></li></ul><p><img src="slidewindow.png" alt=""></p><h3 id="5-3-3-2-拥塞控制"><a href="#5-3-3-2-拥塞控制" class="headerlink" title="5.3.3.2 拥塞控制"></a><strong>5.3.3.2 拥塞控制</strong></h3><ul><li><p>TCP拥塞控制是传输控制协议（英语：Transmission Control Protocol，缩写TCP）避免网络拥塞的算法，是互联网上主要的一个拥塞控制措施</p></li><li><p>TCP使用多种拥塞控制策略来避免雪崩式拥塞。TCP会为每条连接维护一个“拥塞窗口”来限制可能在端对端间传输的未确认分组总数量</p></li><li><p>这类似TCP流量控制机制中使用的滑动窗口，是由发送方控制的</p></li><li><p>TCP在一个连接初始化或超时后使用一种“慢启动”机制来增加拥塞窗口的大小。它的起始值一般为最大分段大小（Maximum segment size，MSS）的两倍，虽然名为“慢启动”，初始值也相当低，但其增长极快：当每个分段得到确认时，拥塞窗口会增加一个MSS，使得在每次往返时间（round-trip time，RTT）内拥塞窗口能高效地双倍增长</p></li><li><p>在流量控制中，接收方通过TCP的“窗口”值（Window Size）来告知发送方，由发送方通过对拥塞窗口和接收窗口的大小比较，来确定任何时刻内需要传输的数据量</p></li><li><p>和式增加，积式减少（additive-increase/multiplicative-decrease，AIMD，这里简称“线增积减”）是一种反馈控制算法，其包含了对拥塞窗口线性增加，和当发生拥塞时对窗口积式减少。多个使用AIMD控制的TCP流最终会收敛到对线路的等量竞争使用。</p></li><li><p>未确认的数据包刚好等于带宽等于延迟</p></li><li><p>当发现丢包的时候立刻减半</p></li></ul><p><img src="traffic.png" alt=""></p><h2 id="5-4-UDP"><a href="#5-4-UDP" class="headerlink" title="5.4 UDP"></a><strong>5.4 UDP</strong></h2><ul><li><p>UDP是一个无连接、不保证可靠性的传输层协议，也就是说发送端不关心发送的数据是否到达目标主机、数据是否出错等，收到数据的主机也不会告诉 发送方是否收到了数据，它的可靠性由上层协议来保障</p></li><li><p>首部结构简单，在数据传输时能实现最小的开销，如果进程想发送很短的报文而对可靠性要求不高可以使用</p></li><li><p>没有握手，也没有挥手</p></li></ul><h3 id="5-4-1-UDP的封装格式"><a href="#5-4-1-UDP的封装格式" class="headerlink" title="5.4.1 UDP的封装格式"></a><strong>5.4.1 UDP的封装格式</strong></h3><h4 id="5-4-1-1-数据包"><a href="#5-4-1-1-数据包" class="headerlink" title="5.4.1.1 数据包"></a><strong>5.4.1.1 数据包</strong></h4><p><img src="15.udp.png" alt=""></p><h4 id="5-4-1-2-数据长度"><a href="#5-4-1-2-数据长度" class="headerlink" title="5.4.1.2 数据长度"></a><strong>5.4.1.2 数据长度</strong></h4><p><img src="udplength.png" alt=""></p><h4 id="5-4-1-3-差错控制"><a href="#5-4-1-3-差错控制" class="headerlink" title="5.4.1.3 差错控制"></a><strong>5.4.1.3 差错控制</strong></h4><p><img src="udpcheck.png" alt=""></p><h4 id="5-4-2-UDP的应用"><a href="#5-4-2-UDP的应用" class="headerlink" title="5.4.2 UDP的应用"></a><strong>5.4.2 UDP的应用</strong></h4><ul><li><p>QQ</p></li><li><p>视频软件</p></li><li><p>TFTP 简单文件传输协议(短信)</p></li></ul><h2 id="5-4-3-UDP服务器"><a href="#5-4-3-UDP服务器" class="headerlink" title="5.4.3 UDP服务器"></a><strong>5.4.3 UDP服务器</strong></h2><h3 id="5-4-3-1-点对点"><a href="#5-4-3-1-点对点" class="headerlink" title="5.4.3.1 点对点"></a><strong>5.4.3.1 点对点</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">// udp_server.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> socket = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg,rinfo</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(msg.toString());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(rinfo);</span><br><span class="line"></span><br><span class="line">   socket.send(msg,<span class="number">0</span>,msg.length,rinfo.port,rinfo.address);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.bind(<span class="number">41234</span>,<span class="string">'localhost'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">// udp_client.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> socket = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg,rinfo</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toString());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(rinfo);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.send(<span class="keyword">new</span> Buffer(<span class="string">'helloworld'</span>),<span class="number">0</span>,<span class="number">5</span>,<span class="number">41234</span>,<span class="string">'localhost'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytes</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发送了个%d字节'</span>,bytes);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="sendudp.png" alt=""></p><p><img src="receiveudp.png" alt=""></p><h4 id="5-4-3-2-广播"><a href="#5-4-3-2-广播" class="headerlink" title="5.4.3.2 广播"></a><strong>5.4.3.2 广播</strong></h4><blockquote><p><em>创建一个UDP服务器并通过该服务器进行数据的广播</em></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">// udp_server.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = dgram.createSocket(<span class="string">'udp4);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server.on('</span>message<span class="string">',function(msg)&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let buf = new Bufffer('</span>已经接收客户端发送的数据<span class="string">'+msg);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server.setBroadcast(true);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server.send(buf,0,buf.length,41235,"192.168.1.255");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server.bind(41234,'</span><span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span><span class="string">');</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">//udp_client.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = dgram.createSocket(<span class="string">'udp4);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">client.bind(41235,'</span><span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = <span class="keyword">new</span> Buffer(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">client.send(buf,<span class="number">0</span>,buf.length,<span class="number">41234</span>,<span class="string">'192.168.1.100'</span>);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg,rinfo</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'received : '</span>,msg);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-4-3-3-组播"><a href="#5-4-3-3-组播" class="headerlink" title="5.4.3.3 组播"></a><strong>5.4.3.3 组播</strong></h4><ul><li><p>所谓的组播，就是将网络中同一业务类型进行逻辑上的分组，从某个socket端口上发送的数据只能被该组中的其他主机所接收，不被组外的任何主机接收。</p></li><li><p>实现组播时，并不直接把数据发送给目标地址，而是将数据发送到组播主机，操作系统将把该数据组播给组内的其他所有成员。</p></li><li><p>在网络中，使用D类地址作为组播地址。范围是指 224.0.0.0 ~ 239.255.255.255,分为三类</p><ul><li><p>局部组播地址: 224.0.0.0 ~ 224.0.0.255 为路由协议和其他用途保留</p></li><li><p>预留组播地址: 224.0.1.0 ~ 238.255.255.255 可用于全球范围或网络协议</p></li><li><p>管理权限组播地址 ： 239.0.0.0 ～ 239.255.255.255 组织内部使用，不可用于Internet</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">//udp_server.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">server.MulticastTTL(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">server.setMulticastLoopback(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">server.addMembership(<span class="string">'230.185.192.108'</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setInterval(broadcast,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString());</span><br><span class="line"></span><br><span class="line">server.send(buffer,<span class="number">0</span>,buffer.length,<span class="number">8080</span>,<span class="string">"230.185.192.108"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="comment">//udp_client.js*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'listening'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">client.addMembership(<span class="string">'230.185.192.108'</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">message,remote</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message.toString());</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.bind(<span class="number">8080</span>,<span class="string">'192.168.1.103'</span>);</span><br></pre></td></tr></table></figure><h3 id="5-4-3-DNS服务器"><a href="#5-4-3-DNS服务器" class="headerlink" title="5.4.3 DNS服务器"></a><strong>5.4.3 DNS服务器</strong></h3><h4 id="3-4-3-1-域名"><a href="#3-4-3-1-域名" class="headerlink" title="3.4.3.1 域名"></a><strong>3.4.3.1 域名</strong></h4><ul><li><p>域名空间结构</p></li><li><p>根域</p></li><li><p>顶级域</p><ul><li><p>组织域</p></li><li><p>国家/地区域名</p></li></ul></li></ul><ul><li>二级域名</li></ul><p><img src="arealocal.png" alt=""></p><h4 id="3-4-3-2-DNS服务器"><a href="#3-4-3-2-DNS服务器" class="headerlink" title="3.4.3.2 DNS服务器"></a><strong>3.4.3.2 DNS服务器</strong></h4><blockquote><p><em>DNS是Domain Name Service的缩写，DNS服务器进行域名和与之对应的IP地址转换的服务器</em></p></blockquote><ul><li><p>IP地址不易记忆</p></li><li><p>早期使用Hosts文件解析域名</p><ul><li><p>主要名称重复</p></li><li><p>主机维护困难</p></li></ul></li><li><p>DNS(Domain Name System 域名系统)</p><ul><li><p>分布式</p></li><li><p>层次性</p></li></ul></li></ul><h4 id="3-4-3-3-查找过程"><a href="#3-4-3-3-查找过程" class="headerlink" title="3.4.3.3 查找过程"></a><strong>3.4.3.3 查找过程</strong></h4><p><img src="dnsquery.jpg" alt=""></p><ul><li><p>客户端向本地域名服务器发出请求，我要访问<a href="http://www.163.com，请告诉我它的IP地址" target="_blank" rel="noopener">www.163.com，请告诉我它的IP地址</a></p></li><li><p>本地DNS服务器向DNS根服务器发出请求，根DNS服务器会告诉本地服务器(.com)的服务器地址</p></li><li><p>本地DNS服务器会向(.com域)发请求，会得到(163.com)的服务器地址</p></li><li><p>本地DNS服务器会向(163.com)发请求,会得到(<a href="http://www.163.com)的IP地址1.1.1.1" target="_blank" rel="noopener">www.163.com)的IP地址1.1.1.1</a></p></li><li><p>本地DNS服务器向客户端回复域名(<a href="http://www.163.com)对应的IP地址是1.1.1.1" target="_blank" rel="noopener">www.163.com)对应的IP地址是1.1.1.1</a></p></li></ul><h3 id="5-4-4-DHCP服务器（Dynamic-Host-Configuration-Protocol）"><a href="#5-4-4-DHCP服务器（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="5.4.4 DHCP服务器（Dynamic Host Configuration Protocol）"></a><strong>5.4.4 DHCP服务器（Dynamic Host Configuration Protocol）</strong></h3><ul><li><p>保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。</p></li><li><p>DHCP应当可以给用户分配永久固定的IP地址。</p></li><li><p>DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机）</p></li><li><p>DHCP服务器应当向现有的BOOTP客户端提供服务。</p></li></ul><h4 id="5-4-4-1-工作流程"><a href="#5-4-4-1-工作流程" class="headerlink" title="5.4.4.1 工作流程"></a><strong>5.4.4.1 工作流程</strong></h4><ul><li><p>主机发送DHCPDISCOVER广播包在网络上寻找DHCP服务器；</p></li><li><p>DHCP服务器向主机发送DHCPOFFER单播数据包，包含IP地址、MAC地址、域名信息以及地址租期；</p></li><li><p>主机发送DHCPREQUEST广播包，正式向服务器请求分配已提供的IP地址；</p></li><li><p>DHCP服务器向主机发送DHCPACK单播包，确认主机的请求</p></li></ul><p><img src="dhcpserver.jpg" alt=""></p><h4 id="5-4-4-2-抓包"><a href="#5-4-4-2-抓包" class="headerlink" title="5.4.4.2 抓包"></a><strong>5.4.4.2 抓包</strong></h4><p><img src="dhcprequest.png" alt=""></p><p><img src="dhcpack.png" alt=""></p><h2 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a><strong>6. 应用层</strong></h2><h3 id="6-1-协议"><a href="#6-1-协议" class="headerlink" title="6.1 协议"></a><strong>6.1 协议</strong></h3><p><img src="17.mail.png" alt=""></p><h3 id="6-2-应用层常见协议"><a href="#6-2-应用层常见协议" class="headerlink" title="6.2 应用层常见协议"></a><strong>6.2 应用层常见协议</strong></h3><ul><li><p>HTTP 超文件传输协议</p></li><li><p>FTP 文件传输协议</p></li><li><p>SMTP(发送邮件)和POP3(接收邮件)</p></li></ul><h3 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a><strong>6.3 案例</strong></h3><p>数据-&gt;传输层(包)-&gt;网络层(段Segment)-&gt;数据链路层(帧)</p><h3 id="6-3-1-发送方是从高层到低层封装数据"><a href="#6-3-1-发送方是从高层到低层封装数据" class="headerlink" title="6.3.1 发送方是从高层到低层封装数据"></a><strong>6.3.1 发送方是从高层到低层封装数据</strong></h3><ul><li><p>在应用层要把各式各样的数据如字母、数字、汉字、图片等转换成二进制</p></li><li><p>在TCP传输层中，上层的数据被分割成小的数据段，并为每个分段后的数据封装TCP报文头部</p></li><li><p>在TCP头部有一个关键的字段信息端口号，它用于标识上层的协议或应用程序，确保上层数据的正常通信</p></li><li><p>计算机可以多进程并发运行，例如在发邮件的同时也可以通过浏览器浏览网页，这两种应用通过端口号进行区分</p></li><li><p>在网络层，上层数据被封装上亲的报文头部(IP头部)，上层的数据是包括TCP头部的。IP地址包括的最关键字段信息就是IP地址，用于标识网络的逻辑地址。</p></li><li><p>数据链路径层，上层数据成一个MAC头部，内部有最关键的是MAC地址。MAC地址就是固化在硬件设备内部的全球唯一的物理地址。</p></li><li><p>在物理层，无论在之前哪一层封装的报文头和还是上层数据都是由二进制组成的，物理将这些二进制数字比特流转换成电信号在网络中传输</p></li></ul><p><img src="18.send.png" alt=""></p><h3 id="6-3-2-接收方是从低层到高层解封装"><a href="#6-3-2-接收方是从低层到高层解封装" class="headerlink" title="6.3.2 接收方是从低层到高层解封装"></a><strong>6.3.2 接收方是从低层到高层解封装</strong></h3><ul><li><p>数据封装完毕传输到接收方后，将数据要进行解封装</p></li><li><p>在物理层，先把电信号转成二进制数据，并将数据传送至数据链路层</p></li><li><p>在数据链路层，把MAC头部拆掉，并将剩余的数据传送至上一层</p></li><li><p>在网络层，数据的IP头部被拆掉，并将剩余的数据送至上一层</p></li><li><p>在传输层，把TCP头部拆掉，将真实的数据传送至应用层</p></li></ul><p><img src="19.receive.png" alt=""></p><h3 id="6-3-3-真实网络环境"><a href="#6-3-3-真实网络环境" class="headerlink" title="6.3.3 真实网络环境"></a><strong>6.3.3 真实网络环境</strong></h3><ul><li><p>发送方和接收方中间可能会有多个硬件中转设备</p></li><li><p>中间可能会增加交换机和路由器</p></li><li><p>数据在传输过程中不断地进行封装和解封装的过程，每层设备只能处理哪一层的数据</p><ul><li><p>交换机属于数据链路层</p></li><li><p>路由器属于网络层</p></li></ul></li></ul><p><img src="reaenv2.png" alt=""></p><p>A电脑 -&gt; A交换机 -&gt; A路由器 -&gt; B路由器 -&gt; B交换机 -&gt; B电脑</p><h2 id="7-附录"><a href="#7-附录" class="headerlink" title="7. 附录"></a><strong>7. 附录</strong></h2><h3 id="7-1-不同层中的称谓"><a href="#7-1-不同层中的称谓" class="headerlink" title="7.1 不同层中的称谓"></a><strong>7.1 不同层中的称谓</strong></h3><ul><li>数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。</li></ul><ul><li>数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。</li></ul><ul><li>段（Segment）：通常是指起始点和目的地都是传输层的信息单元。</li></ul><ul><li>消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。</li></ul><h3 id="7-2-IP头服务类型"><a href="#7-2-IP头服务类型" class="headerlink" title="7.2 IP头服务类型"></a><strong>7.2 IP头服务类型</strong></h3><ul><li>IP首部中的服务类型（TOS）</li></ul><ul><li>TOS包括共8位，包括3 bit的优先权字段（取值可以从000-111所有值），4 bit的TOS子字段和1 bit未用位但必须置0。</li></ul><ul><li>3bit的8个优先级的定义如下：</li></ul><ul><li>111–Network Control(网络控制）一般保留给网络控制数据使用，如路由。</li></ul><ul><li><p>110–Internetwork Control(网间控制)</p></li><li><p>101–Critic(关键)语音数据使用。</p></li><li><p>100–Flash Override(疾速)视频会议和视频流使用。</p></li><li><p>011–Flash(闪速)语音控制数据使用。</p></li><li><p>010–Immediate(快速)数据业务使用</p></li><li><p>001–Priority(优先)数据业务使用</p></li><li><p>000–Routine(普通)默认标记值。</p></li></ul><ul><li>4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是一般服务。</li></ul><ul><li>Telnet、Rlogin这两个交互应用要求最小的传输时延，FTP文件传输要求最大吞吐量，最高可靠性是指网络管理（SNMP）和路由选择协议。用户网络新闻要求最小费用</li></ul>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go2</title>
      <link href="2021/03/24/go2/"/>
      <url>2021/03/24/go2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-io"><a href="#1-io" class="headerlink" title="1. io"></a>1. io</h2><h3 id="1-1-写文件"><a href="#1-1-写文件" class="headerlink" title="1.1 写文件"></a>1.1 写文件</h3><p>按字符串写</p><p>WriteString</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f, err:= os.OpenFile(<span class="string">"./a.txt"</span>, os.O_RDWR, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"openFile err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">  n, err := fmt.Println(<span class="string">"success"</span>) <span class="comment">// n 写入字符个数</span></span><br><span class="line">f.WriteString(<span class="string">"123"</span>) <span class="comment">// 按字符串写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按位置写</p><p>writeAt </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Seek() // 文件位置指针</span></span><br><span class="line">off, _ := f.Seek(<span class="number">-5</span>, io.SeekEnd)</span><br><span class="line">fmt.Println(<span class="string">"off"</span>, off) <span class="comment">// off 表示从文件起始位置往后偏的值</span></span><br><span class="line">n, err = f.WriteAt([]<span class="keyword">byte</span>(<span class="string">"1111"</span>), off)</span><br></pre></td></tr></table></figure><h3 id="1-2-读文件"><a href="#1-2-读文件" class="headerlink" title="1.2 读文件"></a>1.2 读文件</h3><p>按行读</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f, err:= os.OpenFile(<span class="string">"./a.txt"</span>, os.O_RDWR, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"openFile err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">fmt.Println(<span class="string">"success"</span>)</span><br><span class="line"><span class="comment">// 创建一个带有缓冲区的reader</span></span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line">buf, err := reader.ReadBytes(<span class="string">'\n'</span>) <span class="comment">// 读一行数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ReadBytes err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf)) <span class="comment">// hellowo1111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部读取</span></span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  buf, err := reader.ReadBytes(<span class="string">'\n'</span>) <span class="comment">// 读一行数据</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == io.EOF &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ReadBytes err"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(buf)) <span class="comment">// hellowo1111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-缓冲区"><a href="#1-3-缓冲区" class="headerlink" title="1.3 缓冲区"></a>1.3 缓冲区</h3><p>磁盘构成</p><ul><li>振臂 </li><li>磁头</li><li>磁道</li><li>扇区 一个扇区512B，数据在磁盘存储时至少要占据一个扇区。</li></ul><p>磁盘读取是物理操作，物理操作取决于硬件的性能。考虑到物理操作性能开销明显，所以需要进行性能优化。便有了缓冲区。</p><p>一次性尽可能多的奖磁盘上的内容读取到当前内存中，比如需要一行文件。但是缓冲区真正从磁盘上读取的时候。它不止拿了一行。而是尽可能的奖当前扇区里面的数据都读取过来。因为读一行和把当前扇区读完，对于磁头来说，都是一次物理操作。</p><p>一个场景，当读取一行之后，还需要继续读。那么这个时候，就可以直接从缓冲区中读取了，而不需要再次让磁盘执行物理操作读取。而从内存中读取数据是电子操作（电子操作访问速度接近光速，比物理操作快得多）</p><p>缓冲区 “预读入，缓输出”</p><p>往磁盘上写数据的时候，大多情况下是先写到缓冲区中了。等待缓冲区满，由操作系统批量一次性刷到磁盘当中。</p><h3 id="1-4-32位与64位内存地址"><a href="#1-4-32位与64位内存地址" class="headerlink" title="1.4 32位与64位内存地址"></a>1.4 32位与64位内存地址</h3><p>32位 最大内存地址 2^32  4GB（进程空间）</p><p>64位 最大内存地址 2^64  比较大</p><h2 id="2-协议"><a href="#2-协议" class="headerlink" title="2. 协议"></a>2. 协议</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>协议，就是双方约定好的一份的合同，在数据传输层面来说。如果要传输一个文件。我们必然需要来分析一下文件的特征。</p><p>对于发送端来说，我要怎么确保我发出去的东西，接收端能拿到并且拿到的东西是对的；一 文件不能串台，二，文件不能有丢失；</p><p>那最早的传输协议雏形，首先发过去文件名，其次发过去这个文件有多大，最后将文件内容拆包分发。</p><p>对应的在接收端，就知道这个文件的名称和容量的，当接收完毕之后。要校验一下文件名是否对的上的，文件大小是否对的上啊。这就是最早的FTP协议雏形</p><p>后续，随着需要越来越复杂，文件的类型也越来越多，文件体积越来越大。到这个时候，聪明的人类不断地升华这份合同，如果尽可能简单的去把问题高效解决了一直促进着计算机网络的发展；</p><h3 id="2-2-典型协议"><a href="#2-2-典型协议" class="headerlink" title="2.2 典型协议"></a>2.2 典型协议</h3><p>传输层 TCP/UDP</p><p>应用层 HTTP/FTP</p><p>网络层 IP ICMP IGMP</p><p>网络接口层 ARP RARP</p><p>TCP 传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议</p><p>UDP 用户数据报协议 是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送信息</p><p>HTTP超文本传输协议</p><p>FTP 文件传输协议</p><p>IP协议 </p><p>ICMP internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制器之间</p><p>IGMP internet组管理协议，是internet协议族中的一个组播协议，该协议运行在主机和组播路由器之间</p><p>ARP 协议是正向地址解析协议，通知已知IP，寻找对应主机的MAC地址。</p><p>RARP 是反向地址转换协议，通过MAC地址确定IP地址</p><h3 id="2-3-分层模型"><a href="#2-3-分层模型" class="headerlink" title="2.3 分层模型"></a>2.3 分层模型</h3><p>每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽</p><table><thead><tr><th>OSI/RM(理论上的标准)</th><th>TCP/IP（事实上的标准）</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td></tr><tr><td>表示层</td><td>应用层</td></tr><tr><td>会话层</td><td>应用层</td></tr><tr><td>传输层</td><td>传输层</td></tr><tr><td>网络层</td><td>网络层</td></tr><tr><td>数据链路层</td><td>链路层</td></tr><tr><td>物理层</td><td>链路层</td></tr></tbody></table><h3 id="2-4-层与协议"><a href="#2-4-层与协议" class="headerlink" title="2.4 层与协议"></a>2.4 层与协议</h3><p><img src="ceng.png" alt="image-20210329133057260"></p><p><strong>各层功能</strong></p><p><img src="department.png" alt="image-20210329133147213"></p><p>网络层 -&gt; ip</p><p>传输层 -&gt; port</p><h3 id="2-5-传输过程，"><a href="#2-5-传输过程，" class="headerlink" title="2.5 传输过程，"></a>2.5 传输过程，</h3><blockquote><p>将一条字符串从一台主机发往另外一台主机</p></blockquote><h4 id="2-5-1-链路层"><a href="#2-5-1-链路层" class="headerlink" title="2.5.1 链路层"></a>2.5.1 链路层</h4><p>两台主机传输数据，需要硬件支持，主机上得有网卡，软件得有网卡驱动。网卡对应的就是ARP协议</p><p>网卡身份证（全球唯一）：MAC地址；数据包的物理发送地址和物理接收地址</p><p><strong>ARP协议</strong>：借助IP地址获得MAC地址；</p><p><strong>RARP协议</strong>： 借助MAC地址获得IP地址；</p><h4 id="2-5-2-网络层"><a href="#2-5-2-网络层" class="headerlink" title="2.5.2 网络层"></a>2.5.2 网络层</h4><p>网络层的作用是引进一套新地址，能够区分不同计算机是否属于同一个子网络。这套地址就叫做“网络地址”，就是平时说的IP地址；</p><p>网络地址帮助确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。</p><p>IP协议： 在网络环境中唯一标识一台主机；</p><p>IP地址本质： 2进制数——点分十进制 IP地址</p><h4 id="2-5-3-传输层"><a href="#2-5-3-传输层" class="headerlink" title="2.5.3 传输层"></a>2.5.3 传输层</h4><p>TCP/UDP协议</p><p>封装port——在一台主机上唯一标识的进程；</p><h4 id="2-5-4-应用层"><a href="#2-5-4-应用层" class="headerlink" title="2.5.4 应用层"></a>2.5.4 应用层</h4><p>截止到应用层，通过链路层确定MAC地址，通过网络层确定IP地址，通过传输层由PORT定位到进程。至此目标主机确定下来了；</p><p>接下来开始传输实际的数据了，当然不会赤裸裸的将 字符串 丢网上，前面说了，发送端得确保接收端确实拿对并拿全了这个数据包才行；就便有了应用层的协议；</p><p>比如http协议，有文件名，文件MIME，请求体，请求状态等等等等；</p><h4 id="2-5-5-数据包封装的过程"><a href="#2-5-5-数据包封装的过程" class="headerlink" title="2.5.5 数据包封装的过程"></a>2.5.5 数据包封装的过程</h4><p>自上向下</p><p>待发送的原理数据</p><p>应用层</p><p>传输层 ——TCP/UDP， 确定PORT 标识主机上一个进程</p><p>网络层——IP 网络地址—— 唯一标识网络的一台主机</p><p>链路层——ARP 获取MAC地址</p><p><strong>用户层</strong></p><p>应用层</p><p><strong>kernel层</strong></p><p>传输层</p><p>网络层</p><p>链路层</p><p>封装：应用层——传输层——网络层——链路层</p><p>解封装： 链路层——网络层——传输层——应用层</p><h4 id="2-5-6-总结"><a href="#2-5-6-总结" class="headerlink" title="2.5.6 总结"></a>2.5.6 总结</h4><ol><li>mac地址</li><li>IP地址（需指定）</li><li>port（需指定）<ol><li>不能使用系统占用默认端口（80:万维网要用端口，8080：浏览器，5000+用户使用）</li><li>5000-65535（port范围）</li></ol></li></ol><h2 id="3-socket编程"><a href="#3-socket编程" class="headerlink" title="3. socket编程"></a>3. socket编程</h2><p>网络通信过程中，socket一定是成对出现的；</p><p>双向半双工  -&gt; 对讲机 （从右往左，从左往后都可以。一旦其中一端指定了，另一端就也确定了）</p><p>双向全双工 -&gt; 电话</p><p>单工通信  -&gt; 遥控器</p><p>socket是一种典型的双向全双工通信，它的实现是通信的一端封装了两个channel，对外只提供一个访问接口。</p><p><img src="socket1.png" alt="image-20210329143133584"></p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程，“IP地址+端口号”就对应一个socket，欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用socket来描述网络连接的一对一关系。</p><p>常用的socket类型有两种： 流式socket（SOCK_STREAM）和数据包式socket  (SOCK_DGRAM)。</p><p>流式是一种面向连接的socket，针对于面向连接的TCP服务应用：</p><p>数据报式socket是一种无连接的socket，对应于无连接的UDP服务应用；</p><h3 id="3-1-网络应用程序设计模式"><a href="#3-1-网络应用程序设计模式" class="headerlink" title="3.1 网络应用程序设计模式"></a>3.1 网络应用程序设计模式</h3><p>C/S模式</p><p>传统的网络应用设计模式，客户机（client）和服务器（server）模式，需要在通讯两端各自部署客户机和服务器来完成数据通信</p><p>B/S模式</p><p>浏览器（browser）/服务器（server）模式，只需要在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输</p><p>优缺点</p><p>对于C/S模式来说，其优点明显，客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活，可以在标准协议的基础上根据需求裁剪及定制。比如ftp协议的修改裁剪版；</p><p>C/S模式的缺点突出，客户端和服务器都需要有一个开发团队来完成开发，工作量成倍提升，开发周期较长，从用户角度出发， 需要将客户端安插至用户主机上，对用户主机的安全性构成威胁，这也是很多用户不愿使用C/S模式应用程序的重要原因；</p><p>B/S模式相比C/S模式而言，由于它没有独立客户端，使用标准浏览器作为客户端，只需要开发服务器端即可（服务端渲染页面可以理解为只开发服务器）。浏览器跨平台兼容，所以不受平台限制。</p><p>B/S的缺点就是网络应用支持受限，其他主要是浏览器本身的性能和os对比的性能差异；</p><h3 id="3-2-TCP的C-S架构"><a href="#3-2-TCP的C-S架构" class="headerlink" title="3.2 TCP的C/S架构"></a>3.2 TCP的C/S架构</h3><p>c/s架构的协议选择，TCP和UDP，TCP和UDP的差别就是在数据传输之前是否先建立好连接。TCP是先建立好连接，UDP是不建立好连接，直接传输数据。</p><p><img src="tcp.png" alt="image-20210329145859768"></p><p>socket 通信架构</p><ol><li>起一个server服务器，Listen方法，该方法不是监听客户端链接。而是指定IP+port，Listen函数也创建了一个socket，但是此socket不用于通信，它只用于创建通信的socket，它保存IP和port。所以后续有客户端请求的socket进来，这个socket就copy一份出去接客；</li><li>使用Listen() 返回值创建一个 Accept，阻塞监听客户端链接</li><li>当有客户端链接进来，Accept会返回一个socket，这个socket用于通信。</li><li>此刻在client调用Dial函数，也返回一个socket，用于通信。socket在通信中成对出现</li></ol><p><img src="cs.png" alt="image-20210329155637120"></p><p><strong>服务器判断关闭</strong></p><p>Read读客户端，返回0， —— 对端关闭！</p><p>nc命令发送数据时，默认在结尾自带’\n’</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"err="</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line">fmt.Println(<span class="string">"wait client"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept() <span class="comment">//  阻塞监听客户端连接请求</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Accept() err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handlerFunc(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">fmt.Println(<span class="string">"conn success"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> <span class="string">"exit\n"</span> == <span class="keyword">string</span>(buf[:n]) &#123;</span><br><span class="line">fmt.Println(<span class="string">"client exit:"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"client exit:000"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">fmt.Println(<span class="string">"accept client:"</span>, <span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-TCP通信过程"><a href="#3-3-TCP通信过程" class="headerlink" title="3.3 TCP通信过程"></a>3.3 TCP通信过程</h3><p>三次握手（连接过程），四次挥手（断开过程）</p><p><strong>1.</strong>为什么建立协议是三次握手,而关闭连接却是四次握手呢？</p><p>因为是多个半关闭状态， 某一端完全写完之后可以停止发送，但没法停止接收。须等对端发完数据，发完断开请求之后，才能关闭并通知对端；</p><p>因为服务器端的LISTEN状态下的SOCKET当收到SYN报文建连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文时发送。但是关闭连接，当收到对应FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方表示同间现在可以关闭连接了，所以这里的ACK报文和FIN报文多数情况下都是分开发送的</p><p>2.为什么<strong>TIME_WAIT</strong>状态还需要等<strong>2MSL</strong>后才能返回到<strong>CLOSED</strong>状态？</p><p>因为虽然对方同间关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISHED状态）但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文人一定被双方收到，因此处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来生发可能丢失的ACK报文</p><p><img src="three_four.png" alt="image-20210329182124969"></p><p>三次握手</p><ol><li>主动发起请求短，发送SYN</li><li>被动建立连接请求端，应答ACK同时发送SYN</li><li>主动发送请求端，发送应答ACK</li></ol><p>标志TCP三次握手建立完全 —— server： Accept（）返回， —— client Dial 返回</p><p>四次挥手</p><ol><li>主动关闭连接请求，发送FIN</li><li>被动关闭连接请求端，应答ACK （标志，半关闭完成。 —— close() </li><li>被动关闭连接请求端，发送FIN</li><li>主动关闭连接请求端，应答ACK (标志，四次挥手建立完成 —— close)</li></ol><h3 id="3-4-TCP状态"><a href="#3-4-TCP状态" class="headerlink" title="3.4 TCP状态"></a>3.4 TCP状态</h3><p>TCP状态转换图</p><p><strong>主动发起连接请求端</strong>：CLOSED——完成三次握手——ESTABLISEHED（数据通信状态）——Dial函数返回</p><p><strong>被动发起连接请求端</strong>：CLOSED2——调用Accept函数——LISTEN——完成三次握手——ESTABLISEHED（数据通信状态——Accept函数返回</p><p>​    数据传递期间——ESTABLISEHED（数据通信状态）</p><p><strong>主动关闭连接请求端</strong>：ESTABLISEHED——FIN_WAIT_2（半关闭）  ——TIME_WAIT ——2MSL——确认最后一个ACK被对端成功接收</p><p>（半关闭，TIME_WAIT，2MSL——只会出现在“主动关闭连接请求端” ）</p><p><strong>被动关闭连接请求端</strong>： ESTABLISEHED——CLOSE</p><img src="tcpstatus.jpeg" style="zoom:100%;" /><p>状态说明：</p><p><strong>CLOSED</strong>:表示初始状态</p><p><strong>LISTEN</strong>:表示服务器端的某个SOCKET处于监听状态，可以接受连接了</p><p><strong>SYN_RCVD</strong>:表示接受到了SYN报文，在正常情况下，这个状态是服务器SOCKET建立TCP连接的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这个状态，除非写一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不发送因此这个状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态</p><p><strong>ESTABLISHED</strong>:表示连接已经建立了</p><p><strong>FIN_WAIT_1</strong>:1和2真正的含义是表示等待对方的FIN报文，而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHE态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WATI_1状态，而当对方回应ACK报文后则进入到FIN_WAIT_2状态，当然在实际正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态比较难见，而FIN_WAIT_2状态还有时常可以用netstat看到</p><p><strong>FIN_WAIT_2</strong>：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据要传送给你稍后再关闭连接</p><p><strong>TIME_WAIT</strong>:表示收到了对方的FIN报文，并发送出ACK报文，就等2MSL后即可回到CLOSED可用状态了，如果FIN_WAID_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态</p><p><strong>CLOSING</strong>:这种状态比较特殊，实际情况中很少见。正常情况下，发送FIN报文后，按理来说应该先收到（或同时收到）到方的ACK报文再收到对方的FIN报文，但是CLOSING状态表示你发送FIN报文后，并没有收到的收到对方的ACK报文，反而却也收到了对方的FIN报文。发生的原因：如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接</p><p><strong>CLOSE_WAIT</strong>:表示等待关闭，当对方close一个SOCKET后发送FIN报文给自己，系统毫无疑问也会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态，接下来，实际上真正要考虑的是看你是否还有数据发送给对方，如果没有的各话，那么你也可以close这个SOCKET，发送FIN报文给对方，也即关闭连接，所以你有CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接</p><p><strong>LAST_ACK</strong>:表示被动关闭一方在发送FIN报文后，最后等待对方的ACK报文，当收到ACK报文后，也即可以进入到CLOSED可用状态了</p><h4 id="3-4-1-TCP状态-查看程序运行状态命令"><a href="#3-4-1-TCP状态-查看程序运行状态命令" class="headerlink" title="3.4.1 TCP状态 - 查看程序运行状态命令"></a>3.4.1 TCP状态 - 查看程序运行状态命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// linux</span><br><span class="line">netstat -apn|grep 8000</span><br><span class="line"></span><br><span class="line">// mac os</span><br><span class="line">netstat -a </span><br><span class="line">lsof -i:8000 // MAC OS 查看端口情况</span><br></pre></td></tr></table></figure><h3 id="3-5-UDP"><a href="#3-5-UDP" class="headerlink" title="3.5 UDP"></a>3.5 UDP</h3><p>由于UDP是“无连接”的，所以，服务器端不需要额外创建监听套接字，只需要指定好IP和port，然后监听该地址，等待客户端与之建立连接，即可通信；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建监听地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResolveUDPAddr</span><span class="params">(network, address <span class="keyword">string</span>)</span><span class="params">(*UDPAddr, error)</span></span></span><br><span class="line"><span class="comment">// 创建用户通信的socket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenUDP</span><span class="params">(network, laddr *UDPAddr)</span><span class="params">(*UDPConn, error)</span></span></span><br><span class="line"><span class="comment">// 接收udp数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *UDPConn)</span><span class="title">ReadFromUDP</span><span class="params">(b []<span class="keyword">byte</span>)</span><span class="params">(<span class="keyword">int</span> *UDPAddr, error)</span></span></span><br><span class="line"><span class="comment">// 写出数据到udp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *UDPConn)</span><span class="title">WriteToUDP</span><span class="params">(b []<span class="keyword">byte</span>, addr *UDPAddr)</span><span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure><p><strong>UDP通信</strong></p><p>无连接的，不可靠的报文传递，UDP因为无连接，所以线路取决于网络，网络状况会导致UDP丢包；只不过UDP的丢包问题系统层面不会执行重传；因此弥补这一缺陷需要在应用层对数据包进行校验；（需要封装针对UDP底层传输丢包问题的协议）</p><p><strong>TCP通信：</strong></p><p>面向连接的，可靠的数据包传输，不是说TCP不丢包，而是说TCP丢包之后会重传，这个重传指令是系统层面在做；</p><h4 id="3-5-1-udp通信流程"><a href="#3-5-1-udp通信流程" class="headerlink" title="3.5.1 udp通信流程"></a>3.5.1 udp通信流程</h4><p><img src="udp.png" alt="image-20210330000053239"></p><ol><li>创建用于通信的socket</li><li>阻塞读socket</li><li>处理读到的数据</li><li>写数据给客户端</li></ol><h4 id="3-5-2-udp通信"><a href="#3-5-2-udp通信" class="headerlink" title="3.5.2 udp通信"></a>3.5.2 udp通信</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">udpsev, err := net.ResolveUDPAddr(<span class="string">"udp"</span>, <span class="string">"127.0.0.1:8001"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ResolveUDPAddr err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">conn, err := net.ListenUDP(<span class="string">"udp"</span>, udpsev)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ListenUDP err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">n, cltAddr, err := conn.ReadFromUDP(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ReadFromUDP"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"buf..."</span>, <span class="keyword">string</span>(buf[:n]))</span><br><span class="line"></span><br><span class="line">_, err = conn.WriteToUDP([]<span class="keyword">byte</span>(<span class="string">"hi udp client"</span>), cltAddr)</span><br><span class="line">fmt.Println(<span class="string">"not got"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"writeToUdp"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"udp"</span>, <span class="string">"127.0.0.1:8001"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Dial err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(<span class="string">"from client"</span>))</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">n, err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Read err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"server send"</span>, <span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//client nc默认是TCP的，加上-u参数表示udp</span><br><span class="line">$&gt; nc -u 127.0.0.1 <span class="string">"port"</span></span><br></pre></td></tr></table></figure><p>UDP服务器：</p><ol><li>创建server端地址结构 net.ResolveUDPAddr()</li><li>创建用于通信的socket，绑定地址结构 udpConn = net.ListenUDP()</li><li>Defer udpConn.Close()</li><li>读取客户端发送数据 ReadFromUDP() 返回： n, cltAddr(客户端的IP+port)，err</li><li>写数据给客户端   WriteToUDP(“待写数据”，cltAddr)</li></ol><p>UDP客户端：</p><p>参考TCP客户端</p><p>Net.Dial(“udp”, server的IP+PORT)</p><h3 id="3-6-UDP与TCP的差异"><a href="#3-6-UDP与TCP的差异" class="headerlink" title="3.6 UDP与TCP的差异"></a>3.6 UDP与TCP的差异</h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>面向无连接</td></tr><tr><td>要求系统资源较多（系统需要一套资源维护TCP协议）</td><td>要求系统资源较少</td></tr><tr><td>TCP程序结构比较复杂</td><td>UDP程序结构较简单</td></tr><tr><td>使用流式（建立通道后源源不断的写）</td><td>使用数据包式（单次发送就完事了）</td></tr><tr><td>保证数据准确性（回执机制）</td><td>不保证数据准确性（数据包的路径每次都可能不一样）</td></tr><tr><td>保证数据顺序</td><td>不保证数据顺序</td></tr><tr><td>通讯速度较慢</td><td>通讯速度较快</td></tr></tbody></table><p>TCP： 对不稳定网络层，做完全弥补操作</p><p>UDP： 对不稳定的网络层，不作为</p><p>使用场景：</p><p>TCP：对数据传输安全性 稳定性要求较高的场合，网络文件传输，下载，上传。</p><p>UDP：对数据实时传输要求较高的场合，视频直播 在线电话会议，游戏</p><h3 id="3-7-文件传输"><a href="#3-7-文件传输" class="headerlink" title="3.7 文件传输"></a>3.7 文件传输</h3><p>流程简析</p><p>借助TCP完成文件的传输，</p><ol><li>发送方向服务端发送文件名，服务端保存该文件名</li><li>接收方（服务端）向客户端返回一个消息ok，确认文件名保存成功</li><li>发送方（客户端）收到消息后，开始向服务端发送文件数据</li><li>接收方（服务端）读取文件内容，写入到之前保存好的文件中；</li></ol><p>首先获取文件名，借助os包中stat函数来获取文件属性信息。在函数返回的文件属性中包含文件名和文件大小、Stat参数name传入的是文件访问的绝对路径。FileInfo中的Name函数可以将文件名单提取出来；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span></span><br><span class="line"><span class="comment">// A FileInfo describes a file and is returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span>       <span class="comment">// base name of the file</span></span><br><span class="line">Size() <span class="keyword">int64</span>        <span class="comment">// length in bytes for regular files; system-dependent for others</span></span><br><span class="line">Mode() FileMode     <span class="comment">// file mode bits</span></span><br><span class="line">ModTime() time.Time <span class="comment">// modification time</span></span><br><span class="line">IsDir() <span class="keyword">bool</span>        <span class="comment">// abbreviation for Mode().IsDir()</span></span><br><span class="line">Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// underlying data source (can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-1-文件属性"><a href="#3-7-1-文件属性" class="headerlink" title="3.7.1 文件属性"></a>3.7.1 文件属性</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">list := os.Args</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(list) != <span class="number">2</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path := list[<span class="number">1</span>]</span><br><span class="line">fileInfo, err := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"os.Stat err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fileInfo.Name(), fileInfo.Size()) <span class="comment">// cl.go 285</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-2-send"><a href="#3-7-2-send" class="headerlink" title="3.7.2 send"></a>3.7.2 send</h4><ol><li>提示用户使用命令行参数输入文件名，接收文件名filepath（含访问路径）</li><li>使用os.Stat（）获取文件属性，得到纯文件名fileName（去除访问路径）</li><li>主动发送链接服务器请求，结束时关闭连接</li><li>发送文件名到接收端conn.Write()</li><li>读取接收端回发的确认数据conn.Read()</li><li>判断是否为“ok”，如果是，封装函数SendFile()发送文件内容，传参filePath 和conn</li><li>只读Open文件，结束时Close文件</li><li>循环读本地文件，读到EPF，读取完毕</li><li>将读到的内容原封不动conn.Write给接收端（服务器）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendFile</span><span class="params">(conn net.Conn, filePath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// open file by readOnly</span></span><br><span class="line">f, err := os.Open(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="comment">// core, use buf loop the data until EOF</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := f.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"file send complete:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Read file err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// write to net</span></span><br><span class="line">_, err = conn.Write(buf[:n])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"is.Stat err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">list := os.Args</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(list) != <span class="number">2</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path := list[<span class="number">1</span>]</span><br><span class="line">fileInfo, err := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"os.Stat err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileName := fileInfo.Name()</span><br><span class="line">fileSize := fileInfo.Size()</span><br><span class="line">fmt.Println(<span class="string">"fileName="</span>, fileName, <span class="string">"fileSize="</span>, fileSize)</span><br><span class="line"></span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8009"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"dial tcp err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">// send file name to recv</span></span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(fileName))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn Write err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read "OK"</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">n, err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn read err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(buf[:n]) == <span class="string">"OK"</span> &#123;</span><br><span class="line">sendFile(conn, path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-3-recv"><a href="#3-7-3-recv" class="headerlink" title="3.7.3 recv"></a>3.7.3 recv</h4><ol><li>创建监听socket，程序结束时关闭</li><li>阻塞等待发送端连接Accept，程序结束时关闭conn</li><li>接收（读取）文件名，保存</li><li>回发ok</li><li>封装函数RecvFile接收客户端发送的文件内容，传参fileName和conn</li><li>按文件名creat文件，结束时close</li><li>循环read发送端网络文件内容，当读到0说明文件读取完毕</li><li>将读到的内容原封不动的Write到创建的文件中</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvFile</span><span class="params">(conn net.Conn, filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// create file deps filename</span></span><br><span class="line">f, err := os.Create(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"os.Create err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="comment">// get data from socket and write in file</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, _ := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"receive file complete"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// write into local file</span></span><br><span class="line">f.Write(buf[:n])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8009"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen tcp err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">// require filename and save</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">n, err := conn.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn Read:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename := <span class="keyword">string</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"filename="</span>, filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">// send "ok"</span></span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"OK"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write Ok err:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// require file content</span></span><br><span class="line">recvFile(conn, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-HTTP"><a href="#4-HTTP" class="headerlink" title="4. HTTP"></a>4. HTTP</h2><p>web工作方式：</p><ol><li>客户端——&gt; 访问<a href="http://www.xxx.域名-&gt;" target="_blank" rel="noopener">www.xxx.域名-&gt;</a> DNS服务，返回对应IP</li><li>客户端——》 IP+port -〉 访问网页数据（TCP连接，HTTP协议）</li></ol><p>http和URL：<br>http 规定了浏览器访问服务器进行数据通信的规则。http —— TLS、ssl——https</p><p>URL：</p><p>http请求包：</p><p>请求行： 请求方法（空格）请求文件URL（空格）协议版本（\r\n）</p><p>请求头：key:value</p><p>空行：\r\n —— 代表http请求头结束</p><h3 id="4-1-HTTP服务创建流程"><a href="#4-1-HTTP服务创建流程" class="headerlink" title="4.1 HTTP服务创建流程"></a>4.1 HTTP服务创建流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册处理函数，设置回调函数handler</span></span><br><span class="line">http.HandleFunc()</span><br><span class="line"><span class="comment">// 绑定服务器监听地址 </span></span><br><span class="line">http.ListenAndServe()</span><br></pre></td></tr></table></figure><p>Do: 静态文件服务器： 选定一个目录，存放jpg，png，txt，gif,m4a等类型文件，编写一饿服务器程序，可以给浏览器提供该目录下文件的访问服务；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  resp, err := http.Get(<span class="string">"http://xxx"</span>)</span><br><span class="line">  <span class="keyword">defer</span> resp.Body.Close() <span class="comment">// 关闭resp.Body 而不是 resp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  n,err:=resp.Body.Read(buf)</span><br><span class="line">  <span class="keyword">if</span> n==<span class="number">0</span> &#123; <span class="comment">// 网络环境，通常用0去判断是否结尾。因为channel的缘故</span></span><br><span class="line">    fmt.Println(<span class="string">"Read finish!"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err!= <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123; <span class="comment">// 本地文件读取，通常用EOF</span></span><br><span class="line">    fmt.Println(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="keyword">string</span>(buf[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go_web</title>
      <link href="2021/03/16/go-web/"/>
      <url>2021/03/16/go-web/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><p>处理请求</p><p>模版</p><p>中间件</p><p>存储数据</p><p>HTTPS，HTTP2</p><p>测试</p><p>部署</p><h2 id="2-处理请求"><a href="#2-处理请求" class="headerlink" title="2. 处理请求"></a>2. 处理请求</h2><h3 id="2-1-Create-pro"><a href="#2-1-Create-pro" class="headerlink" title="2.1 Create pro"></a>2.1 Create pro</h3><p>创建模块</p><p><code>GO111MODULE=on go mod init pro name</code> </p><p>helloworld</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hi go web"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8999"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-如何处理web请求"><a href="#2-2-如何处理web请求" class="headerlink" title="2.2 如何处理web请求"></a>2.2 如何处理web请求</h3><p>http.Handle 函数</p><p>http.HandleFunc 函数</p><h4 id="2-2-1-创建web-Server"><a href="#2-2-1-创建web-Server" class="headerlink" title="2.2.1 创建web Server"></a>2.2.1 创建web Server</h4><p>两种方式</p><p>方式一</p><p>http.ListenAndServer()</p><p>http.ListenAndServeTLS()  https 服务</p><ul><li>第一个参数是网络地址，</li><li>第二个参数为handler<ul><li>如果为nil，那么就是DefaultServeMux</li></ul></li><li>DefaultServeMux 是一个multiplexer（可以看作是一个路由器）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">"localhost:8989"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>方式二</p><p>http.Server可配置</p><p>server.ListenAndServe()</p><p>server.ListenAndServeTLS()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:= http.Server &#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br></pre></td></tr></table></figure><h4 id="2-2-2-DefaultServeMux"><a href="#2-2-2-DefaultServeMux" class="headerlink" title="2.2.2 DefaultServeMux"></a>2.2.2 DefaultServeMux</h4><p>它是一个multiplexer 多路复用器</p><p>它也是一个handler</p><p><img src="handler00.png" alt="image-20210317103838883"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"myHandler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu := myHandler&#123;&#125;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: &amp;mu,</span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个handler</p><p><img src="handler01.png" alt="image-20210317104736194"></p><p>不指定Server struct里面的Handler字段值</p><p>可以使用http.Handle将某个Handler附加到DefaultServeMux</p><ul><li>http包有一个Handle函数</li><li>ServerMux struct也有一个Handle方法</li></ul><p>如果你调用http.Handle，实际上调用的是DefaultServeMux上的Handle方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(patten <span class="keyword">string</span>, handler Handler)</span> // 注册函数</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"myHandler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hiHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *hiHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello handler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu := myHandler&#123;&#125;</span><br><span class="line">hi:= hiHandler&#123;&#125;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/mu"</span>, &amp;mu)</span><br><span class="line">http.Handle(<span class="string">"/hi"</span>, &amp;hi)</span><br><span class="line"></span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-Handler-函数-http-HandleFunc"><a href="#2-2-3-Handler-函数-http-HandleFunc" class="headerlink" title="2.2.3 Handler 函数 - http.HandleFunc"></a>2.2.3 Handler 函数 - http.HandleFunc</h4><p>handler是一个接口（interface）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler函数就是那些行为与handler类似的函数：</p><p>Handler函数的签名与ServeHTTP方法的签名一样，接收：</p><ul><li>一个http.ResponseWriter</li><li>一个指向http.Request的指针</li></ul><p>Go有一个函数类型： HandlerFunc，可以将某个具有适当签名的函数f， 适配成为一个Handler，而这个Handler具有方法 f</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"myHandler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hiHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *hiHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello handler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"weclome"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu := myHandler&#123;&#125;</span><br><span class="line">hi:= hiHandler&#123;&#125;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/mu"</span>, &amp;mu)</span><br><span class="line">http.Handle(<span class="string">"/hi"</span>, &amp;hi)</span><br><span class="line"><span class="comment">//http.HandleFunc("/weclome", welcome)</span></span><br><span class="line">http.Handle(<span class="string">"/wel"</span>, http.HandlerFunc(welcome)) <span class="comment">// handleFunc 函数内部有适配器 handlerFunc</span></span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器HandlerFunc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-五个内置handler"><a href="#2-2-4-五个内置handler" class="headerlink" title="2.2.4 五个内置handler"></a>2.2.4 五个内置handler</h4><p>NotFoundHandler 404</p><p>RedirectHandler  返回一个handler，把每个请求使用给定的状态吗跳转到指定的URl</p><ul><li>url，要跳转到的URL</li><li>code，跳转的状态吗（3XX），常见的 StatusMovedPermanently， StatusFound 或 StatusSeeOther</li></ul><p>StripPrefix 返回一个handler，它从请求URL中去掉指定的前缀，然后再调用另一个handler</p><p>TimeoutHandler</p><p>FileServer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileServer</span><span class="params">(root FileSystem)</span> <span class="title">Handler</span></span></span><br></pre></td></tr></table></figure><p>返回一个handler，使用基于root的文件系统来相应请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileSystem <span class="keyword">interface</span> &#123;</span><br><span class="line">Open(name <span class="keyword">string</span>)(File, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时需要用到操作系统的文件系统，所以还需要委托给操作系统的文件系统来获取文件；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dir <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dir)</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span><span class="params">(File,error)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) &#123;</span></span><br><span class="line"><span class="comment">//fmt.Printf(request.URL.Path)</span></span><br><span class="line"><span class="comment">//http.ServeFile(writer, request, "/webroot"+request.URL.Path)</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"><span class="comment">//http.ListenAndServe(":8000", nil)</span></span><br><span class="line">http.ListenAndServe(<span class="string">":8000"</span>, http.FileServer(http.Dir(<span class="string">"webroot"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-Request"><a href="#2-2-5-Request" class="headerlink" title="2.2.5 Request"></a>2.2.5 Request</h4><p>HTTP请求</p><p>Request</p><p>URL</p><p>Header</p><p>Body</p><h5 id="2-2-5-1-HTTP消息"><a href="#2-2-5-1-HTTP消息" class="headerlink" title="2.2.5.1 HTTP消息"></a>2.2.5.1 HTTP消息</h5><p>HTTP Request 和 HTTP Response</p><p>它们具有相同的结构</p><ul><li>请求（响应）行</li><li>0个或多个Header</li><li>空行</li><li>可选的消息体（Body）</li></ul><p>net/http 包提供了用于表示HTTP消息的结构</p><p>Request（是个struct），代表了客户端发送的HTTP请求消息</p><p>Request（是个struct），代表了客户端发送的HTTP请求消息</p><p>重要字段：</p><ul><li>URL</li><li>Header</li><li>Body</li><li>Form，PostForm，MultipartForm</li></ul><p>也可以通过Request的方法访问请求中的Cookie、URL、User Agent等消息</p><p>Request即可代表发送到服务器的请求，又可代表客户端发出的请求；</p><h5 id="2-2-5-2-请求URL"><a href="#2-2-5-2-请求URL" class="headerlink" title="2.2.5.2 请求URL"></a>2.2.5.2 请求URL</h5><p>Request的URL字段就代表了请求行（请求信息第一行）里面的部分内容</p><p>URL字段是指向url.URL类型的一个指针，url.URL是一个struct：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> &#123;</span><br><span class="line">  Scheme <span class="keyword">string</span></span><br><span class="line">  Opaque <span class="keyword">string</span></span><br><span class="line">  User *Userinfo</span><br><span class="line">  Host <span class="keyword">string</span></span><br><span class="line">  Path <span class="keyword">string</span></span><br><span class="line">  RawQuery <span class="keyword">string</span></span><br><span class="line">  Fragment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>URL通用形式</p><p><code>scheme://[userinfo@]host/path[?query][#fragment]</code></p><p>不可以斜杠开头的URL被解释为：</p><p><code>scheme:opaque[?query][#fragment]</code></p><h5 id="2-2-5-3-URL-Query"><a href="#2-2-5-3-URL-Query" class="headerlink" title="2.2.5.3 URL Query"></a>2.2.5.3 URL Query</h5><p>RawQuery 会提供实际查询的字符串</p><p><code>http://www.example/com/post?id=123&amp;thread_id=456</code></p><ul><li>它的RawQuery的值就是id=123&amp;thread_id=456</li></ul><p>还有一个简便的方法可以得到Key-Value对： 通过Request的Form字段</p><h5 id="2-2-5-4-URL-Fragment"><a href="#2-2-5-4-URL-Fragment" class="headerlink" title="2.2.5.4 URL Fragment"></a>2.2.5.4 URL Fragment</h5><p>如果从浏览器发出的请求， 那么你无法提取出Fragment字段的值；</p><ul><li>浏览器在发送请求时会把fragment部分去掉</li></ul><p>但不是所有的请求都是从浏览器发出的（例如从HTTP客户端包）</p><h5 id="2-2-5-5-Request-Header"><a href="#2-2-5-5-Request-Header" class="headerlink" title="2.2.5.5 Request Header"></a>2.2.5.5 Request Header</h5><p>请求和响应（Request、Response）的headers是通过Header类型来描述的，它是一个map，用来表述HTTP Header里的 Key-Value对；</p><p>Header map的key是string类型，value是[]string</p><p>设置key的时候会创建一个空的[]string 作为value，value里面第一个元素就是新header的值；</p><p>为指定的key添加一个新的header值，执行append操作即可</p><p> res.Header</p><ul><li>返回map</li></ul><p>r.Header[“Accept-Encoding”]</p><ul><li>返回：<code>[gzip,deflate]([]string类型)</code></li></ul><p>r.Header.Get(“Accept-Encoding”)</p><ul><li>返回： gzip，deflate(string类型)</li></ul><h5 id="2-2-5-6-Request-Body"><a href="#2-2-5-6-Request-Body" class="headerlink" title="2.2.5.6 Request Body"></a>2.2.5.6 Request Body</h5><p>请求和响应的bodies都是使用Body字段来表示的</p><p>Body是一个io.ReadCloser接口</p><ul><li>一个是Reader接口</li><li>一个是Closer接口</li></ul><p>Reader接口定义了一个Open方法：</p><ul><li>参数： []byte</li><li>返回：byte的数量、可选的错误</li></ul><p>Closer接口定义了一个Close方法：</p><ul><li>没有参数，返回可选的错误；</li></ul><p>想要读取请求body的内容，可以调用Body的Read方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8989"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/header"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, r.Header)</span><br><span class="line">fmt.Fprintln(w, r.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">fmt.Fprintln(w, r.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/post"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">length := r.ContentLength</span><br><span class="line">body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length) <span class="comment">// 创建一个长度为ContentLength的 byte slice</span></span><br><span class="line">r.Body.Read(body) <span class="comment">// 将Body里面的内容，通过Read方法读取到body中</span></span><br><span class="line">fmt.Fprintln(w, <span class="keyword">string</span>(body))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-5-7-查询参数（Query-Parameters）"><a href="#2-2-5-7-查询参数（Query-Parameters）" class="headerlink" title="2.2.5.7 查询参数（Query Parameters）"></a>2.2.5.7 查询参数（Query Parameters）</h5><p>URL Query</p><p><code>http://www/example.com/post?id=123&amp;thread_id=456</code></p><p>r.URL.RawQuery会提供实际查询的原始字符串</p><ul><li>上例的RawQuery的值就是 id=123&amp;thread_id=456</li></ul><p>r.URL.Query() 会提供查询字符串对应的 <code>map[string][]string</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url := r.URL</span><br><span class="line">query := url.Query() <span class="comment">// map[string][]string</span></span><br><span class="line">id := query[<span class="string">"id"</span>] <span class="comment">// []string&#123;"123"&#125;</span></span><br><span class="line">threadID := query.Get(<span class="string">"thread_id"</span>) <span class="comment">// "456"</span></span><br></pre></td></tr></table></figure><h4 id="2-2-6-Form"><a href="#2-2-6-Form" class="headerlink" title="2.2.6 Form"></a>2.2.6 Form</h4><h5 id="2-2-6-1-通过表单发送请求"><a href="#2-2-6-1-通过表单发送请求" class="headerlink" title="2.2.6.1 通过表单发送请求"></a>2.2.6.1 通过表单发送请求</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个HTML表单里面的数据会以<code>name-value</code>对的形式，通过POST请求发送出去</p><p>它的数据内容会放在POST请求的Body里面</p><p>但name-value对在Body里面的格式是什么样的？</p><p><strong>表单Post请求的数据格式</strong></p><p>通过POST发送的name-value数据对的格式可以通过表单的Content Type来指定，也就是enctype属性</p><p><strong>表单的enctype属性</strong></p><p>默认值是：application/x-www-form-urlencoded</p><p>浏览器被要求至少要支持： application/x-www-form-urlencoded、multipart/form-data</p><ul><li>html5的话，还需要支持text/plain</li></ul><p>如果enctype是application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。</p><p><code>first_name=alex&amp;last_name=chang</code></p><p>如果enctype是multipart/form-data，那么</p><ul><li>每一个name-value对都会被转换为一个MIME消息部分</li><li>每一个部分都有自己的Content Type 和Content Disposition</li></ul><p><img src="content.png" alt="image-20210317170418395"></p><p><strong>如何选择？</strong></p><p>简单的文本：  application/x-www-form-urlencoded</p><p>大量数据，（文件上传）： multipart-MIME</p><ul><li>甚至可以把二进制数据通过选择Base64编码，来当作文本进行发送</li></ul><p><strong>表单的GET</strong></p><p>通过表单的method属性，可以设置POST还是GET</p><p>GET请求没有Body，所有的数据都通过URL的name-value对 来发送</p><h5 id="2-2-6-2-字段"><a href="#2-2-6-2-字段" class="headerlink" title="2.2.6.2 字段"></a>2.2.6.2 字段</h5><p>Request上的函数允许我们从URL或/和Body中提取数据，通过这些字段：Form，PostForm，MultipartForm</p><p>Form里面的数据是key-value对</p><p>通常的做法是：</p><ul><li>先调用ParseForm 或 ParseMultipartForm来解析Request</li><li>然后相应的访问Form、PostForm或MultipartForm字段</li></ul><p><strong>Form</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">r.ParseForm() <span class="comment">// 解析form</span></span><br><span class="line">fmt.Fprintln(w, r.Form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>PostForm</strong></p><p>上例中，如果只想得到first_name 这个key 的value，可使用r.Form[“first_name”],它返回含有一个元素的slice: [“Dave”]</p><p>如果表单和URL里有同样的Key，那么它们都会放在一个slice里：表单里的值靠前，URL的值靠后；</p><p>如果只想要表单的key-value对，不要URL的，可以使用PostForm字段；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm() <span class="comment">// 解析form</span></span><br><span class="line">  fmt.Fprintln(w, r.Form) </span><br><span class="line">  <span class="comment">// map[first_name:[alex Leo] last_name:[ruan]]</span></span><br><span class="line">  fmt.Fprintln(w, r.PostForm) </span><br><span class="line">  <span class="comment">// map[first_name:[alex] last_name:[ruan]]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>PostForm只支持application/x-www-form-urlencoded，必须使用MultipartForm</p><p><strong>MultipartForm</strong></p><p>想要使用MultipartForm 这个字段，首先需要调用ParseMultipartForm这个方法；</p><ul><li>该方法会在必要时调用ParseForm方法</li><li>参数是需要读取数据的长度</li></ul><p>MultipartForm只包含表单的key-value对</p><p>返回的类型是一个struct而不是map，这个struct里有两个map：</p><ul><li>key是string，value是[]string</li><li>空的（key是string， value是文件）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseMultipartForm(<span class="number">1024</span>) <span class="comment">//1024 为字节数</span></span><br><span class="line">  fmt.Fprintln(w, r.MultipartForm)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &amp;&#123;map[first_name:[alex] last_name:[ruan]] map[]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>MultipartReader</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span><span class="title">MultipartReader</span><span class="params">()</span><span class="params">(*multipart.Reader,error)</span></span></span><br></pre></td></tr></table></figure><p>如果是multipart/form-data或multipart混合的POST请求：</p><ul><li>MultipartReader 返回一个MIME multipart reader</li><li>否则返回nil和一个错误</li></ul><p>可以使用该函数代替ParseMultipartForm来把请求的body作为stream进行处理</p><ul><li>不是把表单作为一个对象来处理的，不是一次性获得整个map</li></ul><p>逐个检查来自表单的值，然后每次处理一个；</p><h5 id="2-2-6-3-FormValue-amp-PostFormValue方法"><a href="#2-2-6-3-FormValue-amp-PostFormValue方法" class="headerlink" title="2.2.6.3 FormValue &amp; PostFormValue方法"></a>2.2.6.3 FormValue &amp; PostFormValue方法</h5><p>FormValue方法会返回Form字段中指定key对应的第一个value</p><ul><li>无需调用ParseForm或ParseMultipartForm</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8000/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, r.FormValue(<span class="string">"first_name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Leo  来自于查询字符串，来自表单里面的值靠前，来自url的靠后，FormValue只取一个值（如果enctype为application/x-www-form-urlencoded的话）；</span></span><br></pre></td></tr></table></figure><p>PostFormValue方法也一样，但只能读取PostForm</p><p>FormValue和PostFormValue都会调用ParseMultipartForm方法</p><p>但如果表单的enctype设为multipart/form-data，那么即使你调用ParseMultipartForm方法，也无法通过FormValue获得想要的值；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8000/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseMultipartForm(<span class="number">1024</span>) <span class="comment">//1024 为字节数</span></span><br><span class="line">  fmt.Fprintln(w, r.FormValue(<span class="string">"first_name"</span>))</span><br><span class="line">  fmt.Fprintln(w,r.PostFormValue(<span class="string">"first_name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Leo</span></span><br><span class="line"><span class="comment">// alex</span></span><br></pre></td></tr></table></figure><h5 id="2-2-6-4-上传文件（Files）"><a href="#2-2-6-4-上传文件（Files）" class="headerlink" title="2.2.6.4 上传文件（Files）"></a>2.2.6.4 上传文件（Files）</h5><p>Multipart/form-data最常见的应用场景就是上传文件（例子）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8000/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">r.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fileHeader:= r.MultipartForm.File[<span class="string">"uploaded"</span>][<span class="number">0</span>]</span><br><span class="line">file,err := fileHeader.Open() <span class="comment">// 从File字段 获得的FileHeader，调用其Open获得文件。</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file) <span class="comment">// 读取文件内容到byte切片里</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8000"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Printf(request.URL.Path)</span><br><span class="line">http.ServeFile(writer, request, <span class="string">"webroot2"</span>+request.URL.Path)</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FormFile方法</p><ul><li>上传文件还有一个简便方法：FormFile</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">  file,_,err := r.FormFile(<span class="string">"uploaded"</span>)</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    data, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Fprintln(w, <span class="keyword">string</span>(data))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无需调用ParseMultipartForm方法</p><p>返回指定key对应的第一个value</p><p>同时返回File和FileHeader，以及错误信息</p><p>如果只上传一个文件，那么这种方式会快一些</p><h5 id="2-2-6-5-POST-JSON"><a href="#2-2-6-5-POST-JSON" class="headerlink" title="2.2.6.5 POST JSON"></a>2.2.6.5 POST JSON</h5><p>不是所有的POST请求都来自Form</p><p>有很多不同的方式对POST请求编码</p><ul><li>application/x-www-form-urlencoded</li><li>application/json</li></ul><p>ParseForm方法无法处理application/json</p><h4 id="2-2-7-ResponseWriter"><a href="#2-2-7-ResponseWriter" class="headerlink" title="2.2.7 ResponseWriter"></a>2.2.7 ResponseWriter</h4><p>从服务器向客户端返回响应需要使用ResponseWriter</p><p>ResponseWriter是一个接口，handler用它来返回响应</p><p>真正支撑ResponseWriter的幕后struct是非导出的http.response</p><p>问题：</p><p>为什么Handler的ServeHTTP（w ResponseWriter, r*Request）,只有一个是指针类型？而w是按值传递的吗？</p><p>ResponseWriter本身是一个interface，而它代表了一个指针，这个指针指向response这个struct的。所以它也可以看作是一个指针。所以它的传递也是按引用进行传递的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">  Header() Header</span><br><span class="line">  Write([]<span class="keyword">byte</span>)(<span class="keyword">int</span> error)</span><br><span class="line">  WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> response <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span> <span class="title">Header</span><span class="params">()</span><span class="title">Header</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span> <span class="title">Write</span><span class="params">()</span><span class="title">Writer</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span> <span class="title">WriteHeader</span><span class="params">()</span><span class="title">WriteHeader</span></span></span><br><span class="line"><span class="comment">// 所以说 response指针就是实现了ResponseWriter接口，所以ResponseWriter接口就代表着 response指针；</span></span><br></pre></td></tr></table></figure><h5 id="2-2-7-1-写入到ResponseWriter"><a href="#2-2-7-1-写入到ResponseWriter" class="headerlink" title="2.2.7.1 写入到ResponseWriter"></a>2.2.7.1 写入到ResponseWriter</h5><p>write方法接收一个byte切片作为参数，然后把它写入到HTTP响应的Body里面；</p><p>如果在Write方法被调用时，header里面没有设定content type，那么数据的前512字节就会被用来检测content type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">str := <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;&lt;go web&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8000"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/write"</span>, writeExample)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i localhost:8000/write</span><br></pre></td></tr></table></figure><h5 id="2-2-7-2-WriteHeader方法"><a href="#2-2-7-2-WriteHeader方法" class="headerlink" title="2.2.7.2 WriteHeader方法"></a>2.2.7.2 WriteHeader方法</h5><p>WriteHeader方法接收一个整数类型（HTTP状态码）作为参数，并把它作为HTTP响应的状态码返回</p><p>如果该方法没有显式调用，那么在第一次调用Write方法前，会隐式的调用WriteHeader(http.StatusOK)</p><ul><li>所以WriteHeader主要用来发送错误类的HTTP状态吗</li></ul><p>调用完WriteHeader方法之后，仍然可以写入到ResponseWriter，但无法再修改header了；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">str := <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;go cProgramming&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeaderExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">w.WriteHeader(<span class="number">501</span>)</span><br><span class="line">fmt.Fprintln(w, <span class="string">"No such service, try next port"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8000"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/write"</span>, writeExample)</span><br><span class="line">http.HandleFunc(<span class="string">"/writeheader"</span>, writeHeaderExample)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-7-3-Header方法"><a href="#2-2-7-3-Header方法" class="headerlink" title="2.2.7.3 Header方法"></a>2.2.7.3 Header方法</h5><p>Header方法返回headers的map，可以进行修改</p><p>修改后的headers将会体现在返回给客户端的HTTP响应里；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headerExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">w.Header().Set(<span class="string">"Location"</span>,<span class="string">"https://reactnative.dev/"</span>)</span><br><span class="line">w.WriteHeader(<span class="number">302</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="red.png" alt="image-20210317232645674"></p><p>json</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">w.Header().Set(<span class="string">"Content-Type"</span>,<span class="string">"application/json"</span>)</span><br><span class="line">post:= &amp;Post&#123;</span><br><span class="line">User: <span class="string">"alex"</span>,</span><br><span class="line">Threads: []<span class="keyword">string</span>&#123;<span class="string">"first"</span>,<span class="string">"second"</span>,<span class="string">"third"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">json,_ := json2.Marshal(post)</span><br><span class="line">w.Write(json)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;"User":"alex","Threads":["first","second","third"]&#125;</span></span><br></pre></td></tr></table></figure><h5 id="2-2-7-4-内置的Response"><a href="#2-2-7-4-内置的Response" class="headerlink" title="2.2.7.4 内置的Response"></a>2.2.7.4 内置的Response</h5><p>NotFound函数，包装一个404状态吗和一个额外的信息</p><p>ServeFile函数，从文件系统提供文件，返回请求者</p><p>ServerContent函数，它可以把实现了io.ReadSeeker接口的任何东西里面的内容返回给请求者</p><ul><li>还可以处理Range请求（范围请求），如果只请求了资源的一部分内容，那么ServeContent就可以如此响应，而ServeFile或io.Copy则不行</li></ul><p>Redirect函数，告诉客户端重定向到另一个URL</p><h2 id="3-connect-sql"><a href="#3-connect-sql" class="headerlink" title="3.connect sql"></a>3.connect sql</h2><h3 id="3-1-Open"><a href="#3-1-Open" class="headerlink" title="3.1 Open"></a>3.1 Open</h3><p>sql.Open()</p><ul><li>参数1 数据库驱动名称</li><li>参数2 数据源名称</li><li>返回值 得到一个指向sql.DB这个struct的指针</li></ul><p>sql.DB是用来操作数据库的，它代表了0个或者多个底层连接的池，这些连接由sql包来维护，sql包会自动的创建和释放这些连接；</p><p>它对于多个goroutine并发的使用是安全的；</p><p>Open()函数并不会连接数据库，甚至不回验证其参数，它只是把后续连接到数据库所必需的structs给设置好了；</p><p>而真正的连接是在被需要的时候才进行懒设置的；</p><p>sql.DB不需要进行关闭（当然你想关闭也是可以的）</p><p>它就是用来处理数据库的，而不是实际的连接</p><p>这个抽象包含了数据库连接的池，而且会对此进行维护</p><p>在使用sql.DB的时候，可以定义它的全局变量进行使用，也可以将它传递函数/方法里；</p><h3 id="3-2-如何获得驱动"><a href="#3-2-如何获得驱动" class="headerlink" title="3.2 如何获得驱动"></a>3.2 如何获得驱动</h3><p>正常的做法是使用sql.Register()函数、数据库驱动的名称和一个实现了driver.Driver接口的struct，来注册数据库的驱动。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql.Register(<span class="string">"sqlserver"</span>, &amp;drv&#123;&#125;)</span><br></pre></td></tr></table></figure><p>但是之前的例子却没有写这句话，为什么？</p><ul><li>因为Sql Server的驱动，是在这个包被引入的时候进行了自我注册</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当go-sql-driver包被引入的时候，它的init函数将会运行并进行自我注册（在Go语言里，每个包的init函数都会在自动的调用）</p><p>在引入go-sql-driver 包的时候，把该包的名称设置为下划线_，这是因为我们不直接使用数据库驱动（只需要它起的“副作用”），我们只使用database/sql</p><p>这样，如果未来升级驱动，也无需改变代码</p><p>Go语言没有提供官方的数据库驱动，所有的数据库驱动都是第三方驱动，但是它们都遵循sql.driver包里面定义的接口</p><h3 id="3-3-下载驱动"><a href="#3-3-下载驱动" class="headerlink" title="3.3 下载驱动"></a>3.3 下载驱动</h3><p><code>go get github.com/go-sql-driver/mysql</code></p><h3 id="3-4-PingContext"><a href="#3-4-PingContext" class="headerlink" title="3.4 PingContext"></a>3.4 PingContext</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DB)</span> <span class="title">PingContext</span></span></span><br></pre></td></tr></table></figure><p>db.PingContext 函数是用来验证与数据库的连接是否仍然有效，如有必要则建立一个连接</p><p>这个函数需要一个Context（上下文）类型的参数，这种类型可以携带截止时间，取消信息和其它请求范围的值，并且可以横跨API边界和进程。</p><p>上例中，创建context使用的是context.Background()函数，该函数返回一个非nil的空Context，它不会被取消，它没有值，没有截止时间；</p><p>它通常在main函数，初始化或测试中，作为传入请求的顶级Context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">err = db.PingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Connected"</span>)</span><br></pre></td></tr></table></figure><h3 id="3-5-查询"><a href="#3-5-查询" class="headerlink" title="3.5 查询"></a>3.5 查询</h3><p>sql.DB类型上用于查询的方法有：</p><ul><li>Query</li><li>QueryRow （返回一行）</li><li>QueryContext</li><li>QueryRowContext</li></ul><h4 id="3-5-1-Query"><a href="#3-5-1-Query" class="headerlink" title="3.5.1 Query"></a>3.5.1 Query</h4><p>返回的类型是 type Rows struct{}</p><p>Rows的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回结果的列的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">ColumnTypes</span><span class="params">()</span><span class="params">([]*ColumnType, error)</span></span></span><br><span class="line"><span class="comment">// 返回所有列名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Columns</span><span class="params">()</span><span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="comment">// 查询遍历中的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 遍历结果集，每次读取一行，返回true说明还有数据 false表示读到最后一行了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 如果查询包含多个结果集，使用NextResultSet。它会准备好下一个结果集用来读取。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">NextResultSet</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Scan</span><span class="params">(dest...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><h4 id="3-5-2-QueryRow"><a href="#3-5-2-QueryRow" class="headerlink" title="3.5.2 QueryRow"></a>3.5.2 QueryRow</h4><p>返回类型是 type Row struct{}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询遍历中的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Row)</span> <span class="title">Scan</span><span class="params">(dest...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><h3 id="3-6-更新"><a href="#3-6-更新" class="headerlink" title="3.6 更新"></a>3.6 更新</h3><p>sql.DB类型上用于更新（执行命令）的方法有：</p><p>Exec</p><p>ExecContext</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a * app)</span><span class="title">Update</span><span class="params">()</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">  _,err := db.Exc(<span class="string">"sql 语句"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-其它"><a href="#3-7-其它" class="headerlink" title="3.7 其它"></a>3.7 其它</h3><p>Ping</p><p>PingContext</p><p>Prepare</p><p>PrepareContext</p><p>Transactions</p><ul><li>Begin</li><li>BeginTx</li></ul><h2 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h2><p>需要给架构增加Controller层</p><p>Controller的角色</p><ul><li>main(): 设置类工作，比如设置http server</li><li>Controller:<ul><li>静态资源 （比如css，js文件）</li><li>把不同的请求送到不同的controller进行处理</li></ul></li></ul><p><img src="ctrl.png" alt="image-20210318180336477"></p><p>go语言提供一个前置的ctrl，所有进来的请求都会经过ctrl，然后由ctrl分发</p><h2 id="5-json"><a href="#5-json" class="headerlink" title="5. json"></a>5. json</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span> <span class="string">`json:"id"`</span></span><br><span class="line">User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Threads []<span class="keyword">string</span> <span class="string">`json:"thread"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-类型映射"><a href="#5-1-类型映射" class="headerlink" title="5.1 类型映射"></a>5.1 类型映射</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Go <span class="keyword">bool</span>: JSON boolean</span><br><span class="line">Go <span class="keyword">float64</span>: JSON 数值</span><br><span class="line">Go <span class="keyword">string</span>; JSON strings</span><br><span class="line">Go <span class="literal">nil</span>: JSON null</span><br></pre></td></tr></table></figure><h3 id="5-2-未知结构的JSON如何映射"><a href="#5-2-未知结构的JSON如何映射" class="headerlink" title="5.2 未知结构的JSON如何映射"></a>5.2 未知结构的JSON如何映射</h3><p>Map[string]interface{} 可以存储任意json对象</p><p>[]interface{} 可以存储任意的JSON数组</p><h3 id="5-3-读取JSON"><a href="#5-3-读取JSON" class="headerlink" title="5.3 读取JSON"></a>5.3 读取JSON</h3><p>需要一个解码器： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dec := json.NewDecoder(r.Body)</span><br></pre></td></tr></table></figure><p>参数需要实现Reader接口</p><p>在解码器上进行编码： dec.Decode(&amp;query)</p><h3 id="5-4-写入JSON"><a href="#5-4-写入JSON" class="headerlink" title="5.4 写入JSON"></a>5.4 写入JSON</h3><p>需要一个编码器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enc := json.NewEncoder(w)</span><br></pre></td></tr></table></figure><p>参数需要实现Writer接口</p><p>编码 ： enc.Encode(results)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">json</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line">dec := json2.NewDecoder(r.Body)</span><br><span class="line">company := Company&#123;&#125;</span><br><span class="line">err:= dec.Decode(&amp;company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc := json2.NewEncoder(w)</span><br><span class="line">err = enc.Encode(company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Marshal 和 Unmarshal</strong></p><p>Marshal （编码）： 把go struct转化为json格式</p><ul><li>Marshalindent, 带缩进</li></ul><p>Unmarshal（解码）： 把json转化为go struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span> <span class="string">`json:"id"`</span></span><br><span class="line">User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Threads []<span class="keyword">string</span> <span class="string">`json:"thread"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  jsonStr := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"id": 123,</span></span><br><span class="line"><span class="string">"name": "alex",</span></span><br><span class="line"><span class="string">"thread": "asia"</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">c:= Company&#123;&#125;</span><br><span class="line">_ = json2.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;c)</span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line">bytes,_ := json2.Marshal(c)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">bytes1, _ := json2.MarshalIndent(c,<span class="string">""</span>,<span class="string">"  "</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;123 alex [asia]&#125;</span></span><br><span class="line"><span class="comment">//&#123;"id":123,"user":"alex","thread":["asia"]&#125;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="string">"user"</span>: <span class="string">"alex"</span>,</span><br><span class="line">  <span class="string">"thread"</span>: [</span><br><span class="line">    <span class="string">"asia"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式的区别</strong></p><p>针对string或bytes：</p><ul><li>Marshal =&gt; string</li><li>Unmarshal &lt;= string</li></ul><p>针对stream：</p><ul><li>Encode =&gt; Stream, 把数据写入到 io.Writer</li><li>Decode &lt;= Stream, 从io.Reader 读取数据</li></ul><h2 id="6-中间件"><a href="#6-中间件" class="headerlink" title="6. 中间件"></a>6. 中间件</h2><p><img src="middleware.png" alt="image-20210319133248463"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(addr <span class="keyword">string</span>, handler Handler)error</span><br><span class="line"><span class="comment">// handler 如果是nil： DefaultServeMux</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想创建handler，必须实现handler接口，需要实现ServeHTTP这个方法</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-创建中间件"><a href="#6-1-创建中间件" class="headerlink" title="6.1 创建中间件"></a>6.1 创建中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">  Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyMiddleware)</span> <span class="title">ServeHTTP</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在next handler之前做一些事情</span></span><br><span class="line">  m.Next.ServeHTTP(w, r) <span class="comment">// 将该请求转发到下一个handler中</span></span><br><span class="line">  <span class="comment">// 在 next handler之后做一些其它事情（对响应进行处理，中间件中创建的资源进行处理，此时响应仍然是没有返回至客户端的）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m.Next.ServeHTTP(w, r) 将该请求转发到下一个handler中。至于下一个handler是什么，这个Next设置成什么，下一个handler就是什么，有可能是nil。在web应用中，如果只有一个中间件的话。那么next就是DefaultServeMux。它就会将这个请求 进行路由。然后进程的处理。</p><p>中间件的用途</p><p>Logging</p><p>安全（请求超时，用户身份认证）</p><p>响应压缩</p><h3 id="6-2-使用请求上下文"><a href="#6-2-使用请求上下文" class="headerlink" title="6.2 使用请求上下文"></a>6.2 使用请求上下文</h3><p><img src="ctx.png" alt="image-20210319144135404"></p><p>比如中间件设置了请求超时，而这个请求到数据库的时候，这个数据库将会花费很长时间。这个时候就需要让访问数据库的代码知道设置了查询超时时间。这就需要使用到上下文来解决；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Request)</span> <span class="title">Context</span><span class="params">()</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">// 返回当前请求的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Request)</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span><span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">// 基于Context 进行 修改，（实际上）创建一个新的Context</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">  <span class="comment">// 返回一个channel，用来做取消操作的。一旦context取消了。它就会接收到一个信号。这个channel也就关闭了；。比如在操作截止时间就会接到这个信号</span></span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 取消操作</span></span><br><span class="line">  <span class="comment">// 如果 Done 这个channel没有关闭的话，error就是nil，如果它关闭了，也就是context被取消了。那么error就存放被取消的原因；以后每次调用error都会显示同一个错误；</span></span><br><span class="line">  Err()error</span><br><span class="line">  <span class="comment">// 使用参数key从context获取一些信息，得到的这些信息可以从架构中的一个层传给另一个层；</span></span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法都是用于读取，不能进行设置；</p><p>Context API - 可以返回新Context</p><ul><li>WithCancal() ,它有一个CancelFunc</li><li>WithDeadline(), 带有一个时间戳 （time.Time）</li><li>WithTimeout(), 带有一个具体的时间段（time.Duration）</li><li>WithValue(), 在里面可以添加一些值；</li></ul><h2 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h2><p>HTTP请求的过程</p><p><img src="http.png" alt="image-20210319155909596"></p><p>在http里面，参数都是以明文进行传输的。在客户端和服务端之间其它的东西，比如某个中间人/中间服务器也能懂得传输的信息。所以说，这种传输是非常不安全的 ；</p><p>HTTPS</p><p>https会稍微给传输层做一点改变，它不是直接在TCP上面传输数据的。会添加一个TLS层，在传输数据的时候，数据首先会被加密。加密之后只有客户端和服务器能够懂得这个加密数据里面真实的内容。中间人/中间服务器即使能获得数据，但是依然无法解析出来内容；也就无法懂得它真正代表的意思了；</p><h3 id="7-1-HTTP-ListenAndServeTLS"><a href="#7-1-HTTP-ListenAndServeTLS" class="headerlink" title="7.1 HTTP.ListenAndServeTLS"></a>7.1 HTTP.ListenAndServeTLS</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServeTLS 四个参数</span></span><br><span class="line">addr</span><br><span class="line">certFile</span><br><span class="line">keyFile</span><br><span class="line">handler</span><br><span class="line">http.ListenAndServeTLS()</span><br></pre></td></tr></table></figure><p>go 提供了生成证书的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go run /usr/<span class="built_in">local</span>/go/src/crypto/tls/generate_cert.go -h</span><br><span class="line"></span><br><span class="line">go run /usr/<span class="built_in">local</span>/go/src/crypto/tls/generate_cert.go -host localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># time  wrote cert.pem</span></span><br><span class="line"><span class="comment"># time  wrote key.pem</span></span><br><span class="line"></span><br><span class="line">http.ListenAndServeTLS(<span class="string">":8080"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, nil)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Request Headers</span><br><span class="line">  :authority: localhost:8080</span><br><span class="line">  :method: GET</span><br><span class="line">  :path: /json</span><br><span class="line">  :scheme: https</span><br><span class="line">  accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">  accept-encoding: gzip, deflate, br</span><br><span class="line">  accept-language: zh-CN,zh;q=0.9</span><br><span class="line">  cache-control: no-cache</span><br><span class="line">  cookie: </span><br><span class="line">  pragma: no-cache</span><br><span class="line">  sec-ch-ua: "Google Chrome";v="89", "Chromium";v="89", ";Not A Brand";v="99"</span><br><span class="line">  sec-ch-ua-mobile: ?0</span><br><span class="line">  sec-fetch-dest: document</span><br><span class="line">  sec-fetch-mode: navigate</span><br><span class="line">  sec-fetch-site: none</span><br><span class="line">  sec-fetch-user: ?1</span><br><span class="line">  upgrade-insecure-requests: 1</span><br><span class="line">  user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36</span><br></pre></td></tr></table></figure><p>Headers 以：开头，在go web应用里面，如果从http转到https，那么此应用会自动从http1.1 升级到http2协议。</p><h2 id="8-HTTP-2"><a href="#8-HTTP-2" class="headerlink" title="8. HTTP/2"></a>8. HTTP/2</h2><p>http2带来效率提升的原因</p><p>Http1.1发送请求</p><ol><li>首先建立tcp连接</li><li>发送请求时，通常header 和 body捆绑在一起发送的。尽管有时候body比较大，会被分到不同的包中发送。</li><li>响应返回的时候，基本和请求类似，也是header和body捆绑发送；</li></ol><p>这就导致header无法被压缩，header描述了请求或者响应里面的内容比如content-type，length等等，有些时候header比较大。</p><p>HTTP2</p><ol><li>依旧建立TCP服务</li><li>在TCP里建立stream，stream是在TCP里面独立通信的管道。各个stream不会相互影响。但是允许在同一个链接里面让多个信息来回发送但不相互干扰。在stream里面是通过Frame来发送消息的；所以它在发送请求的时候，不是将header和body绑在一起发送；而是将消息拆成多个Frame进行发送的；而每个Frame又可以单独的进行优化；</li></ol><p>有哪些Frame</p><p><img src="http2.png" alt="image-20210319172332556"></p><p>客户端往服务端发送header的时候，服务器知道它将接收到header。这个过程就能使用到一些压缩算法。</p><h3 id="8-1-http2的特点"><a href="#8-1-http2的特点" class="headerlink" title="8.1 http2的特点"></a>8.1 http2的特点</h3><ul><li>请求多路复用，可以在同一个TCP连接使用stream发送多个请求；</li><li>Header压缩</li><li>默认安全<ul><li>HTTP， 但很多决定不支持HTTP</li><li>HTTPS</li></ul></li><li>Server Push</li></ul><p><strong>没有Server push</strong></p><p><img src="noserverpush.png" alt="image-20210319172951647"></p><p>没有Server push的时候，请求是一来一回的。</p><p><strong>server push</strong></p><p><img src="serverpush.png" alt="image-20210319173601377"></p><p>节省了一个步骤，从客户端往服务端请求app.css的部分；</p><h2 id="9-部署"><a href="#9-部署" class="headerlink" title="9. 部署"></a>9. 部署</h2><p>Nohup</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./it &amp;</span><br></pre></td></tr></table></figure><p>守护进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; vim /etc/systemd/system/go-web.service</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Go web App running on xxx</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/solenovex/it/it</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">RestartSec=10</span><br><span class="line">KillSignal=SINGINT</span><br><span class="line">SyslogIdentifier=go-web-example</span><br><span class="line">User=solenovex</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start go-web.service</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">sudo systemctl status go-web.service</span><br></pre></td></tr></table></figure><h2 id="10-IM项目"><a href="#10-IM项目" class="headerlink" title="10 IM项目"></a>10 IM项目</h2><h3 id="10-1-构建基础server"><a href="#10-1-构建基础server" class="headerlink" title="10.1 构建基础server"></a>10.1 构建基础server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建</span></span><br><span class="line">go build -o server main.go server.go</span><br><span class="line">./server</span><br><span class="line">$&gt; connect success</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line">nc 127.0.0.1 8888</span><br></pre></td></tr></table></figure><h3 id="10-2-用户上线功能"><a href="#10-2-用户上线功能" class="headerlink" title="10.2 用户上线功能"></a>10.2 用户上线功能</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要给server补充两个属性, OnlineMap 和 channel</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Ip   <span class="keyword">string</span></span><br><span class="line">Port <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/user.png" alt="image-20210323180444298"></p><p><strong>OnlineMap</strong></p><p>key： 当前用户名</p><table><thead><tr><th>user.Name</th><th>User</th></tr></thead><tbody><tr><td>Name1</td><td>User1</td></tr><tr><td>Name2</td><td>User2</td></tr><tr><td>Name3</td><td>user3</td></tr></tbody></table><p>记录当前有哪些用户在线，一个客户端就是一个用户；</p><p>用一个User类来表示客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User &#123;</span><br><span class="line">  username</span><br><span class="line">  conn <span class="comment">// 可以跟客户端进行通信</span></span><br><span class="line">  channel <span class="comment">// 每个用户都绑定一个channel，专门用来向user实例对应的客户端来发消息的；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>channel</strong></p><p>每个用户都绑定一个channel，专门用来向user实例对应的客户端来发送消息。比如服务器往客户端1发送消息时，服务器就应该将消息发给User1.channel。channel又该如何将消息发送给客户端呢？</p><p>每个User实例中都会有一个goroutine，此goroutine应该阻塞监听channel，查看它当中是否有数据存在。一旦监听到数据，立即将数据通过conn写到对应的客户端中；</p><p><strong>Message</strong></p><p>message本质上是个channel，它属于server的channel。Message是用来将消息进行广播的。（如果当前有一条消息需要让所有客户端都收听到的话）</p><p>如何广播？</p><p>将消息发送到Message的管道中，Message中除了有管道，还需要有一个goroutine。不断在监听当前管道。一旦监听到有消息时，遍历OnlineMap依次将消息发送给每个的user的channel中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server</span></span><br><span class="line">$&gt; ./server</span><br><span class="line"><span class="comment"># client1</span></span><br><span class="line">$&gt; nc 127.0.0.1 8888</span><br><span class="line">$&gt;[127.0.0.1:51375]127.0.0.1:51375:online <span class="comment">#1</span></span><br><span class="line">$&gt;[127.0.0.1:51753]127.0.0.1:51753:online <span class="comment">#2</span></span><br><span class="line">$&gt;[127.0.0.1:51979]127.0.0.1:51979:online <span class="comment">#3</span></span><br><span class="line"><span class="comment"># client2</span></span><br><span class="line">$&gt; nc 127.0.0.1 8888</span><br><span class="line">$&gt;[127.0.0.1:51753]127.0.0.1:51753:online <span class="comment">#2</span></span><br><span class="line">$&gt;[127.0.0.1:51979]127.0.0.1:51979:online <span class="comment">#3</span></span><br><span class="line"><span class="comment"># client3</span></span><br><span class="line">$&gt; nc 127.0.0.1 8888</span><br><span class="line">$&gt; [127.0.0.1:51979]127.0.0.1:51979:online <span class="comment">#3</span></span><br></pre></td></tr></table></figure><h3 id="10-3-用户消息广播机制"><a href="#10-3-用户消息广播机制" class="headerlink" title="10.3 用户消息广播机制"></a>10.3 用户消息广播机制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#im1</span></span><br><span class="line"><span class="comment"># server</span></span><br><span class="line">$&gt; ./server</span><br><span class="line"><span class="comment"># client1</span></span><br><span class="line">$&gt; nc 127.0.0.1 8888</span><br><span class="line">$&gt; [127.0.0.1:55858]127.0.0.1:55858:online</span><br><span class="line">$&gt; [127.0.0.1:55894]127.0.0.1:55894:online</span><br><span class="line">$&gt; [127.0.0.1:55894]127.0.0.1:55894:hello</span><br><span class="line"><span class="comment"># client2</span></span><br><span class="line">$&gt; nc 127.0.0.1 8888</span><br><span class="line">$&gt; [127.0.0.1:55894]127.0.0.1:55894:online</span><br><span class="line">$&gt; hello</span><br><span class="line">$&gt; [127.0.0.1:55894]127.0.0.1:55894:hello</span><br></pre></td></tr></table></figure><h3 id="10-4-用户业务层封装"><a href="#10-4-用户业务层封装" class="headerlink" title="10.4 用户业务层封装"></a>10.4 用户业务层封装</h3><h3 id="10-5-在线用户查询"><a href="#10-5-在线用户查询" class="headerlink" title="10.5 在线用户查询"></a>10.5 在线用户查询</h3><h3 id="10-6-修改用户名"><a href="#10-6-修改用户名" class="headerlink" title="10.6 修改用户名"></a>10.6 修改用户名</h3><p>定义一种消息格式</p><p><code>rename|newUsername</code></p><h3 id="10-7-超时强T"><a href="#10-7-超时强T" class="headerlink" title="10.7 超时强T"></a>10.7 超时强T</h3><p>用户的任意消息表示用户为活跃，长时间不发消息则视为超时，可强制下线。</p><p>那如何判断当前用户是否活跃；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现原理</span></span><br><span class="line">当服务端能从客户端 Read到一条信息的，开启定时器；等定时器达到一定阈值的时候，则判定客户端失联</span><br></pre></td></tr></table></figure><h3 id="10-8-私聊"><a href="#10-8-私聊" class="headerlink" title="10.8 私聊"></a>10.8 私聊</h3><p>同修改用户名一样，也是定义一种消息格式</p><p><code>to|username|send message</code></p><h3 id="10-9-客户端"><a href="#10-9-客户端" class="headerlink" title="10.9 客户端"></a>10.9 客户端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build</span></span><br><span class="line">$&gt; go build -o server main.go server.go user.go</span><br><span class="line">$&gt; go build -o client client.go</span><br></pre></td></tr></table></figure><h2 id="11-gin"><a href="#11-gin" class="headerlink" title="11. gin"></a>11. gin</h2><h3 id="11-1-创建项目"><a href="#11-1-创建项目" class="headerlink" title="11.1 创建项目"></a>11.1 创建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#create</span></span><br><span class="line">Environment: https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line"><span class="comment"># import "github.com/gin-gonic/gin"</span></span><br><span class="line">go mod tidy <span class="comment"># 查漏补缺,类似 npm install</span></span><br></pre></td></tr></table></figure><h3 id="11-2-CLD分层"><a href="#11-2-CLD分层" class="headerlink" title="11.2 CLD分层"></a>11.2 CLD分层</h3><ul><li>协议处理层： 支持各种协议</li><li>Controller： 服务的入口，负责处理路由、参数校验、请求转发</li><li>Logic/Service： 逻辑（服务）层，负责处理业务员逻辑</li><li>DAO/Repository：负责数据与存储相关功能</li></ul><h3 id="11-3-通用脚手架"><a href="#11-3-通用脚手架" class="headerlink" title="11.3 通用脚手架"></a>11.3 通用脚手架</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">go_boilerplate</span><br><span class="line">├── config.yaml <span class="comment"># 全局配置器</span></span><br><span class="line">├── dao         <span class="comment"># dao层</span></span><br><span class="line">│   ├── mysql</span><br><span class="line">│   │   └── mysql.go</span><br><span class="line">│   └── redis</span><br><span class="line">│       └── redis.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── logger <span class="comment"># 日志</span></span><br><span class="line">│   └── logger.go</span><br><span class="line">├── main.go</span><br><span class="line">├── modules <span class="comment"># modules 备用</span></span><br><span class="line">├── pkg <span class="comment"># pkg备用</span></span><br><span class="line">├── routes </span><br><span class="line">│   └── routes.go</span><br><span class="line">├── settings </span><br><span class="line">│   └── settings.go <span class="comment"># viper 配置信息</span></span><br><span class="line">└── web_app.log</span><br></pre></td></tr></table></figure><p>一个新的项目，从程序入口main.go 开始读取；</p><h4 id="11-3-1-现有settings设计的问题"><a href="#11-3-1-现有settings设计的问题" class="headerlink" title="11.3.1 现有settings设计的问题"></a>11.3.1 现有settings设计的问题</h4><p>到项目后期，新接手的同事比较难一下知道项目中用到的配置信息；</p><p>一个优化点：</p><p>现在不是把配置文件读取出，之后直接保存到viper变量里面去。而是把它存储到内部定义的结构体中去。</p><p>什么意思呢？</p><p>就好比，刚开始项目是一个人开发的，他自然知道存在哪些配置。比如<code>viper.GetString(&quot;mysql.user&quot;)</code>等等；所以这里其实需要有一个类似interface的东西去提示给新开发者较好；这里选用结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/fsnotify/fsnotify"</span></span><br><span class="line"><span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Conf 全局变量，用来保存程序的所有配置信息</span></span><br><span class="line"><span class="keyword">var</span> Conf = <span class="built_in">new</span>(AppConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Name         <span class="keyword">string</span> <span class="string">`mapstructure:"name"`</span></span><br><span class="line">Mode         <span class="keyword">string</span> <span class="string">`mapstructure:"mode"`</span></span><br><span class="line">Version      <span class="keyword">string</span> <span class="string">`mapstructure:"version"`</span></span><br><span class="line">Port         <span class="keyword">int</span>    <span class="string">`mapstructure:"port"`</span></span><br><span class="line">*LogConfig   <span class="string">`mapstructure:"log"`</span></span><br><span class="line">*MySQLConfig <span class="string">`mapstructure:"mysql"`</span></span><br><span class="line">*RedisConfig <span class="string">`mapstructure:"redis"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Level      <span class="keyword">string</span> <span class="string">`mapstructure:"level"`</span></span><br><span class="line">Filename   <span class="keyword">string</span> <span class="string">`mapstructure:"filename"`</span></span><br><span class="line">MaxSize    <span class="keyword">int</span>    <span class="string">`mapstructure:"max_size"`</span></span><br><span class="line">MaxAge     <span class="keyword">int</span>    <span class="string">`mapstructure:"max_age"`</span></span><br><span class="line">MaxBackups <span class="keyword">int</span>    <span class="string">`mapstructure:"max_backups"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySQLConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Host         <span class="keyword">string</span> <span class="string">`mapstructure:"host"`</span></span><br><span class="line">User         <span class="keyword">string</span> <span class="string">`mapstructure:"user"`</span></span><br><span class="line">Password     <span class="keyword">string</span> <span class="string">`mapstructure:"password"`</span></span><br><span class="line">DbName       <span class="keyword">string</span> <span class="string">`mapstructure:"db_name"`</span></span><br><span class="line">Port         <span class="keyword">int</span>    <span class="string">`mapstructure:"port"`</span></span><br><span class="line">MaxOpenConns <span class="keyword">int</span>    <span class="string">`mapstructure:"max_open_conns"`</span></span><br><span class="line">MaxIdleConns <span class="keyword">int</span>    <span class="string">`mapstructure:"max_idle_conns"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Host     <span class="keyword">string</span> <span class="string">`mapstructure:"host"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`mapstructure:"password"`</span></span><br><span class="line">Port     <span class="keyword">int</span>    <span class="string">`mapstructure:"port"`</span></span><br><span class="line">DB       <span class="keyword">int</span>    <span class="string">`mapstructure:"db"`</span></span><br><span class="line">PoolSize <span class="keyword">int</span>    <span class="string">`mapstructure:"pool_size"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">viper.SetConfigFile(<span class="string">"config.yaml"</span>)</span><br><span class="line"><span class="comment">//viper.SetConfigName("config") // 指定配置文件名称（不需要带后缀）</span></span><br><span class="line"><span class="comment">//viper.SetConfigType("yaml")   // 指定配置文件类型(专用于从远程获取配置信息时指定配置文件类型的)</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"."</span>)   <span class="comment">// 指定查找配置文件的路径（这里使用相对路径）</span></span><br><span class="line">err = viper.ReadInConfig() <span class="comment">// 读取配置信息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 读取配置信息失败</span></span><br><span class="line">fmt.Printf(<span class="string">"viper.ReadInConfig() failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把读取到的配置信息反序列化到 Conf 变量中</span></span><br><span class="line"><span class="keyword">if</span> err := viper.Unmarshal(Conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"viper.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">viper.WatchConfig()</span><br><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(in fsnotify.Event)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"配置文件修改了..."</span>)</span><br><span class="line"><span class="keyword">if</span> err := viper.Unmarshal(Conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"viper.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增加结构体之后的流程</strong></p><ol><li>程序启动时，还是使用viper从配置文件里面去加载信息。</li><li>加载完信息之后，反序列化结构体变量，放到结构体中去，比如AppConfig。然后在程序中使用的是这个结构体而不是配置文件；</li></ol><h2 id="12-Gin-pro"><a href="#12-Gin-pro" class="headerlink" title="12. Gin_pro"></a>12. Gin_pro</h2><h3 id="12-1-create-sql"><a href="#12-1-create-sql" class="headerlink" title="12.1 create sql"></a>12.1 create sql</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci,</span><br><span class="line">    <span class="string">`gender`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">    <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`idx_username`</span> (<span class="string">`username`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`idx_user_id`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_general_ci;</span><br></pre></td></tr></table></figure><h4 id="12-1-1-primary-key与唯一索引"><a href="#12-1-1-primary-key与唯一索引" class="headerlink" title="12.1.1 primary key与唯一索引"></a>12.1.1 primary key与唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY (`id`),  "设置primary key"</span><br><span class="line">UNIQUE KEY `idx_username` (`username`) USING BTREE,</span><br><span class="line">UNIQUE KEY `idx_user_id` (`user_id`) USING BTREE</span><br><span class="line">"分别给 username 和 user_id 添加唯一索引"</span><br></pre></td></tr></table></figure><h4 id="12-1-2-user-id"><a href="#12-1-2-user-id" class="headerlink" title="12.1.2 user_id"></a>12.1.2 user_id</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`user_id` bigint(20) NOT NULL,  "bigint(20) 占8个字节，对应go语言的int64"</span><br><span class="line">`username` varchar(64) COLLATE utf8mb4_general_ci NOT NULL,</span><br></pre></td></tr></table></figure><ul><li>为何不使用 自增的 id做 user_id，反而另外设一个字段呢</li></ul><p>原因一：那别人在你数据库里面注册一个用户，就能知道你的用户量了；</p><p>原因二： 当使用分库分表的时候，分成不同的库，那id可能有重复的。（因为每个表的id都自增）</p><ul><li>为何不使用uuid</li></ul><p>uuid生成出来的id 就失去了使用数字来做 用户ID的特点，int可以按照时间来排序，随着时间递增。而uuid是无规律的；检索起来也不是特别的方便。</p><ul><li>目前主流的方案</li></ul><p>大型项目一般使用分布式的ID生成器，</p><p><strong>分布式ID的特点</strong></p><ul><li>全局唯一性： 不能出现有重复的ID标识，这是基本要求</li><li>递增性： 确保生成ID对于用户或业务是递增的；</li><li>高可用性： 确保任何时候都能生成正确的ID</li><li>高性能性： 在高并发的环境下依然表现良好</li></ul><p>不仅是用于用户ID，实际互联网中有很多场景需要能够生成类似MYSQL自增ID这样不断增大，同时又不会重复的id，以支持业务中的高并发场景。</p><p>比较典型的场景有： 电商促销时短时间内会有大量的订单涌入到系统，比如每秒10w+；</p><p> 在这些业务场景下将数据插入数据库之前，我们需要给这些订单和消息先分配一个唯一ID，然后再保存到数据库中；</p><p> 对这个id的要求是希望其中能带有一些时间消息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进行排序；</p><p><strong>snowflake算法</strong></p><p>雪花算法，它是Twitter开源的由64位整数组成分布式ID，性能较高，并且在单机上递增</p><p>snowflake-64bit</p><p><img src="xuehua.png" alt="image-20210415181135423"></p><ol><li><strong>第一位</strong> 占用1bit，其值始终是0，没有实际作用</li><li><strong>时间戳</strong> 占用41bit，单位为毫秒，总共可以容纳约69年的时间，当然，我们的时间毫秒计数不会真的从1970年开始，那样我们系统跑到 2039/9/7 23:47:35 就不能用了，所以这里的时间戳只是相对于某个时间的增量，比如我们的系统上线是2020-07-01，那么我们完全可以把这个timestamp当作是从2020-07-01 00:00:00.000的偏移量</li><li><strong>工作机器id</strong> 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，最多可以容纳1024个节点</li><li><strong>序列号</strong> 占用12bit，用来记录同豪秒内产生的不同id，每个节点每豪秒0开始不断累加，最多可以累加到4095，同一豪秒一共可以产生4096个ID；</li></ol><p>snowFlake算法在同一毫秒内最多可以生成的ID数量为<strong>同一毫秒的ID数量=1024*4096 = 4194304</strong></p><h3 id="12-2-登陆注册流程"><a href="#12-2-登陆注册流程" class="headerlink" title="12.2 登陆注册流程"></a>12.2 登陆注册流程</h3><p>中文注释的另外一个作用，提供编码思路（有的时候面对功能模块没思路的时候，通过写注释，分析要完成需求的实际步骤）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取参数和参数校验</span></span><br><span class="line"><span class="comment">// 2. 业务处理</span></span><br><span class="line"><span class="comment">// 3. 返回响应</span></span><br></pre></td></tr></table></figure><h4 id="12-2-1-validater做参数校验"><a href="#12-2-1-validater做参数校验" class="headerlink" title="12.2.1 validater做参数校验"></a>12.2.1 validater做参数校验</h4>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust</title>
      <link href="2021/03/16/rust/"/>
      <url>2021/03/16/rust/</url>
      
        <content type="html"><![CDATA[<h2 id="1-rust"><a href="#1-rust" class="headerlink" title="1. rust"></a>1. rust</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br><span class="line">rustup doc <span class="comment"># 离线文档</span></span><br><span class="line">rustc main.rs <span class="comment"># 编译main.rs  c为compiler</span></span><br></pre></td></tr></table></figure><h2 id="2-cargo"><a href="#2-cargo" class="headerlink" title="2. cargo"></a>2. cargo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo --version</span><br><span class="line">cargo new hello_cargo <span class="comment"># 创建一个 hello_cargo的项目</span></span><br></pre></td></tr></table></figure><h3 id="2-1-cargo-toml"><a href="#2-1-cargo-toml" class="headerlink" title="2.1 cargo.toml"></a>2.1 cargo.toml</h3><blockquote><p>TOML (Tom’s Obvious Minimal Language) 格式，是Cargo是配置格式</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span>  <span class="comment"># 区域标题，表示下方内容是用来配置包（package）的</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"hello_cargo"</span>  <span class="comment"># 项目名</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"ruanhan1988 &lt;2856197796@qq.com&gt;"</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">"2018"</span> <span class="comment"># 使用的rust版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> <span class="comment"># 区域标题， 另一个区域的开始，它会列出项目的依赖项</span></span><br></pre></td></tr></table></figure><h3 id="2-2-crate"><a href="#2-2-crate" class="headerlink" title="2.2 crate"></a>2.2 crate</h3><blockquote><p>在rust里面， 代码的包称为crate</p></blockquote><h3 id="2-3-非cargo创建的项目"><a href="#2-3-非cargo创建的项目" class="headerlink" title="2.3 非cargo创建的项目"></a>2.3 非cargo创建的项目</h3><blockquote><p>非cargo创建的项目，转化为使用cargo</p></blockquote><ol><li>把源代码文件移动到src下</li><li>创建Cargo.html并填写相应的配置</li></ol><h3 id="2-4-Cargo-构建项目"><a href="#2-4-Cargo-构建项目" class="headerlink" title="2.4 Cargo 构建项目"></a>2.4 Cargo 构建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build <span class="comment"># 构建</span></span><br><span class="line"><span class="comment"># 会创建出来一个可执行文件: target/debug/hello_cargo 或 target\debug\hello_cargo.exe</span></span><br></pre></td></tr></table></figure><h4 id="2-4-1-cargo-lock"><a href="#2-4-1-cargo-lock" class="headerlink" title="2.4.1 cargo.lock"></a>2.4.1 cargo.lock</h4><blockquote><p>第一次运行 cargo build会在项目目录生成 cargo.lock文件</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is automatically @generated by Cargo.</span></span><br><span class="line"><span class="comment"># It is not intended for manual editing.</span></span><br><span class="line"><span class="section">[[package]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"hello_cargo"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br></pre></td></tr></table></figure><p>该文件负责追踪项目以来的精确版本</p><p>不需要手动修改该文件</p><h3 id="2-5-构建和运行cargo项目"><a href="#2-5-构建和运行cargo项目" class="headerlink" title="2.5 构建和运行cargo项目"></a>2.5 构建和运行cargo项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p>如果源代码没有更改，直接运行上次生成的二进制文件；</p><h3 id="2-6-cargo-check"><a href="#2-6-cargo-check" class="headerlink" title="2.6 cargo check"></a>2.6 cargo check</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check <span class="comment"># 检查代码，确保能通过编译，但是不产生任何可执行文件；</span></span><br></pre></td></tr></table></figure><p>cargo check效率较build命令高很多，编写代码时，可反复使用cargo check检查代码，提高效率；</p><h3 id="2-7-发布"><a href="#2-7-发布" class="headerlink" title="2.7 发布"></a>2.7 发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br><span class="line"><span class="comment"># 编译时会进行优化, 代码会运行更快，但是编译时间更长</span></span><br><span class="line"><span class="comment"># 会在 target/release 而不是 target/debug 生成可执行文件</span></span><br></pre></td></tr></table></figure><h3 id="2-8-添加依赖包"><a href="#2-8-添加依赖包" class="headerlink" title="2.8 添加依赖包"></a>2.8 添加依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.html</span></span><br><span class="line">[package]</span><br><span class="line">name = <span class="string">"guessing_number"</span></span><br><span class="line">version = <span class="string">"0.1.0"</span></span><br><span class="line">authors = [<span class="string">"ruanhan1988 &lt;2856197796@qq.com&gt;"</span>]</span><br><span class="line">edition = <span class="string">"2018"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">rand = <span class="string">"0.3.14"</span>   <span class="comment"># 添加依赖包</span></span><br></pre></td></tr></table></figure><p>在dependencies区域下，直接填写 rand = “0.3.14”即可；</p><h2 id="3-guess-number-pro"><a href="#3-guess-number-pro" class="headerlink" title="3. guess number-pro"></a>3. guess number-pro</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess number"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess a number"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> guess =  <span class="built_in">String</span>::new(); <span class="comment">// 创建一个可变的变量，rust中变量默认是 immutable的</span></span><br><span class="line">    <span class="comment">// String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码</span></span><br><span class="line">    <span class="comment">// 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数</span></span><br><span class="line">    <span class="comment">// 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法</span></span><br><span class="line">    </span><br><span class="line">    io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br><span class="line">    <span class="comment">// rust中，引用默认也是不可变的，添加mut关键字，使其变为可变</span></span><br><span class="line">    <span class="comment">// &amp;mut guess 即指guess的引用  .expect 如果读取发生错误，程序崩溃退出；</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"you guess the number is: &#123;&#125;"</span>, guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-read-line"><a href="#3-1-read-line" class="headerlink" title="3.1 read_line"></a>3.1 read_line</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_line</span></span>(&amp;<span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">usize</span>&gt;</span><br><span class="line"><span class="comment">// read_line 有一个叫 io::Result 类型的返回值，在rust标准库中，有很多类型都叫做Result。既有通用的result（范型的result），也有特定版本，子模块的Result，比如io::Result, Result类型实际上枚举类型，一个枚举类型有几个固定的值，这些值称做是这些枚举类型的变体。而io::Result枚举类型一共两个变体，Ok和Err</span></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2-完整代码"><a href="#3-2-完整代码" class="headerlink" title="3.2 完整代码"></a>3.2 完整代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering; <span class="comment">// Ording 枚举类型</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="comment">// 默认情况下，rust会将 一个叫 prelude的模块 导入到每个程序的作用域中，</span></span><br><span class="line"><span class="comment">// 如果需要使用的类型不在 prelude里面，就需要显式的导入 比如 use std::io</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess number"</span>);</span><br><span class="line">    <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// loop 添加一个无限循环</span></span><br><span class="line">    <span class="keyword">loop</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"guess a number"</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guess =  <span class="built_in">String</span>::new(); <span class="comment">// 创建一个可变的变量，rust中变量默认是 immutable的</span></span><br><span class="line">        <span class="comment">// String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码</span></span><br><span class="line">        <span class="comment">// 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数</span></span><br><span class="line">        <span class="comment">// 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br><span class="line">        <span class="comment">// rust中，引用默认也是不可变的，添加mut关键字，使其变为可变</span></span><br><span class="line">        <span class="comment">// &amp;mut guess 即指guess的引用  .expect 如果读取发生错误，程序崩溃退出；</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"you guess the number is: &#123;&#125;"</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在rust中允许使用同名的新变量来 shadow原来同名的旧变量，也就是说从声明新guess之后，</span></span><br><span class="line">        <span class="comment">// 代码中出现的guess变量都将是这个 u32类型的变量；这种用法通常使用在需要有类型转换的场景</span></span><br><span class="line">        <span class="comment">// 中，我们复用guess这个名而无需创建新的变量名；</span></span><br><span class="line">       <span class="comment">// let guess:u32 = guess.trim().parse().expect("plase type a number"); // parse返回值是Result，所以可以使用expect处理未来可能存在的异常</span></span><br><span class="line">       <span class="keyword">let</span> guess:<span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse()&#123;<span class="comment">// 使用match 提高程序健壮性</span></span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"valid number"</span>);</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="comment">// 非合法数字，直接continue</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match关键字， 根据cmp返回的Ordering 这个枚举类型的值来决定下一步来做什么。</span></span><br><span class="line">        <span class="comment">// 而match表达式 是有多个 arm /分支 组成的；</span></span><br><span class="line">        <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123; <span class="comment">// cmp  compare 返回值 Ordering</span></span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"Too small!"</span>), <span class="comment">// arm</span></span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"To big!"</span>), <span class="comment">// arm</span></span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"you win"</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出 match</span></span><br><span class="line">            &#125;, <span class="comment">// arm</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-通用编程概念"><a href="#4-通用编程概念" class="headerlink" title="4. 通用编程概念"></a>4. 通用编程概念</h2><h3 id="4-1-变量与可变性"><a href="#4-1-变量与可变性" class="headerlink" title="4.1 变量与可变性"></a>4.1 变量与可变性</h3><p>声明变量用let</p><p>默认情况，变量是immutable</p><p>声明变量，在变量前面加上mut，就可以使变量可变；</p><h4 id="4-1-1-变量与常量"><a href="#4-1-1-变量与常量" class="headerlink" title="4.1.1 变量与常量"></a>4.1.1 变量与常量</h4><blockquote><p>常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别：</p></blockquote><p>不可以使用mut，常量永远都是不可变的；</p><p>声明变量使用const关键字，它的类型必须被标注；</p><p>常量可以在任何作用域内进行声明，包括全局作用域</p><p>常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值；</p><p>在程序运行期间，常量在其声明的作用域内一直有效</p><p>命名规范： Rust里常量使用全大写字母，每个单词之间用下划线分开；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_POINTS:<span class="built_in">u32</span> = <span class="number">100_00</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-Shadowing-隐藏"><a href="#4-1-2-Shadowing-隐藏" class="headerlink" title="4.1.2 Shadowing(隐藏)"></a>4.1.2 Shadowing(隐藏)</h4><blockquote><p> 可以使用相同的名字声明新的变量，新的变量就会shadow（隐藏）之前声明的同名变量</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> x = x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = x*<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 在后续的代码中这个变量名代表的就是新的变量；</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"value is &#123;&#125;"</span>, x); <span class="comment">// 12  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-shadow与mut"><a href="#4-1-3-shadow与mut" class="headerlink" title="4.1.3 shadow与mut"></a>4.1.3 shadow与mut</h4><blockquote><p> Shadow和把变量标记为mut是不一样的，</p></blockquote><p>如果不使用let关键字，那么重新给非mut的变量赋值会导致编译时错误</p><p>而使用let声明的同名新变量，也是不可变的；</p><p>使用let声明的同名新变量，它的类型可以与之前不同；</p><h3 id="4-2-数据类型"><a href="#4-2-数据类型" class="headerlink" title="4.2 数据类型"></a>4.2 数据类型</h3><p>Rust是静态编译语言，在编译时必须知道所有变量的类型；</p><p>基于使用的值，编译器通常能够推断出它的具体类型；</p><p>但如果可能的类型比较多（例如把String转为整数的parse方法），就必须添加类型的</p><p>标注，否则编译会报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = '<span class="number">42</span>'.parse(); <span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> num:<span class="built_in">u32</span> = '<span class="number">42</span>'.parse <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h4 id="4-2-1-标量类型"><a href="#4-2-1-标量类型" class="headerlink" title="4.2.1 标量类型"></a>4.2.1 标量类型</h4><blockquote><p>一个标量类型代表一个单个的值；</p></blockquote><p>Rust有四个主要的标量类型：</p><h5 id="4-2-1-1-整数类型"><a href="#4-2-1-1-整数类型" class="headerlink" title="4.2.1.1 整数类型"></a>4.2.1.1 整数类型</h5><p>整数类型没有小数部分</p><p>例如u32就是一个无符号的整数类型，占据32位的空间</p><p>无符号 以u开头</p><p>有符号 以i开头</p><p><strong>Rust的整数类型列表如图</strong></p><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p><strong>isize 和 usize类型</strong></p><p>isize 和 usize类型的位数由程序运行的计算机的架构所决定</p><p>如果是64位计算机，那就是64位，如果32位计算机，就是32位；</p><p>使用isize和usize 的主要场景是针对某中集合进行索引操作；</p><h5 id="4-2-1-2-浮点类型"><a href="#4-2-1-2-浮点类型" class="headerlink" title="4.2.1.2 浮点类型"></a>4.2.1.2 浮点类型</h5><p>f32</p><p>f64</p><h5 id="4-2-1-3-布尔类型"><a href="#4-2-1-3-布尔类型" class="headerlink" title="4.2.1.3 布尔类型"></a>4.2.1.3 布尔类型</h5><p>true</p><p>false</p><h5 id="4-2-1-4-字符类型"><a href="#4-2-1-4-字符类型" class="headerlink" title="4.2.1.4 字符类型"></a>4.2.1.4 字符类型</h5><p>char 4个字节</p><h4 id="4-2-2-复合类型"><a href="#4-2-2-复合类型" class="headerlink" title="4.2.2 复合类型"></a>4.2.2 复合类型</h4><blockquote><p>复合类型可以将多个值放在一个类型里</p></blockquote><p>Rust提供了两种基础的复合类型： 元祖（Tuple）、数组</p><h5 id="4-2-2-1-Tuple"><a href="#4-2-2-1-Tuple" class="headerlink" title="4.2.2.1 Tuple"></a>4.2.2.1 Tuple</h5><p>Tuple可以将多个类型的多个值放在一个类型里</p><p>Tuple的长度是固定的：一旦声明就无法改变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;, &#123;&#125;"</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h5 id="4-2-2-2-数组"><a href="#4-2-2-2-数组" class="headerlink" title="4.2.2.2 数组"></a>4.2.2.2 数组</h5><p>数组中每个元素的类型必须相同</p><p>数组的长度也是固定的</p><p><strong>数组的用处</strong></p><p>如果想让你的数据存放在stack上而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处；</p><p><strong>数组的类型</strong></p><p>[类型;  长度]</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>另一种声明数组的方法</p><p>如果数组的每个元素都相同，那么可以在：</p><p>在中括号里制定初始值；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>;<span class="number">5</span>]; </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>访问数组的元素</strong></p><p>数组是stack上分配的单个块的内存</p><p>可以使用索引来访问数组的元素（例子）</p><p>如果访问的索引超出了数组的范围，那么；</p><ul><li>编译会通过</li><li>运行会报错（runtime时会panic）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> mouths = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> index = [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> month = months[index[<span class="number">1</span>]]; <span class="comment">// 编译时不会报错，只有运行时才会检测</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, month); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust不会允许其继续访问相应的地址的内存；</p><h3 id="4-3-函数"><a href="#4-3-函数" class="headerlink" title="4.3 函数"></a>4.3 函数</h3><p>函数名  多个单词用下划线连接；</p><p>parameter 行参</p><p>arguments 实参</p><h4 id="4-3-1-函数的返回值"><a href="#4-3-1-函数的返回值" class="headerlink" title="4.3.1 函数的返回值"></a>4.3.1 函数的返回值</h4><p>在-&gt; 符号后边声明函数返回值的类型，但是不可以为返回值命名；</p><p>在rust里面，返回值</p><h3 id="4-4-注释"><a href="#4-4-注释" class="headerlink" title="4.4 注释"></a>4.4 注释</h3><h3 id="4-5-控制流"><a href="#4-5-控制流" class="headerlink" title="4.5 控制流"></a>4.5 控制流</h3><h4 id="4-5-1-if-else"><a href="#4-5-1-if-else" class="headerlink" title="4.5.1 if else"></a>4.5.1 if else</h4><p>match 重构多重if else语句</p><h4 id="4-5-2-循环"><a href="#4-5-2-循环" class="headerlink" title="4.5.2 循环"></a>4.5.2 循环</h4><p>Rust 提供了三种循环： loop， while 和 for</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">loop</span>&#123; <span class="comment">// 无限循环；</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">   <span class="keyword">while</span> number !== <span class="number">0</span> &#123;</span><br><span class="line">     <span class="comment">///</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-2-1-使用for循环遍历集合"><a href="#4-5-2-1-使用for循环遍历集合" class="headerlink" title="4.5.2.1 使用for循环遍历集合"></a>4.5.2.1 使用for循环遍历集合</h5><p>由于for循环的安全，简洁性，所以它在Rust里用的最多；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子： 用for循环显示倒计时的例子</strong></p><p>载入标准库</p><p>Range</p><p>指定一个开始数字和一个结束数字，Range可以生成它们之间的数字（不含结束）</p><p>rev方法可以反转Range</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"LIFTOFF!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-所有权"><a href="#5-所有权" class="headerlink" title="5. 所有权"></a>5. 所有权</h2><p>所有权是Rust最独特的特性，它让Rust无需GC就可以保证内存安全；</p><p>所有程序在运行时都必须管理它们使用计算机内存的方式</p><ul><li>有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存</li><li>在其他语言中，程序员必须显式地分配和释放内存；</li></ul><p>Rust采用了第三种方式</p><ul><li>内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则；</li><li>当程序运行时，所有权特性不会减慢程序的运行速度；</li></ul><h3 id="5-1-stack-vs-heap"><a href="#5-1-stack-vs-heap" class="headerlink" title="5.1 stack vs heap"></a>5.1 stack vs heap</h3><p>在像Rust这样的系统级编程语言里，一个值是在stack上还是在heap上对语言的行为和你为什么要做某些决定是有更大的影响的；</p><p>在你的代码运行的时候，stack 和 heap都是你可用的内存，但他们的结构很不相同；</p><p><strong>存储数据</strong></p><p>stack按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO）</p><ul><li>添加数据叫做压入栈</li><li>移除数据叫做弹出栈</li></ul><p>所有存储在Stack上的数据必须拥有已知的固定的大小；</p><ul><li>编译时大小未知的数据或运行时大小可能发生变化的数据必须存在heap上</li></ul><p>heap内存组织性差一点；</p><ul><li>当你把数据放入heap时，你会请求一定数量的空间</li><li>操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址</li><li>这个过程叫做heap上进行分配，有时仅仅称为“分配”</li></ul><p>把值压到stack上不叫分配</p><p>因为指针是已知固定大小的，可以把指针存放在stack上。</p><ul><li>但如果想要实际数据，你必须使用指针来定位；</li></ul><p>把数据压到stack上要比在heap上分配快得多：</p><ul><li>因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在stack的顶端</li></ul><p>在heap上分配空间需要做更多的工作：</p><ul><li>操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配；</li></ul><p><strong>访问数据</strong></p><p>访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据；</p><ul><li>对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快</li><li>如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack上）</li><li>如果数据之间的距离比较远，那么处理速度就会慢一些（heap上）<ul><li>在heap上分配大量的空间也是需要时间的；</li></ul></li></ul><p><strong>函数调用</strong></p><p>调用函数时，值被传入到函数（也包括指向heap的指针），函数本地的变量被压到stack上，当函数结束后，这些值会从stack上弹出；</p><h3 id="5-2-所有权存在的原因"><a href="#5-2-所有权存在的原因" class="headerlink" title="5.2 所有权存在的原因"></a>5.2 所有权存在的原因</h3><h4 id="5-2-1-所有权解决的问题"><a href="#5-2-1-所有权解决的问题" class="headerlink" title="5.2.1 所有权解决的问题"></a>5.2.1 所有权解决的问题</h4><p>跟踪代码的哪些部分正在使用heap的哪些数据；</p><p>最小化heap上的重复数据量</p><p>情理heap上未使用的数据以避免空间不足</p><p>一旦懂得所有权，那么就不需要经常去想stack或heap了；</p><p>但是知道管理heap数据是所有权存在的原因，这有助于理解它为什么会这样工作；</p><h3 id="5-3-所有权规则"><a href="#5-3-所有权规则" class="headerlink" title="5.3 所有权规则"></a>5.3 所有权规则</h3><p>每个值都有一个变量，这个变量是该值的所有者；</p><p>每个值同时只能有一个所有者；</p><p>当所有者超出作用域（scope）时，该值将被删除；</p><h4 id="5-3-1-变量作用域"><a href="#5-3-1-变量作用域" class="headerlink" title="5.3.1 变量作用域"></a>5.3.1 变量作用域</h4><p>scope就是程序中一个项目的有效范围</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="comment">// s不可用</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">"hello"</span>; <span class="comment">// s 可用</span></span><br><span class="line">  <span class="comment">// 可以对s进行相关操作</span></span><br><span class="line">&#125; <span class="comment">// s作用域到此结束， s不再可用；</span></span><br></pre></td></tr></table></figure><h4 id="5-3-2-String类型"><a href="#5-3-2-String类型" class="headerlink" title="5.3.2 String类型"></a>5.3.2 String类型</h4><p>Rust还有第二种字符串类型： String</p><ul><li>在heap上分配，能够存储在编译时未知数量的文本；</li></ul><h5 id="5-3-2-1-创建String类型的值"><a href="#5-3-2-1-创建String类型的值" class="headerlink" title="5.3.2.1 创建String类型的值"></a>5.3.2.1 创建String类型的值</h5><blockquote><p>可以使用from函数从字符串字面值创建出String类型</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">// :: 表示from是String类型下的函数</span></span><br><span class="line"><span class="comment">// 这类字符串是可以被修改的；</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">  s.push_str(<span class="string">", world"</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s); <span class="comment">// hi, world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-2-内存和分配"><a href="#5-3-2-2-内存和分配" class="headerlink" title="5.3.2.2 内存和分配"></a>5.3.2.2 内存和分配</h5><p><strong>为什么string类型的值可以修改，而字符串字面值不能修改</strong></p><ul><li>因为它们处理内存的方式不同；</li></ul><p>字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里；</p><ul><li>速度快、高效，是因为其不可变性；</li></ul><p>String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容：</p><ul><li><p>操作系统必须在运行时来请求内存，</p><ul><li>这步通过调用String::from来实现</li></ul></li><li><p>当用完String之后，需要使用某种方式将内存返回给操作系统</p><ul><li><p>这步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存</p></li><li><p>没有GC，就需要我们去识别内存何时不再使用，并调用代码将它返回；</p><ul><li>如果忘了，那就浪费内存</li><li>如果提前做了，变量就会非法</li><li>如果做了两次，就是Bug，必须一次分配对应一次释放；</li></ul></li></ul></li></ul><p>Rust采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统；</p><ul><li>drop函数</li></ul><p>当变量走出作用域的时候，会调用drop函数</p><h3 id="5-4-变量和数据交互的方式"><a href="#5-4-变量和数据交互的方式" class="headerlink" title="5.4 变量和数据交互的方式"></a>5.4 变量和数据交互的方式</h3><h4 id="5-4-1-移动（Move）"><a href="#5-4-1-移动（Move）" class="headerlink" title="5.4.1 移动（Move）"></a>5.4.1 移动（Move）</h4><blockquote><p>多个变量可以与同一个数据使用一种独特的方式来交互；</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// borrow of moved value: `s`</span></span><br><span class="line">    <span class="keyword">let</span> s2 = s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s2); <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个String由3部分组成：<ul><li>一个指向存放字符串内容的内存的指针 ptr</li><li>一个长度 len</li><li>一个容量 capacity</li></ul></li></ul><p><img src="heap01.png" alt="image-20210302114049906"></p><ul><li>上面这些东西放在stack上</li><li>存放字符串内容的部分在heap上</li><li>长度len，就是存放字符串内容所需的字节数；</li></ul><p><img src="heap02.png" alt="image-20210302130115114"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure><p>当把s1赋给s2，String的数据被复制了一份：</p><ul><li>在stack上复制了一份指针、长度、容量</li><li>并没有复制指针所指向的heap上的数据</li></ul><p>当变量离开作用域时，Rust会自动调用drop函数，并将变量使用的heap内存释放；</p><p>当s1、s2离开作用域时，它们都会尝试释放相同的内存</p><ul><li>会引起二次释放（double free）的bug</li></ul><p>rust为了保证内存安全：</p><ul><li>Rust没有尝试复制被分配的内存</li><li>Rust让s1失效<ul><li>当s1离开作用域的时候，rust不需要释放任何东西；</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// borrow of moved value: `s`</span></span><br><span class="line">    <span class="keyword">let</span> s2 = s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s2); <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-2-浅拷贝和深拷贝"><a href="#5-4-2-浅拷贝和深拷贝" class="headerlink" title="5.4.2 浅拷贝和深拷贝"></a>5.4.2 浅拷贝和深拷贝</h4><p>浅拷贝</p><p>深拷贝</p><p>你也许会将复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以我们用一个新的术语：移动（Move）</p><p>隐含的一个设计原则： Rust不会自动创建数据的深拷贝</p><ul><li>就运行时性能而言，任何自动赋值的操作都是廉价的；</li></ul><h4 id="5-4-3-变量和数据交互的方式：克隆（Clone）"><a href="#5-4-3-变量和数据交互的方式：克隆（Clone）" class="headerlink" title="5.4.3 变量和数据交互的方式：克隆（Clone）"></a>5.4.3 变量和数据交互的方式：克隆（Clone）</h4><p>如果真想对heap上面的String数据进行深度拷贝，而不仅仅是Stack上的数据，可以使用clone方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; borrow of moved value: &#96;s&#96;</span><br><span class="line">    let s2 &#x3D; s;</span><br><span class="line">    let s3 &#x3D; s2.clone();</span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, s2, s3); &#x2F;&#x2F; hello hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clone 相当于无论是Stack上还是heap上的数据，都统统复制一遍</p><p><img src="heap03.png" alt="image-20210302131623712"></p><h4 id="5-4-4-复制"><a href="#5-4-4-复制" class="headerlink" title="5.4.4 复制"></a>5.4.4 复制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clone 比较消耗资源；主要还是针对heap上的数据操作。</p><p>而针对Stack上的数据，只需要复制就好了；</p><h5 id="5-4-4-1-Copy-trait"><a href="#5-4-4-1-Copy-trait" class="headerlink" title="5.4.4.1 Copy trait"></a>5.4.4.1 Copy trait</h5><p>Rust 提供了一个名为Copy的 trait，trait简单理解为接口</p><p>Copy trait，可以用于像整数这样完全存放在stack上面的类型；</p><p>如果一个类型实现了Copy这个trait，那么旧的变量在赋值后仍然可用；</p><p>如果一个类型或者该类型的一部分实现了Drop trait，那么Rust不允许让它再实现Copy trait了</p><h5 id="5-4-4-2-一些拥有Copy-trait的类型"><a href="#5-4-4-2-一些拥有Copy-trait的类型" class="headerlink" title="5.4.4.2 一些拥有Copy trait的类型"></a>5.4.4.2 一些拥有Copy trait的类型</h5><p>任何简单标量的组合类型都可以是Copy的</p><p>任何需要分配内存或某种资源的都不是Copy的</p><p>一些拥有Copy trait的类型</p><ul><li>所有整数类型，例如 u32</li><li>bool</li><li>char</li><li>所有浮点类型 例如f64</li><li>Tuple（元组），如果其所有的字段都是Copy的<ul><li>(i32,i32)是</li><li>(I32, String) 不是</li></ul></li></ul><h3 id="5-5-所有权与函数"><a href="#5-5-所有权与函数" class="headerlink" title="5.5 所有权与函数"></a>5.5 所有权与函数</h3><p>在语义上，将值传递给函数和把值赋给变量是类似的：</p><h4 id="5-5-1-将值传递给函数将发生移动或复制"><a href="#5-5-1-将值传递给函数将发生移动或复制" class="headerlink" title="5.5.1 将值传递给函数将发生移动或复制"></a>5.5.1 将值传递给函数将发生移动或复制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"alex"</span>);</span><br><span class="line">    take_ownership(s);</span><br><span class="line">    <span class="comment">// 从这里之后，s的值被移动到函数里面；</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    makes_copy(x);</span><br><span class="line">    <span class="comment">// x值是被拷贝到函数里面</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;"</span>, x);</span><br><span class="line">    <span class="comment">// x 被回收；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_ownership</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125; <span class="comment">// rust会调用drop ，str占用的内存会被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">makes_copy</span></span>(<span class="built_in">str</span>: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125; <span class="comment">// 对于i32这种基础类型，不会有额外的事情发生</span></span><br></pre></td></tr></table></figure><h4 id="5-5-2-返回值与作用域"><a href="#5-5-2-返回值与作用域" class="headerlink" title="5.5.2 返回值与作用域"></a>5.5.2 返回值与作用域</h4><p>函数在返回值的过程中同样也会发生所有权的转移</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个变量的所有权总是遵循同样的模式：</p><ul><li>把一个值赋给其它变量时就会发生移动</li><li>当一个包含heap数据的变量离开作用域时，它的值就会被drop函数清理，除非数据的所有权移动到另一个变量上了；</li></ul><h3 id="5-6-引用"><a href="#5-6-引用" class="headerlink" title="5.6 引用"></a>5.6 引用</h3><p>如果让函数使用某个值，但不获得其所有权？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"alex"</span>);</span><br><span class="line">  <span class="keyword">let</span> (s2, len) = calculate_length(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;"</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;<span class="comment">// usize 跟架构有关的无符号整数类型</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">str</span>.len();</span><br><span class="line">  (<span class="built_in">str</span>, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust有一个特性叫做 <code>引用（Reference)</code></p><h4 id="5-6-1-引用"><a href="#5-6-1-引用" class="headerlink" title="5.6.1 引用"></a>5.6.1 引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="symbol">'hi</span>');</span><br><span class="line">  <span class="keyword">let</span> len = calcuate_length(&amp;s1); <span class="comment">//&amp;s1并不拥有s1，所有不会转移s1的所有权，而是将s1的引用传给了 函数， 当作用域结束之后，s1并不会被清理掉</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calcuate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125; <span class="comment">// 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，</span></span><br><span class="line"><span class="comment">// 所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权</span></span><br><span class="line"><span class="comment">// 这种将引用作为函数参数的行为，我们就将其称为借用；</span></span><br></pre></td></tr></table></figure><p><img src="yinyong01.png" alt="image-20210303150138448"></p><p>如上图，s就是s1的引用，</p><p>s实际上是一个指针，它指向s1。</p><p>s1也是一个指针，它指向存在heap上的真实的内容；</p><p><code>calcuate_length</code> 参数的类型是 &amp; String而不是String， &amp;符号就表示引用：允许你引用某些值而不取得其所有权</p><h4 id="5-6-2-借用"><a href="#5-6-2-借用" class="headerlink" title="5.6.2 借用"></a>5.6.2 借用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calcuate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125; <span class="comment">// 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，</span></span><br></pre></td></tr></table></figure><ul><li>所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权</li><li>这种将引用作为函数参数的行为，我们就将其称为借用；</li></ul><p><strong>是否可以修改借用的东西？</strong></p><ul><li>不行</li><li>和变量一样，引用默认也是不可变的</li><li>只要设置mut，就可以修改借用的东西</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// 设置为可变的</span></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-3-可变引用"><a href="#5-6-3-可变引用" class="headerlink" title="5.6.3 可变引用"></a>5.6.3 可变引用</h4><p>可变引用有一个重要的限制： 在特定作用域内，对某一块数据，只能有一个可变的引用；</p><p>这样做的好处是可在编译时防止数据竞争；</p><p><strong>数据竞争是如何发生的</strong></p><ul><li>两个或多个指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有使用任何机制来同步对数据的访问</li></ul><p><strong>可以通过创建新的作用域，来允许非同时的创建多个可变引用（例子）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="symbol">'alex</span>');</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> s2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可以同时拥有一个可变引用和一个不变的引用</strong></p><ul><li>多个不变的引用是可以的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="symbol">'alex</span>');</span><br><span class="line">  <span class="keyword">let</span> r1 = &amp;s;</span><br><span class="line">  <span class="keyword">let</span> r2 = &amp;s;</span><br><span class="line">  <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s; <span class="comment">// error! 不可以同时拥有可变引用和不可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-4-悬垂引用-Dangling-References"><a href="#5-6-4-悬垂引用-Dangling-References" class="headerlink" title="5.6.4 悬垂引用 Dangling References"></a>5.6.4 悬垂引用 Dangling References</h4><blockquote><p>一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了；</p></blockquote><p>Rust里，编译器可保证引用永远都不是悬空引用；</p><ul><li>如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域；</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> r = dangle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// compiler error：</span></span><br><span class="line">  <span class="keyword">let</span> s = Sring::from(<span class="symbol">'alex</span>');</span><br><span class="line">  &amp;s</span><br><span class="line">&#125;<span class="comment">// 随着s离开作用域，会调用drop释放内存，而对它的引用 &amp;s 却继续返回了。所以这个引用指向了一个被释放掉了的内存地址；即悬空指针，但Rust在编译阶段就规避掉了；</span></span><br></pre></td></tr></table></figure><h4 id="5-6-5-引用的规则"><a href="#5-6-5-引用的规则" class="headerlink" title="5.6.5 引用的规则"></a>5.6.5 引用的规则</h4><p>在任何给定的时刻，只能满足下列条件之一：</p><ul><li>一个可变的引用</li><li>任意数量不可变的引用</li></ul><p>引用必须一直有效</p><h3 id="5-7-切片-slice"><a href="#5-7-切片-slice" class="headerlink" title="5.7 切片 slice"></a>5.7 切片 slice</h3><blockquote><p>Rust的另外一种不持有所有权的数据类型：切片（slice）</p></blockquote><p>编写一个函数：</p><ul><li>它接收字符串作为参数</li><li>返回它在这个字符串里找到的第一个单词</li><li>如果函数没找到任何空格，那么整个字符串就被返回；</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello alex"</span>);</span><br><span class="line">    <span class="keyword">let</span> name_index = first_world(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, name_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes(); <span class="comment">// 转成字节数组</span></span><br><span class="line">  <span class="comment">// iter 方法为bytes创建一个迭代器，这个方法依次返回集合中的每个元素。然后</span></span><br><span class="line">  <span class="comment">// 调用的enumerate方法，它会将iter方法的结果进行包装，并把结果作为tuple的一部分进行返回。</span></span><br><span class="line">  <span class="comment">// 元祖的第一个元素，就是enumerate遍历的索引 i，第二个元素就是引用 item。</span></span><br><span class="line">  <span class="comment">// (i, &amp;item) 实际上是模式匹配之后的解构</span></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而上面的函数设计是有问题的， name_index 和 s 太过耦合了。当s被清空之后，name_index的值就不再有意义了；</p><p>那如何确保 s 和 name_index 之间的同步性呢；</p><p><strong>解决方案： 字符串切片</strong></p><h4 id="5-7-1-字符串切片"><a href="#5-7-1-字符串切片" class="headerlink" title="5.7.1 字符串切片"></a>5.7.1 字符串切片</h4><blockquote><p>字符串切片是指向字符串中一部分内容的引用</p></blockquote><p>形式： [开始索引…结束索引]</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>几个语法糖</p><p>注意：</p><ul><li>字符串切片的范围索引必须发生在有效的UTF-8字符边界内；</li><li>如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello alex"</span>);</span><br><span class="line">    <span class="keyword">let</span> name_index = first_world(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, name_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;str 字符串切片</span></span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-7-2-字符串字面值是切片"><a href="#5-7-2-字符串字面值是切片" class="headerlink" title="5.7.2 字符串字面值是切片"></a>5.7.2 字符串字面值是切片</h4><p>字符串字面值被直接存储在二进制程序中；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"he"</span> <span class="comment">// s 为 &amp;str类型，即字符串切片</span></span><br><span class="line"><span class="comment">// s就是一个指向二进制程序 特定位置的切片，而&amp;str是不可变的引用；</span></span><br></pre></td></tr></table></figure><p>变量s的类型是&amp;str， 它是一个指向二进制程序特定位置的切片</p><ul><li>&amp;str是不可变引用，所以字符串字面值也是不可变的；</li></ul><h4 id="5-7-3-将字符串切片作为参数传递"><a href="#5-7-3-将字符串切片作为参数传递" class="headerlink" title="5.7.3 将字符串切片作为参数传递"></a>5.7.3 将字符串切片作为参数传递</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_string = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> my_string_literal = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入字符串字面值的 slice</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值 **就是** 字符串 slice，</span></span><br><span class="line">    <span class="comment">// 这样写也可以，即不使用 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(my_string_literal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;str 字符串切片</span></span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能；</p><h2 id="6-struct"><a href="#6-struct" class="headerlink" title="6. struct"></a>6. struct</h2><h3 id="6-1-定义并实例化struct"><a href="#6-1-定义并实例化struct" class="headerlink" title="6.1 定义并实例化struct"></a>6.1 定义并实例化struct</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    emila: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"alex"</span>),</span><br><span class="line">        emila: <span class="built_in">String</span>::from(<span class="string">"123@qq.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">12</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦struct的实例是可变的，那么实例中所有的字段都是可变的。不允许部分可变，部分不可变</p><h4 id="6-1-1-tuple-struct"><a href="#6-1-1-tuple-struct" class="headerlink" title="6.1.1 tuple struct"></a>6.1.1 tuple struct</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>black和origin是不同的类型，是不同tuple struct的实例</p><h4 id="6-1-2-Unit-Like-Struct（没有任何字段）"><a href="#6-1-2-Unit-Like-Struct（没有任何字段）" class="headerlink" title="6.1.2 Unit-Like Struct（没有任何字段）"></a>6.1.2 Unit-Like Struct（没有任何字段）</h4><ul><li>可以定义没有任何字段的struct，叫做Unit-Like Struct（因为与（），单元类型类似）</li><li>适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据</li></ul><h4 id="6-1-3-struct-数据的所有权"><a href="#6-1-3-struct-数据的所有权" class="headerlink" title="6.1.3 struct 数据的所有权"></a>6.1.3 struct 数据的所有权</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    emila: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的字段使用了String 而不是 &amp;str<ul><li>该struct实例拥有其所有的数据</li><li>只要struct实例是有效的，那么里面的字段数据也是有效的</li></ul></li><li>struct里也可以存放引用，但这需要使用生命周期；<ul><li>声明周期保证只要struct实例是有效的，那么里面的引用也是有效的；</li><li>如果struct里面存储引用，而不使用生命周期，就会报错</li></ul></li></ul><h4 id="6-1-4-计算面积的例子"><a href="#6-1-4-计算面积的例子" class="headerlink" title="6.1.4 计算面积的例子"></a>6.1.4 计算面积的例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rect: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rect.height * rect.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, area(&amp;rect));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-5-几种模式"><a href="#6-1-5-几种模式" class="headerlink" title="6.1.5 几种模式"></a>6.1.5 几种模式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::fmt::Display</span><br><span class="line">std::fmt::<span class="built_in">Debug</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line">&#123;:?&#125;</span><br><span class="line">&#123;:#?&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-struct的方法"><a href="#6-2-struct的方法" class="headerlink" title="6.2 struct的方法"></a>6.2 struct的方法</h3><p>方法和函数类似： fn关键字、名称、参数、返回值</p><p>方法与函数不同之处：</p><ul><li>方法是在struct（或enum、trait对象）的上下文中定义</li><li>第一个参数是self，表示方法被调用的struct实例</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123; <span class="comment">// impl块中定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 方法第一个参数可以是 &amp;self</span></span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-1-方法调用的运算符"><a href="#6-2-1-方法调用的运算符" class="headerlink" title="6.2.1 方法调用的运算符"></a>6.2.1 方法调用的运算符</h4><p>在调用方法时， Rust根据情况自动添加 &amp;、 &amp;mut 或 *， 以便object可以匹配方法的签名；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两行代码效果相同：</span></span><br><span class="line">p1.dis(&amp;p2);</span><br><span class="line">(&amp;p1).dis(&amp;p2);</span><br></pre></td></tr></table></figure><h4 id="6-2-2-方法参数"><a href="#6-2-2-方法参数" class="headerlink" title="6.2.2 方法参数"></a>6.2.2 方法参数</h4><p>方法可以有多个参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hole</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height &gt; other.height &amp;&amp; <span class="keyword">self</span>.width &gt; other.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect.area());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect1.can_hole(&amp;rect1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-关联函数"><a href="#6-3-关联函数" class="headerlink" title="6.3 关联函数"></a>6.3 关联函数</h3><p>可以在impl块里定义不把self作为第一个参数的函数，它们叫关联函数（不是方法）</p><ul><li>例如： String::from()</li></ul><p>关联函数通常用于构造器</p><ul><li>::符号<ul><li>关联函数</li><li>模块创建的命名空间</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = Rectangle::square(<span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-枚举与模式匹配"><a href="#7-枚举与模式匹配" class="headerlink" title="7. 枚举与模式匹配"></a>7. 枚举与模式匹配</h2><h3 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ip</span></span> &#123;</span><br><span class="line">V4,V6</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Ip::V4;</span><br><span class="line"><span class="keyword">let</span> b = Ip::V6;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"::1"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-1-1-将数据附加到枚举的变体中"><a href="#7-1-1-将数据附加到枚举的变体中" class="headerlink" title="7.1.1 将数据附加到枚举的变体中"></a>7.1.1 将数据附加到枚举的变体中</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure><p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p><p>优点：</p><ul><li>不需要额外使用struct</li><li>每个变体可以拥有不同的类型以及关联的数据量</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ip</span></span> &#123;</span><br><span class="line">V4(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>),</span><br><span class="line">V6(<span class="built_in">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-option枚举"><a href="#7-2-option枚举" class="headerlink" title="7.2 option枚举"></a>7.2 option枚举</h3><p>定义于标准库中</p><p>在Prelude中</p><p>描述了： 某个值可能存在（某种类型）或不存在的情况</p><h4 id="7-2-1-Option"><a href="#7-2-1-Option" class="headerlink" title="7.2.1 Option"></a>7.2.1 Option<T></h4><p>Rust中类似Null概念的枚举 - Option<T></p><p>Rust没有Null</p><p>其它语言中：</p><ul><li>Null是一个值，它表示“没有值”</li><li>一个变量可以处于两种状态： 空值（null）、非空</li></ul><p>Null引用： Billion Dollar Mistake</p><p>Null的问题在于： 当你尝试像使用非Null值那样使用Null值的时候，就会引起某种错误</p><p>Null的概念还是有用的：因某种原因而变为无效或缺失的值；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库中的定义：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它包含在Prelude（预导入模块）中，可直接使用；</p><ul><li>Option<T></li><li>Some<T></li><li>None</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure><p><strong>Option<T>比Null好在哪？</strong></p><p>Option<T>和T是不同的类型，不可以把Option<T>直接当成T</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> x:<span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> sum = x + y; <span class="comment">// error: cannot add Option&lt;i8&gt; to i8;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若想使用Option<T>中的 T，必须将它转换为 T；</p><p>这就避免了其它语言中最常见的那个错误；那就是假设某个值存在，但它实际上为Null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比如在C#</span><br><span class="line">string a &#x3D; null;</span><br><span class="line">string b &#x3D; a + &quot;12345&quot;; &#x2F;&#x2F; error</span><br></pre></td></tr></table></figure><h3 id="7-3-match"><a href="#7-3-match" class="headerlink" title="7.3 match"></a>7.3 match</h3><p>控制流运算符 - match</p><ul><li>match允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码；</li><li>模式可以是字面量、变量名、通配符</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-1-绑定值的模式"><a href="#7-3-1-绑定值的模式" class="headerlink" title="7.3.1 绑定值的模式"></a>7.3.1 绑定值的模式</h4><p>匹配的分支可以绑定到被匹配对象的部分值</p><ul><li>因此，可以从enum变体中提取值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"penny"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = Coin::Quarter(UsState::Alabama);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value_in_cents(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2-匹配Option"><a href="#7-3-2-匹配Option" class="headerlink" title="7.3.2 匹配Option"></a>7.3.2 匹配Option<T></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">  <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-3-match必须穷举所有可能"><a href="#7-3-3-match必须穷举所有可能" class="headerlink" title="7.3.3 match必须穷举所有可能"></a>7.3.3 match必须穷举所有可能</h4><p>_ 通配符： 替代其余没有列出的值；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-if-let"><a href="#7-4-if-let" class="headerlink" title="7.4 if let"></a>7.4 if let</h3><p>处理只关心一种匹配而忽略其它匹配的情况</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="comment">// match 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if let 相当于只处理一种匹配的情况，其它的分支就不关心了</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>if let 优缺点</strong></p><p>更少的代码，更少的锁紧，更少的模版代码</p><p>放弃了穷举的可能</p><p>可以把 if let 看作是 match的语法糖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if let 搭配 else</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"others"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Package-Crate-和-Module"><a href="#8-Package-Crate-和-Module" class="headerlink" title="8. Package, Crate 和 Module"></a>8. Package, Crate 和 Module</h2><p>模块系统：</p><ul><li>Package（包）， Cargo的特性，让你构建、测试、共享crate；</li><li>Crate（单元包）， 一个模块树，它可产生一个library或执行文件；</li><li>Module（模块）， use： 让你控制代码的组织、作用域、私有路径；</li><li>path（路径）： 为struct、function 或module 等项命名的方式；</li></ul><h3 id="8-1-Package-和-Crate"><a href="#8-1-Package-和-Crate" class="headerlink" title="8.1 Package 和 Crate"></a>8.1 Package 和 Crate</h3><p>crate上面是package，</p><p><strong>Crate的类型</strong></p><ul><li>binary</li><li>library</li></ul><p><strong>Crate Root</strong></p><ul><li>是源代码文件</li><li>Rust编译器从这里开始，组成你的Crate的根Module</li></ul><p><strong>一个Package</strong></p><ul><li>包含1个Cargo.toml, 它描述了如何构建这些Crates；</li><li>只能包含0-1个library crate；</li><li>可以包含任意数量的binary crate；</li><li>必须至少包含一个crate（library或binary）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; cargo new my-pro</span><br><span class="line"><span class="comment"># create binary (application) `my-pro` package</span></span><br></pre></td></tr></table></figure><h4 id="8-1-1-Cargo的惯例"><a href="#8-1-1-Cargo的惯例" class="headerlink" title="8.1.1 Cargo的惯例"></a>8.1.1 Cargo的惯例</h4><p>src/main.rs</p><ul><li>src/main.rs    // package 的入口文件<ul><li>Binary crate 的 crate root （cargo会默认让 main.rs做为crate的根）</li><li>crate名与package名相同 （也是指这个binary crate的名和包名相同，都是my-pro）</li></ul></li><li>src/lib.rs<ul><li>Package 包含一个library crate</li><li>library crate 的 crate root</li><li>crate名与package名相同 （也都是my-pro）</li></ul></li></ul><p>复习：</p><p>如果有main.rs,就说明有一个 binary crate。</p><p>如果有lib.rs , 就说明有一个library crate。</p><p>两个都是入口文件，都是crate的根。而crate名都与package名相同。</p><p>cargo会把crate root文件交给rustc 来构建library 或 binary</p><p>一个Package可以同时包含main.rs 和 lib.rs, </p><ul><li>表明，这个package含有一个 binary crate，一个library crate。名称都与package名相同</li><li>一个package可以有多个binary crate<ul><li>文件都放在src/bin</li><li>每个文件是单独的binary crate</li></ul></li></ul><h3 id="8-2-Crate的作用"><a href="#8-2-Crate的作用" class="headerlink" title="8.2 Crate的作用"></a>8.2 Crate的作用</h3><blockquote><p>将相关功能组合到一个作用域内，便于在项目间进行共享，也能防止命名冲突</p></blockquote><p>例如： rand crate，访问它的功能需要通过它的名字： rand</p><h3 id="8-3-定义module来控制作用域和私有性"><a href="#8-3-定义module来控制作用域和私有性" class="headerlink" title="8.3 定义module来控制作用域和私有性"></a>8.3 定义module来控制作用域和私有性</h3><p><strong>Module</strong></p><p>在一个crate内，将代码进行分组；</p><p>增加可读性，易于复用；</p><p>控制项目（item）的私有性，public、private</p><h4 id="8-3-1-建立module"><a href="#8-3-1-建立module" class="headerlink" title="8.3.1 建立module"></a>8.3.1 建立module</h4><ul><li>mod 关键字{}</li><li>可嵌套</li><li>可包含其它项（struct、enum、常量、trait、函数等）的定义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cargo new my-pro</span></span><br><span class="line">|- crate</span><br><span class="line">|- front_of_house</span><br><span class="line">|- hosting</span><br><span class="line">|- add_to_waitlist</span><br><span class="line">|- seat_at_table</span><br><span class="line">|- serving</span><br><span class="line">|- take_over</span><br><span class="line">|- serve_order</span><br><span class="line">|- take_payment</span><br></pre></td></tr></table></figure><p>main.rs   lib.rs 都叫crate roots；</p><ul><li>这两个文件（任意一个）的内容形成了名为crate的模块，位于整个模块树的根部；</li><li>整个模块树在隐式的crate模块下</li></ul><h3 id="8-4-path"><a href="#8-4-path" class="headerlink" title="8.4 path"></a>8.4 path</h3><p>根其它语言里面的命名空间有点类似</p><ul><li>为了在Rust的模块中找到某个条目，需要使用路径</li><li>路径的两种形式<ul><li>绝对路径： 从crate root开始，使用crate名或字面值crate</li><li>相对路径： 从当前模块开始，使用self，super或当前模块的标识符；</li></ul></li><li>路径至少由一个标识符组成，标识符之间使用::</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟级别可以不加 pub 互相调用</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pub 关键字 设置该module为公共的</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Absolute path</span></span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Relative path</span></span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-1-私有边界（private-boundary）"><a href="#8-4-1-私有边界（private-boundary）" class="headerlink" title="8.4.1 私有边界（private boundary）"></a>8.4.1 私有边界（private boundary）</h4><p>模块不仅可以组织代码，还可以定义私有边界</p><p>如果想把 函数 或 struct 等设为私有，可以将它放到某个模块中；</p><p>Rust中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的；</p><ul><li>父级模块无法访问子模块中的私有条目<ul><li>私有条目都是隐藏实现细节，不允许其它模块进行访问。</li><li>子模块里可以使用所有祖先模块中的条目</li></ul></li></ul><h4 id="8-4-2-super关键字"><a href="#8-4-2-super关键字" class="headerlink" title="8.4.2 super关键字"></a>8.4.2 super关键字</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ls..</span><br><span class="line">$&gt; hello hello.c</span><br><span class="line">$&gt; ../hello <span class="comment"># hello</span></span><br></pre></td></tr></table></figure><ul><li>super关键字</li></ul><p>在Rust中，用来访问父级模块路径中的内容，类似文件系统中的..</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fix_incorrect_order</span></span>()&#123;</span><br><span class="line">    cook_order();</span><br><span class="line">    super::serve_order(); <span class="comment">// 上一级模块的 serve_order 方法</span></span><br><span class="line">    crate::serve_order(); <span class="comment">// 绝对路径的写法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">cook_order</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-3-use关键字"><a href="#8-4-3-use关键字" class="headerlink" title="8.4.3 use关键字"></a>8.4.3 use关键字</h4><p>可以使用use关键字将路径导入到作用域内</p><ul><li>仍遵循私有性规则</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用use来指定相对路径</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 函数 指定到父级模块； hosting</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用use来指定绝对路径</span></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting;</span><br></pre></td></tr></table></figure><ul><li>struct, enum 其它： 指定完整路径（指定到本身）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"> map.insert(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同名条目： 指定到父级</li></ul><h5 id="8-4-3-1-使用pub-use重新导出名称"><a href="#8-4-3-1-使用pub-use重新导出名称" class="headerlink" title="8.4.3.1 使用pub use重新导出名称"></a>8.4.3.1 使用pub use重新导出名称</h5><p>使用use将路径（名称）导入到作用域内后，该名称在此作用域内是私有的；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting; <span class="comment">// 从此，外部模块也能访问 hosting了</span></span><br><span class="line"><span class="comment">// 函数 指定到父级模块； hosting</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-4-3-2-使用嵌套路径清理大量的use语句"><a href="#8-4-3-2-使用嵌套路径清理大量的use语句" class="headerlink" title="8.4.3.2 使用嵌套路径清理大量的use语句"></a>8.4.3.2 使用嵌套路径清理大量的use语句</h5><p>如果使用同一个包或模块下的多个条目（例子）</p><p>可使用嵌套路径在同一行内将上述条目进行引入：</p><ul><li>路径相同的部分::{路径差异的部分}</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use std::cmp::Ordering;</span></span><br><span class="line"><span class="comment">// use std::io;</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use std::io;</span></span><br><span class="line"><span class="comment">// use std::io::Write</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-4-4-通配符"><a href="#8-4-4-通配符" class="headerlink" title="8.4.4 通配符 *"></a>8.4.4 通配符 *</h4><p>使用 * 可以把路径中所有的公共条目都引入到作用域</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*</span><br></pre></td></tr></table></figure><p>谨慎使用</p><p>应用场景：</p><ul><li>测试，将所有被测试代码引入到tests模块</li><li>有时被用于预导入（prelude）模块</li></ul><h4 id="8-4-5-as关键字"><a href="#8-4-5-as关键字" class="headerlink" title="8.4.5  as关键字"></a>8.4.5  as关键字</h4><p>as关键字可以为引入的路径指定本地的别名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f2</span></span>() -&gt; IoResult&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-4-6-使用外部包（package）"><a href="#8-4-6-使用外部包（package）" class="headerlink" title="8.4.6 使用外部包（package）"></a>8.4.6 使用外部包（package）</h4><ol><li>cargo.toml 添加依赖的包（package）</li><li>use将特定条目引入作用域；</li></ol><h5 id="8-4-6-1-切换国内镜像"><a href="#8-4-6-1-切换国内镜像" class="headerlink" title="8.4.6.1 切换国内镜像"></a>8.4.6.1 切换国内镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">where</span> cargo</span><br><span class="line">$&gt; <span class="built_in">cd</span> /Users/xx/.cargo/</span><br><span class="line">$&gt; ls -a</span><br><span class="line">$&gt; vim config</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = <span class="string">"https://github.com/rust-lang/crates.io-index"</span></span><br><span class="line"></span><br><span class="line">replace-with = <span class="string">'tuna'</span></span><br><span class="line">[source.tuna]</span><br><span class="line">registry = <span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"</span></span><br><span class="line"></span><br><span class="line">[net]</span><br><span class="line">git-fetch-with-cli = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="8-5-将模块拆分为不同文件"><a href="#8-5-将模块拆分为不同文件" class="headerlink" title="8.5 将模块拆分为不同文件"></a>8.5 将模块拆分为不同文件</h3><p>将模块内容移动到其它文件</p><p>模块定义时，如果模块名后边是； ，而不是代码块</p><ul><li>Rust 会从与模块同名的文件中加载内容</li><li>模块树的结构不会变化</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- src</span><br><span class="line">|- /front_of_house</span><br><span class="line">|- hosting.rs</span><br><span class="line">|- front_of_houre.rs</span><br><span class="line">|- lib.rs</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"><span class="comment">// hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>随着模块逐渐变大，该技术让你可以把模块的内容移动到其它文件中；</p><h2 id="9-集合"><a href="#9-集合" class="headerlink" title="9. 集合"></a>9. 集合</h2><h3 id="9-1-Vector"><a href="#9-1-Vector" class="headerlink" title="9.1 Vector"></a>9.1 Vector</h3><p> Vec<T>,叫作vector</p><ul><li>由标准库提供</li><li>可存储多个值</li><li>只能存储相同类型的数据</li><li>值在内存中连续存放</li></ul><h4 id="9-1-1-创建"><a href="#9-1-1-创建" class="headerlink" title="9.1.1 创建"></a>9.1.1 创建</h4><p>Vec<T>  使用 vec! 宏</p><h4 id="9-1-2-所有权和借用规则"><a href="#9-1-2-所有权和借用规则" class="headerlink" title="9.1.2 所有权和借用规则"></a>9.1.2 所有权和借用规则</h4><p>不能在同一作用域内同时拥有可变和不可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line">  <span class="keyword">let</span> first = &amp;v[<span class="number">0</span>]; <span class="comment">// 不可变借用</span></span><br><span class="line">  v.push(<span class="number">6</span>); <span class="comment">// 可变的借用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector的工作原理： vec里面的元素在内存中的摆放是连续的，所以再往vec中添加一个元素的时候，在内存中就没有这么大的连续内存块。就可能将内存重新分配一下了，再找一个足够大的内存来放置这些添加了元素之后的vector，原来那块内存可能被释放掉或者重新分配，而first变量仍然指向原来的内存地址，这样的话，程序必然出现问题了；所以，借用规则防止类似的情况发生</p><h4 id="9-1-3-遍历"><a href="#9-1-3-遍历" class="headerlink" title="9.1.3 遍历"></a>9.1.3 遍历</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-4-vector-enum"><a href="#9-1-4-vector-enum" class="headerlink" title="9.1.4 vector+enum"></a>9.1.4 vector+enum</h4><p>使用enum来存储多种数据类型</p><ul><li>enum的变体可以附加不同类型的数据</li><li>enum的变体定义在同一个enum类型下</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="9-2-String"><a href="#9-2-String" class="headerlink" title="9.2 String"></a>9.2 String</h3><p>字符串困扰</p><ul><li>Rust倾向于暴露可能的错误</li><li>字符串数据结构复杂</li><li>UTF-8</li></ul><h4 id="9-2-1-定义"><a href="#9-2-1-定义" class="headerlink" title="9.2.1 定义"></a>9.2.1 定义</h4><p>Rust的核心语言层面，只有字符串类型：字符串切片 str （&amp;str）</p><ul><li>字符串切片： 对存储在其它地方、utf-8编码的字符串引用<ul><li>字符串字面值： 存储在二进制文件中，也是字符串切片</li></ul></li></ul><h4 id="9-2-2-String类型"><a href="#9-2-2-String类型" class="headerlink" title="9.2.2 String类型"></a>9.2.2 String类型</h4><p>来自标准库 而不是核心语言</p><ul><li>可增长，可修改，可拥有</li><li>UTF-8 编码</li></ul><h4 id="9-2-3-其它类型的字符串"><a href="#9-2-3-其它类型的字符串" class="headerlink" title="9.2.3 其它类型的字符串"></a>9.2.3 其它类型的字符串</h4><p>Rust标准库还包含了很多其它的字符串类型， OsString、OsStr、CString、CStr</p><ul><li>String vs Str后缀： 拥有或借用的变体</li><li>可存储不同编码的文本或在内存中以不同的形式展现</li></ul><h4 id="9-2-4-使用初始值创建String"><a href="#9-2-4-使用初始值创建String" class="headerlink" title="9.2.4 使用初始值创建String"></a>9.2.4 使用初始值创建String</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">"initial contents"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = data.to_string();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">"initial contents"</span>.to_string();</span><br><span class="line"><span class="comment">// 字符串字面值创建String</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"initial contents"</span>);</span><br></pre></td></tr></table></figure><h4 id="9-2-5-更新"><a href="#9-2-5-更新" class="headerlink" title="9.2.5 更新"></a>9.2.5 更新</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"bar"</span>);</span><br><span class="line">  s.push_str(&amp;s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">   <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"bar"</span>);</span><br><span class="line">   <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">   <span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// // 注意 s1 被移动了，不能继续使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为在使用了 +，实际上使用了类似 下面 add这样的方法,当然标准库里面是泛型方法，这里为了理解，给替换成string类型先</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, s:&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span>&#123;...&#125; <span class="comment">// 参数1是 String，而不是切片，所以s1失去了所有权；</span></span><br></pre></td></tr></table></figure><p>标准库中的add使用了泛型</p><p>只能把&amp;str添加到String</p><p>解引用强制转换（deref coercion）</p><h4 id="9-2-6-format-连接多个字符串"><a href="#9-2-6-format-连接多个字符串" class="headerlink" title="9.2.6 format! 连接多个字符串"></a>9.2.6 format! 连接多个字符串</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="symbol">'tic</span>');</span><br><span class="line">  <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="symbol">'tac</span>');</span><br><span class="line">  <span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="symbol">'toe</span>');</span><br><span class="line">  <span class="keyword">let</span> s3 = s1 + <span class="string">"-"</span> + &amp;s2 + <span class="string">"-"</span> + &amp;s3;</span><br><span class="line">  <span class="comment">// 类似于</span></span><br><span class="line">  <span class="built_in">format!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3); <span class="comment">// format! 宏不会取得后续所有参数的所有权</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>format! 宏不会取得后续所有参数的所有权</p><h4 id="9-2-7-索引字符串"><a href="#9-2-7-索引字符串" class="headerlink" title="9.2.7 索引字符串"></a>9.2.7 索引字符串</h4><p>Rust字符串不支持索引；</p><h4 id="9-2-8-bytes，scalar-Values，-Grapheme-Clusters-字节、标量值、字形簇"><a href="#9-2-8-bytes，scalar-Values，-Grapheme-Clusters-字节、标量值、字形簇" class="headerlink" title="9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇"></a>9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> w = <span class="string">"नमस्ते"</span>;</span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> w.bytes()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    <span class="comment">// [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> w.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    <span class="comment">// ['न', 'म', 'स', '्', 'त', 'े']</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-9-Rust不允许对String进行索引最后一个原因"><a href="#9-2-9-Rust不允许对String进行索引最后一个原因" class="headerlink" title="9.2.9 Rust不允许对String进行索引最后一个原因"></a>9.2.9 Rust不允许对String进行索引最后一个原因</h4><ul><li>索引操作应消耗一个常量时间（O（1））</li><li>而String无法保证，需要遍历所有内容，来确定有多少个合法的字符</li></ul><h4 id="9-2-10-字符串切割"><a href="#9-2-10-字符串切割" class="headerlink" title="9.2.10 字符串切割"></a>9.2.10 字符串切割</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure><h3 id="9-3-HashMap"><a href="#9-3-HashMap" class="headerlink" title="9.3 HashMap"></a>9.3 HashMap</h3><p>对于实现Copy trait的类型（i32），值会被复制到HashMap中</p><p>对于拥有所有权的值（String），值会被移动，所有权会转移给HashMap</p><p>如果将值的引用插入到HashMap，值本身就不会移动</p><ul><li>在hashMap有效的期间，被引用的值必须保持有效</li></ul><h4 id="9-3-1-get"><a href="#9-3-1-get" class="headerlink" title="9.3.1 get"></a>9.3.1 get</h4><p>可以通过get方法并提供对应的键来从哈希map中获取值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">  scores.insert(<span class="built_in">String</span>::from(<span class="string">"blue"</span>), <span class="number">10</span>);</span><br><span class="line">  scores.insert(<span class="built_in">String</span>::from(<span class="string">"yellow"</span>), <span class="number">50</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"blue"</span>);</span><br><span class="line">  <span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">match</span> score &#123;</span><br><span class="line">    <span class="literal">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s), <span class="comment">// 10</span></span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"team not exist"</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-2-更新HashMap"><a href="#9-3-2-更新HashMap" class="headerlink" title="9.3.2 更新HashMap"></a>9.3.2 更新HashMap</h3><ul><li><p>K已经存在，对应一个V</p><ul><li>替换现有的V</li><li>保留现有的V，忽略新的V</li><li>合并现有的V和新的V</li></ul></li><li><p>K不存在</p><ul><li>添加一对K，V</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure><h5 id="9-3-2-1-entry"><a href="#9-3-2-1-entry" class="headerlink" title="9.3.2.1 entry"></a>9.3.2.1 entry</h5><p>entry方法： 检查指定的K是否对应一个V</p><ul><li>参数为K</li><li>返回enum Entry：代表值是否存在</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure><p>Entry的 or_insert 方法</p><ul><li>返回<ul><li>如果K存在，返回到对应的V的一个可变引用</li><li>如果K不存在，将方法参数作为K的新值插进去，返回到这个值的可变引用；</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据旧值更新一个值</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, map);</span><br></pre></td></tr></table></figure><h2 id="10-panic"><a href="#10-panic" class="headerlink" title="10. panic"></a>10. panic</h2><p>  Rust错误分类</p><ul><li>可恢复<ul><li>例如文件未找到，可再次尝试</li></ul></li><li>不可恢复<ul><li>bug，例如访问的索引超出范围</li></ul></li></ul><p>Rust没有类似异常的机制</p><ul><li>可恢复错误： Result&lt;T,E&gt;</li><li>不可恢复： painc！</li></ul><p>当执行painc！时，程序立即结束执行</p><p>不可恢复的错误与panic！</p><p>当panic！宏执行：</p><ul><li><p>你的程序会打印一个错误信息</p></li><li><p>展开（unwind）、清理调用栈（Stack）</p></li><li><p>退出程序</p></li></ul><p>为应对panic，展开或中止（abort）调用栈</p><ul><li><p>默认情况下，当panic发生：</p><ul><li>-程序展开调用栈（工作量大）<ul><li>rust沿着调用栈往回走</li><li>清理每个遇到的函数中的数据</li></ul></li><li>或立即中止调用栈：<ul><li>不进行清理，直接停止程序</li><li>内存需要OS进行清理</li></ul></li></ul></li><li><p>想让二进制文件更小，把设置从“展开”改为“中止”：</p><ul><li>在Cargo.toml中适当的profile部分设置：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = <span class="string">'abort'</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可恢复的错误与panic！</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">"crash and burn"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-1-Result-与可恢复的错误"><a href="#10-1-Result-与可恢复的错误" class="headerlink" title="10.1 Result 与可恢复的错误"></a>10.1 Result 与可恢复的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="literal">Ok</span>(T),</span><br><span class="line">  <span class="literal">Err</span>(E)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T: 操作成功情况下，Ok变体里返回的数据的类型</p><p>E： 操作失败情况下，Err变体里返回的错误的类型</p><p>处理Result的一种方式： match表达式</p><p>和Option枚举一样，Result及其变体也是有prelude带入作用域</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"./0.txt"</span>);</span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Error opening file &#123;:?&#125;"</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-匹配不同的错误"><a href="#10-2-匹配不同的错误" class="headerlink" title="10.2 匹配不同的错误"></a>10.2 匹配不同的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">"hello.txt"</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: &#123;:?&#125;"</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: &#123;:?&#125;"</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例使用了很多match</p><p>match很有用，但是很原始</p><p>闭包（closure）。Result&lt;T,E&gt;有很多方法</p><ul><li>它们接收闭包作为参数</li><li>使用match实现</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(<span class="string">"hello.txt"</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: &#123;:?&#125;"</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: &#123;:?&#125;"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-1-unwrap"><a href="#10-2-1-unwrap" class="headerlink" title="10.2.1 unwrap"></a>10.2.1 unwrap</h4><p>unwrap： match表达式的一个快捷方法；</p><ul><li>如果Result结果是Ok，返回Ok里面的值</li><li>如果Result结果是Err，调用panic！宏</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"0.txt"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Error opening file &#123;:?&#125;"</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> f = File::open(<span class="string">"0.txt"</span>).unwrap(); <span class="comment">// 相当于上面的match表达式</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2-expect"><a href="#10-2-2-expect" class="headerlink" title="10.2.2 expect"></a>10.2.2 expect</h4><p>expect： 和unwrap类似，但可指定错误信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-传播错误"><a href="#10-3-传播错误" class="headerlink" title="10.3 传播错误"></a>10.3 传播错误</h3><p>当编写一个其实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 <strong>传播</strong>（<em>propagating</em>）错误，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">match</span> f.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="literal">Ok</span>(s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>?运算符</p><p>?运算符： 传播错误的一种快捷方式</p><p>？与from函数</p><ul><li>Trait std::convert::From 上的from函数：<ul><li>用于错误之间的转换</li></ul></li><li>被？所应用的错误，会隐士的被from函数处理</li><li>当？调用from函数时：<ul><li>它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</li></ul></li></ul><p>用于： 针对不同错误的原因，返回同一种错误类型</p><ul><li>只要每个错误类型实现了转换为所返回的错误类型的from函数</li></ul><p>链式操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    File::open(<span class="string">"hello.txt"</span>)?.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>?运算符只能用于返回Result的函数</p><p>?运算符与main函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main中使用？</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()-&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">  <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数返回类型是：()</p><p>main函数的返回类型也可以是： Result&lt;T,E&gt;</p><p>Box<dyn Error>是trait对象</p><ul><li>简单理解： “任何可能的错误类型”</li></ul><h3 id="10-4-什么时候应该用panic"><a href="#10-4-什么时候应该用panic" class="headerlink" title="10.4 什么时候应该用panic!"></a>10.4 什么时候应该用panic!</h3><p>见示例</p><h2 id="11-泛型，Trait-生命周期"><a href="#11-泛型，Trait-生命周期" class="headerlink" title="11. 泛型，Trait 生命周期"></a>11. 泛型，Trait 生命周期</h2><h3 id="11-1-泛型"><a href="#11-1-泛型" class="headerlink" title="11.1 泛型"></a>11.1 泛型</h3><p>你编些的代码不是最终的代码，而是一种模版，里面有一些“占位符”；</p><p>编译器在编译时将“占位符”替换为具体的类型；</p><p>在编译的时候，会将泛型的类型参数编译成具体的类型。这个过程叫单态化；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> char_list = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-Trait"><a href="#11-2-Trait" class="headerlink" title="11.2 Trait"></a>11.2 Trait</h3><ul><li>Trait告诉rust编译器：<ul><li>某种类型具有哪些并且可以与其它类型共享的功能</li></ul></li><li>Trait：抽象的定义共享行为</li><li>Trait bounds（约束）泛型类型参数指定为实现了特定行为的类型；</li><li>Trait 与其它语言的接口（interface）类似，但有些区别；</li></ul><h4 id="11-2-1-如何定义一个trait"><a href="#11-2-1-如何定义一个trait" class="headerlink" title="11.2.1 如何定义一个trait"></a>11.2.1 如何定义一个trait</h4><p>类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。</p><p>trait 定义： 是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p><ul><li>关键字： trait</li><li>只有方法签名，没有具体实现</li><li>trait可以有多个方法： 每个方法签名占一行，以；结尾</li><li>实现该trait的类型必须提供具体的方法实现；</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123; <span class="comment">// 一个trait， 可以有多个方法的签名 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sunmmary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-2-2-在类型上实现trait"><a href="#11-2-2-在类型上实现trait" class="headerlink" title="11.2.2 在类型上实现trait"></a>11.2.2 在类型上实现trait</h4><p>与为类型实现方法类似</p><p>不同之处：</p><ul><li>impl  类型  for  trait名{}  // 为类型实现方法则是   <code>impl 类型 {...}</code></li><li>在impl的块里，需要对Trait里的方法签名进行具体的实现</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123; <span class="comment">// 一个trait， 可以有多个方法的签名 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-2-3-实现trait的约束"><a href="#11-2-3-实现trait的约束" class="headerlink" title="11.2.3 实现trait的约束"></a>11.2.3 实现trait的约束</h4><p>可以在某个类型上实现某个trait的前提条件是：</p><ul><li>这个类型或这个trait是在本地crate里定义的</li></ul><p>无法为外部类型来实现外部的trait；</p><ul><li>这个限制是程序属性的一部分（也就是一致性）</li><li>更具体地说是孤儿规则： 之所以这样命名是因为父类型不存在；</li><li>此规则确保其它人的代码不能破坏您的代码，反之亦然；</li><li>如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了；</li></ul><h4 id="11-2-4-默认实现"><a href="#11-2-4-默认实现" class="headerlink" title="11.2.4 默认实现"></a>11.2.4 默认实现</h4><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123;</span><br><span class="line">  <span class="comment">// 一个trait， 可以有多个方法的签名</span></span><br><span class="line">  <span class="comment">// fn summarize(&amp;self) -&gt; String;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize1</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">"(...)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Sunmmary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">  <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Sunmmary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认实现的方法可以调用trait中其它的方法，即使这些方法没有默认实现</p><p>注意： 无法从方法的重写实现里面调用默认的实现</p><h4 id="11-2-5-Trait作为参数"><a href="#11-2-5-Trait作为参数" class="headerlink" title="11.2.5 Trait作为参数"></a>11.2.5 Trait作为参数</h4><p><strong>impl Trait语法</strong></p><p>适用于简单情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123;</span><br><span class="line">  <span class="comment">// 一个trait， 可以有多个方法的签名</span></span><br><span class="line">  <span class="comment">// fn summarize(&amp;self) -&gt; String;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize1</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">"(...)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123; <span class="comment">// 类型区域 添加 impl Summary</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Trait bound语法</strong></p><p>可用于复杂情况</p><ul><li>impl Trait 语法是 Trait bound的语法糖</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用  +  ，指定多个 Trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display) &#123; <span class="comment">// 类型区域 添加 impl Summary</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item1: T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Trait bound 使用where子句</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T, U&gt;(a: T, b: U) -&gt; <span class="built_in">String</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, a.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现Trait作为返回类型</li></ul><p>impl Trait 语法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify1</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">  NewsArticle &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>::from(<span class="string">""</span>),</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错</p><p>使用Trait Bound的例子</p><ul><li>例子： 使用Trait Bound修复largest函数</li></ul><ul><li>使用Trait Bound有条件的实现方法<ul><li>在使用泛型类型参数的impl块上使用 Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以为实现了其它Trait的任意类型有条件的实现某个Trait</li><li>为满足Trait Bound 的所有类型上实现Trait叫做覆盖实现；</li></ul><h3 id="11-3-生命周期"><a href="#11-3-生命周期" class="headerlink" title="11.3 生命周期"></a>11.3 生命周期</h3><p>Rust的每个引用都有自己的生命周期</p><p>声明周期： 引用保持有效的作用域</p><p>大多数情况： 声明周期是隐式的、可被推断的</p><p>当引用的声明周期可能以不同的方式互相关联时： 手动标注声明周期</p><h4 id="11-3-1-生命周期——避免悬垂引用"><a href="#11-3-1-生命周期——避免悬垂引用" class="headerlink" title="11.3.1 生命周期——避免悬垂引用"></a>11.3.1 生命周期——避免悬垂引用</h4><p>生命周期的主要目标： 避免悬垂引用（dangling reference）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> r;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    r = &amp;x; <span class="comment">// error , x走出作用域之后被释放掉了；</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"r: &#123;&#125;"</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust如何识别上面代码不合法呢？答案是 借用检查器</p><h4 id="11-3-2-借用检查器"><a href="#11-3-2-借用检查器" class="headerlink" title="11.3.2 借用检查器"></a>11.3.2 借用检查器</h4><p>Rust编译器的借用检查器： 比较作用域来判断所有的借用是否合法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r;                <span class="comment">// ---------+-- 'a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">5</span>;        <span class="comment">// -+-- 'b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r: &#123;&#125;"</span>, r); <span class="comment">// ---------+         </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-3-函数中的泛型生命周期"><a href="#11-3-3-函数中的泛型生命周期" class="headerlink" title="11.3.3 函数中的泛型生命周期"></a>11.3.3 函数中的泛型生命周期</h4><h5 id="11-3-3-1-生命周期标注"><a href="#11-3-3-1-生命周期标注" class="headerlink" title="11.3.3.1 生命周期标注"></a>11.3.3.1 生命周期标注</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"abc"</span>; <span class="comment">// 字符串字面量，也就是字符串切片类型</span></span><br><span class="line">    <span class="keyword">let</span> result = longest(&amp;string1, string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"longest -&gt; &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要让参数 x，y 和 返回值 做生命周期的关联</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-3-3-2-生命周期标注"><a href="#11-3-3-2-生命周期标注" class="headerlink" title="11.3.3.2 生命周期标注"></a>11.3.3.2 生命周期标注</h5><p>生命周期标注语法</p><ul><li>生命周期的标注不会改变引用的生命周期长度</li><li>当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用</li><li>生命周期的标注： 描述了多个引用的生命周期间的关系，但不影响生命周期</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"abc"</span>; <span class="comment">// 字符串字面量，也就是字符串切片类型</span></span><br><span class="line">    <span class="keyword">let</span> result = longest(&amp;string1, string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"longest -&gt; &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要让参数 x，y 和 返回值 做生命周期的关联</span></span><br><span class="line"><span class="comment">// 'a 为生命周期的标注： 描述了多个引用的生命周期的关系</span></span><br><span class="line"><span class="comment">// 不影响生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期参数名：</p><ul><li>以 单引号 开头</li><li>通常全小写非常短</li><li>很多使用’a</li></ul><p>生命周期标注的位置</p><ul><li>在引用的 &amp; 符号后</li><li>使用空格将标注 和 引用类型 分开</li></ul><p>生命周期的标注</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span> <span class="comment">// 一个引用</span></span><br><span class="line">&amp; <span class="symbol">'a</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp; <span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><p>单个生命周期标注本身没有意义</p><p>标注之所以存在，是为了向rust描述多个泛型生命周期参数之间的关系</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  'a 生命周期取决于 x 和 y中 存活时间较短的那个</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure><h4 id="11-3-4-深入理解生命周期"><a href="#11-3-4-深入理解生命周期" class="headerlink" title="11.3.4 深入理解生命周期"></a>11.3.4 深入理解生命周期</h4><p>指定生命周期参数的方式依赖于函数所做的事情</p><p>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配；</p><p>如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值：</p><ul><li>这就是悬垂引用，该值在函数结束时就走出了作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">  <span class="keyword">let</span> string2 = <span class="string">"xyz"</span>;</span><br><span class="line">  <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"the longest string is&#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp; <span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"abc"</span>);</span><br><span class="line"> <span class="comment">// result.as_str() // 报错，字符串切片引用会随着函数执行完毕被释放，所以会导致 悬垂引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法一：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp; <span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"abc"</span>);</span><br><span class="line"> result <span class="comment">// 把函数所有权移交给调用者；然后这块内存清理就交由调用者来清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个例子看出，生命周期语法就是用来关联函数的不同参数以及返回值之间生命周期的。一旦它们取得某种联系，rust就获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其它违反内存安全的行为；</p><h5 id="11-3-4-1-Struct定义中的生命周期标注"><a href="#11-3-4-1-Struct定义中的生命周期标注" class="headerlink" title="11.3.4.1 Struct定义中的生命周期标注"></a>11.3.4.1 Struct定义中的生命周期标注</h5><p>Struct里可包括：</p><ul><li>自持有的类型 </li><li>引用： 需要在每个引用上添加生命周期标注</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"call me inhmael, Some years age..."</span>);</span><br><span class="line">  <span class="comment">// first_sentence 的生命周期反问大于 结构体内的 first_sentence；所以此段代码可以编译通过</span></span><br><span class="line">  <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not found a '.'"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> i = ImportantExcerpt&#123;</span><br><span class="line">    part: first_sentence</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-3-4-2-生命周期的省略"><a href="#11-3-4-2-生命周期的省略" class="headerlink" title="11.3.4.2 生命周期的省略"></a>11.3.4.2 生命周期的省略</h5><p>每个引用都有生命周期</p><p>需要为使用生命周期的函数或struct指定生命周期参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有指定生命周期参数却通过编译</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">  <span class="keyword">for</span>(i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而之前的例子告诫我们应该写成下面这种才能编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s : &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp; <span class="symbol">'a</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p> Rust发现，在某些特定情况下。程序员总是一遍又一遍编写同样的生命周期标注。而且这种场景是可预测的。它有一些明确的模式</p><p>于是，rust团队就将这些模式写入了编译器代码。就使得借用检查器在这些情况下可以自动的对生命周期进行推导，而无需显式的标注。</p><p>了解这段历史是有必要的，因为在未来可能会有更多的特定模式被直接添加到编译器当中；也就是说在未来需要手动标注生命周期的地方可能会越来越少；</p><h5 id="11-3-4-3-生命周期省略规则"><a href="#11-3-4-3-生命周期省略规则" class="headerlink" title="11.3.4.3 生命周期省略规则"></a>11.3.4.3 生命周期省略规则</h5><p>这个在Rust引用分析中所编入的模式就称为生命周期省略规则；</p><ul><li>这些规则无需开发者来遵守</li><li>它们是一些特殊情况，由编译器来考虑</li><li>如果你的代码复合这些情况，那么久无需显式标注生命周期</li></ul><p>生命周期省略规则不会提供完整的推断：</p><p>如果应用规则后，引用的生命周期仍然模糊不清-&gt; 编译错误</p><p>解决方法： 添加生命周期标注，表明引用间的相互关系</p><h5 id="11-3-4-4-输入、输出生命周期"><a href="#11-3-4-4-输入、输出生命周期" class="headerlink" title="11.3.4.4 输入、输出生命周期"></a>11.3.4.4 输入、输出生命周期</h5><p>生命周期在</p><ul><li>函数/方法的参数： 输入生命周期</li><li>函数/方法的返回值： 输出生命周期</li></ul><h5 id="11-3-4-5-生命周期省略的三个规则"><a href="#11-3-4-5-生命周期省略的三个规则" class="headerlink" title="11.3.4.5 生命周期省略的三个规则"></a>11.3.4.5 生命周期省略的三个规则</h5><p>编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期；</p><ul><li>规则1 应用于输入生命周期</li><li>规则2、3 应用于输出生命周期</li><li>如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用 -&gt; 报错</li><li>这些规则适用于fn定义 和 impl块</li></ul><p><strong>规则1: 每个引用类型的参数都有自己的生命周期</strong></p><p>换句话说，单参数的函数它就拥有一个生命周期参数，而拥有两个参数的函数就拥有两个不同的生命周期参数。</p><p><strong>规则2: 如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数</strong></p><p><strong>规则3： 如果有多个输入生命周期参数，但其中一个是 &amp;self 或者 &amp; mut self（是方法），那么self的生命周期会被赋给所有的输出生命周期参数</strong></p><p>demo1</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 首先适用第一条规则，单参数函数它拥有一个生命周期参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 第二条规则，如果只有1个输入生命周期参数，该生命周期被赋给所有输出生命周期参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp; <span class="symbol">'a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure><p>demo2</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">//首先应用规则1，两个参数都有自己的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>,<span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>)-&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 因为有两个参数，所以第二条规则已经不适用了</span></span><br><span class="line"><span class="comment">// 没有self，所有第三条也不适用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在应用完三条规则之后，依然无法计算出返回类型的生命周期。所以编译器报错。</span></span><br></pre></td></tr></table></figure><h4 id="11-3-5-方法定义中的生命周期标注"><a href="#11-3-5-方法定义中的生命周期标注" class="headerlink" title="11.3.5 方法定义中的生命周期标注"></a>11.3.5 方法定义中的生命周期标注</h4><p>在struct上使用生命周期实现方法，语法和泛型参数的语法一样</p><ul><li>在哪儿声明和使用生命周期参数 依赖于<ul><li>生命周期参数是否和字段、方法的参数或返回值有关</li></ul></li></ul><p>struct字段的生命周期名：</p><ul><li>在impl后声明</li><li>在struct名后使用</li><li>这些生命周期是struct类型的一部分</li></ul><p>impl块内的方法签名中：</p><ul><li><p>引用必须绑定于struct字段引用的生命周期，或者引用是独立的也可以</p></li><li><p>生命周期省略规则经常使用方法中的生命周期标注不是必须的；</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// impl 后面 和结构体后面 的生命周期参数不能省略</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"Call me Ishmael,Some..."</span>);</span><br><span class="line">  <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not found a '.'"</span>);</span><br><span class="line">  <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">    part: first_sentence</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-6-静态生命周期"><a href="#11-3-6-静态生命周期" class="headerlink" title="11.3.6 静态生命周期"></a>11.3.6 静态生命周期</h4><p>‘static 是一个特殊的生命周期： 整个程序的持续时间；</p><ul><li>例如： 所有的字符串字面值都拥有 ‘static 生命周期</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"i have a static lifetime"</span></span><br><span class="line"><span class="comment">// 这个字符串字面值，它是被直接存储在二进制程序里面。所以它总是可用的。所以所有字符串字面值的生命周期都是 'static</span></span><br></pre></td></tr></table></figure><p>为引用指定 ‘static 生命周期前要三思</p><ul><li>是否需要引用在程序整个生命周期内都存活</li></ul><p>因为在大部分情况下，错误的原因都在于尝试创建一个悬垂引用或者是可用生命周期不匹配。这个时候应该去尝试解决这些问题，而不是指定一个 ‘static </p><p><strong>一个涉及泛型参数类型、Trait Bound、生命周期的例子</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_announcement</span></span>&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line">(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, ann: T) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">where</span> T: Display,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"Announcement! &#123;&#125;"</span>, ann);</span><br><span class="line">  <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="12-编写自动化测试"><a href="#12-编写自动化测试" class="headerlink" title="12 编写自动化测试"></a>12 编写自动化测试</h2><h3 id="12-1-编写和运行测试"><a href="#12-1-编写和运行测试" class="headerlink" title="12.1 编写和运行测试"></a>12.1 编写和运行测试</h3><p>测试</p><ul><li>函数</li><li>验证非测试代码的功能是否和预期一致</li></ul><p>测试函数体（通常）执行的3个操作 （3A操作）</p><ul><li>准备数据/状态 Arrange</li><li>运行被测试的代码  Act</li><li>断言（Assert）结果 Assert</li></ul><p>解剖测试函数</p><p>测试函数需要使用test属性（attribute）进行标注</p><ul><li>Attribute 就是一段Rust代码的元数据，它不会被改变被它修饰代码的逻辑，它只是被代码进行修饰或标注</li><li>在函数上面一行加上 #[test]，可以函数变为测试函数</li></ul><p>运行测试</p><ul><li>使用cargo test命令运行所有测试函数<ul><li>Rust会构建一个Test Runner可执行文件<ul><li>它会运行标注了test的函数，并报错其运行是否成功</li></ul></li></ul></li><li>当使用cargo 创建library项目的时候，会生成一个test module，里面有一个test函数；<ul><li>你可以添加任意数量的test module或函数</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$&gt; cargo new adder --lib <span class="comment"># 创建一个库项目 adder</span></span><br><span class="line">$&gt; <span class="built_in">cd</span> adder &amp;&amp; cargo <span class="built_in">test</span> <span class="comment"># 运行测试</span></span><br><span class="line"></span><br><span class="line">$&gt; Compiling adder v0.1.0 (/Users/ruanhan/rust_pro/adder)</span><br><span class="line"></span><br><span class="line">Finished <span class="built_in">test</span> [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 1.25s</span><br><span class="line"></span><br><span class="line">Running target/debug/deps/adder-710a662a5bf33e5e</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 tests::it_works </span></span><br><span class="line"><span class="built_in">test</span> tests::it_works ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br><span class="line"></span><br><span class="line">Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br></pre></td></tr></table></figure><p>测试失败</p><ul><li>测试函数panic就表示失败</li><li>每个测试运行在一个新线程</li><li>当主线程看见某个测试线程挂掉了，那个测试标记为失败了；</li></ul><h3 id="12-2-断言宏（Assert）"><a href="#12-2-断言宏（Assert）" class="headerlink" title="12.2 断言宏（Assert）"></a>12.2 断言宏（Assert）</h3><p>使用assert! 宏检查测试结果</p><p>assert！ 宏，来自标准库，用来确定某个状态是否为true</p><ul><li>true 测试通过</li><li>false 调用panic！，测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">larger_can_hold_smaller</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> larger = Rectangle &#123;</span><br><span class="line">            width: <span class="number">8</span>,</span><br><span class="line">            height: <span class="number">7</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> smaller = Rectangle &#123;</span><br><span class="line">            width: <span class="number">5</span>,</span><br><span class="line">            height: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(larger.can_hold(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用assert_eq! 和 assert_ne! 测试相等性</strong></p><p>都来自标准库</p><p>判断两个参数是否 相等或不等；</p><p>实际上，它们使用的就是 == 和 != 运算符</p><p>断言失败： 自动打印出两个参数的值；</p><ul><li>使用debug格式打印参数<ul><li>要求参数实现了 PartiaEq 和 Debug Traits（所有的基本类型和标准库里大部分类型都实现了）</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests1 &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, add_two(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-自定义错误信息"><a href="#12-3-自定义错误信息" class="headerlink" title="12.3 自定义错误信息"></a>12.3 自定义错误信息</h3><p>可以向 assert!    assert_eq!   assert_ne! 添加可选的自定义信息</p><ul><li>这些自定义消息和失败消息都会打印出来</li><li>assert!: 第1参数必填，自定义消息作为第2个参数</li><li>assert_eq!   assert_ne! ： 前2个参数必填，自定义消息作为第3个参数；</li><li>自定义消息参数会被传递给 format!  宏，可以使用{} 占位符</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">greeting</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Hello &#123;&#125;!"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greeting_contain_name</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = greeting(<span class="string">"Carol"</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(result.contains(<span class="string">"Caro1l"</span>), <span class="string">"错误信息是 '&#123;&#125;'"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-用should-panic检查恐慌"><a href="#12-4-用should-panic检查恐慌" class="headerlink" title="12.4 用should_panic检查恐慌"></a>12.4 用should_panic检查恐慌</h3><p>验证错误处理的情况</p><ul><li>测试除了验证代码的返回值是否正确，还需验证代码是否如预期的处理了发生错误的情况；</li><li>可验证代码在特定情况下是否发生了panic</li><li>这种测试需要添加 should_panic 属性</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be between 1 and 100, got &#123;&#125;."</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为should_panic 属性添加一个可选的expected参数，让should_panic更精确；将检查失败信息中是否包含所指定文字；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[should_panic(expected=<span class="meta-string">"guess value must be less than ..."</span>)]</span></span><br></pre></td></tr></table></figure><h3 id="12-5-在测试中使用Result-lt-T-E-gt"><a href="#12-5-在测试中使用Result-lt-T-E-gt" class="headerlink" title="12.5 在测试中使用Result&lt;T,E&gt;"></a>12.5 在测试中使用Result&lt;T,E&gt;</h3><p>无需panic，可使用Result&lt;T,E&gt; 作为返回类型编写测试：</p><ul><li>返回Ok： 测试通过</li><li>返回Err： 测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line">mode test &#123;</span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span> -&gt; <span class="title">Result</span></span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>+<span class="number">2</span> ==<span class="number">4</span> &#123;</span><br><span class="line">      <span class="literal">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">"not equal"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 不要在使用Result&lt;T,E&gt; 编写的测试上标注</p><p>#[should_panic]</p><h3 id="12-6-控制测试如何运行"><a href="#12-6-控制测试如何运行" class="headerlink" title="12.6 控制测试如何运行"></a>12.6 控制测试如何运行</h3><p>改变cargo test的行为： 添加命令行参数</p><p>不添加任何参数就是默认行为</p><ul><li>并行运行</li><li>所有测试</li><li>捕获（不显示）所有输出，使读取与测试结果相关的输出更容易</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示cargo test命令 所用的参数有哪些</span></span><br><span class="line">cargo <span class="built_in">test</span> --<span class="built_in">help</span> </span><br><span class="line"><span class="comment"># 显示出所有可以用在-- 后的参数，给二进制程序添加的参数</span></span><br><span class="line">cargo <span class="built_in">test</span> -- --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="12-7-并行-连续运行测试"><a href="#12-7-并行-连续运行测试" class="headerlink" title="12.7 并行/连续运行测试"></a>12.7 并行/连续运行测试</h3><p>运行多个测试： 默认使用多个线程并行运行；</p><ul><li>运行快</li></ul><p>确保测试之间</p><ul><li>不会互相依赖</li><li>不依赖于某个共享状态（环境、工作目录、环境变量等）</li></ul><p>显式函数输出</p><p>默认，如测试通过，rust的test库会捕获所有打印到标准输出的内容</p><p>例如： 如果被测试代码中用到了println!</p><ul><li>如果测试通过： 不会在终端看到println! 打印的内容</li><li>如果测试失败： 会看到println! 打印的内容和失败信息</li></ul><p>如果想在成功的测试中看到打印的内容： –show-output</p><h3 id="12-8-按名称运行测试"><a href="#12-8-按名称运行测试" class="headerlink" title="12.8 按名称运行测试"></a>12.8 按名称运行测试</h3><p>运行单个测试： 指定测试名</p><p>运行多个测试： 指定测试名的一部分（模块名也可以）</p><h3 id="12-9-忽略测试"><a href="#12-9-忽略测试" class="headerlink" title="12.9 忽略测试"></a>12.9 忽略测试</h3><p>忽略某些测试，运行剩余测试</p><ul><li>ignore属性（attribute）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="meta">#[ignore]</span> <span class="comment">// 忽略 expensive_test这个测试</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cargo test – –ignore  单独执行此忽略的测试</p><h3 id="12-10-测试的分类"><a href="#12-10-测试的分类" class="headerlink" title="12.10 测试的分类"></a>12.10 测试的分类</h3><p>Rust对测试的分类</p><ul><li>单元测试</li><li>集成测试</li></ul><p>单元测试</p><ul><li>小、专注</li><li>一次对一个模块进行隔离的测试</li><li>可测试private接口</li></ul><p>集成测试：</p><p>在库外部，和其它外部代码一样使用你的代码</p><p>只能使用public接口</p><p>可能在每个测试中使用多个模块</p><p>#[cfg(test)] 标注</p><p>test 模块上的 #[cfg(test)]标注</p><ul><li>只有运行 cargo test 才编译和运行代码</li><li>运行cargo build则不会</li></ul><p>集成测试在不同的目录，它不需要 #[cfg(test)] 标注</p><p>cfg：configuration</p><ul><li>告诉rust下面的条目只有在特定的配置选项下才被包含</li><li>配置选项test： 由Rust提供，用来编译和运行测试<ul><li>只有cargo test才会编译代码，包括模块中的helper函数和 #[test]标注的函数</li></ul></li></ul><p>测试私有函数</p><ul><li>rust允许测试私有函数</li></ul><h3 id="12-11-集成测试"><a href="#12-11-集成测试" class="headerlink" title="12.11 集成测试"></a>12.11 集成测试</h3><p>在Rust里，集成测试完全位于被测试库的外部</p><p>目的：是测试被测试库的多个部分是否能正确在一起工作</p><p>集成测试的覆盖率很重要；</p><h2 id="13-rustlings"><a href="#13-rustlings" class="headerlink" title="13 rustlings"></a>13 rustlings</h2><p>Thanks for installing Rustlings!</p><p>Is this your first time? Don’t worry, Rustlings was made for beginners! We are<br>going to teach you a lot of things about Rust, but before we can get<br>started, here’s a couple of notes about how Rustlings operates:</p><ol><li>The central concept behind Rustlings is that you solve exercises. These<br>exercises usually have some sort of syntax error in them, which will cause<br>them to fail compliation or testing. Sometimes there’s a logic error instead<br>of a syntax error. No matter what error, it’s your job to find it and fix it!<br>You’ll know when you fixed it because then, the exercise will compile and<br>Rustlings will be able to move on to the next exercise.</li><li>If you run Rustlings in watch mode (which we recommend), it’ll automatically<br>start with the first exercise. Don’t get confused by an error message popping<br>up as soon as you run Rustlings! This is part of the exercise that you’re<br>supposed to solve, so open the exercise file in an editor and start your<br>detective work!</li><li>If you’re stuck on an exercise, there is a helpful hint you can view by typing<br>‘hint’ (in watch mode), or running <code>rustlings hint myexercise</code>.</li><li>If an exercise doesn’t make sense to you, feel free to open an issue on GitHub!<br>(<a href="https://github.com/rust-lang/rustlings/issues/new" target="_blank" rel="noopener">https://github.com/rust-lang/rustlings/issues/new</a>). We look at every issue,<br>and sometimes, other learners do too so you can help each other out!</li></ol><p>Got all that? Great! To get started, run <code>rustlings watch</code> in order to get the first<br>exercise. Make sure to have your editor open!</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go1</title>
      <link href="2021/03/09/go1/"/>
      <url>2021/03/09/go1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-编译型语言"><a href="#1-编译型语言" class="headerlink" title="1. 编译型语言"></a>1. 编译型语言</h2><p>Go 语言是一门编译语言</p><ul><li>在运行程序之前，GO首先使用编译器把代码编译成机器可以识别的1和0</li><li>它会把代码编译成一个可执行文件，在编译的过程中，编译器能捕获一些错误；</li></ul><p>解释型语言</p><ul><li>python，js等都是使用解释器，随着程序运行，一个语句一个语句进行翻译，但也这意味着bug可能就潜伏在你还没测试过的路径上。这些就是解释型语言；</li></ul><h2 id="2-install-go"><a href="#2-install-go" class="headerlink" title="2. install go"></a>2. install go</h2><p>go 代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/go <span class="comment"># go环境 编译器路径</span></span><br><span class="line">$&gt; <span class="built_in">cd</span> go/bin &amp;&amp; ls</span><br><span class="line">$&gt; go     <span class="comment"># go语言编译环境 # 需要将这个路径配置到环境变量中  /usr/local/go/bin/go</span></span><br><span class="line">$&gt; gofmt</span><br><span class="line">$&gt; vim ~/.bashrc</span><br><span class="line"><span class="comment">#编辑之后</span></span><br><span class="line">$&gt; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置go语言路径</span></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go <span class="comment"># 源码包所在路径</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/go  <span class="comment"># go开发者 go的项目默认路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go env <span class="comment"># 查看配置</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on <span class="comment"># 修改go env</span></span><br></pre></td></tr></table></figure><h2 id="3-const-var"><a href="#3-const-var" class="headerlink" title="3. const var"></a>3. const var</h2><p>常量与变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> distance, speed = <span class="number">56</span>, <span class="number">108</span></span><br><span class="line"><span class="keyword">const</span> hours, minutes = <span class="number">24</span>, <span class="number">60</span></span><br></pre></td></tr></table></figure><h3 id="3-1-短声明"><a href="#3-1-短声明" class="headerlink" title="3.1 短声明"></a>3.1 短声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种声明效果一样</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line">count:= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短声明可以在无法使用var的地方使用</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> count= <span class="number">10</span>; count&gt;<span class="number">0</span>; count-- &#123;</span><br><span class="line">  fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> count:=<span class="number">10</span>; count&gt;<span class="number">0</span>; count-- &#123;</span><br><span class="line">  fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num:=rand.Intn(<span class="number">3</span>);num==<span class="number">0</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> num:=rand.Intn(<span class="number">10</span>); num&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Printls(<span class="string">"1"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>,<span class="number">3</span>:</span><br><span class="line">  fmt.Printls(<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短声明不能用来声明 package作用域的变量</p><ul><li>era变量在main函数外声明的<ul><li>它拥有package作用域</li><li>如果main package有多个函数，那么era对它们都可见</li><li>package作用域的变量不能用短声明</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> era = <span class="string">"AD"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  year := <span class="number">2018</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下3个等价</span></span><br><span class="line">age = age + <span class="number">1</span></span><br><span class="line">age += <span class="number">1</span></span><br><span class="line">age++</span><br><span class="line">++age <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="4-1-逻辑运算符"><a href="#4-1-逻辑运算符" class="headerlink" title="4.1 逻辑运算符"></a>4.1 逻辑运算符</h3><p>|| 或</p><p> &amp;&amp; 与</p><p>！ 可以把true 变为 false，反之亦然</p><h2 id="5-包"><a href="#5-包" class="headerlink" title="5. 包"></a>5. 包</h2><p>引用多个包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> number = rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">fmt.Println(number)</span><br><span class="line"></span><br><span class="line">number = rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">fmt.Println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-包路径管理"><a href="#5-1-包路径管理" class="headerlink" title="5.1 包路径管理"></a>5.1 包路径管理</h3><p>把项目建在 GOPATH的src目录下；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"golangStudy/00module/lib1"</span> <span class="comment">// 路径需要写全 ，此路径针基于 gopath下的src 往下查找的</span></span><br><span class="line"><span class="string">"golangStudy/00module/lib2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lib1.Lib1Test1()</span><br><span class="line">lib2.Lib2Test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-匿名导包"><a href="#5-2-匿名导包" class="headerlink" title="5.2 匿名导包"></a>5.2 匿名导包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"_lib1"</span> <span class="comment">// 添加下划线，某个场景只需要执行该包 init方法的时候</span></span><br></pre></td></tr></table></figure><h3 id="5-3-取别名"><a href="#5-3-取别名" class="headerlink" title="5.3 取别名"></a>5.3 取别名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mylib2 <span class="string">"lib2"</span></span><br></pre></td></tr></table></figure><h3 id="5-4-Go-modules"><a href="#5-4-Go-modules" class="headerlink" title="5.4 Go modules"></a>5.4 Go modules</h3><p>Go modules 是go语言的依赖解决方案，发布于Go1.11， 成长于Go1.12，正式于Go1.14 推荐在生产上使用</p><p>Go modules解决Go1.11 前的几个常见争议问题</p><ol><li>GO语言长久以来的依赖管理问题</li><li>淘汰 现有的GOPATH的使用模式</li><li>统一社区中的其它的依赖管理工具（提供迁移功能）</li></ol><p><strong>GOPATH</strong>的工作模式</p><p>Go modules的目的之一就是淘汰GOPATH；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go env</span><br><span class="line">$&gt; GOPATH=Users/xxx/go</span><br><span class="line">$&gt; <span class="built_in">cd</span> <span class="variable">$GOPATH</span></span><br></pre></td></tr></table></figure><p><strong>GOPATH</strong>的弊端</p><ol><li>无版本控制概念， <code>go get -u  github.com/xxx/xxx</code> 无法指定版本</li><li>无法同步一致第三方版本号</li><li>无法指定当前项目引用的第三方版本号</li></ol><h4 id="5-4-1-Go-mod-命令"><a href="#5-4-1-Go-mod-命令" class="headerlink" title="5.4.1 Go mod 命令"></a>5.4.1 Go mod 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go mode init <span class="comment"># 生成 go.mod</span></span><br><span class="line">go mode download <span class="comment"># 下载go.mod 文件中指明的所有依赖</span></span><br><span class="line">go mode tidy <span class="comment"># 整理现有的依赖</span></span><br><span class="line">go mode graph <span class="comment"># 查看现有的依赖结构</span></span><br><span class="line">go mode edit <span class="comment"># 编辑 go.mod 文件</span></span><br><span class="line">go mode vendor <span class="comment"># 导出项目所有的依赖到vendor</span></span><br><span class="line">go mode verify <span class="comment"># 校验一个模块是否被篡改过</span></span><br><span class="line">go mode why <span class="comment"># 查看为什么需要依赖某模块</span></span><br></pre></td></tr></table></figure><h4 id="5-4-2-Go-mod环境变量"><a href="#5-4-2-Go-mod环境变量" class="headerlink" title="5.4.2 Go mod环境变量"></a>5.4.2 Go mod环境变量</h4><p>GO111MODULE</p><p>go提供 GO111MODULE 作为go modules的开关；其允许设置以下参数</p><ul><li>auto 只要项目包含了go.mod文件的话启用Go modules，</li><li>on 启用Go modules，推荐设置</li><li>off 禁用Go modules，不推荐设置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 GO111MODULE</span></span><br><span class="line">go env -w GO111MODULE=<span class="string">"on"</span></span><br></pre></td></tr></table></figure><p>GOPROXY</p><p>这个环境变量主要是用于设置Go模块代理（Go module proxy），其作用是用于使Go在后续拉取模块版本时直接通过镜像站点来快速拉取</p><p>代理</p><ul><li>阿里云 <code>https://mirrors.aliyun.com/goproxy</code></li><li>七牛云 <code>https://goproxy.io,direct</code></li></ul><p>GOSUMDB</p><p>它的值是一个Go checksum database， 用于在拉取模块版本时，保证拉去的模块版本数据未经过篡改，若发现不一致，将会立即中止；</p><p>GOPARVATE</p><p>私有仓库，设置了GOPARVATE的话，就不再需要去GOPROXY上去下载，也不需要从GOSUMDB上去校验了</p><p><code>go env -w GOPRIVATE=&quot;*.example.com&quot;</code></p><h4 id="5-4-3-go-mod-初始化项"><a href="#5-4-3-go-mod-初始化项" class="headerlink" title="5.4.3 go mod  初始化项"></a>5.4.3 go mod  初始化项</h4><p>任意文件夹创建一个项目（不要求在 $GOPATH/src）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mkdir modules_test</span><br><span class="line">$&gt; <span class="built_in">cd</span> modules_test &amp;&amp; go mod init github.com/orgs/TenonMortise/modules_test</span><br><span class="line">$&gt; go get github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_github.com/<span class="keyword">go</span>-sql-driver/mysql</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go mod模式中 包都下载到了  $GOPATH/pkg  中</p><p><strong>在该项目编写源代码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动下载</span></span><br><span class="line">go get github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure><p><strong>go.sum</strong></p><p>作用： 罗列当前项目直接或间接的依赖所有模块版本，保证今后项目以来的版本不会被覆盖</p><p>h1:hash 表示整体项目的zip文件打开之后的全部文件的校验和生成的hash， 如果不存在，可能表示依赖的库可能用不上；</p><p>xxx/go.mod  h1:hash.  Go.mod文件做的hash</p><h4 id="5-4-4-修改项目模块的版本依赖关系"><a href="#5-4-4-修改项目模块的版本依赖关系" class="headerlink" title="5.4.4 修改项目模块的版本依赖关系"></a>5.4.4 修改项目模块的版本依赖关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; go mod edit -replace=zinx@v0.0.0-xxx=zin@v1.0.0-xxx</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go.mod 会多一行replace语句</span></span><br><span class="line">replace zin -replace=zinx@v0.0.0-xxx=&gt;zin@v1.0.0-xxx</span><br></pre></td></tr></table></figure><h2 id="6-循环-分支"><a href="#6-循环-分支" class="headerlink" title="6 循环 分支"></a>6 循环 分支</h2><h3 id="6-1-Boolean类型"><a href="#6-1-Boolean类型" class="headerlink" title="6.1 Boolean类型"></a>6.1 Boolean类型</h3><p>true 和false</p><p>go中，” “ 空串不会自动转为false </p><h3 id="6-2-strings-Contains"><a href="#6-2-strings-Contains" class="headerlink" title="6.2 strings.Contains"></a>6.2 strings.Contains</h3><p>来自strings包的Contains函数可以判断某个字符串是否包含另外要给字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"you find yourself in a dimlu lit cavern"</span>)</span><br><span class="line"><span class="keyword">var</span> command = <span class="string">"walk outside"</span></span><br><span class="line"><span class="keyword">var</span> exit = strings.Contains(command, <span class="string">"outside"</span>)</span><br><span class="line">fmt.Println(<span class="string">"you leave the cave: "</span>, exit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-compare"><a href="#6-3-compare" class="headerlink" title="6.3 compare"></a>6.3 compare</h3><p>如果比较两个值，得到的结果也是 true 或false</p><p>比较运算符：</p><p><code>== &lt;= &lt; != &gt;= &gt;</code></p><h3 id="6-4-if"><a href="#6-4-if" class="headerlink" title="6.4 if"></a>6.4 if</h3><p>判断条件不加括号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> command == <span class="string">"alex"</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> command == <span class="string">"let"</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-swtch"><a href="#6-6-swtch" class="headerlink" title="6.6 swtch"></a>6.6 swtch</h3><p>条件不加括号，不需要break关键字</p><p>还有一个fallthrough关键字，它用来执行下一个case的body部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">"alex"</span></span><br><span class="line"><span class="keyword">switch</span> command &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"gi"</span>:</span><br><span class="line">  ..</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"go"</span>,<span class="string">"run"</span>:</span><br><span class="line">  ..</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> room = <span class="string">"cave"</span></span><br><span class="line"><span class="keyword">switch</span> room &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"cave"</span>:</span><br><span class="line">    fmt.Printls(<span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"go"</span>,<span class="string">"run"</span>:</span><br><span class="line">  fmt.Printls(<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 1，2</span></span><br></pre></td></tr></table></figure><h3 id="6-7-循环"><a href="#6-7-循环" class="headerlink" title="6.7 循环"></a>6.7 循环</h3><p>for关键字让代码重复执行</p><p>for后边没有根条件，那就是无限循环</p><ul><li>可以使用break跳出循环</li></ul><p><strong>遍历数组</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">numbers := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">fmt.Println(i, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-8-变量的作用域"><a href="#6-8-变量的作用域" class="headerlink" title="6.8 变量的作用域"></a>6.8 变量的作用域</h3><p>当变量被声明以后，它就进入了作用域</p><ul><li>只要变量在作用域内，你就可以访问它</li><li>否则，访问它会报错的</li></ul><p>变量声明的位置，决定了它的作用域</p><p>作用域的好处？</p><ul><li>可以在不通的作用域内使用相同的变量名</li></ul><p>在Go里面， 作用域的范围就是{}之间的部分</p><h2 id="7-数据类型"><a href="#7-数据类型" class="headerlink" title="7. 数据类型"></a>7. 数据类型</h2><h3 id="7-1-声明浮点型变量"><a href="#7-1-声明浮点型变量" class="headerlink" title="7.1 声明浮点型变量"></a>7.1 声明浮点型变量</h3><p>下面这三个语句的效果是一样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">days := <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">var</span> days = <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">var</span> days <span class="keyword">float64</span> = <span class="number">365.2425</span></span><br></pre></td></tr></table></figure><p>只要数字含有小数部分，那么它的类型就是float64</p><p>如果你使用一个整数来初始化某个变量，那么你必须指定它的类型为float64，否则它就是一个整数类型</p><h3 id="7-2-单精度浮点数类型"><a href="#7-2-单精度浮点数类型" class="headerlink" title="7.2 单精度浮点数类型"></a>7.2 单精度浮点数类型</h3><p>Go语言有两种浮点数类型</p><p>默认是float64</p><ul><li>64位的浮点类型</li><li>占用8字节内存</li><li>某些编程语言把这种类型叫做double（双精度）</li></ul><p>float32</p><ul><li>占用4字节内存</li><li>精度比float64低</li><li>有时叫做单精度类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi64 = math.Pi</span><br><span class="line"><span class="keyword">var</span> pi32 <span class="keyword">float32</span> = math.Pi</span><br><span class="line"></span><br><span class="line">fmt.Println(pi64)</span><br><span class="line">fmt.Println(pi32)</span><br></pre></td></tr></table></figure><h3 id="7-3-单双精度的使用场景"><a href="#7-3-单双精度的使用场景" class="headerlink" title="7.3 单双精度的使用场景"></a>7.3 单双精度的使用场景</h3><ul><li>当处理大量数据时，例如3D游戏中的数千个顶点，使用float32牺牲精度来节省内存是很有意义的；</li><li>math包里面的函数操作的都是float64类型，所以应该首选使用float64，除非你有足够的理由不去使用它；</li></ul><h3 id="7-4-零值"><a href="#7-4-零值" class="headerlink" title="7.4 零值"></a>7.4 零值</h3><p>Go里面每个类型都有一个默认值，称作零值</p><p>当你声明却不对它进行初始化的时候，它的值就是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price <span class="keyword">float64</span></span><br><span class="line">fmt.Println(price)</span><br><span class="line"></span><br><span class="line">price := <span class="number">0.0</span></span><br></pre></td></tr></table></figure><h3 id="7-5-显示浮点类型"><a href="#7-5-显示浮点类型" class="headerlink" title="7.5 显示浮点类型"></a>7.5 显示浮点类型</h3><ul><li>使用Print或Println打印浮点类型的时候，默认的行为是尽可能的多显示几位小数</li><li>结合%f格式显示小数的位置</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">third := <span class="number">1.0</span>/<span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%f\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%.3f\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%4.2f\n"</span>, third)</span><br></pre></td></tr></table></figure><p>%4.2f</p><p>%4 标识宽度</p><p>2f 表示precision</p><ul><li>宽度： 会显示出的最少字符个数（包括小数点和小数）<ul><li>如果宽度大于数字的个数，那么左边会填充空格</li><li>如果没指定宽度，那么就按实际的位数进行显示</li></ul></li><li>精度： 小数点后边显示的位数</li></ul><h3 id="7-6-整数类型"><a href="#7-6-整数类型" class="headerlink" title="7.6 整数类型"></a>7.6 整数类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> year <span class="keyword">int</span> = <span class="number">2018</span>  <span class="comment">// 常用整型</span></span><br><span class="line"><span class="keyword">var</span> month <span class="keyword">uint</span> = <span class="number">2</span> <span class="comment">// 无符号整数类型</span></span><br></pre></td></tr></table></figure><h4 id="7-6-1-int-和-uint"><a href="#7-6-1-int-和-uint" class="headerlink" title="7.6.1 int 和 uint"></a>7.6.1 int 和 uint</h4><p>int和uint是针对目标设备优化的类型</p><ul><li>在old 的移动设备上，int 和 uint都是32位的</li><li>比较新的计算机上，int 和 uint都是64位的</li><li>虽然在某些设备上int可以看作int32，在某些设备上可以看作是int64，但他们其实是3种不同的类型</li><li>int并不是其它类型的别名</li></ul><p>tip</p><p>如果你在较老的32位设备上，使用了超过20亿的整数，而且代码还能运行，那么最好使用int64 和 uint64 来代替 int和uint</p><h4 id="7-6-2-uint8"><a href="#7-6-2-uint8" class="headerlink" title="7.6.2 uint8"></a>7.6.2 uint8</h4><p>uint8 可以表示8位的颜色（红绿蓝： 0-255）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue <span class="keyword">uint8</span> = <span class="number">0</span>,<span class="number">141</span>,<span class="number">213</span></span><br></pre></td></tr></table></figure><p>为什么不使用int</p><ul><li>uint8取值范围正好合适，而int则多出来几十亿不合理的数字</li><li>如果很多颜色数据连续存储，例如未被压缩的图片，那么使用uint8可以节省很多内存</li></ul><h3 id="7-7-输出数据类型"><a href="#7-7-输出数据类型" class="headerlink" title="7.7 输出数据类型"></a>7.7 输出数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:= <span class="number">1.0</span></span><br><span class="line">fmt.Println(<span class="string">"%T"</span>, a)</span><br></pre></td></tr></table></figure><h3 id="7-8-文本"><a href="#7-8-文本" class="headerlink" title="7.8 文本"></a>7.8 文本</h3><h3 id="7-8-1-声明字符串"><a href="#7-8-1-声明字符串" class="headerlink" title="7.8.1 声明字符串"></a>7.8.1 声明字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peace := <span class="string">"peace"</span></span><br><span class="line"><span class="keyword">var</span> peace = <span class="string">"peace"</span></span><br><span class="line"><span class="keyword">var</span> peace <span class="keyword">string</span> = <span class="string">"peace"</span></span><br></pre></td></tr></table></figure><p>字符串的零值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blank <span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="7-9-类型转换"><a href="#7-9-类型转换" class="headerlink" title="7.9 类型转换"></a>7.9 类型转换</h3><p>连接两个字符串，使用+运算符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout:= <span class="string">"alex"</span> + <span class="string">"leo"</span> <span class="comment">// compiler success</span></span><br></pre></td></tr></table></figure><p>如果想连接字符串和数值，是会报错的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout:= <span class="string">"alex"</span> + <span class="number">10</span> + <span class="string">"leo"</span> <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure><p>整数和浮点数也不能直接连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想把age转化成浮点类型，需要使用目标类型将其“包裹”起来</span></span><br><span class="line">age := <span class="number">41</span></span><br><span class="line">marsAge := float(age)</span><br></pre></td></tr></table></figure><p>从浮点类型转为整数类型</p><ul><li>可以从浮点类型转化为整数类型，小数点后面的部分会被截断，而不是舍入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">earthDays := <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">int</span>(earthDays)</span><br></pre></td></tr></table></figure><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><h3 id="8-1-函数声明"><a href="#8-1-函数声明" class="headerlink" title="8.1 函数声明"></a>8.1 函数声明</h3><p>在go里，大写字母开头的函数、变量或其它标识符都会被导出，对其它包可用；</p><p>小写字母开头的就不行；</p><h3 id="8-2-方法"><a href="#8-2-方法" class="headerlink" title="8.2 方法"></a>8.2 方法</h3><p>也是一个函数，但是它根某一个类型相关联的；</p><p><strong>声明新类型</strong></p><p>关键字type可以用来声明新类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> temperature celsius = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>虽然celsius 是一种全新的类型，但是由于它和float64具有相同的行为和表示，所以赋值操作能顺利执行；</p><p>例如加法等运算，也可以像float64那样使用；</p><h4 id="8-2-1-通过方法添加行为"><a href="#8-2-1-通过方法添加行为" class="headerlink" title="8.2.1 通过方法添加行为"></a>8.2.1 通过方法添加行为</h4><p>在C#、java里，方法属于类</p><p>在Go里，它提供了方法，但是没提供类和对象</p><p>go比其它语言的方法要灵活</p><p>可以将方法与同包中声明的任何类型相关联、但不可以是int、float64等预声明的类型进行关联；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 两种类型不能混用，哪怕底层指向的是同一类型</span></span><br><span class="line">  <span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line">  <span class="keyword">var</span> w <span class="keyword">float64</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> k kelvin = <span class="number">20</span></span><br><span class="line">  k+=w <span class="comment">// compiler error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">float64</span></span><br><span class="line">y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p为接收者， 类似this 的作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">distance</span><span class="params">(q Point)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q.y &gt; p.y &amp;&amp; q.X &gt; p.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> point = Point&#123;<span class="number">3.12</span>, <span class="number">3.14</span>&#125;</span><br><span class="line"><span class="keyword">var</span> point1 = Point&#123;<span class="number">4.10</span>, <span class="number">3.12</span>&#125;</span><br><span class="line">fmt.Println(point.y)</span><br><span class="line">fmt.Println(point.distance(point1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个方法可以有多个参数，但只能有一个接收者</p><p>在方法体中，接收者的行为和其它参数一样；</p><h4 id="8-2-2-方法调用"><a href="#8-2-2-方法调用" class="headerlink" title="8.2.2 方法调用"></a>8.2.2 方法调用</h4><p>变量.方法()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">float64</span></span><br><span class="line">y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p为接收者， 类似this 的作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">distance</span><span class="params">(q Point)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q.y &gt; p.y &amp;&amp; q.X &gt; p.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> point = Point&#123;<span class="number">3.12</span>, <span class="number">3.14</span>&#125;</span><br><span class="line"><span class="keyword">var</span> point1 = Point&#123;<span class="number">4.10</span>, <span class="number">3.12</span>&#125;</span><br><span class="line">fmt.Println(point.distance(point1)) <span class="comment">// 变量.方法()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-一等函数"><a href="#8-3-一等函数" class="headerlink" title="8.3 一等函数"></a>8.3 一等函数</h3><p>在go里，函数是头等的，它可以用在整数、字符串或其它类型能用的地方；</p><ul><li>将函数赋给变量</li><li>将函数作为函数的返回类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  sensor:= fakeSensor</span><br><span class="line">  sensor()</span><br><span class="line">  sensor:= realSensor</span><br><span class="line">  sensor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将函数作为参数传递给函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, sensor <span class="keyword">func</span>()</span> <span class="title">kelvin</span>)</span>  &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  measureTemperature(<span class="number">3</span>, fakeSensor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明函数类型</strong></p><p>为函数声明类型有助于精简和明确调用者的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sensor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">kelvin</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, s <span class="keyword">func</span>()</span> <span class="title">kelvin</span>)</span></span><br><span class="line"><span class="comment">// 可以优化为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, s sensor )</span></span></span><br></pre></td></tr></table></figure><p><strong>闭包和匿名函数</strong></p><p>匿名函数就是没有名字的函数，在Go里也称作函数字面值；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"&gt;&gt;."</span>)</span><br><span class="line">&#125;</span><br><span class="line">  f() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"&gt;&gt;."</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> k <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> sensor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realSensor</span><span class="params">()</span> <span class="title">k</span></span> &#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calibrate</span><span class="params">(s sensor, offset k)</span> <span class="title">sensor</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s() + offset</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  sensor := calibrate(realSensor, <span class="number">5</span>)</span><br><span class="line">  sensor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包就是由于怒名函数封闭并包围作用域中的变量而得名的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> k <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">type</span> sersor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span></span><br><span class="line"><span class="keyword">var</span> f k = <span class="number">3</span></span><br><span class="line">ser := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(ser()) <span class="comment">// 3</span></span><br><span class="line">f++</span><br><span class="line">fmt.Println(ser()) <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-多返回值"><a href="#8-4-多返回值" class="headerlink" title="8.4 多返回值"></a>8.4 多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">666</span>, <span class="number">777</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo3</span><span class="params">()</span><span class="params">(r1 <span class="keyword">int</span> ,r2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 有名称的返回值</span></span><br><span class="line">  r1= <span class="number">666</span></span><br><span class="line">  r2 =<span class="number">777</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo4</span><span class="params">()</span><span class="params">(r1 ,r2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 有名称的返回值</span></span><br><span class="line">  r1= <span class="number">666</span></span><br><span class="line">  r2 =<span class="number">777</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ret1, ret2 := foo2()</span><br><span class="line">  r1, r2 := foo3() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9 数组"></a>9 数组</h2><h3 id="9-1-数组的复制"><a href="#9-1-数组的复制" class="headerlink" title="9.1 数组的复制"></a>9.1 数组的复制</h3><p>无论数组赋值给新的变量还是将它传递给函数，都会产生一个完整的数组副本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">plants := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">clones := plants</span><br><span class="line">plants[<span class="number">0</span>] = <span class="string">"alex"</span></span><br><span class="line">fmt.Println(plants)</span><br><span class="line">fmt.Println(clones)</span><br><span class="line"><span class="comment">// [alex b c]</span></span><br><span class="line"><span class="comment">// [a b c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组也是一种值，函数通过值传递来接收参数，所以数组作为函数的参数就非常低效</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func clonefunc(p [<span class="number">3</span>]string) [<span class="number">3</span>]string &#123;</span><br><span class="line"><span class="keyword">for</span> i := range p &#123;</span><br><span class="line">p[i] = <span class="string">"pruffix"</span> + p[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">plants := [...]string&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(clonefunc(plants))</span><br><span class="line">fmt.Println(plants)</span><br><span class="line"><span class="comment">// [pruffixa pruffixb pruffixc]</span></span><br><span class="line"><span class="comment">// [a b c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的长度也是数组类型的一部分</p><ul><li>尝试将长度不符的数组作为参数传递，将会报错</li><li>函数一般使用slice而不是数组作为参数</li></ul><h2 id="10-slice"><a href="#10-slice" class="headerlink" title="10 slice"></a>10 slice</h2><p>指向数组的窗口</p><p>假如p 是一个数组，那么 p[0:4] 就是一个切片，它切分出数组里面前4个元素</p><p>切分数组不会导致数组被修改，它只是创建了指向数组的一个窗口或视图，这种视图就是slice类型；</p><p>默认索引</p><p>[:10]</p><p>[1:]</p><p>[:]</p><p>切分数组的语法也可以用于切分字符串</p><ul><li>切分字符串时，索引代表的是字节数而非 字符串的数；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">que := <span class="string">"汉字^&amp;COMasf"</span></span><br><span class="line">fmt.Println(que[:<span class="number">3</span>]) <span class="comment">// 汉</span></span><br></pre></td></tr></table></figure><h3 id="10-1-slice的字面值"><a href="#10-1-slice的字面值" class="headerlink" title="10.1 slice的字面值"></a>10.1 slice的字面值</h3><p>Go里面很多函数都倾向于使用slice而不是数组作为参数</p><p>想要获得与底层数组相同元素的slice，那么可以使用[:]进行切分</p><h3 id="10-2-声明slice"><a href="#10-2-声明slice" class="headerlink" title="10.2 声明slice"></a>10.2 声明slice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明slice</span></span><br><span class="line">d := []<span class="keyword">string</span> &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line"><span class="comment">// 声明array</span></span><br><span class="line">f := [...]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"c"</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hyper</span><span class="params">(worlds []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> worlds &#123;</span><br><span class="line">worlds[i] = strings.TrimSpace(worlds[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;<span class="string">"a   "</span>, <span class="string">"   b"</span>, <span class="string">" c "</span>&#125;</span><br><span class="line">hyper(planets)</span><br><span class="line">fmt.Println(planets) <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-带有方法的切片"><a href="#10-3-带有方法的切片" class="headerlink" title="10.3 带有方法的切片"></a>10.3 带有方法的切片</h3><p>在go里，可以将slice或数组作为底层类型，然后绑定其它方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>,</span><br><span class="line">&#125;</span><br><span class="line">sort.StringSlice(planets).Sort()</span><br><span class="line">fmt.Println(planets) <span class="comment">// [Ear Mer Ven]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-append函数"><a href="#10-4-append函数" class="headerlink" title="10.4 append函数"></a>10.4 append函数</h3><p>append函数也是内置函数，它可以将元素添加到slice里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>,</span><br><span class="line">&#125;</span><br><span class="line">sort.StringSlice(planets).Sort()</span><br><span class="line">planets = <span class="built_in">append</span>(planets, <span class="string">"Xyy"</span>)</span><br><span class="line">fmt.Println(planets) <span class="comment">// [Ear Mer Ven Xyy]</span></span><br></pre></td></tr></table></figure><p>思考一个问题</p><p>当直接声明<code>planets := []string{&quot;Mer&quot;, &quot;Ven&quot;, &quot;Ear&quot;,}</code>的时候，会创建一个数组。该数组有3个元素。后面append又给 planets添加了1个元素。因为声明的数组是定长，那么append的这个元素被添加到哪里了呢？</p><h3 id="10-5-长度和容量"><a href="#10-5-长度和容量" class="headerlink" title="10.5 长度和容量"></a>10.5 长度和容量</h3><blockquote><p>长度就是切片里有多少个元素，</p><p>容量就是指切片对应的底层数组，底层数组的容量是多少，那么切片的容量就是多少</p></blockquote><p>slice中元素的个数决定slice的长度</p><p>如果slice底层数组比slice还大，那么就说该slice还有容量可供增长</p><ul><li>获取切片的长度 len(slice)</li><li>获取切片的容量 cap(slice)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dump</span><span class="params">(label <span class="keyword">string</span>, slice []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v: length %v, cap %v \n"</span>, label, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">&#125;</span><br><span class="line">dump(<span class="string">"planets"</span>, planets)</span><br><span class="line">dump(<span class="string">"planets[1:2]"</span>, planets[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// planets: length 5, cap 5 </span></span><br><span class="line"><span class="comment">// planets[1:2]: length 1, cap 4</span></span><br></pre></td></tr></table></figure><p>当往一个切片append元素的时候，要看一下底层数组的长度够不够，如果不够的话，新声明一个长度为当前数组长度两倍长度的数组，然后将老数组的值依次复制到新数组里面，再追加append的元素。<br>如果够的话，直接追加不创建新数组；</p><p>planets[1:2] cap为何是 4 ？</p><h3 id="10-6-三个索引的切分操作"><a href="#10-6-三个索引的切分操作" class="headerlink" title="10.6 三个索引的切分操作"></a>10.6 三个索引的切分操作</h3><p>Go1.2 引入了能够限制新建切片容量的三索引切分操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">&#125;</span><br><span class="line">  ter := planets[<span class="number">0</span>:<span class="number">4</span>:<span class="number">4</span>] <span class="comment">// 第三个指定切片容量为4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-7-使用make函数对slice进行预分配"><a href="#10-7-使用make函数对slice进行预分配" class="headerlink" title="10.7 使用make函数对slice进行预分配"></a>10.7 使用make函数对slice进行预分配</h3><p>当slice的容量不足以执行append操作时，Go必须创建新数组并复制旧数组中的内容</p><p>但通过内置的make函数，可以对slice进行预分配策略</p><ul><li>尽量避免额外的内存分配和数组复制操作</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dump</span><span class="params">(label <span class="keyword">string</span>, slice []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v: length %v, cap %v \n"</span>, label, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">10</span>) <span class="comment">// 设置 长度 容量</span></span><br><span class="line">dump(<span class="string">"aa"</span>, planets) <span class="comment">// aa: length 0, cap 10</span></span><br><span class="line">planets = <span class="built_in">append</span>(planets,</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">)</span><br><span class="line">dump(<span class="string">"bb"</span>, planets) <span class="comment">// bb: length 5, cap 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-8-声明可变参数的函数"><a href="#10-8-声明可变参数的函数" class="headerlink" title="10.8 声明可变参数的函数"></a>10.8 声明可变参数的函数</h3><p>声明Printf append 这样的可变参数函数，需要在函数的最后一个参数前面加上 … 符号；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...string 行参</span></span><br><span class="line"><span class="comment">// planets... 实参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">terraform</span><span class="params">(prefix <span class="keyword">string</span>, worlds ...<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">newWorlds := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(worlds))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> worlds &#123;</span><br><span class="line">newWorlds[i] = prefix + <span class="string">" "</span> + worlds[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newWorlds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">twoWorlds := terraform(<span class="string">"New"</span>, <span class="string">"Venus"</span>, <span class="string">"Mars"</span>)</span><br><span class="line">fmt.Println(twoWorlds)</span><br><span class="line"><span class="comment">// [New Venus New Mars]</span></span><br><span class="line"></span><br><span class="line">planets := []<span class="keyword">string</span>&#123;<span class="string">"Venus"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>&#125;</span><br><span class="line">newPlanets := terraform(<span class="string">"New"</span>, planets...)</span><br><span class="line">fmt.Println(newPlanets)</span><br><span class="line"><span class="comment">// [New Venus New Mars New Jupiter]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-map"><a href="#11-map" class="headerlink" title="11. map"></a>11. map</h2><h3 id="11-1-声明"><a href="#11-1-声明" class="headerlink" title="11.1 声明"></a>11.1 声明</h3><p><code>map[string]int</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temperature := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">  <span class="string">"E"</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="string">"M"</span>: <span class="number">-65</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-map不会被复制"><a href="#11-2-map不会被复制" class="headerlink" title="11.2 map不会被复制"></a>11.2 map不会被复制</h3><p>数组，int 等类型在赋值给新变量或传递至函数/方法的时候会创建相应的副本</p><p>map不会, </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"E"</span>:    <span class="string">"Sector zz9"</span>,</span><br><span class="line"><span class="string">"Mars"</span>: <span class="string">"Sector zz9"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">planetsMark := planets</span><br><span class="line">planets[<span class="string">"Earth"</span>] = <span class="string">"whoops"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(planets)     <span class="comment">// map[E:Sector zz9 Earth:whoops Mars:Sector zz9]</span></span><br><span class="line">fmt.Println(planetsMark) <span class="comment">// map[E:Sector zz9 Earth:whoops Mars:Sector zz9]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(planets, <span class="string">"Earth"</span>)</span><br><span class="line">fmt.Println(planetsMark) <span class="comment">// map[E:Sector zz9 Mars:Sector zz9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-使用make对map进行预分配"><a href="#11-3-使用make对map进行预分配" class="headerlink" title="11.3 使用make对map进行预分配"></a>11.3 使用make对map进行预分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temperature := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>创建map时，make函数可以接受一个或者两个参数</p><ul><li>第二个参数用于为指定数量的key预先分配空间</li><li>使用make函数创建的map初始长度为0</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">temperatures := []<span class="keyword">float64</span>&#123;</span><br><span class="line"><span class="number">-28.0</span>, <span class="number">32.0</span>, <span class="number">-31.0</span>, <span class="number">-29.0</span>, <span class="number">-23.0</span>, <span class="number">-29.0</span>, <span class="number">-28.0</span>, <span class="number">-33.0</span>,</span><br><span class="line">&#125;</span><br><span class="line">frequency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>) <span class="comment">// key 为float64 value为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, t := <span class="keyword">range</span> temperatures &#123;</span><br><span class="line">frequency[t]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t, num := <span class="keyword">range</span> frequency &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%+.2f occurs %d times\n"</span>, t, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-struct"><a href="#12-struct" class="headerlink" title="12. struct"></a>12. struct</h2><p>struct允许将不同的类型的东西组合在一起</p><h3 id="12-1-声明"><a href="#12-1-声明" class="headerlink" title="12.1 声明"></a>12.1 声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">  lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-将struct编码为JSON"><a href="#12-2-将struct编码为JSON" class="headerlink" title="12.2 将struct编码为JSON"></a>12.2 将struct编码为JSON</h3><p>json包的Marshal函数可以将struct中的数据转化为JSON格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curiosity := location&#123;<span class="number">-4.12</span>, <span class="number">123.23</span>&#125;</span><br><span class="line">bytes, err := json.Marshal(curiosity)</span><br><span class="line">exitOnError(err)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes)) <span class="comment">// &#123;"Lat":-4.12,"Long":123.23&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitOnError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-使用struct标签来自定义JSON"><a href="#12-3-使用struct标签来自定义JSON" class="headerlink" title="12.3 使用struct标签来自定义JSON"></a>12.3 使用struct标签来自定义JSON</h3><p>go语言中的json包要求struct中的字段必须以大写字母开头，类似驼峰命名；</p><p>但有时候需要snake_case蛇形命名规范，那么该怎么办？</p><p>可以为字段标注标签，使得json包在进行编码的时候能够按照标签里的样式修改字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat  <span class="keyword">float64</span> <span class="string">`json:"latitude"xml:"latitude"`</span></span><br><span class="line">Long <span class="keyword">float64</span> <span class="string">`json:"longitude"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curiosity := location&#123;<span class="number">-4.12</span>, <span class="number">123.23</span>&#125;</span><br><span class="line">bytes, err := json.Marshal(curiosity)</span><br><span class="line">exitOnError(err)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes)) <span class="comment">// &#123;"latitude":-4.12,"longitude":123.23&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitOnError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-1-结构体标签在json中的应用"><a href="#12-3-1-结构体标签在json中的应用" class="headerlink" title="12.3.1 结构体标签在json中的应用"></a>12.3.1 结构体标签在json中的应用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title  <span class="keyword">string</span>   <span class="string">`json:"title"`</span> <span class="comment">// 当前的字段在json中显示的名称是什么</span></span><br><span class="line">Year   <span class="keyword">int</span>      <span class="string">`json:"year"`</span></span><br><span class="line">Actors []<span class="keyword">string</span> <span class="string">`json:"actors"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">movie := Movie&#123;<span class="string">"alex"</span>, <span class="number">2000</span>, []<span class="keyword">string</span>&#123;<span class="string">"xing"</span>&#125;&#125;</span><br><span class="line"><span class="comment">// struct -&gt; json</span></span><br><span class="line">jsonStr, err := json.Marshal(movie)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"jsonStr = %s\n"</span>, jsonStr)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// json -&gt; struct</span></span><br><span class="line">movie2 := Movie&#123;&#125;</span><br><span class="line">err = json.Unmarshal(jsonStr, &amp;movie2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jsonStr = &#123;"title":"alex","year":2000,"actors":["xing"]&#125;</span></span><br><span class="line"><span class="comment">// struct=&#123;alex 2000 [xing]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="12-4-将方法关联到struct"><a href="#12-4-将方法关联到struct" class="headerlink" title="12.4 将方法关联到struct"></a>12.4 将方法关联到struct</h3><p>方法可以关联到声明的类型上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">  d,m,s <span class="keyword">float64</span></span><br><span class="line">  h <span class="keyword">rune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c coordinate)</span> <span class="title">decimal</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-4-1-构造函数"><a href="#12-4-1-构造函数" class="headerlink" title="12.4.1 构造函数"></a>12.4.1 构造函数</h4><p>可以使用struct复合字面值来初始化你所要的数据</p><p>但如struct初始化的时候还要做很多事情，那就可以考虑写一个构造用的函数</p><p>Go语言没有专用的构造函数，但以new或者New开头的函数，通常是用来构造数据的，例如 newPerson NewPerson</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">  d,m,s <span class="keyword">float64</span></span><br><span class="line">  h <span class="keyword">rune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c coordinate)</span> <span class="title">decimal</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  sign := <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">switch</span> c.h &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>, <span class="string">'W'</span>,<span class="string">'s'</span>,<span class="string">'w'</span>:</span><br><span class="line">    sign = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sign * (c.d + c.m/<span class="number">60</span> + c.s/<span class="number">3600</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造用的函数,在go中没有专业的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLocation</span><span class="params">(lat, long coordinate)</span> <span class="title">location</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> location&#123;lat.decimal(), long.decimal()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">  lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  lat := coordinate&#123;...&#125;</span><br><span class="line">  long := coordinate&#123;...&#125;</span><br><span class="line">  curiosity := newLocation(lat, long)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-4-2-New函数"><a href="#12-4-2-New函数" class="headerlink" title="12.4.2 New函数"></a>12.4.2 New函数</h4><p>有一些用于构造的函数的名称就是New （例如errors包里面的New函数）</p><p>这是因为函数调用时使用 包名.函数名 的形式</p><p>如果该函数叫NewError，那么调用的时候就是errors.NewError()， 这就不如errors.New() 简洁</p><h3 id="12-5-class的替代方案"><a href="#12-5-class的替代方案" class="headerlink" title="12.5 class的替代方案"></a>12.5 class的替代方案</h3><p>Go语言没有class，但使用struct并配备几个方法也可以达到同样的效果</p><h3 id="12-6-反射"><a href="#12-6-反射" class="headerlink" title="12.6 反射"></a>12.6 反射</h3><p>对一个已经的变量作为输入，得出该变量的type 和 value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Valueof</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="comment">// valueof 用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Typeof</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// Typeof 用来动态获取输入参数接口的值的类型，如果接口为空则返回nil</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectName</span><span class="params">(num <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(reflect.TypeOf(num))</span><br><span class="line">fmt.Println(reflect.ValueOf(num))</span><br><span class="line">  <span class="comment">// float64</span></span><br><span class="line"><span class="comment">// 1.23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="keyword">int</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this User)</span> <span class="title">Call</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoFileAndMethod</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">inputType := reflect.TypeOf(input)</span><br><span class="line">fmt.Println(<span class="string">"inputType is:"</span>, inputType.Name())</span><br><span class="line"></span><br><span class="line">inputValue := reflect.ValueOf(input)</span><br><span class="line">fmt.Println(<span class="string">"inputValue is:"</span>, inputValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过type 获取里面的字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputType.NumField(); i++ &#123;</span><br><span class="line">field := inputType.Field(i)</span><br><span class="line">value := inputValue.Field(i)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s: %v = %v\n"</span>, field.Name, field.Type, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过type获取里面的方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputType.NumMethod(); i++ &#123;</span><br><span class="line">m := inputType.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">"%s: %v\n"</span>, m.Name, m.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;<span class="number">1</span>, <span class="string">"alex"</span>, <span class="number">18</span>&#125;</span><br><span class="line">DoFileAndMethod(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inputType is: User</span></span><br><span class="line"><span class="comment">// inputValue is: &#123;1 alex 18&#125;</span></span><br><span class="line"><span class="comment">// id: int = 1</span></span><br><span class="line"><span class="comment">// name: string = alex</span></span><br><span class="line"><span class="comment">// age: int = 18</span></span><br><span class="line"><span class="comment">// Call: func(main.User) int</span></span><br></pre></td></tr></table></figure><p><strong>反射结构体标签</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> resume <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`info:"name" doc:"名字"`</span></span><br><span class="line">Sex  <span class="keyword">string</span> <span class="string">`info:"sex"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTag</span><span class="params">(str <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(str).Elem()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">tagstring := t.Field(i).Tag.Get(<span class="string">"info"</span>)</span><br><span class="line">tagdoc := t.Field(i).Tag.Get(<span class="string">"doc"</span>)</span><br><span class="line">fmt.Println(<span class="string">"info:"</span>, tagstring, <span class="string">"doc:"</span>, tagdoc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> re resume</span><br><span class="line">findTag(&amp;re)</span><br><span class="line"><span class="comment">// info: name doc: 名字</span></span><br><span class="line"><span class="comment">// info: sex doc:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-组合和转发"><a href="#13-组合和转发" class="headerlink" title="13. 组合和转发"></a>13. 组合和转发</h2><h3 id="13-1-组合"><a href="#13-1-组合" class="headerlink" title="13.1 组合"></a>13.1 组合</h3><p>在面向对象的世界中，对象由更小的对象组合而成</p><p>术语： 对象组合或组合</p><p>Go通过结构体视线组合（composition）</p><p>Go提供了“嵌入”（embedding） 特性，他可以实现方法的转发（forwarding）</p><p>组合是一种更简单，灵活的方式</p><p><strong>拆分类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> report <span class="keyword">struct</span> &#123;</span><br><span class="line">sol       <span class="keyword">int</span></span><br><span class="line">high, low <span class="keyword">float64</span></span><br><span class="line">lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol         <span class="keyword">int</span></span><br><span class="line">temperature temperature</span><br><span class="line">location    location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br></pre></td></tr></table></figure><p><strong>duck type</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol         <span class="keyword">int</span></span><br><span class="line">temperature temperature</span><br><span class="line">location    location</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t temperature)</span> <span class="title">averae</span><span class="params">()</span> <span class="title">celsius</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (t.high + t.low) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reportNew)</span> <span class="title">averae</span><span class="params">()</span> <span class="title">celsius</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.temperature.averae()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := temperature&#123;high: <span class="number">12.4</span>, low: <span class="number">134.5</span>&#125;</span><br><span class="line">loc := location&#123;lat: <span class="number">22.3</span>, long: <span class="number">34.9</span>&#125;</span><br><span class="line">report := reportNew&#123;</span><br><span class="line">sol:         <span class="number">12</span>,</span><br><span class="line">temperature: t,</span><br><span class="line">location:    loc,</span><br><span class="line">&#125;</span><br><span class="line">t.averae()</span><br><span class="line">report.temperature.averae() <span class="comment">// duck type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-转发方法"><a href="#13-2-转发方法" class="headerlink" title="13.2 转发方法"></a>13.2 转发方法</h3><p>Go可以通过struct嵌入 来实现方法的转发</p><p>在struct中只给定字段类型，不给定字段名即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol         <span class="keyword">int</span></span><br><span class="line">temperature temperature <span class="comment">// 字段名 类型</span></span><br><span class="line">location    location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol <span class="keyword">int</span></span><br><span class="line">temperature <span class="comment">// struct 嵌入</span></span><br><span class="line">location <span class="comment">// 只有类型，没有字段名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struct的嵌入之后，被嵌入的类型可以直接使用 嵌入类型上的方法了</p><p>在struct中，可以转发任意类型</p><h3 id="13-3-命名冲突"><a href="#13-3-命名冲突" class="headerlink" title="13.3 命名冲突"></a>13.3 命名冲突</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> report <span class="keyword">struct</span> &#123;</span><br><span class="line">sol</span><br><span class="line">temperature</span><br><span class="line">location</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> sol <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">days := <span class="keyword">int</span>(s2 - s)</span><br><span class="line"><span class="keyword">if</span> days &lt; <span class="number">0</span> &#123;</span><br><span class="line">days = -days</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> days</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">days</span><span class="params">(l2 location)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">report := report&#123;sol: <span class="number">15</span>&#125;</span><br><span class="line">fmt.Println(report.sol.days(<span class="number">1446</span>))</span><br><span class="line">fmt.Println(report.days(<span class="number">1446</span>)) <span class="comment">// error 发生歧义， 编译器不知道该调 location类型还是sol类型下面的days方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">days := <span class="keyword">int</span>(s2 - s)</span><br><span class="line"><span class="keyword">if</span> days &lt; <span class="number">0</span> &#123;</span><br><span class="line">days = -days</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> days</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">days</span><span class="params">(l2 location)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r report)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123; <span class="comment">// 顶级类型，可以调用report.days直接访问</span></span><br><span class="line">  <span class="keyword">return</span> r.sol.days(s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">report := report&#123;sol: <span class="number">15</span>&#125;</span><br><span class="line">fmt.Println(report.sol.days(<span class="number">1446</span>))</span><br><span class="line">fmt.Println(report.days(<span class="number">1446</span>)) <span class="comment">// compiler success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-4-继承还是组合"><a href="#13-4-继承还是组合" class="headerlink" title="13.4 继承还是组合"></a>13.4 继承还是组合</h3><p>优先使用对象组合而不是类的继承</p><p>对传统的继承不是必须额，所有使用继承解决的问题都可以通过其它方法解决；</p><h2 id="14-接口"><a href="#14-接口" class="headerlink" title="14. 接口"></a>14. 接口</h2><p>接口关注于类型可以做什么，而不是存储了什么</p><p>接口通过列举类型必须满足的一组方法来进行声明</p><p>在Go语言中，不需要显式声明接口；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 多态</span></span><br><span class="line">t = martian&#123;&#125; <span class="comment">// martian 类型实现了talk方法，所以可以直接赋值</span></span><br><span class="line">fmt.Println(t.talk())</span><br><span class="line">t = laser(<span class="number">3</span>) <span class="comment">// laser 类型实现了talk方法，所以可以直接赋值</span></span><br><span class="line">fmt.Println(t.talk())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-1-接口类型"><a href="#14-1-接口类型" class="headerlink" title="14.1 接口类型"></a>14.1 接口类型</h3><p>为了复用，通常会把接口声明为类型</p><p>按约定，接口名称通常以er结尾</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">shout(martian&#123;&#125;) <span class="comment">// martian 实现了 talker 类型，可以直接调用</span></span><br><span class="line">shout(laser(<span class="number">2</span>)) <span class="comment">// laser实现了 talker类型，可以直接调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口可以和struct嵌入特性一同使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> starship <span class="keyword">struct</span> &#123;</span><br><span class="line">laser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := starship&#123;laser(<span class="number">3</span>)&#125; <span class="comment">// starship 类型包含了laser</span></span><br><span class="line">fmt.Println(s.talk()) <span class="comment">// 因为laser实现talk方法，所以 starship可以调用talk方法</span></span><br><span class="line">shout(s) <span class="comment">// starship有talk方法，满足了 talker类型，而talker类型又能作为 shout函数的参数，所以可以将 starship 传入shout方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时使用组合和接口将构成非常强大的设计工具；</p><h3 id="14-2-探索接口"><a href="#14-2-探索接口" class="headerlink" title="14.2 探索接口"></a>14.2 探索接口</h3><p>Go语言的接口都是隐式满足的</p><p>Go允许在实现代码的过程中，随时创建新的接口。任何代码都能实现接口。包括已经存在的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stardater <span class="keyword">interface</span> &#123;</span><br><span class="line">YearDay() <span class="keyword">int</span></span><br><span class="line">Hour() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> sol <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">YearDay</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(s % <span class="number">668</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">Hour</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func stardate(t time.Time) float64 &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stardate</span><span class="params">(t stardater)</span> <span class="title">float64</span></span> &#123; <span class="comment">// 既然 stardater实现了 YearDay和Hour，可以更改此类型</span></span><br><span class="line">doy := <span class="keyword">float64</span>(t.YearDay())</span><br><span class="line">h := <span class="keyword">float64</span>(t.Hour()) / <span class="number">24.0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1000</span> + doy + h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">day := time.Date(<span class="number">2012</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Printf(<span class="string">"%.1f Has\n"</span>, stardate(day))</span><br><span class="line"></span><br><span class="line">s := sol(<span class="number">1422</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%.1f Happy\n"</span>, stardate(s)) <span class="comment">// 因为sol类型也实现了stardater接口，所以可以传入stardate方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-3-满足接口"><a href="#14-3-满足接口" class="headerlink" title="14.3 满足接口"></a>14.3 满足接口</h3><p>Go标准库导出了很多只有单个方法的接口；</p><p>Go通过简单的、通常只有单个方法的接口… 来鼓励组合而不是继承，这些接口在各个组件之间形成了简明易懂的界限</p><p>例如在fmt包 声明的Stringer接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v, %v"</span>, l.lat, l.long)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">curiosity := location&#123;<span class="number">-4.5895</span>, <span class="number">137.4417</span>&#125;</span><br><span class="line">fmt.Println(curiosity) <span class="comment">// location实现了String方法，满足了 Stringer接口。 所以就能被fmt.Println 调用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库中常用的接口还包括: io.Reader, io.Write, json.Marshaler</p><h2 id="15-指针"><a href="#15-指针" class="headerlink" title="15 指针"></a>15 指针</h2><p>指针是指向另一个变量地址的变量</p><p>Go语言的指针同时也强调安全性，不会出现迷途指针（dangling pointers）</p><h3 id="15-1-amp-和"><a href="#15-1-amp-和" class="headerlink" title="15.1 &amp; 和 *"></a>15.1 &amp; 和 *</h3><p>变量会将它们的值存储在计算机的RAM里，存储位置就是该变量的内存地址；</p><p>&amp; ： 获得变量的内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">answer := <span class="number">42</span></span><br><span class="line">fmt.Println(&amp;answer) <span class="comment">// 0xc000014090</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp; 操作符无法获得字符串/数值/布尔字面值的地址；</p><ul><li>&amp;42， &amp;”hello” 这些都会导致编译器报错</li></ul><p><code>*操作符</code>与&amp;的作用相反，它用来解引用，提供内存地址指向的值；</p><p>C语言中的内存地址可以通过 address++ 这样的指针运算进行操作，在Go里面不允许这种不安全的操作</p><h3 id="15-2-指针类型"><a href="#15-2-指针类型" class="headerlink" title="15.2 指针类型"></a>15.2 指针类型</h3><p>指针存储的是内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">answer := <span class="number">42</span></span><br><span class="line">address := &amp;answer    <span class="comment">// *int address就是一个指向int类型的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针类型和其它普通类型一样，出现在所有需要用到类型的地方，如变量声明、函数行参、返回值类型、结构体字段等</p><p>将*放在类型前面表示声明指针类型</p><p>将*放在变量前面表示解引用操作</p><h3 id="15-3-指针就是用来指向的"><a href="#15-3-指针就是用来指向的" class="headerlink" title="15.3 指针就是用来指向的"></a>15.3 指针就是用来指向的</h3><p>两个指针变量持有相同的内存地址，那么它们就是相等的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 说明下面语句的作用</span></span><br><span class="line">a = *b; <span class="comment">// 将b指针解引用，赋值给a，这个是值拷贝</span></span><br><span class="line">*b = <span class="string">'alex'</span> <span class="comment">// b地址解引用，重复赋值</span></span><br></pre></td></tr></table></figure><h3 id="15-4-指向结构的指针"><a href="#15-4-指向结构的指针" class="headerlink" title="15.4 指向结构的指针"></a>15.4 指向结构的指针</h3><p>与字符串和数值不一样，复合字面量的前面可以放置&amp;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name, superpower <span class="keyword">string</span></span><br><span class="line">age              <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">timmy := &amp;person&#123;</span><br><span class="line">name: <span class="string">"alex"</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (*timmy).superpower = "flying" // 访问字段时， 解引用不是必须要做的</span></span><br><span class="line">timmy.superpower = <span class="string">"flying"</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, timmy) <span class="comment">// &amp;&#123;name:alex superpower:flying age:10&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问字段时，对结构体进行解引用并不是必须的；</p><h3 id="15-5-指向数组的指针"><a href="#15-5-指向数组的指针" class="headerlink" title="15.5 指向数组的指针"></a>15.5 指向数组的指针</h3><p>和结构体一样，可以把&amp; 放在数组的复合字面值前面来创建指向数组的指针</p><p>数组在执行索引或切片操作时会自动解引用。没有必要写(*array)[0]这种形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  arr := &amp;[<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line">  arr[<span class="number">0</span>]</span><br><span class="line">  arr[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与C语言不一样，Go里面数组和指针是两种完全独立的类型</p><p>slice和map的复合字面值前面也可以放置 &amp;操作符，但是Go并没有为它们提供自动解引用的功能；</p><h4 id="15-5-1-修改数组"><a href="#15-5-1-修改数组" class="headerlink" title="15.5.1  修改数组"></a>15.5.1  修改数组</h4><p>函数通过指针对数组的元素进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rune指的是？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">(board *[8][8]<span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'r'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> board [<span class="number">8</span>][<span class="number">8</span>]<span class="keyword">rune</span></span><br><span class="line">reset(&amp;board)</span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, board[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">// r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-5-2-什么情况下应该使用指向数组的指针"><a href="#15-5-2-什么情况下应该使用指向数组的指针" class="headerlink" title="15.5.2 什么情况下应该使用指向数组的指针"></a>15.5.2 什么情况下应该使用指向数组的指针</h4><p>隐式的指针</p><p>Go语言里一些内置的集合类型就在暗中使用指针</p><p>map在被赋值或者被作为参数传递的时候不会被复制</p><ul><li>map就是一种隐式指针</li><li>这种写法就是多此一举： func demo(planets *map[string]string) 应该去掉🌟</li></ul><p>map的键值都可以是指针类型</p><p>需要将指针指向map的情况并不多见</p><h4 id="15-5-3-slice指向数组"><a href="#15-5-3-slice指向数组" class="headerlink" title="15.5.3 slice指向数组"></a>15.5.3 slice指向数组</h4><p>之前说过slice是指向数组的窗口，实际上slice在指向数组元素的时候也使用了指针；</p><p>每个slice内部都会被表示为一个包含3个元素的结构，它们分别指向：</p><ul><li>数组的指针</li><li>slice的容量</li><li>slice的长度</li></ul><p>当slice被直接传递至函数或方法时，slice的内部指针就可以对底层数据进行修改 </p><p>指向slice的显式指针的唯一作用就是修改slice本身： slice的长度、容量以及起始偏移量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reclassify</span><span class="params">(p *[]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">*p = (*p)[<span class="number">0</span>:<span class="number">8</span>] <span class="comment">// 修改切片本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"m"</span>, <span class="string">"v"</span>, <span class="string">"E"</span>, <span class="string">"MA"</span>, <span class="string">"ju"</span>, <span class="string">"sa"</span>, <span class="string">"ur"</span>, <span class="string">"ne"</span>, <span class="string">"pl"</span>,</span><br><span class="line">&#125;</span><br><span class="line">reclassify(&amp;planets)</span><br><span class="line">fmt.Println(planets) <span class="comment">// [m v E MA ju sa ur ne]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-5-4-指针和接口"><a href="#15-5-4-指针和接口" class="headerlink" title="15.5.4 指针和接口"></a>15.5.4 指针和接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">shout(martian&#123;&#125;)</span><br><span class="line">shout(&amp;martian&#123;&#125;)</span><br><span class="line"><span class="comment">// NACK NACK</span></span><br><span class="line"><span class="comment">// NACK NACK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是martian 还是指向martian的指针，都可以满足talker接口</p><p>如果方法使用的指针接收者，那么情况会有所不同；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(*l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pew := laser(<span class="number">2</span>)</span><br><span class="line">shout(&amp;pew) <span class="comment">// PEWPEW</span></span><br><span class="line">shout(pew) <span class="comment">// compiler error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-6-实现修改"><a href="#15-6-实现修改" class="headerlink" title="15.6 实现修改"></a>15.6 实现修改</h3><p>Go语言的函数和方法都是按值传递参数的，这意味着函数总是操作于被传递参数的副本；</p><p>当指针被传递到函数时，函数将接收传入的内存地址的副本，之后函数可以通过解引用内存地址来修改指针指向的值；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name, superpower <span class="keyword">string</span></span><br><span class="line">age              <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">birthday</span><span class="params">(p *person)</span></span> &#123;</span><br><span class="line">p.age++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">rebecca := person&#123;</span><br><span class="line">name:       <span class="string">"alex"</span>,</span><br><span class="line">age:        <span class="number">10</span>,</span><br><span class="line">superpower: <span class="string">"imagination"</span>,</span><br><span class="line">&#125;</span><br><span class="line">birthday(&amp;rebecca) <span class="comment">// 传入的虽然是指针副本，但是指向同一地址</span></span><br><span class="line"><span class="comment">// birthday(rebecca) // 传入的是引用类型副本，等于复制了一个引用类型，性能差</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, rebecca) <span class="comment">// &#123;name:alex superpower:imagination age:11&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-7-指针接收者"><a href="#15-7-指针接收者" class="headerlink" title="15.7 指针接收者"></a>15.7 指针接收者</h3><p>方法的接收者和方法的参数在处理指针方面是很相似的</p><p>Go语言在变量通过点标记法进行调用的时候，自动使用&amp;取得变量的内存地址</p><ul><li>所以不用写 (&amp;nathan).birthday() 这种形式也可以正常运行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name, superpower <span class="keyword">string</span></span><br><span class="line">age              <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">birthday</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">terry := &amp;person&#123;</span><br><span class="line">name: <span class="string">"alex"</span>,</span><br><span class="line">age:  <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line">terry.birthday()</span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, terry) <span class="comment">// &amp;&#123;name:alex age:16&#125;</span></span><br><span class="line"></span><br><span class="line">nathan := person&#123;</span><br><span class="line">name: <span class="string">"leo"</span>,</span><br><span class="line">age:  <span class="number">17</span>,</span><br><span class="line">&#125;</span><br><span class="line">nathan.birthday()</span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, nathan) <span class="comment">// &#123;name:leo age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指针作为接收者的策略应该始终如一：</p><p>如果一种类型的某些方法需要用到指针作为接收者，就应该为这种类型的所有方法都是用指针作为接收者；</p><h3 id="15-8-内部指针"><a href="#15-8-内部指针" class="headerlink" title="15.8 内部指针"></a>15.8 内部指针</h3><p>Go语言提供了内部指针这种特性</p><p>它用于确定结构体中指定字段的内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stats <span class="keyword">struct</span> &#123;</span><br><span class="line">level             <span class="keyword">int</span></span><br><span class="line">endurance, health <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelUp</span><span class="params">(s *stats)</span></span> &#123;</span><br><span class="line">s.level++</span><br><span class="line">s.endurance = <span class="number">42</span> + (<span class="number">15</span> * s.level)</span><br><span class="line">s.health = <span class="number">5</span> * s.endurance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> character <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">stats stats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">player := character&#123;name: <span class="string">"alex"</span>&#125;</span><br><span class="line">levelUp(&amp;player.stats)            <span class="comment">//  结构体某个字段的地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, player.stats) <span class="comment">// &#123;level:1 endurance:57 health:285&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;操作符不仅可以获得结构体的内存地址，还可以获得结构体中指定字段的内存地址；</p><h3 id="15-9-小结"><a href="#15-9-小结" class="headerlink" title="15.9 小结"></a>15.9 小结</h3><p>应合理使用指针，不要过度使用指针</p><h2 id="16-nil"><a href="#16-nil" class="headerlink" title="16. nil"></a>16. nil</h2><p>nil是一个名字，表示“无” 或“零”</p><p>Go里面，nil是一个零值</p><p>如果一个指针没有明确的指向，那么它的值就是nil</p><p>除了指针，nil还是slice、map和接口的零值</p><p>Go语言的nil，比以往语言中的null更为友好，并且用的没那么频繁，但是仍需谨慎使用</p><h3 id="16-1-nil会导致panic"><a href="#16-1-nil会导致panic" class="headerlink" title="16.1 nil会导致panic"></a>16.1 nil会导致panic</h3><p>如果指针没有明确的指向，那么程序将无法对其实施的解引用。</p><p>尝试解引用一个nil指针将导致程序崩溃</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nowhere *<span class="keyword">int</span></span><br><span class="line">fmt.Println(nowhere) <span class="comment">//  &lt;nil&gt;</span></span><br><span class="line">fmt.Println(*nowhere) <span class="comment">// compiler error</span></span><br><span class="line">  <span class="comment">// 防范代码</span></span><br><span class="line">  <span class="keyword">if</span> nowhere != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(*nowhere)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">days</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.age++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为值为nil的接收者和值为nil的参数在行为上并没有区别，所以go语言即使在接收者为nil的情况下，也会继续调用方法；</p><h3 id="16-2-nil函数值"><a href="#16-2-nil函数值" class="headerlink" title="16.2 nil函数值"></a>16.2 nil函数值</h3><p>当变量被声明为函数类型时，它的默认值是nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">fmt.Println(fn == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查函数值是否为nil，并在有需要时提供默认行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortStrings</span><span class="params">(s []<span class="keyword">string</span>, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> less == <span class="literal">nil</span> &#123;</span><br><span class="line">less = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(s, less)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">food := []<span class="keyword">string</span>&#123;<span class="string">"onion"</span>, <span class="string">"carrot"</span>, <span class="string">"celery"</span>&#125;</span><br><span class="line">sortStrings(food, <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(food) <span class="comment">// [carrot celery onion]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-nil-slice"><a href="#16-3-nil-slice" class="headerlink" title="16.3 nil slice"></a>16.3 nil slice</h3><p>如果slice 在声明之后没有使用复合字面值或内置的make 函数进行初始化，那么它的值就是nil</p><p>幸运的是，range、len、append等内置数都可以正常处理值为nil的slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> soup []<span class="keyword">string</span></span><br><span class="line">fmt.Println(soup == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> _, ingredient := <span class="keyword">range</span> soup &#123;</span><br><span class="line">fmt.Println(ingredient)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(soup)) <span class="comment">// 0</span></span><br><span class="line">soup = <span class="built_in">append</span>(soup, <span class="string">"onion"</span>, <span class="string">"carrort"</span>, <span class="string">"celery"</span>)</span><br><span class="line">fmt.Println(soup) <span class="comment">// [onion carrort celery]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然空slice和值为nil的slice并不相等，但它们通常可以替换使用；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirepoix</span><span class="params">(ingredients []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(ingredients, <span class="string">"onion"</span>, <span class="string">"carrot"</span>, <span class="string">"celery"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">soup := mirepoix(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(soup) <span class="comment">// [onion carrort celery]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-4-nil-map"><a href="#16-4-nil-map" class="headerlink" title="16.4 nil map"></a>16.4 nil map</h3><p>和slice一样，如果map在声明后没有使用复合字面值或内置的make函数进行初始化，那么它的值将会是默认的nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> soup <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(soup == <span class="literal">nil</span>)         <span class="comment">// true</span></span><br><span class="line">measurement, ok := soup[<span class="string">"onion"</span>] <span class="comment">// 对值为nil的map读取不会报错</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(measurement)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ingredient, measurement := <span class="keyword">range</span> soup &#123; <span class="comment">// 对值为nil的 map进行 range操作依然不会报错</span></span><br><span class="line">fmt.Println(ingredient, measurement)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-5-nil接口"><a href="#16-5-nil接口" class="headerlink" title="16.5 nil接口"></a>16.5 nil接口</h3><p>声明为接口类型的变量在未被赋值时，它的零值是nil</p><p>对于一个未被赋值的接口变量来说，它的接口类型和值都是nil，并且变量本身也等于nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// %T 接口类型</span></span><br><span class="line"><span class="comment">// %v 值</span></span><br></pre></td></tr></table></figure><p>当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">v = p</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// *int &lt;nil&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。</p><p>在Go中，接口类型的变量只有在类型和值都为nil时才等于nil</p><ul><li>即使接口变量的值仍为nil，但只要它的类型不是nil，那么该变量就不等于nil；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">v = p</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, v) <span class="comment">//(*int)(nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-6-nil之外的另一个选择"><a href="#16-6-nil之外的另一个选择" class="headerlink" title="16.6 nil之外的另一个选择"></a>16.6 nil之外的另一个选择</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> number <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="keyword">int</span></span><br><span class="line">valid <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNumber</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">number</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> number&#123;value: v, valid: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n number)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !n.valid &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"not set"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>, n.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := newNumber(<span class="number">42</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 42</span></span><br><span class="line">e := number&#123;&#125;</span><br><span class="line">fmt.Println(e) <span class="comment">// not set</span></span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><h2 id="17-处理错误"><a href="#17-处理错误" class="headerlink" title="17 处理错误"></a>17 处理错误</h2><p>Go语言允许函数和方法同时返回多个值</p><p>按照惯例，函数在返回错误时，最后边的返回值应用来表示错误</p><p>调用函数后，应立即检查是否发生错误；</p><ul><li>如果没有错误发生，那么返回的错误值为nil</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">files, err := ioutil.ReadDir(<span class="string">"."</span>) <span class="comment">// . 表示当前目录</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">fmt.Println(file.Name()) <span class="comment">// 00.go</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> </p><p>当错误发生时候，函数返回的其它值通常就不再可信</p><h3 id="17-1-优雅的错误处理"><a href="#17-1-优雅的错误处理" class="headerlink" title="17.1 优雅的错误处理"></a>17.1 优雅的错误处理</h3><p>减少错误处理代码是一种策略是： 将程序中不会出错的部分和包含潜在错误隐患的部分隔离开来</p><p>对于不得不返回错误的代码，应尽力简化相应的错误处理代码</p><h3 id="17-2-go的谚语"><a href="#17-2-go的谚语" class="headerlink" title="17.2 go的谚语"></a>17.2 go的谚语</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Errors are value， </span><br><span class="line">Do not just check erros， handle them gracefully <span class="comment"># 除了检查错误，还要优雅的处理它们</span></span><br><span class="line">Do not panic</span><br><span class="line"></span><br><span class="line">Make the zero value useful</span><br><span class="line"></span><br><span class="line">the bigger the interface, the weaker the abstraction <span class="comment"># interface越大，抽象度越差</span></span><br><span class="line"></span><br><span class="line">interface &#123;&#125; says nothing <span class="comment"># interface&#123;&#125; 相当于什么都没定义，可以表示任意类型</span></span><br><span class="line"></span><br><span class="line">Gofmt is style is no one is favorite, yet gofmt is everyone is favorite <span class="comment"># gofmt的样式所有人都不喜欢，但gofmt 所有人都喜欢</span></span><br><span class="line"></span><br><span class="line">Doc is <span class="keyword">for</span> users</span><br><span class="line"></span><br><span class="line">a litter copying is better than a little dependency <span class="comment"># 少许的拷贝要比少许的依赖要好</span></span><br><span class="line"></span><br><span class="line">clear is better than clever</span><br><span class="line"><span class="comment"># 清晰比聪明更好</span></span><br><span class="line"></span><br><span class="line">concurrency is not parallelism</span><br><span class="line"><span class="comment"># 并发并不是并行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> not communicate by sharing memory, share memory by communicating</span><br><span class="line"><span class="comment"># 不要通过共享内存来进行通信,通过通信来共享内存</span></span><br><span class="line"></span><br><span class="line">channels orchestrate； mutexes serialize</span><br><span class="line"><span class="comment"># channels 应该进行编排，mutexes（互斥量）按序列化执行</span></span><br></pre></td></tr></table></figure><h3 id="17-3-文件写入"><a href="#17-3-文件写入" class="headerlink" title="17.3 文件写入"></a>17.3 文件写入</h3><p>写入文件的时候可能出错：</p><ul><li>路径不正确</li><li>权限不够</li><li>磁盘空间不足</li></ul><p>文件写入完毕后，必须被关闭，确保文件被刷到磁盘上，避免资源的泄漏；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到 f文件内</span></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Errors are values."</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// write error</span></span><br><span class="line">f.Close()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Do not just check erros, handle them gracefully"</span>)</span><br><span class="line">f.Close()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := proverbs(<span class="string">"proverbs.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-4-内置类型-error"><a href="#17-4-内置类型-error" class="headerlink" title="17.4 内置类型 error"></a>17.4 内置类型 error</h3><p>内置类型error用来表示错误</p><h2 id="18-defer关键字"><a href="#18-defer关键字" class="headerlink" title="18 defer关键字"></a>18 defer关键字</h2><p>使用defer关键字，Go可以确保<code>所有deferred的动作可以在函数返回前执行</code>；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入到 f文件内</span></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Errors are values."</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// write error</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Do not just check erros, handle them gracefully"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := proverbs(<span class="string">"proverbs.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以defer任意的函数和方法</p><p>defer并不是专门做错误处理的；</p><p>defer可以消除必须时刻惦记执行资源释放的负担</p><h3 id="18-1-defer的动作什么时候会被执行"><a href="#18-1-defer的动作什么时候会被执行" class="headerlink" title="18.1 defer的动作什么时候会被执行"></a>18.1 defer的动作什么时候会被执行</h3><p>有创意的错误处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> safeWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">w   io.Writer</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *safeWriter)</span> <span class="title">writeln</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> sw.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, sw.err = fmt.Fprintln(sw.w, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">sw := safeWriter&#123;w: f&#125;</span><br><span class="line">sw.writeln(<span class="string">"Errors are values"</span>)</span><br><span class="line">sw.writeln(<span class="string">"Do not juse check errors, handle them gracefully"</span>)</span><br><span class="line">sw.writeln(<span class="string">"do not panic"</span>)</span><br><span class="line"><span class="keyword">return</span> sw.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-2-New-error"><a href="#18-2-New-error" class="headerlink" title="18.2 New error"></a>18.2 New error</h3><p>erros包里有一个构造用New函数，它接收string作为参数用来表示错误信息。该函数返回error类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An error occurred: %v, \n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// An error occurred: out of bounds,</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>错误信息应具有信息性</p><p>可以把错误信息当作用户界面的一部分，无论对最终用户还是开发者；</p><h3 id="18-3-按需返回错误"><a href="#18-3-按需返回错误" class="headerlink" title="18.3 按需返回错误"></a>18.3 按需返回错误</h3><p>按照惯例，包含错误信息的变量名应以Err开头</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// 按惯例，包含错误信息的变量名应以Err开头</span></span><br><span class="line">ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrBounds</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrBounds, ErrDigit:</span><br><span class="line">fmt.Println(<span class="string">"Les erreurs de parametres hors limites."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>errors.New 这个构造函数是使用指针实现的，所以上例中的switch语句比较的是内存地址，而不是错误包含的文字信息</p><h3 id="18-4-自定义错误类型"><a href="#18-4-自定义错误类型" class="headerlink" title="18.4 自定义错误类型"></a>18.4 自定义错误类型</h3><p>error类型是一个内置的接口：任何类型只要实现了返回string的Error()方法就满足了该接口；</p><p>可以创建新的错误类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SudokuError []error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(se SudokuError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> se &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strings.Join(s, <span class="string">", "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errs SudokuError</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrBounds)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !validDigit(digit) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrDigit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">int8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> digit &gt;= <span class="number">1</span> &amp;&amp; digit &lt;= <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">12</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrBounds, ErrDigit:</span><br><span class="line">fmt.Println(<span class="string">"Les erreurs de parametres hors limites."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out of bounds, invalid digit</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br></pre></td></tr></table></figure><p>按照惯例， 自定义错误类型的名字应以Error结尾</p><ul><li>有时候名字就是Error，例如 url.Error</li></ul><h3 id="18-5-类型断言"><a href="#18-5-类型断言" class="headerlink" title="18.5 类型断言"></a>18.5 类型断言</h3><p>上例中，我们可以使用类型断言来访问每一种错误；</p><p>使用类型断言，你可以把接口类型转化成底层的具体类型</p><ul><li>例如： err.(SudokuError)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SudokuError []error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(se SudokuError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> se &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strings.Join(s, <span class="string">", "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errs SudokuError</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrBounds)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !validDigit(digit) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrDigit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">int8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> digit &gt;= <span class="number">1</span> &amp;&amp; digit &lt;= <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">10</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 使用类型错误断言，</span></span><br><span class="line"><span class="keyword">if</span> errs, ok := err.(SudokuError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d error(s) occurred: \n"</span>, <span class="built_in">len</span>(errs))</span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> errs &#123;</span><br><span class="line">fmt.Printf(<span class="string">"- %v\n"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - out of bounds</span></span><br><span class="line"><span class="comment">// - invalid digit</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br></pre></td></tr></table></figure><p>如果类型满足多个接口，那么类型断言使它从一个接口类型转化为另一个接口类型</p><h3 id="18-6-do-not-panic（不要恐慌）"><a href="#18-6-do-not-panic（不要恐慌）" class="headerlink" title="18.6 do not panic（不要恐慌）"></a>18.6 do not panic（不要恐慌）</h3><p>Go没有异常，它有个类似机制panic</p><p>当panic发生，那么程序就会崩溃</p><h3 id="18-7-其它语言的异常-vs-Go的错误值"><a href="#18-7-其它语言的异常-vs-Go的错误值" class="headerlink" title="18.7 其它语言的异常 vs Go的错误值"></a>18.7 其它语言的异常 vs Go的错误值</h3><p>其它语言的异常在行为和实现上与Go语言的错误值有很大的不同</p><ul><li>如果函数抛出异常，并且附近没人捕获它，那么它就会 冒泡 到函数的调用者那里，如果还没有人进行捕获，那么就继续“冒泡”到更上层的调用者。。。直到达到栈（Stack）的顶部（例如main函数）</li><li>异常这种错误处理方式可被看作是可选的；<ul><li>不处理异常，就不需要加入其它代码；</li><li>想要处理异常，就需要加入相当数量的专用代码</li></ul></li><li>Go语言中错误值更简单灵活；<ul><li>忽略错误是有意识的决定，从代码上看也是显而易见的；</li></ul></li></ul><h3 id="18-8-如何panic"><a href="#18-8-如何panic" class="headerlink" title="18.8 如何panic"></a>18.8 如何panic</h3><p>Go里有一个和其它语言异常类似的机制： panic</p><p>实际上，panic很少出现</p><p>创建panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="string">"i forgot my towel"</span>)</span><br></pre></td></tr></table></figure><p>panic的参数可以是任意类型</p><h3 id="18-9-错误值、panic、os-Exit"><a href="#18-9-错误值、panic、os-Exit" class="headerlink" title="18.9 错误值、panic、os.Exit"></a>18.9 错误值、panic、os.Exit</h3><p>通常，更推荐使用错误值，其次才是panic</p><p>panic比Os.Exit更好： panic后会执行所有defer的动作，而Os.Exit则不会</p><p>有时候Go程序会panic而不是返回错误值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> zero <span class="keyword">int</span></span><br><span class="line">_ = <span class="number">42</span> / zero</span><br><span class="line"><span class="comment">// panic: runtime error: integer divide by zero</span></span><br><span class="line"><span class="comment">// exit status 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止panic导致程序崩溃，Go提供了recover函数(恢复)</p><p>defer的动作会在函数返回前执行，即使发生了panic</p><p>但如果defer的函数调用了recover，panic就会停止，程序将继续运行；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// defer会在函数返回前执行，即使发生panic</span></span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;<span class="comment">// defer调用recover，panic就会停止，程序将继续执行</span></span><br><span class="line">fmt.Println(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"i forgot my towel"</span>)</span><br><span class="line"><span class="comment">// i forgot my towel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-doc"><a href="#19-doc" class="headerlink" title="19. doc"></a>19. doc</h2><p><a href="Https://pkg.go.dev">Https://pkg.go.dev</a></p><p><a href="https://golang.org" target="_blank" rel="noopener">https://golang.org</a></p><p>Effective go</p><h2 id="20-Error"><a href="#20-Error" class="headerlink" title="20 Error"></a>20 Error</h2><h3 id="20-1-Error-vs-exception"><a href="#20-1-Error-vs-exception" class="headerlink" title="20.1 Error vs exception"></a>20.1 Error vs exception</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// New 返回的是 内部 errorString对象的指针；</span></span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go error就是一个普通的接口，普通的值</p><p>基础库中大量自定义的error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrInvalidUnreadByte = errors.New(<span class="string">"bufio:invalid use UnreadByte"</span>)</span><br></pre></td></tr></table></figure><ul><li>New函数为什么返回 &amp;errorString</li></ul><p>返回地址的好处就是，假如两个error的文本内容完全一致，它也不会相等；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errorString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span><span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> errorString(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNamedType = New(<span class="string">"EOF"</span>)</span><br><span class="line"><span class="keyword">var</span> ErrStructType = errors.New(<span class="string">"EOF"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> ErrNamedType == New(<span class="string">"EOF"</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">"Named Type Error"</span>) <span class="comment">// 输出了这里，因为底层都是string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ErrStructType == errors.New(<span class="string">"EOF"</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">"struct type Error"</span>) <span class="comment">// 不输出，因为底层是true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20-1-1-exception"><a href="#20-1-1-exception" class="headerlink" title="20.1.1 exception"></a>20.1.1 exception</h4><p>Go的处理异常逻辑是不引入exception，支持多参数返回，所以很容易在函数签名中带上实现了error interface的对象，交由调用者来判定；</p><p><em>如果一个函数返回了(value error)，不能对这个value做任何假设，必须先判定error，唯一可以忽略error的是，如果你连value也不关心</em></p><p>当我们抛出异常的时候，相当于你把exception扔给了调用者来处理。比如C++中，把string转为int，如果转换失败，会抛出异常；</p><p>Go panic 意味着fatal error （“就是挂了”），不能假设调用者来解决 panic，意味着代码不能继续运行；</p><p>使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了panic；</p><p>如果出现了panic，不能假定调用者来解决这个panic，或者recover这个错误，然后让这个代码的逻辑继续进行，因为可能逻辑不完整。</p><p>Request-Driven</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">()</span> <span class="title">HandlerFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">var</span> rawReq []<span class="keyword">byte</span></span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        c.AbortWithStatus(<span class="number">500</span>) <span class="comment">//直接服务端异常，不做现场恢复；</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    c.Next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在请求中的野生的goroutine是 recover不住的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"goland go"</span>)</span><br><span class="line">Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"一路向西"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(x <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">x()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goland go<br>hello<br>一路向西</p><h4 id="20-1-2-什么panic不处理"><a href="#20-1-2-什么panic不处理" class="headerlink" title="20.1.2 什么panic不处理"></a>20.1.2 什么panic不处理</h4><ol><li>main函数里面有些代码是强依赖的,如果初始化不成功 只能panic</li><li>配置文件写的值不对；</li></ol><ul><li>什么是强依赖，什么是弱依赖</li></ul><p>代码做DAO的初始化，如果DAO的数据库能连不上，redis cache能连上。这个时候代码该不该启动呢？</p><p>这个示例就相当如果缓存击穿，读库的话 一定会报错；</p><p>读多写少的话，是不是先提供读请求出去呢？</p><ul><li>DAO层查一个记录查不到，请问是返回一个空指针，还是返回一个error比较好</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Positive</span><span class="params">(n <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="string">"undefined"</span>) <span class="comment">// 返回一个error类型更优雅</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n &gt; <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Check</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">pos, err := Positive(n)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(n,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pos &#123;</span><br><span class="line">fmt.Println(n,<span class="string">"is positive"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(n,<span class="string">"is negative"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Check(<span class="number">1</span>)</span><br><span class="line">Check(<span class="number">0</span>)</span><br><span class="line">Check(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界，不可恢复的问题，栈溢出，我们才使用panic，对于其他的错误情况，我们应该是期望使用 errors来进行判断</p><p>error模型的好处；</p><ul><li>简单</li><li>go的编程模型是考虑失败，而不是成功（plan for failure， not success）</li><li>没有隐藏的控制流（哪层的异常，哪里catch）</li><li>完全交给你来控制error</li><li>Error are values（不会像exception那样固定死类型，给予开发者更多可以diy的）</li></ul><h3 id="20-2-Error-Type"><a href="#20-2-Error-Type" class="headerlink" title="20.2 Error Type"></a>20.2 Error Type</h3><h4 id="20-2-1-Sentinel-Error"><a href="#20-2-1-Sentinel-Error" class="headerlink" title="20.2.1 Sentinel Error"></a>20.2.1 Sentinel Error</h4><p>预定义的特定错误，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>) <span class="comment">// 包级别的变量</span></span><br></pre></td></tr></table></figure><p>虽然标准库中有大量EOF这种包变量的写法，但并不建议在项目中大量使用；</p><p>但是，在定义业务的错误码的时候，使用这种方式也不失为一种方案；</p><h4 id="20-2-2-Error-types"><a href="#20-2-2-Error-types" class="headerlink" title="20.2.2 Error types"></a>20.2.2 Error types</h4><p>不推荐使用</p><h4 id="20-2-3-Opaque-errors"><a href="#20-2-3-Opaque-errors" class="headerlink" title="20.2.3 Opaque errors"></a>20.2.3 Opaque errors</h4><blockquote><p>非透明的。  （推荐使用）</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/quux/bar"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line">x,err:= bar.Foo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不透明错误处理的全部功能——只需返回错误而不假设其内容；</p><p>断言错误实现了特定的行为，而不是断言错误是特定的类型或值；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">  Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  te, ok := err.(temporary) <span class="comment">// 在内部断言；</span></span><br><span class="line">  <span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-3-Handling-Error"><a href="#20-3-Handling-Error" class="headerlink" title="20.3 Handling Error"></a>20.3 Handling Error</h3><blockquote><p>如何优雅的写error代码</p></blockquote><ol><li>缩进，无错误的正常流程代码，将成为一条直线，而不是缩进的代码</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do stuff</span></span><br><span class="line"><span class="comment">// 正常逻辑在非缩进里面写；</span></span><br><span class="line"></span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// do stuff</span></span><br><span class="line">  <span class="comment">// 会陷入无限缩进的坑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle error</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  err := authenticate(r.User)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推荐的写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> authenticate(r.User) <span class="comment">// 返回的类型和 函数签名的返回值是match的，直接返回即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 坏的实践</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span><span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">br = bufio.NewReader(r)</span><br><span class="line">lines <span class="keyword">int</span></span><br><span class="line">err error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err = br.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">lines++</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines1</span><span class="params">(r io.Reader)</span><span class="params">(<span class="keyword">int</span>, error)</span></span>  &#123;</span><br><span class="line">sc:= bufio.NewScanner(r) <span class="comment">// 扫描器</span></span><br><span class="line">lines := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">lines++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lines, sc.Err() <span class="comment">// 将错误信息直接写入src.Err中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 啰嗦的 err处理</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">Key, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">Code <span class="keyword">int</span></span><br><span class="line">Reason <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span> </span><br><span class="line">error &#123;</span><br><span class="line">_, err := fmt.Fprintf(w, <span class="string">"HTTP/11 %d %s\r\n"</span>, st.Code, st.Reason)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, h:= <span class="keyword">range</span> headers &#123;</span><br><span class="line">_,err := fmt.Fprintf(w, <span class="string">"%s: %s\r\n"</span>, h.Key, h.Value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := fmt.Fprintf(w, <span class="string">"\r\n"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _,err := fmt.Fprintf(w, <span class="string">"\r\n"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_,err = io.Copy(w, body)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的实现</span></span><br><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">io.Writer</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span> <span class="title">Write</span> <span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123; <span class="comment">// 等下次调用的时候，如果e.err有报错，直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">n, e.err = e.Writer.Write(buf) <span class="comment">// 先将报错信息 保存在e.err中</span></span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">ew := &amp;errWriter&#123;Writer:w&#125;</span><br><span class="line">fmt.Fprintf(ew, <span class="string">"HTTP/11 %d %s\r\n"</span>, st.Code, st.Reason)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,h:= <span class="keyword">range</span> headers&#123;</span><br><span class="line">fmt.Fprintf(ew, <span class="string">"%s:%s\r\n"</span>, h.Key, h.Value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(ew, <span class="string">"\r\n"</span>)</span><br><span class="line">io.Copy(ew,body)</span><br><span class="line"><span class="keyword">return</span> ew.err <span class="comment">// 最终返回 累计写入到 err的错误；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20-3-1-Wrap-erros"><a href="#20-3-1-Wrap-erros" class="headerlink" title="20.3.1 Wrap erros"></a>20.3.1 Wrap erros</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> authenticate(r.User) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果authenticate返回错误，则AuthenticateRequest 会将错误返回给调用方，调用者可能也会这样做。依此类推，在程序的顶部，输出的错误会是“没有这样的文件或目录”</p><ul><li>第一次改进</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  err := authenticate(r.User)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"authenticate failed: %v"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解决的问题在于，没有生成错误的file:line 信息，没有导致错误的调用堆栈的堆栈跟踪。</p><p>还有一个坑就是，这种模式与sentinel erros或type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始错误，导致等值判定失败；</p><p><strong>处理error的依据</strong></p><p>You should only handle errors once, Handling an error means. Inspecting the error value, and making a single decision;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span><span class="title">error</span></span> &#123;</span><br><span class="line">_, err := w.Write(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"unable to write:"</span>, err)</span><br><span class="line">    <span class="comment">// 因此在此return了 err</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">    <span class="comment">// 如果这里不err会发生什么呢？</span></span><br><span class="line"><span class="comment">// Go的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做任何假设；</span></span><br><span class="line">    <span class="comment">// 由于JSON序列化失败，buf内容是未知的，可能它不包含任何内容，也可能包含一个半写的JSON片段；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf, err := json.Marshal(conf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"could not marshal config: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 因为WriteAll函数内部已经log了错误，这里属于重复log</span></span><br><span class="line">log.Printf(<span class="string">"could not write config: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那日志到底怎么打？</strong></p><blockquote><p>日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应该予以质疑，记录的原因是因为某些东西失败了，而日志包含了答案；</p></blockquote><ol><li>错误要被日志记录</li><li>应用程序处理错误，保证100%完整性</li><li>之后不再报告当前错误</li></ol><p>建议使用<code>github.com/pkg/errors</code></p><ul><li>第二次改进</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="keyword">string</span>)</span><span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"open failed"</span>)</span><br><span class="line"><span class="comment">// wrap方法会把堆栈信息保存起来；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">buf, err := ioutil.ReadAll(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span><span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">home:= os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">config, err:= ReadFile(filepath.Join(home, <span class="string">".settings.xml"</span>))</span><br><span class="line"><span class="keyword">return</span> config, errors.WithMessage(err, <span class="string">"could not read config"</span>)</span><br><span class="line"><span class="comment">//withMessage： 不保存堆栈信息，只附带一些上下文信息；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">_,err:= ReadConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 在最上层打日志；</span></span><br><span class="line">fmt.Printf(<span class="string">"orginal error: %T %v\n"</span>, errors.Cause(err), errors.Cause(err))</span><br><span class="line">fmt.Printf(<span class="string">"stack trace: \n%+v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">orginal error: *fs.PathError open /Users/ruanhan/.settings.xml: no such file or directory</span><br><span class="line">stack trace: </span><br><span class="line">open /Users/ruanhan/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/ruanhan/<span class="number">2020</span>/<span class="keyword">go</span>/error/<span class="number">06.</span><span class="keyword">go</span>:<span class="number">14</span></span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/ruanhan/<span class="number">2020</span>/<span class="keyword">go</span>/error/<span class="number">06.</span><span class="keyword">go</span>:<span class="number">28</span></span><br><span class="line">main.main</span><br><span class="line">        /Users/ruanhan/<span class="number">2020</span>/<span class="keyword">go</span>/error/<span class="number">06.</span><span class="keyword">go</span>:<span class="number">34</span></span><br><span class="line">runtime.main</span><br><span class="line">        /usr/local/<span class="keyword">go</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">225</span></span><br><span class="line">runtime.goexit</span><br><span class="line">        /usr/local/<span class="keyword">go</span>/src/runtime/asm_amd64.s:<span class="number">1371</span></span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure><p><code>github.com/pkg/errors</code>pkg errors的心智负担</p><p><strong>在你的应用代码中，使用errors.New或者errors。Errorf返回错误</strong></p><p>注意下面的errors都是指的 <code>github.com/pkg/errors</code>这个包</p><ol><li>errors.New 和 errors.Errorf 都会将堆栈信息保存了；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseArgs</span><span class="params">(args []<span class="keyword">string</span>)</span><span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args)&lt;<span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"not enough arguments,expected at lease"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果调用其他包内的函数（项目中的其他函数，错误来自别人），通常简单的直接返回</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err  <span class="comment">// 如果不直接返回，会造成堆栈双倍信息； </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果和其他库(其他库就是github这种第三方库，或者是公司的基础库，或者是标准库)进行协作，考虑使用errors.Wrap 或者 errors.Wrapf保存堆栈信息。同样适用于和标准库协作的时候。（所以这也解释了第二种情况为何不warp而直接返回的原因，说白就是最底层的这个函数需要warp，底层这个函数一般都是跟数据库，rpc等，只有那个函数返回的需要warp）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"failed to open %q"</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>直接返回错误，而不是每个错误产生的地方到处到日志</p></li><li><p>在程序的顶部或者是工作的goroutine顶部（请求入口），使用%+v把堆栈详情记录</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  err := app.Run()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"FATAL: %+v\n"</span>,err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>使用errors.Cause获取root error，再进行和sentinel error判定；</li></ol><ul><li>总结<ul><li>选择wrap error是只有 application 可以选择应用的策略，具有最高可重用性的包只能返回根错误，此机制与Go标准库中使用的相同（kit库的sql.ErrNoRows）(基础库不应该去wrap error)</li><li>这是关于函数/方法调用返回每个错误的基本问题，如果函数/方法不打算处理错误，那么用足够的上下文wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句，确定您记录的上下文是足够多还是太多的一个好方法是检查日志并验证它们在开发期间是否为您工作</li><li>一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零（比如降级处理中，你返回了降级数据，然后需要return nil)</li></ul></li></ul><h3 id="20-4-Go-1-13-errors"><a href="#20-4-Go-1-13-errors" class="headerlink" title="20.4 Go 1.13 errors"></a>20.4 Go 1.13 errors</h3><h3 id="20-5-Go-2-Error-Inspection"><a href="#20-5-Go-2-Error-Inspection" class="headerlink" title="20.5 Go 2 Error Inspection"></a>20.5 Go 2 Error Inspection</h3><h3 id="20-6-References"><a href="#20-6-References" class="headerlink" title="20.6 References"></a>20.6 References</h3>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack5_1</title>
      <link href="2021/02/23/webpack5-1/"/>
      <url>2021/02/23/webpack5-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Webpack5-boilerplate"><a href="#Webpack5-boilerplate" class="headerlink" title="Webpack5 boilerplate"></a>Webpack5 boilerplate</h2><h3 id="1-Common"><a href="#1-Common" class="headerlink" title="1. Common"></a>1. Common</h3><h4 id="2-1-init"><a href="#2-1-init" class="headerlink" title="2.1 init"></a>2.1 init</h4><p><strong>install webpack5</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev --save-exact</span><br></pre></td></tr></table></figure><h4 id="2-2-添加changelog"><a href="#2-2-添加changelog" class="headerlink" title="2.2 添加changelog"></a>2.2 添加changelog</h4><h4 id="2-3-添加CI-CD"><a href="#2-3-添加CI-CD" class="headerlink" title="2.3 添加CI/CD"></a>2.3 添加CI/CD</h4><h4 id="2-4-项目结构设计"><a href="#2-4-项目结构设计" class="headerlink" title="2.4 项目结构设计"></a>2.4 项目结构设计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|- &#x2F;config     一些配置文件，比如webpack config等</span><br><span class="line">|- &#x2F;internals  一些内部脚本，生成模版文件， 执行cleanAndSetup操作等；</span><br><span class="line">|- &#x2F;scripts    必要的npm scripts</span><br><span class="line">|- package.json</span><br><span class="line">|- index.html</span><br><span class="line">|- &#x2F;src</span><br><span class="line">  |- index.ts</span><br></pre></td></tr></table></figure><h4 id="2-5-添加-prettier"><a href="#2-5-添加-prettier" class="headerlink" title="2.5 添加 prettier"></a>2.5 添加 prettier</h4><blockquote><p>格式化代码利器，配合vscode全局使用；</p></blockquote><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact prettier</span><br></pre></td></tr></table></figure><p><strong>init</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#123;&#125;&gt; .prettierrc.json</span><br><span class="line">touch .prettierignore</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .prettierignore </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore artifacts:</span></span><br><span class="line">build</span><br><span class="line">coverage</span><br></pre></td></tr></table></figure><h4 id="2-6-babel"><a href="#2-6-babel" class="headerlink" title="2.6 babel"></a>2.6 babel</h4><p><strong>babel简述</strong></p><p>babel是一个js编译器，主要是将es6+转换为向后兼容的js语法；这样就能运行在旧版本浏览器或者其他低版本的环境中；</p><ul><li><p>利用<code>@Babel/polyfill</code>可以通过Polyfill方式在目标环境中添加缺失的特性；</p></li><li><p>babel能够转换jsx语法；主要用到<code>@babel/preset-react</code>;</p></li><li><p>babel还可以删除类型注释，主要用到<code>@babel/preset-typescript</code>，但是无法做类型检查，类型检查需要Flow/Typescript这类的工具;</p></li><li><p>babel是构建在插件之上的，使用现有的插件可以组成一个转换管道；通过使用或创建一个<code>preset</code> 即可轻松使用一组插件；使用<code>generator-babel-plugin</code>生成一个插件模版；</p></li></ul><h5 id="2-6-1-概念"><a href="#2-6-1-概念" class="headerlink" title="2.6.1 概念"></a>2.6.1 概念</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact @babel/core @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure><h6 id="2-6-1-1-babel-core"><a href="#2-6-1-1-babel-core" class="headerlink" title="2.6.1.1 @babel/core"></a>2.6.1.1 @babel/core</h6><p>babel 核心功能包含在该模块中；</p><h6 id="2-6-1-2-babel-cli"><a href="#2-6-1-2-babel-cli" class="headerlink" title="2.6.1.2 @babel/cli"></a>2.6.1.2 @babel/cli</h6><p>@babel/cli 是一个能够从终端（命令行）使用的工具；</p><p><strong>babelrc</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"presets"</span>: [],</span><br><span class="line"><span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-6-1-3-plugins"><a href="#2-6-1-3-plugins" class="headerlink" title="2.6.1.3 plugins"></a>2.6.1.3 plugins</h6><blockquote><p>插件是小型的js程序，用于指导babel如何代码进行转换</p></blockquote><p>现在，babel虽然开箱即用，但是什么动作都不做。类似于<code>const babel = code =&gt; code</code>，将代码解析之后再输出同样的代码，如果想要babel做一些实际的工作，就需要为其添加插件；</p><p>例如<code>@babel/plugin-transform-arrow-functions</code>之类的插件能将es6的箭头函数转换成es5的function；但是代码中依然有其他es6属性，比如class。 我们希望对它们也进行转换，不需要一个接一个添加所需要的插件。可以使用一个<code>preset</code>（即一组预先设定的插件）</p><p>就像插件一样，可以根据自己所需要的插件组合创建一个 自己的<code>preset</code>并将其分享出去；</p><p><strong>插件参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加参数的时候,下面这几种是一致的；</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"pluginA"</span>, [<span class="string">"pluginA"</span>], [<span class="string">"pluginA"</span>,&#123;&#125;]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加参数，请传递一个以参数名作为（key）的对象</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"transform-async-to-module-method"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"module"</span>: <span class="string">"bluebird"</span>,</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"coroutine"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-6-1-4-preset-（-babel-env）"><a href="#2-6-1-4-preset-（-babel-env）" class="headerlink" title="2.6.1.4 preset （@babel/env）"></a>2.6.1.4 preset （@babel/env）</h6><blockquote><p>除了一个一个添加插件，还可以以 preset 的形式启用一组插件，对比plugin来说，preset就是为了让不想自动手动组合插件的开发者提供的，preset可以作为Babel插件的组合；</p></blockquote><p>可以简单把Babel Preset视为Babel Plugin的集合，比如babel-preset-es2015 就包含了所有跟es6转换有关的插件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/babel src --out-dir lib --presets=@babel/env</span><br></pre></td></tr></table></figure><p><strong>preset参数</strong></p><p>格式与plugin一致；</p><p><strong>官方Preset</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@babel/preset-env</span><br><span class="line">@babel/preset-flow</span><br><span class="line">@babel/preset-react</span><br><span class="line">@babel/preset-typescript</span><br></pre></td></tr></table></figure><h6 id="2-6-1-5-Plugin与Preset执行顺序"><a href="#2-6-1-5-Plugin与Preset执行顺序" class="headerlink" title="2.6.1.5 Plugin与Preset执行顺序"></a>2.6.1.5 Plugin与Preset执行顺序</h6><p>可以同时使用多个Plugin 和Preset，此时，它们执行顺序非常重要</p><ol><li>先执行完所有Plugin，再执行Preset</li><li>多个Plugin，按声明次序顺序执行</li><li>多个Preset，按照声明次序逆序执行</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [ </span><br><span class="line">    <span class="string">"transform-react-jsx"</span>,</span><br><span class="line">    <span class="string">"transform-async-to-generator"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"presets"</span>: [ </span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"es2016"</span>    </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行顺序</strong></p><p><code>transform-react-jsx，transform-async-to-generator，es2016，es2015</code></p><h6 id="2-6-1-6-babel-polyfill"><a href="#2-6-1-6-babel-polyfill" class="headerlink" title="2.6.1.6 babel-polyfill"></a>2.6.1.6 babel-polyfill</h6><p>babel默认只转换新的js句法（syntax），不转新的API，类似Proxy，Promise这些。举例来说，ES6在Array对象上新增了Array.from方法，babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill；</p><p>从babel7.4.0版本开始，这个软件包已经不推荐使用了，建议使用<code>core-js/stable</code> 和<code>regenerator-runtime/runtime</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/stable'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'regenerator-runtime/runtime'</span></span><br></pre></td></tr></table></figure><p><strong>useBuiltIns</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"edge"</span>: <span class="string">"17"</span>,</span><br><span class="line">          <span class="attr">"firefox"</span>: <span class="string">"60"</span>,</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span>,</span><br><span class="line">          <span class="attr">"safari"</span>: <span class="string">"11.1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span> <span class="comment">// 当此参数设置为 "usage" 时，就会加载上面所提到的最后一个优化措施，也就是只包含你所需要的 polyfill. </span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br><span class="line"><span class="comment">// 加了 "useBuiltIns": "usage" 之类转化为</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.promise.finally'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().finaly();</span><br></pre></td></tr></table></figure><p>Babel将检查你的所有代码，以便查找目标环境中缺失的功能，然后只把必须的polyfill包含进来；如果没加<code>useage</code>，那必须在所有代码之前通过require加载一次完成的polyfill</p><h6 id="2-6-1-7-小结"><a href="#2-6-1-7-小结" class="headerlink" title="2.6.1.7 小结"></a>2.6.1.7 小结</h6><p>使用<code>@babel-cli</code>从终端运行Babel；</p><p>利用 <code>@babel/polyfill</code>模拟所有新的js功能，比如Array.from, Promise等；</p><p>而<code>@babel-env</code>preset 只对目标环境（如浏览器）中缺失的功能进行代码转换和加载polyfill；</p><h5 id="2-6-2-配置"><a href="#2-6-2-配置" class="headerlink" title="2.6.2 配置"></a>2.6.2 配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;&#125;&gt;babel.config.json</span><br></pre></td></tr></table></figure><h6 id="2-6-2-1-typescript"><a href="#2-6-2-1-typescript" class="headerlink" title="2.6.2.1 typescript"></a>2.6.2.1 typescript</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact @babel/preset-typescript</span><br></pre></td></tr></table></figure><h6 id="2-6-2-2-react"><a href="#2-6-2-2-react" class="headerlink" title="2.6.2.2 react"></a>2.6.2.2 react</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact @babel/preset-react</span><br></pre></td></tr></table></figure><h4 id="2-7-引入typescript"><a href="#2-7-引入typescript" class="headerlink" title="2.7 引入typescript"></a>2.7 引入typescript</h4><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact typescript ts-loader</span><br></pre></td></tr></table></figure><p><strong>tsconfig.json</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;&#125; &gt;tsconfig.json</span><br></pre></td></tr></table></figure><h4 id="2-8-引入react"><a href="#2-8-引入react" class="headerlink" title="2.8 引入react"></a>2.8 引入react</h4><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react react-dom react-router react-router-dom redux react-saga reselect react-redux immer connected-react-router <span class="built_in">history</span> --save --save-exact</span><br></pre></td></tr></table></figure><p>记得加入@types</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/react @types/react-dom --save-dev --save-exact</span><br></pre></td></tr></table></figure><h4 id="2-9-载入css相关资源"><a href="#2-9-载入css相关资源" class="headerlink" title="2.9 载入css相关资源"></a>2.9 载入css相关资源</h4><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader css-loader less less-loader --save-dev --save-exact</span><br></pre></td></tr></table></figure><p><strong>安装PostCSS Preset Env</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact postcss-preset-env postcss postcss-loader</span><br></pre></td></tr></table></figure><p><strong>MiniCssExtractPlugin</strong></p><p>生产模式下运行时使用来提取CSS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact mini-css-extract-plugin</span><br></pre></td></tr></table></figure><h4 id="2-10-解析图片，字体之类的"><a href="#2-10-解析图片，字体之类的" class="headerlink" title="2.10 解析图片，字体之类的"></a>2.10 解析图片，字体之类的</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader --save-dev --save-exact</span><br></pre></td></tr></table></figure><h4 id="2-11-HtmlWebpackPlugin"><a href="#2-11-HtmlWebpackPlugin" class="headerlink" title="2.11 HtmlWebpackPlugin"></a>2.11 HtmlWebpackPlugin</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact html-webpack-plugin</span><br></pre></td></tr></table></figure><h3 id="2-Dev"><a href="#2-Dev" class="headerlink" title="2. Dev"></a>2. Dev</h3><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact webpack-hot-middleware express webpack-dev-middleware</span><br></pre></td></tr></table></figure><h3 id="3-Pro"><a href="#3-Pro" class="headerlink" title="3. Pro"></a>3. Pro</h3>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graphics1</title>
      <link href="2021/02/09/graphics1/"/>
      <url>2021/02/09/graphics1/</url>
      
        <content type="html"><![CDATA[<p>前置</p><h2 id="1-Course-Topis（mainly-4-parts）"><a href="#1-Course-Topis（mainly-4-parts）" class="headerlink" title="1. Course Topis（mainly 4 parts）"></a>1. Course Topis（mainly 4 parts）</h2><ul><li>Rasterization （光栅化）</li><li>Curves and Meshes</li><li>Ray Tracing （光线追踪）</li><li>Animation/Simulation （动画/模拟）</li></ul><h3 id="1-1-Rasterization"><a href="#1-1-Rasterization" class="headerlink" title="1.1 Rasterization"></a>1.1 Rasterization</h3><p>光栅化， 把三维空间的几何形体显示在屏幕上。这就是光栅化。</p><p>实时的计算机图形学的主要应用，在计算机图形学的范畴内，实时的定义我们认为是每秒钟生成30幅画面或者叫30帧，能达到这个级别就叫实时，否则叫离线；</p><h3 id="1-2-Curves-and-Meshes"><a href="#1-2-Curves-and-Meshes" class="headerlink" title="1.2 Curves and Meshes"></a>1.2 Curves and Meshes</h3><p>在图形学中，如何表示一条光滑的曲线。如何表示曲面。</p><h3 id="1-3-Ray-Tracing-（光线追踪）"><a href="#1-3-Ray-Tracing-（光线追踪）" class="headerlink" title="1.3 Ray Tracing （光线追踪）"></a>1.3 Ray Tracing （光线追踪）</h3><p>生成真实美观的画面；</p><p>trade off 取舍 </p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liner_Algebra</title>
      <link href="2021/02/08/liner-Algebra/"/>
      <url>2021/02/08/liner-Algebra/</url>
      
        <content type="html"><![CDATA[<p>一系列简短可刷的视频，将线性代数中的几何直觉动画化；</p><p>即使你能跟上视频的速度，你也需要留点时间给自己思考，学习往往发生在此刻；</p><h2 id="1-向量"><a href="#1-向量" class="headerlink" title="1. 向量"></a>1. 向量</h2><h3 id="1-1-含义"><a href="#1-1-含义" class="headerlink" title="1.1 含义"></a>1.1 含义</h3><p>线性代数中最基础、最根源的组成部分就是向量；</p><p>一般来说，有三种看待向量的观点，看似不同却有所关联；</p><h4 id="1-1-1-物理专业视角"><a href="#1-1-1-物理专业视角" class="headerlink" title="1.1.1 物理专业视角"></a>1.1.1 物理专业视角</h4><p>向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向；但是只要以上两个特征相同，你可以自由移动一个向量而保持它不变；</p><p><strong>二维向量</strong></p><p>处在平面中的巷里那个是二维的；</p><p><strong>三维向量</strong></p><p>而处在我们所生活的空间中的向量是三维的；</p><h4 id="1-1-2-计算机专业视角"><a href="#1-1-2-计算机专业视角" class="headerlink" title="1.1.2 计算机专业视角"></a>1.1.2 计算机专业视角</h4><p>从计算机专业学生的视角看，向量是有序的数字列表；比如你正在做一些有关房价的分析；而你只关心两个特征： ``房屋面积<code>和</code>价格`。</p><p>你可能会用一对数字对每个房屋进行建模；第一个数代表房屋面积，第二个数代表价格；</p><p>注意，这里的数字顺序不可颠倒；用行话来讲，你会用二维向量对房屋进行建模；在这里，“向量”只不过是“列表”的一个花哨的说法；之所以这个向量是二维的，是因为这个列表的长度是2；</p><h4 id="1-1-3-数学专业视角"><a href="#1-1-3-数学专业视角" class="headerlink" title="1.1.3 数学专业视角"></a>1.1.3 数学专业视角</h4><p>另一方面，数学家试图去概括这两种观点，大致地说，向量可以是任何东西。只要保证两个向量相加以及数字与向量相乘是有意义的即可；</p><p><strong>向量加法和向量数乘贯穿线性代数始终，二者起着很重要的作用</strong></p><p>一种思考“向量”的特定方式</p><p>现在关注的是它的几何方面，首先需要考虑一个箭头，考虑这个箭头在某个坐标系中，比如x-y平面。并且箭头起点位于原点；这与物理专业学生的看法略有不同。因为在他们眼中，向量可以在空间中自由落脚；但是在线性代数中，向量经常以原点作为起点；</p><p>一旦你理解了“向量是空间中的箭头”这种观点，就来看看“向量是有序的数字列表”这种观点；</p><p>在直角坐标系中，一个向量的坐标由一对数构成；（-2，3），这对数指导你如何从原点（向量起点）出发到达它的尖端（向量终点）</p><p>第一个数告诉你沿着X轴走多远，正数代表向右移动，负数代表向左移动；</p><p>第二个数告诉你沿着Y轴走多远；正数代表向上移动，负数代表向下移动；</p><p>为了把向量和点区别开，惯用方法是把这对数竖着写，然后用方括号括起来；每一对数给出唯一一个向量；</p><h3 id="1-2-向量的和"><a href="#1-2-向量的和" class="headerlink" title="1.2 向量的和"></a>1.2 向量的和</h3><p><img src="vector1.png" alt="image-20210208234410862"></p><p>平移第二个向量，使它的起点与第一个向量的终点重合。然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是它们的和；</p><p>顺便一提，这个向量加法的定义差不多是线性代数中唯一允许向量离开原点的情形；</p><h4 id="1-2-1-数学角度看向量加法"><a href="#1-2-1-数学角度看向量加法" class="headerlink" title="1.2.1 数学角度看向量加法"></a>1.2.1 数学角度看向量加法</h4><p><img src="vector2.png" alt="image-20210208235656431"></p><p><img src="vector3.png" alt="image-20210208235911892"></p><p>我们重新编排它们的吮吸，使得我们先完成所有水平运送，再完成所有竖直运动；</p><p><img src="vector4.png" alt="image-20210209000135241"></p><p>所以新向量的坐标就是 (1+3, 2+(-1)); 即<code>(x1+x2,y1+y2)</code>,总体来说，在“向量是有序的数字列表”观点里，向量加法就是把对应项相加；</p><h3 id="1-3-向量数乘"><a href="#1-3-向量数乘" class="headerlink" title="1.3 向量数乘"></a>1.3 向量数乘</h3><p>另一个向量基础运算就是向量数乘</p><h4 id="1-3-1-缩放"><a href="#1-3-1-缩放" class="headerlink" title="1.3.1 缩放"></a>1.3.1 缩放</h4><p>比如说你选择数字2，把它与一个给定向量相乘。意味着你把这个向量拉长为原向量的2倍。 如果将向量乘以1/3，就意味着这个向量长度缩短为原来的1/3.如果乘以-1.8，相当于往反方向拉长1.8倍；<code>2,1/3,-1.8,它们用于缩放向量，被称为“标量”</code>实际上自始至终，数字在线性代数中起到的主要作用就是缩放向量；所以，“标量”和“数字”两个词通常在这里可以相互替换；</p><p>这种拉伸或压缩，有时又使向量反向的过程被称为“缩放”；</p><h4 id="1-3-2-数学角度看向量数乘"><a href="#1-3-2-数学角度看向量数乘" class="headerlink" title="1.3.2 数学角度看向量数乘"></a>1.3.2 数学角度看向量数乘</h4><p>从数字的角度来看，将一个向量伸长为原来的2倍；对应于将每一个分量分别乘以2；</p><p><img src="vector5.png" alt="image-20210209002032279"></p><p>所以将向量看作一个数字列表时，向量与标量相乘就是将向量中的每个分量与标量相乘；</p><h3 id="1-4-向量点乘与叉乘"><a href="#1-4-向量点乘与叉乘" class="headerlink" title="1.4 向量点乘与叉乘"></a>1.4 向量点乘与叉乘</h3><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>线性代数围绕两种基本运算： 向量加法与向量乘法“究竟是什么意思了”；</p><p>为什么数学家只考虑这两种运算，并且又是如何将它们抽象独立出来，不管你选什么代表向量都与之无关；</p><p>实际上无论你怎么看待向量都无所谓，或把向量看作空间中的箭头；或者把向量看作数字列表；这种观点又恰好有漂亮的几何意义与之对应。线性代数的效用很少提现在这些观点的其中一个上，而是更多地体现在它能够在这些观点中相互转化；</p><p>线性代数为数据分析提供了一条将大量数据列表概念化、可视化的渠道；它让数据样式变得非常明晰，并让你大致了解特定运算的意义；</p><p>另一方面，线性代数给物理学家和计算机图形程序员提供了一种语言；让他们通过计算机能处理数字来描述并操纵空间；</p><h2 id="2-线性组合、张成的空间与基"><a href="#2-线性组合、张成的空间与基" class="headerlink" title="2. 线性组合、张成的空间与基"></a>2. 线性组合、张成的空间与基</h2><h3 id="2-1-基向量"><a href="#2-1-基向量" class="headerlink" title="2.1 基向量"></a>2.1 基向量</h3><p>关于向量坐标，还有一种有趣的方式来看待这些坐标，它对线性代数很重要。当你看到一对描述向量的数时，比如（3，-2），可以把它的每个坐标看作一个标量；</p><p><img src="vector6.png" alt="image-20210209101806130"></p><p><img src="vector7.png" alt="image-20210209102013500"></p><p>在xy坐标系中，有两个非常特别的向量。一个指向正右方，长度为1，通常被称为<code>i 帽</code>或者x方向的单位向量；另一个指向正上方，长度为1。通常被称为<code>j帽</code> 或者y方向的单位向量；</p><p><img src="vector8.png" alt="image-20210209102531618"></p><p>现在想象向量(3,-2)的x坐标是一个标量，它将<code>i帽</code>拉伸为原来的3倍；它将<code>j帽</code>拉伸为原来的2倍；从这个角度去看，这个向量实际上是两个经过缩放的向量的和；</p><p><img src="vector9.png" alt="image-20210209102757457"></p><p>“缩放向量并且相加” 这一概念至关重要，<code>i 与 j 是xy坐标系的“基向量”；它们合起来被称为坐标系的基；</code></p><p>这是在说，当你把坐标看作标量时；基向量实际上就是这些标量缩放的对象；</p><p><img src="vector10.png" alt="image-20210209103551566"></p><p><img src="vector11.png" alt="image-20210209103743636"></p><p>我们根据这两个特殊的基向量构建坐标系时，也浮现了一些有趣而微妙的问题，<code>如果我们选择不同的基向量会怎么样？</code>我们完全可以选择不同的基向量，获得一个合理的新坐标系；</p><p><img src="vector12.png" alt="image-20210209104537826"></p><p>比如说，随便选一个指向右上方的向量（红色），再随便选一个指向右下方的向量（蓝色）。想象一下，通过选择两个标量，分别用于缩放二者的其中一个；然后把它们相加，你能得到不同的结果；</p><p><img src="vector13.png" alt="image-20210209104634338"></p><p>通过改变所选择的标量，你可以得到哪些二维向量？</p><p>答案是，你可以得到所有的二维向量。为什么呢？</p><p>这样一对新的基向量，同样允许我们在一对数和二维向量之间自由转化；</p><p>但是这种变换关系与之前用i帽 和 j帽的变换关系完全不同；</p><p><img src="vector14.png" alt="image-20210209114258225"></p><p><img src="vector15.png" alt="image-20210209114403505"></p><p><code>每当我们用数字描述向量时，它都依赖于我们正在使用的基</code>两个数乘向量和被称为这两个向量的线性组合。</p><p><img src="vector16.png" alt="image-20210209115355067"></p><h3 id="2-2-向量张成的空间（span）"><a href="#2-2-向量张成的空间（span）" class="headerlink" title="2.2 向量张成的空间（span）"></a>2.2 向量张成的空间（span）</h3><p>“线性”这个词从哪儿来？这根直线又又什么关系？</p><p>如果固定其中一个标量，让另一个标量自由变化。所产生的向量的终点会描出一条直线；(下面两张图分别为固定向量W缩放V 和 固定V缩放W)</p><p><img src="vector17.png" alt="image-20210209115702292"></p><p><img src="vector18.png" alt="image-20210209115821892"></p><p>如果你让两个标量同时自由变化，考虑所有可能得到的向量；可能有两种情况；</p><p>大部分情况下，对于一对初始向量，你能到达平面中的每一个点；所有二维向量都尽在掌握；</p><p>但是也有糟糕的情况，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上；</p><p><img src="vector19.png" alt="image-20210209120416875"></p><p>实际上还有第三种情况： 两个向量都是零向量。那就只能乖乖呆在原点了；</p><p><img src="vector20.png" alt="image-20210209125225821"></p><p>所有可以表示为给定向量线性组合的向量的集合；被称为给定向量张成的空间（span）; 现在用行话重新叙述刚才的内容；对大部分二维向量对来说，它们张成的空间是所有二维向量的集合。</p><p>但当共线的时，它们张成的空间就是终点落在一条直线上的向量的集合；</p><p><strong>线性代数紧紧围绕向量加法与数乘</strong></p><p>两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么？</p><p>现在是时候讨论一下通常我们是如何将向量看作点的；</p><p>想象落在一条直接上的一些向量时，你会觉得拥挤。而同时想象所有二维向量填满平面时，你会觉得非常拥挤；</p><p><img src="vector21.png" alt="image-20210209142438907"></p><p>所以为了对抗这种情况，通常我们就用向量的终点代表改向量。而像以往一样，它的起点仍旧位于原点；用这种方法来看，如果你要考虑落在一条直线上的所有向量时，你需要考虑直线本身就行了；类似地，同时考虑所有二维向量时，将每个向量抽象为它的终点；实际上，你就不必考虑所有的箭头了，只需要考虑无限大的二维平面本身即可；</p><p>当你只考虑一个向量时，就把它看作箭头。当你考虑多个向量时，就把它们都看作点；前面有提到对大部分二维向量来说，它们张成的空间是整个无限大的二维平面；如果共线，它们张成的空间就是一条直线；</p><h4 id="2-2-1-两个三维向量张成的空间是什么样的？"><a href="#2-2-1-两个三维向量张成的空间是什么样的？" class="headerlink" title="2.2.1  两个三维向量张成的空间是什么样的？"></a>2.2.1  两个三维向量张成的空间是什么样的？</h4><p>如果我们再去考虑三维空间，张成空间这个概念就开始变得有趣了。这两个向量张成的空间就是它们所有可能的线性组合。</p><p><img src="vector22.png" alt="image-20210209144441848"></p><p>这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量张成的空间；或者说，所有终点落在这个平面上的向量的集合是这两个向量张成的空间；</p><p>如果再加上第三个向量，那么它们张成的空间又是什么样的呢？</p><p>会有两种情况，如果第三个向量恰好落在前两个向量所张成的平面上。那么它们张成的空间并不会改变，还是被困在这个平面上；</p><p>另外一种情况，如果你随机选一个向量，它几乎不可能落在前面两个向量所张成的平面中。这种情况下，由于第三个向量指向不同的方向。当你缩放第三个向量时，它将前两个向量张成的平面沿它的方向来回移动，从而扫过整个空间；</p><h3 id="2-3-线性无关与线性相关"><a href="#2-3-线性无关与线性相关" class="headerlink" title="2.3 线性无关与线性相关"></a>2.3 线性无关与线性相关</h3><p>当有多个向量，并且可以移除其中一个而不减少张成的空间。当这种情况发生时，我们称它们是“线性相关”的；另一种表述方法是其中一个向量，可以表示为其它向量的线性组合，因为这个向量已经落在其它向量张成的空间之中；</p><p>另一方面，如果所有向量都给张成的空间增添了新的维度；它们就被称为是“线性无关”的。</p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p><strong>“向量空间的一组基是张成该空间的一个线性无关的向量集；”</strong></p><p>空间的一组基的严格定义是这样的： 张成该空间的一个线性无关向量的集合，基于目前对“张成” 和 “线性无关” 这两个词的理解。思考一下为什么这个定义合乎情理；</p><h2 id="3-矩阵与线性变换"><a href="#3-矩阵与线性变换" class="headerlink" title="3. 矩阵与线性变换"></a>3. 矩阵与线性变换</h2><h3 id="3-1-线性变换"><a href="#3-1-线性变换" class="headerlink" title="3.1 线性变换"></a>3.1 线性变换</h3><blockquote><p>很遗憾， Matrix（矩阵）是什么是说不清的，你必须得自己亲眼看看；</p></blockquote><p>“如果要我选出一个主题，它不仅让线性代数的其它内容一目了然，又经常被初次学习线性代数的人忽视，我会选择这个——线性变换的概念以及它和矩阵的关系”</p><p>在这期视频中，只会集中讨论这些变换在二维空间中长什么样。以及它们如何与矩阵向量乘法关联。尤其展示一种不用死记硬背的考虑矩阵向量乘法的方法；</p><p><img src="matrix1.png" alt="image-20210209154527578"></p><p>首先，先来解析“线性变换”这个术语。“变换”本质上是“函数”的一种花哨的说法，它接收输入内容，并输出对应结果；</p><p><img src="matrix2.png" alt="image-20210209154800497"></p><p><img src="matrix3.png" alt="image-20210209154826105"></p><p>特别地，在线性代数的情况下。我么考虑的是接收一个向量并且输出一个向量的变换；</p><p>特别的，在线性代数的情况下。我们考虑的是接收一个向量并且输出一个向量的变换；</p><p><img src="matrix4.png" alt="image-20210209155750711"></p><p><img src="matrix5.png" alt="image-20210209155826060"></p><p>既然“变换”和“函数”意义相同，为什么还要使用前者而不是后者？因为使用“变换”是在暗示以特定方式来可视化这一输入-输出关系； 一种理解“向量的函数”的方法是使用运动。</p><p><img src="matrix6.png" alt="image-20210209160637527"></p><p>如果一个变换接收一个向量并输出一个向量；我们想象这个输入向量移动到输出向量的位置；</p><p>接下来，要理解整个变换。我们可以想象每一个输入向量都移动到对应输出向量的位置；同样多个箭头显得很拥挤，只用终点表示该向量，用这种方法考虑所有输入向量都移动到对应输出向量的位置时。我们只用看空间中的所有点移动到其它点的位置；</p><p><img src="matrix7.png" alt="image-20210209160814616"></p><p>各种个样对空间的变换所产生的效果是美妙的，任意一个变换可以非常复杂。幸运的是，<code>线性代数限制在一种特殊类型的变换上；这种变换更容易理解，称为线性变换</code></p><p><img src="transform1.png" alt="image-20210209161355416"></p><p>直观地说，如果一个变换具有以下两条性质，我们就称它是线性的；</p><p>一是直线在变换后仍然保持为直线，不能有所弯曲；</p><p>二是原点必须保持固定；</p><p>举例： 上图变换保持原点不动，乍一看它好像保持直线平直；但实际并非如此，因为只展示了水平和竖直的网格线；</p><p>当你看看它对一条对角线的作用时，很明显它不是一个线性变换；</p><p><img src="transform2.png" alt="image-20210209162235888"></p><p>总体来说，你应该把线性变换看作是“保持网格线平行且等距分布”的变换；</p><h4 id="3-1-1-如何用数值描述线性变换"><a href="#3-1-1-如何用数值描述线性变换" class="headerlink" title="3.1.1 如何用数值描述线性变换"></a>3.1.1 如何用数值描述线性变换</h4><p><img src="transform3.png" alt="image-20210209162450690"></p><p>当你在通过编程制作动画和视频来教授这一主题，你应该给计算机什么样的计算公式；使得你给它一个向量的坐标，它能给你变换后向量的坐标呢？</p><p>实际结果是，你只需要记录两个基向量i帽和j帽变换后的位置；</p><p><img src="transform5.png" alt="image-20210209163505605"></p><p>比如说，考虑坐标为（-1，2）的向量V。 这个向量就是 -1 与 i帽之积与2与j帽之积的和；</p><p>如果运用一些变换，并且跟随这三个向量的运动。网格线保持平行且等距分布的性质有一个重要的推论；</p><p><img src="transform6.png" alt="image-20210209165040650"></p><p>变换后的向量V的位置，是-1与变换后的i帽之积，加上2与变换后的j帽之积；</p><p>换句话说，向量V是i帽和j帽的一个特定线性组合，那么变换后的向量V也是变换后i帽和j帽的同样的线性组合；这意味着，你可以只根据变换后的i帽和j帽，就推断出变换后的V；</p><p>如上图所示的变换，可以看出i帽落在坐标（1，-2）上。j帽落在x轴上，坐标为（3，0）；也就是说，-1乘以i帽加上2乘以j帽所代表的向量；会落在-1 乘以向量（1，-2）加上2乘以向量（3，0）的位置上；简单运算之后，你就能推断出向量V一定落在向量（5，2）上；</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformed V = <span class="number">-1</span>(Transformed i) + <span class="number">2</span>(Transformed j)</span><br></pre></td></tr></table></figure><p><img src="transform7.png" alt="image-20210209165909608"></p><p>实际上，因为展示出整个变换的样子。完全可以直接读出向量V在变换后落在坐标（5，2）上；但是更炫酷的是，只要记录了变换后的i帽和j帽。我们就可以推断出任意向量在变换之后的位置；完全必须观察变换本身是什么样。</p><p>一般情况下，一个向量的坐标是（x，y），变换后这个向量就是x乘以变换后的i帽（1，-2）；加上y乘以变换后的j帽（3，0）。简单运算之后你就知道它落在坐标（1x+3y, -2x+0y）上。运用这个公式，我给你任意一个向量，你都能告诉它在变换后的位置；</p><p><img src="transform8.png" alt="image-20210209173033678"></p><p>以上这些内容是在说，一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标。通常我们将这些坐标包装在一个<code>2*2</code>的格子中，称它为<code>2*2</code>矩阵；</p><p><img src="transform9.png" alt="image-20210209175112110"></p><p>你可以把它的列理解为两个特殊的向量，即变换后的i帽和j帽。如果你有一个描述线性变换的2*2矩阵，以及一个给定向量；你想了解线性变换对这个向量的作用；你只需要取出向量的坐标；将它们分别与矩阵的特定列相乘，然后将结果相加即可；这与“缩放基向量再相加”的思想一致</p><p><img src="transfrom10.png" alt="image-20210209175818004"></p><h2 id="4-矩阵乘法与线性变换复合"><a href="#4-矩阵乘法与线性变换复合" class="headerlink" title="4. 矩阵乘法与线性变换复合"></a>4. 矩阵乘法与线性变换复合</h2><h2 id="5-三维空间中的线性变换"><a href="#5-三维空间中的线性变换" class="headerlink" title="5. 三维空间中的线性变换"></a>5. 三维空间中的线性变换</h2><h2 id="6-行列式"><a href="#6-行列式" class="headerlink" title="6. 行列式"></a>6. 行列式</h2><h2 id="7-逆矩阵、列空间与零空间"><a href="#7-逆矩阵、列空间与零空间" class="headerlink" title="7. 逆矩阵、列空间与零空间"></a>7. 逆矩阵、列空间与零空间</h2><h2 id="8-非方阵"><a href="#8-非方阵" class="headerlink" title="8. 非方阵"></a>8. 非方阵</h2><h2 id="9-点积与对偶性"><a href="#9-点积与对偶性" class="headerlink" title="9. 点积与对偶性"></a>9. 点积与对偶性</h2><h2 id="10-叉积的标准介绍"><a href="#10-叉积的标准介绍" class="headerlink" title="10. 叉积的标准介绍"></a>10. 叉积的标准介绍</h2><h2 id="11-以线性变换的眼光看叉积"><a href="#11-以线性变换的眼光看叉积" class="headerlink" title="11. 以线性变换的眼光看叉积"></a>11. 以线性变换的眼光看叉积</h2><h2 id="12-基变换"><a href="#12-基变换" class="headerlink" title="12. 基变换"></a>12. 基变换</h2><h2 id="13-特征向量与特征值"><a href="#13-特征向量与特征值" class="headerlink" title="13. 特征向量与特征值"></a>13. 特征向量与特征值</h2><h2 id="14-抽象向量空间"><a href="#14-抽象向量空间" class="headerlink" title="14. 抽象向量空间"></a>14. 抽象向量空间</h2><h2 id="15-克莱姆法则，几何解释"><a href="#15-克莱姆法则，几何解释" class="headerlink" title="15. 克莱姆法则，几何解释"></a>15. 克莱姆法则，几何解释</h2>]]></content>
      
      
      <categories>
          
          <category> algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cli</title>
      <link href="2021/02/07/cli/"/>
      <url>2021/02/07/cli/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Quick-start"><a href="#1-Quick-start" class="headerlink" title="1. Quick start"></a>1. Quick start</h2><h3 id="1-1-创建文件夹"><a href="#1-1-创建文件夹" class="headerlink" title="1.1  创建文件夹"></a>1.1  创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mkdir sunmao &amp;&amp; <span class="built_in">cd</span> sunmao &amp;&amp; npm init -y</span><br><span class="line">$&gt; touch sm.js</span><br></pre></td></tr></table></figure><h3 id="1-2-设置package-json"><a href="#1-2-设置package-json" class="headerlink" title="1.2 设置package.json"></a>1.2 设置package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"sunmao"</span>,</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"sunmao"</span>: <span class="string">"sm.js"</span> <span class="comment">// 添加 bin 配置，sumao 命令即 指向 sm.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"A Iterating scaffolding for react, redux-saga and Typescript"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"main.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"git+https://github.com/TenonMortise/sunmao"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"ruanhan"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"bugs"</span>: &#123;</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/TenonMortise/sunmao/issues"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://github.com/TenonMortise/sunmao#readme"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-npm-link"><a href="#1-3-npm-link" class="headerlink" title="1.3 npm link"></a>1.3 npm link</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sm.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello, sunmao'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&gt; chmod 755 sm.js</span><br><span class="line">$&gt; sudo npm link</span><br><span class="line"></span><br><span class="line">up to date <span class="keyword">in</span> 10.078s</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/sunmao -&gt; /usr/<span class="built_in">local</span>/lib/node_modules/sunmao/sm.js</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/node_modules/sunmao -&gt; /Users/ruanhan/sunmao</span><br><span class="line"></span><br><span class="line">$&gt; sunmao</span><br><span class="line">$&gt; hello, sunmao</span><br></pre></td></tr></table></figure><p>参考文档：</p><p><a href="https://javascript.ruanyifeng.com/nodejs/npm.html#toc0" target="_blank" rel="noopener">npm link</a></p><h3 id="1-4-npm-unlink"><a href="#1-4-npm-unlink" class="headerlink" title="1.4 npm unlink"></a>1.4 npm unlink</h3><p>如果你的项目不再需要该模块，可以在项目目录内使用<code>npm unlink</code>命令，删除符号链接。</p><h2 id="2-第三方工具介绍"><a href="#2-第三方工具介绍" class="headerlink" title="2. 第三方工具介绍"></a>2. 第三方工具介绍</h2><h3 id="2-1-commander-js"><a href="#2-1-commander-js" class="headerlink" title="2.1 commander.js"></a>2.1 commander.js</h3><p>可以自动的解析命令和参数，用于处理用户输入的命令。</p><h3 id="2-2-download-git-repo"><a href="#2-2-download-git-repo" class="headerlink" title="2.2 download-git-repo,"></a>2.2 download-git-repo,</h3><p>下载并提取 git 仓库，用于下载项目模板。</p><h3 id="2-3-inrequire-js"><a href="#2-3-inrequire-js" class="headerlink" title="2.3 inrequire.js"></a>2.3 inrequire.js</h3><p>通用的命令行用户界面集合，用于和用户进行交互。</p><h3 id="2-4-ora"><a href="#2-4-ora" class="headerlink" title="2.4 ora"></a>2.4 ora</h3><p>下载过程久的话，可以用于显示下载中的动画效果。</p><h3 id="2-5-chalk"><a href="#2-5-chalk" class="headerlink" title="2.5 chalk"></a>2.5 chalk</h3><p>可以给终端的字体加上颜色。</p><h3 id="2-6-log-symbols"><a href="#2-6-log-symbols" class="headerlink" title="2.6 log-symbols"></a>2.6 log-symbols</h3><p>可以在终端上显示出 √ 或 × 等的图标。</p><h3 id="2-7-install"><a href="#2-7-install" class="headerlink" title="2.7 install"></a>2.7 install</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commander download-git-repo inquirer ora chalk log-symbols</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp</title>
      <link href="2021/02/02/dp/"/>
      <url>2021/02/02/dp/</url>
      
        <content type="html"><![CDATA[<h2 id="1-动态规划题目特点"><a href="#1-动态规划题目特点" class="headerlink" title="1 动态规划题目特点"></a>1 动态规划题目特点</h2><ol><li>计数类</li></ol><ul><li>有多少种方式走到右下角</li><li>有多少种方法选出K个数使得和是sum</li></ul><ol start="2"><li>求最大最小值（DP最大的一类）</li></ol><ul><li>从左上角走到右下角路径的最大数字和</li><li>最长上升子序列长度</li></ul><ol start="3"><li>求存在性</li></ol><ul><li>取石子游戏，先手是否必胜</li><li>能不能选出K个数使得和是sum</li></ul><h2 id="2-dp解题步骤"><a href="#2-dp解题步骤" class="headerlink" title="2 dp解题步骤"></a>2 dp解题步骤</h2><p>以 Coin Change 为例；</p><p><strong>三种硬币，分别面值2元，5元和7元， 没种硬不都有足够多，去书店买本书需要27元。如何用最少的硬币组合正好付清，不需要对方找钱</strong></p><p><code>分析： 这题出现求最少，显然可以使用DP方法来解决</code></p><h3 id="2-1-动态规划组成部分一：-确定状态"><a href="#2-1-动态规划组成部分一：-确定状态" class="headerlink" title="2.1 动态规划组成部分一： 确定状态"></a>2.1 动态规划组成部分一： 确定状态</h3><h4 id="2-1-1-状态在动态规划中的作用属于定海神针"><a href="#2-1-1-状态在动态规划中的作用属于定海神针" class="headerlink" title="2.1.1  状态在动态规划中的作用属于定海神针"></a>2.1.1  状态在动态规划中的作用属于定海神针</h4><h4 id="2-1-2-简单来说，解动态规划的时候需要开一个数组，数组的每个元素f-i-或者-f-i-j-代表什么；-类似于解数学题中，X，-Y，Z代表什么；"><a href="#2-1-2-简单来说，解动态规划的时候需要开一个数组，数组的每个元素f-i-或者-f-i-j-代表什么；-类似于解数学题中，X，-Y，Z代表什么；" class="headerlink" title="2.1.2  简单来说，解动态规划的时候需要开一个数组，数组的每个元素f[i] 或者 f[i][j]代表什么； 类似于解数学题中，X， Y，Z代表什么；"></a>2.1.2  简单来说，解动态规划的时候需要开一个数组，数组的每个元素<code>f[i]</code> 或者 <code>f[i][j]</code>代表什么； 类似于解数学题中，X， Y，Z代表什么；</h4><h4 id="2-1-3-确定状态需要两个意识："><a href="#2-1-3-确定状态需要两个意识：" class="headerlink" title="2.1.3  确定状态需要两个意识："></a>2.1.3  确定状态需要两个意识：</h4><h5 id="2-1-3-1-最后一步"><a href="#2-1-3-1-最后一步" class="headerlink" title="2.1.3.1 最后一步"></a>2.1.3.1 最后一步</h5><p>  虽然我们不知道最优策略是什么，但是最优策略肯定是K梅硬币a1,a2,…,ak 面值加起来是27；</p><p>最后一步指的就是最优策略中的最后一个决策，对应到这一题就是一定会有一枚最后的硬币决策： ak， 那么除了这枚硬币，前面硬币的面值加起来是27-ak；</p><p><img src="01.png" alt="image-20210202160842790"></p><p><strong>关键点1：</strong></p><p>我们不关心前面的 <code>k-1</code> 枚硬币是怎么拼出<code>27-ak</code>的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道<code>ak</code> 和<code>k</code>， 但是我们确定前面的硬币拼出了 <code>27-ak</code>；</p><p><strong>关键点2:</strong></p><p>因为是最优策略，所以拼出<code>27-ak</code>的硬币数一定要最少，否则这就不是最优策略了；</p><p>解析关键点2： 比如最优策略要用5枚硬币，假设最后一枚是5元面额，那么4枚硬币组成了22元。你不可能用3枚，2枚甚至1枚拼成22元； 浅显的道理，如果用3枚可以拼出来22元的话，那么最优策略要用5枚的假设就不成立；</p><h5 id="2-1-3-2-子问题"><a href="#2-1-3-2-子问题" class="headerlink" title="2.1.3.2 子问题"></a>2.1.3.2 子问题</h5><p>我现在当然想求K，但是想求K的话，需要知道前面k-1等于几。（即最少需要多少枚硬币可以拼出27-ak）</p><p>所以，我们的要求就变成了：最少要用多少枚硬币可以拼出27-ak枚硬币；</p><p>原问题是最少用多少枚硬币拼出27；</p><p>我们将原问题转化成了一个子问题，而且规模更小： <code>27-ak</code></p><p>那该如何定义状态呢，一旦子问题出来了，状态就直接把相同的汉字copy下来。即<code>最少用多少枚硬币拼出X</code></p><p>为了简化定义，我们设状态 <code>f(x)=最少用多少枚硬币拼出x</code>结合这一题就是<code>f(x)=最少用多少枚硬币拼出27</code>.整个问题就变成，以前求<code>f(27)</code>,现在求<code>f(27-ak)</code>;</p><p><img src="01.png" alt="ziwenti"></p><p>等等，我们还不知道最后那枚硬币ak是多少， 当然最后那枚硬币ak只可能是2，5或者7</p><p>如果ak是2的话，f(27)应该是f(27-2)+1（加上最后这一枚硬币2）</p><p>如果ak是5的话，f(27)应该是f(27-5)+1（加上最后这一枚硬币5）</p><p>如果ak是7的话，f(27)应该是f(27-7)+1（加上最后这一枚硬币7）</p><p>除此之外，没有其他的可能了；</p><p>因为我们需求最少的硬币数，所以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">27</span>) = min&#123;f(<span class="number">27</span><span class="number">-2</span>)+<span class="number">1</span>, f(<span class="number">27</span><span class="number">-5</span>)+<span class="number">1</span>, f(<span class="number">27</span><span class="number">-7</span>)+<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="02.png" alt="image-20210202225916604"></p><h4 id="2-1-4-递归解法的问题"><a href="#2-1-4-递归解法的问题" class="headerlink" title="2.1.4 递归解法的问题"></a>2.1.4 递归解法的问题</h4><p>递归做了很多重复计算，效率低下</p><p>如何避免？</p><p>DP是将计算结果保存下来，并改变计算顺序；</p><h3 id="2-2-动态规划组成部分二：-转移方程"><a href="#2-2-动态规划组成部分二：-转移方程" class="headerlink" title="2.2 动态规划组成部分二： 转移方程"></a>2.2 动态规划组成部分二： 转移方程</h3><p>设状态f[x] = 最少用多少枚硬币拼出X；</p><p>对于任意X</p><p><img src="03.png" alt="image-20210202231607434"></p><h4 id="2-2-1-f-x-与-f-x-的区别"><a href="#2-2-1-f-x-与-f-x-的区别" class="headerlink" title="2.2.1 f[x] 与 f(x)的区别"></a>2.2.1 f[x] 与 f(x)的区别</h4><p>f[x] ，[] 代表数组下标</p><p>f(x)  ，（）代表函数调用</p><h3 id="2-3-动态规划组成部分三：-初始条件和边界条件"><a href="#2-3-动态规划组成部分三：-初始条件和边界条件" class="headerlink" title="2.3 动态规划组成部分三： 初始条件和边界条件"></a>2.3 动态规划组成部分三： 初始条件和边界条件</h3><p><code>f[x]=min{f[x-2]+1, f[x-5]+1, f[x-7]+1}</code></p><p><strong>两个问题</strong></p><p>x-2, x-5或者x-7 小于0怎么办？什么时候停下来？</p><p>如果不能拼出Y，就定义f[Y] = 正无穷，例如 f[-1] = f[-2] = … = 正无穷</p><p>所以f[1] = min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1；</p><p>初始条件： f[0] = 0; 因为初始条件用转移方程是算不出来的。但我又需要它的定义。</p><p>根据 f[0] = min{f[-2]+1, f[-5]+1, f[-7]+1} 算，f[0]是正无穷的。而我们明明知道，f[0] 不等于正无穷，而是等于0，所以需要手动制定。有的时候初始条件不需要给很多个，比如f[0], f[1], f[2] 等等是不需要额外多个去定义，定不定义该值取决于能否根据其他预设的值;比如f[1] 是正无穷，f[2] = {f[0]+1, f[-3]+1, f[-5]+1} 是 1， 然后后面的值都能基于此算出来了；</p><p>初始条件的实质就是把那些最小的值定义下来，边界情况的实质就是不要数组越界；不管数组往下越界到负数，还是数组往上越界超过了都不行；</p><h3 id="2-4-动态规划组成部分四：计算顺序"><a href="#2-4-动态规划组成部分四：计算顺序" class="headerlink" title="2.4 动态规划组成部分四：计算顺序"></a>2.4 动态规划组成部分四：计算顺序</h3><p>拼出X所需要的最少硬币数： f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}</p><p>初始条件： f[0] = 0</p><p>然后计算 f[1], f[2],… , f[27] （对于此题来说，是从小到大来计算，DP大多数情况下都是从小到大，二维的话就是从上到下，从左到右）</p><p>计算顺序只有一个原则，那就是当我们计算到f[X]时，f[X-2], f[X-5], f[X-7] 都已经出结果了；</p><h3 id="2-5-动态规划计算步骤"><a href="#2-5-动态规划计算步骤" class="headerlink" title="2.5 动态规划计算步骤"></a>2.5 动态规划计算步骤</h3><p>f[X] = 最少用多少枚硬币拼出X</p><p>f[X] = 正无穷 表示无法用硬币拼出X</p><p><img src="04.png" alt="image-20210203112234974"></p><p>每一步尝试三种硬币，一共27步；</p><p>与递归算法相比，没有任何重复计算；</p><p>算法时间复杂度（即需要进行的步数）： <code>27*3  (总面额*多少种硬币)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>A  [2, 5, 7]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>M  27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coinChange</span>(<span class="params">A, M</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 0 ... n: [n+1]</span></span><br><span class="line">  <span class="comment">// 0 ... n-1: [n]</span></span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Array</span>(M + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// number of kind of coins</span></span><br><span class="line">  <span class="keyword">let</span> n = A.length;</span><br><span class="line">  <span class="comment">// initialization</span></span><br><span class="line"></span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i, j;</span><br><span class="line">  <span class="comment">//最少用多少枚硬币 依次拼出  f[1], f[2], ... f[27]，从小到大的顺序</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">    <span class="comment">// 初始设置为无穷大</span></span><br><span class="line">    f[i] = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">    <span class="comment">// last coin A[j] 要拼出i块钱，最后一枚硬币应该是谁（这枚硬币不应该跳出A的范围）</span></span><br><span class="line">    <span class="comment">// f[i] = min&#123;f[i-A[0]] + 1,..., f[i-A[n-1]]+1&#125;;</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= A[j] &amp;&amp; f[i - A[j]] != <span class="built_in">Number</span>.MAX_VALUE) &#123;</span><br><span class="line">        <span class="comment">// i - A[j] 可能是负数，所以需要添加判断</span></span><br><span class="line">        <span class="comment">// 无穷大不能+1，会越界。所以需要添加校验；</span></span><br><span class="line">        f[i] = <span class="built_in">Math</span>.min(f[i - A[j]] + <span class="number">1</span>, f[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[M] == <span class="built_in">Number</span>.MAX_VALUE) &#123;</span><br><span class="line">    <span class="comment">// 如果拼不出来，要求返回-1；</span></span><br><span class="line">    f[M] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[M];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(coinChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">27</span>));</span><br></pre></td></tr></table></figure><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p>求最值型动态规划</p><p>动态规划组成部分：</p><ol><li>确定状态<ul><li>最后一步 (最优策略中使用的最后一枚硬币ak)</li><li>化成子问题 （最少的硬币拼出更小的面值27-ak）</li></ul></li><li>转移方程<ul><li>f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}</li></ul></li><li>初始条件和边界条件<ul><li>f[0] = 0, 如果不能拼出Y，f[Y]= 正无穷</li></ul></li><li>计算顺序<ul><li>f[0], f[1], f[2], …</li></ul></li></ol><p>消除冗余，加速计算；</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webgl01</title>
      <link href="2021/01/28/webgl01/"/>
      <url>2021/01/28/webgl01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图形系统绘图原理"><a href="#1-图形系统绘图原理" class="headerlink" title="1. 图形系统绘图原理"></a>1. 图形系统绘图原理</h2><p>webgl绘图，要深入细节里，根内存、cpu交互，真正控制图形输出的每一个细节；</p><p>webgl基础概念，GPU， 渲染管线，着色器；</p><h3 id="1-1-计算机图形系统"><a href="#1-1-计算机图形系统" class="headerlink" title="1.1 计算机图形系统"></a>1.1 计算机图形系统</h3><p>一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。</p><ul><li><p>光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</p></li><li><p>像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</p></li><li><p>帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</p></li><li><p>CPU（Central Processing Unit）：中央处理单元，负责逻辑计算。</p></li><li><p>GPU（Graphics Processing Unit）：图形处理单元，负责图形计算。</p></li></ul><h4 id="1-1-1-绘图通用过程"><a href="#1-1-1-绘图通用过程" class="headerlink" title="1.1.1 绘图通用过程"></a>1.1.1 绘图通用过程</h4><p>首先，经过CPU处理，成为具有特定结构的几何信息，然后，这些信息会被送到GPU中进行处理。在GPU中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上；</p><p>这个过程主要分为两个步骤，</p><p>一是对 给定的数据结合绘图的场景进行计算（例如相机，光源，遮挡物体等等）进行计算，最终将图形变为屏幕空间的2D坐标。</p><p>二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上，这整个过程是一步一步进行的，前一步的输出就是最后一步的输入，这个过程叫做渲染管线（RenderPipelines）</p><h4 id="1-1-2-GPU"><a href="#1-1-2-GPU" class="headerlink" title="1.1.2 GPU"></a>1.1.2 GPU</h4><p>CPU 和 GPU 都属于处理单元，但是结构不同。</p><p>CPU像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物，一条CPU流水线串行处理这些任务的速度，取决于CPU（管道）的处理能力；一个计算机系统会有很多条CPU流水线，任何一个任务 都可以随机通过任意一个流水线，这样计算机就能够并行处理多个任务了，这样一条流水线对应的就是 thread；</p><p>CPU处理大型任务是足够的，但是处理图像应用就不合适了。处理图像，实际上是处理计算图片上每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成一个简单的任务，而每一个图片应用又是由无数个个像素点组成的，所以，需要在同一时间处理无数个小任务。要处理这么多的小任务，使用更小，更多的处理单元，是一种更好的处理方式，GPU就是这样的处理单元；</p><p>GPU由大量的小型处理单元构成，它没有CPU那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张800*600大小的图片，GPU也可以保证这48万个像素点分别对应一个小单元，这样就可以同时对每个像素点进行计算了；</p><h2 id="2-helloWorld"><a href="#2-helloWorld" class="headerlink" title="2 .helloWorld"></a>2 .helloWorld</h2><p>浏览器提供的webgl API是 OpenGL ES的js绑定版本，它赋予了开发者操作GPU的能力。这一特点也让webGL的绘图方式略微复杂，无法直接调用API控制画笔。大致需要以下几个步骤</p><h3 id="2-1-webGL绘图步骤"><a href="#2-1-webGL绘图步骤" class="headerlink" title="2.1 webGL绘图步骤"></a>2.1 webGL绘图步骤</h3><ol><li>创建webgl上下文</li><li>创建webgl程序</li><li>将数据存入缓冲区</li><li>将缓冲区数据读取到GPU</li><li>GPU执行webgl程序，输出结果</li></ol><h3 id="2-1-1-创建webgl上下文"><a href="#2-1-1-创建webgl上下文" class="headerlink" title="2.1.1 创建webgl上下文"></a>2.1.1 创建webgl上下文</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gl = canvas.getContext(<span class="string">'webgl'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-2-创建webgl程序"><a href="#2-2-2-创建webgl程序" class="headerlink" title="2.2.2 创建webgl程序"></a>2.2.2 创建webgl程序</h3><p>webgl程序是一个webGL Program对象，它是给GPU 最终运行着色器的程序；</p><p>首先编写两个着色器；两个着色器分别对应的是 顶点 和图元， webgl是以顶点和图元来描述图形几何信息的；所以顶点和图元是绘图过程中必不可少的。webgl绘制一个图形的过程，一般需要两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，一段叫片元着色器（Fragment Shader）负责处理图形的像素信息；</p><h4 id="2-2-2-1-顶点"><a href="#2-2-2-1-顶点" class="headerlink" title="2.2.2.1 顶点"></a>2.2.2.1 顶点</h4><p>顶点就是几何图形的顶点，三角形有三个顶点，四边形有四个顶点。</p><h4 id="2-2-2-2-图元"><a href="#2-2-2-2-图元" class="headerlink" title="2.2.2.2 图元"></a>2.2.2.2 图元</h4><p>图元是webgl可直接处理的图形单元，由webgl绘图模式决定，有点、线、三角形等；webgl中最小的图元是三角形；</p><p>webgl支持的图元类型有七种；</p><ul><li>gl.POINTS(点), </li><li>gl.LINES(线段), </li><li>gl.LINE_STRIP(线条), </li><li>gl.LINE_LOOP(回路), </li><li>gl.TRIANGLES(三角形), </li><li>gl.TRIANGLE_STRIP(三角带), </li><li>gl.TRIANGLE_FAN(三角扇)。</li></ul><p>要绘制空心三角形，gl.LINE_STRIP(线条)、gl.LINES(线段)、 gl.LINE_LOOP(回路)都可以实现。 </p><p>但是gl.LINES(线段)需要写入六个顶点([-1, -1, 0, 1, 0, 1, 1, -1, 1, -1,-1, -1]), </p><p>gl.LINE_STRIP(线条)也需要写入四个顶点([-1, -1, 0, 1, 1, -1,-1, -1]),</p><p>而gl.LINE_LOOP(回路)，只需要是三个顶点([-1, -1, 0, 1, 1, -1])；</p><h4 id="2-2-2-3-顶点着色器和片元着色器"><a href="#2-2-2-3-顶点着色器和片元着色器" class="headerlink" title="2.2.2.3 顶点着色器和片元着色器"></a>2.2.2.3 顶点着色器和片元着色器</h4><p>顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息（如顶点的坐标、法线方向、材质等等，从而改变我们绘制出来的图形的形状或者大小等等；</p><p>顶点处理完成之后，webgl就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单讲，就是对指定图元中的像素点着色；</p><p>webgl从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是生成光栅信息的过程，也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化后的像素信息；</p><p><strong>举例</strong></p><p>将图元设为<code>线段</code>，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是<code>空心</code>的。</p><p>将图元设为<code>三角形</code>，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是<code>实心</code>的；</p><p>因为图元是webGL可以直接处理的图形单元，所以其他非图元的圆形最终必须要转换为图元才可以被webGL处理。比如绘制实心四边形，就需要将四边形拆分成两个三角形，再交给webGL分别绘制出来；</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="comment">// attribute 相当于var const，声明变量的关键字</span></span><br><span class="line"><span class="comment">// vec2 变量类型，vec2表示二维向量</span></span><br><span class="line"><span class="comment">// position 变量名</span></span><br><span class="line"><span class="keyword">const</span> vertex = `</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> position;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_PointSize</span> = <span class="number">1.0</span>;</span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">`;</span><br><span class="line"><span class="comment">// 通过gl_Position 设置顶点；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">const</span> fragment = `</span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">`;</span><br><span class="line"><span class="comment">// gl_FragColor 是webGL片元着色器内置变量，表示当前像素点颜色。 它是一个用RGBA色值表示的四维向量数据；</span></span><br><span class="line"><span class="comment">// 变量类型 vec4 表示四维向量</span></span><br><span class="line"><span class="comment">// webGL可以并行地对整个三角形的所有像素点同时运行片元着色器，并行处理是WebGL程序非常重要的概念；不论这个三角形是大是小，有几十个像素点还是上百万个像素点，GPU都是同时处理每个像素点的；也就是说，图形中有多少个像素点，着色器程序在GPU中就会被同时执行多少次；</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建顶点着色器对象</span></span><br><span class="line"><span class="keyword">const</span> vertexShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class="line">gl.shaderSource(vertexShader, vertex);</span><br><span class="line">gl.compileShader(vertexShader);</span><br><span class="line"><span class="comment">// 创建片元着色器对象</span></span><br><span class="line"><span class="keyword">const</span> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class="line">gl.shaderSource(fragmentShader, fragment);</span><br><span class="line">gl.compileShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建webGLProgram 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> program = gl.createProgram();</span><br><span class="line">gl.attachShader(program, vertexShader);</span><br><span class="line">gl.attachShader(program, fragmentShader);</span><br><span class="line">gl.linkProgram(program);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用webGLProgram对象</span></span><br><span class="line">gl.useProgram(program);</span><br></pre></td></tr></table></figure><h4 id="2-2-2-4-向片元着色器传递数据（与绘图步骤无关）"><a href="#2-2-2-4-向片元着色器传递数据（与绘图步骤无关）" class="headerlink" title="2.2.2.4 向片元着色器传递数据（与绘图步骤无关）"></a>2.2.2.4 向片元着色器传递数据（与绘图步骤无关）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> postion;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color; <span class="comment">// 顶点着色器可通过 varying变量传给片元着色器；</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_PointSize</span> = <span class="number">1.0</span>;</span><br><span class="line">  color = <span class="type">vec3</span>(<span class="number">0.5</span> + position * <span class="number">0.5</span>, <span class="number">0.0</span>); <span class="comment">// 将顶点值映射为一个RGB颜色值；</span></span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position*<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将gl_FragColor 的rgb值设为变量color的值；</span></span><br><span class="line"><span class="comment">// 这个三角形是一个颜色均匀渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。webgl</span></span><br><span class="line"><span class="comment">// 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值</span></span><br><span class="line"><span class="comment">// 利用线性插值可以让像素点的颜色均匀渐变这一特点，可以绘制更多颜色丰富的图形；</span></span><br></pre></td></tr></table></figure><h3 id="2-2-3-将数据存入缓冲区"><a href="#2-2-3-将数据存入缓冲区" class="headerlink" title="2.2.3 将数据存入缓冲区"></a>2.2.3 将数据存入缓冲区</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三角形的顶点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>, <span class="number">-1</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将points写入webGL缓冲区</span></span><br><span class="line"><span class="keyword">const</span> bufferId = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="2-2-4-将缓冲区数据读取到GPU"><a href="#2-2-4-将缓冲区数据读取到GPU" class="headerlink" title="2.2.4 将缓冲区数据读取到GPU"></a>2.2.4 将缓冲区数据读取到GPU</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顶点着色器中的position变量的地址</span></span><br><span class="line"><span class="keyword">const</span> vPosition = gl.getAttribLocation(program, <span class="string">'position'</span>);</span><br><span class="line"><span class="comment">// 给变量设置长度和类型</span></span><br><span class="line">gl.vertexAttribPointer(vPosition, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 激活这个变量</span></span><br><span class="line">gl.enableVertexAttribArray(vPosition);</span><br></pre></td></tr></table></figure><p>经过这样处理，在顶点着色器中，定义的points类型数组中对应的值，就能通过变量position读取到了；</p><h3 id="2-2-5-GPU执行webgl程序，输出结果"><a href="#2-2-5-GPU执行webgl程序，输出结果" class="headerlink" title="2.2.5 GPU执行webgl程序，输出结果"></a>2.2.5 GPU执行webgl程序，输出结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">gl.drawArrays(gl.TRIANGLES,<span class="number">0</span>, points.length/<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="3-Math"><a href="#3-Math" class="headerlink" title="3. Math"></a>3. Math</h2><p>我们要建立一套与各个图形系统无关联的，简单基于<code>向量和矩阵运算</code>的数学体系，用它来描述所有的几何图形信息。</p><p>如何建立一套描述几何图形信息的数学体系，以及如何用这个体系来解决可视化图形呈现的问题；</p><h3 id="3-1-坐标系"><a href="#3-1-坐标系" class="headerlink" title="3.1 坐标系"></a>3.1 坐标系</h3><p>坐标系与向量来描述基本图形的方法，从如何定义和变换图形的直角坐标系，以及如何运用向量表示点和线段；</p><h4 id="3-1-1-HTML"><a href="#3-1-1-HTML" class="headerlink" title="3.1.1 HTML"></a>3.1.1 HTML</h4><p>窗口坐标体系，以参考对象的元素盒子左上角为坐标原点，x轴向右，y轴向下，坐标值对应像素值；</p><h4 id="3-1-2-SVG"><a href="#3-1-2-SVG" class="headerlink" title="3.1.2 SVG"></a>3.1.2 SVG</h4><p>视区盒子（viewBox）坐标系，默认情况下，是以svg根元素左上角为坐标原点，x轴向右，y轴向下，svg根元素右下角坐标为它的像素宽高值。</p><p>如果设置了viewBox属性，那么svg根元素左上角为viewBox的前两个值，右下角为viewBox的后两个值；</p><h4 id="3-1-3-Canvas"><a href="#3-1-3-Canvas" class="headerlink" title="3.1.3 Canvas"></a>3.1.3 Canvas</h4><p>画布左上角为坐标原点，右下角坐标值为canvas画布宽高值；</p><h4 id="3-1-4-webGL"><a href="#3-1-4-webGL" class="headerlink" title="3.1.4 webGL"></a>3.1.4 webGL</h4><p>三维坐标系，它默认以画布正中间为坐标原点，x轴朝右，y轴朝上，z轴朝外，x轴，y轴在画布中范围是 -1 到1；</p><h4 id="3-1-5-坐标系转换-以canvas为例"><a href="#3-1-5-坐标系转换-以canvas为例" class="headerlink" title="3.1.5  坐标系转换(以canvas为例)"></a>3.1.5  坐标系转换(以canvas为例)</h4><p>因为html svg canvas webgl都是直角坐标系，所以它们可以方便地相互转化。html，svg，canvas提供了transform的api很方便进行坐标系转换；</p><p>webgl本身不提供tranform的api，可以在shader里做矩阵运算来实现坐标转换。</p><p>在很多可视化场景下，要处理成千上万的图形，如果这个时候，在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。采用坐标变换的方式就是一个很好的优化思路，它能够简化计算量，这不仅让代码更容易理解，也可以节省CPU运算时间；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rc2 = rough.canvas(canvas2);</span><br><span class="line"><span class="keyword">const</span> ctx = rc2.ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过translate变换 ，将canvas坐标画布原点从左上角（0，0）移动至（256， 256）的位置，即画布的底边上的中心位置；</span></span><br><span class="line">ctx.translate(<span class="number">256</span>, <span class="number">256</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以移动了原点后的新的坐标为参照，通过scale(1,-1) 将Y轴向下的部分，即y&gt;0的部分沿x轴翻转180度；这样就变成画布底边中点为原点，x轴向右，y轴向上的坐标系了；</span></span><br><span class="line">ctx.scale(<span class="number">1</span>, <span class="number">-1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hillOpts2 = &#123; <span class="attr">roughness</span>: <span class="number">2.8</span>, <span class="attr">strokeWidth</span>: <span class="number">2</span>, <span class="attr">fill</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line">rc2.path(<span class="string">"M-180 0L-80 100L20 0"</span>, hillOpts2);</span><br><span class="line">rc2.path(<span class="string">"M-20 0L80 100L180 0"</span>, hillOpts2);</span><br><span class="line"></span><br><span class="line">rc2.circle(<span class="number">0</span>, <span class="number">150</span>, <span class="number">105</span>, &#123;</span><br><span class="line">  stroke: <span class="string">"red"</span>,</span><br><span class="line">  strokeWidth: <span class="number">4</span>,</span><br><span class="line">  fill: <span class="string">"rgba(255,255, 0, 0.4)"</span>,</span><br><span class="line">  fillStyle: <span class="string">"solid"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-向量"><a href="#3-2-向量" class="headerlink" title="3.2 向量"></a>3.2 向量</h3><p>在直角坐标系里绘制图形，一般的几何图形都是由点，线段喝面构成，其中，点和线段是基础的图元信息，因此，如何描述它们是绘图的关键；</p><p>如何用向量来描述点和线段？一般用向量来表示一个点或者一个线段；</p><p>用二维向量来表示这个平面上的点和线段，二维向量其实就是一个包含了两个数值的数组，一个是x坐标值，一个是y坐标值；</p><p><img src="xiangliang1.png" alt="image-20210129145004214"></p><p><code>向量V(x,y)有两个含义，一是表示该坐标系下位于（x，y）处的一个点，二是可以表示从原点（0，0）到坐标（x，y）的一根线段。</code></p><h4 id="3-2-1-向量基本运算"><a href="#3-2-1-向量基本运算" class="headerlink" title="3.2.1 向量基本运算"></a>3.2.1 向量基本运算</h4><p><img src="xiangliang2.png" alt="image-20210129150448210"></p><p>现在有两个向量，v1和v2；</p><p>v1+v2 相当于将V1的终点沿着v2向量的方向移动一段距离。这段距离等于v2向量的长度。</p><p>这样在平面上得到三个元素</p><ol><li>一个新的点 (x1+x2, y1+y2)；</li><li>一条新的线段 [(0, 0), (x1+x2, y1+y2)];</li><li>一段折线 [(0,0),(x1,y1),(x1+x2, y1+y2)];</li></ol><h4 id="3-2-2-向量长度和方向"><a href="#3-2-2-向量长度和方向" class="headerlink" title="3.2.2 向量长度和方向"></a>3.2.2 向量长度和方向</h4><p>一个向量包含长度和方向信息</p><p>它的长度可以用向量的 x、y 的平方和的平方根 （勾三股四弦五）来表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.length = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">Math</span>.hypot(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y)&#125;;</span><br></pre></td></tr></table></figure><p>它的方向可以用与 x 轴的夹角来表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.dir = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="keyword">this</span>.y, <span class="keyword">this</span>.x);&#125;</span><br><span class="line"><span class="comment">// Math.atan2 的取值范围是 -π到π，负数表示在 x 轴下方，正数表示在 x 轴上方。</span></span><br></pre></td></tr></table></figure><p><img src="atan2.png" alt="image-20210129161732242"></p><p>根据长度和方向的定义，还能推导出一组关系方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.x = v.length * <span class="built_in">Math</span>.cos(v.dir);</span><br><span class="line">v.y = v.length * <span class="built_in">Math</span>.sin(v.dir);</span><br></pre></td></tr></table></figure><p><strong>推导过程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#角A  对边=y 邻边 = x, 斜边 = z</span></span><br><span class="line">x*x + y*y = z*z</span><br><span class="line">sinA = 对边/斜边 = y/z</span><br><span class="line">cosA = 邻边/斜边 = x/z</span><br><span class="line">tanA = 对边/邻边 = sinA/cosA = (y/z) / (x/z) = y/x;</span><br><span class="line"></span><br><span class="line">v.length * cosA = z * (x/z) = x</span><br><span class="line">v.length * sinA = z * (y/z) = y</span><br></pre></td></tr></table></figure><p>结论： 可以很简单构造出一个绘图向量。如果以点 V（x0, y0）为起点，沿着某个方向画一段长度为length的线段，只需构造如下一个向量即可；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = length * v(cos(A), sin(A))</span><br></pre></td></tr></table></figure><p><strong>推导过程</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 = length * v(cos(A), sin(A))</span><br><span class="line">#  这里写成 v1 = length (cosA, sinA) 更容易理解一些</span><br><span class="line">cosA = x/z;</span><br><span class="line">sinA = y/z;</span><br><span class="line">length = z;</span><br></pre></td></tr></table></figure><p>可视化呈现依赖于计算机图形学，而向量运算是整个计算机图形学的数学基础；</p><p><img src="xiangliang6.png" alt="image-20210201115049568"></p><h3 id="3-3-向量乘法"><a href="#3-3-向量乘法" class="headerlink" title="3.3 向量乘法"></a>3.3 向量乘法</h3><p>向量的点乘Dot.product, 向量的点乘也叫向量的内积、数量积；</p><p>向量的叉乘Corss.product，也叫向量积，外积、叉积；</p><h4 id="3-3-1-一个例子引出向量乘法的"><a href="#3-3-1-一个例子引出向量乘法的" class="headerlink" title="3.3.1 一个例子引出向量乘法的"></a>3.3.1 一个例子引出向量乘法的</h4><p>*<em>判断：一个点是否在扫描器内 *</em></p><p><img src="xiangliang3.png" alt="image-20210201100216269"></p><p><strong>解答</strong></p><p>如图所示，扫描器是60度，垂直向上，所以它的范围应该是60度到120度； 也就是 <code>Math.PI/3</code> 到 <code>2*Math.PI/3</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  先求出目标向量与X轴的夹脚</span></span><br><span class="line">v.dir = <span class="built_in">Math</span>.atan2(v.y, v.x); <span class="comment">// 此方法是求解夹角的，比如 Math.atan2(1,1) === Math.PI/4 // true</span></span><br><span class="line"><span class="comment">// 求解该 dir是否在扫描器之内</span></span><br><span class="line">isIn = v.dir &gt; <span class="built_in">Math</span>.PI/<span class="number">3</span> &amp;&amp; v.dir &lt; <span class="number">2</span>*<span class="built_in">Math</span>.PI/ <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-向量点乘"><a href="#3-3-2-向量点乘" class="headerlink" title="3.3.2 向量点乘"></a>3.3.2 向量点乘</h4><p>两个N维向量，a和b， a = [a1,a2,a3,…an], b = [b1b2b3….bn];  那向量的点积代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a*b = a1*b1 + a2*b2 + .... an*bn</span><br></pre></td></tr></table></figure><p>a, b 向量点积的几何意义，是a向量乘以b向量在a向量上的投影分量。</p><p>它的物理含义相当于a力作用于物体，产生b位移所做的功。</p><p><img src="xiangliang4.png" alt="image-20210201101853232"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当a、b向量平行时，那么它们的夹角为0</span></span><br><span class="line">a.x * b.x + a.y * b.y = a.length * b.length;</span><br><span class="line"><span class="comment">// 当a、b两个向量垂直时，它们的夹角就是90度，那么a.b = 0；</span></span><br><span class="line">a.x * b.x + a.y * b.y === a*b*cos(<span class="number">90</span>度) = a*b*<span class="number">0</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>向量的点乘， 对两个向量执行点乘运算，结果是一个【Scaler标量】（一个数字）</p><p>（标量： scalar， 只有大小没有方向的量，例如物体移动中的平均速率·路程）</p><h4 id="3-3-3-向量的叉乘"><a href="#3-3-3-向量的叉乘" class="headerlink" title="3.3.3 向量的叉乘"></a>3.3.3 向量的叉乘</h4><p>向量的叉乘，则是针对两条向量的另一种运算方式。</p><p>向量叉乘运算的结果不是标量，而是一个新的向量；新的向量会 垂直于 原来的这两条向量；</p><p><img src="xiangliang7.png" alt="image-20210201130057607"></p><p>向量A和向量B的叉积是向量C， 【向量C】同时垂直于【向量A和向量B】</p><p><img src="xiangliang8.png" alt="image-20210201130451600"></p><p>【向量的叉乘】一个用途就是找到我们应该在哪一轴上施加【扭力Torque】（还有，跟踪导弹，比如合金弹头的C弹，也是可以通过叉乘的方法去实现的）；</p><p>如下示例：</p><p>【向量A】表示的是炮口【当前朝向】</p><p>【向量B】表示的是炮口将要【调整后的朝向】</p><p>【向量C】将两个向量进行叉乘后，找到炮口需要在哪一轴上进行旋转并且施加相应的扭力；</p><p><img src="xiangliang9.png" alt="image-20210201131037523"></p><p><img src="xiangliang5.png" alt="image-20210201104506469"></p><p><strong>叉积几何意义</strong></p><p>向量a和b的叉积，就相当于向量a（蓝色带箭头线段）与向量b沿垂直方向的投影（红色带箭头线段）的乘积。（如上图所示），二维向量叉积的几何意义就是向量a、b组成的平行四边形的面积；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|a| 表示向量a的length；</span><br></pre></td></tr></table></figure><p><strong>思考题：求点到线段的距离</strong></p><p>在了解向量叉积的几何意义之后， 我们通过向量叉积得到平行四边形的面积，再除以底边长；就能得到点到向量所在直线的距离</p><p><strong>叉乘在数学上的计算方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中，i，j，k 分别是 x，y，z 轴的单位向量，我们把行列式展开，就能得到如下公式：</span></span><br><span class="line">a X b = [y1 * z2 - y2 * z1, - (x1 * z2 - x2 * z1), x1 * y2 - x2 * y1]</span><br></pre></td></tr></table></figure><p>更多点积差积相关知识参考<a href="https://geek-docs.com/linear-algebra/vector/vector-chaji.html" target="_blank" rel="noopener">https://geek-docs.com/linear-algebra/vector/vector-chaji.html</a></p><p><strong>回到思考题3:  给任意一个点，判断这个点在不在扫描器内</strong></p><p><img src="xiangliang3.png" alt="image-20210201100216269"></p><p><strong>归一化</strong></p><p>归一化，用 v0的 x、y 分别除以它的绝对值。归一化后的向量方向不变，长度为 1。 在向量乘法里，如果 a、b 都是长度为 1 的归一化向量，那么|a X b| 的结果就是 a、b 夹角的正弦值，而|a • b|的结果就是 a、b 夹角的余弦值。</p><p>好了，再说回来，我们把归一化的向量 a 叉乘扫描器中线上的 v(0,1)，由于扫描器关于 y 轴对称，所以扫描器边缘与 y 轴的夹角是正负 30 度。那么在与单位向量求叉积的时候，就会出现 2 种情况：</p><ol><li>点在扫描范围内，如向量 a，就一定满足： |a X v| &lt;= ||a||v|sin(30°)| = |sin(30°)| = 0.5；</li><li>点不在扫描范围内，如向量 b，就一定满足：|b X v| &gt; ||b||v|sin(30°)| = |sin(30°)| = 0.5。</li></ol><p><img src="xiangliang10.png" alt="image-20210201170711074"></p><p>因此，只要任意一点所在的向量与单位向量的叉积结果的绝对值不大于0.5（即sin30度），就说明这个点在扫描范围内，所以如下判断方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> isInRange = <span class="built_in">Math</span>.abs(<span class="keyword">new</span> Vec2(<span class="number">0</span>, <span class="number">1</span>).cross(v0.normalize())) &lt;= <span class="number">0.5</span>; </span><br><span class="line"><span class="comment">// v0.normalize()即将v0归一化</span></span><br></pre></td></tr></table></figure><h4 id="3-3-4-点乘与叉乘加述"><a href="#3-3-4-点乘与叉乘加述" class="headerlink" title="3.3.4 点乘与叉乘加述"></a>3.3.4 点乘与叉乘加述</h4><ul><li>Dot product </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a向量 * b向量 = a长度 * b长度 * cos@</span><br><span class="line">  <span class="comment">// @ 为a向量和b向量的夹角</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 点乘使用场景1， 快速得到两个向量的夹角</span></span><br><span class="line">  cos@ = （a向量 * b向量） / （a长度 * b长度）</span><br></pre></td></tr></table></figure><p>点乘能快速得到两个向量的夹角， 特别是在两个向量都是单位向量的时候。它们的长度自然都是1；所以它们的点乘自然就是夹角的cos值；</p><p><strong>点乘满足的计算规律</strong></p><p>交换律，分配律，结合率；</p><ul><li>Cross product</li></ul><h3 id="3-4-向量和参数方程描述曲线"><a href="#3-4-向量和参数方程描述曲线" class="headerlink" title="3.4 向量和参数方程描述曲线"></a>3.4 向量和参数方程描述曲线</h3><p>用参数方程描述曲线的方法，通过此方法可以描述常见的圆，椭圆，抛物线，正余弦等曲线，还能描述更具一般性的曲线；比如贝塞尔曲线，或者Catmull-Rom曲线等等；</p><h4 id="3-4-1-画圆"><a href="#3-4-1-画圆" class="headerlink" title="3.4.1 画圆"></a>3.4.1 画圆</h4><p><img src="xiangliang11.png" alt="image-20210201210910536"></p><p>如下图所示的参数方程，圆心为（x0, y0），半径为r；</p><h4 id="3-4-2-画圆椎曲线"><a href="#3-4-2-画圆椎曲线" class="headerlink" title="3.4.2 画圆椎曲线"></a>3.4.2 画圆椎曲线</h4><p>除了画圆，参数方程还可以描述很多其他圆椎曲线，比如椭圆的参数方程。它其实和圆的参数方程很接近。其中，a，b 分别是椭圆的长轴和短轴，当a=b=r时，这个方程就是椭圆的方程式。圆是椭圆的特例；</p><p><img src="xiangliang12.png" alt="image-20210201212553422"></p><h4 id="3-4-3-抛物线的参数方程，"><a href="#3-4-3-抛物线的参数方程，" class="headerlink" title="3.4.3 抛物线的参数方程，"></a>3.4.3 抛物线的参数方程，</h4><p>其中p是常数，为焦点到准线的距离</p><p><img src="xiangliang13.png" alt="image-20210201212737588"></p><h4 id="3-4-4-贝塞尔曲线"><a href="#3-4-4-贝塞尔曲线" class="headerlink" title="3.4.4 贝塞尔曲线"></a>3.4.4 贝塞尔曲线</h4><h3 id="3-5-三角剖分和向量操作描述并处理多边形"><a href="#3-5-三角剖分和向量操作描述并处理多边形" class="headerlink" title="3.5 三角剖分和向量操作描述并处理多边形"></a>3.5 三角剖分和向量操作描述并处理多边形</h3><h3 id="3-6-仿射变换对几何图形进行坐标变换"><a href="#3-6-仿射变换对几何图形进行坐标变换" class="headerlink" title="3.6 仿射变换对几何图形进行坐标变换"></a>3.6 仿射变换对几何图形进行坐标变换</h3>]]></content>
      
      
      <categories>
          
          <category> webgl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas</title>
      <link href="2021/01/26/canvas/"/>
      <url>2021/01/26/canvas/</url>
      
        <content type="html"><![CDATA[<h2 id="1-canvas-基础API"><a href="#1-canvas-基础API" class="headerlink" title="1. canvas 基础API"></a>1. canvas 基础API</h2><h3 id="1-1-context"><a href="#1-1-context" class="headerlink" title="1.1 context"></a>1.1 context</h3><p>context对象 <strong>proto</strong> 指向CanvasRenderingContext2D，一些绘图API集中在这些地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure><p> context对象API大体分两类</p><ol><li><p>设置状态的 （颜色，线宽， 坐标变换）</p></li><li><p>绘制指令API，绘制不同形状的几何图形</p></li></ol><h3 id="1-2-绘图API"><a href="#1-2-绘图API" class="headerlink" title="1.2 绘图API"></a>1.2 绘图API</h3><h4 id="1-2-1-rect"><a href="#1-2-1-rect" class="headerlink" title="1.2.1 rect"></a>1.2.1 rect</h4><p>绘制矩形指令</p><p><strong>参数</strong></p><p>四个参数，分别为<code>要绘制矩形的x坐标</code>，<code>要绘制矩形y坐标</code>, <code>矩形宽</code>和<code>矩形高</code>；</p><h4 id="1-2-2-缓存当前状态和恢复"><a href="#1-2-2-缓存当前状态和恢复" class="headerlink" title="1.2.2 缓存当前状态和恢复"></a>1.2.2 缓存当前状态和恢复</h4><p>类似一个压栈和弹栈功能；</p><p><strong>save</strong></p><p>保留当前的路径和颜色等状态</p><p><strong>restore</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"green"</span>;</span><br><span class="line">ctx.save(); <span class="comment">// 保存画笔初始坐标(0,0), 填充色为绿色</span></span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the default state</span></span><br><span class="line">ctx.restore();</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">150</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 该图形的画笔坐标回到 初始状态，即 (0,0) ,填充色为绿色，而不是默认色；</span></span><br></pre></td></tr></table></figure><h3 id="1-3-绘制状态API"><a href="#1-3-绘制状态API" class="headerlink" title="1.3 绘制状态API"></a>1.3 绘制状态API</h3><p><strong>fillStyle</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.fillStyle = color;</span><br></pre></td></tr></table></figure><h3 id="1-4-坐标系统"><a href="#1-4-坐标系统" class="headerlink" title="1.4 坐标系统"></a>1.4 坐标系统</h3><p>  左上角为 (0, 0)</p><p> 右下角为 (canvas.width, canvas.height)</p><h3 id="1-5-绘图过程"><a href="#1-5-绘图过程" class="headerlink" title="1.5 绘图过程"></a>1.5 绘图过程</h3><ol><li>获取canvas对象，getContext(‘2d’)</li><li>绘制状态， fillStyle， translate等；</li><li>beginPath开始绘制</li><li>调绘图指令，rect等</li><li>调fill指令，将绘制内容输出到画布中；</li></ol><h3 id="1-6-图形信息"><a href="#1-6-图形信息" class="headerlink" title="1.6 图形信息"></a>1.6 图形信息</h3><p>有的时候，类似一份层级数据（城市 &gt; 省份 &gt; 中国）这样层级数据，要将它与绘图指令建立联系，建立联系指的是 要把数据的层级、位置、和要绘制的圆的半径、位置一一对应起来；</p><p>换句话说就是要把数据转换成图形信息，这个步骤需要数学计算；</p><p>假设，我们要将数据展现在一个画布宽高为 1600 * 1600 的 Canvas 中，那我们可以通过 d3.pack() 将数据映射为一组 1600 宽高范围内的圆形。</p><p>具体绘制的过程比较简单，<code>只需要遍历数据并且根据数据内容绘制圆弧</code></p>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="2021/01/25/C/"/>
      <url>2021/01/25/C/</url>
      
        <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="1-程序"><a href="#1-程序" class="headerlink" title="1.程序"></a>1.程序</h2><blockquote><p>写程序前，先构想好程序的结构，而不是先从定义变量开始。</p></blockquote><ol><li>没有想好解决方案，不要急于动手写程序？</li><li>有了解决方案以后，可以按照“先粗后细，先抽象后具体”的办法，先有程序的轮廓，如有必要可以解决“建模工具”画一些图，而后再动手写程序；</li><li>写程序时，可以先写出程序轮廓，而后再补充变量定义等细节；</li></ol><p>程序并不纠结于是否更优。<br>而在于程序结构是不是清楚，是不是容易被人看懂</p><h3 id="1-1-写程序的过程"><a href="#1-1-写程序的过程" class="headerlink" title="1.1 写程序的过程"></a>1.1 写程序的过程</h3><blockquote><p>按照由大到小，由粗到细，由抽象到具体的方法分析、编写程序</p></blockquote><ul><li>程序的结构 （基本思想）<ul><li>程序由若干个“模块”组成</li><li>模块之内“高内聚”（高内聚， 就是这个模块只做这个事情，不干别的。功能单一）</li><li>模块之间“低耦合” （当一个模块被改动的时候，只会印象它自己，而不会影响别的）</li></ul></li></ul><h3 id="1-2-编程语言共性-（语法）"><a href="#1-2-编程语言共性-（语法）" class="headerlink" title="1.2 编程语言共性 （语法）"></a>1.2 编程语言共性 （语法）</h3><p>程序设计语言的构成,语言种类千差万别，但是，一般来说，基本成分不外四种：</p><ol><li>数据， 用以描述程序中所涉及的数据 （数据类型）</li><li>运算，用以描述程序中所包含的运算；（运算符）</li><li>控制，用以表达程序中的控制构造；（三种类型的控制语句是如何写的，顺序，分支，循环）</li><li>IO，用以表达程序中数据的传输； （如何输入和输出数据）</li></ol><h3 id="1-3-大纲"><a href="#1-3-大纲" class="headerlink" title="1.3 大纲"></a>1.3 大纲</h3><ol><li>基本概念</li><li>数据类型，运算符，表达式</li><li>IO</li><li>流程控制（顺序，分支，循转）</li><li>数组</li><li>指针</li><li>函数</li><li>构造类型</li><li>动态内存管理</li><li>调试工具，（gdb，make）</li><li>常用库函数</li></ol><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><blockquote><p>把内存想象成一个长长的带子,带子上面有很多小方格，每个格子都是一个字节（存储单元）。每个小方格都有它对应的地址，每个字节（单元）有八位，1B（byte） = 8b（bit）每一个位存储一个二进制的数。</p></blockquote><h3 id="2-1-变量与常量"><a href="#2-1-变量与常量" class="headerlink" title="2.1 变量与常量"></a>2.1 变量与常量</h3><h4 id="2-1-1-常量"><a href="#2-1-1-常量" class="headerlink" title="2.1.1 常量"></a>2.1.1 常量</h4><blockquote><p>在程序执行过程中值不会发生变化的量，数组名是一个典型的常量，一旦数组定义了，gcc为当前的数组分配了一段空间了。然后数组的位置就定死了。数组名就是一个数组的起始位置。是一个常量，如果你在=左边写上一个常量，就表示企图更改一个常量的值；比如<code>1=f</code> ，显然不成立；</p></blockquote><p><strong>常量的分类</strong></p><ul><li><p>整型常量</p></li><li><p>实型常量</p><p>3.14,  5.26;</p></li><li><p>字符常量</p><p>由单引号印起来的单个字符或者转义字符，如’a’</p><p>转义字符： ‘\n’, ‘\r’, ‘\t’ ，’\015’(八进制数)， ‘\x7f’(十六进制数)</p></li><li><p>字符串常量</p><p>由双引号印起来的一个或多个字符组成的序列，如: “”(空串)</p><p>一个字符串在存储的时候，最末尾会有一个结束标记，通常称作尾0<code>\0</code>.所以<code>&quot;&quot;</code>是占空间的，空字符占一个字节的空间；</p><ul><li>合法的字符串 （””, “a”, “abXYZ”）</li><li>暂时不确定是否合法的字符 （”abc\n\021\018”) 因为<code>\018</code>不是八进制，因为出现了8，而我们知道<code>\0</code>是字符串数组的末尾。所以<code>\0</code>到底能否插入进字符串中间，这个需要后续字符数组专题揭秘；</li><li>字符串常量需要借助构造类型——数组来保存</li><li><code>&#39;a&#39;和&quot;a&quot;的区别</code>：前者是字符常量，后者是字符串常量。</li></ul></li><li><p>标识常量</p><ul><li><p>#define， 程序中一改全改 <code>#define PI 3.14</code>，在程序预处理之后，宏名被宏体完整的替换；<code>define ADD 2+3 ADD*ADD</code> = <code>2+3*2+3而不是(2+3)*(2+3)</code>。 #define，处理在程序的预处理阶段，占编译时间。不占运行时间。一改全改；缺点： 不检查语法，只是单纯的宏体与宏名之间的替换；</p><ol><li>带参数的#define</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX(a, b)  a&gt;b?a:b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  i = <span class="number">5</span>;</span><br><span class="line">  j=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"/d\n"</span>, MAX(i, j));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -E define.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  i = <span class="number">5</span>;</span><br><span class="line">  j=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"/d\n"</span>, (i&gt;j?i:j));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>一个特殊问题的解决方式</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max = %d\n"</span>, MAX(i++, j++));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i=%d\tj=%d\n"</span>, i, j);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((i++) &gt; (j++) ? (i++) : (j++))</span><br><span class="line"></span><br><span class="line"><span class="comment">// max = 6</span></span><br><span class="line"><span class="comment">// i=7     j=4</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>首先，max和MAX的区别，MAX只占用预编译时间，等运行的时候，实际上已经将所有宏体替换到程序中去了。不会再需要额外的时间了。而max则不同，在函数的调用位置，对当前的一个执行现场做一个压栈保存。然后去到指定的函数去执行。（跳往另外一个入口地址）然后再回来，弹栈恢复当前现场的过程。这个过程 占用了运行的时间；</p></li><li><p>什么时候用宏，什么时候用函数？在需要极致性能的场景用宏，前提是宏能满足；比如内核。在应用层面，系统层面，多用函数。因为应用层要求更高的是稳定性，而非实时性。</p></li><li><p>解决方案，需要找一个变量来接受；而不是让其继续做加运算；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (&#123;typeof(a) A = a, B = b;((A) &gt; (B) ? (A) : (B)); &#125;)</span></span><br><span class="line"><span class="comment">// typeof(a) 用a的类型定义A，就很灵性了。有点泛型的意思了；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max = %d\n"</span>, MAX(i++, j++));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i=%d\tj=%d\n"</span>, i, j);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// max = 5</span></span><br><span class="line"><span class="comment">// i=6     j=4</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-变量"><a href="#2-1-2-变量" class="headerlink" title="2.1.2 变量"></a>2.1.2 变量</h4><blockquote><p>用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量；</p></blockquote><p>当计算机执行到 <code>int max=0</code> 这句程序时，计算机会在内存里面找到一片存储空间（几个连续的存储单元），然后给该片存储空间取个名字叫 <code>Max</code>， 再把 <code>0</code> 这个初始值放在这个存储空间中来。<code>并记下这个名字（Max）和这片连续的存储空间的起始的地址之间的对应关系</code></p><p>定义： [存储类型]  数据类型  标识符 =  值 </p><p><code>TYPE NAME = VALUE;</code></p><p>存储类型 可选</p><h5 id="2-1-2-1-标识符"><a href="#2-1-2-1-标识符" class="headerlink" title="2.1.2.1 标识符"></a>2.1.2.1 标识符</h5><p>当定义一个某种类型的标识符的时候，编译器会为当前的值分配一块内存空间；如何称呼这块空间，就是<code>房间号</code>。房间号就是标识符。编译器会给标识符（房间号）和内存地址标识做关联。当搜索变量名的时候，编译器知道要去到哪块内存地址去搜索；简单说，标识符就是这块空间的临时别名；</p><h4 id="2-1-3-存储类型"><a href="#2-1-3-存储类型" class="headerlink" title="2.1.3 存储类型"></a>2.1.3 存储类型</h4><blockquote><p>auto, static register extern(说明型)</p></blockquote><h5 id="2-1-3-1-auto"><a href="#2-1-3-1-auto" class="headerlink" title="2.1.3.1 auto"></a>2.1.3.1 auto</h5><blockquote><p>默认，自动分配空间，自动回收空间</p></blockquote><p>auto类型分配在栈上，堆主要是来进行动态内存分配的空间；堆栈不挨着</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">int</span> i; <span class="comment">// 原则上不会 对 i所在这块空间进行初始化</span></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i); <span class="comment">// 随机的结果，当然有的编译器会置为0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"j= %d\n"</span>, j); <span class="comment">// 0  编译器会初始化为0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x =<span class="number">0</span>;</span><br><span class="line">  x = x+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明： 这三个地址未必一致，但一致的原因是 auto类型的变量都存放在栈上，栈上的空间按正常理论来讲，它实际上是连续分配的。而当前x在  func函数被调用的时候，它才会被产生。然后在当前函数执行结束的时候，这块空间被释放掉了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="2-1-3-2-register"><a href="#2-1-3-2-register" class="headerlink" title="2.1.3.2 register"></a>2.1.3.2 register</h5><blockquote><p>建议型关键字；</p></blockquote><p>寄存器类型，资源少，速度快，寄存器存放在CPU当中，寄存器的数据比较吃紧，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i =<span class="number">1</span>; <span class="comment">// 除非i在程序中，超高频率被使用，才建议编译器将i分配到寄存器中；至于有没有被放到寄存器中，由gcc来决定；</span></span><br></pre></td></tr></table></figure><p><strong>register的苛刻条件；</strong></p><ol><li>只能定义局部变量，不能定义全局变量；</li><li>大小有限制，只能定义 32 位大小的数据类型，如double 就不可以</li><li>寄存器中没有地址，所以一个寄存器类型变量无法打印出地址查看或者使用；</li></ol><h5 id="2-1-3-3-static"><a href="#2-1-3-3-static" class="headerlink" title="2.1.3.3 static"></a>2.1.3.3 static</h5><blockquote><p>静态型，自动初始化为0值或空值，并值其变量的值有继承性（继承性指的的static在内存中只此一份，所以下次使用的时候还是基于上一次的值，而不会被初始化）。另外，常用于修饰变量或函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x =<span class="number">0</span>;</span><br><span class="line">  x = x+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;1</span></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;2</span></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;3</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明： static类型的变量，只用一块空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>static 修饰函数：</strong></p><p>防止该函数对外扩展，（简单说就是该函数只能在当前文件下使用，在别的文件下没法使用；）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello func"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_func</span><span class="params">()</span>  <span class="comment">// 外界可以通过 call_func 这个桥梁函数来引用 func</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说全局变量都要修饰成static，防止跟别的.c文件中同名变量冲突。然后用static来修饰函数，为的是强调当前函数不可外扩，（该函数只能在当前文件使用，别的文件下没法使用）</p><h5 id="2-1-3-4-extern"><a href="#2-1-3-4-extern" class="headerlink" title="2.1.3.4 extern"></a>2.1.3.4 extern</h5><blockquote><p>说明型， 意味着不能改变被说明的变量的值或类型；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proj.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">  func();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proj.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proj.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">// 我的i不是自己定义的，是引用其他文件里面的i，编译器自己去找，extern不能改变声明的类型和值；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-变量的生命周期和作用范围（即作用域）"><a href="#2-1-4-变量的生命周期和作用范围（即作用域）" class="headerlink" title="2.1.4 变量的生命周期和作用范围（即作用域）"></a>2.1.4 变量的生命周期和作用范围（即作用域）</h4><ol><li>全局变量和局部变量</li><li>局部变量和局部变量</li><li>参考图片</li></ol><h2 id="3-C程序"><a href="#3-C程序" class="headerlink" title="3. C程序"></a>3. C程序</h2><h3 id="3-1-程序规范"><a href="#3-1-程序规范" class="headerlink" title="3.1 程序规范"></a>3.1 程序规范</h3><blockquote><p>以helleworld为例对写程序的思路提出如下要求:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void main(void);</span></span><br><span class="line"><span class="comment">//void main(int argc, char **argv); // char * argv[]</span></span><br><span class="line"><span class="comment">//int main(int argc, char **argv);</span></span><br><span class="line"><span class="comment">//int main(void);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello c!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>头文件正确包含的重要性；</li><li>知道程序中的所有警告<code>gcc file.c -Wall</code></li><li>如何调试段错误，先把程序中的所有警告调好；</li><li>以函数为单位来进行程序编写；</li><li>声明部分 和  实现部分（变量先定义，后使用）</li><li>return 0 （exit(0) 在单进程单线程的程序中 和 return 0意义一样的，exit(0)是给它父进程看的，当前main函数的父进程是shell）</li><li>多用空格空行</li><li>添加注释</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $? <span class="comment"># 上一条语句执行的状态</span></span><br></pre></td></tr></table></figure><h3 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h3><blockquote><p>#if #endif 注释</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(0)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3-编译"><a href="#3-3-编译" class="headerlink" title="3.3 编译"></a>3.3 编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gcc hello.c</span></span><br><span class="line">.c -&gt; .out</span><br></pre></td></tr></table></figure><p><strong>gcc过程(c源文件到可执行文件需要经过的顺序)</strong></p><p>c源文件 - 预处理 - 编译 - 汇编  - 链接 - 可执行文件</p><ul><li>预处理 <code>gcc -E hello.c &gt; hello.i</code> (预处理hello.c，保存至 hello.i 文件)<pre><code>以#开头的语句部分都是在预处理阶段解决掉的；`include`或者 `if define`</code></pre></li><li>编译阶段<code>gcc -S hello.i</code> (编译hello.i)<pre><code>默认会生成一个 .s文件，编译成汇编文件；</code></pre></li><li>汇编阶段<code>gcc -c hello.s</code><pre><code>生成一个 .o文件；</code></pre></li><li>链接阶段<code>gcc hello.o -o hello</code> (链接.o文件 生成可执行文件 hello)<pre><code>生成可执行文件hello;</code></pre></li></ul><h4 id="3-3-1-C编译"><a href="#3-3-1-C编译" class="headerlink" title="3.3.1 C编译"></a>3.3.1 C编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c  <span class="comment"># 把test.c 编译成一个可执行文件 test</span></span><br><span class="line">gcc hello.c -Wall   <span class="comment"># 显示编译警告，原则上编码过程当中把程序调到没有警告为止；</span></span><br><span class="line">./<span class="built_in">test</span>              <span class="comment"># 执行 test</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-多个-c文件"><a href="#3-3-2-多个-c文件" class="headerlink" title="3.3.2 多个.c文件"></a>3.3.2 多个.c文件</h4><ul><li>main() 里的代码太长了 适合分成几个函数</li><li>一个源文件太长适合分成几个文件</li><li>两个独立的源文件不能编译形成可执行的程序</li></ul><h4 id="3-3-3-头文件"><a href="#3-3-3-头文件" class="headerlink" title="3.3.3 头文件"></a>3.3.3 头文件</h4><blockquote><p>把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件(.c文件)中  #include 这个头文件，就能让编译器在编译的时候知道函数的原型</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.c  max.c  max.h</span></span><br><span class="line">gcc  main.c  max.c</span><br></pre></td></tr></table></figure><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h2><ul><li>不同数据类型所占字节数</li><li>存储区别</li><li>不同类型的数据间转换</li><li>特殊性：</li></ul><h3 id="4-1-基本类型"><a href="#4-1-基本类型" class="headerlink" title="4.1 基本类型"></a>4.1 基本类型</h3><ul><li>数值类型 <ul><li>整型<ul><li>短整型 short   （2个字节，16位）</li><li>整型 int      （4个字节，32位）</li><li>长整型 long    （4个字节，32位）</li></ul></li><li>浮点型<ul><li>单精度型 float   （4个字节，32位）</li><li>双精度型 double    （8个字节，64位）</li></ul></li></ul></li><li>字符类型 char           （1个字节，8位）</li></ul><h4 id="4-1-1-整形存储"><a href="#4-1-1-整形存储" class="headerlink" title="4.1.1 整形存储"></a>4.1.1 整形存储</h4><p><strong>整型的存储都是以补码的形势来存储的</strong></p><p>补码：正数的补码是它二进制本身，负数的补码是它绝对值的那个数的二进制形式取反再加1的结果；</p><p>254 -&gt; unsigned int(无符号 int) -&gt; 32位</p><p>-254 -&gt; 254-&gt; 1111 1110 取反 +1  </p><ul><li>有无符号的区别，最高位到底代表是符号还是正常有效值；有符号的话，为0表示正数，为1表示负数；</li></ul><p>(254)10 =&gt; (11111110)2</p><p>方法： 除2取余倒序排列；（转2进制）11111110</p><pre><code>除8取余倒序排列；（转8进制）376除16取余倒序排列；（转16进制） FE</code></pre><p><strong>进制表示</strong></p><ul><li>254                 十进制</li><li>B11111110    二进制</li><li>0376               八进制</li><li>0xFE               十六进制</li></ul><h4 id="4-1-2-浮点型存储"><a href="#4-1-2-浮点型存储" class="headerlink" title="4.1.2  浮点型存储"></a>4.1.2  浮点型存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span> * <span class="number">10</span>^<span class="number">0</span></span><br><span class="line"><span class="number">0.314</span> * <span class="number">10</span>^<span class="number">1</span></span><br><span class="line"><span class="number">0.0314</span> * <span class="number">10</span>^<span class="number">2</span></span><br><span class="line"><span class="number">314</span> * <span class="number">10</span>^<span class="number">-2</span></span><br></pre></td></tr></table></figure><p><strong>浮点数是以0.314 * 10^1的方式来存储3.14的</strong></p><p><code>整数部分为0，只是在意精度部分是多少。然后在意指数部分是多少。</code></p><ul><li>浮点数在32 个bit上是如何存放的<br>0～22位（共23个bit）用来记录精度部分。 22位～30位（共8个bit） 用来存储的是指数部分。最高位（第31位） 表示的是符号位置，表示是正数还是负数；</li></ul><p><strong>举例</strong></p><p>0.000789 -&gt; 0.789 -&gt; 10^3</p><p><code>精度部分存储 789的二进制形式，8个位存储3</code></p><ul><li>float 32位</li><li>double 64位 ，比float多出来的32位完全放在精度的控制上</li></ul><h4 id="4-1-3-char存储"><a href="#4-1-3-char存储" class="headerlink" title="4.1.3 char存储"></a>4.1.3 char存储</h4><ul><li>char 8位。                    -128～127</li><li>unsigned char 8位。   0～255</li></ul><h4 id="4-1-4-不同类型的数据间转换"><a href="#4-1-4-不同类型的数据间转换" class="headerlink" title="4.1.4 不同类型的数据间转换"></a>4.1.4 不同类型的数据间转换</h4><h5 id="4-1-4-1-精度丢失"><a href="#4-1-4-1-精度丢失" class="headerlink" title="4.1.4.1 精度丢失"></a>4.1.4.1 精度丢失</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.9</span>;</span><br><span class="line"><span class="keyword">int</span> i = f; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h5 id="4-1-4-2-隐式转换"><a href="#4-1-4-2-隐式转换" class="headerlink" title="4.1.4.2 隐式转换"></a>4.1.4.2 隐式转换</h5><p><strong>编译器默认做的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">ch + i   --&gt; i  <span class="comment">// 默认往精度高，或者所占字节长比较高的那一种数据类型去靠拢的</span></span><br><span class="line">f -d     --&gt; d  <span class="comment">// 精度高的 double</span></span><br><span class="line">(ch + i) - (<span class="keyword">float</span> - <span class="keyword">double</span>) --&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><h5 id="4-1-4-3-显式转换"><a href="#4-1-4-3-显式转换" class="headerlink" title="4.1.4.3 显式转换"></a>4.1.4.3 显式转换</h5><p><strong>强制类型转换</strong></p><h5 id="4-1-4-4-特殊性："><a href="#4-1-4-4-特殊性：" class="headerlink" title="4.1.4.4 特殊性："></a>4.1.4.4 特殊性：</h5><ol><li>布尔型bool</li><li>float类型； <code>1.0/3*3 ！= 1</code></li><li>char型是否有符号，不知道，一个未定义的行为</li><li>不同形式的0值；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="string">'0'</span>;</span><br><span class="line"><span class="string">"0"</span>;</span><br><span class="line"><span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾）</li></ol><h3 id="4-2-构造类型"><a href="#4-2-构造类型" class="headerlink" title="4.2 构造类型"></a>4.2 构造类型</h3><ul><li>数组</li><li>结构体 struct</li><li>共用体  union</li><li>枚举类型 enum</li></ul><h4 id="4-2-1-enum"><a href="#4-2-1-enum" class="headerlink" title="4.2.1  enum"></a>4.2.1  enum</h4><p>*<em>语法: *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum 标识符</span><br><span class="line">&#123;</span><br><span class="line">  成员1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> day</span><br><span class="line">&#123;</span><br><span class="line">  MON,  <span class="comment">//默认从0 开始往下排</span></span><br><span class="line">  TUS,</span><br><span class="line">  THR,</span><br><span class="line">  WES,</span><br><span class="line">  FRI = <span class="number">1</span>,  <span class="comment">// 如果给FRI赋值为1的话，那么接下来会从1继续排</span></span><br><span class="line">  SAT,</span><br><span class="line">  SUN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main () &#123;</span><br><span class="line">  <span class="keyword">enum</span> day a = FRI;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>把enum当宏使用: *</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    STATE_RUNNING = <span class="number">1</span>,</span><br><span class="line">    STATE_CANCELED,</span><br><span class="line">    STATE_OVER</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">char</span> start;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_st</span> <span class="title">job1</span>;</span></span><br><span class="line">   <span class="comment">// job1.state = STATE_CANCELED;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (job1.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_CANCELED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_OVER:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_RUNNING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 信号，操作系统后续会讲</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>这种场景可以用 enum代替宏的使用: *</em></p><p>因为宏经过预编译之后被替换掉了，宏的部分会被替换。影响调试。<br>当然enum不是万能，并不能替代宏；宏还可以传递参数</p><h4 id="4-2-2-结构体类型"><a href="#4-2-2-结构体类型" class="headerlink" title="4.2.2 结构体类型"></a>4.2.2 结构体类型</h4><ul><li>类型描述</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">  数据类型 成员<span class="number">1</span>;</span><br><span class="line">  数据类型 成员<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型嵌套</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">birthdata_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> year;</span><br><span class="line">  <span class="keyword">int</span> month;</span><br><span class="line">  <span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">birthday_st</span> <span class="title">birth</span>;</span> <span class="comment">// 嵌套定义</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> chinese;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">birthdata_st</span>  // 嵌套定义</span></span><br><span class="line"><span class="class">  &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">  &#125;birth;</span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> chinese;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义变量（变量，数组，指针），初始化及成员引用；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span>  <span class="comment">// student 不是变量名而是类型</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>]</span><br><span class="line">  .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员引用：</p><p> <code>变量名.成员名</code></p><p><code>指针名-&gt;成员名</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="keyword">int</span> bigint;</span><br><span class="line">  <span class="keyword">float</span> mfloat;</span><br><span class="line">  <span class="keyword">char</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> <span class="title">a</span> = &#123;</span></span><br><span class="line">      <span class="number">123</span>,</span><br><span class="line">      <span class="number">456.789</span>,</span><br><span class="line">      <span class="string">'a'</span>&#125;;</span><br><span class="line"></span><br><span class="line">  a.bigint = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d, %f, %c\n"</span>, a.bigint, a.mfloat, a.name);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>定义结构体变量的方式: *</em></p><p><code>student tudent1,student2;</code><br>(结构体类型名) (结构体变量名)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>]</span><br><span class="line">  .....</span><br><span class="line">&#125; lige_1, lige_2;</span><br></pre></td></tr></table></figure><p>*<em>结构体赋值: *</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike2</span> = <span class="title">mike</span>;</span>  <span class="comment">// 结构体赋值相当于copy一份给对方</span></span><br><span class="line">    mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike2.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">        mike2.name[i] = <span class="built_in">toupper</span>(mike2.name[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike2.id_num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike2.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>结构体内存 *</em> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 看上去是10个字节，结果打印出来的是16个字节；</span></span><br><span class="line"><span class="comment">// 地址对齐， 结构体对齐的概念；</span></span><br></pre></td></tr></table></figure><ul><li>一个公式</li></ul><p>address（当前准备存储的变量的地址）%（你当前要存放变量的sizeOf）<br>如果能整除的话，那么这个变量就存放在这里，如果这个表达式不成立，那么address就得 + 1；</p><p>举例子说明,首先下面是一段内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">0</span><br><span class="line">----------</span><br><span class="line">1</span><br><span class="line">----------</span><br><span class="line">2</span><br><span class="line">----------</span><br><span class="line">3</span><br><span class="line">----------</span><br><span class="line">4</span><br><span class="line">----------</span><br><span class="line">5</span><br><span class="line">----------</span><br><span class="line">6</span><br><span class="line">----------</span><br><span class="line">7</span><br><span class="line">----------</span><br><span class="line">8</span><br><span class="line">----------</span><br><span class="line">9</span><br><span class="line">----------</span><br><span class="line">10</span><br><span class="line">----------</span><br><span class="line">11</span><br><span class="line">----------</span><br><span class="line">12</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>解释 *</em></p><p>首先内存第一个地址的值是0，结构体的第一个属性是int，我们知道int占4个字节。0/4 能整除，因此第一个int占据从0-3 这个几个内存中，然后 char占1个字节，4/1能整除，因此第二个char占据了4这个内存中。接着结构体第三个属性为float，占据4个字节。内存地址5/4没法整除，当前内存++，分别到6，7，都无法整除4.到了8，8/4能整除，所以，从8打11这一段内存就存放着float这个属性，接下来又是char12/1能整除，所以char属性占据了char12这个内存地址； </p><p><code>值得注意的是，不同的操作系统内存对齐的方式是不同的；因此在socket编程中，我们传过去的结构体数据在末端一定不能做对齐；因为不知道不同平台到底是什么字节对齐的</code></p><p>*<em>结构体对齐 *</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure><p>这个操作在网络编程当中很常用；</p><p>总结</p><p>如果没有内存对齐，就是指定<strong>attribute</strong>((packed))的话，那么结构体内存的大小就是各个属性的sizeof累加的结果。如果没加就需要考虑内存对齐的问题，不同的机器内存对齐的方式是不同的。因为在跨机器编程比如socket编程当中，是需要指定<strong>attribute</strong>((packed))来确保数据的完整性和 安全性；</p><h5 id="4-2-2-1-结构体作为函数参数传递给函数（值传递，地址传递）"><a href="#4-2-2-1-结构体作为函数参数传递给函数（值传递，地址传递）" class="headerlink" title="4.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）"></a>4.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span> <span class="params">(struct student mike)</span> </span>&#123;</span><br><span class="line">    mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">           mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    renew(mike);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="number">20130123</span></span><br><span class="line">#MIKE</span><br><span class="line">#<span class="number">123</span></span><br><span class="line"><span class="meta">#mike</span></span><br></pre></td></tr></table></figure><ul><li>结论</li></ul><p>结构体的传入是 值拷贝，函数内部执行的是副本</p><h5 id="4-2-2-2-当把结构体当成形参传递的时候，意味着什么"><a href="#4-2-2-2-当把结构体当成形参传递的时候，意味着什么" class="headerlink" title="4.2.2.2 当把结构体当成形参传递的时候，意味着什么"></a>4.2.2.2 当把结构体当成形参传递的时候，意味着什么</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(struct simp_st b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 内存总是要分配一个完整的 结构体 体积所占的空间用来接受这个形参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(b)); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> *<span class="title">p</span> = &amp;<span class="title">a</span>;</span></span><br><span class="line">    func(a);</span><br><span class="line">    <span class="comment">// func(a.i, a.ch, a.f)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>小结： 所以我们一般不会这么去用。会有非常严重的性能浪费；一般我们会传递结构体指针；</li></ul><h5 id="4-2-2-3-结构体作为函数返回值时"><a href="#4-2-2-3-结构体作为函数返回值时" class="headerlink" title="4.2.2.3 结构体作为函数返回值时"></a>4.2.2.3 结构体作为函数返回值时</h5><p> 总结： 结构体作为函数返回值时，相当于copy一份给调用者</p><h5 id="4-2-2-4-指向结构体变量的指针"><a href="#4-2-2-4-指向结构体变量的指针" class="headerlink" title="4.2.2.4  指向结构体变量的指针"></a>4.2.2.4  指向结构体变量的指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> = &amp;<span class="title">mike</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*p).id_num);  <span class="comment">// 123</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 123   另外一种写法  -&gt; 指向运算符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// mike  另外一种写法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (*p).name);  <span class="comment">// mike</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-5-指向结构体变量的指针作为参数传入函数"><a href="#4-2-2-5-指向结构体变量的指针作为参数传入函数" class="headerlink" title="4.2.2.5 指向结构体变量的指针作为参数传入函数"></a>4.2.2.5 指向结构体变量的指针作为参数传入函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span> <span class="params">(struct student mike)</span> </span>&#123;</span><br><span class="line">   mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">          mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">   renew(&amp;mike);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num); <span class="comment">// 20130123    值被篡改</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);  <span class="comment">// MIKE         值被篡改</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-6-结构体数组"><a href="#4-2-2-6-结构体数组" class="headerlink" title="4.2.2.6 结构体数组"></a>4.2.2.6 结构体数组</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">myclass</span>[3] =</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="number">123</span>, &#123;<span class="string">'m'</span>,<span class="string">'k'</span>,<span class="string">'k'</span>,<span class="string">'e'</span>&#125;,</span><br><span class="line">        <span class="number">133</span>, &#123;<span class="string">'j'</span>,<span class="string">'o'</span>,<span class="string">'y'</span>&#125;,</span><br><span class="line">        <span class="number">143</span>, &#123;<span class="string">'t'</span>,<span class="string">'o'</span>,<span class="string">'m'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> * <span class="title">p</span> = &amp;<span class="title">myclass</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 123 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// mkke</span></span><br><span class="line">    p++; <span class="comment">// 跳一个结构体 体积的内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 133</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// joy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-7-链表"><a href="#4-2-2-7-链表" class="headerlink" title="4.2.2.7 链表"></a>4.2.2.7 链表</h5><ul><li>动态地 申请内存空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pint = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);   <span class="comment">// 开辟一片内存存储空间并返回起始地址； </span></span><br><span class="line"><span class="keyword">delete</span> pint;  <span class="comment">// 释放掉指针所指向的内存空间；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">// 申请一个 4个整型小数组的空间；并返回起始地址；</span></span><br><span class="line"><span class="keyword">delete</span> [] pia; <span class="comment">// 开个方括号，指的是释放掉的是一个数组区域</span></span><br></pre></td></tr></table></figure><ul><li>动态地 建立链表节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    student *next;</span><br><span class="line">&#125;</span><br><span class="line">student *head;</span><br><span class="line">head = <span class="keyword">new</span> student;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-共用体"><a href="#4-2-3-共用体" class="headerlink" title="4.2.3 共用体"></a>4.2.3 共用体</h4><blockquote><p>共用体和结构体语法很像，但截然不同的是，结构体各个成员会占用不同的内存，结构体整体内存 &gt;= sizeof（所有属性）， 因为有内存缝隙的 概念，所以有时候会大一些；</p><p>而公用体的内存体积取决于最大属性的体积；共用体所有成员占据同一段内存；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来的值覆盖掉。</p><p>共用体是硬件稀缺时代的产物；结合实际场景，比如 checkbox 男女只能同时存在一个；</p></blockquote><p><strong>语法</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 共用体名 &#123;</span><br><span class="line">  成员列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型嵌套</li></ul><p>硬件存储分大小端的；</p><p>大端格式： 数据的低位保存在高地址中；</p><p>小端格式： 数据的低位保存在低地址中；</p><ul><li>定义变量（变量，数组，指针），初始化及成员引用 (变量名.成员 指针名-&gt;成员)</li><li>占用内存大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> test_un</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> test_un a;</span><br><span class="line">  a.f = <span class="number">345.678</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">// 8  验证多个成员共用一块空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, a.f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> unioz</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">  &#125; c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> unioz x;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>)); <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(x));      <span class="comment">// 48</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数传参（值，地址）</li><li>位域</li></ul><h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5. 类型转换"></a>5. 类型转换</h2><p>存储涉及到2进制，8进制，10进制，16进制。这几种进制之间的转换首先要区别开，如何去获得一个二进制</p><h3 id="5-1-十进制转二进制"><a href="#5-1-十进制转二进制" class="headerlink" title="5.1  十进制转二进制"></a>5.1  十进制转二进制</h3><blockquote><p>除2取余，余数倒序排列</p></blockquote><p>254 -&gt; unsigned int -&gt; 32位 （4个字节）</p><p>254（10进制）-&gt; 11111110 (2进制) -&gt; 376 (8进制) -&gt; FE(16进制)</p><p>c语言程序当中是不识别二进制的</p><p>254         默认10进制<br>B11111110   二进制<br>0376        八进制<br>0xFE        十六进制</p><h3 id="5-2-补码"><a href="#5-2-补码" class="headerlink" title="5.2 补码"></a>5.2 补码</h3><blockquote><p>一个正数的补码形式就是 它二进制本身,负数的补码是它绝对值的二进制形式取反 + 1</p></blockquote><p>254 -&gt; unsigned int -&gt; 32位<br>-254 -&gt; 254 -&gt; 1111 1110 取反 + 1</p><h2 id="6-运算符和表达式"><a href="#6-运算符和表达式" class="headerlink" title="6. 运算符和表达式"></a>6. 运算符和表达式</h2><p>表达式与语句的区别</p><ul><li>运算符部分：</li></ul><ol><li>每个运算符所需要的参与运算的操作个数</li><li>结合性</li><li>优先级</li><li>运算符的特殊性</li></ol><ul><li>% 要求 除数，被除数都是整型</li></ul><ol start="5"><li>位运算的重要性</li></ol><h3 id="8-1-自增和自减"><a href="#8-1-自增和自减" class="headerlink" title="8.1 自增和自减"></a>8.1 自增和自减</h3><blockquote><p>运算符在前，先进行计算，再取变量值使用变量在前， 先取变量值使用，再进行计算</p></blockquote><h2 id="7-位运算"><a href="#7-位运算" class="headerlink" title="7. 位运算"></a>7. 位运算</h2><h3 id="3-1-gt-gt-lt-lt"><a href="#3-1-gt-gt-lt-lt" class="headerlink" title="3.1  &gt;&gt; &lt;&lt;"></a>3.1  &gt;&gt; &lt;&lt;</h3><blockquote><p>位运算（左移右移）基本等同于乘2除2运算,像汇编当中乘以多少，除以多少，几乎按这种方式来实现的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100 = <span class="number">12</span></span><br><span class="line">~i -&gt; B0011  <span class="comment">// 取反</span></span><br><span class="line"><span class="comment">// 把i往右移一位，1100  变成 110， 转化为10进制就是12</span></span><br><span class="line">i &gt;&gt; <span class="number">1</span>  --&gt; <span class="number">110</span> = <span class="number">6</span>  </span><br><span class="line"><span class="comment">// 把i往左移一位， 1100变成11000， 转化为10进制就是24</span></span><br><span class="line">i &lt;&lt; <span class="number">1</span> --&gt; <span class="number">11000</span> = <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="3-2-（取反）"><a href="#3-2-（取反）" class="headerlink" title="3.2  ~ （取反）"></a>3.2  ~ （取反）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100 = <span class="number">12</span></span><br><span class="line">~i -&gt; B0011  <span class="comment">// 取反</span></span><br></pre></td></tr></table></figure><h3 id="3-3-按位或"><a href="#3-3-按位或" class="headerlink" title="3.3  按位或"></a>3.3  按位或</h3><blockquote><p>按位或的计算原则是，同一个位上，两者有一者为1就为真，两者都为假才为假</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i|j</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">｜ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1101</span> -&gt; <span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="3-4-按位与"><a href="#3-4-按位与" class="headerlink" title="3.4  按位与"></a>3.4  按位与</h3><blockquote><p>按位与的计算原则是，同一个位上，两者有都为1就为真，否则为假</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i&amp;j</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">&amp; <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="3-5-相同为0，-不同为1"><a href="#3-5-相同为0，-不同为1" class="headerlink" title="3.5  ^ (相同为0， 不同为1)"></a>3.5  ^ (相同为0， 不同为1)</h3><blockquote><p>亦或计算原则， 同一个位上，相同为0， 不同为1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i^j</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">^ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="3-6-位运算的重要意义"><a href="#3-6-位运算的重要意义" class="headerlink" title="3.6  位运算的重要意义"></a>3.6  位运算的重要意义</h3><ul><li>将操作数中第N位 置1， 其他位不变；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num = num | 1 &lt;&lt; n // 把某一位 置1的话，把1左移 N个位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如将i 的第二位 置1</span></span><br><span class="line"><span class="keyword">int</span> i = B1011;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i = i | i &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">| <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>   <span class="comment">// 注意是把 1 左移动 N个位。 1  -&gt;  0100  空位补0</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>将操作数中第N位 清0， 其他位不变；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num = num &amp; ~(1 &lt;&lt; n) // 把某一位 置1的话，把1左移 N个位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如将i 的第1位 置0</span></span><br><span class="line"><span class="keyword">int</span> i = B1011;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i = i | i &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">| <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   <span class="comment">// -&gt; 把1左移N位取反</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li><p>测试第n位： if (num &amp; i 1 &lt;&lt; n)</p></li><li><p>从一个指定宽度的数中取出其中的某几位 （练习题）</p></li></ul><h2 id="8-内核代码位置"><a href="#8-内核代码位置" class="headerlink" title="8.  内核代码位置"></a>8.  内核代码位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /linux/include/linux</span><br><span class="line">vim list.h</span><br></pre></td></tr></table></figure><h2 id="9-宏"><a href="#9-宏" class="headerlink" title="9.  宏"></a>9.  宏</h2><ul><li>#开头的是编译预处理指令</li><li>它们不是C语言的成分，但是C语言程序离不开它们</li><li>#define 用来定义一个宏；</li><li>define (定义一个宏)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(<span class="string">"%d\n"</span>, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言程序在编译之前，会做一次编译预处理；</span></span><br><span class="line"><span class="comment">// 会把程序中所有的PI都替换成 3.14159</span></span><br></pre></td></tr></table></figure><h3 id="4-1-save-temps"><a href="#4-1-save-temps" class="headerlink" title="4.1 save-temps"></a>4.1 save-temps</h3><p>对一个 .c 文件执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 02.c --save-temps</span><br></pre></td></tr></table></figure><p>生成 四个文件</p><p><code>02.i</code><br><code>02.s</code><br><code>02.o</code><br><code>a.out</code></p><p>过程依次是</p><p><code>.c -&gt; .i -&gt; .s -&gt; .o -&gt; a.out</code></p><p>.c是源代码，经过编译预处理之后变成 .i 这种中间结果文件，<br>当中所有编译预处理指令都执行完，比如 define 宏需要替换掉;<br>然后由于编译器对 .i文件进行编译 生成汇编代码 .s文件；<br>然后汇编代码文件，进行汇编变成目标文件， 目标文件再经过链接<br>之后形成一个可执行的东西；</p><ul><li>查看 .i 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail  03.i</span><br><span class="line">tail -n 50 03.i <span class="comment"># 看03.i文件 最后 50行</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"># <span class="number">943</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">3</span> <span class="string">"03.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">2</span>*<span class="number">3.1415927</span>*<span class="number">3.0</span>); <span class="comment">// 这里明显把宏替换成了值；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 同样的可以把 “%f\n” 也替换成宏**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(FORMATTER, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-宏的缺点"><a href="#4-2-宏的缺点" class="headerlink" title="4.2 宏的缺点"></a>4.2 宏的缺点</h3><blockquote><p>不检查语法，在预处理或者编译阶段是不报错的；</p></blockquote><h3 id="4-3-define"><a href="#4-3-define" class="headerlink" title="4.3 define"></a>4.3 define</h3><ul><li>#define &lt;名字&gt; &lt;值&gt;</li><li>结尾没有 分号，因为不是C的语句</li><li>名字必须是一个单词，值可以是各种东西</li><li>在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值；</li><li>完全的文本替换</li><li>gcc –save-temps</li><li>如果一个宏的值中有其他的宏的名字，也是会被替换的</li><li>如果一个宏的值超过一行，最后一行之前的行末需要加\</li><li>宏的值后面出现的注释不会被当作宏的一部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159        <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI          <span class="comment">// PI * 2</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(FORMATTER, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159        <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI          <span class="comment">// PI * 2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRT printf(<span class="meta-string">"%f"</span>, PI)\</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI2)</span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PRT;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-没有值的宏"><a href="#4-4-没有值的宏" class="headerlink" title="4.4 没有值的宏"></a>4.4 没有值的宏</h3><ul><li>#define_DEBUG</li><li>这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了；</li></ul><h3 id="4-5-预定义的宏"><a href="#4-5-预定义的宏" class="headerlink" title="4.5 预定义的宏"></a>4.5 预定义的宏</h3><blockquote><p>用来表示一些特殊的东西，可以让编译器替我们插入一些特殊的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_LINE_     <span class="comment">//这个源代码所在当前的行号；</span></span><br><span class="line">_FILE_     <span class="comment">// 源代码的文件名</span></span><br><span class="line">_DATE_     <span class="comment">// 编译时候的日期</span></span><br><span class="line">_TIME_     <span class="comment">// 编译时候的时间</span></span><br><span class="line">_STDC_</span><br></pre></td></tr></table></figure><h3 id="4-6-像函数的宏"><a href="#4-6-像函数的宏" class="headerlink" title="4.6 像函数的宏"></a>4.6 像函数的宏</h3><p><code>#define cube(x) ((x)*(x)*(x))</code></p><p>宏可以带参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cube(x) ((x)*(x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cube(<span class="number">5</span>));  <span class="comment">// 125</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 .i 文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((<span class="number">5</span>)*(<span class="number">5</span>)*(<span class="number">5</span>)));  <span class="comment">// 被预处理成这样了；</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">2</span>*<span class="number">3.1415927</span>*<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-错误定义的宏"><a href="#4-7-错误定义的宏" class="headerlink" title="4.7 错误定义的宏"></a>4.7 错误定义的宏</h3><p><code>#define RADTODEG(x) (x*57.29578)</code><br><code>#define RADTODEG(x) (x)*57.29578</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADTODEG(x) (x*57.29578)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADTODEG(x) (x)*57.29578</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, RADTODEG(<span class="number">5</span>+<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">180</span>/RADTODEG2(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被预处理的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, (<span class="number">5</span>+<span class="number">2</span> * <span class="number">57.29578</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">180</span>/<span class="number">1</span>*<span class="number">57.29678</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 被预处理的结果是不符合我们的要求的；</p><h3 id="4-8带参数的宏的原则"><a href="#4-8带参数的宏的原则" class="headerlink" title="4.8带参数的宏的原则"></a>4.8带参数的宏的原则</h3><ul><li><p>一切都要有括号</p><ul><li>整个值要有括号，指的是整个宏的值有括号</li><li>参数出现的每个地方都要括号 </li></ul></li><li><p>#define RADTODEG(x) ((x)*57.29578)</p></li><li><p>可以带多个参数</p><ul><li>#define MIN((a,b) ((a)&gt;(b)?(b):(a))</li></ul></li><li><p>也可以组合（嵌套）使用其他宏</p></li><li><p>在大型程序的代码中使用非常普遍</p></li><li><p>可以非常复杂，如“产生”函数</p><ul><li>在# 和 ## 这两个运算符的帮助下</li></ul></li><li><p>存在中西方文化差异</p></li><li><p>部分宏会被inline函数替代 </p></li></ul><h3 id="4-9-什么时候用宏-什么时候用函数"><a href="#4-9-什么时候用宏-什么时候用函数" class="headerlink" title="4.9 什么时候用宏 什么时候用函数"></a>4.9 什么时候用宏 什么时候用函数</h3><p>应用求稳定，用函数<br>追求极致性能，用宏</p><h3 id="4-10-include-“”-还是-lt-gt"><a href="#4-10-include-“”-还是-lt-gt" class="headerlink" title="4.10 include  “” 还是 &lt;&gt;"></a>4.10 include  “” 还是 &lt;&gt;</h3><p>include 做了什么？</p><blockquote><p>include就是把头文件里头所有的文本插入到include所在.c文件的那一行.</p></blockquote><ul><li>#include有两种形式来指出要插入的文件<ul><li>“”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找</li><li>&lt;&gt; 让编译器只在指定的目录去找</li></ul></li><li>编译器自己知道自己的标准库的头文件在哪里</li><li>环境变量和编译器命令行参数也可以指定寻找头文件的目录</li></ul><h3 id="4-11-头文件-（-h文件）"><a href="#4-11-头文件-（-h文件）" class="headerlink" title="4.11 头文件 （.h文件）"></a>4.11 头文件 （.h文件）</h3><ul><li>在使用和定义这个函数的地方都应该 #include 这个头文件</li><li>一般的做法就是任何.c都有对应的同名的.h,把所有对外公开的函数的原型和全局变量的声明都放进去</li><li>在函数前面加上static 就使得它成为只能在所在的编译单元中被使用的函数</li><li>在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量</li></ul><h3 id="4-12-变量的声明"><a href="#4-12-变量的声明" class="headerlink" title="4.12 变量的声明"></a>4.12 变量的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> gAll;   <span class="comment">// 全局声明一个 变量</span></span><br></pre></td></tr></table></figure><ul><li>int i； 是变量的定义</li><li>extern int i； 是变量的声明</li></ul><h3 id="4-13声明和定义"><a href="#4-13声明和定义" class="headerlink" title="4.13声明和定义"></a>4.13声明和定义</h3><ul><li>声明是不产生的代码的东西<ul><li>函数原型</li><li>变量声明</li><li>结构声明</li><li>宏声明</li><li>枚举声明</li><li>类型声明</li><li>inline函数</li></ul></li><li>定义是产生代码的东西</li></ul><h2 id="10-typedef"><a href="#10-typedef" class="headerlink" title="10. typedef"></a>10. typedef</h2><blockquote><p>为已有的数据类型改名</p></blockquote><p><code>typedef  已有的数据类型 新名字;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  INT i;</span><br><span class="line">  <span class="built_in">printf</span>(D, i); </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-typedef-和-define的区别"><a href="#5-1-typedef-和-define的区别" class="headerlink" title="5.1  typedef 和 define的区别"></a>5.1  typedef 和 define的区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *IP;</span><br><span class="line"></span><br><span class="line">IP p,q  --&gt; <span class="keyword">int</span> *p, q;</span><br><span class="line">IP p,q  --&gt; <span class="keyword">int</span> *p, *q;</span><br></pre></td></tr></table></figure><p>** 更多示例** </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ARR[<span class="number">6</span>];    ---&gt; <span class="keyword">int</span> [<span class="number">6</span>] -&gt; ARR;</span><br><span class="line">ARR a; --&gt; <span class="keyword">int</span> a[<span class="number">6</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> <span class="title">NODE</span>;</span></span><br><span class="line">NODE a; --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> <span class="title">a</span>;</span></span><br><span class="line">NODE *p; --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">NODEP</span>;</span></span><br><span class="line">NODEP p --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;NODE, *NODEP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">FUNC</span><span class="params">(<span class="keyword">int</span>)</span></span>; --&gt; <span class="keyword">int</span>(<span class="keyword">int</span>)  FUNC;</span><br><span class="line">FUNC f; --&gt; <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> *<span class="title">FUNCP</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNCP p; ---&gt;  <span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *(*FUNCP)(<span class="keyword">int</span>);</span><br><span class="line">FUNCP p; ---&gt; <span class="keyword">int</span> *(*p)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>类型      数组名[常量表达式]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>    sheep[<span class="number">10</span>]</span><br><span class="line"><span class="keyword">int</span>      a2001[<span class="number">1000</span>]</span><br></pre></td></tr></table></figure><h2 id="11-一唯数组"><a href="#11-一唯数组" class="headerlink" title="11.  一唯数组"></a>11.  一唯数组</h2><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h3><p>  【存储类型】 数据类型 标识符 【下标】</p><h3 id="1-1-2-初始化"><a href="#1-1-2-初始化" class="headerlink" title="1.1.2 初始化"></a>1.1.2 初始化</h3><p>不初始化<br>全部初始化<br>部分初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">// 不给长度也行</span></span><br><span class="line">  <span class="keyword">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;   <span class="comment">// [1,2,0,0]   部分元素初始化</span></span><br><span class="line">  <span class="keyword">int</span> c[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;   <span class="comment">// [0,0,0,0]     部分元素初始化</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;  <span class="comment">// compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-3-元素引用"><a href="#1-1-3-元素引用" class="headerlink" title="1.1.3 元素引用"></a>1.1.3 元素引用</h3><p>  数组名【下标】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arr[M];</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">      <span class="keyword">for</span>(; i&lt;M; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;arr[i], arr[i]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x7ffee4394940-&gt;-466007712</span></span><br><span class="line"><span class="comment">// 0x7ffee4394944-&gt;32766</span></span><br><span class="line"><span class="comment">// 0x7ffee4394948-&gt;201064485</span></span><br></pre></td></tr></table></figure><ul><li><p>下标</p><p>查找块</p></li></ul><h3 id="1-1-4-数组名"><a href="#1-1-4-数组名" class="headerlink" title="1.1.4 数组名"></a>1.1.4 数组名</h3><blockquote><p>当前数组的起始位置，数组名本身就是表示地址的一个常量。</p></blockquote><p>常量： 程序执行过程当中不会发生变化的量；正因为数组名是常量，所以它不能无条件出现在数组的左边；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arr[M] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      arr[M] = &#123;<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 语法错误，数组名是常量，无法被直接赋值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">      <span class="keyword">for</span>(; i&lt;M; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;arr[i], arr[i]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-5-数组越界"><a href="#1-1-5-数组越界" class="headerlink" title="1.1.5 数组越界"></a>1.1.5 数组越界</h3><blockquote><p>溢出数组所在内存区域</p></blockquote><h4 id="1-1-6-fb"><a href="#1-1-6-fb" class="headerlink" title="1.1.6 fb"></a>1.1.6 fb</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fib[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">2</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">         fib[i] = fib[i<span class="number">-1</span>] + fib[i<span class="number">-2</span>];</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fb加个排序</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fib[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> j;</span><br><span class="line">     <span class="keyword">int</span> tmp;</span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">2</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">         fib[i] = fib[i<span class="number">-1</span>] + fib[i<span class="number">-2</span>];</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">     i=<span class="number">0</span>;</span><br><span class="line">     j=<span class="keyword">sizeof</span>(fib)/<span class="keyword">sizeof</span>(fib[<span class="number">0</span>]) <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">     &#123;</span><br><span class="line">         tmp = fib[i];</span><br><span class="line">         fib[i] = fib[j];</span><br><span class="line">         fib[j] = tmp;</span><br><span class="line">         i++;</span><br><span class="line">         j--;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="12-二维数组"><a href="#12-二维数组" class="headerlink" title="12.  二维数组"></a>12.  二维数组</h2><h3 id="1-2-1-定义，初始化"><a href="#1-2-1-定义，初始化" class="headerlink" title="1.2.1 定义，初始化"></a>1.2.1 定义，初始化</h3><p>   【存储类型】  数据类型   标识符  【行下标】 【列下标】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> b[][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[M][N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-二维数组元素引用"><a href="#1-2-2-二维数组元素引用" class="headerlink" title="1.2.2 二维数组元素引用"></a>1.2.2 二维数组元素引用</h3><p>数组名[行标][列标]<br>int a[3][4]   // 定一个三行四列的二维数组</p><h3 id="1-2-3-存储形式"><a href="#1-2-3-存储形式" class="headerlink" title="1.2.3 存储形式"></a>1.2.3 存储形式</h3><blockquote><p>顺序存储，按行存储,二维数组在内存中的存储， 是拉平的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">a[0][0]</span><br><span class="line">----------</span><br><span class="line">a[0][1]</span><br><span class="line">----------</span><br><span class="line">a[0][2]</span><br><span class="line">----------</span><br><span class="line">a[0][3]</span><br><span class="line">----------</span><br><span class="line">a[1][0]</span><br><span class="line">----------</span><br><span class="line">a[1][1]</span><br><span class="line">----------</span><br><span class="line">a[1][2]</span><br><span class="line">----------</span><br><span class="line">a[1][3]</span><br><span class="line">----------</span><br><span class="line">a[2][0]</span><br><span class="line">----------</span><br><span class="line">a[2][1]</span><br><span class="line">----------</span><br><span class="line">a[2][2]</span><br><span class="line">----------</span><br><span class="line">a[2][3]</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><ol><li>深入理解二维数组</li></ol><table><thead><tr><th>1 a[0][0]</th><th>2 a[0][1]</th><th>3 a[0][2]</th><th>4 a[0][3]</th></tr></thead><tbody><tr><td>5 a[1][0]</td><td>6 a[1][1]</td><td>7 a[1][2]</td><td>8 a[1][3]</td></tr><tr><td>9 a[2][0]</td><td>10 a[2][1]</td><td>11 a[2][2]</td><td>12 a[2][3]</td></tr></tbody></table><h3 id="1-2-4-二维数组练习题"><a href="#1-2-4-二维数组练习题" class="headerlink" title="1.2.4 二维数组练习题"></a>1.2.4 二维数组练习题</h3><h4 id="1-2-4-1-行列互换"><a href="#1-2-4-1-行列互换" class="headerlink" title="1.2.4.1 行列互换"></a>1.2.4.1 行列互换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N][M];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[j][i] = arr[i][j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-2-求最大值及其所在位置"><a href="#1-2-4-2-求最大值及其所在位置" class="headerlink" title="1.2.4.2 求最大值及其所在位置"></a>1.2.4.2 求最大值及其所在位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">max</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[M][N] = &#123;<span class="number">43</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">89</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>][<span class="number">0</span>], row =<span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]&gt;<span class="built_in">max</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">max</span>= a[i][j];</span><br><span class="line">               row = i;</span><br><span class="line">               col = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">max</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d --- %d\n"</span>, row, col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N][M];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">max</span>();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-3-求各行与各列的和"><a href="#1-2-4-3-求各行与各列的和" class="headerlink" title="1.2.4.3 求各行与各列的和"></a>1.2.4.3 求各行与各列的和</h4><p><img src="./2_arr.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sum</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[<span class="number">4</span>][<span class="number">3</span>] += a[i][j];</span><br><span class="line">            a[<span class="number">4</span>][j] += a[i][j];</span><br><span class="line">            a[i][<span class="number">3</span>] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-4-矩阵乘积"><a href="#1-2-4-4-矩阵乘积" class="headerlink" title="1.2.4.4 矩阵乘积"></a>1.2.4.4 矩阵乘积</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 2</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; ;</span><br><span class="line">     <span class="keyword">int</span> b[N][K]= &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> c[M][K];</span><br><span class="line">     <span class="keyword">int</span> i,j,k;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;N; k++)</span><br><span class="line">             &#123;</span><br><span class="line">                 c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%4d"</span>,c[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     mul();</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-5-深入理解二维数组"><a href="#1-2-5-深入理解二维数组" class="headerlink" title="1.2.5 深入理解二维数组"></a>1.2.5 深入理解二维数组</h3><p><img src="./arr_2.png" alt=""></p><h4 id="1-2-5-1-三维数组"><a href="#1-2-5-1-三维数组" class="headerlink" title="1.2.5.1 三维数组"></a>1.2.5.1 三维数组</h4><p>a[5][3][4]    数据立方体  </p><p>5 -&gt; 片<br>3 -&gt; 行<br>4 -&gt; 列</p><p>在内存中依然是打平存放；</p><h2 id="13-字符数组"><a href="#13-字符数组" class="headerlink" title="13. 字符数组"></a>13. 字符数组</h2><h3 id="1-3-1-定义，初始化，存储特点"><a href="#1-3-1-定义，初始化，存储特点" class="headerlink" title="1.3.1 定义，初始化，存储特点"></a>1.3.1 定义，初始化，存储特点</h3><p> 【存储类型】 数据类型  标识符 【下标】。。。</p><h4 id="1-3-1-1-单个字符初始化"><a href="#1-3-1-1-单个字符初始化" class="headerlink" title="1.3.1.1 单个字符初始化"></a>1.3.1.1 单个字符初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br></pre></td></tr></table></figure><p>char c[] = {‘C’, ‘h’, ‘i’, ‘n’, ‘a’};<br>// c[0] = C   c[1] = h  c[2]= i  c[3]=n  c[4]=a</p><h4 id="1-3-1-2-用字符串常量初始化"><a href="#1-3-1-2-用字符串常量初始化" class="headerlink" title="1.3.1.2 用字符串常量初始化"></a>1.3.1.2 用字符串常量初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">6</span>] = <span class="string">"hello"</span>;  <span class="comment">// 最后一位 以 '\0' 结尾</span></span><br></pre></td></tr></table></figure><p>char c[] = “China”<br>// c[0] = C   c[1] = h  c[2]= i  c[3]=n  c[4]=a  c[5]=\0</p><h3 id="1-3-2-输入输出"><a href="#1-3-2-输入输出" class="headerlink" title="1.3.2 输入输出"></a>1.3.2 输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[N], str1[N], str2[N];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>, str, str1,str2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n%s\n%s\n"</span>, str, str1,str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// how are you</span></span><br><span class="line"><span class="comment">// how</span></span><br><span class="line"><span class="comment">// are</span></span><br><span class="line"><span class="comment">// you</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-1-单词计数"><a href="#1-3-2-1-单词计数" class="headerlink" title="1.3.2.1 单词计数"></a>1.3.2.1 单词计数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">     <span class="keyword">int</span> count =<span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     gets(str);</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">             flag = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 count++;</span><br><span class="line">                 flag=<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"count = %d\n"</span>, count);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-字符数组注意事项"><a href="#1-3-3-字符数组注意事项" class="headerlink" title="1.3.3 字符数组注意事项"></a>1.3.3 字符数组注意事项</h3><blockquote><p>所有字符串都是以  \0 来结尾的；所有以 \0结尾 的字符数组都可以被看为字符串</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>] = <span class="string">"China"</span>; <span class="comment">//只可以在数组定义并初始化的时候</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用赋值语句将一个字符串常量或字符数组直接赋给另一个字符数组</span></span><br><span class="line">str1[] = <span class="string">"China"</span>   <span class="comment">// 赋值，不合法</span></span><br><span class="line">str1 = <span class="string">"China"</span>     <span class="comment">// 赋值，不合法</span></span><br><span class="line">str2 = str1        <span class="comment">// 赋值，不合法</span></span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol><li>变量与地址</li><li>指针与指针变量</li><li>直接访问与间接访问</li><li>空指针与野指针</li><li>空类型指针</li><li>定义，初始化，书写规则</li><li>指针运算</li><li>指针与数组<ol><li>指针与一维数组</li><li>指针与二维数组</li><li>指针与字符数组</li></ol></li><li>const与指针</li><li>指针数组和数组指针</li><li>多级指针</li></ol><h2 id="14-变量与地址"><a href="#14-变量与地址" class="headerlink" title="14. 变量与地址"></a>14. 变量与地址</h2><p>变量名： 变量名就是用户对某一块内存空间的抽象表示；想把这块儿内存置成100，就写<code>int i = 100;</code>变量名就是某个内存空间的别名；</p><p>地址： 指针就是地址，指针就是指向某个内存空间地址的地址值；</p><h3 id="1-1-变量的三要素"><a href="#1-1-变量的三要素" class="headerlink" title="1.1  变量的三要素"></a>1.1  变量的三要素</h3><p><code>int a = 3</code> 在内存中， 即产生 0x0012FF78，3，a 三个要素。</p><ol><li>0x0012FF78即变量的地址， 把这个变量的地址称为“指向该变量的指针”；</li><li>3即变量值；</li><li>a即变量的签名；</li></ol><h3 id="1-2-输出变量的地址"><a href="#1-2-输出变量的地址" class="headerlink" title="1.2  输出变量的地址"></a>1.2  输出变量的地址</h3><p>地址运算符 “&amp;” </p><p><code>int a = 3; printf(&quot;%x&quot;, &amp;a)</code></p><h2 id="15-指针与指针变量"><a href="#15-指针与指针变量" class="headerlink" title="15. 指针与指针变量"></a>15. 指针与指针变量</h2><p><strong>语法</strong></p><p><code>TYPE NAME = VALUE；</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;    <span class="comment">// type 为 int</span></span><br><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// type 为 int *, 而不是 int</span></span><br></pre></td></tr></table></figure><h3 id="2-1-非法操作（野指针）"><a href="#2-1-非法操作（野指针）" class="headerlink" title="2.1 非法操作（野指针）"></a>2.1 非法操作（野指针）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// 合法操作，指针一旦定义出来，就要给一个明确指向；没有的话，下回分解</span></span><br><span class="line"><span class="keyword">int</span> * p = <span class="number">0x7fffa37eac60</span>; <span class="comment">// 可能这个地址已经被占用了，一般情况下，是个非法操作；</span></span><br></pre></td></tr></table></figure><h3 id="2-2-指针变量"><a href="#2-2-指针变量" class="headerlink" title="2.2 指针变量"></a>2.2 指针变量</h3><blockquote><p>专门用于存放指针（某个变量的地址）的变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> * pointer;  <span class="comment">//定义名字为pointer的指针变量；只能存放地址！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int *pointer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) int 是指针变量的基类型  所谓基类型：指针变量指向的变量的类型</span></span><br><span class="line"><span class="comment">// 2) *   是指针运算符，表示pointer这个变量的类型</span></span><br><span class="line"><span class="comment">// 3) pointer   是指指针变量的名字</span></span><br><span class="line"></span><br><span class="line">pointer = &amp;c;</span><br><span class="line"><span class="comment">// 将变量c 的地址赋值给指针变量pointer；</span></span><br><span class="line"><span class="comment">// 赋值后，称指针变量pointer指向了变量c；</span></span><br></pre></td></tr></table></figure><p>则<code>*pointer</code>： 为pointer所指向的存储单元的内容；是变量c。<br>因此<code>*pointer</code>可以当作 变量c 来使用</p><h3 id="2-3-指针变量的地址"><a href="#2-3-指针变量的地址" class="headerlink" title="2.3 指针变量的地址"></a>2.3 指针变量的地址</h3><blockquote><p>指针变量也是变量，是变量就有地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(P, p);</span><br><span class="line">    <span class="built_in">printf</span>(P, &amp;p);   <span class="comment">// 指针变量也有地址；</span></span><br><span class="line"><span class="comment">// 0x7ffee6a26ac8</span></span><br><span class="line"><span class="comment">// 0x7ffee6a26ac0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-指针变量示例"><a href="#2-4-指针变量示例" class="headerlink" title="2.4 指针变量示例"></a>2.4 指针变量示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b=<span class="number">3</span>, temp;</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>, *p2 = <span class="literal">NULL</span>;</span><br><span class="line">    p1 = &amp;a;</span><br><span class="line">    p2 = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">if</span>(*p1 &lt; *p2) &#123;</span><br><span class="line">        temp = *p1; *p1 = *p2; *p2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p1);  <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p2);  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-指针作运算-取地址-和-取-和关系运算"><a href="#2-5-指针作运算-取地址-和-取-和关系运算" class="headerlink" title="2.5 指针作运算 (取地址 和 取 * 和关系运算)"></a>2.5 指针作运算 (取地址 和 取 * 和关系运算)</h3><p><img src="./point_01.png" alt=""></p><h4 id="2-5-1-取地址"><a href="#2-5-1-取地址" class="headerlink" title="2.5.1 取地址"></a>2.5.1 取地址</h4><blockquote><p>要获取某个变量在内存中的房间号</p></blockquote><h4 id="2-5-2-取"><a href="#2-5-2-取" class="headerlink" title="2.5.2 取*"></a>2.5.2 取*</h4><blockquote><p>找到现在给定房间号里面存放的内容</p></blockquote><h2 id="16-直接访问和间接访问"><a href="#16-直接访问和间接访问" class="headerlink" title="16. 直接访问和间接访问"></a>16. 直接访问和间接访问</h2><h3 id="3-1一级间接访问和-二级间接访问"><a href="#3-1一级间接访问和-二级间接访问" class="headerlink" title="3.1一级间接访问和 二级间接访问"></a>3.1一级间接访问和 二级间接访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">     <span class="keyword">int</span> **q = &amp;p;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(P, p); <span class="comment">// 0x7ffee92579b8</span></span><br><span class="line">     <span class="built_in">printf</span>(P, q); <span class="comment">// 0x7ffee92579b0</span></span><br><span class="line">     <span class="built_in">printf</span>(P, *q); <span class="comment">// 0x7ffee92579b8</span></span><br><span class="line"> printt(D, i); <span class="comment">// 1 直接访问</span></span><br><span class="line">     <span class="built_in">printf</span>(D, *p); <span class="comment">// 1  一级间接访问</span></span><br><span class="line">     <span class="built_in">printf</span>(D, **q);<span class="comment">// 1 二级间接访问</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-指针关系运算"><a href="#3-2-指针关系运算" class="headerlink" title="3.2 指针关系运算"></a>3.2 指针关系运算</h3><blockquote><p>当两个指针指向的是一块连续内存空间的时候， 比如两个指针指向同一个数组。在这种情况下，两个指针可以做一个关系上的比较；</p></blockquote><p><code>++ --</code></p><blockquote><p>++ – 运算实际上改变指针位置；</p></blockquote><h3 id="3-3-指针变量类型与指针变量大小"><a href="#3-3-指针变量类型与指针变量大小" class="headerlink" title="3.3  指针变量类型与指针变量大小"></a>3.3  指针变量类型与指针变量大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">float</span> *q;</span><br><span class="line"><span class="keyword">double</span> *d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(i)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(p)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(q)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(d)); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 结构体指针的大小也是8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">不管指针是多少级的指针，不管指针是什么样的类型。指针在某个平台下所占的地址空间是确定的。那既然如此为何 要给指针变量加类型呢，比如 int *p, float *q.</span></span><br><span class="line"><span class="comment">那是因为有 *p 取* 的操作，比如*q的时候，怎么就能知道去对应地址读取 4个字节呢？ 这个时候就要靠 指针变量的 变量类型加持了。所以这个变量类型之间的意义 就不尽相同了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * s;</span><br><span class="line">s = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(D, *s); <span class="comment">// 这个时候，不知道要去读取 4个字节，所以结果不是1；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-空指针与野指针"><a href="#17-空指针与野指针" class="headerlink" title="17. 空指针与野指针"></a>17. 空指针与野指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> * p = <span class="literal">NULL</span>;<span class="comment">// 指针被定义出来，还未决定指向哪里的时候，可以先指向NULL，系统上 0 号不分配给任何进程；把指针置为空是为了预防野指针；</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-野指针"><a href="#4-1-野指针" class="headerlink" title="4.1 野指针"></a>4.1 野指针</h3><blockquote><p>当前这个指针的指向是不确定的，或者压根就没有指向；但是直接使用这个指针了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p --&gt; %d\n"</span>, p ,*p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffee67879d8---&gt;0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p --&gt; %d\n"</span>, p ,*p);</span><br><span class="line"></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 段错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-1-如何杜绝野指针"><a href="#4-1-1-如何杜绝野指针" class="headerlink" title="4.1.1 如何杜绝野指针"></a>4.1.1 如何杜绝野指针</h4><blockquote><p>指针一经定义，就必须有一个明确的指向，没有暂时没有指向的话，就先指向NULL；</p></blockquote><h2 id="18-空类型"><a href="#18-空类型" class="headerlink" title="18. 空类型"></a>18. 空类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * p = <span class="literal">NULL</span>; <span class="comment">// 即 空类型 void * 是一个百搭的类型，任何类型的指针值都可以赋值给它。void * 也可以把自己的值赋值给任何类型的指针；</span></span><br></pre></td></tr></table></figure><h3 id="5-1-空类型的使用场景"><a href="#5-1-空类型的使用场景" class="headerlink" title="5.1 空类型的使用场景"></a>5.1 空类型的使用场景</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="19-运算符优先级"><a href="#19-运算符优先级" class="headerlink" title="19. 运算符优先级"></a>19. 运算符优先级</h2><blockquote><p>上面优先级比下面高</p></blockquote><ul><li>后置++ –<ul><li>前置++ – 逻辑非 (!) * &amp;   // 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高<ul><li>算术运算符<ul><li>关系运算符<ul><li>&amp;&amp;和｜｜<ul><li>赋值运算符</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li>同级别，优先级由右往左结合顺序， 离目标越近，优先级越高</li></ul><p>如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;*pointer = &amp;(*pointer)</span><br><span class="line">*&amp;a = *(&amp;a)</span><br></pre></td></tr></table></figure><p><code>(*pointer)++ 不等于 *pointer++</code></p><p>(<em>pointer)++ 是先 做取</em>运算，得到的int类型自增， <em>pointer++ 则是 指针变量移位，然后再取</em>运算</p><p><code>*pointer++ 的含义</code></p><p>假设： pointer当前所存的地址是0x00000100</p><ul><li>若pointer 的指针变量基类型是 指向一个 int或实型（占4个字节），则pointer++ 等于 iptr + 1*4 = 0x00000104</li><li>若pointer 指向一个 字符型（占1个字节），则pointer++ 等于 iptr + 1*1 = 0x00000101</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">33</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(P, a); <span class="comment">// 0x7ffee0eeda20</span></span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(P, p); <span class="comment">// 0x7ffee0eeda20</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p); <span class="comment">//  5</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p++); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p++); <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p);   <span class="comment">// 19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*p++ 是地址移动</span><br></pre></td></tr></table></figure><p>** 小结** </p><p>  指针和指针变量是不同的。指针是地址，指针变量就是一个普通的变量。<br><em>pointer指的是这个指针变量 所指向的那片内存空间里面的内容。<br>(</em>pointer)++ 不等于 *pointer++</p><h2 id="20-指针与数组"><a href="#20-指针与数组" class="headerlink" title="20. 指针与数组"></a>20. 指针与数组</h2><blockquote><p>数组名代表数组首元素的地址 （<em>数组名相当于指向数组第一个元素的指针</em>）；<br>数组名不是变量，不能给a赋值；<br><code>int *p = &amp;a[0];</code> <code>a++</code>是没有意义的（a只是个常量），但<code>p++</code>会引起p变化。<br>p可以指向数组最后一个元素以后的元素。<br>指针做加减运算时一定注意有效的范围；（指针理论上能够在内存中自由的漂移，很可能移除某一个数组的范围，有的时候就比较危险了）</p></blockquote><p><img src="./arr_1.png" alt=""></p><h3 id="7-1-数组名代表数组首元素的地址"><a href="#7-1-数组名代表数组首元素的地址" class="headerlink" title="7.1 数组名代表数组首元素的地址"></a>7.1 数组名代表数组首元素的地址</h3><blockquote><p>数组名是指向数组第一个元素的指针；</p></blockquote><ul><li>对于数组a[10], 数组名 a代表数组 a[10]中第一个元素a[0]的地址； 即  a 与 a[0]等价</li><li>注意： a是地址常量，不是变量，不能给a赋值；</li></ul><h3 id="7-2-创建一个匿名数组"><a href="#7-2-创建一个匿名数组" class="headerlink" title="7.2  创建一个匿名数组"></a>7.2  创建一个匿名数组</h3><blockquote><p>指针和数组的关系，其实就是一种引用方式而已。你的一维数组名和一级指针之间的关系其实除了一个是变量，一个是常量之外。完全可以等价代换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> [<span class="number">3</span>])&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(D, p[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-利用指针变量引用数组元素"><a href="#7-3-利用指针变量引用数组元素" class="headerlink" title="7.3 利用指针变量引用数组元素"></a>7.3 利用指针变量引用数组元素</h3><ul><li>若定义<ul><li>数组 int a[10]; 指针 int * pointer;</li></ul></li><li>则:<ul><li>pointer =a; 等价于pointer = &amp;a[0];</li></ul></li><li>数组访问<br>  pointer+ i; 等价于 a+i; 等价于 &amp;a[i];<br>  *(pointer+i);  等价于 *(a+i); 等价于a[i];</li><li>表示形式<br>  pointer[i] 等价于 *(pointer+i);</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = a; <span class="comment">// a 是 数组的地址，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);   <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p++);  <span class="comment">// 4    ++的含义是先使用p，然后再++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);     <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *++p);   <span class="comment">// 6   前+ 和 后+ 跟js一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">0</span>]); <span class="comment">// 因为p=a了，所以p[0] 即a[0]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-抽象公式"><a href="#7-4-抽象公式" class="headerlink" title="7.4 抽象公式"></a>7.4 抽象公式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a[i]: a[i] = *(a+i) = *(p+i) = p[i];</span></span><br><span class="line"><span class="comment">// &amp;a[i]: &amp;a[i] = a+i = p+i = &amp;p[i];</span></span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><h3 id="7-5-重置指针变量"><a href="#7-5-重置指针变量" class="headerlink" title="7.5 重置指针变量"></a>7.5 重置指针变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d/n"</span>, p++);</span><br><span class="line"></span><br><span class="line">p = a; <span class="comment">// 这里需要 重置一下 p的指针；不然会数组越界；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *p++);</span><br></pre></td></tr></table></figure><h3 id="7-6-需要注意的问题"><a href="#7-6-需要注意的问题" class="headerlink" title="7.6 需要注意的问题"></a>7.6 需要注意的问题</h3><blockquote><p><code>int * p = &amp;a[0];</code> , <code>* a++</code>是没有意义的（因为a是个常量），但<code>p++</code>会引起<code>p</code>变化；<code>* p</code>可以指向数组最后一个元素以后的元素；（因为p是内存中的一个指针），所以指针做加减运算时一定注意有效的范围。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],</span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;a[<span class="number">1</span>];</span><br><span class="line">iPtr--;     <span class="comment">// 指向&amp;a[0]</span></span><br><span class="line">*iPtr = <span class="number">3</span>;  <span class="comment">// a[0] = 3</span></span><br><span class="line">iPtr--;     <span class="comment">// 指向&amp;a[-1], dangerous</span></span><br><span class="line">*iPtr = <span class="number">6</span>;  <span class="comment">// (damage)  对内存造成损坏，影响内存中其他的变量</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a[<span class="number">3</span>];</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p++); <span class="comment">// 100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p--); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *--p); <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7-指向二维数组的指针"><a href="#7-7-指向二维数组的指针" class="headerlink" title="7.7 指向二维数组的指针"></a>7.7 指向二维数组的指针</h3><h4 id="7-7-1-遍历数组元素"><a href="#7-7-1-遍历数组元素" class="headerlink" title="7.7.1 遍历数组元素"></a>7.7.1 遍历数组元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">for</span> (p= &amp;a[<span class="number">0</span>][<span class="number">0</span>]   ;p &lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">12</span>; p++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x7ffeefbff4f0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4f4</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4f8</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4fc</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff500</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff504</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff508</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff50c</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff510</span></span><br><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff514</span></span><br><span class="line"><span class="comment">// 19</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff518</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff51c</span></span><br><span class="line"><span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>如上所示， 会将这个数组的内容都打印出来了，因为二维数组会被拉平存储到一段连续的内存空间当中</p><h4 id="7-7-2-二维数组行列指针"><a href="#7-7-2-二维数组行列指针" class="headerlink" title="7.7.2 二维数组行列指针"></a>7.7.2 二维数组行列指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> D <span class="meta-string">"%d\n"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> P <span class="meta-string">"%p\n"</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"&amp;a = %p, &amp;a+1 = %p\n"</span>, &amp;a, &amp;a+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%&amp;a[0][0] = %p, &amp;a[1][0] = %p\n"</span>, &amp;a[<span class="number">0</span>][<span class="number">0</span>], &amp;a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%p---&gt;%d\n"</span>, &amp;a[i][j], a[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;a = 0x7ffefe385370,            &amp;a+1 = 0x7ffefe3853a0</span></span><br><span class="line"><span class="comment">// %&amp;a[0][0] = 0x7ffefe385370, &amp;a[1][0] = 0x7ffefe385380</span></span><br><span class="line"><span class="comment">// 0x7ffefe385370---&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffefe385374---&gt;2</span></span><br><span class="line"><span class="comment">// 0x7ffefe385378---&gt;3</span></span><br><span class="line"><span class="comment">// 0x7ffefe38537c---&gt;4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffefe385380---&gt;5</span></span><br><span class="line"><span class="comment">// 0x7ffefe385384---&gt;6</span></span><br><span class="line"><span class="comment">// 0x7ffefe385388---&gt;7</span></span><br><span class="line"><span class="comment">// 0x7ffefe38538c---&gt;8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffefe385390---&gt;9</span></span><br><span class="line"><span class="comment">// 0x7ffefe385394---&gt;10</span></span><br><span class="line"><span class="comment">// 0x7ffefe385398---&gt;11</span></span><br><span class="line"><span class="comment">// 0x7ffefe38539c---&gt;12</span></span><br></pre></td></tr></table></figure><p>小结：</p><blockquote><p>所以a除了是二维数组的数组名（地址常量）之外，在使用上比较偏向一个指向行指针。</p></blockquote><h4 id="7-7-3-能够接收二维数组指针的指针变量"><a href="#7-7-3-能够接收二维数组指针的指针变量" class="headerlink" title="7.7.3 能够接收二维数组指针的指针变量"></a>7.7.3 能够接收二维数组指针的指针变量</h4><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">     p  =&amp;a[i][j]; <span class="comment">// *(a+0) , *a</span></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++,p++) <span class="comment">// for (i=0; i&lt;12; i++)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);  <span class="comment">//     printf("%d ", p[i]);</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 1 2 3 4 5 6 7 8 9 10 11 12</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="7-7-4-另一段程序"><a href="#7-7-4-另一段程序" class="headerlink" title="7.7.4 另一段程序"></a>7.7.4 另一段程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>], i,j;</span><br><span class="line">p = a;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;    <span class="comment">// i&lt;3 代表行号， j&lt;4 代表列号；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; *(*(p+i)+j); <span class="comment">// 正误判断： 访问元素 a[i][j]</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>程序分析</em></p><p>从 p = a 开始</p><ul><li><p>a相当于指向a[3][4]的“第一个元素”的指针；</p></li><li><p>所谓“第一个元素”是指一个“包含4个int型元素的一维数组”；</p></li><li><p>所以，a相当于一个“包含4个int型元素的一维数组”的地址；</p></li><li><p>因此，p的基类型应该是： “包含4个int型元素的一维数组”</p></li><li><p>变量定义语句的语法为： int (*p)[4];</p></li></ul><p>*p(数组)</p><p>p -&gt; |    (<em>p)[0] | (</em>p)[1] | (<em>p)[2] | (</em>p)[3] |</p><h4 id="7-7-5-利用指针变量引用多维数组中的数组"><a href="#7-7-5-利用指针变量引用多维数组中的数组" class="headerlink" title="7.7.5 利用指针变量引用多维数组中的数组"></a>7.7.5 利用指针变量引用多维数组中的数组</h4><p><em>(</em>(p+i)+j)是什么？</p><ul><li><p>p 是指向一个“包含4个int型元素的一维数组”；</p></li><li><p>p+i 是第i+1个“包含4个int型元素的一维数组”的地址;</p></li><li><p>p+i 等价于&amp;a[i]；</p></li><li><p>*(p+i)等价于a[i]；</p></li><li><p>*(p+i)+j 等价于 a[i]+j; // 这里把a[i] 当作一个指针来看 因此， a[i]+j 等价于 &amp;a[i][j];</p></li><li><p><em>(</em>(p+i)+j) 等价于 a[i][j];</p></li></ul><h3 id="7-8-指针与字符数组"><a href="#7-8-指针与字符数组" class="headerlink" title="7.8  指针与字符数组"></a>7.8  指针与字符数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> s[] = <span class="string">"i love coding!"</span>; <span class="comment">// codeing</span></span><br><span class="line"> <span class="keyword">char</span> *p = s+<span class="number">7</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s+<span class="number">7</span>);</span><br><span class="line"> <span class="built_in">puts</span>(s);</span><br><span class="line"> <span class="built_in">puts</span>(p); <span class="comment">// puts(p) 相当于把p的起始位置拿进来， 依次输出，直到碰到\0 为止；</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// coding!</span></span><br><span class="line"><span class="comment">// i love coding!</span></span><br><span class="line"><span class="comment">// coding!</span></span><br></pre></td></tr></table></figure><h4 id="7-8-1-字符数组拼接"><a href="#7-8-1-字符数组拼接" class="headerlink" title="7.8.1  字符数组拼接"></a>7.8.1  字符数组拼接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// str = "world"  false</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"world123"</span>); <span class="comment">// 覆盖原来数组空的每一项</span></span><br><span class="line"><span class="built_in">puts</span>(str); <span class="comment">// world123</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// world123</span></span><br></pre></td></tr></table></figure><h4 id="7-8-2-字符串长度和字符串字节数"><a href="#7-8-2-字符串长度和字符串字节数" class="headerlink" title="7.8.2 字符串长度和字符串字节数"></a>7.8.2 字符串长度和字符串字节数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d ,%d"</span>, <span class="keyword">sizeof</span>(str), <span class="built_in">strlen</span>(str));  <span class="comment">// 6, 5</span></span><br></pre></td></tr></table></figure><h4 id="7-8-3-字符指针跟字符数组的区别"><a href="#7-8-3-字符指针跟字符数组的区别" class="headerlink" title="7.8.3 字符指针跟字符数组的区别"></a>7.8.3 字符指针跟字符数组的区别</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(str); <span class="comment">// 8   指针变量不分类型 ， 64位系统下长度都是8个字节， 32位系统为4个字节；</span></span><br><span class="line"><span class="built_in">strlen</span>(str); <span class="comment">// 5   字符串长度</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"world"</span>); <span class="comment">// 段错误， 字符指针跟字符数组的区别就在于此。因为str 指向的是一个 字符串常量的地址， strcpy是一个覆盖写操作，显然，企图去更改一个常量是无效的。之所以是常量，是串常量，这个串在当前存储位置是特殊的。在使用上不允许被改变和覆盖。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line">str = <span class="string">"world123"</span>; <span class="comment">//更改指针指向；</span></span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h2 id="21-字符串与指针"><a href="#21-字符串与指针" class="headerlink" title="21. 字符串与指针"></a>21. 字符串与指针</h2><blockquote><p>指向字符串的指针</p></blockquote><ul><li>指向字符串的指针变量： char a[10]; char *p; p=a;</li></ul><p>数组和字符串太接近了。那怎么去定义指向字符串的指针呢？也很简单， 我首先定义一个字符数组，它就是用来存放字符串的。 我们以前讲过字符串和字符数组其实区别就在于有没有最后的反斜杠零， 本质上都是字符数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *s = c;</span><br><span class="line"><span class="built_in">printf</span>(P, s); <span class="comment">// 0x7ffee2066aba</span></span><br><span class="line"><span class="built_in">printf</span>(P, c); <span class="comment">// 0x7ffee2066aba</span></span><br><span class="line"><span class="built_in">printf</span>(S, s); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">printf</span>(S, c); <span class="comment">// hello </span></span><br><span class="line">s++;</span><br><span class="line"><span class="built_in">printf</span>(S, s); <span class="comment">// ello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-字符串指针举例"><a href="#8-1-字符串指针举例" class="headerlink" title="8.1  字符串指针举例"></a>8.1  字符串指针举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>] = <span class="string">"ABC"</span>;</span><br><span class="line"><span class="keyword">char</span> *pc;</span><br><span class="line">pc = <span class="string">"hello"</span>; <span class="comment">// 虽然 hello赋值给了pc，但是却不能通过pc去改变hello， 因为hello是常量，常量在内存中被放在特殊的地方了；这片区域不允许修改；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// hello</span></span><br><span class="line">pc++;                  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ello</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// e</span></span><br><span class="line">pc = <span class="built_in">buffer</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc;           <span class="comment">// ABC</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-const与指针"><a href="#22-const与指针" class="headerlink" title="22. const与指针"></a>22. const与指针</h2><blockquote><p>const是把某些内容常量化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>; <span class="comment">// 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针常量</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><h3 id="9-1-变量值常量化"><a href="#9-1-变量值常量化" class="headerlink" title="9.1  变量值常量化"></a>9.1  变量值常量化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>; <span class="comment">// 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure><h3 id="9-2-常量指针"><a href="#9-2-常量指针" class="headerlink" title="9.2  常量指针"></a>9.2  常量指针</h3><blockquote><p>指针的指向可以发生变化，但是指针所指向当前的那块内存的值是不可以发生变化的；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">  <span class="comment">//   float *p = &amp;pi;  // 警告： initialization discards ‘const’ qualifier from pointer target type</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">float</span> *p = &amp;pi;</span><br><span class="line">    *p = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, *p);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> chart * pathname, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 常量指针，保护pathname值不被篡改</span></span><br></pre></td></tr></table></figure><h3 id="9-3-指针常量"><a href="#9-3-指针常量" class="headerlink" title="9.3  指针常量"></a>9.3  指针常量</h3><p><code>int *const p;</code></p><blockquote><p>指针常量指 指针的指向永远不能发生变化；但是指针指向的值可以有变化；</p></blockquote><h4 id="9-3-1-引用"><a href="#9-3-1-引用" class="headerlink" title="9.3.1 引用"></a>9.3.1 引用</h4><p>引用是C++语言的概念，C中并没有；</p><p>在《thinking c++》一书中有这么一句，“A reference (&amp;) is like a constant pointer that is automatically<br>dereferenced.” （引用（＆）就像一个常量指针，它会自动 取消引用）</p><p> 这句话是什么意思呢？</p><h3 id="9-4-如何区分到底是-常量指针，还是指针常量"><a href="#9-4-如何区分到底是-常量指针，还是指针常量" class="headerlink" title="9.4  如何区分到底是 常量指针，还是指针常量"></a>9.4  如何区分到底是 常量指针，还是指针常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p; <span class="comment">// 如果先碰到const关键字，就把常量先念出来</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p; <span class="comment">// 如果先看到 *，就把指针先念出来</span></span><br></pre></td></tr></table></figure><h3 id="9-5-两个const修饰"><a href="#9-5-两个const修饰" class="headerlink" title="9.5  两个const修饰"></a>9.5  两个const修饰</h3><p><code>const int *const p;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;i;</span><br><span class="line"></span><br><span class="line">p = &amp;j; <span class="comment">// warning 因为p是只读的，不能更改指向；</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// warning 因为*p 也是只读的；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-6-指向符号常量的指针"><a href="#9-6-指向符号常量的指针" class="headerlink" title="9.6  指向符号常量的指针"></a>9.6  指向符号常量的指针</h3><p><code>const int * p;</code></p><p>当把p定义成一个指向符号常量的指针的时侯， 然后再让这个p指向什么东西， 它所指向的那个东西就不能被修改了。我们就不能通过p再去修改 它所指向的那个东西了。</p><ul><li>深坑啊,要留意</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">78</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a;</span><br><span class="line">*p1 = <span class="number">58</span>;   <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line">p1 = &amp;b;    <span class="comment">// （可以给 p1 重新赋值）</span></span><br><span class="line">*p1 = <span class="number">68</span>;    <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line"><span class="built_in">printf</span>(D, *p1);  <span class="comment">// 28</span></span><br><span class="line">p1 = &amp;c;      <span class="comment">// （可以给 p1 重新赋值）</span></span><br><span class="line">*p1 = <span class="number">88</span>;     <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line"><span class="built_in">printf</span>(D, *p1)  <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-7-再谈一维数组的地址"><a href="#9-7-再谈一维数组的地址" class="headerlink" title="9.7 再谈一维数组的地址"></a>9.7 再谈一维数组的地址</h3><p><em>数组名相当于指向数组第一个元素的指针</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// a[1]的地址，管辖范围只有a[1]</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// a[1]的地址，管辖范围是整个a的内存空间</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// a[2]的地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 跳出了a的内存范围，理论上是 a[5]的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(P, a);           <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, a+<span class="number">1</span>);         <span class="comment">// 0x7ffee42adab4   跨越4个字节</span></span><br><span class="line"><span class="built_in">printf</span>(P, &amp;a);          <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, &amp;a+<span class="number">1</span>);        <span class="comment">// 0x7ffee42adac0  // 跨越16个字节</span></span><br><span class="line"><span class="built_in">printf</span>(P, *(&amp;a));       <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, *(&amp;a) + <span class="number">1</span>);   <span class="comment">// 0x7ffee42adab4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据C语言的规范 *(&amp;a)  等同于 a; 即a数组第一个元素的内存地址<br>*(&amp;a) + 1 等同于 a+1; 即a数组第二个元素的内存地址</p><p>&amp;a的管辖范围是整个数组a。c语言规范中，当它前面出现*时，管辖范围降级，即堕落成了 a[0]的地址；</p><h3 id="9-8-总结"><a href="#9-8-总结" class="headerlink" title="9.8  总结"></a>9.8  总结</h3><blockquote><p>数组名相当于指向数组第一个元素的指针</p></blockquote><ul><li>&amp;运算符 - 升级</li></ul><p>若 a 是指向数组第一个元素的指针，即a相当于 &amp;a[0];</p><ul><li>&amp;a是“指向数组”的指针；&amp;a+1将跨越16个字节；</li><li>&amp;a相当于管辖范围 “上升” 了一级;</li></ul><ul><li>*运算符 - 降级<br>*a是数组的第一个元素a[0]；即 *a等价于a[0]；</li></ul><ul><li>*a 相当于管辖范围“下降”了一级；      </li></ul><h3 id="9-9-指向二维数组的指针"><a href="#9-9-指向二维数组的指针" class="headerlink" title="9.9  指向二维数组的指针"></a>9.9  指向二维数组的指针</h3><ul><li><p>二维数组的定义</p><ul><li>二维数组a[3][4]包含三个元素： a[0] a[1] a[2]</li><li>每个元素都是一个“包含四个整型元素”的数组</li></ul></li></ul><p>| 1 a[0][0]  | 2 a[0][1] | 3 a[0][2] | 4 a[0][3] |<br>| 5 a[1][0]  | 6 a[1][1] | 7 a[1][2] | 8 a[1][3] |<br>| 9 a[2][0]  | 10 a[2][1]| 11 a[2][2]| 12 a[2][3]| </p><pre><code>- 二维数组的第一个元素是a[0];- a[0]是一个“包含四个整形元素”的一维数组；</code></pre><p><img src="./pointer_1.png" alt=""></p><p>推论</p><p>a 与 &amp;a[0] 等价<br>a[0] 与  &amp;a[0][0] 等价<br>a[0] 与 <em>a 等价<br>a[0][0] 与 *</em>a 等价</p><h3 id="9-10-总结"><a href="#9-10-总结" class="headerlink" title="9.10  总结"></a>9.10  总结</h3><p>三条规律<br>1） 数组名相当于指向数组第一个元素的指针；<br>2） &amp;E相当于把E的管辖范围上升了一个级别；<br>3） *E相当于把E的管辖范围下降了一个级别；</p><h2 id="23-指针与函数"><a href="#23-指针与函数" class="headerlink" title="23. 指针与函数"></a>23. 指针与函数</h2><h3 id="10-1-指针用作函数参数"><a href="#10-1-指针用作函数参数" class="headerlink" title="10.1 指针用作函数参数"></a>10.1 指针用作函数参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> *q1, <span class="keyword">int</span> *q2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (*q1 &lt; *q2)&#123;</span><br><span class="line">        temp = *q1;</span><br><span class="line">        *q1 = *q2;</span><br><span class="line">        *q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, *p1, *p2;</span><br><span class="line">    <span class="built_in">scanf</span>(a);</span><br><span class="line">    <span class="built_in">scanf</span>(b);</span><br><span class="line">    p1 = &amp;a; p2 = &amp;b;</span><br><span class="line">    Rank(p1, p2); <span class="comment">// 指针传递，即地址传递</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-将数组名作为实参"><a href="#10-2-将数组名作为实参" class="headerlink" title="10.2 将数组名作为实参"></a>10.2 将数组名作为实参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">total += *p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, total); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">sum(a, <span class="number">3</span>); <span class="comment">// 将数组名作为实参赋给指针型形参</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-“数组名”-做形参"><a href="#10-3-“数组名”-做形参" class="headerlink" title="10.3  “数组名” 做形参"></a>10.3  “数组名” 做形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 编译器将形参数组名 作为 指针变量来处理！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span><span class="number">-1</span>; i++) &#123;</span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>) = *<span class="built_in">array</span> + *(<span class="built_in">array</span>+<span class="number">1</span>); <span class="comment">// 数组从第二项开始，每一项都等于自己加上前一项的和；</span></span><br><span class="line"><span class="built_in">array</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(a, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序里，把一个指针变量或者是数组的名字，传递给一个函数的时候，是挺危险的，因为这个函数拿到的，是这个变量或者是数组的地址， 它拿到了地址，它就可以直接对地址里面存放的这些值，进行肆意的修改，那有没有一种办法，可以呢 使我既能够把这个地址传递给某个函数，又能够确保不让这个函数随意的修改这片地址里面的值呢？ </p><ul><li>如何 “限制” 指针的功能<ul><li>如何“限制”指针实参的功能</li></ul></li></ul><h3 id="10-4-即指向符号常量的指针"><a href="#10-4-即指向符号常量的指针" class="headerlink" title="10.4  即指向符号常量的指针"></a>10.4  即指向符号常量的指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 补充为const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span><span class="number">-1</span>; i++) &#123;</span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>) = *<span class="built_in">array</span> + *(<span class="built_in">array</span>+<span class="number">1</span>); <span class="comment">//  array变成常量之后，无法修改</span></span><br><span class="line"><span class="built_in">array</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(a, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符号常量声明语句</p><ol><li>const 数组类型 常量名 = 常量值；</li><li>数据类型 const 常量名 = 常量值；</li></ol><h3 id="10-5-指针用作函数返回值"><a href="#10-5-指针用作函数返回值" class="headerlink" title="10.5  指针用作函数返回值"></a>10.5  指针用作函数返回值</h3><p>函数的返回值可以是多种类型</p><ol><li>返回整形数据的函数<br> <code>int max(int x, int y);</code></li><li>返回指针类型数据的函数<br> <code>int *min(int x, int y)</code><ul><li>函数名字前面表示函数的类型 *</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int arr[][4] 除了这么定义，还可以 int *(arr)[4]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *pt;</span><br><span class="line">pt = *(arr+n<span class="number">-1</span>) + m<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> (pt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="built_in">get</span>(a, <span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析一下返回结果， 又一个需要注意的深坑</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = getInt1();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">// 这里会打印未知数，也可能会打印20；为什么呢，因为随着getInt1的运行时完毕，导致它函数内部的所有引用被释放了。所以返回的地址&amp;value1 指向的内存空间被释放掉了；所以谁也不会知道这个地址现在存放的是个啥，如果该块内存没有被新写入值，那么还是20；新写入的话，那就是新的未知量了；</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value2 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p, *q;</span><br><span class="line">p = getInt1();</span><br><span class="line">q = getInt2();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);  <span class="comment">// 这里大概率会是30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那既然如此，有什么办法解决这个问题</p><ul><li>静态局部变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value2 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p, *q;</span><br><span class="line">p = getInt1();</span><br><span class="line">q = getInt2();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *q);  <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>什么是静态局部变量</li></ul><p>** 静态局部变量 ** </p><blockquote><p>函数中局部变量的值在函数调用结束后不消失而保留原值</p></blockquote><p>即其占用的存储单元不释放，在下一次该函数调用时，仍可以继续使用该变量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;  <span class="comment">// 有点像 hooks，只初始化一次，后续不再重新将其赋值为0；</span></span><br><span class="line">    a = a+<span class="number">1</span>;</span><br><span class="line">    b = b+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i&lt;<span class="number">3</span>;i--)&#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>小结</li></ul><p>指针与函数</p><pre><code>指针用做函数参数    函数拿到地址可对其所指内容进行修改；    可以使用const来“限制”指针的功能；指针用做函数返回值    必须确保函数返回的地址是有意义的；    返回全局变量或静态局部变量；</code></pre><h2 id="24-指针数组和数组指针"><a href="#24-指针数组和数组指针" class="headerlink" title="24. 指针数组和数组指针"></a>24. 指针数组和数组指针</h2><h3 id="11-1-数组指针"><a href="#11-1-数组指针" class="headerlink" title="11.1 数组指针"></a>11.1 数组指针</h3><blockquote><p>归根结底是一个指针，是指向数组的指针。</p></blockquote><p>【存储类型】 数据类型 （*指针名）【下标】 = 值；</p><p>如： <code>int (*p)[3]; ---&gt; type name  ----&gt;  int[3] *p</code></p><p>解析：</p><blockquote><p>定义一个指针变量 p, 用来指向 <code>int[3]</code> 类型的元素的起始位置。原来 <code>int * p</code> 的时候，<code>p+1</code> 的操作是移动一个 <code>int</code> 的大小。如果p的类型 变成了 <code>int [3]</code>的话，<code>p+1</code>的操作是一下移动三个 int 元素的大小。所以数组指针是在某种 大小的数组中进行移动。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = *a;</span><br><span class="line">     <span class="keyword">int</span> (*q)[N]= a;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p %p\n"</span>, a, a+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p %p\n\n"</span>, q, q+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt;M; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%p -&gt; %d\n"</span>, *(a+i)+j, *(*(a+i)+j));</span><br><span class="line">            <span class="comment">//  printf("%p -&gt; %d\n", *(q+i)+j, *(*(q+i)+j)); // a 和 q现在是等价的，区别只是一个是常量，一个是变量；</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 0x7ffd6f5ad200</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 0x7ffd6f5ad200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 -&gt; 1</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f4 -&gt; 2</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f8 -&gt; 3</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1fc -&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad200 -&gt; 5</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad204 -&gt; 6</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad208 -&gt; 7</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad20c -&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad210 -&gt; 9</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad214 -&gt; 10</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad218 -&gt; 11</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad21c -&gt; 12</span></span><br></pre></td></tr></table></figure><h3 id="11-2-指针数组"><a href="#11-2-指针数组" class="headerlink" title="11.2 指针数组"></a>11.2 指针数组</h3><blockquote><p>归根结底是一个数组</p></blockquote><p>【存储类型】 数据类型 * 数组名 【长度】</p><p>如： <code>int * arr[3]; ---&gt; TYPE NAME ---&gt; int *[3] arr;</code></p><h3 id="11-3-指针数组与数组指针的区别"><a href="#11-3-指针数组与数组指针的区别" class="headerlink" title="11.3 指针数组与数组指针的区别"></a>11.3 指针数组与数组指针的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, k, j;</span><br><span class="line">  <span class="comment">//  指针数组</span></span><br><span class="line">  <span class="keyword">char</span> *name[<span class="number">5</span>] = &#123;<span class="string">"Follow me"</span>, <span class="string">"Basic"</span>, <span class="string">"Great"</span>, <span class="string">"Fortran"</span>, <span class="string">"Computer"</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> *tmp;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span> - <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    k = i;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name[k], name[j]) &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != i)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp = name[i];</span><br><span class="line">      name[i] = name[k];</span><br><span class="line">      name[k] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(name[i]);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-多级指针"><a href="#25-多级指针" class="headerlink" title="25 .多级指针"></a>25 .多级指针</h2><p><img src="./point_01.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line1 <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Line2 <span class="keyword">int</span> *p = &amp;num</span><br><span class="line">Line3 <span class="keyword">int</span> *p1 = p;</span><br><span class="line">Line4 <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">Line5 <span class="keyword">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure><p>多级指针的本质，只是C语言的一个书写规范<br>，事实上任何指针都可以保存任何地址；</p><ul><li>多级指针的存储的值的推理过程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line1 <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Line2 <span class="keyword">int</span> *p = &amp;num</span><br><span class="line">Line3 <span class="keyword">int</span> *p1 = p;</span><br><span class="line">Line4 <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">Line5 <span class="keyword">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li>函数的定义</li><li>函数的传参</li><li>函数的调用 （嵌套和递归）</li><li>函数与数组</li><li>函数与指针 （指针函数， 函数指针， 函数指针数组）</li></ol><h2 id="26-函数的定义"><a href="#26-函数的定义" class="headerlink" title="26. 函数的定义"></a>26. 函数的定义</h2><p>  数据类型  函数名 （【数据类型 形参名 。。。】）</p><blockquote><p>函数的类型是指 函数的返回值的数据类型</p></blockquote><h3 id="1-1-1-main函数"><a href="#1-1-1-main函数" class="headerlink" title="1.1.1 main函数"></a>1.1.1 main函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  argc： 参数计数器，统计终端上多少个参数传进来</span></span><br><span class="line"><span class="comment">  *argv[]： 列表，用来传递刚才命令行传递进来的参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *argv[]是一个数组；</span></span><br><span class="line"><span class="comment">  argv 是数组名；</span></span><br><span class="line"><span class="comment">  char* 指数组中每个元素的类型为 char*；即字符指针</span></span><br><span class="line"><span class="comment">  argv 即字符数组指针的首地址；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"argc=%d\n"</span>, argc);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main /etc/a*.conf</span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>因为shell 会自动解析通配符，把结果都解析出来。</p><p><img src="./function_01.png" alt=""><br>图示：char * argv 数组模型</p><p>** 输出argv** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">// for (i=0; i&lt;argc; i++)</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; argv[i] !=<span class="literal">NULL</span>; i++)</span><br><span class="line">    <span class="built_in">puts</span>(argv[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-C语言使用函数之前也需要先声明"><a href="#1-1-2-C语言使用函数之前也需要先声明" class="headerlink" title="1.1.2 C语言使用函数之前也需要先声明"></a>1.1.2 C语言使用函数之前也需要先声明</h3><blockquote><p>函数在使用前都要声明，除非被调用函数的定义部分已经出现在主调函数之前, 在C语言中，函数声明就是函数原型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 需要先声明，因为main函数在 printf_hello函数上面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  printf_hello();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-函数的传参"><a href="#27-函数的传参" class="headerlink" title="27. 函数的传参"></a>27. 函数的传参</h2><h3 id="1-2-1-值传递"><a href="#1-2-1-值传递" class="headerlink" title="1.2.1 值传递"></a>1.2.1 值传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_value</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="comment">// 参数i j 随着 print_value 调用栈执行结束就释放掉了。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d%d\n"</span>, i,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i =<span class="number">3</span>; l = <span class="number">5</span>;</span><br><span class="line">  printf_value(i,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-地址传递"><a href="#1-2-2-地址传递" class="headerlink" title="1.2.2 地址传递"></a>1.2.2 地址传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> * i, <span class="keyword">int</span> * j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  tmp = *i;</span><br><span class="line">  *i = *j;</span><br><span class="line">  *j = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i =<span class="number">3</span>; l = <span class="number">5</span>;</span><br><span class="line">  swap(&amp;i,&amp;l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-函数的调用（嵌套调用-和-递归调用）"><a href="#28-函数的调用（嵌套调用-和-递归调用）" class="headerlink" title="28. 函数的调用（嵌套调用 和 递归调用）"></a>28. 函数的调用（嵌套调用 和 递归调用）</h2><h3 id="1-3-1-函数的调用方式"><a href="#1-3-1-函数的调用方式" class="headerlink" title="1.3.1 函数的调用方式"></a>1.3.1 函数的调用方式</h3><ol><li>函数调用作为独立语句，<code>stringPrint();</code></li><li>函数作为表达式的一部分,<code>number = max(numA,numB)/2;</code></li><li>以实参形式出现在其他函数的调用中,<code>number = min(sum(-5, 100), numC);</code></li></ol><h3 id="1-3-2-嵌套调用"><a href="#1-3-2-嵌套调用" class="headerlink" title="1.3.2 嵌套调用"></a>1.3.2 嵌套调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">max</span>(a,b,c) - <span class="built_in">min</span>(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = a &lt; b? a :b;</span><br><span class="line">  <span class="keyword">return</span> tmp &lt; c ? tmp : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = a &gt; b? a :b;</span><br><span class="line">  <span class="keyword">return</span> tmp &gt; c ? tmp : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>, c = <span class="number">10</span>;</span><br><span class="line">  result = minus(a,b,c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-函数与数组"><a href="#39-函数与数组" class="headerlink" title="39. 函数与数组"></a>39. 函数与数组</h2><h3 id="1-4-1-函数与一唯数组"><a href="#1-4-1-函数与一唯数组" class="headerlink" title="1.4.1 函数与一唯数组"></a>1.4.1 函数与一唯数组</h3><p>问题：封装一个printf_arr方法来遍历数组；应该如何定义 printf_arr 的行参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_arr</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"printf_arr ---&gt; %p\n"</span>, a); <span class="comment">// 传入的是 数组 a的 起始地址；</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++) <span class="comment">// 是因为 a的 sizeof为 8， 所以只能访问数组前2位</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);   <span class="comment">// 1， 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main ---&gt; %p\n"</span>,a ); <span class="comment">// a 即 &amp;a, 即 &amp;a[0];</span></span><br><span class="line">  printf_arr(a);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main       ---&gt; 0x7ffd84a62eb0</span></span><br><span class="line"><span class="comment">// printf_arr ---&gt; 0x7ffd84a62eb0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(p));<span class="comment">// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(a)); <span class="comment">// 20，整个数组所占内存的大小，因为每个int是 4个字节；</span></span><br><span class="line">  print_arr(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 解决方法**</p><p>将数组的长度，当做第二个参数传入给 子函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(p));<span class="comment">// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]); <span class="comment">// p[i] 与 *(p+i) 等价</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(a)); <span class="comment">// 20，整个数组所占内存的大小，因为每个int是 4个字节；</span></span><br><span class="line">  print_arr(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_arr</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 当 p[] 作为行参时， [] 等同于 * 因此 int p[] 即为 int *p</span></span><br></pre></td></tr></table></figure><p>** 示例** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>  a[N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">   a            -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  *a即*(a+<span class="number">0</span>)    -&gt;  <span class="keyword">int</span></span><br><span class="line">  a[<span class="number">0</span>]          -&gt;  <span class="keyword">int</span></span><br><span class="line">  &amp;a[<span class="number">3</span>]         -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  p[i]          -&gt;  <span class="keyword">int</span></span><br><span class="line">  p             -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  *p            -&gt;  <span class="keyword">int</span></span><br><span class="line">  p+<span class="number">1</span>           -&gt;  <span class="keyword">int</span> *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 逆序** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j, m, tmp;</span><br><span class="line">  m = (n <span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;=m;i++) &#123;</span><br><span class="line">    j = n <span class="number">-1</span> -i;</span><br><span class="line">    tmp = p[i];</span><br><span class="line">    p[i] = p[j];</span><br><span class="line">    p[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">0</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  func(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a));</span><br><span class="line">   <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-函数与二维数组"><a href="#1-4-2-函数与二维数组" class="headerlink" title="1.4.2 函数与二维数组"></a>1.4.2 函数与二维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; M; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure><p>问题： 同样的把输出放到一个独立的函数中去，也就是考察一下 二维数组应该如何给函数传参</p><blockquote><p>这个问题实际考察点在于 二维数组如何 过实参给函数，以及函数的二维数组行参应该如何定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种, 用一个二维数组的指针去接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> (*p) [N], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(*p+i)); <span class="comment">// 关键点在这里， 首先 p 指向的是 int [3] 这个类型。所以需要降级 为列指针</span></span><br><span class="line">      &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M*N); <span class="comment">// *a  === a[0] === *(a+0)</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种，用一个普通一维数组指针去接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n);</span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(p+i));</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(&amp;a[<span class="number">0</span>][<span class="number">0</span>], M*N); <span class="comment">// 传递的是列指针</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span>  <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> (*p)[N],<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(*(p+i)+j));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M,N);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四种</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> p[][N],<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>, p[i][j]);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M,N);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>** 小结 ** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[M][N] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">int</span> * p = *a;</span><br><span class="line"><span class="keyword">int</span> (*q)[N] = a;</span><br></pre></td></tr></table></figure><p>二维数组 参与传参的一些基本内容</p><table><thead><tr><th align="left">a[i][j]</th><th align="center">*(a+i)+j</th><th align="right">a[i]+j</th><th align="center">p[i]</th><th align="right">*p</th></tr></thead><tbody><tr><td align="left">q[i][j]</td><td align="center">*q === *(q+0)</td><td align="right">q</td><td align="center">p+3</td><td align="right">q+2</td></tr><tr><td align="left">int</td><td align="center">int *</td><td align="right">int *</td><td align="center">int</td><td align="right">int</td></tr><tr><td align="left">int</td><td align="center">int *</td><td align="right">int (*)[N]</td><td align="center">int *</td><td align="right">int (*)[N]</td></tr></tbody></table><h4 id="1-4-2-1-示例：-求平均数"><a href="#1-4-2-1-示例：-求平均数" class="headerlink" title="1.4.2.1 示例： 求平均数"></a>1.4.2.1 示例： 求平均数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">average_score</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum/n;</span><br><span class="line">&#125;</span><br><span class="line">find_num(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+num)+i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">  average_score(*a, M*N);</span><br><span class="line">  find_num(a, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-2-二维数组什么时候传行指针，什么时候传列指针"><a href="#1-4-2-2-二维数组什么时候传行指针，什么时候传列指针" class="headerlink" title="1.4.2.2  二维数组什么时候传行指针，什么时候传列指针"></a>1.4.2.2  二维数组什么时候传行指针，什么时候传列指针</h4><blockquote><p>当不区分行列的时候，可以把它当作一个大的一维数组。那就传递指针。 如果要区分行列来做某件事情的时候，那就需要把行指针传递过去。</p></blockquote><h3 id="1-4-3-函数与字符数组"><a href="#1-4-3-函数与字符数组" class="headerlink" title="1.4.3 函数与字符数组"></a>1.4.3 函数与字符数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(str2, str1);  <span class="comment">//实现了拷贝</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">mystrcpy</span><span class="params">(<span class="keyword">char</span> * dest, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ret = dest;</span><br><span class="line">  <span class="keyword">if</span> (dest != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">while</span>((*dest++ = *src++) != <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  mystrcpy(str2, str1);  <span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line">  <span class="built_in">puts</span>(str2); <span class="comment">// 测试一下</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个 mystrncpy 用于拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">mystrncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i&lt;n &amp;&amp; (dest[i] = src[i]); i++)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">for</span> (; i&lt;n; i++)</span><br><span class="line">    dest[i] = <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  mystrncpy(str2, str1, <span class="number">5</span>);  <span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line">  <span class="built_in">puts</span>(str2); <span class="comment">// 测试一下</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-函数与指针"><a href="#30-函数与指针" class="headerlink" title="30.  函数与指针"></a>30.  函数与指针</h2><blockquote><p>指针函数, 函数指针, 函数指针数组</p></blockquote><h3 id="1-5-1-指针函数"><a href="#1-5-1-指针函数" class="headerlink" title="1.5.1 指针函数"></a>1.5.1 指针函数</h3><blockquote><p>一个函数的返回值为指针，即为指针函数</p></blockquote><p><code>返回值 * 函数名(形参);</code><br><code>如： int * fun(int);</code></p><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从find_num 这个函数说起，这个函数并不纯，而且没有实现它的功能；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, *(*(p+num)+i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">  <span class="keyword">float</span> ave;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  find_num(a, num); <span class="comment">// find_num 的设计不应该没有返回值；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span> <span class="comment">// 将find_num 设计成为一个指针函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; M <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> *(p+num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> * res;</span><br><span class="line">    <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> ave;</span><br><span class="line">    <span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line">    res = find_num(a, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d"</span>,res[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-函数指针"><a href="#1-5-2-函数指针" class="headerlink" title="1.5.2 函数指针"></a>1.5.2 函数指针</h3><blockquote><p>一个指针指向的是函数， 在C语言里面。你并不能用一个普通变量去接收 函数啊，或者结构体等等数据类型，必须要使用相同的类型变量去接收相同的类型。比如函数要用函数指针变量去接收；</p></blockquote><p>  类型  (<em>指针名) （形参）<br>  如： int (</em>p)(int);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个函数指针</span></span><br><span class="line"></span><br><span class="line">  p = add; <span class="comment">// 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址， 也可以写成 p = &amp;add;这里之所以省略，是因为函数名(add)本身就是一个地址。所以在指针和函数的指向关系当中，地址符可以省略。同样的 `ret = *p(a, b)`； p前面的 *也可以省略。 `ret = p(a, b)`。指向函数的指针，让这个指针指向某一个函数的入口地址。下面通过指针来传参数就如同通过函数名来传参数是一样的；</span></span><br><span class="line">  ret = p(a, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-函数指针数组"><a href="#1-5-3-函数指针数组" class="headerlink" title="1.5.3 函数指针数组"></a>1.5.3 函数指针数组</h3><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret1, ret2;</span><br><span class="line">  <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个函数指针</span></span><br><span class="line">  <span class="keyword">int</span> (*q)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 这里面定义两个相同的 函数指针有点浪费</span></span><br><span class="line"></span><br><span class="line">  p = add; <span class="comment">// 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址</span></span><br><span class="line">  ret1 = p(a, b);</span><br><span class="line">  ret2 = q(a, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret2;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-引出函数指针数组"><a href="#1-5-4-引出函数指针数组" class="headerlink" title="1.5.4 引出函数指针数组"></a>1.5.4 引出函数指针数组</h3><p>语法：</p><p>类型 （<em>数组名[下标]）（形参）；<br>如: int (</em>arr[N])(int);<br>arr是一个数组，这个数组有N个元素。这N个元素都是指向函数的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret1, ret2;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">// int (int, int) *funcp[2];  funcp这个数组有两个指针，两个指针都是指向 int (int, int) 类型的函数； 转换一种写法就是</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> (*funcp[<span class="number">2</span>])(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// p = add;</span></span><br><span class="line">  <span class="comment">// q = sub;</span></span><br><span class="line">  <span class="comment">// ret1 = p(a, b);</span></span><br><span class="line">  <span class="comment">// ret2 = q(a, b);</span></span><br><span class="line"></span><br><span class="line">  funcp[<span class="number">0</span>] = add;</span><br><span class="line">  funcp[<span class="number">1</span>] = sub;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret1 = funcp[i](a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf("%d\n",ret1);</span></span><br><span class="line">  <span class="comment">// printf("%d\n",ret2;</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-指向指针函数的函数指针数组"><a href="#1-5-5-指向指针函数的函数指针数组" class="headerlink" title="1.5.5 指向指针函数的函数指针数组"></a>1.5.5 指向指针函数的函数指针数组</h3><p>  <code>int *(*func[N])(int)</code></p><h2 id="31-函数的执行过程"><a href="#31-函数的执行过程" class="headerlink" title="31. 函数的执行过程"></a>31. 函数的执行过程</h2><h3 id="1-6-1-main函数-——-函数执行的入口"><a href="#1-6-1-main函数-——-函数执行的入口" class="headerlink" title="1.6.1 main函数 —— 函数执行的入口"></a>1.6.1 main函数 —— 函数执行的入口</h3><ul><li>遇到函数，开辟内存空间；</li><li>在内存空间再碰到函数时候，<ul><li>初始化内嵌函数；</li><li>传递参数</li><li>保存外层函数执行空间</li><li>执行完毕后。。。。释放函数执行栈</li><li>接收函数的返回值</li><li>恢复现场，从断点处继续执行</li></ul></li></ul><h3 id="1-6-2-参数的传递"><a href="#1-6-2-参数的传递" class="headerlink" title="1.6.2 参数的传递"></a>1.6.2 参数的传递</h3><ul><li><p>实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”。即拷贝</p></li><li><p>函数调用时，系统给行参分配存储单元，并将实参对应的值传递给形参；</p><p>P.S. 实参与形参的类型必须相同或可以兼容；</p></li></ul><h3 id="1-6-3-变量的作用范围"><a href="#1-6-3-变量的作用范围" class="headerlink" title="1.6.3 变量的作用范围"></a>1.6.3 变量的作用范围</h3><p>局部变量与全局变量</p><blockquote><p>根据变量在程序中作用范围的不同，可以将变量分为局部变量和全局变量</p></blockquote><ul><li><p>局部变量<br>在函数内或块内定义，只在这个函数或块内其作用的变量；</p></li><li><p>全局变量<br>在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。</p></li><li><p>当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量</p></li></ul><h2 id="32-数组与函数"><a href="#32-数组与函数" class="headerlink" title="32. 数组与函数"></a>32. 数组与函数</h2><ul><li>数组名 做函数参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">30</span>;</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  change(a);  <span class="comment">// 地址传递， 数组的名字代表着数组所在的地址；</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d, %d,"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>]); <span class="comment">// 30 50</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-缓冲区"><a href="#33-缓冲区" class="headerlink" title="33.  缓冲区"></a>33.  缓冲区</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// __FUNCTION__ 当前所在的函数，</span></span><br><span class="line">    <span class="comment">// __LINE__ 当前所在的行数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s:%d]before"</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s:%d]after"</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">./<span class="built_in">printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发现两个printf都没打印出来东西</span></span><br></pre></td></tr></table></figure><p>** 缓冲机制 **</p><blockquote><p>由于使用了终端设备，所以原本默认是全缓冲模式变成了行缓冲模式。所以printf是遇到了 \n 才去刷新缓冲区的。或者是当前等缓冲区满了去自动刷新。\n 是去强制刷新缓冲区。 没有加\n  那个“before”这句话就放到了输出缓冲区当中，什么时候刷新呢？ 要么等程序结束自动刷新IO，要么就是遇到一些强制刷新的函数iflush 这种，要么就等到缓冲区攒满了一次性去刷新。</p></blockquote><h2 id="34-动态内存管理"><a href="#34-动态内存管理" class="headerlink" title="34. 动态内存管理"></a>34. 动态内存管理</h2><blockquote><p>在编写程序时，通常并不知道需要处理的数据量，或者难以评估所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，就需要动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存管理原理；</p></blockquote><p>以下几个函数都存在标准 stdlib.h 中</p><h3 id="1-9-1-malloc-calloc-（分配新的内存区域）"><a href="#1-9-1-malloc-calloc-（分配新的内存区域）" class="headerlink" title="1.9.1 malloc  calloc （分配新的内存区域）"></a>1.9.1 malloc  calloc （分配新的内存区域）</h3><p><code>void *malloc(size_t, size);</code></p><p>它会在堆上分配这块连续的内存空间，并返回起始地址；</p><p><code>void *calloc(size_t nmemb, size_t size)</code></p><p>一个成员 size个大小，nmemb这么多成员的空间；连续申请多块 size大的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// 用完记得释放掉内存， 在同一个函数中做到 malloc 和 free一一对应</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span> ;i&lt;num; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>*<em>一道面试题 (提示： 这个程序当中已经产生了内存泄漏) *</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// p在这个函数当中是一个局部变量，随着func执行完毕之后，这块内存空间会丢失。导致内存泄漏，只有随着操作系统中这个进程结束掉，才会释放这100个单位的内存</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  func(p, num);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> **p, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 用一个二级指针来接受</span></span><br><span class="line">  *p = <span class="built_in">malloc</span>(n);           <span class="comment">// 此时*p 就是main函数中的p</span></span><br><span class="line">  <span class="keyword">if</span> (*p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  func(&amp;p, num);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改法二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  p = func(p, num);  <span class="comment">// 用p 来接触返回值</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-2-realloc-（调整已分配的内存区域）"><a href="#1-9-2-realloc-（调整已分配的内存区域）" class="headerlink" title="1.9.2   realloc  （调整已分配的内存区域）"></a>1.9.2   realloc  （调整已分配的内存区域）</h3><p><code>void *realloc(void *ptr, size_t size);</code></p><p>重新分配一块动态的内存空间 ,比如之前用malloc calloc分配的内存空间太大或者太小，现在把 起始地址传进去(第一个参数); 然后要size 大小的这么一段(第二个参数)；所以 realloc会在当前地址往下继续扩展，凑足size返回回来；当然，如果*ptr 开始的这个区段，没有一整块size大小的空间，那么就会去别的内存上面去寻找。直到找到之后，再返回那块空间的起始地址回来；</p><h3 id="1-9-3-free-（释放已分配的内存区域）"><a href="#1-9-3-free-（释放已分配的内存区域）" class="headerlink" title="1.9.3  free  （释放已分配的内存区域）"></a>1.9.3  free  （释放已分配的内存区域）</h3><blockquote><p>原则， 谁申请谁释放， （防止内存泄露）；如果不能做到在同一函数中做到谁申请谁释放 就在同一模块中做到这些；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 测试地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p--&gt;%d\n"</span>, *p); <span class="comment">// 0xa--&gt;0</span></span><br><span class="line"><span class="built_in">free</span>(p);                 <span class="comment">// 正确的做法是</span></span><br><span class="line">p = <span class="literal">NULL</span>;                <span class="comment">// 正确的做法是，一个指针free了之后，立即赋值 NULL</span></span><br><span class="line"><span class="comment">// free 代表着 变量p对于那片 内存空间 没有了 控制权限；所以free之后要 p = NULL</span></span><br><span class="line">*p = <span class="number">123</span>;                <span class="comment">// 实际上这是个野指针，该块内存释放掉了，有可能被其他人用来声明变量了。这里重新赋值，相当于可能把别人的变量给覆盖了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);      <span class="comment">// 123</span></span><br><span class="line">                         <span class="comment">// 测试地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p--&gt;%d\n"</span>, *p); <span class="comment">// 0x7b--&gt;145574408</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts declaration files</title>
      <link href="2021/01/21/ts-declaration-files/"/>
      <url>2021/01/21/ts-declaration-files/</url>
      
        <content type="html"><![CDATA[<h2 id="10-Declaration-Files"><a href="#10-Declaration-Files" class="headerlink" title="10. Declaration Files"></a>10. Declaration Files</h2><h3 id="10-1-Declaration-Reference"><a href="#10-1-Declaration-Reference" class="headerlink" title="10. 1 Declaration Reference"></a>10. 1 Declaration Reference</h3><p>本节显示一些API的文档以及该API的示例用法，并说明如何编写相应的声明。</p><h4 id="10-1-1-具有属性的对象"><a href="#10-1-1-具有属性的对象" class="headerlink" title="10.1.1 具有属性的对象"></a>10.1.1 具有属性的对象</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">let</span> result = myLib.makeGreeting(<span class="string">"hello, world"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"The computed greeting is:"</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = myLib.numberOfGreetings;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeGreeting</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">let</span> <span class="title">numberOfGreetings</span>: <span class="title">number</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-2-Overloaded-Functions"><a href="#10-1-2-Overloaded-Functions" class="headerlink" title="10.1.2  Overloaded Functions"></a>10.1.2  Overloaded Functions</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="keyword">let</span> x : Widget = getWidget(<span class="number">43</span>);</span><br><span class="line"><span class="keyword">let</span> arr: Widget[] = getWidget(<span class="string">"all of them"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getWidget</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">Widget</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getWidget</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">Widget</span>[]</span>;</span><br></pre></td></tr></table></figure><h4 id="10-1-3-Reusable-Types-Interfaces"><a href="#10-1-3-Reusable-Types-Interfaces" class="headerlink" title="10.1.3 Reusable Types (Interfaces)"></a>10.1.3 Reusable Types (Interfaces)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line">greet(&#123;</span><br><span class="line">  greeting: <span class="string">"hello world"</span>,</span><br><span class="line">  duration: <span class="number">4000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">interface</span> GreetingSettings &#123;</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  duration?: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">setting: GreetingSettings</span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h4 id="10-1-4-Reusable-Types-Type-Aliases"><a href="#10-1-4-Reusable-Types-Type-Aliases" class="headerlink" title="10.1.4 Reusable Types (Type Aliases)"></a>10.1.4 Reusable Types (Type Aliases)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"howdy"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MyGreeter <span class="keyword">extends</span> Greeter &#123;&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">"hello"</span>);</span><br><span class="line">greet(getGreeting);</span><br><span class="line">greet(<span class="keyword">new</span> MyGreeter());</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用类型别名来简化类型：</span></span><br><span class="line"><span class="keyword">type</span> GreetingLike = <span class="built_in">string</span> | <span class="function">(<span class="params">(<span class="params"></span>)=&gt; <span class="built_in">string</span></span>) | <span class="params">MyGreeter</span>;</span></span><br><span class="line"><span class="function"><span class="params">declare</span> <span class="params">function</span> <span class="params">greet</span>(<span class="params">g: GreetingLike</span>): <span class="params">void</span>;</span></span><br></pre></td></tr></table></figure><h4 id="10-1-5-组织类型"><a href="#10-1-5-组织类型" class="headerlink" title="10.1.5 组织类型"></a>10.1.5 组织类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Greeter(<span class="string">"Hello"</span>);</span><br><span class="line">g.log(&#123; verbose: <span class="literal">true</span> &#125;);</span><br><span class="line">g.alert(&#123; modal: <span class="literal">false</span>, title: <span class="string">"Current Greeting"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用命名空间去组织类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> GreetingLib &#123;</span><br><span class="line">  <span class="keyword">interface</span> LogOptions &#123;</span><br><span class="line">    verbose?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> AlertOptions &#123;</span><br><span class="line">    modal: <span class="built_in">boolean</span>;</span><br><span class="line">    title?: <span class="built_in">string</span>;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用嵌套的命名空间来声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> GreetingLib.Options &#123;</span><br><span class="line">  <span class="comment">// Refer to via GreetingLib.Options.Log</span></span><br><span class="line">  <span class="keyword">interface</span> Log &#123;</span><br><span class="line">    verbose?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> Alert &#123;</span><br><span class="line">    modal: <span class="built_in">boolean</span>;</span><br><span class="line">    title?: <span class="built_in">string</span>;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-6-Classes"><a href="#10-1-6-Classes" class="headerlink" title="10.1.6 Classes"></a>10.1.6 Classes</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">const</span> myGreeter = <span class="keyword">new</span> Greeter(<span class="string">"hello, world"</span>);</span><br><span class="line">myGreeter.greeting = <span class="string">"howdy"</span>;</span><br><span class="line">myGreeter.showGreeting();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SpecialGreeter <span class="keyword">extends</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"Very special greetings"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用 declare class 来描述类或类对象。类可以具有属性和方法以及构造函数。</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">greeting: <span class="built_in">string</span></span>);</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  showGreeting(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-7-Global-Variables"><a href="#10-1-7-Global-Variables" class="headerlink" title="10.1.7 Global Variables"></a>10.1.7 Global Variables</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="built_in">console</span>.log(f00/<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> foo: <span class="built_in">number</span></span><br></pre></td></tr></table></figure><h4 id="10-1-8-Global-Functions"><a href="#10-1-8-Global-Functions" class="headerlink" title="10.1.8 Global Functions"></a>10.1.8 Global Functions</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line">greet(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">str: <span class="built_in">string</span></span>):<span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h3 id="10-2-Library-Structures"><a href="#10-2-Library-Structures" class="headerlink" title="10.2 Library Structures"></a>10.2 Library Structures</h3><p>针对不同类型的库，编写对应类型的声明文件。你是通过cdn获取这些库还是通过npm获取；你是require引入还是import引入；</p><h4 id="10-2-1-模块化的库"><a href="#10-2-1-模块化的库" class="headerlink" title="10.2.1 模块化的库"></a>10.2.1 模块化的库</h4><p>几乎每个现代的Node.js库都属于模块家族。这些类型的库仅在带有模块加载器的JS环境中工作。例如，express仅在Node.js中有效，并且必须使用CommonJS require函数加载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someLib = <span class="built_in">require</span>(<span class="string">"someLib"</span>);</span><br><span class="line">define(..., [<span class="string">'someLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">someLib</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>从代码中识别模块库</strong></p><ul><li>Unconditional calls to <code>require</code> or <code>define</code></li><li>Declarations like <code>import * as a from &#39;b&#39;;</code> or <code>export c;</code></li><li>Assignments to <code>exports</code> or <code>module.exports</code></li></ul><p>They will rarely have:</p><ul><li>Assignments to properties of <code>window</code> or <code>global</code></li></ul><h5 id="10-2-1-1-Modules-d-ts"><a href="#10-2-1-1-Modules-d-ts" class="headerlink" title="10.2.1.1 Modules.d.ts"></a>10.2.1.1 Modules.d.ts</h5><ul><li>常见的Commonjs 模式</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getArrayLength,</span><br><span class="line">  maxInterval,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This can be described by the following .d.ts:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br></pre></td></tr></table></figure><ul><li>Es  module</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This would have the following .d.ts equivalent:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Default Exports</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="regexp">/hello( world)?/</span>;</span><br><span class="line"><span class="comment">// .d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> helloWorld: <span class="built_in">RegExp</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> helloWorld;</span><br></pre></td></tr></table></figure><p>CommonJS中的一种导出样式是导出函数。由于函数也是对象，因此可以在导出中添加额外的字段。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.slice;</span><br><span class="line">&#125;</span><br><span class="line">getArrayLength.maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = getArrayLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Which can be described with:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 需要在 tsconfig.json 中设置 esModuleInterop: true</span></span><br></pre></td></tr></table></figure><p>如果没有在 tsconfig.json 中设置 esModuleInterop: true</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> getArrayLength &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 export= 语法</span></span><br><span class="line"><span class="keyword">export</span> = getArrayLength;</span><br></pre></td></tr></table></figure><ul><li>模块中的类型</li></ul><p>可能需要提供一种不存在的JavaScript代码类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    length: getArrayLength(arr),</span><br><span class="line">    firstObject: arr[<span class="number">0</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getArrayMetadata,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// described</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayMetadata = &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  firstObject: <span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>):<span class="title">ArrayMetadata</span></span>;</span><br><span class="line"><span class="comment">// 泛型优化版</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayMetadata&lt;ArrType&gt; = &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  firstObject: ArrType | <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>&lt;<span class="title">ArrType</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  arr: ArrType[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ArrayMetadata</span>&lt;<span class="title">ArrType</span>&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li>Namespaces in Module Code</li></ul><p>试图描述JavaScript运行时的关联可能很棘手。如果类似ES模块的语法没有提供足够的工具来描述导出，则可以使用名称空间。</p><p>您可能有足够复杂的类型来描述，因此您选择在.d.ts中对它们进行命名空间：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时可用的JavaScript类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> API &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">baseURL: <span class="built_in">string</span></span>);</span><br><span class="line">  getInfo(opts: API.InfoRequest): API.InfoResponse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This namespace is merged with the API class and allows for consumers, and this file</span></span><br><span class="line"><span class="comment">// to have types which are nested away in their own sections.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> API &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> InfoRequest &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> InfoResponse &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用<code>export as namespace</code>声明模块将在UMD上下文中的全局范围内可用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> namespaces moduleName;</span><br></pre></td></tr></table></figure><ul><li>Template</li></ul><p>为了让您了解所有这些部分如何组合在一起，这里是制作新模块时的参考.d.ts。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果此模块是在模块加载程序环境之外加载时公开全局变量“ myLib”的UMD模块，请在此处声明该全局变量。</span></span><br><span class="line"><span class="comment">否则，删除此声明。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module exports functions, declare them like so.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myOtherFunction</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ You can declare types that are available via importing the module */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ You can declare properties of the module using const, let, or var */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myField: <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><ul><li>库文件布局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myLib</span><br><span class="line">  +---- index.js</span><br><span class="line">  +---- foo.js</span><br><span class="line">  +---- bar</span><br><span class="line">         +---- index.js</span><br><span class="line">         +---- baz.js</span><br></pre></td></tr></table></figure><ul><li>声明文件布局应为</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@types&#x2F;myLib</span><br><span class="line">  +---- index.d.ts</span><br><span class="line">  +---- foo.d.ts</span><br><span class="line">  +---- bar</span><br><span class="line">         +---- index.d.ts</span><br><span class="line">         +---- baz.d.ts</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thest could be imported as</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"myLib"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"myLib/foo"</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">require</span>(<span class="string">"myLib/bar"</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">require</span>(<span class="string">"myLib/bar/baz"</span>);</span><br></pre></td></tr></table></figure><ul><li>Testing your types</li></ul><p>If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:</p><blockquote><ol><li>Create a new folder in <code>node_modules/@types/[libname]</code></li><li>Create an <code>index.d.ts</code> in that folder, and copy the example in</li><li>See where your usage of the module breaks, and start to fill out the index.d.ts</li><li>When you’re happy, clone <a href="https://github.com/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped/DefinitelyTyped</a> and follow the instructions in the README.</li></ol></blockquote><p>Otherwise</p><blockquote><ol><li>Create a new file in the root of your source tree: <code>[libname].d.ts</code></li><li>Add <code>declare module &quot;[libname]&quot; { }</code></li><li>Add the template inside the braces of the declare module, and see where your usage breaks</li></ol></blockquote><h5 id="10-2-1-2-module-function"><a href="#10-2-1-2-module-function" class="headerlink" title="10.2.1.2  module:function"></a>10.2.1.2  module:function</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greeter <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line">greeter(<span class="number">2</span>);</span><br><span class="line">greeter(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></table></figure><p>如果模块可以像一个函数一样被调用，需使用module-function 模版</p><p>要同时通过UMD和模块引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file for function modules.</span></span><br><span class="line"><span class="comment"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that ES6 modules cannot directly export class objects.</span></span><br><span class="line"><span class="comment">// This file should be imported using the CommonJS-style:</span></span><br><span class="line"><span class="comment">//   import x = require('[~THE MODULE~]');</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Alternatively, if --allowSyntheticDefaultImports or</span></span><br><span class="line"><span class="comment">// --esModuleInterop is turned on, this file can also be</span></span><br><span class="line"><span class="comment">// imported as a default import:</span></span><br><span class="line"><span class="comment">//   import x from '[~THE MODULE~]';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Refer to the TypeScript documentation at</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require</span></span><br><span class="line"><span class="comment">// to understand common workarounds for this limitation of ES6 modules.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when</span></span><br><span class="line"><span class="comment"> *~ loaded outside a module loader environment, declare that global here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this declaration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myFuncLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This declaration specifies that the function</span></span><br><span class="line"><span class="comment"> *~ is the exported object from the file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> = Greeter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This example shows how to have multiple overloads for your function */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">Greeter</span>.<span class="title">NamedReturnType</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">length: <span class="built_in">number</span></span>): <span class="title">Greeter</span>.<span class="title">LengthReturnType</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want to expose types from your module as well, you can</span></span><br><span class="line"><span class="comment"> *~ place them in this block. Often you will want to describe the</span></span><br><span class="line"><span class="comment"> *~ shape of the return type of the function; that type should</span></span><br><span class="line"><span class="comment"> *~ be declared in here, as this example shows.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ Note that if you decide to include this namespace, the module can be</span></span><br><span class="line"><span class="comment"> *~ incorrectly imported as a namespace object, unless</span></span><br><span class="line"><span class="comment"> *~ --esModuleInterop is turned on:</span></span><br><span class="line"><span class="comment"> *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> LengthReturnType &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> NamedReturnType &#123;</span><br><span class="line">    firstName: <span class="built_in">string</span>;</span><br><span class="line">    lastName: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*~ If the module also has properties, declare them here. For example,</span></span><br><span class="line"><span class="comment">   *~ this declaration says that this code is legal:</span></span><br><span class="line"><span class="comment">   *~   import f = require('super-greeter');</span></span><br><span class="line"><span class="comment">   *~   console.log(f.defaultName);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> defaultName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> defaultLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-1-2-module-class"><a href="#10-2-1-2-module-class" class="headerlink" title="10.2.1.2  module:class"></a>10.2.1.2  module:class</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeter = <span class="built_in">require</span>(<span class="string">"super-greeter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">new</span> Greeter();</span><br><span class="line">greeter.greet();</span><br></pre></td></tr></table></figure><p>如果导出的对象是一个类的话；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file for class modules.</span></span><br><span class="line"><span class="comment"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that ES6 modules cannot directly export class objects.</span></span><br><span class="line"><span class="comment">// This file should be imported using the CommonJS-style:</span></span><br><span class="line"><span class="comment">//   import x = require('[~THE MODULE~]');</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Alternatively, if --allowSyntheticDefaultImports or</span></span><br><span class="line"><span class="comment">// --esModuleInterop is turned on, this file can also be</span></span><br><span class="line"><span class="comment">// imported as a default import:</span></span><br><span class="line"><span class="comment">//   import x from '[~THE MODULE~]';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Refer to the TypeScript documentation at</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require</span></span><br><span class="line"><span class="comment">// to understand common workarounds for this limitation of ES6 modules.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when</span></span><br><span class="line"><span class="comment"> *~ loaded outside a module loader environment, declare that global here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this declaration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myClassLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This declaration specifies that the class constructor function</span></span><br><span class="line"><span class="comment"> *~ is the exported object from the file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> = MyClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Write your module's methods and properties in this class */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> MyClass &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">customGreeting?: <span class="built_in">string</span></span>);</span><br><span class="line"></span><br><span class="line">  greet: <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  myMethod(opts: MyClass.MyClassMethodOptions): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want to expose types from your module as well, you can</span></span><br><span class="line"><span class="comment"> *~ place them in this block.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ Note that if you decide to include this namespace, the module can be</span></span><br><span class="line"><span class="comment"> *~ incorrectly imported as a namespace object, unless</span></span><br><span class="line"><span class="comment"> *~ --esModuleInterop is turned on:</span></span><br><span class="line"><span class="comment"> *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> MyClass &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> MyClassMethodOptions &#123;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    height?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-1-3-Module-plugin"><a href="#10-2-1-3-Module-plugin" class="headerlink" title="10.2.1.3  Module: plugin"></a>10.2.1.3  Module: plugin</h5><p>If you have a module which when imported, makes changes to other modules use template</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jest = <span class="built_in">require</span>(<span class="string">'jest'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jest-matchers-files"</span>);</span><br></pre></td></tr></table></figure><p>when you want to work with JavaScript code which extends another library.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normal Greeter API</span></span><br><span class="line">greeter(<span class="number">2</span>);</span><br><span class="line">greeter(<span class="string">"Hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we extend the object with a new function at runtime</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"hyper-super-greeter"</span>;</span><br><span class="line">greeter.hyperGreet();</span><br></pre></td></tr></table></figure><p>The definition for “super-greeter”</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ This example shows how to have 多个重载 for your function */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> GreeterFunction &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">  (time: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This example shows how to export 一个接口指定的function  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> greeter: GreeterFunction;</span><br></pre></td></tr></table></figure><p>We can extend the existing module like the following:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module plugin template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ On this line, import the module which this module adds to */</span></span><br><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Here, declare the same module as the one you imported above</span></span><br><span class="line"><span class="comment"> *~ then we expand the existing declaration of the greeter function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> "super-greeter" &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> GreeterFunction &#123;</span><br><span class="line">    <span class="comment">/** Greets even better! */</span></span><br><span class="line">    hyperGreet(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2-Global-Libraries"><a href="#10-2-2-Global-Libraries" class="headerlink" title="10.2.2 Global Libraries"></a>10.2.2 Global Libraries</h4><p>全局库是可以从全局范围访问的库（即，无需使用任何形式的导入）。许多库只是公开一个或多个全局变量供使用。例如jquery;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(() =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--一般情况，全局库的使用方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://a.great.cdn.for/someLib.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，最流行的可全局库 实际上是作为 UMD标准 编写的（请参见下文）。 UMD库文档很难与全局库文档区分开。在编写全局声明文件之前，请确保该库不是UMD。</p><p><strong>从代码中识别Global Library</strong></p><p>查看全局库的代码时，通常会看到：</p><ul><li>Top-level <code>var</code> statements or <code>function</code> declarations</li><li>One or more assignments to <code>window.someName</code></li><li>Assumptions that DOM primitives like <code>document</code> or <code>window</code> exist</li></ul><p>You <em>won’t</em> see:</p><ul><li>Checks for, or usage of, module loaders like <code>require</code> or <code>define</code></li><li>CommonJS/Node.js-style imports of the form <code>var fs = require(&quot;fs&quot;);</code></li><li>Calls to <code>define(...)</code></li><li>Documentation describing how to <code>require</code> or import the library</li></ul><h5 id="10-2-2-1-Global-d-ts"><a href="#10-2-2-1-Global-d-ts" class="headerlink" title="10.2.2.1  Global.d.ts"></a>10.2.2.1  Global.d.ts</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this library is callable (e.g. can be invoked as myLib(3)),</span></span><br><span class="line"><span class="comment"> *~ include those call signatures here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this section.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">myLib</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">myLib</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want the name of this library to be a valid type name,</span></span><br><span class="line"><span class="comment"> *~ you can do so here.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ For example, this allows us to write 'var x: myLib';</span></span><br><span class="line"><span class="comment"> *~ Be sure this actually makes sense! If it doesn't, just</span></span><br><span class="line"><span class="comment"> *~ delete this declaration and add types inside the namespace below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> myLib &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your library has properties exposed on a global variable,</span></span><br><span class="line"><span class="comment"> *~ place them here.</span></span><br><span class="line"><span class="comment"> *~ You should also place types (interfaces and type alias) here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="comment">//~ We can write 'myLib.timeout = 50;'</span></span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can access 'myLib.version', but not change it</span></span><br><span class="line">  <span class="keyword">const</span> version: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ There's some class we can create via 'let c = new myLib.Cat(42)'</span></span><br><span class="line">  <span class="comment">//~ Or reference e.g. 'function f(c: myLib.Cat) &#123; ... &#125;</span></span><br><span class="line">  <span class="keyword">class</span> Cat &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">number</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~ We can read 'c.age' from a 'Cat' instance</span></span><br><span class="line">    readonly age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~ We can invoke 'c.purr()' from a 'Cat' instance</span></span><br><span class="line">    purr(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can declare a variable as</span></span><br><span class="line">  <span class="comment">//~   'var s: myLib.CatSettings = &#123; weight: 5, name: "Maru" &#125;;'</span></span><br><span class="line">  <span class="keyword">interface</span> CatSettings &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    tailLength?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can write 'const v: myLib.VetID = 42;'</span></span><br><span class="line">  <span class="comment">//~  or 'const v: myLib.VetID = "bob";'</span></span><br><span class="line">  <span class="keyword">type</span> VetID = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkCat</span>(<span class="params">c: Cat, s?: VetID</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-2-2-Global-Modifying-Module"><a href="#10-2-2-2-Global-Modifying-Module" class="headerlink" title="10.2.2.2 Global: Modifying Module"></a>10.2.2.2 Global: Modifying Module</h5><p>导入全局变量的模块会在全局范围内更改现有值。例如，可能存在一个库，该库在导入时将新成员添加到String.prototype。由于存在运行时冲突的可能性，该模式有些危险，但是我们仍然可以为其编写声明文件。</p><p><strong>识别全局修改模块</strong></p><p>全局修改模块通常易于从其文档中识别，它们类似全局插件，但是需要require方法的调用 才能激活它们的副作用；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'require' call that doesn't use its return value</span></span><br><span class="line"><span class="keyword">var</span> unused = <span class="built_in">require</span>(<span class="string">"magic-string-time"</span>);</span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"magic-string-time"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"hello, world"</span>;</span><br><span class="line"><span class="comment">// Creates new methods on built-in types</span></span><br><span class="line"><span class="built_in">console</span>.log(x.startsWithHello());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// Creates new methods on built-in types</span></span><br><span class="line"><span class="built_in">console</span>.log(y.reverseAndSort());</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the global-modifying module template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Note: If your global-modifying module is callable or constructable, you'll</span></span><br><span class="line"><span class="comment"> *~ need to combine the patterns here with those in the module-class or module-function</span></span><br><span class="line"><span class="comment"> *~ template files</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="comment">/*~ Here, declare things that go in the global namespace, or augment</span></span><br><span class="line"><span class="comment">   *~ existing declarations in the global namespace</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> String &#123;</span><br><span class="line">    fancyFormat(opts: StringFormatOptions): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your module exports types or values, write them as usual */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringFormatOptions &#123;</span><br><span class="line">  fancinessLevel: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ For example, declaring a method on the module (in addition to its global side effects) */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-UMD"><a href="#10-2-3-UMD" class="headerlink" title="10.2.3 UMD"></a>10.2.3 UMD</h4><p>UMD模块既可以用作模块（通过import），也可以用作全局模块（在没有模块加载器的环境中运行时）。这样编写了许多流行的库，例如Moment.js。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs 环境下</span></span><br><span class="line"><span class="keyword">import</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="comment">// 浏览器环境下</span></span><br><span class="line"><span class="built_in">console</span>.log(mement.format());</span><br></pre></td></tr></table></figure><p><strong>umd模版</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([<span class="string">"libName"</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"libName"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.returnExports = factory(root.libName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span> ? self : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Use b in some fashion.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Just return a value to define the module export.</span></span><br><span class="line">    <span class="comment">// This example returns an object, but the module</span></span><br><span class="line">    <span class="comment">// can return a function as the exported value.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>UMD库的文档通常还会演示一个显示require的“在Node.js中使用”示例，以及一个使用<code>script</code>标记加载该脚本的“在浏览器中使用”示例。</p><h4 id="10-2-4-Consuming-Dependencies"><a href="#10-2-4-Consuming-Dependencies" class="headerlink" title="10.2.4 Consuming Dependencies"></a>10.2.4 Consuming Dependencies</h4><p>你的库可能具有集中依赖关系，下面会说明如何将它们导入声明文件；</p><ul><li>Dependencies on Global Libraries</li></ul><p>If your library depends on a global library, use a <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> directive:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="someLib" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">someLib</span>.<span class="title">thing</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Dependencies on Modules</li></ul><p>If your library depends on a module, use an <code>import</code> statement:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">"moment"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">moment</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Dependencies on UMD libraries</li></ul><p>From a Global Library</p><p>If your global library depends on a UMD module, use a <code>/// &lt;reference types</code> directive:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="moment" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">moment</span></span>;</span><br></pre></td></tr></table></figure><p>From a Module or UMD Library</p><p>If your module or UMD library depends on a UMD library, use an <code>import</code> statement:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> someLib <span class="keyword">from</span> <span class="string">"someLib"</span>;</span><br></pre></td></tr></table></figure><p>Do <em>not</em> use a <code>/// &lt;reference</code> directive 来声明对UMD库的依赖！</p><h4 id="10-2-5-Preventing-Name-Conflicts"><a href="#10-2-5-Preventing-Name-Conflicts" class="headerlink" title="10.2.5 Preventing Name Conflicts"></a>10.2.5 Preventing Name Conflicts</h4><p>编写全局声明文件时，可以在全局范围内定义许多类型。强烈不建议这样做，因为当项目中有许多声明文件时，它可能导致无法解决的名称冲突。</p><p>库定义的任何全局变量只声明 namespaces</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> cats &#123;</span><br><span class="line"><span class="keyword">interface</span> KittySettings &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// But not</span></span><br><span class="line"> <span class="comment">// at top-level</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span> CatsKittySettings&#123;&#125;</span><br></pre></td></tr></table></figure><p>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</p><h3 id="10-3-Do’s-and-Don’ts"><a href="#10-3-Do’s-and-Don’ts" class="headerlink" title="10.3 Do’s and Don’ts"></a>10.3 Do’s and Don’ts</h3><h4 id="10-3-1-基本类型"><a href="#10-3-1-基本类型" class="headerlink" title="10.3.1 基本类型"></a>10.3.1 基本类型</h4><p>不要使用<code>Number,String,Boolean, Symbol, or Object</code> 等类型；</p><h4 id="10-3-2-any"><a href="#10-3-2-any" class="headerlink" title="10.3.2 any"></a>10.3.2 any</h4><p>any类型你懂得，尽量别用。anyScript毫无意义；</p><h4 id="10-3-3-Callback-Types"><a href="#10-3-3-Callback-Types" class="headerlink" title="10.3.3 Callback Types"></a>10.3.3 Callback Types</h4><p>对于返回值被忽略的回调，别使用any, 使用void更好；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: () =&gt; <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: () =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-4-重载和回调函数"><a href="#10-3-4-重载和回调函数" class="headerlink" title="10.3.4 重载和回调函数"></a>10.3.4 重载和回调函数</h4><p>不要编写仅在回调函数上有所不同的单独重载：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params">action: () =&gt; <span class="built_in">void</span>, timeout?: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (done: DoneFn) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Do write a single overload using the maximum arity:</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (done: DoneFn) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><p>原因：回调忽略参数始终是合法的，因此不需要较短的重载。首先提供一个较短的回调允许输入错误类型的函数，因为它们与第一个重载匹配。</p><h4 id="10-3-5-function-重载"><a href="#10-3-5-function-重载" class="headerlink" title="10.3.5 function 重载"></a>10.3.5 function 重载</h4><p>不要在更具体的重载之前放置更一般的重载；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLElement</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLDivElement</span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem: HTMLDivElement;</span><br><span class="line"><span class="keyword">var</span> x = fn(myElem); <span class="comment">// x: any, wat?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过将更一般的签名放在更具体的签名之后来对重载进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLDivElement</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLElement</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem: HTMLDivElement;</span><br><span class="line"><span class="keyword">var</span> x = fn(myElem); <span class="comment">// x: string, :)</span></span><br></pre></td></tr></table></figure><p>原因：TypeScript在解决函数调用时选择第一个匹配的重载。当较早的过载比较晚的过载“更普遍”时，较晚的过载实际上是隐藏的，无法调用。</p><h4 id="10-3-6-Use-Optional-Parameters"><a href="#10-3-6-Use-Optional-Parameters" class="headerlink" title="10.3.6 Use Optional Parameters"></a>10.3.6 Use Optional Parameters</h4><p>不要写一些仅在尾随参数上有所不同的重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">interface</span> Example &#123;</span><br><span class="line">  diff(one: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two: <span class="built_in">string</span>, three: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">interface</span> Example &#123;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two?: <span class="built_in">string</span>, three?: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-7-Union-Types"><a href="#10-3-7-Union-Types" class="headerlink" title="10.3.7 Union Types"></a>10.3.7 Union Types</h4><p>不要只在一个参数位置编写因类型而异的重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">interface</span> Moment &#123;</span><br><span class="line">  utcOffset(): <span class="built_in">number</span>;</span><br><span class="line">  utcOffset(b: <span class="built_in">number</span>): Moment;</span><br><span class="line">  utcOffset(b: <span class="built_in">string</span>): Moment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">interface</span> Moment &#123;</span><br><span class="line">  utcOffset(): <span class="built_in">number</span>;</span><br><span class="line">  utcOffset(b: <span class="built_in">number</span> | <span class="built_in">string</span>): Moment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// When written with separate overloads, incorrectly an error</span></span><br><span class="line">  <span class="comment">// When written with union types, correctly OK</span></span><br><span class="line">  <span class="keyword">return</span> moment().utcOffset(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-Deep-Dive"><a href="#10-4-Deep-Dive" class="headerlink" title="10.4 Deep Dive"></a>10.4 Deep Dive</h3><h4 id="10-4-1-Namespaces"><a href="#10-4-1-Namespaces" class="headerlink" title="10.4.1 Namespaces"></a>10.4.1 Namespaces</h4><p>类型可以存在于名称空间中。例如，如果我们有声明let x：A.B.C，则说类型C来自A.B命名空间。A， B 不一定必须是类型或者值</p><h4 id="10-4-2-简单组合，一个名字多种含义"><a href="#10-4-2-简单组合，一个名字多种含义" class="headerlink" title="10.4.2 简单组合，一个名字多种含义"></a>10.4.2 简单组合，一个名字多种含义</h4><p>给定名称A，我们最多可以找到A的三种不同含义：类型，值或名称空间。名称的解释方式取决于所使用的上下文。例如，在一个声明文件中 中 <code>let m：A.A = A ;</code>，首先将A用作namespaces，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！</p><h5 id="10-4-2-1-User-Combinations"><a href="#10-4-2-1-User-Combinations" class="headerlink" title="10.4.2.1 User Combinations"></a>10.4.2.1 User Combinations</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> SomeVar: &#123; a: SomeType &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumed</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">"./foo"</span>;</span><br><span class="line"><span class="keyword">let</span> x: foo.SomeType = foo.SomeVar.a;</span><br><span class="line"><span class="built_in">console</span>.log(x.count);</span><br></pre></td></tr></table></figure><p>这种方法不错，但我们可能会认为 SomeType 和 SomeVar 紧密相关，因此您希望它们具有相同的名称。我们可以使用合并相同的名称Bar呈现这两个不同的对象；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> Bar: &#123;a : Bar&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Bar &#123;</span><br><span class="line">count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumed</span></span><br><span class="line"><span class="keyword">import</span> &#123; Bar &#125; <span class="keyword">from</span> <span class="string">"./foo"</span>;</span><br><span class="line"><span class="keyword">let</span> x: Bar = Bar.a;</span><br><span class="line"><span class="built_in">console</span>.log(x.count);</span><br></pre></td></tr></table></figure><p>我们在这里使用Bar作为类型和值。请注意，我们不必将Bar值声明为Bar类型，它们是独立的。</p><h5 id="10-4-2-2-Advanced-Combinations"><a href="#10-4-2-2-Advanced-Combinations" class="headerlink" title="10.4.2.2 Advanced Combinations"></a>10.4.2.2 Advanced Combinations</h5><p>某些声明可以跨多个声明进行组合，比如 class C {}  和 interface C{} 可以共存，并且都给类型C贡献了属性。 只要不造成冲突，就是合法的，一般的经验法则是， 值始终会与同名的其他值发生冲突，除非将它们声明为namespaces,；</p><p>s, types will conflict if they are declared with a type alias declaration (<code>type s = string</code>), and namespaces never conflict.</p><ul><li>Adding using an `interface</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: Foo = ...;</span><br><span class="line"><span class="built_in">console</span>.log(a.x + a.y); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this also works with classes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: Foo = ...;</span><br><span class="line"><span class="built_in">console</span>.log(a.x + a.y); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that we cannot add to type aliases (type s = string;) using an interface.</span></span><br></pre></td></tr></table></figure><ul><li>Adding using a namespace</li></ul><p>可以使用namespace声明以任何不会造成冲突的方式添加新的类型，值和namespace。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给class添加一个静态成员</span></span><br><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">let</span> y = C.x; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>在此示例中，我们向C的静态侧（其构造函数）添加了一个值。这是因为我们添加了一个值，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。</p><p>We could also add a namespaced type to a class:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> D &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y: C.D; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>在我们为其编写 namespace 声明之前，没有 <code>namespace C</code>。作为命名空间的C的含义与该类创建的C的值或类型的含义不冲突。</p><p>我们可以使用名称空间声明执行许多不同的合并;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Y &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Z &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> Y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Z &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> C &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> X = <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>In this example, the first block creates the following name meanings:</p><ul><li>A value <code>X</code> (because the <code>namespace</code> declaration contains a value, <code>Z</code>)</li><li>A namespace <code>X</code> (because the <code>namespace</code> declaration contains a type, <code>Y</code>)</li><li>A type <code>Y</code> in the <code>X</code> namespace</li><li>A type <code>Z</code> in the <code>X</code> namespace (the instance shape of the class)</li><li>A value <code>Z</code> that is a property of the <code>X</code> value (该class的构造函数)</li></ul><p>The second block creates the following name meanings:</p><ul><li>A value <code>Y</code> (of type <code>number</code>) that is a property of the <code>X</code> value</li><li>A namespace <code>Z</code></li><li>A value <code>Z</code> that is a property of the <code>X</code> value</li><li>A type <code>C</code> in the <code>X.Z</code> namespace</li><li>A value <code>C</code> that is a property of the <code>X.Z</code> value</li><li>A type <code>X</code></li></ul><h3 id="10-5-Publish-to-npm"><a href="#10-5-Publish-to-npm" class="headerlink" title="10.5 Publish to npm"></a>10.5 Publish to npm</h3><h4 id="10-5-1-两种发布方法"><a href="#10-5-1-两种发布方法" class="headerlink" title="10.5.1 两种发布方法"></a>10.5.1 两种发布方法</h4><ol><li>bundling with your npm package</li><li>publishing to the <a href="https://www.npmjs.com/~types" target="_blank" rel="noopener">@types organization</a> on npm.</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="..." /&gt;</span></span><br><span class="line"><span class="comment">// Don’t use /// &lt;reference path="..." /&gt; in your declaration files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference path="../typescript/lib/typescriptServices.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do use /// &lt;reference types="..." /&gt; instead.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types="typescript" /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="10-5-2-Packaging-dependent-declarations"><a href="#10-5-2-Packaging-dependent-declarations" class="headerlink" title="10.5.2 Packaging dependent declarations"></a>10.5.2 Packaging dependent declarations</h4><p>If your type definitions depend on another package:</p><ul><li><em>Don’t</em> combine it with yours, keep each in their own file.</li><li><em>Don’t</em> copy the declarations in your package either.</li><li><em>Do</em> depend on the npm type declaration package if it doesn’t package its declaration files.</li></ul><h4 id="10-5-3-Publish-to-types"><a href="#10-5-3-Publish-to-types" class="headerlink" title="10.5.3 Publish to @types"></a>10.5.3 Publish to @types</h4><p>Packages under the <a href="https://www.npmjs.com/~types" target="_blank" rel="noopener">@types</a> organization are published automatically from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a> using the <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher" target="_blank" rel="noopener">types-publisher tool</a>. To get your declarations published as an @types package, please submit a pull request to <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a>. You can find more details in the <a href="http://definitelytyped.org/guides/contributing.html" target="_blank" rel="noopener">contribution guidelines page</a>.</p><h3 id="10-6-Find-and-Install-Declaration-Files"><a href="#10-6-Find-and-Install-Declaration-Files" class="headerlink" title="10.6 Find and Install Declaration Files"></a>10.6 Find and Install Declaration Files</h3><ul><li>loadsh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/lodash</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 npm install 了 类型声明</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line">_.padStart(<span class="string">"hi"</span>, <span class="number">20</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or if you’re not using modules, you can just use the global variable _.</span></span><br><span class="line">_.padStart(<span class="string">"Hello TypeScript!"</span>, <span class="number">20</span>, <span class="string">" "</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts modules</title>
      <link href="2021/01/20/ts-modules/"/>
      <url>2021/01/20/ts-modules/</url>
      
        <content type="html"><![CDATA[<h2 id="6-Modules"><a href="#6-Modules" class="headerlink" title="6. Modules"></a>6. Modules</h2><h3 id="6-1-import-export"><a href="#6-1-import-export" class="headerlink" title="6.1 import/export"></a>6.1 import/export</h3><p>模块是在自己的范围内执行的，而不是在全局范围内执行的；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用导出形式之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种导入形式将其导入。</p><p>模块是声明性的，模块之间的关系是根据文件级别的导入和导出指定的；</p><p>模块使用模块加载器相互导入， 在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。</p><h4 id="6-1-1-export"><a href="#6-1-1-export" class="headerlink" title="6.1.1 export"></a>6.1.1 export</h4><p>可以通过添加export关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重命名导出</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure><p><strong>重新导出不会将其导入本地，也不会引入局部变量。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParseIntBasedZipCodeValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(s).toString() === s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export original validator but rename it</span></span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> RegExpBasedZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br></pre></td></tr></table></figure><p><strong>导出所有</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./StringValidator"</span>; <span class="comment">// exports 'StringValidator' interface</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>; <span class="comment">// exports 'ZipCodeValidator' class and 'numberRegexp' constant value</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./ParseIntBasedZipCodeValidator"</span>; <span class="comment">//  exports the 'ParseIntBasedZipCodeValidator' class</span></span><br><span class="line"><span class="comment">// and re-exports 'RegExpBasedZipCodeValidator' as alias</span></span><br><span class="line"><span class="comment">// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'</span></span><br><span class="line"><span class="comment">// module.</span></span><br></pre></td></tr></table></figure><h4 id="6-1-2-import"><a href="#6-1-2-import" class="headerlink" title="6.1.2 import"></a>6.1.2 import</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single export</span></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="comment">// renamed</span></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> ZCV &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZCV();</span><br><span class="line"><span class="comment">// 将整个模块导入单个变量，并使用它来访问模块导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.ZipCodeValidator();</span><br><span class="line"><span class="comment">// 某些模块会设置一些可由其他模块使用的全局状态。这些模块可能没有任何出口</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./my-module.js"</span></span><br></pre></td></tr></table></figure><h4 id="6-1-3-default-exports"><a href="#6-1-3-default-exports" class="headerlink" title="6.1.3 default exports"></a>6.1.3 default exports</h4><blockquote><p>默认导出</p></blockquote><p>​        每个模块可以选择导出默认导出。默认导出用关键字<code>default</code>标记；每个模块只能有一个默认导出。默认导出使用其他导入形式导入。</p><p>​        默认出口真的很方便。例如，像jQuery之类的库可能具有jQuery或$的默认导出，我们也可能以$或jQuery的名称导入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> $:JQuery</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.ts</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">"jquery"</span>;</span><br><span class="line">$(<span class="string">"button"</span>).html(<span class="string">"xxx"</span>)</span><br></pre></td></tr></table></figure><h4 id="6-1-4-Export-all-as-x"><a href="#6-1-4-Export-all-as-x" class="headerlink" title="6.1.4 Export all as x"></a>6.1.4 Export all as x</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> utilities <span class="keyword">from</span> <span class="string">"./utilities"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;utilities&#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br></pre></td></tr></table></figure><h4 id="6-1-4-export-import-require"><a href="#6-1-4-export-import-require" class="headerlink" title="6.1.4 export =      import = require()"></a>6.1.4 export =      import = require()</h4><p>TypeScript supports <code>export =</code> to model the traditional CommonJS and AMD workflow.</p><p><code>export =</code>语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。</p><p>当使用<code>export =</code>导出模块时, 必须用 <code>import module = require(&quot;module&quot;)</code> 导入模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// z.ts</span></span><br><span class="line"><span class="keyword">let</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> = ZipCodeValidator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t.ts</span></span><br><span class="line"><span class="keyword">import</span> zip = <span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> zip();</span><br></pre></td></tr></table></figure><h3 id="6-2-code-generation-for-Modules"><a href="#6-2-code-generation-for-Modules" class="headerlink" title="6.2 code generation for Modules"></a>6.2 code generation for Modules</h3><p>typescript 会依据不同的模块规则，生成不同的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleModule.ts</span></span><br><span class="line"><span class="keyword">import</span> m = <span class="built_in">require</span>(<span class="string">"mod"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = m.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>AMD / RequireJS SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"./mod"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, mod_1</span>) </span>&#123;</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>CommonJS / Node SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>UMD SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> v = factory(<span class="built_in">require</span>, exports);</span><br><span class="line">  <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">module</span>.exports = v;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">  define([<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"./mod"</span>], factory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>System SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.register([<span class="string">"./mod"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">exports_1</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> mod_1;</span><br><span class="line"><span class="keyword">var</span> t;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  setters: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">mod_1_1</span>) </span>&#123;</span><br><span class="line">      mod_1 = mod_1_1;</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    exports_1(<span class="string">"t"</span>, (t = mod_1.something + <span class="number">1</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Native ECMAScript 2015 modules SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">"./mod"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> t = something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="6-3-可选模块加载和其他高级加载方案"><a href="#6-3-可选模块加载和其他高级加载方案" class="headerlink" title="6.3 可选模块加载和其他高级加载方案"></a>6.3 可选模块加载和其他高级加载方案</h3><p>为了保持类型安全，我们可以使用typeof关键字。当在类型位置中使用typeof关键字时，将产生值的类型，在这种情况下为模块的类型。</p><h4 id="6-3-1-Dynamic-Module-Loading-in-Node-js"><a href="#6-3-1-Dynamic-Module-Loading-in-Node-js" class="headerlink" title="6.3.1 Dynamic Module Loading in Node.js"></a>6.3.1 Dynamic Module Loading in Node.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line"><span class="keyword">let</span> ZipCodeValidator: <span class="keyword">typeof</span> Zip = <span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line"><span class="keyword">if</span> (validator.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-2-Sample-Dynamic-Module-Loading-in-require-js"><a href="#6-3-2-Sample-Dynamic-Module-Loading-in-require-js" class="headerlink" title="6.3.2 Sample: Dynamic Module Loading in require.js"></a>6.3.2 Sample: Dynamic Module Loading in require.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">moduleNames: <span class="built_in">string</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">onLoad: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Zip <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"./ZipCodeValidator"</span>], <span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (validator.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-3-Sample-Dynamic-Module-Loading-in-System-js"><a href="#6-3-3-Sample-Dynamic-Module-Loading-in-System-js" class="headerlink" title="6.3.3 Sample: Dynamic Module Loading in System.js"></a>6.3.3 Sample: Dynamic Module Loading in System.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> System: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">System.import(<span class="string">"./ZipCodeValidator"</span>).then(<span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (x.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-使用其他js库"><a href="#6-4-使用其他js库" class="headerlink" title="6.4 使用其他js库"></a>6.4 使用其他js库</h3><p>为了描述非ts编写的库，我们需要声明该库公开的API；通常将这些声明定义在<code>.d.ts</code>文件中，就类似c/c++程序中的 <code>.h</code>文件；</p><p>Ts程序在开发过程中，会不可避免的引用到第三方js库，但是无法使用Typescript诸如类型检查等特性功能，为了解决这个问题，需要将这些库的函数和方法去掉后只保留导出类型声明，而产生一个描述js库和模块信息的声明文件，通过引用这个声明文件，就可以借用TS的各种特性来使用库文件；</p><h4 id="6-4-1-声明文件的存放方式"><a href="#6-4-1-声明文件的存放方式" class="headerlink" title="6.4.1 声明文件的存放方式"></a>6.4.1 声明文件的存放方式</h4><ol><li>在tsconfig include 字段包含 的范围内编写.d.ts，都能被自动识别</li><li>在x.js 相同目录创建同名声明文件x.d.ts，这样也会被自动识别；</li><li>node_modules/@types/ 下存放的各个第三方模块声明文件，自己编写的声明文件不要放这里；</li><li>作为npm模块发布时，声明文件可捆绑发布，需在package.json中指明“types”：”./types/index.d.ts”</li></ol><h4 id="6-4-1-无配置使用js"><a href="#6-4-1-无配置使用js" class="headerlink" title="6.4.1 无配置使用js"></a>6.4.1 无配置使用js</h4><p>在tsconfig.json中关闭”noImplicitAny”: false时，可直接在Ts中引用js的库，所有的引入都会被默认为any类型。此方法不推荐使用；</p><h4 id="6-4-2-Ts中引入js"><a href="#6-4-2-Ts中引入js" class="headerlink" title="6.4.2 Ts中引入js"></a>6.4.2 Ts中引入js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hello = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;hello&#125; <span class="keyword">from</span> <span class="string">'./hello'</span></span><br><span class="line"><span class="comment">// 无法找到模块'./hello'的声明文件</span></span><br><span class="line"><span class="comment">// 这就告诉用户，需要为hello.js编写声明文件了；</span></span><br><span class="line"><span class="comment">// hello.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">const</span> hello: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>  上面的例子稍微简单一些，下面写一个相对复杂点的demo</p><p><strong>tsconfig.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist/"</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>],</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"./src/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-src</span><br><span class="line">-swap</span><br><span class="line">-index.js</span><br><span class="line">-index.d.ts</span><br><span class="line">-index.ts</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap/index.js</span></span><br><span class="line"><span class="keyword">const</span> NAME = <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line">  temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;NAME&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  swap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> swap &#123; <span class="comment">// ts 编译运行时的 swap命名空间, 增加命名空间放置被全局污染。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T, b: T</span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> swap; <span class="comment">// 注意这里要导出，有export/import 语句的文件 才是模块</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> swap <span class="keyword">from</span> <span class="string">"./swap"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"3"</span>,</span><br><span class="line">  b = <span class="string">"4"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(swap.swap&lt;<span class="built_in">string</span>&gt;(a, b));</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure><h4 id="6-4-3-declare"><a href="#6-4-3-declare" class="headerlink" title="6.4.3 declare"></a>6.4.3 declare</h4><p><strong>var和declare的区别</strong></p><p>​        var表示创建一个新变量，declare用来告诉ts编译器这个变量已经在别处被创建过了， 如果你用declare，什么都不会添加到生成的js中， 它只是对编译器一个简单的提示；</p><p>​        举例说明，如果你引入的第三方js文件中有 <code>var externalModule</code>，你需要定义<code>declare var externalModule</code> 去提示ts编译器，externalModule这个变量已经被创建了；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">class</span> Action &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个class  Action的具体实现应该在其他什么地方，可以在个 .js文件里面</p><p>​        </p><h4 id="6-4-4-Ts中导入-png-json等"><a href="#6-4-4-Ts中导入-png-json等" class="headerlink" title="6.4.4 Ts中导入.png .json等"></a>6.4.4 Ts中导入.png .json等</h4><p>导入.png .json 等文件时，同样也需要去编写声明文件；</p><p>提供一种方式，可以创建一个声明文件 <code>src/@types/definition.d.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.png' &#123;</span><br><span class="line"><span class="keyword">const</span> value: <span class="built_in">string</span></span><br><span class="line"><span class="keyword">export</span> = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="comment">// 之后在TS中导入也不会有问题</span></span><br><span class="line"><span class="keyword">import</span> avatar <span class="keyword">from</span> <span class="string">'./img/avatar.png'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> avatar = <span class="built_in">require</span>(<span class="string">'./img/avatar.png'</span>)</span><br><span class="line">  <span class="comment">// 可能会提示 require 未定义，有两种方式：</span></span><br><span class="line">  <span class="comment">//  1. 自行声明：declare const require: any</span></span><br><span class="line">  <span class="comment">//  2. yarn add -D @types/node</span></span><br></pre></td></tr></table></figure><h4 id="6-4-5-第三方模块没有可用的声明文件"><a href="#6-4-5-第三方模块没有可用的声明文件" class="headerlink" title="6.4.5  第三方模块没有可用的声明文件"></a>6.4.5  第三方模块没有可用的声明文件</h4><p>有些模块没有对应的声明文件时，需要我们自己编写声明文件，以rc-form为例子，需要在<code>src/@types/defintion.d.ts</code>中添加声明代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defintion.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "rc-form" &#123;</span><br><span class="line"><span class="comment">// 再次简单进行类型声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createForm: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createFormField: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formShape: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-6-webpack-别名-aliases"><a href="#6-4-6-webpack-别名-aliases" class="headerlink" title="6.4.6  webpack  别名  aliases"></a>6.4.6  webpack  别名  aliases</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">aliases: &#123;</span><br><span class="line">  <span class="comment">// 公共的工具类、容器和组件</span></span><br><span class="line">  utils: path.resolve(<span class="string">'../utils'</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;ua&#125; <span class="keyword">from</span> <span class="string">'utils/broswer'</span></span><br><span class="line"><span class="comment">// cannot find module 'utils/browser'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要在tsconfig.json 添加baseUrl 和 paths</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 添加配置</span></span><br><span class="line">  <span class="string">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">  <span class="string">"paths"</span>: &#123;</span><br><span class="line">    <span class="string">"utils/*"</span>: [<span class="string">"../utils/*"</span>],</span><br><span class="line">    <span class="string">"components/*"</span>: [<span class="string">"../components/*"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"include"</span>: [<span class="string">"./src/*"</span>, <span class="string">"./src/**/*"</span>],</span><br><span class="line"><span class="string">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-7-类型Window上不存在属性“X”"><a href="#6-4-7-类型Window上不存在属性“X”" class="headerlink" title="6.4.7 类型Window上不存在属性“X”"></a>6.4.7 类型Window上不存在属性“X”</h4><p>需要对window进行扩展，直接在<code>src/@types/definition.d.ts</code>中扩展</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">x: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(Window.x) <span class="comment">// success</span></span><br></pre></td></tr></table></figure><ul><li>注意全局声明和局部声明</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;IPerson&#125; <span class="keyword">from</span> <span class="string">'./intefaces/index.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">X: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.X); <span class="comment">// fail: 类型“Window"上不存在属性“X”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决思路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;IPerson&#125; <span class="keyword">from</span> <span class="string">'./intefaces/index.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="keyword">interface</span> Window &#123;</span><br><span class="line">    X: <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.X) <span class="comment">// success </span></span><br><span class="line"><span class="comment">// 原因在于当一个 .ts文件加入import/export 语句的时候，该文件会变为一个模块；因为这个模块中的声明也会变为局部声明； 因此需要加到global的域上</span></span><br></pre></td></tr></table></figure><h3 id="6-5-Ambient-Modules"><a href="#6-5-Ambient-Modules" class="headerlink" title="6.5 Ambient Modules"></a>6.5 Ambient Modules</h3><p>在nodejs中，很多任务的完成都需要引入一个或多个模块，我们可以给每个模块在他们的根目录建立一个.d.ts文件用来声明类型，但合并这些声明到一个大的.d.ts文件往往更方便一些。使用module关键字和 引号名 。这些引号名的名称将在以后的导入中使用；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "url" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Url &#123;</span><br><span class="line">  protocol?: <span class="built_in">string</span>;</span><br><span class="line">  hostname?: <span class="built_in">string</span>;</span><br><span class="line">  pathname?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  urlStr: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  parseQueryString?,</span></span></span><br><span class="line"><span class="function"><span class="params">  slashesDenoteHost?</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Url</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "path" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> sep: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we can <code>/// &lt;reference&gt;</code> <code>node.d.ts</code> and then load the modules using <code>import url = require(&quot;url&quot;);</code> or <code>import * as URL from &quot;url&quot;</code>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="node.d.ts"/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> URL <span class="keyword">from</span> <span class="string">"url"</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = URL.parse(<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure><h4 id="6-5-1-不想为第三方js写声明"><a href="#6-5-1-不想为第三方js写声明" class="headerlink" title="6.5.1 不想为第三方js写声明"></a>6.5.1 不想为第三方js写声明</h4><p>If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declarations.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "hot-new-<span class="keyword">module</span>";</span><br><span class="line"></span><br><span class="line">// All imports from shorthand <span class="keyword">module</span> will have the any type;</span><br><span class="line">import x, &#123;y&#125; <span class="keyword">from</span> <span class="string">"hot-new-module"</span>;</span><br><span class="line">x(y);</span><br></pre></td></tr></table></figure><h4 id="6-5-2-通配符"><a href="#6-5-2-通配符" class="headerlink" title="6.5.2 通配符"></a>6.5.2 通配符</h4><p>一些模块加载器（例如SystemJS和AMD）允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declareations.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*!text" &#123;</span><br><span class="line"><span class="keyword">const</span> content: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Some do it the other way around.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "json!*" &#123;</span><br><span class="line"><span class="keyword">const</span> value: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now you can import things that match "*!text" or "json!*".</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">"./xyz.txt!text"</span>;</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">"json!http://example.com/data.json"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data, fileContent);</span><br></pre></td></tr></table></figure><h4 id="6-5-3-UMD-modules"><a href="#6-5-3-UMD-modules" class="headerlink" title="6.5.3 UMD modules"></a>6.5.3 UMD modules</h4><p>一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为UMD模块。可以通过导入或全局变量访问这些库。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math-lib.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPreme</span>(<span class="params">x: <span class="built_in">number</span></span>):<span class="title">boolean</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> mathLib;</span><br></pre></td></tr></table></figure><p>The library can then be used as an import within modules:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">"math-lib"</span>;</span><br><span class="line">isPrime(<span class="number">2</span>);</span><br><span class="line">mathLib.isPrime(<span class="number">2</span>); <span class="comment">// ERROR: can't use the global definition from inside a module</span></span><br></pre></td></tr></table></figure><p>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathLib.isPrime(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="6-7-Guidance-for-structuring-modules"><a href="#6-7-Guidance-for-structuring-modules" class="headerlink" title="6.7 Guidance for structuring modules"></a>6.7 Guidance for structuring modules</h3><h4 id="6-7-1-Export-as-close-to-top-level-as-possible"><a href="#6-7-1-Export-as-close-to-top-level-as-possible" class="headerlink" title="6.7.1 Export as close to top-level as possible"></a>6.7.1 Export as close to top-level as possible</h4><p>如果要导入大量内容，请使用名称空间导入模式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLargeModule.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Dog &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Cat &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Tree &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Flower &#123; ... &#125;</span><br><span class="line"><span class="comment">// Consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myLargeModule <span class="keyword">from</span> <span class="string">"./MyLargeModule.ts"</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure><h4 id="6-7-2-Re-export-to-extend"><a href="#6-7-2-Re-export-to-extend" class="headerlink" title="6.7.2 Re-export to extend"></a>6.7.2 Re-export to extend</h4><p>通常，您将需要扩展模块上的功能。常见的JS模式是使用扩展来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样合并。推荐的解决方案是不要变更原始对象，而是导出提供新功能的新对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Calculator &#123;</span><br><span class="line"><span class="keyword">private</span> current = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> operator: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 只能做10以内的计算；</span></span><br><span class="line">  <span class="keyword">if</span> (digit &gt;= <span class="string">"0"</span> &amp;&amp; digit &lt;= <span class="string">"9"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue * <span class="number">10</span> + (digit.charCodeAt(<span class="number">0</span>) - <span class="string">"0"</span>.charCodeAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processOperator(operator: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>].indexOf(operator) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> operator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> evaluateOperator(</span><br><span class="line">  operator: <span class="built_in">string</span>,</span><br><span class="line">  left: <span class="built_in">number</span>,</span><br><span class="line">  right: <span class="built_in">number</span></span><br><span class="line">): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>.operator) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">      <span class="keyword">return</span> left - right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">      <span class="keyword">return</span> left * right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">      <span class="keyword">return</span> left / right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> evaluate() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.operator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">this</span>.evaluateOperator(</span><br><span class="line">      <span class="keyword">this</span>.operator,</span><br><span class="line">      <span class="keyword">this</span>.memory,</span><br><span class="line">      <span class="keyword">this</span>.current</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">this</span>.current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.current = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> handleChar(char: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (char === <span class="string">"="</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.evaluate();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.processDigit(char, <span class="keyword">this</span>.current);</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">this</span>.processOperator(char);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.evaluate();</span><br><span class="line">        <span class="keyword">this</span>.operator = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Unsupported input: '<span class="subst">$&#123;char&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> getResult() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.memory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c: Calculator, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">  c.handleChar(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`result of '<span class="subst">$&#123;input&#125;</span>' is '<span class="subst">$&#123;c.getResult()&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">import</span> &#123;Calculator,  test&#125; <span class="keyword">from</span> <span class="string">'./ProgrammerCalculator'</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">"1+2*33/11="</span>);</span><br></pre></td></tr></table></figure><p><strong>新需求： 要求计算超过9的值</strong></p><p>这个时候不在原类上更改，而是在继承类上做新功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Calculator &#125; <span class="keyword">from</span> <span class="string">"./Calculator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ProgrammerCalculator <span class="keyword">extends</span> Calculator &#123;</span><br><span class="line"><span class="keyword">static</span> digits = [</span><br><span class="line">  <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"2"</span>,</span><br><span class="line">  <span class="string">"3"</span>,</span><br><span class="line">  <span class="string">"4"</span>,</span><br><span class="line">  <span class="string">"5"</span>,</span><br><span class="line">  <span class="string">"6"</span>,</span><br><span class="line">  <span class="string">"7"</span>,</span><br><span class="line">  <span class="string">"8"</span>,</span><br><span class="line">  <span class="string">"9"</span>,</span><br><span class="line">  <span class="string">"A"</span>,</span><br><span class="line">  <span class="string">"B"</span>,</span><br><span class="line">  <span class="string">"C"</span>,</span><br><span class="line">  <span class="string">"D"</span>,</span><br><span class="line">  <span class="string">"E"</span>,</span><br><span class="line">  <span class="string">"F"</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> base: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">const</span> maxBase = ProgrammerCalculator.digits.length;</span><br><span class="line">  <span class="keyword">if</span> (base &lt;= <span class="number">0</span> || base &gt; maxBase) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`base has to be within 0 to <span class="subst">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      currentValue * <span class="keyword">this</span>.base + ProgrammerCalculator.digits.indexOf(digit)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export the new extended calculator as Calculator</span></span><br><span class="line"><span class="keyword">export</span> &#123; ProgrammerCalculator <span class="keyword">as</span> Calculator &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also, export the helper function</span></span><br><span class="line"><span class="keyword">export</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">"./Calculator"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Calculator, test &#125; <span class="keyword">from</span> <span class="string">"./ProgrammerCalculator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">"001+010="</span>); <span class="comment">// prints 3</span></span><br></pre></td></tr></table></figure><h4 id="6-7-3-Do-not-use-namespaces-in-modules"><a href="#6-7-3-Do-not-use-namespaces-in-modules" class="headerlink" title="6.7.3  Do not use namespaces in modules"></a>6.7.3  Do not use namespaces in modules</h4><p>当首次转向基于模块的组织时，一种普遍的趋势是将导出包装在命名空间的附加层中。模块具有自己的作用域，并且从模块外部仅可见导出的声明。考虑到这一点，名称空间在使用模块时几乎没有价值。</p><h2 id="7-Namespaces"><a href="#7-Namespaces" class="headerlink" title="7. Namespaces"></a>7. Namespaces</h2><p>在TypeScript 1.5中，模块命名法则已更改。 “Internal modules”现在是“namespaces”。为了与ECMAScript 2015的术语保持一致，“External modules”现在简称为“modules”（module X {}  等同于 namespaceX {}）</p><p>在声明内部模块时，在使用module关键字的任何地方，可以并且应该改用namespace关键字。</p><h3 id="7-1-多个相似对象添加namespaces"><a href="#7-1-多个相似对象添加namespaces" class="headerlink" title="7.1 多个相似对象添加namespaces"></a>7.1 多个相似对象添加namespaces</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      validators[name].isAcceptable(s) ? <span class="string">"matches"</span> : <span class="string">"does not match"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Splitting-Across-Files"><a href="#7-2-Splitting-Across-Files" class="headerlink" title="7.2  Splitting Across Files"></a>7.2  Splitting Across Files</h3><p>​    随着应用程序的扩展，我们希望将代码拆分为多个文件，以使其易于维护;</p><h5 id="7-2-1-Multi-file-namespaces"><a href="#7-2-1-Multi-file-namespaces" class="headerlink" title="7.2.1 Multi-file namespaces"></a>7.2.1 Multi-file namespaces</h5><p>  我们将Validation名称空间拆分为多个文件。即使文件是分开的，它们每个都可以贡献相同的名称空间，并且可以像将它们全部定义在一个位置一样使用。由于文件之间存在依赖性，因此我们将添加参考标记，以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。</p><ul><li>Validation.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LettersOnlyValidator.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ZipCodeValidator.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Test.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="LettersOnlyValidator.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="ZipCodeValidator.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      validators[name].isAcceptable(s) ? <span class="string">"matches"</span> : <span class="string">"does not match"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦涉及到多个文件，需要确保所有已编译的代码都已加载，有两种方法可以做到这点</p><h6 id="7-2-1-1-级联输出"><a href="#7-2-1-1-级联输出" class="headerlink" title="7.2.1.1 级联输出"></a>7.2.1.1 级联输出</h6><p>使用 –outFile，将所有输入文件编译为单个js输出文件</p><p><code>tsc --outFile sample.js Test.ts</code></p><h6 id="7-2-1-2-自动排序输出"><a href="#7-2-1-2-自动排序输出" class="headerlink" title="7.2.1.2 自动排序输出"></a>7.2.1.2 自动排序输出</h6><p>编译器将根据文件中存在的参考标记自动排序输出文件。您还可以分别指定每个文件：</p><p><code>tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</code></p><h6 id="7-2-1-3-单个编译"><a href="#7-2-1-3-单个编译" class="headerlink" title="7.2.1.3 单个编译"></a>7.2.1.3 单个编译</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc test.ts</span><br><span class="line">tes Validation.ts</span><br></pre></td></tr></table></figure><h3 id="7-3-Aliases"><a href="#7-3-Aliases" class="headerlink" title="7.3 Aliases"></a>7.3 Aliases</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Square &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = Shapes.Polygons;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.Square(); </span><br><span class="line"><span class="comment">// Same as 'new Shapes.Polygons.Square()'</span></span><br></pre></td></tr></table></figure><h4 id="7-3-1-使用第三方JavaScript库"><a href="#7-3-1-使用第三方JavaScript库" class="headerlink" title="7.3.1 使用第三方JavaScript库"></a>7.3.1 使用第三方JavaScript库</h4><p>为了描述不是用TypeScript编写的库的形状，我们需要声明该库公开的API。因为大多数JavaScript库仅公开一些顶级对象，所以namespaces是表示它们的好方法。</p><p>D3在名为d3的全局对象中定义其功能。由于此库是通过script标签加载的，因此可以使用命名空间来声明它的shape。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> namspace D3 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Selectors &#123;</span><br><span class="line">  select: &#123;</span><br><span class="line">    (selector: <span class="built_in">string</span>): Selection;</span><br><span class="line">    (element: EventTarget): Selection;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Event &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Base <span class="keyword">extends</span> Selectors &#123;</span><br><span class="line">  event: Event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> d3: D3.Base;</span><br></pre></td></tr></table></figure><h2 id="8-三斜杠指令"><a href="#8-三斜杠指令" class="headerlink" title="8. 三斜杠指令"></a>8. 三斜杠指令</h2><p>三斜杠指令是包含单个XML标签的单行注释。注释的内容用作编译器指令。</p><p>三斜杠指令仅在其包含文件的顶部有效。三斜杠指令只能在单行或多行注释之前，包括其他三斜杠指令。如果在声明或声明之后遇到它们，则将它们视为常规的单行注释，并且没有特殊含义。</p><ul><li><code>/// &lt;reference path=&quot;./lib/index.d.ts&quot; /&gt;</code>：表示对一个文件的依赖。</li><li><code>/// &lt;reference types=&quot;jye&quot; /&gt;</code>：表示对一个库的依赖。</li></ul><p>三斜线的<code>path</code> &amp; <code>types</code>，和<code>es6</code>的<code>import</code>语义相似，同时<strong>三斜线指令必须放在文件的最顶端</strong>。例如，当我们的声明文件过于庞大，一般都会采用三斜线指令，将我们的声明文件拆分成若干个，然后由一个入口文件引入。</p><h3 id="8-1-文件之间的依赖声明"><a href="#8-1-文件之间的依赖声明" class="headerlink" title="8.1  文件之间的依赖声明"></a>8.1  文件之间的依赖声明</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path="..."/&gt;</span></span><br><span class="line"><span class="comment">///&lt;reference path="..."/&gt;   是这个group中最常见的，它用作文件之间依赖关系的声明；</span></span><br></pre></td></tr></table></figure><p>三斜杠指令指示编译器在编译过程中包括其他文件；</p><p>当使用 –out 或 –outFile时，它们还可以用作对输出进行排序的方法。预处理通过后，文件以与输入相同的顺序输出到目标文件位置。</p><h3 id="8-2-input-files-预处理"><a href="#8-2-input-files-预处理" class="headerlink" title="8.2  input files 预处理"></a>8.2  input files 预处理</h3><p>编译器对输入文件进行预处理，以解析所有三斜杠引用指令。在此过程中，其他文件将添加到编译过程中。</p><p>该过程从一组根文件开始；这些是在命令行或tsconfig.json文件的“files”列表中指定的文件名。这些根文件将按照指定的顺序进行预处理。在将文件添加到列表之前，必须先处理其中的所有三斜杠引用及其目标。按照在文件中出现的顺序，深度优先地解析三斜杠引用</p><p>A triple-slash reference path is resolved relative to the containing file, if unrooted.</p><h3 id="8-3-types"><a href="#8-3-types" class="headerlink" title="8.3 types"></a>8.3 types</h3><p><code>types=&quot;...&quot; 与 path=&quot;...&quot;</code> 类似，前者声明对包的依赖，后者声明对一个文件的依赖</p><p>这些程序包名称的解析过程与import语句中的模块名称解析过程相似。考虑三重斜杠引用类型指令的一种简单方法是将其作为声明包的导入。</p><p>在一个声明文件中包括 <code>types=&quot;node&quot;</code> 则该声明文件使用<code>@types/node/index.d.ts</code>中声明的名称，因此，此包需要与声明文件一起包含在编译中; </p><p>仅当您书写d.ts文件时，才使用这些指令；</p><p>对于编译期间生成的声明文件，编译器会自动添加<code>types=&quot;...&quot;</code>。当且仅当reslulting file使用 referenced package中 任何声明的时候，才会在生成的声明文件中添加 <code>types=&quot;...&quot;</code> ；</p><p>在 .ts 文件声明对 一个@types 包的依赖， 使用命令行 –types 或者 tsconfig.json中设置；</p><h3 id="8-4-lib"><a href="#8-4-lib" class="headerlink" title="8.4 lib"></a>8.4 lib</h3><p><code>lib=&quot;...&quot;</code> </p><p>此指令允许文件显式包括现有的内置lib文件。</p><p>例如，在编译中的一个文件中添加/// &lt;reference lib =“ es2017.string” /&gt;等效于使用–lib es2017.string进行编译。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference lib="es2017.string" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">"foo"</span>.padStart(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="9-Namespaces-and-Modules"><a href="#9-Namespaces-and-Modules" class="headerlink" title="9. Namespaces and Modules"></a>9. Namespaces and Modules</h2><h3 id="9-1-使用modules"><a href="#9-1-使用modules" class="headerlink" title="9.1 使用modules"></a>9.1 使用modules</h3><p>模块可以包含代码和声明</p><p>从es6开始，模块是语言的原生机制，新的项目，模块将是推荐的代码组织机制；</p><h3 id="9-2-使用namespaces"><a href="#9-2-使用namespaces" class="headerlink" title="9.2 使用namespaces"></a>9.2 使用namespaces</h3><p>命名空间是TypeScript特定的组织代码的方式。</p><p>命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。与模块不同，它们可以跨越多个文件，并且可以使用–outFile进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都作为script标记包含在HTML页面中。</p><p>就像所有全局命名空间污染一样，很难识别组件依赖性，尤其是在大型应用程序中。</p><h3 id="9-3-使用namespaces-和-modules-遇到的一些坑"><a href="#9-3-使用namespaces-和-modules-遇到的一些坑" class="headerlink" title="9.3 使用namespaces 和 modules 遇到的一些坑"></a>9.3 使用namespaces 和 modules 遇到的一些坑</h3><h4 id="9-3-1-不需要namespaces的时候"><a href="#9-3-1-不需要namespaces的时候" class="headerlink" title="9.3.1 不需要namespaces的时候"></a>9.3.1 不需要namespaces的时候</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `shapes.ts`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Square &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `shapeConsumer.ts`</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">"./shapes"</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.Shapes.Triangle(); <span class="comment">// shapes.Shapes?</span></span><br></pre></td></tr></table></figure><p>推荐的做法，当一个文件中定义了import/export 的时候，那么它就变成了一个模块。模块中，命名空间显然多此一举了</p><p><strong>推荐做法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Square &#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shapeConsumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">"./shapes"</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.Triangle();</span><br></pre></td></tr></table></figure><h4 id="9-3-2-reference-和import-的使用时机"><a href="#9-3-2-reference-和import-的使用时机" class="headerlink" title="9.3.2 reference 和import 的使用时机"></a>9.3.2 reference 和import 的使用时机</h4><p>一个常见的错误是尝试使用<code>/// reference ...</code>语法来引用模块文件，而不是使用<code>import</code>语句；</p><p>编译器如何 基于 <code>path of an import path(import X from &#39;xxx&#39;; import x = require(&#39;...&#39;))</code> 找到模块的类型信息；</p><p>编译器将尝试查找.ts，.tsx，然后找到具有适当路径的.d.ts。如果找不到特定的文件，然编译器会去找<code>ambient module declaration</code> 记得这些需要在 .d.ts 文件中声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myModules.d.ts</span></span><br><span class="line"><span class="comment">// In a .d.ts file or .ts file that is not a module:</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "SomeModule" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// myOtherModule.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference path="myModules.d.ts" /&gt;  记得添加依赖</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">"SomeModule"</span>; <span class="comment">// 这里并不是导入 文件名，而是模块名，因为 myModules.d.ts 不是一个模块；</span></span><br></pre></td></tr></table></figure><p><code>/// reference path=&quot;myModules.d.ts&quot;</code> 使我们能够找到包含环境模块声明的声明文件，This is how the <code>node.d.ts</code> file that several of the TypeScript samples use is consumed.</p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts generics</title>
      <link href="2021/01/20/ts-generics/"/>
      <url>2021/01/20/ts-generics/</url>
      
        <content type="html"><![CDATA[<h2 id="5-Generics"><a href="#5-Generics" class="headerlink" title="5. Generics"></a>5. Generics</h2><p>泛型，创建可重用组件的工具。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// Property 'length' does not exist on type 'T'.</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-泛型定义"><a href="#5-1-泛型定义" class="headerlink" title="5.1 泛型定义"></a>5.1 泛型定义</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">  &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity1: &#123; &lt;T&gt;(arg: T): T &#125; = identity;</span><br><span class="line"><span class="keyword">let</span> myIdentity2: GenericIdentityFn = identity;</span><br></pre></td></tr></table></figure><h3 id="5-2-泛型类"><a href="#5-2-泛型类" class="headerlink" title="5.2 泛型类"></a>5.2 泛型类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-泛型约束"><a href="#5-3-泛型约束" class="headerlink" title="5.3 泛型约束"></a>5.3 泛型约束</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-Using-Type-Parameters-in-Generic-Constraints"><a href="#5-3-1-Using-Type-Parameters-in-Generic-Constraints" class="headerlink" title="5.3.1 Using Type Parameters in Generic Constraints"></a>5.3.1 Using Type Parameters in Generic Constraints</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">"a"</span>);</span><br><span class="line">getProperty(x, <span class="string">"m"</span>);</span><br><span class="line"><span class="comment">// Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.</span></span><br></pre></td></tr></table></figure><h4 id="5-3-2-泛型类"><a href="#5-3-2-泛型类" class="headerlink" title="5.3.2 泛型类"></a>5.3.2 泛型类</h4><p>使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c: &#123; <span class="keyword">new</span> (): T &#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">  hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">  nametag: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  numLegs: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c: <span class="keyword">new</span> () =&gt; A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;</span><br><span class="line">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts doc</title>
      <link href="2021/01/19/ts-doc/"/>
      <url>2021/01/19/ts-doc/</url>
      
        <content type="html"><![CDATA[<h1 id="handbook"><a href="#handbook" class="headerlink" title="handbook"></a>handbook</h1><p><strong>A reader who completes the walkthrough should be able to:</strong></p><ul><li>Read and understand commonly-used TypeScript syntax and patterns</li><li>Explain the effects of important compiler options</li><li>Correctly predict type system behavior in most cases</li><li>Write a .d.ts declaration for a simple function, object, or class</li></ul><h2 id="1-basic-Types"><a href="#1-basic-Types" class="headerlink" title="1. basic Types"></a>1. basic Types</h2><p> 在TypeScript中，我们支持与JavaScript中期望的类型相同的类型，并添加了一个额外的枚举类型以帮助处理问题。</p><p>Boolean, Number, String, Array,Tuple,Enum,Unkown,Any,Void, Null and Undefined, Never, Object,</p><ul><li>Tuple</li></ul><p>元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对字符串和一个数字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">"hello"</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">"hello"</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><ul><li>Enum</li></ul><p>枚举是JavaScript标准数据类型集的一个有用补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays 'Green'</span></span><br><span class="line"><span class="built_in">console</span>.log(colorName);</span><br></pre></td></tr></table></figure><ul><li>Unknown</li></ul><p>我们可能需要描述编写应用程序时不知道的变量类型。这些值可能来自动态内容，例如来自用户-或者我们可能要有意接受我们API中的所有值。在这些情况下，我们希望提供一种类型，该类型告诉编译器和将来的读者此变量可以是任何变量，因此我们将其赋予未知类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: unknown = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, definitely a boolean</span></span><br><span class="line">notSure = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果您有一个类型未知的变量，则可以通过进行typeof检查，比较检查或更高级的类型防护来将其范围缩小到更具体的范围;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> maybe: unknown;</span><br><span class="line"><span class="comment">// 'maybe' could be a string, object, boolean, undefined, or other types</span></span><br><span class="line"><span class="keyword">const</span> aNumber: <span class="built_in">number</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'unknown' is not assignable to type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (maybe === <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TypeScript knows that maybe is a boolean now</span></span><br><span class="line">  <span class="keyword">const</span> aBoolean: <span class="built_in">boolean</span> = maybe;</span><br><span class="line">  <span class="comment">// So, it cannot be a string</span></span><br><span class="line">  <span class="keyword">const</span> aString: <span class="built_in">string</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'boolean' is not assignable to type 'string'.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> maybe === <span class="string">"string"</span>) &#123;</span><br><span class="line">  <span class="comment">// TypeScript knows that maybe is a string</span></span><br><span class="line">  <span class="keyword">const</span> aString: <span class="built_in">string</span> = maybe;</span><br><span class="line">  <span class="comment">// So, it cannot be a boolean</span></span><br><span class="line">  <span class="keyword">const</span> aBoolean: <span class="built_in">boolean</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'string' is not assignable to type 'boolean'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Any</li></ul><p>在某些情况下，并非所有类型信息都可用。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况，可能要选择退出类型检查。将这些值标记为any类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="comment">// OK, return value of 'getValue' is not checked</span></span><br><span class="line"><span class="keyword">const</span> str: <span class="built_in">string</span> = getValue(<span class="string">"myString"</span>);</span><br></pre></td></tr></table></figure><p>与 unknown 不同，any类型的变量使您可以访问任意属性，甚至是不存在的属性。这些属性包括函数，并且TypeScript不会检查它们的存在或类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> looselyTyped: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// OK, ifItExists might exist at runtime</span></span><br><span class="line">looselyTyped.ifItExists();</span><br><span class="line"><span class="comment">// OK, toFixed exists (but the compiler doesn't check)</span></span><br><span class="line">looselyTyped.toFixed();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strictlyTyped: unknown = <span class="number">4</span>;</span><br><span class="line">strictlyTyped.toFixed();</span><br><span class="line"><span class="comment">// Object is of type 'unknown'.</span></span><br></pre></td></tr></table></figure><ul><li>Void</li></ul><p>void有点像任何其他的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Null and Undefined</li></ul><p>在TypeScript中，undefined和null实际上实际上分别将其类型命名为undefined和null。就像void一样，它们本身并不是非常有用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>Never</li></ul><p>The <code>never</code> type is a subtype of, and assignable to, every type; however, <em>no</em> type is a subtype of, or assignable to, <code>never</code> (except <code>never</code> itself). Even <code>any</code> isn’t assignable to <code>never</code>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function returning never must not have a reachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred return type is never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function returning never must not have a reachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object</li></ul><p>object是代表非基本类型的类型，即不是数字，字符串，布尔值，bigint，symbol，null或undefined的任何类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With object type, APIs like Object.create can be better represented.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">create(&#123; prop: <span class="number">0</span> &#125;);</span><br><span class="line">create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//Argument of type '42' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="string">"string"</span>);</span><br><span class="line"><span class="comment">//Argument of type '"string"' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//Argument of type 'false' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">//Argument of type 'undefined' is not assignable to parameter of type 'object | null'.</span></span><br></pre></td></tr></table></figure><ul><li>Type assertions</li></ul><p>类型断言是一种告诉编译器“相信我，我知道我在做什么”的方法。类型断言就像其他语言中的类型转换一样，但是它不执行数据的特殊检查或重构。它对运行时没有影响，仅由编译器使用。 TypeScript假定您（程序员）已经执行了所需的任何特殊检查。</p><p>类型断言的两种形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型1: as 语句</span></span><br><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"><span class="comment">// 类型2: 尖括号</span></span><br><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><p>jsx中无法使用 类型2；</p><ul><li>About Number, String, Boolean, Symbol and Object</li></ul><p>可能会认为数字，字符串，布尔值，符号或对象类型与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎永远不应将其用作类型。</p><h2 id="2-interface"><a href="#2-interface" class="headerlink" title="2. interface"></a>2. interface</h2><h3 id="2-1-readonly"><a href="#2-1-readonly" class="headerlink" title="2.1 readonly"></a>2.1 readonly</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript具有与Array <T>相同的ReadonlyArray <T>类型，并且删除了所有变异方法，因此可以确保创建后不更改数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Index signature in type 'readonly number[]' only permits reading.</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Property 'push' does not exist on type 'readonly number[]'.</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Cannot assign to 'length' because it is a read-only property.</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.</span></span><br></pre></td></tr></table></figure><p>在代码片段的最后一行，您可以看到，即使将整个ReadonlyArray分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><ul><li>ReadOnly or const</li></ul><p>记住是使用只读还是const的最简单方法是询问是否在变量或属性上使用它。变量使用const，而属性使用只读。</p><h3 id="2-2-Optional"><a href="#2-2-Optional" class="headerlink" title="2.2 Optional"></a>2.2 Optional</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Excess-Property-Checks"><a href="#2-3-Excess-Property-Checks" class="headerlink" title="2.3 Excess Property Checks"></a>2.3 Excess Property Checks</h3><p>但是，TypeScript认为此代码中可能存在错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行过多的属性检查。如果对象文字具有“目标类型”所没有的任何属性，则会出现错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    color: config.color || <span class="string">"red"</span>,</span><br><span class="line">    area: config.width ? config.width * config.width : <span class="number">20</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="comment">//Argument of type '&#123; colour: string; width: number; &#125;' is not assignable to parameter of type 'SquareConfig'.</span></span><br><span class="line"> <span class="comment">// Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?</span></span><br></pre></td></tr></table></figure><ul><li>解决方案</li></ul><ol><li>解决这些检查实际上非常简单。最简单的方法是只使用类型断言：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySquare = createSquare(&#123;width: <span class="number">100</span>, opacity: <span class="number">0.5</span>&#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure><ol start="2"><li>如果对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mySquare = createSquare(&#123;width: <span class="number">100</span>, opacity: <span class="number">0.5</span>&#125;);</span><br><span class="line"><span class="comment">// 只要您在squareOptions和SquareConfig之间具有一个公共属性，上述变通办法就会起作用。但是，如果变量没有任何公共对象属性，它将失败。</span></span><br><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">"red"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br><span class="line"><span class="comment">// Type '&#123; colour: string; &#125;' has no properties in common with type 'SquareConfig'.</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Function-Types"><a href="#2-4-Function-Types" class="headerlink" title="2.4 Function Types"></a>2.4 Function Types</h3><p>为了描述带有接口的函数类型，我们给接口一个调用签名。这就像只声明参数列表和返回类型的函数声明。参数列表中的每个参数都需要名称和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch2: SearchFunc;</span><br><span class="line"><span class="comment">// 参数不定义string，ts会自动推断</span></span><br><span class="line">mySearch2 = <span class="function"><span class="keyword">function</span> (<span class="params">src, sub</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">src, sub</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回值需要遵守interface</span></span><br><span class="line"><span class="comment">//Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.</span></span><br><span class="line"><span class="comment">//  Type 'string' is not assignable to type 'boolean'.</span></span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"string"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-5-Indexable-Types"><a href="#2-5-Indexable-Types" class="headerlink" title="2.5 Indexable Types"></a>2.5 Indexable Types</h3><p>可索引类型具有索引签名，该签名描述了可用于索引对象的类型以及建立索引时对应的返回类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为在用数字索引时，JavaScript实际上会在将其索引到对象之前将其转换为字符串。这意味着使用100（一个数字）进行索引与使用“ 100”（一个字符串）进行索引是同一回事，因此两者必须保持一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: indexing with a numeric string might get you a completely separate type of Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">  [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">Numeric index <span class="keyword">type</span> <span class="string">'Animal'</span> is not assignable to <span class="built_in">string</span> index <span class="keyword">type</span> <span class="string">'Dog'</span>.</span><br><span class="line">  [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管字符串索引签名是描述“字典”模式的强大方法，但它们还强制所有属性与其返回类型匹配。这是因为字符串索引声明obj.property也可以作为obj [“ property”]使用。在以下示例中，名称的类型与字符串索引的类型不匹配，并且类型检查器给出错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>; <span class="comment">// ok, length is a number</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// error, the type of 'name' is not a subtype of the indexer</span></span><br><span class="line"><span class="comment">// Property 'name' of type 'string' is not assignable to string index type 'number'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果索引签名是属性类型的并集，则可以接受不同类型的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberOrStringDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span> | <span class="built_in">string</span>; <span class="comment">// 属性类型</span></span><br><span class="line">  length: <span class="built_in">number</span>; <span class="comment">// ok, length is a number</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// ok, name is a string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，您可以将索引签名设为只读，以防止分配给它们的索引：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">  readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">"Mallory"</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">// Index signature in type 'ReadonlyStringArray' only permits reading.</span></span><br></pre></td></tr></table></figure><h3 id="2-6-Class-Types"><a href="#2-6-Class-Types" class="headerlink" title="2.6 Class Types"></a>2.6 Class Types</h3><h4 id="2-6-1-Implement"><a href="#2-6-1-Implement" class="headerlink" title="2.6.1 Implement"></a>2.6.1 Implement</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为当类实现接口时，仅检查该类的实例侧。由于构造函数位于静态端，因此它不包含在此检查中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">  <span class="comment">// Class 'Clock' incorrectly implements interface 'ClockConstructor'.</span></span><br><span class="line"> <span class="comment">//  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.</span></span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> Clock(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>需要直接使用类的静态方面。在此示例中，我们定义了两个接口，用于构造函数的ClockConstructor和用于实例方法的ClockInterface。然后，为方便起见，我们定义了一个构造函数createClock，该函数创建传递给它的类型的实例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: ClockConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">  hour: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  minute: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure><p>另一种简单的方法是使用类表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Clock: ClockConstructor = <span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clock = <span class="keyword">new</span> Clock(<span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line">clock.tick();</span><br></pre></td></tr></table></figure><h3 id="2-7-Extending-Interfaces"><a href="#2-7-Extending-Interfaces" class="headerlink" title="2.7 Extending Interfaces"></a>2.7 Extending Interfaces</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h3 id="2-8-Hybrid-Types"><a href="#2-8-Hybrid-Types" class="headerlink" title="2.8 Hybrid Types"></a>2.8 Hybrid Types</h3><p>an object that acts as both a function and an object, with additional properties:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125; <span class="keyword">as</span> Counter;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><p>与第三方JavaScript交互时，您可能需要使用上述模式来完全描述类型的形状</p><h3 id="2-9-Interfaces-Extending-Classes"><a href="#2-9-Interfaces-Extending-Classes" class="headerlink" title="2.9 Interfaces Extending Classes"></a>2.9 Interfaces Extending Classes</h3><p>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</p><p>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ImageControl <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line"><span class="comment">//Class 'ImageControl' incorrectly implements interface 'SelectableControl'.</span></span><br><span class="line"> <span class="comment">// Types have separate declarations of a private property 'state'.</span></span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        In the above example, <code>SelectableControl</code> contains all of the members of <code>Control</code>, including the private <code>state</code> property. Since <code>state</code> is a private member it is only possible for descendants of <code>Control</code> to implement <code>SelectableControl</code>. This is because only descendants of <code>Control</code> will have a <code>state</code> private member that originates in the same declaration, which is a requirement for private members to be compatible.</p><p>​        Within the <code>Control</code> class it is possible to access the <code>state</code> private member through an instance of <code>SelectableControl</code>. Effectively, a <code>SelectableControl</code> acts like a <code>Control</code> that is known to have a <code>select</code> method. The <code>Button</code> and <code>TextBox</code> classes are subtypes of <code>SelectableControl</code> (because they both inherit from <code>Control</code> and have a <code>select</code> method). The <code>ImageControl</code> class has it’s own <code>state</code> private member rather than extending <code>Control</code>, so it cannot implement <code>SelectableControl</code>.</p><h2 id="3-Functions"><a href="#3-Functions" class="headerlink" title="3. Functions"></a>3. Functions</h2><p>在TypeScript中，尽管有类，名称空间和模块，但是函数仍然在描述操作方式中起着关键作用。 TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。</p><h3 id="3-1-this"><a href="#3-1-this" class="headerlink" title="3.1 this"></a>3.1 this</h3><p>Learning how to use <code>this</code> in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use <code>this</code> and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of <code>this</code> with a couple of techniques. If you need to learn how <code>this</code> works in JavaScript, though, first read Yehuda Katz’s <a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">Understanding JavaScript Function Invocation and “this”</a>. Yehuda’s article explains the inner workings of <code>this</code> very well, so we’ll just cover the basics here.</p><p><strong><code>this</code> and arrow functions</strong></p><p>In JavaScript, <code>this</code> is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</p><p>Let’s look at an example:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Notice that <code>createCardPicker</code> is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the <code>this</code> being used in the function created by <code>createCardPicker</code> will be set to <code>window</code> instead of our <code>deck</code> object. That’s because we call <code>cardPicker()</code> on its own. A top-level non-method syntax call like this will use <code>window</code> for <code>this</code>. (Note: under strict mode, <code>this</code> will be <code>undefined</code> rather than <code>window</code>).</p><p>We can fix this by making sure the function is bound to the correct <code>this</code> before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original <code>deck</code> object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the <code>this</code> where the function is created rather than where it is invoked:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture 'this' right here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Even better, TypeScript will warn you when you make this mistake if you pass the <code>--noImplicitThis</code> flag to the compiler. It will point out that <code>this</code> in <code>this.suits[pickedSuit]</code> is of type <code>any</code>.</p><p><strong><code>this</code> parameters</strong></p><p>Unfortunately, the type of <code>this.suits[pickedSuit]</code> is still <code>any</code>. That’s because <code>this</code> comes from the function expression inside the object literal. To fix this, you can provide an explicit <code>this</code> parameter. <code>this</code> parameters are fake parameters that come first in the parameter list of a function:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// make sure `this` is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s add a couple of interfaces to our example above, <code>Card</code> and <code>Deck</code>, to make the types clearer and easier to reuse:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">  suit: <span class="built_in">string</span>;</span><br><span class="line">  card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">  suits: <span class="built_in">string</span>[];</span><br><span class="line">  cards: <span class="built_in">number</span>[];</span><br><span class="line">  createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Now TypeScript knows that <code>createCardPicker</code> expects to be called on a <code>Deck</code> object. That means that <code>this</code> is of type <code>Deck</code> now, not <code>any</code>, so <code>--noImplicitThis</code> will not cause any errors.</p><p><strong><code>this</code> parameters in callbacks</strong></p><p>You can also run into errors with <code>this</code> in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, <code>this</code> will be <code>undefined</code>. With some work you can use <code>this</code> parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">  addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type. Second, annotate your calling code with <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickBad(<span class="keyword">this</span>: Handler, e: Event) &#123;</span><br><span class="line">    <span class="comment">// oops, used `this` here. using this callback would crash at runtime</span></span><br><span class="line">    <span class="keyword">this</span>.info = e.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'.</span></span><br><span class="line">  <span class="comment">//The 'this' types of each signature are incompatible.</span></span><br><span class="line">   <span class="comment">// Type 'void' is not assignable to type 'Handler'.Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'.</span></span><br><span class="line"> <span class="comment">// The 'this' types of each signature are incompatible.</span></span><br><span class="line"> <span class="comment">//   Type 'void' is not assignable to type 'Handler'.</span></span><br></pre></td></tr></table></figure><p>With <code>this</code> annotated, you make it explicit that <code>onClickBad</code> must be called on an instance of <code>Handler</code>. Then TypeScript will detect that <code>addClickListener</code> requires a function that has <code>this: void</code>. To fix the error, change the type of <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickGood(<span class="keyword">this</span>: <span class="built_in">void</span>, e: Event) &#123;</span><br><span class="line">    <span class="comment">// can't use `this` here because it's of type void!</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"clicked!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickGood);</span><br></pre></td></tr></table></figure><p>Because <code>onClickGood</code> specifies its <code>this</code> type as <code>void</code>, it is legal to pass to <code>addClickListener</code>. Of course, this also means that it can’t use <code>this.info</code>. If you want both then you’ll have to use an arrow function:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.info = e.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This works because arrow functions use the outer <code>this</code>, so you can always pass them to something that expects <code>this: void</code>. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler.</p><h3 id="3-2-Overloads"><a href="#3-2-Overloads" class="headerlink" title="3.2 Overloads"></a>3.2 Overloads</h3><p>JavaScript本质上是一种非常动态的语言。一个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">  <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">    <span class="keyword">return</span> pickedCard;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure><h2 id="4-Classes"><a href="#4-Classes" class="headerlink" title="4. Classes"></a>4. Classes</h2><h3 id="4-1-abstract"><a href="#4-1-abstract" class="headerlink" title="4.1 abstract"></a>4.1 abstract</h3><p> abstract关键字用于定义抽象类以及抽象类中的抽象方法。</p><p>抽象类， 是可以从中派成出其他类的基类；简单说就是只能被继承，不能new出实例；与interface不同的是，抽象类中可以有成员实现的详细信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> App &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> setTargetProps&lt;T&gt; (target: T, source: Partial&lt;T&gt;): T &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(target).forEach(<span class="function">(<span class="params">property: keyof T</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setTargetPropsByProperty(target, property, source[property])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> App();</span><br><span class="line"><span class="comment">// Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> App&#123;&#125;;</span><br><span class="line"><span class="comment">// 非抽象类“ B”未实现从类“ App”继承的抽象成员“ make”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C <span class="keyword">extends</span> App&#123;</span><br><span class="line">  make()&#123;&#125; <span class="comment">// 需要实现抽象类中定义的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含abstract关键字，并且可以选择包括访问修饰符。</p><h3 id="4-2-public-private-and-protected"><a href="#4-2-public-private-and-protected" class="headerlink" title="4.2 public,private, and protected"></a>4.2 public,private, and protected</h3><h4 id="4-2-1-类型兼容"><a href="#4-2-1-类型兼容" class="headerlink" title="4.2.1 类型兼容"></a>4.2.1 类型兼容</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"Rhino"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Goat"</span>);</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; </span><br><span class="line"><span class="comment">// Type 'Employee' is not assignable to type 'Animal'. 没有继承关系的类型无法做赋值操作；</span></span><br><span class="line"><span class="comment">//  Types have separate declarations of a private property 'name'</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-protected"><a href="#4-2-2-protected" class="headerlink" title="4.2.2 protected"></a>4.2.2 protected</h4><p>protected修饰符的行为与private修饰符非常相似，除了声明为protected的成员也可以在派生类中访问之外；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">    <span class="comment">// 派生类中可以访问到 基类中的 protected 属性；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch());</span><br><span class="line"><span class="comment">// 虽然我们不能从Person外部使用name，但仍可以在Employee的实例方法中使用它，因为Employee源自Person。</span></span><br><span class="line"><span class="built_in">console</span>.log(howard.name);</span><br><span class="line"><span class="comment">// Property 'name' is protected and only accessible within class 'Person' and its subclasses.</span></span><br></pre></td></tr></table></figure><p>构造函数也可能被标记为受保护的。这意味着该类不能在其包含的类之外实例化，但是可以扩展。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee can extend Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>);</span><br><span class="line"><span class="comment">// Constructor of class 'Person' is protected and only accessible within the class declaration. 因为 new Person的时候是需要调 Person的构造函数，由于其构造函数添加了 protected关键字。实例是无法调类的构造函数的，所以就无法被实例化了；</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-Readonly"><a href="#4-2-3-Readonly" class="headerlink" title="4.2.3 Readonly"></a>4.2.3 Readonly</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">readonly theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dad = <span class="keyword">new</span> Octopus(<span class="string">"Man with the 8 strong legs"</span>);</span><br><span class="line">dad.name = <span class="string">"Man with the 3-piece suit"</span>;</span><br><span class="line"><span class="comment">// Cannot assign to 'name' because it is a read-only property.</span></span><br><span class="line"><span class="built_in">console</span>.log(dad.name)</span><br></pre></td></tr></table></figure><h4 id="4-2-4-accessors"><a href="#4-2-4-accessors" class="headerlink" title="4.2.4 accessors"></a>4.2.4 accessors</h4><p>TypeScript支持getters / setter方法，以拦截对对象成员的访问。这使您可以更好地控制如何访问每个对象上的成员的方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  fullName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此版本中，我们添加了一个setter来检查newName的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是这样，我们会抛出错误通知客户端代码出了点问题。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullNameMaxLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span> = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"fullName has a max length of "</span> + fullNameMaxLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><p>首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。</p><p>其次，带有get和no set的访问器会自动推断为只读。当代码生成.d.ts文件时很有用，因为用户通过ide可以看到这些无法进行更改。</p><h4 id="4-2-5-Static"><a href="#4-2-5-Static" class="headerlink" title="4.2.5 Static"></a>4.2.5 Static</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Grid &#123;</span><br><span class="line">  <span class="keyword">static</span> origin = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  calculateDistanceFromOrigin(point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDist = point.x - Grid.origin.x;</span><br><span class="line">    <span class="keyword">let</span> yDist = point.y - Grid.origin.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>); <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>); <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;));</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;));</span><br></pre></td></tr></table></figure><h4 id="4-2-6-Using-a-class-as-an-interface"><a href="#4-2-6-Using-a-class-as-an-interface" class="headerlink" title="4.2.6 Using a class as an interface"></a>4.2.6 Using a class as an interface</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="5-Decorators"><a href="#5-Decorators" class="headerlink" title="5. Decorators"></a>5. Decorators</h2><p>随着TypeScript和ES6中类的引入，现在存在某些情况，这些情况需要附加功能来支持  annotating or modifying classes and class members。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的第2阶段提议，可作为TypeScript的实验功能使用。</p><p>JavaScript引入class之后，我们需要在不同的类之间共享或者扩展一些方法或行为的时候，代码会变得很复杂，不够优雅，这也是装饰器被提出的一个很重要原因之一；</p><p>要为装饰器启用实验性支持，必须在命令行或tsconfig.json中启用experimentalDecorators编译器选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰器是一种特殊的声明，可以附加到类声明，方法，访问器，属性或参数上。装饰器使用<code>@expression</code>形式，其中expression求值之后必须也是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入；</p><h3 id="5-1-class-decorators"><a href="#5-1-class-decorators" class="headerlink" title="5.1 class decorators"></a>5.1 class decorators</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.age = 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addName</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.name = "leo";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span></span><br><span class="line"><span class="meta">@addName</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age, person.name); <span class="comment">// 18 ,'age'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line"><span class="keyword">var</span> __decorate = <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length,</span><br><span class="line">    r =</span><br><span class="line">      c &lt; <span class="number">3</span></span><br><span class="line">        ? target</span><br><span class="line">        : desc === <span class="literal">null</span></span><br><span class="line">        ? (desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key))</span><br><span class="line">        : desc;</span><br><span class="line">  <span class="keyword">var</span> d;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">"function"</span>) &#123;</span><br><span class="line">    r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> ((d = decorators[i]))</span><br><span class="line">        <span class="comment">// 核心代码就是 d(r) r为构造函数Person</span></span><br><span class="line">        r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.age = 18;</span><br><span class="line">&#125;</span><br><span class="line">function addName(<span class="keyword">constructor</span>) &#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.name = "leo";</span><br><span class="line">&#125;</span><br><span class="line">var Person = /** @class */ (function () &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Person = __decorate([addAge, addName], Person);</span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.age, person.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-reflect-metadata"><a href="#5-2-reflect-metadata" class="headerlink" title="5.2 reflect-metadata"></a>5.2 reflect-metadata</h3><p><strong>install</strong></p><p><code>npm install reflect-metadata</code></p><p><strong>demo</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span>;</span><br><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>, <span class="string">"alex"</span>, target);</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>, <span class="string">"world"</span>, target, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getOwnMetadata(<span class="string">"name"</span>, target)); <span class="comment">// alex</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getOwnMetadata(<span class="string">"name"</span>, target, <span class="string">"hello"</span>)); <span class="comment">// world</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classMetadata</span>(<span class="params">key: <span class="built_in">any</span>, value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    Reflect.defineMetadata(key, value, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodMetadata</span>(<span class="params">key: <span class="built_in">any</span>, value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyName: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Person.prototype.hello.name=world</span></span><br><span class="line">    Reflect.defineMetadata(key, value, target, propertyName);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给类本身增加元数据</span></span><br><span class="line"><span class="comment">//@Reflect.metadata('name','Person')</span></span><br><span class="line"><span class="meta">@classMetadata</span>(<span class="string">"name"</span>, <span class="string">"Person"</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">//给类的原型增加元数据</span></span><br><span class="line">  <span class="comment">//@Reflect.metadata('name', 'world')</span></span><br><span class="line">  <span class="meta">@methodMetadata</span>(<span class="string">"name"</span>, <span class="string">"world"</span>)</span><br><span class="line">  hello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>, Person)); <span class="comment">// Person</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>, <span class="keyword">new</span> Person(), <span class="string">"hello"</span>)); <span class="comment">// world</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html5vedio</title>
      <link href="2021/01/04/html5vedio/"/>
      <url>2021/01/04/html5vedio/</url>
      
        <content type="html"><![CDATA[<h4 id="html5-播放器加速"><a href="#html5-播放器加速" class="headerlink" title="html5 播放器加速"></a>html5 播放器加速</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"></span><br><span class="line">video.playbackRate = <span class="number">2</span> <span class="comment">// 播放器播放速度</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browser-sync</title>
      <link href="2020/12/21/browser-sync/"/>
      <url>2020/12/21/browser-sync/</url>
      
        <content type="html"><![CDATA[<h2 id="全局安装1231312312312123"><a href="#全局安装1231312312312123" class="headerlink" title="全局安装1231312312312123"></a>全局安装1231312312312123</h2><p><code>sudo npm install -g browser-sync</code></p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器 监听所有的html文件</span></span><br><span class="line">$ browser-sync start --server --files <span class="string">"*.html"</span></span><br><span class="line"><span class="comment"># 启动服务器 监听所有的文件</span></span><br><span class="line">$ browser-sync start --server --files <span class="string">"**"</span></span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>browser-sync start --server --port 3333 --files &quot;*.css,*.html,*.js&quot;</code></p><h2 id="start-options"><a href="#start-options" class="headerlink" title="start options"></a>start options</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">help</span>                 <span class="comment">#输出使用信息</span></span><br><span class="line">--version               <span class="comment">#输出的版本号</span></span><br><span class="line">--browser               <span class="comment">#选择哪个浏览器应该是自动打开</span></span><br><span class="line">--files                 <span class="comment">#文件路径看</span></span><br><span class="line">--exclude               <span class="comment">#文件模式忽视</span></span><br><span class="line">--server               <span class="comment">#运行本地服务器（使用您的CWD作为Web根）</span></span><br><span class="line">--index                 <span class="comment">#指定哪些文件应该被用作索引页</span></span><br><span class="line">--extensions           <span class="comment">#指定文件扩展名回退</span></span><br><span class="line">--startPath             <span class="comment">#指定起始路径，打开浏览器</span></span><br><span class="line">--https                 <span class="comment">#启用S​​SL地方发展</span></span><br><span class="line">--directory             <span class="comment">#显示服务器的目录列表</span></span><br><span class="line">--proxy                 <span class="comment">#代理现有的服务器</span></span><br><span class="line">--xip                   <span class="comment">#使用xip.io域路由</span></span><br><span class="line">--tunnel               <span class="comment">#使用公共网址</span></span><br><span class="line">--open                 <span class="comment">#选择哪个URL是自动打开（本地，外部或隧道）</span></span><br><span class="line">--config               <span class="comment">#指定为BS-config.js文件的路径</span></span><br><span class="line">--host                 <span class="comment">#指定主机名使用</span></span><br><span class="line">--logLevel             <span class="comment">#设置记录器输出电平（沉默，信息或调试）</span></span><br><span class="line">--port                <span class="comment">#指定要使用的端口</span></span><br><span class="line">--reload-delay        <span class="comment">#以毫秒为单位的时间延迟重装事件以下文件的变化</span></span><br><span class="line">--reload-debounce      <span class="comment">#限制在浏览器中的频率：刷新事件可以被发射到连接的客户机</span></span><br><span class="line">--ui-port              <span class="comment">#指定端口的UI使用</span></span><br><span class="line">--no-notify            <span class="comment">#禁用浏览器的通知元素</span></span><br><span class="line">--no-open              <span class="comment">#不要打开一个新的浏览器窗口</span></span><br><span class="line">--no-online            <span class="comment">#强制离线使用</span></span><br><span class="line">--no-ui                <span class="comment">#不要启动用户界面</span></span><br><span class="line">--no-ghost-mode        <span class="comment">#禁用幽灵模式</span></span><br><span class="line">--no-inject-changes    <span class="comment">#刷新上的每个文件更改</span></span><br><span class="line">--no-reload-on-restart<span class="comment">#不要自动重新加载在重新启动所有浏览器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab3</title>
      <link href="2020/12/17/gitlab3/"/>
      <url>2020/12/17/gitlab3/</url>
      
        <content type="html"><![CDATA[<h2 id="gitlab-分支策略"><a href="#gitlab-分支策略" class="headerlink" title="gitlab 分支策略"></a>gitlab 分支策略</h2><blockquote><p>考虑到gitlab一般在企业内部使用，一般不存在社区开发者，所以在管理上不会采用github的upstream/origin双仓库模式。gitlab下，开发者们面向一个仓库进行提交即可；</p></blockquote><h3 id="设置对分支的保护权限"><a href="#设置对分支的保护权限" class="headerlink" title="设置对分支的保护权限"></a>设置对分支的保护权限</h3><blockquote><p>顾名思义，分支的权限必不可少，它可以约束开发者们的提交行为和提交策略。避免失误操作将未测试过的代码强制提交到生产分支；developer可以不关心；</p></blockquote><p><img src="branch.png" alt="Protected Branches"></p><h3 id="issue与Milestones"><a href="#issue与Milestones" class="headerlink" title="issue与Milestones"></a>issue与Milestones</h3><blockquote><p>issue可以理解为一个最小原子的任务，多个任务组成一个 milestones；Milestones 可以理解为某个时间区间内的任务集；一个Milestones可包含多个issue； 当该Milestones中所有issue完成，则标志着此Milestones的结束；</p></blockquote><h4 id="创建issue和mr"><a href="#创建issue和mr" class="headerlink" title="创建issue和mr"></a>创建issue和mr</h4><ol><li>创建一个issue</li></ol><p><img src="issue.png" alt="issue"></p><ol start="2"><li>关联一个mr</li></ol><p><img src="mr.png" alt="mr"></p><ol start="3"><li>branch name</li></ol><blockquote><p>branch name 会以issue的序号开始，然后抓取title中的英文和数字做连接。</p></blockquote><p>可采用<code>index-categroy-content-[username]-[time]</code>的自定义方式，括号部分可选</p><ul><li><p>category</p><ul><li>feature</li><li>bugfix</li><li>chore</li><li>enhance</li></ul></li><li><p>content，一到三个词简述任务</p></li><li><p>username，任务认领人</p></li><li><p>time，创建分支的时间，一般 <code>201217</code>或者<code>1225</code></p></li></ul><ol start="4"><li>source</li></ol><p>基于什么分支创建当前分支，<code>feature/chore/enhance</code>选择<code>dev-0.3</code>, <code>bugfix</code>选择<code>env-dev</code></p><h3 id="提交代码流程"><a href="#提交代码流程" class="headerlink" title="提交代码流程"></a>提交代码流程</h3><p><img src="flow.jpg" alt="flow"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch <span class="comment"># 获取issue关联的分支名</span></span><br><span class="line">git checkout -b 6-feature-pivotDrill origin/6-feature-pivotDrill <span class="comment"># 基于远端新建一个本地开发分支</span></span><br><span class="line"></span><br><span class="line">git rebase dev-0.3 <span class="comment"># 在开发过程中，不定时rebase 宿主分支，防止版本隔断</span></span><br><span class="line">git push origin 6-feature-pivotDrill <span class="comment"># 提交至远程映射</span></span><br><span class="line"><span class="comment"># 通知maintainer完成代码合并，并关闭issue</span></span><br></pre></td></tr></table></figure><h3 id="commits规范"><a href="#commits规范" class="headerlink" title="commits规范"></a>commits规范</h3><p><code>&#39;type(module) some desc&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type = [</span><br><span class="line">  <span class="string">"build"</span>, <span class="comment">// 构建执行</span></span><br><span class="line">  <span class="string">"chore"</span>, <span class="comment">// 构建工具相关</span></span><br><span class="line">  <span class="string">"ci"</span>, <span class="comment">// CI 相关</span></span><br><span class="line">  <span class="string">"docs"</span>, <span class="comment">// 文档更新</span></span><br><span class="line">  <span class="string">"feat"</span>, <span class="comment">// 新功能</span></span><br><span class="line">  <span class="string">"fix"</span>, <span class="comment">// bug 修复</span></span><br><span class="line">  <span class="string">"perf"</span>, <span class="comment">// 性能优化</span></span><br><span class="line">  <span class="string">"refactor"</span>, <span class="comment">// 功能重构</span></span><br><span class="line">  <span class="string">"release"</span>,</span><br><span class="line">  <span class="string">"revert"</span>, <span class="comment">// 回滚操作</span></span><br><span class="line">  <span class="string">"style"</span>, <span class="comment">// 样式变动</span></span><br><span class="line">  <span class="string">"test"</span>, <span class="comment">// 单元测试</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">moduele = [</span><br><span class="line">  <span class="comment">// 以davinci为例,只列出前端模块</span></span><br><span class="line">  <span class="string">"project"</span>,</span><br><span class="line">  <span class="string">"dashboard"</span>,</span><br><span class="line">  <span class="string">"display"</span>,</span><br><span class="line">  <span class="string">"widget"</span>,</span><br><span class="line">  <span class="string">"schdule"</span>,</span><br><span class="line">  <span class="string">"view"</span>,</span><br><span class="line">  <span class="string">"source"</span>,</span><br><span class="line">  <span class="string">"user"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="review代码的参考标准"><a href="#review代码的参考标准" class="headerlink" title="review代码的参考标准"></a>review代码的参考标准</h3><ol><li>格式化后的代码，在vscode中安装<code>prettier</code>工具，设置<code>ctrl+s</code>默认对当前页进行<code>prettier</code>格式化；</li><li>所有commits必须要关联issue，如果没有issue要新建issue然后关联mr（merge request），基于当前mr提交代码；</li><li>原则上，不能有肉眼可见的bug，一般review代码时会进行简单的测试；</li><li>其他规则（代码规范）</li></ol><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><blockquote><p>原则上，所有新提交的代码参考项目代码风格即可。简述为下面几个方面</p></blockquote><ol><li>原则上，变量名含义精准，（ps：严禁全局作用域中出现单字符命名空间；）</li><li>不要求一定要加注释或者不加注释，我们的愿景是能够书写无注释就能看懂的代码。根据业务逻辑难易程度，自行决定。 尽量英文注释；</li><li>不建议提交大量重复代码，须做好代码的抽象复用；</li><li>尽量使用被主流浏览器支持的的es规范书写代码，原则上新es规范下已有的工具类和函数，不重复造轮子；</li><li>其他涉及<code>html/css/javascript</code>相关的推荐规范会渐进式纳入规范集；</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab2</title>
      <link href="2020/12/16/gitlab2/"/>
      <url>2020/12/16/gitlab2/</url>
      
        <content type="html"><![CDATA[<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p><img src="label.png" alt="label"></p><h3 id="标签组"><a href="#标签组" class="headerlink" title="标签组"></a>标签组</h3><blockquote><p>标签组的意义就是定义一次，多个项目统一使用</p></blockquote><h4 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h4><blockquote><p>前端还是后端，ios 还是 android</p></blockquote><ul><li>angular</li><li>node</li></ul><h4 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h4><blockquote><p>目前产品中存在的问题，以及该问题的优先级程度</p></blockquote><ul><li>bug： 常规bug</li><li>security： 安全漏洞</li><li>production： 涉及到生产环境</li></ul><h4 id="Mindless"><a href="#Mindless" class="headerlink" title="Mindless"></a>Mindless</h4><blockquote><p>影响较小的任务，比如更改文件夹目录，适配规范</p></blockquote><ul><li>chore</li><li>legal</li></ul><h4 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h4><blockquote><p>影响用户体验，或者用户对产品的理解. These can be both opportunities and “UX bugs”.</p></blockquote><ul><li>copy</li><li>design</li><li>ux: User Experience</li></ul><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><blockquote><p>服务器环境，开发环境，生产环境或者测试环境</p></blockquote><ul><li>staging</li><li>test</li></ul><h4 id="Feedback"><a href="#Feedback" class="headerlink" title="Feedback"></a>Feedback</h4><blockquote><p>待确认的问题，比如一些拍脑袋的需求；或者某个需求我们还没决定怎么实现</p></blockquote><ul><li>discussion</li><li>question： 还没到需要讨论的情况</li><li>rfc</li></ul><h4 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h4><blockquote><p>现有功能或基础架构上的迭代。</p></blockquote><ul><li>enhancement: 现有模块有更高的完成度</li><li>optimization: 现有功能代码层面的重构，或者交互流程上的梳理</li></ul><h4 id="Additions"><a href="#Additions" class="headerlink" title="Additions"></a>Additions</h4><blockquote><p>新功能，新页面</p></blockquote><ul><li>feature</li></ul><h4 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h4><blockquote><p>现在不好说，未来肯定有结果，可能做成功， 可能做不成；</p></blockquote><ul><li>in progress： 进行中的需求</li><li>watchlist： 先拖着的需求，有可能就拖掉了</li></ul><h4 id="Inactive"><a href="#Inactive" class="headerlink" title="Inactive"></a>Inactive</h4><blockquote><p>无需采取任何行动或可能采取任何行动。该问题已解决，可以通过其他问题更好地解决；</p></blockquote><ul><li>invalid： 无效的</li><li>wontfix： 不会修复</li><li>duplicate： 重复</li><li>on hold： 等待候听</li></ul>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准io</title>
      <link href="2020/12/16/apue-1/"/>
      <url>2020/12/16/apue-1/</url>
      
        <content type="html"><![CDATA[<h1 id="APUE"><a href="#APUE" class="headerlink" title="APUE"></a>APUE</h1><p>APUE主要讨论了三部分内容：文件IO、并发、进程间通信。</p><p>*<em>文件IO: *</em></p><p>标准IO：优点是可移植性高，缺点是性能比系统 IO 差，且功能没有系统 IO 丰富。<br>系统IO：因为是内核直接提供的系统调用函数，所以性能比标准 IO 高，但是可移植性比标准 IO 差。</p><p><strong>并发：</strong></p><p>信号 + 多进程；<br>多线程；</p><p><strong>进程间通信：</strong></p><ul><li>FIFO：管道；</li><li>System V：又称为 XSI，支持以下三种方式：<ul><li>msg：消息队列；</li><li>sem：信号量；</li><li>shm：共享存储；</li></ul></li><li>Socket：套接字（网络通信）；</li></ul><h2 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h2><blockquote><p>前面提到了标准 IO（STDIO）和系统 IO（SYSIO），那么这里整理一下它们的差别。</p></blockquote><h3 id="1-1-stdio-和-sysio-异同"><a href="#1-1-stdio-和-sysio-异同" class="headerlink" title="1.1  stdio 和 sysio 异同"></a>1.1  stdio 和 sysio 异同</h3><table><thead><tr><th align="left">类型</th><th align="center">可移植性</th><th align="center">实时性</th><th align="center">吞吐量</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">STDIO</td><td align="center">高</td><td align="center">低</td><td align="center">高</td><td align="center">受限</td></tr><tr><td align="left">SYSIO</td><td align="center">低</td><td align="center">高</td><td align="center">低</td><td align="center">自由</td></tr></tbody></table><p>表格中的每一项都是两者之间相对而言，使用哪种 IO 并没有绝对的好坏之分，要根据实际的需求来决定应该使用哪个。</p><h4 id="1-1-1-可移植性："><a href="#1-1-1-可移植性：" class="headerlink" title="1.1.1 可移植性："></a>1.1.1 可移植性：</h4><p>标准 IO 是 C89 支持的函数，所以使用了标准 IO 的程序无论在 Linux 平台还是换成了 Windows 平台，不用修改代码是可以直接编译运行的。</p><p>而系统 IO 是由内核直接提供的函数库实现的，不同的操作系统平台上提供的 IO 操作接口是不同的，所以想要移植使用了系统 IO 的程序，必须按照目标平台的 IO 库修改程序并重新调试。</p><p>所以你写的程序将来可能在不同的平台上运行，那么最好使用标准 IO 库；如果你的程序是专门针对于某个平台而开发的，那么使用系统 IO 库能够得到我们下面说的其它优势。</p><h4 id="1-1-2-实时性和吞吐量："><a href="#1-1-2-实时性和吞吐量：" class="headerlink" title="1.1.2 实时性和吞吐量："></a>1.1.2 实时性和吞吐量：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">      <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">      <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">      <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall 1.c</span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="comment"># bbbaaa</span></span><br></pre></td></tr></table></figure><p>输出的结果为什么不是 ababab 呢，这就是因为标准 IO 具有合并系统调用的功能，putchar(3) 将本应该执行多次的 write(2) 动作合并成了一步来完成，所以 aaa 是作为一个字符串打印的，这一点我们可以通过 strace(1) 命令跟踪系统调用来得出结论(下方第7行)。另外由于 stdout 默认使用的是行缓冲模式(下面会讲缓冲)，所以对 putchar(3) 的调用并没有立即打印出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ strace ./a.out</span><br><span class="line"># ... 此处省略n行不相关内容</span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>) = <span class="number">0x7f077a35f000</span></span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"aaa\n"</span>, <span class="number">4</span>aaa</span><br><span class="line">  ) = <span class="number">4</span></span><br><span class="line">  exit_group(<span class="number">0</span>) </span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>到这里我们还是没有说明白为什么标准 IO 吞吐量高，而系统 IO 实时性高。我再举个简单的栗子：门卫老大爷负责送信到邮局，他去一次邮局要花费 10 分钟的时间，而每次最多能送 20 封信，每当信件累计到 20 封的时候他就要动身去邮局了。但是当他收到一封加急的邮件时，就会立即去一趟邮局。系统 IO 就好比每收到一封信时都要去一趟邮局，所以实时性高。而标准 IO 就好比要攒够 20 封信才去一趟邮局，所以吞吐量高，因为用户把信件交到老大爷的手上时就会立即返回，响应速度快，用户体验更好。而我们使用 fflush(3) 之类的函数强制刷新缓冲的时候，就相当于是老大爷收到了一封加急信件需要立即去一趟邮局送信。</p><p>至于这里所说的标准 IO 功能受限，是因为标准 IO 在各个平台上都是使用系统 IO 封装的，为了使它具有通用性，又要考虑底层操作系统各自平台在实现上的差异，难免在功能上就要作出让步。</p><h3 id="1-2-文件位置指针"><a href="#1-2-文件位置指针" class="headerlink" title="1.2  文件位置指针"></a>1.2  文件位置指针</h3><p>当我们打开一个文件要对它进行读写的时候，我们怎么能知道要从哪里开始读（写）文件呢？其实标准库准备了一个工具辅助我们读写文件，它就是文件位置指针。当我们使用标准库函数操作文件的时候，它会自动根据文件位置指针找到我们要操作的位置，也会随着我们的读写操作而自动修改指向，而不用我们自己手动记录和修改文件的操作位置。它使用起来非常方便，以至于你完全感觉不到它的存在，但是为了更好的理解文件 IO，你必须知道它的作用。</p><h3 id="1-3-stdio函数"><a href="#1-3-stdio函数" class="headerlink" title="1.3 stdio函数"></a>1.3 stdio函数</h3><h4 id="1-fopen-3"><a href="#1-fopen-3" class="headerlink" title="1.fopen(3)"></a>1.fopen(3)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fopen - stream <span class="built_in">open</span> functions</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><p>这是今天要学习的第一个函数，在操作文件之前，我们需要通过 fopen() 函数将文件打开，通过这个函数我们可以告诉操作系统我们要操作的是哪个文件，以及用什么样的方式操作这个文件。</p><p>参数列表：</p><p>path：要操作的文件路径。</p><p>mode：文件的打开方式，这个打开方式一共分为6种。</p><p>r：以只读的方式打开文件，并且文件位置指针会被定位到文件首。如果要打开的文件不存在则报错。</p><p>r+：以读写的方式打开文件，并且文件位置指针会被定位到文件首。如果要打开的文件不存在则报错。</p><p>w：以只写的方式打开文件，如果文件不存在则创建，如果文件已存在则被截断为 0 字节，并且文件位置指针会被定位到文件首。</p><p>w+：以读写的方式打开文件，如果文件不存在则创建，如果文件已存在则被截断为 0 字节，并且文件位置指针会被定位到文件首。</p><p>a：以追加的方式打开文件，如果文件不存在则创建，且文件位置指针会被定位到文件最后一个有效字符的后面（EOF，end of the file）。</p><p>a+：以读和追加的方式打开文件，如果文件不存在则创建，且读文件位置指针会被初始化到文件首，但是总是写入到最后一个有效字符的后面（EOF，end of the file）。</p><p>返回值：</p><p>FILE 是一个由标准库定义的结构体，各位童鞋不要企图通过手动修改结构体里的内容来实现文件的操作，一定要通过标准库函数来操作文件。</p><p>这个函数返回一个 FILE 类型的指针，它作为我们打开文件的凭据，后面所有对这个文件的操作都需要使用这个指针，而且使用之后一定不要忘记调用 fclose(3) 函数释放资源。</p><p>如果该函数返回了一个指向 NULL 的指针，则表示文件打开失败了，可以通过 errno 获取到具体失败的原因。</p><p>error 是什么呢？它是标准 C 中定义的一个整形值，用来表示上次发生的错误。大家可以在头文件中看看 errno 都定义了哪些值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/include/asm-generic/errno.h</span><br><span class="line">vim /usr/include/asm-generic/errno-base.h</span><br></pre></td></tr></table></figure><p>通常系统调用会给我们我返回一个整形值来表示是否出现了错误，当出现了错误的时候会设置 errno，通过 errno 我们就可以得知出现了什么错误了。</p><p>当然，直接给我们一个数字，我们自己再从头文件中查找这个数字表示的意义，然后再打印出来给用户看，似乎态麻烦了，没有什么简便的办法吗？</p><p>别担心，其实标准库已经为我们准备好专门的转换函数了：perror(3) 和 strerror(3)</p><p>perror(3) 会自动读取 errno 帮我们转换成对应的文字描述，并且将它们输出到标准错误流中。它的参数是一个字符串，用来让我们自定义一些错误消息给用户看，它的输出格式就是 我们给传递的参数：errno 转换的描述文字。</p><p>strerror(3) 函数也会将 errno 转换为文字，不过它不会自动读取 errno 当前的值，需要我们把 errno 传递给它。它也不会帮我们输出到标准输出中，而是将转换完的字符串返回给我们。</p><p>如果大家是开发一个前台应用，一般可以使用 perror(3) 函数直接将错误输出给用户。</p><p>如果大家开发的是后台应用（如守护进程等），那么一般先使用 strerrno(3) 函数将 errno 转换为字符串，然后再把这个字符串传给日志系统记录下来。</p><p>大家在使用 errno 这个全局变量的时候要导入 errno.h 头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>在使用 strerror(3) 函数时不要忘记导入 string.h 头文件，否则会报段错误！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &lt;<span class="built_in">string</span>.h&gt;</span><br></pre></td></tr></table></figure><p>其实现在的很多 *nix 系统中，errno 早已不是全局变量了，为了线程安全它已经变成了一个宏定义，这个我们在后面的博文中介绍线程的时候会讨论它。</p><h4 id="2-fclose-3"><a href="#2-fclose-3" class="headerlink" title="2.fclose(3)"></a>2.fclose(3)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fclose - <span class="built_in">close</span> a stream</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数是与 fopen(3) 函数对应的，当我们使用完一个文件之后，需要调用 fclose(3) 函数释放相关的资源，否则会造成内存泄漏。当一个 FILE 指针被 fclose(3) 函数成功释放后，这个指针所指向的内容将不能再次被使用，如果需要再次打开文件还需要调用 fopen(3) 函数。</p><p>参数列表：</p><p>fp：fopen(3) 函数的返回值作为参数传入即可。</p><h4 id="3-fgets-3"><a href="#3-fgets-3" class="headerlink" title="3.fgets(3)"></a>3.fgets(3)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fgets - input of strings</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> <span class="built_in">size</span>, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>从输入流 stream 中读取一个字符串回填到 s 所指向的空间。</p><p>这里出现了一个 stream 的概念，这个 stream 是什么呢，它被成为“流”，其实就是操作系统对于可以像文件一样操作的东西的一种抽象。它并非像自然界的小河流水一样潺潺细流，而通常是要么没有数据，要么一下子来一坨数据。当然 stream 也未必一定就是文件，比如系统为每个进程默认打开的三个 stream：stdin、stdout、stderr，它们本身就不是文件，就是与文件有着相同的操作方式，所以同样被抽象成了“流”。</p><p>这个函数并没有解决 gets(3) 函数可能会导致的数组越界问题，而是通过牺牲了获取数据的正确性来保证程序不会出现数组越界的错误，实际上是掩盖了 gets(3) 的问题。</p><p>该函数遇到如下四种情况会返回：</p><p>　　1.当读入的数据量达到 size - 1 时；</p><p>　　2.当读取的字符遇到 \n 时；</p><p>　　3.当读取的字符遇到 EOF 时；</p><p>　　4.当读取遇到错误时；</p><p>并且它会在读取到的数据的最后面添加一个 \0 到 s 中。</p><p>返回值：</p><p>成功时返回 s。</p><p>返回 NULL 时表示出现了错误或者读到了 strem 的末尾(EOF)。</p><h4 id="4-fread-3-、fwrite-3"><a href="#4-fread-3-、fwrite-3" class="headerlink" title="4.fread(3)、fwrite(3)"></a>4.fread(3)、fwrite(3)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fread, fwrite - binary stream input/output</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数使用得最频繁，用来读写 stream，通常是用来读写文件。</p><p>参数列表：</p><p>ptr：fread(3) 将从 stream 中读取出来的数据回填到 ptr 所指向的位置；fwrite(3) 则将从 ptr 所只想的位置读取数据写入到 stream 中；</p><p>size：要读取的每个对象所占用的字节数；</p><p>nmemb：要读取出多少个对象；</p><p>stream：数据来源或去向；</p><p>返回值：</p><p>注意这两个函数的返回值表示的是成功读（写）的对象的个数，而不是字节数！</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(buf, <span class="number">1</span>, <span class="number">10</span>, fp); <span class="comment">// 读取 10 个对象，每个对象 1 个字节</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(buf, <span class="number">10</span>, <span class="number">1</span>, fp); <span class="comment">// 读取 1 个对象，每个对象 10 个字节</span></span><br></pre></td></tr></table></figure><p>当数据量充足的时候，这两种方式是没有区别的。</p><p>但是！！当数据量少于 size 个字节的整倍数时，第二种方法的的最后一个对象会读取失败。比如数据只有 45 个字节，那么第二种方法的返回值为 4，因为它只能成功读取 4 个对象。</p><p>所以通常第一种方式读写数据使用得比较普遍。</p><h4 id="5-atoi-3"><a href="#5-atoi-3" class="headerlink" title="5.atoi(3)"></a>5.atoi(3)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> atoi, atol, atoll, atoq - convert a <span class="built_in">string</span> to an integer</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">atoll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">atoq</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;</span><br></pre></td></tr></table></figure><p>atoi(3) 函数族在这里提一下，主要是为了下面的 printf(3) 函数族做一个铺垫。</p><p>这些函数的作用是方便的将一个字符串形式的数字转换为对应的数字类型的数字。</p><p>上面这句话可能有点坳口，给你看个例子就懂了，下面是伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"123abc456"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = atoi(str);</span><br></pre></td></tr></table></figure><p>i 的结果会变成 123。这些函数会转换一个字符串中地一个非有效数字前面的数字。如果很不幸这个字符串中的第一个字符就不是一个有效数字时，那么它们会返回 0。</p><h4 id="6-printf-3"><a href="#6-printf-3" class="headerlink" title="6.printf(3)"></a>6.printf(3)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>,   <span class="built_in">fprintf</span>,  <span class="built_in">sprintf</span>,  <span class="built_in">snprintf</span> - formatted output conversion</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>printf(3) 函数大家一定不会陌生了，应该从写 Hello World! 的时候就接触到了的吧，所以我也不多介绍了，主要介绍两个内容。</p><p>一个是面试常考的一个问题，用了这么久的 printf(3) 函数，大家有没有注意过它的返回值表示什么呢？</p><p>printf(3) 的返回值表示成功打印的有效字符数量，不包括 \0。</p><p>另一个要说的就是刚才我们提到了 atoi(3) 函数族，它们负责将字符串转换为数字，那么有没有什么函数可以将数字转换为字符串呢，其实通过 sprintf(3) 或 snprintf(3) 就可以了。</p><p>有了这两个函数，不仅可以方便的将数字转换为字符串，还可以将多个字符串任意拼接为一个完整的字符串。</p><p>这里直接讲解一下 snprintf(3) 函数。</p><p>参数列表：</p><p>　　str：拼接之后的结果会回填到这个指针所指向的位置；</p><p>　　size：size - 1 为回填到 str 中的最大长度，数据超过这个长度的部分则会被舍弃，然后会在拼接的字符串的尾部追加 \0；</p><p>　　format：格式化字符串，用法与 printf(3) 相同，这里不再赘述；</p><p>　　…：格式化字符串的参数，用法与 printf(3) 相同；</p><p>这个函数与 fputs(3) 一样，只是掩盖了 sprintf(3) 可能会导致的数组越界问题，通过牺牲数据的正确性来保证程序不会出现数组越界的错误。</p><h4 id="7-scanf-3"><a href="#7-scanf-3" class="headerlink" title="7.scanf(3)"></a>7.scanf(3)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>,  <span class="built_in">fscanf</span>, <span class="built_in">sscanf</span> - input format conversion</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>scanf(3) 函数族相信也不用过多的介绍了，这里唯一要强调的就是：scanf(3) 函数支持多种格式化参数，唯独 %s 是不能安全使用的，可能会导致数组越界，所以当需要接收用户输入的时候可以使用 fgets(3) 等函数来替代。</p><h4 id="8-fseek-3"><a href="#8-fseek-3" class="headerlink" title="8.fseek(3)"></a>8.fseek(3)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>fseek(3) 函数族的函数用来控制和获取文件位置指针所在的位置，从而能够使我们灵活的读写文件。</p><p>介绍一下 fseek(3) 函数的参数列表：</p><p>　　stream：这个已经不需要多介绍了吧，就是准备修改文件位置指针的文件流；</p><p>　　offset：基于 whence 参数的偏移量；</p><p>　　whence：相对于文件的哪里；有三个宏定义可以作为它的参数：SEEK_SET（文件首）, SEEK_CUR（当前位置）, or SEEK_END（文件尾）；</p><p>返回值：</p><p>　　成功返回 0；失败返回 -1，并且会设置 errno。</p><p>单独看参数列表也许你还有所疑惑，那么我写点简单的伪代码作为例子：</p><p>1 fseek(fp, -10, SEEK_CUR); // 从当前位置向前偏移10个字节。<br>2 fseek(fp, 2GB, SEEK_SET); // 可以制造一个空洞文件，如迅雷刚开始下载时产生的文件。<br>ftell(3) 函数以字节为单位获得文件指针的位置。</p><p>fseek(fp, 0, SEEK_END) + ftell(3) 可以计算出文件总字节大小。</p><p>还有一个值得大家注意的问题：</p><p>fseek(3) 和 ftell(3) 的参数和返回值使用了 long，所以取值范围为 -2GB ~ (2GB-1)，而 ftell(3) 只能表示 2G-1 之内的文件大小，所以可以使用 fseeko(3) 和 ftello(3) 函数替代它们，但它们只是方言（SUSv2, POSIX.1-2001.）。</p><p>由于这两个函数比较古老，所以设计的时候认为 +-2GB 的取值范围已经足够用了，而没有意识到科技发展如此迅速的今天，2GB 大小的文件已经完全不能满足实际的需求了。</p><p>rewind(3) 函数将文件位置指针移动到文件起始位置，相当于：</p><p>1 (void) fseek(stream, 0L, SEEK_SET)</p><h4 id="9-getline-3"><a href="#9-getline-3" class="headerlink" title="9.getline(3)"></a>9.getline(3)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getline - delimited <span class="built_in">string</span> input</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">getline</span><span class="params">(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Feature Test Macro Requirements <span class="keyword">for</span> <span class="title">glibc</span> <span class="params">(see feature_test_macros(<span class="number">7</span>))</span>:</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">getline</span><span class="params">()</span>:</span></span><br><span class="line">    Since glibc 2.10:</span><br><span class="line">        _POSIX_C_SOURCE &gt;= <span class="number">200809L</span> || _XOPEN_SOURCE &gt;= <span class="number">700</span></span><br><span class="line">    Before glibc <span class="number">2.10</span>:</span><br><span class="line">        _GNU_SOURCE</span><br></pre></td></tr></table></figure><p>这个函数是一个非常好用的函数，它能帮助我们一次获取一行数据，而无论这个数据有多长。</p><p>参数列表：<br>　　lineptr：一个一级指针的地址，它会将读取到的数据填写到一级指针指向的位置，并将&gt;该位置回填到该参数中。指针初始必须置为NULL，该函数会根据指针是否为 NULL 来决定是否需要分配新的内存。<br>　　n：是由该函数回填的申请的内存缓冲区的总大小，长度初始必须置为0。<br>虽然很好用，但是各位童鞋别高兴得太早了，该函数仅支持 GNU 标准，所以是方言，大家还是自己封装一个备用吧。</p><p>另外，想要使用这个函数必须在编译的时候指定 -D_GNU_SOURCE 参数：</p><p><code>$&gt; gcc -D_GNU_SOURCE</code></p><p>当然如果不想在编译的时候添加参数，也可以在引用头文件之前 #define _GNU_SOURCE，只是比较丑陋而已。</p><p>还有一个办法，是在 makefile 中配置 CFLAGS += -D_GNU_SOURCE，这样即省去了编译时手动写参数的麻烦，也避免了代码中的丑陋。</p><h4 id="10-fflush-3"><a href="#10-fflush-3" class="headerlink" title="10.fflush(3)"></a>10.fflush(3)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fflush - <span class="built_in">flush</span> a stream</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>fflush(3) 函数的作用是刷新缓冲区，提到这个函数就要讲讲缓冲区了。</p><p> 缓冲区的作用是为了合并系统调用，在上面讲 STDIO 与 SYSIO 的区别时大家已经看到什么是合并系统调用了。</p><p>Linux 系统中有三种缓冲形式：无缓冲、行缓冲和全缓冲。</p><p>无缓冲：需要立刻输出时使用，例如 stderr；</p><p>行缓冲：遇到换行符时进行刷新、缓冲区满了的时候刷新、强制刷新(fflush(3))；而标准输出(stdout)是行缓冲，因为涉及到终端设备；</p><p>全缓冲：只有缓冲区满了的时候和强制刷新(fflush(3))时才会刷新，这是 Linux 默认的缓冲模式，但终端设备除外，终端设备使用行缓冲模式；</p><p>当数据被放入缓冲区的时候是不会通过系统调用(read(3)、write(3))送到内核中的，只有缓冲区被刷新的时候数据才会通过系统调用进入内核。而刷新缓冲区就是 fflush(3) 函数的作用。</p><p>fflush(3) 的参数是具体要刷新的流，当参数为 NULL 时会刷新所有的输出流。</p><h2 id="man手册"><a href="#man手册" class="headerlink" title="man手册"></a>man手册</h2><p>man 手册一共有 8 章，每一章保存不一样的内容，这八章的内容分别是：</p><ul><li><p>第一章：shell 命令。如：ls、vim，查询方法： <code>man ls</code></p></li><li><p>第二章：系统调用。如：open、close，查询方法：<code>man 2 open</code> 或 <code>man close</code>。因为第一章也有 open，所以 man 的参数中要加章节号；因为第一章中没有 close，所以查询 close 不需要加章节号。</p></li><li><p>第三章：库函数。如：printf、fopen，查询方法：<code>man 3 printf</code> 或 <code>man fopen</code></p></li><li><p>第四章：/dev 下的文件。如：zero。</p></li><li><p>第五章：一些配置文件的格式。如：/etc/shadow，查询方法：<code>man shadow</code></p></li><li><p>第六章：预留给游戏的，由游戏自己定义。如：sol。</p></li><li><p>第七章：附件和变量。如 iso-8859-1。</p></li><li><p>第八章：只能由 root 执行的系统管理命令。如 mkfs。</p></li></ul><p>因为有些函数的名字会在不同的章节出现，这种函数在查询 man 手册的时候如果不加上章节号默认会查询低编号的章节。</p><p>比如 printf，如果你输入的查询命令是 <code>man printf</code>，那么打开的并不是 printf 标准库函数的手册，而是 printf shell 命令的手册，想要查询 printf 函数的手册就需要在 man 命令后面加上该函数所在的章节数，正确的命令是 <code>man 3 printf</code>，这样就会打开 man 手册第三章的 printf 函数。</p><p>另外，如果想查看每个章节中都有哪些内容，可以使用 <code>man -aw</code> 命令得到 man 手册的安装路径，然后找到对应的 man 章节的目录，再用 zcat 命令查看那些 gz 文件。</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="2020/12/16/apue-10/"/>
      <url>2020/12/16/apue-10/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><blockquote><p>进程间通信（IPC） 分为 PIPE（管道）、Socket（套接字） 和 XSI（System V）。<br>XSI 又分为 msg（消息队列）、sem（信号量数组） 和 shm（共享内存）。<br>进程间通信又分同一台主机上 和 不同的主机上的。</p></blockquote><ol><li>管道</li><li>XSI -&gt; SYSV</li><li>网络套接字（跨网络的进程通信）</li></ol><ul><li>封装协议</li></ul><blockquote><p>协议就是双方约定对话的格式，实际上每一个用于传输的例子都是在封装协议。</p></blockquote><p>这些手段都是用于进程间通讯的，只有进程间通讯才需要借助第三方机制，线程之间的通讯是不需要借助第三方机制的，因为线程之间的地址空间是共享的。</p><h2 id="1-1-管道"><a href="#1-1-管道" class="headerlink" title="1.1 管道"></a>1.1 管道</h2><blockquote><p>管道分为命名管道（FIFO）和匿名管道（PIPE）；无论是哪种管道，都是由内核帮你创建和维护的；</p></blockquote><p>管道的特点：</p><p>1.管道是半双工的，即同一时间数据只能从一端流向另一端。试想，如果一个管道从两边同时输入和输出数据，那么管道里的数据就乱了。</p><p>2.管道是单工，两端一端作为读端，一端作为写端。</p><p>3.管道具有自适应的特点，默认会适应速度比较慢的一方，管道被写满或读空时速度快的一方会自动阻塞。</p><p><img src="./pipe.png" alt=""></p><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p>pipe(2) 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe - create pipe</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>返回值0 成功，-1失败</p><p>pipe(2) 用于创建管道，pipefd 是一个数组，表示管道的两端文件描述符，pipefd[0] 端作为读端，pipefd[1] 端作为写端。</p><p>pipe(2) 产生的是匿名管道，在磁盘的任何位置上找不到这个管道文件，而且匿名管道只能用于具有亲缘关系的进程之间通信。</p><p><em>一般情况有亲缘关系的进程之间使用管道进行通信时，会把自己不用的一端文件描述符关闭。</em></p><p>下面是创建匿名管道在父子进程之间传送了一个字符串“Hello”的小栗子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(pd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程 读取管道数据</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="built_in">close</span>(pd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取数据，如果子进程比父进程先被调度会阻塞等待数据写入</span></span><br><span class="line">        len = <span class="built_in">read</span>(pd[<span class="number">0</span>],buf,BUFSIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="comment">/* 管道是 fork(2) 之前创建的，</span></span><br><span class="line"><span class="comment">        * 父子进程里都有一份，</span></span><br><span class="line"><span class="comment">        * 所以退出之前要确保管道两端都关闭</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">close</span>(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程 向管道写入数据</span></span><br><span class="line">        <span class="built_in">close</span>(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">write</span>(pd[<span class="number">1</span>],<span class="string">"Hello!"</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="built_in">close</span>(pd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把一个命令的标准输出做成另一个命令的标准输入</li></ul><p><code>cat h.mp3 | mpg123 -</code></p><p>在上面的栗子中，父进程创建了一个匿名管道，在 pd[2] 数组中凑齐了读写双方，子进程同样继承了具有读写双方的数组 pd[2]。</p><p>父进程先关闭管道的读端然后向管道中写入数据，然后将用完的写端也关闭，等待子进程消亡并为其收尸。</p><p>子进程先关闭管道的写端然后读取父进程写入管道的字符串，把它打印到控制台之后再关闭用完的读端，然后退出。</p><p>这个程序在 fork(2) 之后如果是子进程先运行，那么会阻塞在 read(2) 阶段，等待父进程被调度并向管道中写入数据。</p><p>如果在 fork(2) 之后是父进程先运行，那么父进程会阻塞在 wait(2) 阶段等待子进程运行结束。</p><p>所以无论是谁先运行，只要没有出现异常运行的结果都是我们预期之内的。</p><h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>mkfifo 命令</p><p>管道有一个自同步的机制，必须凑齐读写双方才能操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mkfifo namedfifo <span class="comment"># 创建一个命令管道</span></span><br><span class="line">$&gt; ls -l namedfifo</span><br><span class="line">prw-r--r--. 1  6月 7 17:47  namedfifo</span><br><span class="line"></span><br><span class="line">$&gt;  date &gt; namedfifo</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另一个终端上</span></span><br><span class="line">$&gt; cat namedfifo <span class="comment"># 相当于读者读管道</span></span><br></pre></td></tr></table></figure><p>mkfifo(3) 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mkfifo - make a FIFO special file (a named pipe)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>mkfifo(3) 函数用于创建命名管道，作用与匿名管道相同，不过可以在不同的进程之间使用，相当于对一个普通文件进行读写操作就可以了。</p><p>这个管道文件是任何有权限的进程都可以使用的，两端都像操作一个普通文件一样对它进行打开、读写、关闭动作就可以了，只要一端写入数据另一端就可以都出来。</p><p>但是最好一端只读一端只写，否则在实际项目中你很难保证拿出的不是脏数据（自己写进去数据的混合着另一端写进去的数据被其中一端读了出来），除非像下面那个栗子那样结构简单清晰。</p><p>参数列表：</p><p>　　pathname：管道文件的路径和文件名。</p><p>　　mode：创建管道文件的权限。还是老规矩，传入的 mode 值要与系统的 umask 值做运算：(mode &amp; ~umask)</p><p>返回值：成功返回 0，失败返回 -1 并设置 errno。</p><p>我们看下面的栗子是如何使用命名管道通讯的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME    <span class="meta-string">"/tmp/myfifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ] = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个命名管道，大家可以用 ls -l 命令查看这个管道文件的属性</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(PATHNAME, <span class="number">0644</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"mkfifo()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!pid) &#123; <span class="comment">// parent</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!pid) &#123; <span class="comment">// parent</span></span><br><span class="line">            <span class="comment">// 两个子进程都创建完之后父进程直接退出，使两个子进程不具有亲缘关系。</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* child 2 */</span></span><br><span class="line">        <span class="comment">/* 像操作普通文件一样对这个管道进行 open(2)、read(2)、write(2)、close(2) */</span></span><br><span class="line">        fd = <span class="built_in">open</span>(PATHNAME, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">read</span>(fd, buf, BUFSIZ);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">" World!"</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// child 1</span></span><br><span class="line">        fd = <span class="built_in">open</span>(PATHNAME, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">"Hello"</span>, <span class="number">6</span>);</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 刚写完管道不要马上读，等第二个进程读取完并且写入新数据之后再读。</span></span><br><span class="line">        <span class="built_in">read</span>(fd, buf, BUFSIZ);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="comment">// 肯定是这个进程最后退出，所以把管道文件删除，不然下次再创建的时候会报文件已存在的错误</span></span><br><span class="line">        <span class="built_in">remove</span>(PATHNAME);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，父进程首先在磁盘上创建一个命名管道文件，然后创建两个子进程后退出。每个子进程都对管道文件进行一次读和一次写的动作，然后子进程退出，整个过程就结束了。</p><p>第一个子进程在写完管道之后要先休眠，等待第二个子进程从管道的另一端把数据读入并写入新的数据，第一个子进程再醒来读出管道的内容。如果第一个子进程不休眠而是在写完之后马上读管道，很可能在它写完管道之后第二个子进程还没来得及调度，它自己就又把管道里的数据读出来了，这样不仅读出来的不是第二个子进程写入的数据，还会导致第二个子进程永远阻塞在 read(2) 阶段，因为管道中不会再有数据写入。</p><p>管道大家都会用了吗？看上去不是很难是吧，赶快自己动手写写试试吧。</p><h3 id="协同进程（双工管道）"><a href="#协同进程（双工管道）" class="headerlink" title="协同进程（双工管道）"></a>协同进程（双工管道）</h3><p>这一小节主要是说管道是半双工的，两个进程一个只能对它读，另一个只能对它写，否则会出现脏数据，也就是无法区分出读出来的数据是来自于自己的还是来自于另一个进程的。</p><p>如果想要实现双工，必须采用两个管道，一个进程对一个管道只读，对另一个管道只写。</p><p>明白了这个原理，相信大家可以利用上面的 pipe(2) 或 mkfifo(3) 函数利用两个半双工管道实现进程之间的全双工通讯。</p><h2 id="1-2-XSI-IPC"><a href="#1-2-XSI-IPC" class="headerlink" title="1.2 XSI IPC"></a>1.2 XSI IPC</h2><p>IPC -&gt; Inter - Process Communication</p><p>XSI IPC 分三种机制</p><ul><li>Message Queues  消息队列</li><li>Semaphore Arrays   信号量数组</li><li>Shared Memory Segments 共享内存</li></ul><p>XSI IPC 是 System V 规范里面的进程间通信手段，而不是 POSIX 标准的。关于 System V、POSIX 等等的前世今生可以自行 Google 一下</p><p>在学习 XSI IPC 之前，我们先来认识两条命令：</p><p><code>ipcs(1) 命令可以查看 XSI IPC 的使用情况。</code></p><p><code>ipcrm(1) 命令可以删除指定的 XSI IPC。</code></p><p>为什么要先介绍这两个命令呢？如果实验的过程中需要查看 IPC 是否建立成功，可以通过 ipcs(1) 命令，如果实验出问题了，则可以使用 ipcrm(1) 命令删除错误的 IPC。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00000000 32769      usera      600        393216     2          dest         </span><br><span class="line">0x00000000 65538      usera      600        393216     2          dest         </span><br><span class="line">0x00000000 98307      usera      600        393216     2          dest         </span><br><span class="line">0x00000000 131076     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 163845     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 196614     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 229383     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 262152     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 294921     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 327690     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 360459     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 393228     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 425997     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 458766     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 491535     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 524304     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 557073     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 589842     usera      600        393216     2          dest         </span><br><span class="line">0x00000000 655380     usera      600        393216     2          dest         </span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages  </span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>通过 ipcs(1) 命令可以看出来，命令的输出结果分为三个部分，第一部分是系统中当前开辟的共享内存（shm），第二部分是信号量数组（sem），第三部分是消息队列（msg）。</p><p>可以看到，不论是哪一部分，都有一列叫做“key”，没错，使用 XSI IPC 通信的进程就是通过同一个 key 值操作同一个共享资源的。这个 key 是一个正整数，与文件描述符不同的是，生成一个新 key 值时它不采用当前可用数值中的最小值，而是类似生成进程 ID 的方式，key 值连续的加 1，直至达到一个整数的最大正值，然后再回转到 0 从头开始累加。</p><h3 id="1-2-1-Message-Queues"><a href="#1-2-1-Message-Queues" class="headerlink" title="1.2.1 Message Queues"></a>1.2.1 Message Queues</h3><blockquote><p>有没有亲缘关系的进程间通讯都可以使用消息队列，消息队列是双工的。</p></blockquote><p>消息队列可以让通信双方传送结构体数据，这样也提高了传送数据的灵活性。</p><p>既然是通讯，那么在通信之前就要先在通信双方约定通信协议，协议就是通信双方约定的数据交换格式。</p><p>从消息队列开始一直到 Socket，我们都会看到比较类似的程序架构，因为无论是消息队列还是 Socket，它们都需要约定通信协议，而且都是按照一定的步骤才能实现通讯。</p><p>消息队列在约定协议的时候，在我们自己定义的结构体里要强制添加一个 long mtype; 成员。这个成员的作用是用于区分多种消息类型中的不同类型的数据包，当只有一种类型的包时这个成员没什么用，但是也必须得带上。</p><p>既然是通讯，那么就要区分主动端（先发包的一方）和被动端（先收包的一方，程序需要先运行起来），它们运行的时机不同，作用不同，甚至调用的函数也不同，所以我们的后面的每个栗子几乎都要编译出 2 个不同的可执行程序来测试。</p><p>前面说了，学到这里操作基本上都是按部就班的了，所以 msg、sem 和 shm 都有一系列函数遵循下面的命名规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxget() <span class="comment">// 创建</span></span><br><span class="line">xxxop() <span class="comment">// 相关操作</span></span><br><span class="line">xxxctl() <span class="comment">// 其它的控制或销毁</span></span><br></pre></td></tr></table></figure><p>下面我们看看消息队列的创建函数：msgget(2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgget - get a System V message queue identifier</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><p>msgget(2) 函数的作用是创建一个消息队列，消息队列是双工的，两边都可以读写。</p><p>参数列表：</p><p>　　key 相当于通信双方的街头暗号，拥有相同 key 的双方才可以通信。</p><p>　　key 值必须是唯一的，系统中有个 ftok(3) 函数可以用于获取 key，通过文件 inode 和 salt 进行 hash 运算来生成唯一的 key，只要两个进程使用相同的文件和 salt 就可以生成一样的 key 值了。</p><p>　　msgflg：特殊要求。无论有多少特殊要求，只要使用了 IPC_CREAT，就必须按位或一个权限，权限也不是你想指定多大就能多大的，还是老规矩，要用它 &amp;= ~umask，这个我们前面提到过。</p><p>同一个消息队列只需要创建一次，所以谁先运行起来谁有责任创建消息队列，后运行起来的就不需要创建了。</p><p>同理，对于后启动的进程来说，消息队列不是它创建的，那么它也没有必要销毁了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="1-2-1-1-msgrcv-2-函数和-msgsnd-2-函数"><a href="#1-2-1-1-msgrcv-2-函数和-msgsnd-2-函数" class="headerlink" title="1.2.1.1 msgrcv(2) 函数和 msgsnd(2) 函数"></a>1.2.1.1 msgrcv(2) 函数和 msgsnd(2) 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgrcv, msgsnd - message operations</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* msgp 成员的定义要类似 msgbuf 这个结构体，第一个成员必须是 long 类型的 mtype，并且必须是 &gt; 0 的值 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;       <span class="comment">/* 消息类型，必须 &gt; 0 */</span></span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* 消息数据字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>msgrcv(2) 函数从 msgid 这个消息队列中接收数据，并将接收到的数据放到 msgp 结构体中，这段空间有 msgz 个字节大小，msgz 的值要减掉强制的成员 mtype 的大小（sizeof(long)）。</p><p>msgtyp 是 msgp 结构体中的 mtype 成员，表示要接收哪种类型的消息。虽然 msg 是消息队列，但是它并不完全遵循队列的形式，可以让接收者挑消息接收。如果不挑消息可以填写 0，这样就按照队列中的消息顺序返回。</p><p>msfglg 是特殊要求位图，没有写0。</p><p>msgsnd(2) 函数向 msgid 这个消息队列发送 msgp 结构体数据，msgp 的大小是 msgsz，msgflg 是特殊要求，没有特殊要求可以写 0。 </p><h4 id="1-2-1-2-msgctl-2-函数"><a href="#1-2-1-2-msgctl-2-函数" class="headerlink" title="1.2.1.2 msgctl(2) 函数"></a>1.2.1.2 msgctl(2) 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgctl - message control operations</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>msgctl(2) 函数是不是有点眼熟呢？没错，跟 iocrtl(2)、fcntl(2) 这种函数的用法很类似。通过 cmd 指定具体的命令，然后通过 buf 为 cmd 命令设定参数，当然有些命令是需要参数的，有些命令则不需要参数。</p><p>最长用的 cmd 就是 IPC_RMID，表示删除（结束）某个 IPC 通信，并且这个命令不需要 buf 参数，直接传入 NULL 即可。</p><p>buf 结构体里面的成员很多，由于 cmd 一般只有 IPC_RMID 比较常用，所以 LZ 就不把 buf 结构体拿出来挨个成员解释了，需要用到的童鞋自行查阅一下 man 手册吧，遇到了什么问题可以在评论中讨论。</p><p>看下面的小栗子，我们把上面讲到的几个消息队列的函数使用一遍，在两个进程之间实现简单的通讯。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h 定义双方都需要使用的数据或对象 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE        32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通讯双方生成 key 值共同使用的文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYPATH            <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="comment">/* 通讯双方生成 key 值共同使用的 salt 值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYPROJ            <span class="meta-string">'a'</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消息类型，只要是大于 0 的合法整数即可 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGTYPE            10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通讯双方约定的协议 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype;</span><br><span class="line">  <span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** rcver.c 接收方 ********************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">key_t</span> key;</span><br><span class="line">  <span class="keyword">int</span> msgid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 /tmp/out 文件和字符 'a' 生成唯一的 key，注意文件必须是真实存在的</span></span><br><span class="line">  key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">  <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"ftok()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收端应该先启动，所以消息队列由接收端创建</span></span><br><span class="line">  msgid = msgget(key,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"msgget()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不停的接收消息</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 没有消息的时候会阻塞等待</span></span><br><span class="line">      <span class="keyword">if</span>(msgrcv(msgid,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf)-<span class="keyword">sizeof</span>(<span class="keyword">long</span>),<span class="number">0</span>,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"msgrcv"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 用结构体中强制添加的成员判断消息类型，</span></span><br><span class="line"><span class="comment">        * 当然在这个例子中只有一种消息类型，所以不判断也可以。</span></span><br><span class="line"><span class="comment">        * 如果包含多种消息类型这里可以写一组 switch...case 结构</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="keyword">if</span>(rbuf.mtype == MSGTYPE)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,rbuf.math);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,rbuf.chinese);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 谁创建谁销毁。</span></span><br><span class="line"><span class="comment">    * 当然这个程序是无法正常结束的，只能通过信号杀死。</span></span><br><span class="line"><span class="comment">    * 使用信号杀死之后大家可以用 ipcs(1) 命令查看一下，消息队列应该是没有被销毁的，</span></span><br><span class="line"><span class="comment">    * 大家可以使用上面我们提到的 ipcrm(1) 命令把它删掉。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** snder.c 发送方 ********************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">key_t</span> key;</span><br><span class="line">  <span class="keyword">int</span> msgid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置随机数种子</span></span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="comment">// 用与接收方相同的文件和 salt 生成一样的key，这样才可以通讯</span></span><br><span class="line">  key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">  <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"ftok()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得消息队列</span></span><br><span class="line">  msgid = msgget(key,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"msgget()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为要发送的结构体赋值</span></span><br><span class="line">  sbuf.mtype = MSGTYPE;</span><br><span class="line">  <span class="built_in">strcpy</span>(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">  sbuf.math = rand()%<span class="number">100</span>;</span><br><span class="line">  sbuf.chinese = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送结构体</span></span><br><span class="line">  <span class="keyword">if</span>(msgsnd(msgid,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf)-<span class="keyword">sizeof</span>(<span class="keyword">long</span>),<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"msgsnd()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消息队列不是发送方创建的，所以发送方不用负责销毁</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动接收者，然后启动发送者</span></span><br><span class="line">./rcver</span><br><span class="line">./snder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送着控制台</span></span><br><span class="line">ok!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收者控制台</span></span><br><span class="line">Name = Alan</span><br><span class="line">Math = 97</span><br><span class="line">Chinese = 9</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./rcver</span><br><span class="line">./rcver</span><br><span class="line">./rcver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送者控制台</span></span><br><span class="line">ok!</span><br><span class="line">ok!</span><br><span class="line">ok!</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">./snder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收者控制台</span></span><br><span class="line">Name = Alan</span><br><span class="line">Math = 97</span><br><span class="line">Chinese = 9</span><br><span class="line"></span><br><span class="line">Name = Alan</span><br><span class="line">Math = 97</span><br><span class="line">Chinese = 9</span><br><span class="line"></span><br><span class="line">Name = Alan</span><br><span class="line">Math = 97</span><br><span class="line">Chinese = 9</span><br></pre></td></tr></table></figure><p>结论：</p><p>说明消息队列有缓存消息的能力；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line">bytes <span class="keyword">in</span> POSIX msg queues       819200</span><br><span class="line"><span class="comment"># 这个消息队列的大小 是  819200个字节数， 当消息队列大于这个数字的时候，会造成消息队列数据丢失</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ipcs</span><br><span class="line"></span><br><span class="line">键            msqid  拥有者  权限    已用字节  消息</span><br><span class="line">0x61004069     0     hy     600     0       0</span><br><span class="line"><span class="comment"># 发现依然消息队列存在，那是因为接收者那里有一个死循环。导致进程无法正常终止</span></span><br><span class="line"></span><br><span class="line">$&gt; ipcrm  -q  0 <span class="comment"># 杀掉 msqid为0 的消息队列</span></span><br></pre></td></tr></table></figure><p>这段程序的源文件有三个：proto.h、rcver.c 和 snder.c。</p><p>proto.h 中的 KEYPROJ （salt 值）用一个字符来替代整形数，为什么不直接写数字呢？因为宏定义是没有数据类型的，没有单位的数字是不靠谱的，而字符的 ASCII 码一定是一个 0-255 之间的整形数。</p><p>接收方要先运行，所以又接收方创建消息队列。发送方要使用相同的文件和 salt 生成于接收方相同的 key 值，这样它们才能使用同一个消息队列。</p><p>发送方生成一个结构体，用随机数为结构体中的两个成员赋值，分别模拟学生的数学和语文成绩，接收方在接收到数据之后把每个成员解析出来，并打印到控制台上。</p><p>可以看出来，发送方和接收方必须使用相同的结构体才能保证数据能够正常被解析，所以这个结构体就是我们上面所说的“协议”。既然是协议，我们就要把它定义在一个共用的结构体（proto.h）中，让发送方和接收方都引用这个头文件，这样就能保证它们可以使用相同的结构体通讯了。</p><h4 id="1-2-1-3-FTP实例-基于消息队列的版本"><a href="#1-2-1-3-FTP实例-基于消息队列的版本" class="headerlink" title="1.2.1.3 FTP实例(基于消息队列的版本)"></a>1.2.1.3 FTP实例(基于消息队列的版本)</h4><blockquote><p>双方进行数据传输，一方作为发送端 一方作为接收端</p></blockquote><p><img src="../../apue/ipc/xsi/msg/myftp/myftp.png" alt=""></p><p>讲解：</p><p>首先c 请求 s， 把path传给 s。 s返回一个一个的数据包给c， 最后一个数据包为 EOT表示发完。<br>c端将s返回的包内容 输出到终端上（有点类似cat 的内容），前面说了c 请求一个 path （文件的地址）。这里有点不灵活。需要在 频繁代码中 去更改path 文件地址。想办法弄到在命令行上指定path</p><h2 id="1-3-Semaphore-Arrays-信号量数组"><a href="#1-3-Semaphore-Arrays-信号量数组" class="headerlink" title="1.3 Semaphore Arrays   信号量数组"></a>1.3 Semaphore Arrays   信号量数组</h2><p>semget();<br>semop();<br>semctl();</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semget - get a semaphore set identifier</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><p>semget(2) 函数用于创建信号量。</p><p>成功返回 sem  ID，失败返回 -1 并设置 errno。</p><p>参数列表：</p><p>　　key：具有亲缘关系的进程之间可以使用一个匿名的 key 值，key 使用宏 IPC_PRIVATE 即可。</p><p>　　nsems：表示你到底有多少个 sem。信号量实际上是一个计数器，所以如果设置为 1 可以用来模拟互斥量。</p><p>　　semflg：IPC_CREAT 表示创建 sem，同时需要按位或一个权限，如果是匿名 IPC 则无需指定这个宏，直接给权限就行了。</p><p>semctl(2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semctl - semaphore control operations</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>semctl(2) 函数用来控制或销毁信号量。</p><p>参数列表：</p><p>　　semnum：信号量素组下标；</p><p>　　cmd：可选的宏参见《APUE》第三版 P457。常用的有 IPC_RMID，表示从系统中删除该信号量集合。SETVAL 可以为第几个成员设置值。关于这两个宏的用法，我们在下面的栗子中会见到。</p><p>　　…：根据不同的命令设置不同的参数，所以后面的参数是变长的。</p><p>semop(2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semop - semaphore operations</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> short sem_num; <span class="comment">/* 对第几个资源（数组下标）操作 */</span></span><br><span class="line">short sem_op; <span class="comment">/* 取几个资源写负数几(不要写减等于)，归还几个资源就写正数几 */</span></span><br><span class="line">short sem_flg; <span class="comment">/* 特殊要求 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数就是让我们操作信号量的。由于多个信号量可以组成数组，所以我们又看到了熟悉的函数定义方式，一个参数作为数组的起始位置，另一个参数指定数组的长度。</p><p>参数列表：</p><p>　　sops：结构体数组起始位置；</p><p>　　nsops：结构体数组长度；</p><p>返回值：成功返回0，失败返回-1并设置 errno。</p><p>前面说过了，信号量实际上就是计数器，所以每次在使用资源之前，我们需要扣减信号量，当信号量被减到 0 时会阻塞等待。每次使用完成资源之后，需要归还信号量，也就是增加信号量的数值。</p><p>下面我们使用上面操作信号量的函数实现一个通过信号量实现互斥量的栗子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCNUM        20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME        <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个函数都要使用这个信号量 ID，所以定义为全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> semid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line"></span><br><span class="line">  op.sem_num = <span class="number">0</span>; <span class="comment">// 只有一个资源，所以数组下标是 0</span></span><br><span class="line">  op.sem_op = <span class="number">-1</span>; <span class="comment">// 取一个资源就减1</span></span><br><span class="line">  op.sem_flg = <span class="number">0</span>; <span class="comment">// 没有特殊要求</span></span><br><span class="line">  <span class="keyword">while</span>(semop(semid,&amp;op,<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 出现假错就重试</span></span><br><span class="line">      <span class="keyword">if</span>(errno != EINTR &amp;&amp; errno != EAGAIN)</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"semop()"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line"></span><br><span class="line">  op.sem_num = <span class="number">0</span>;</span><br><span class="line">  op.sem_op = <span class="number">1</span>; <span class="comment">// 归还一个资源</span></span><br><span class="line">  op.sem_flg = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(semop(semid,&amp;op,<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(errno != EINTR &amp;&amp; errno != EAGAIN)</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"semop()"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func_add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">  fp = fopen(FNAME,<span class="string">"r+"</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"fopen()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先取得信号量在操作文件，取不到就阻塞等待，避免发生竞争</span></span><br><span class="line">  P();</span><br><span class="line">  fgets(buf,BUFSIZE,fp);</span><br><span class="line">  rewind(fp);</span><br><span class="line">  sleep(<span class="number">1</span>); <span class="comment">// 调试用，为了放大竞争，更容易看出来互斥量发挥了作用</span></span><br><span class="line">  <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>,atoi(buf)+<span class="number">1</span>);</span><br><span class="line">  fflush(fp);</span><br><span class="line">  <span class="comment">// 操作结束之后归还信号量，让其它进程可以取得信号量</span></span><br><span class="line">  V();</span><br><span class="line">  fclose(fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在具有亲缘关系的进程之间使用，所以设置为 IPC_PRIVATE 即可。</span></span><br><span class="line">  <span class="comment">// 另外想要实现互斥量的效果，所以信号量数量设置为 1 个即可。</span></span><br><span class="line">  semid = semget(IPC_PRIVATE,<span class="number">1</span>,<span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span>(semid &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"semget()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 union semun.val 的值设置为 1</span></span><br><span class="line">  <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,SETVAL,<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"semctl()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 20 个子进程</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; PROCNUM ; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      pid = fork();</span><br><span class="line">      <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"fork()"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(pid == <span class="number">0</span>)    <span class="comment">// child</span></span><br><span class="line">      &#123;</span><br><span class="line">          func_add();</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; PROCNUM ; i++)</span><br><span class="line">      wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁信号量</span></span><br><span class="line">  semctl(semid,<span class="number">0</span>,IPC_RMID);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">echo</span> 1 &gt; <span class="string">'./p'</span></span><br><span class="line"></span><br><span class="line">./add</span><br></pre></td></tr></table></figure><p>大家还记得以前我们写的用 20 个进程同时向一个文件中写入累加的数值吗？还是这个程序，这次我们使用信号量来实现它们之间的互斥效果。</p><p>程序的结构跟以前的实现方式差不多，只不过锁的形式不一样了而已。</p><h2 id="1-4-Shared-Memory-Segments-共享内存"><a href="#1-4-Shared-Memory-Segments-共享内存" class="headerlink" title="1.4 Shared Memory Segments 共享内存"></a>1.4 Shared Memory Segments 共享内存</h2><p>还记得之前在《高级 IO》部分的博文中我们利用 mmap(2) 函数实现过一个共享内存吗？</p><p>这次我们使用的是 XSI 的共享内存，比使用 mmap(2) 实现的共享内存稍微麻烦一点。不过不用担心，也一样很简单，不就是遵循上面说的那个命名规则的三个函数嘛，有了消息队列和信号量的铺垫，相信不用 LZ 讲大家也差不多能才出来 shm 是个什么套路了。</p><p>没错，第一个函数就是 shmget(2)，我们来看一下它的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shmget - allocates a shared memory segment</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数列表：</p><p>　　key：共享内存的唯一标识，具有亲缘关系的进程之间使用共享内存可以使用 IPC_PRIVATE 宏代替。</p><p>　　size：是共享内存的大小。</p><p>　　shmflg：IPC_CREAT 表示创建 shm，同时需要按位或一个权限，如果是匿名 IPC 则无需指定这个宏，直接给权限就行了。</p><p>返回值：成功返回 shm ID；失败返回 -1，man 手册里没说是否设置 errno，这个需要大家根据自己的环境测试一下，或者查阅自己环境下的 man 手册。</p><h3 id="1-4-1-shmat-2-函数和-shmdt-2-函数"><a href="#1-4-1-shmat-2-函数和-shmdt-2-函数" class="headerlink" title="1.4.1 shmat(2) 函数和 shmdt(2) 函数"></a>1.4.1 shmat(2) 函数和 shmdt(2) 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shmat - shared memory operations</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>虽然函数名叫做 shmat，根据上面说过的约定，用 man 手册查 shmop 也是可以查到这个命令的。</p><p>shmat(2) 函数使进程与共享内存关联起来。</p><p>shmat(2)函数中的 shmaddr 参数是共享内存的起始地址，传入 NULL 由内核帮我们寻找合适的地址，一般情况我们都是传入 NULL 值。</p><p>shmdt(2) 函数用于使进程分离共享内存，共享内存使用完毕之后需要用这个函数分离。分离不带表释放了这块空间，使用共享内存的双方依然要遵守“谁申请，谁释放”的原则，所以没有申请的一方是不需要释放的，但是双方都需要分离。</p><h3 id="1-4-2-shmctl-2"><a href="#1-4-2-shmctl-2" class="headerlink" title="1.4.2 shmctl(2)"></a>1.4.2 shmctl(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shmctl - shared memory control</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>与消息队列和信号量一样，这个函数用于控制或删除共享内存。</p><p>参数 LZ 就不做介绍了，只说一下如何删除共享内存吧。cmd 参数设置为 IPC_RMID 并且 buf 参数设置为 NULL 就可以删除共享内存了。</p><p>下面我们来看一个共享内存实现进程间通讯的栗子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请的共享内存大小，单位是字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">int</span> shmid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有亲缘关系的进程 key 参数可以使用 IPC_PRIVATE 宏，并且创建共享内存 shmflg 参数不需要使用 IPC_CREAT 宏</span></span><br><span class="line">  shmid = shmget(IPC_PRIVATE,MEMSIZE,<span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"shmget()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"fork()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// 子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 关联共享内存</span></span><br><span class="line">      str = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(str == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"shmat()"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向共享内存写入数据</span></span><br><span class="line">      <span class="built_in">strcpy</span>(str,<span class="string">"Hello!"</span>);</span><br><span class="line">      <span class="comment">// 分离共享内存</span></span><br><span class="line">      shmdt(str);</span><br><span class="line">      <span class="comment">// 无需释放共享内存</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 父进程</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 等待子进程结束再运行，因为需要读取子进程写入共享内存的数据</span></span><br><span class="line">      wait(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">// 关联共享内存</span></span><br><span class="line">      str = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(str == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"shmat()"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 直接把共享内存中的数据打印出来</span></span><br><span class="line">      <span class="built_in">puts</span>(str);</span><br><span class="line">      <span class="comment">// 分离共享内存</span></span><br><span class="line">      shmdt(str);</span><br><span class="line">      <span class="comment">// 释放共享内存</span></span><br><span class="line">      shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后父进程要在父子进程用完共享内存之后调用 shmctl(2) 使用 IPC_RMID 宏来回收资源，参数为 NULL</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sysio</title>
      <link href="2020/12/16/apue-2/"/>
      <url>2020/12/16/apue-2/</url>
      
        <content type="html"><![CDATA[<h1 id="sysio"><a href="#sysio" class="headerlink" title="sysio"></a>sysio</h1><h2 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1.文件描述符"></a>1.文件描述符</h2><p>在 SYSIO 中贯穿了一个整形数，它就是文件描述符。对内核而言，所有打开的文件都是通过文件描述符引用的。它的作用与 STDIO 中的 FILE 结构体类似，但是它们的工作原理是完全不同的。它实际上是一个由内核保存的数组下标，所以不会是负数，下面我会用一张图来表示它的作用。</p><p><img src="./sys_01.jpg" alt=""><br>图1 SYSIO 文件描述符</p><p>图是在 Ubuntu 下好不容易找到了一个画图软件画的，质量不怎么样，小伙伴们先凑合着看吧。</p><p>我解释下图上画的东西。</p><p>图片一共分为标准 IO 和系统 IO 两部分，系统 IO 部分有一个数组，这个数组中的指针指向了内核中具体描述文件信息的结构体，而通过这些结构体再引用具体的文件(inode)。而操作系统提供给我们的文件描述符就是这个数组的下标。这个数组的长度是 1024，也就表示一个进程最多可以打开 1024 个文件，当然这个上限可以通过 ulimit(1) 命令修改，具体用法这里不再赘述。</p><p>当产生一个文件描述符时，优先采用当前最小的可用数值。假设当前已经占用的文件描述符为1、2、3、5，那么再次产生的文件描述符就是 4。</p><p>还要注意一点，上面这个文件描述符数组在每个进程中都会持有一份，所以理论上是每个进程最多可以打开 1024 个文件，而不是系统中所有的进程一共只能打开 1024 个文件。</p><h2 id="2-sysio-函数"><a href="#2-sysio-函数" class="headerlink" title="2. sysio 函数"></a>2. sysio 函数</h2><h3 id="2-1-fileno-3"><a href="#2-1-fileno-3" class="headerlink" title="2.1 fileno(3)"></a>2.1 fileno(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Feature Test Macro Requirements <span class="keyword">for</span> <span class="title">glibc</span> <span class="params">(see feature_test_macros(<span class="number">7</span>))</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">fileno</span><span class="params">()</span>: _POSIX_C_SOURCE &gt;</span>= <span class="number">1</span> || _XOPEN_SOURCE || _POSIX_SOURCE</span><br></pre></td></tr></table></figure><p>这个函数的作用是从 STDIO 的 FILE 结构体指针中获得 SYSIO 的文件描述符。</p><h3 id="2-2-fdopen-3"><a href="#2-2-fdopen-3" class="headerlink" title="2. 2 fdopen(3)"></a>2. 2 fdopen(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"></span><br><span class="line">　　<span class="function">Feature Test Macro Requirements <span class="keyword">for</span> <span class="title">glibc</span> <span class="params">(see feature_test_macros(<span class="number">7</span>))</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">     <span class="title">fdopen</span><span class="params">()</span>: _POSIX_C_SOURCE &gt;</span>= <span class="number">1</span> || _XOPEN_SOURCE || _POSIX_SOURCE</span><br></pre></td></tr></table></figure><p> 这个函数和上面的 flieno(3) 函数的功能是反过来的，作用是把 SYSIO 的文件描述符转换为 STDIO 的 FILE 结构体指针。mode 参数的作用与 fopen(3) 中的 mode 参数相同，这里不再赘述。</p><p>虽然这两个函数可以在 STDIO 与 SYSIO 之间互相转换，但是并不推荐对同一个文件同时采用两种方式操作。因为 STDIO 和 SYSIO 之间它们处理文件的私有数据是不同步的，如果同时使用两种方式操作同一个文件则可能带来不可预知的后果，具体可以参考上一篇博文中提到的那个合并系统调用的例子。</p><h3 id="2-3-open-2"><a href="#2-3-open-2" class="headerlink" title="2. 3 open(2)"></a>2. 3 open(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span> - <span class="built_in">open</span> <span class="keyword">and</span> possibly create a file <span class="keyword">or</span> device</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p> 想要使用 SYSIO 操作文件或设备，要先通过 open(2) 函数获得一个文件描述符。注意博文中在函数上方标识出来的头文件，大家在使用这个函数的时候一定要一个不少的全部包含到源代码中。</p><p>参数列表：</p><p>　　pathname：要打开的文件路径。</p><p>　　flags：指定文件的操作方式，多个选项之间用按位或( | )运算符链接。</p><p>　　　　必选项，三选一：O_RDONLY, O_WRONLY, O_RDWR</p><p>　　　　可选项：可选项有很多，这里只介绍常用的，想要查看完全的可选项，可以查阅 man 手册。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>O_APPEND</td><td>追加到文件尾部。</td></tr><tr><td>O_CREAT</td><td>创建新文件。</td></tr><tr><td>O_DIRECT</td><td>最小化缓冲。关于缓冲区的解释：buffer 是写操作的加速机制，cache 是读操作的加速机制。</td></tr><tr><td>O_DIRECTORY</td><td>强调一定要打开一个目录，如果 pathname 不是目录则会打开失败。</td></tr><tr><td>O_LARGEFILE</td><td>打开大文件的时候要加这个，会将 off_t 定义为 64 bit，当然也可以在编译的时候使用上一篇博文提到的宏定义来指定 off_t 的长度。</td></tr><tr><td>O_NOFOLLOW</td><td>如果 pathname 是符号链接则不展开，也就是说打开的是符号链接文件本身，而不是符号链接指向的文件。</td></tr><tr><td>O_NONBLOCK</td><td>非阻塞形式。阻塞是读取不到数据时死等，非阻塞是尝试读取，无论能否读取到数据都返回。</td></tr><tr><td>O_TRUNC</td><td>将已存在的普通文件长度截断为0（也就是将文件内容清空）。</td></tr></tbody></table><p>　　mode：8 进制文件权限。当 flags 包含 O_CREAT 选项时必须传这个参数，否则可以不用传这个参数。当然系统在创建文件的时候不会直接这个参数，而是通过如下的公式计算得到最终的文件权限：</p><p><code>mode &amp; ~(umask)</code></p><p>　　具体的 umask 的值可以通过 umask(1) 命令获得。通过这样的公式进行计算可以避免程序中创建出权限过高的文件。</p><p>不知道小伙伴们注意到没有，这个函数有一个有趣的地方。C 语言中是没有函数重载这个概念的，那么为什么这两个 open(2) 函数很像重载的函数呢？实际上它们是用可变长参数列表来实现的。</p><p>顿时让我想起来一道面试题：如何确定一个函数是用重载实现的还是用变长参数实现的？答案是给它多传几个参数嘛，如果报错了那一定是函数重载，否则就是变长参数实现的呗。</p><h3 id="2-4-close-2"><a href="#2-4-close-2" class="headerlink" title="2. 4 close(2)"></a>2. 4 close(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span> - <span class="built_in">close</span> a file descriptor</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p> 关闭文件描述符。</p><p>参数是要关闭的文件描述符。注意当一个文件描述符被关闭之后就不能再使用了，虽然 fd 这个变量的值没有变，但是内核已经将相关的资源释放了，这个 fd 相当于一个野指针了。</p><p>返回值：</p><p>　　成功为0，失败为-1。但很少对它的返回值做校验，一般都认为不会失败。</p><h3 id="2-5-read-2"><a href="#2-5-read-2" class="headerlink" title="2. 5 read(2)"></a>2. 5 read(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> - <span class="built_in">read</span> from a file descriptor</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>这是 SYSIO 读取文件的函数，作用是从文件描述符 fd 中读取 count 个字节的数据到 buf 所指向的空间。</p><p>返回值：返回成功读取到的字节数；0 表示读取到了文件末尾；-1 表示出现错误并设置 errno。</p><p>　　注意 read(2) 函数与 STDIO 中的 fread(3) 函数的返回值是有区别的，fread(3) 返回的是成功读取到了多少个对象，而 read(2) 函数返回的是成功读取到的字节数量。</p><h3 id="2-6-write-2"><a href="#2-6-write-2" class="headerlink" title="2. 6 write(2)"></a>2. 6 write(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span> - <span class="built_in">write</span> to a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p> write(2) 是 SYSIO 向文件中写入数据的函数，作用是将 buf 中 count 字节的数据写入到文件描述符 fd 所对应的文件中。</p><p>返回值：返回成功写入的字节数；0 并不表示写入失败，仅仅表示什么都没有写入；-1 才表示出现错误并设置 errno。</p><p>　　注意 write(2) 函数与 STDIO 中的 fwrite(3) 函数的返回值是有区别的，fwrite(3) 返回的是成功写入了多少个对象，而 write(2) 函数返回的是成功写入的字节数量。</p><p>大家想一想，为什么会出现写入的值是 0 的情况呢？其实原因有很多，其中一个原因是当写入的时候发生了阻塞，而阻塞中的 write(2) 系统调用恰巧被一个信号打断了，那么 write(2) 可能没有写入任何数据就返回了，所以返回值会是0。至于什么是阻塞，什么是信号，LZ 会在后面的博文中讲解。</p><h3 id="2-7-lseek-2"><a href="#2-7-lseek-2" class="headerlink" title="2. 7  lseek(2)"></a>2. 7  lseek(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lseek - reposition <span class="built_in">read</span>/<span class="built_in">write</span> file offset</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><p>通过上一篇博文大家知道了文件位置指针这个概念，它是系统为了方便我们读写文件而设定的一个标记，随着我们通过函数对文件的读写，它会自动相应的向文件尾部偏移。</p><p>那么是不是说当我们读取过文件的一段内容之后，就没办法回去再次读取同一段内容了呢？</p><p>其实不是的，通过 lseek(2) 函数就可以让我们随心所欲的控制文件位置指针了。</p><p>参数列表：</p><p>fd：要操作的文件描述符；</p><p>offset：相对于 whence 的偏移量；</p><p>whence：相对位置；三选一：SEEK_SET、SEEK_CUR、SEEK_END</p><p>SEEK_SET 表示文件的起始位置；</p><p>SEEK_CUR 表示文件位置指针当前所在位置；</p><p>SEEK_END 表示文件末尾；</p><p>返回值：</p><p>　　成功时返回文件首相对于移动结束之后的文件位置指针所在位置的偏移量；失败时返回 -1 并设置 errno；</p><p>这个函数的 offset 参数和返回值都对基本数据类型进行了封装，这一点要比标准库的 fseek(3) 更先进。</p><p>写一段伪代码来说明这个函数的使用方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">-1024</span>, SEEK_CUR); <span class="comment">// 从文件位置指针当前位置向前偏移 1024 个字节</span></span><br><span class="line">lseek(fd, <span class="number">1024</span>, SEEK_SET); <span class="comment">// 从文件起始位置向后偏移 1kb</span></span><br><span class="line">lseek(fd, <span class="number">1024U</span>L*<span class="number">1024U</span>L*<span class="number">1024U</span>L*<span class="number">5U</span>L, SEEK_SET); <span class="comment">// 产生一个 5GB 大小的空洞文件</span></span><br></pre></td></tr></table></figure><h3 id="2-8-time-1"><a href="#2-8-time-1" class="headerlink" title="2. 8 time(1)"></a>2. 8 time(1)</h3><p>之前讨论过 STDIO 与 SYSIO 的效率问题，所以在这里聊一聊 time(1) 命令。</p><p>这个命令可不是用来查看系统当前时间的，想要查看系统时间得使用 date(1) 命令，这个不是我们今天要讨论的内容，所以就不说了。</p><p>time(1) 命令的作用是监视一个程序的用户时间，从而可以粗略的帮助我们分析这个程序的执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((readlen = <span class="built_in">read</span>(srcfd, buf, BUFSIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       pos = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (readlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              writelen = <span class="built_in">write</span>(destfd, buf+pos, readlen);</span><br><span class="line">               <span class="keyword">if</span> (writelen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                       err = errno;</span><br><span class="line">                      <span class="keyword">goto</span> e_write;</span><br><span class="line">               &#125;</span><br><span class="line">               pos += writelen;</span><br><span class="line">               readlen -= writelen;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是一个模仿 cp(1) 命令的程序的核心部分代码，其中的 buf 是一个 char 数组，用来作为数据读写的缓存。当 buf 的容量不同时文件拷贝的效率也是不同的，因为过于频繁的执行系统调用和使用过大的缓存都会使效率下降。如果通过不停的修改 buf 的容量的方式测试 buf 为多大的时候拷贝效率最高的话，就可以使用 time(1) 命令监视程序的执行时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall mycp_sysio.c -o mycp_sysio</span><br><span class="line">time ./mycp_sysio rhel-server-6.4-x86_64-dvd.iso tmp.iso</span><br><span class="line">real 1m30.014s</span><br><span class="line">user 0m0.003s</span><br><span class="line">sys 1m29.003s</span><br></pre></td></tr></table></figure><p>sys 是程序在内核态消耗的时间，也就是执行系统调用所消耗的时间。 </p><p>user 是程序在用户态消耗的时间，也就是程序本身的代码所消耗的时间。</p><p>real 是用户等待的总时间，是 sys + user + CPU 调度时间，所以 real 时间会稍微比 sys + user 时间长一点。一个程序从提高响应素的的方式提高用户体验，一般指的就是提高 real 时间。</p><h2 id="3-文件共享"><a href="#3-文件共享" class="headerlink" title="3 文件共享"></a>3 文件共享</h2><p> 文件共享就是指多个进程共同处理同一个文件，就是 图1 中第二个文件表项和第三个文件表项共同指向同一个 inode 的图示，不过这两个文件表项来自于不同的进程表项时才叫做文件共享。</p><h3 id="3-1-原子操作"><a href="#3-1-原子操作" class="headerlink" title="3.1 原子操作"></a>3.1 原子操作</h3><p> 通俗来讲，原子操作就是将多个动作一气呵成的做完，中间不会被打断，要么执行完所有的步骤，要么一步也不会执行。这里用创建临时文件来举个栗子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmpnam, tmpnam_r - create a name <span class="keyword">for</span> a temporary file</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>如果我们需要创建一个临时文件，那么首先需要又操作系统提供一个文件名，然后再创建这个文件。</p><p>tmpnam(3) 函数就是用来获得临时文件的文件名的。为什么要通过这个函数由操作系统来为我们生成文件名呢？就是因为系统中进程比较多，临时文件也比较多，怕文件重名嘛。</p><p>但是这个函数只负责生成一个目前系统中不存在的临时文件名，并不负责创建一个文件，所以创建文件的任务要由我们自己使用 fopen(3) 或 open(2) 等手段创建。</p><p>假设在我们拿到这个文件名的时候，临时文件还没有在磁盘上真正创建，另一个进程拿到了一个与我们相同的文件名，那么这个时候再创建文件就是有问题的了。</p><p>这就是因为获得文件名与创建文件这个动作不原子造成的，如果获得唯一的文件名和创建文件这个动作一气呵成中间不会被打断，则这个问题就不会发生，我们创建好文件之后另一个进程就再也拿不到相同的文件名了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmpfile - create a temporary file</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>既然使用 tmpnam(3) 函数无法原子的创建临时文件，那么就没有原子的方式来避免上面描述的问题了吗？当然有办法，那就是使用 tmpfile(3) 函数来创建临时文件。</p><p>tmpfile(3) 函数是获得文件名和创建临时文件的动作一气呵成的，它直接会返回一个创建好的 FILE 结构体指针给我们，这样一来妈妈再也不用担心我们的文件名会被别人抢占了。:)</p><p>当然系统中有许多地方需要原子操作，不仅仅是创建临时文件，所以系统还有其它函数提供了原子操作，遇到的时候我们再讲解，这里不再详述。</p><h3 id="3-2-dup-2-、dup2-2"><a href="#3-2-dup-2-、dup2-2" class="headerlink" title="3.2 dup(2)、dup2(2)"></a>3.2 dup(2)、dup2(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dup, dup2 - duplicate a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数是用来复制文件描述符的，就是 图1 中 文件描述符 3 和 6 指向了同一个文件表项的情况。</p><p>举个栗子，用 dup(2) 实现输出的重定向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* 要求在不改变下面的内容的情况下，使输出的内容到文件中  */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"dup test."</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>puts(3) 函数是将参数字符串写入到标准输出 stdout（文件描述符是 1） 中，而标准输出默认目标是我们的 shell。如果想要让 puts(3) 的参数输出到一个文件中，实现思路是：首先打开一个文件获得一个新的文件描述符，然后关闭标准输出文件描述符(1)，然后使用 dup(2) 函数族复制产生一个新的文件描述符，此时的 1 号文件描述符就不是标准输出的文件描述符了，而是我们自己创建的文件的描述符了。还记得我们之前提到过吗，文件描述符优先使用可用范围内最小的。进程中当前打开的文件描述符有标准输入(0)、标准输出(1)、标准错误(2)和我们自己打开的文件(3)，当我们关闭了 1 号文件描述符后，当前可用的最小文件描述符是 1，所以新复制的文件描述符就是 1。而标准库函数 puts(3) 在调用系统调用 write(2) 函数向 1 号文件描述符打印时，正好是打印到了我们所指定的文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   fd = <span class="built_in">open</span>(<span class="string">"tmp"</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">    <span class="comment">/* if error */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>); <span class="comment">// 关闭标准输出</span></span><br><span class="line">    dup(fd);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 要求在不改变下面的内容的情况下，使输出的内容到文件中  */</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"dup test."</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于题目的要求是 puts(3) 上面注释以下的内容都不能修改，原则上 1 号文件描述符在这里使用完毕也需要 close(2)，所以这里造成了一个内存泄漏，但并不影响对 dum(2) 函数族的解释和测试。</p><p>上面的代码用 close(2) + dup(2) 的方式或者 dup2(2) 的方式都可以实现。</p><p>dup(2) 和 dup2(2) 的作用是相同的，区别是 dum2(2) 函数可以用第二个参数指定新的文件描述符的编号。</p><p>如果新的文件描述符已经被打开则先关闭它再重新打开。</p><p>如果两个参数相同，则 dup2(2) 函数会返回原来的文件描述符，而不会关闭它。</p><p>另外一点比较重要，close(2) + dup(2) 的方式不原子，而 dup2(2) 这两步动作是原子的，在并发的情况下可能会出现问题。后面的博文我们会通过信号和多线程来讨论并发。</p><h3 id="3-3-sync-2"><a href="#3-3-sync-2" class="headerlink" title="3.3 sync(2)"></a>3.3 sync(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync, syncfs - commit buffer cache to disk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 有指向的一个文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 只刷数据，不刷亚数据， 数据指的是文件内有效的内容，亚数据指的是描述 文件 以及文件操作内容 的信息数据；</span></span><br></pre></td></tr></table></figure><p>sync(2) 函数族的函数作用是全局催促，将 buffer 和 cache 刷新和同步到 disk，一般在设备即将卸载的时候使用。这个函数族的函数不是很常用，所以用到的时候再具体讨论，这里不再详述。</p><h3 id="3-4-fcntl-2"><a href="#3-4-fcntl-2" class="headerlink" title="3.4  fcntl(2)"></a>3.4  fcntl(2)</h3><blockquote><p>文件描述符 所边的魔术几乎都来源于该函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fcntl - manipulate file descriptor 管理文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fd: 文件描述符</span></span><br><span class="line"><span class="comment"> * cmd： 要对此文件描述符做什么样的事情</span></span><br><span class="line"><span class="comment"> * arg： 要做的这件事情，需要传递的参数 （由于命令不同，会造成传参不同，由于命令不同，会造成返回值不同）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这是一个管家级别的函数，根据不同的 cmd 和 arg 读取或修改对已经打开的文件的操作方式。具体的命令和参数请查阅 man 手册，这里不再花费大量篇幅赘述。</p><h3 id="3-5-ioctl-2"><a href="#3-5-ioctl-2" class="headerlink" title="3.5 ioctl(2)"></a>3.5 ioctl(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ioctl - control device</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>Linux 的一切皆文件的设计原理将所有的设备都抽象为一个文件，当一个设备的某些操作不能被抽象成打开、关闭、读写、跳过等动作时，其它的动作都通过 ioctl(2) 函数控制。</p><p>例如将声卡设备抽象为一个文件，录制音频和播放音频的动作则可以被抽象为对声卡文件的读、写操作。但是像配置频率、音色等功能无法被抽象为对文件的操作形式，那么就需要通过 ioctl(2) 函数对声卡设备进行控制，具体的控制命令则由驱动程序提供。</p><h3 id="3-6-dev-fd"><a href="#3-6-dev-fd" class="headerlink" title="3.6 /dev/fd"></a>3.6 /dev/fd</h3><p>/dev/fd 是一个虚拟目录，它里面是当前进程所使用的文件描述符信息。如果用 ls(1) 查看，则里面显示的是 ls(1) 这个进程所使用的文件描述符信息。而打开里面的文件则相当于复制文件描述符。</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程环境</title>
      <link href="2020/12/16/apue-3/"/>
      <url>2020/12/16/apue-3/</url>
      
        <content type="html"><![CDATA[<h1 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h1><p>本章前半部分讨论进程的开始和结束，后半部分讨论参数列表、环境变量、C 程序虚拟地址空间布局等内容。</p><ol><li>main函数</li><li>进程的终止</li><li>命令行参数的分析</li><li>环境变量</li><li>C程序的存储空间布局</li><li>库</li><li>函数跳转</li><li>资源的获取及控制</li></ol><h2 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1. main() 函数"></a>1. main() 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>;</span><br></pre></td></tr></table></figure><p>其实最早的 main 函数是三个参数的，除了 argc 和 argv 以外，还有一个环境变量。后来发现环境变量越来越好用，所以就独立出来成了单独的功能。</p><h2 id="2-进程终止"><a href="#2-进程终止" class="headerlink" title="2. 进程终止"></a>2. 进程终止</h2><blockquote><p>Linux 系统一共有 8 种进程终止方式.1-5为正常终止方式, 6-8为异常终止方式（必知必会）</p></blockquote><ol><li>从 main() 函数返回；</li><li>调用 exit(3) 函数；</li><li>调用 _exit(2) 或 _Exit(2) 函数；</li><li>最后一个线程从其启动例程返回；</li><li>从最后一个线程调用 pthread_exit(3) 函数；</li><li>调用 abort(3) 函数；</li><li>接收到一个信号并终止；（ctrl+c）</li><li>最后一个线程对取消请求作出响应；</li></ol><p>第 1 条：在 main() 函数中执行 return 语句，可以将一个 int 值作为程序的返回值返回给调用者，一般是 shell。返回 0 表示程序正常结束，返回 非零值 表示程序异常结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?  <span class="comment"># 打印上一条语句的执行状态</span></span><br></pre></td></tr></table></figure><p>第 2 条：在 main() 函数中执行 return 语句相当于调用 exit(3) 函数，exit(3) 是专门用于结束进程的，它依赖于 _exit(2) 或 _Exit(2) 系统调用。程序中任何地方调用 exit(3) 都会退出，但 return 语句只有在 main() 函数中才能结束进程，在其它函数中执行 return 语句只能退出当前函数。exit 能返回的值在<code>-128 ～ 127</code>之间；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 3 条：_exit(2) 和 _Exit(2) 函数都是系统调用，在程序中的任何地方调用它们程序都会立即结束。</p><p>上面三条有两点需要大家注意，我先把问题提出来大家思考一下，下面会有讲解：</p><p>(1) return 、exit(3)、_exit(2) 和 _Exit(2) 的返回值取值范围是多少呢？</p><p>(2) exit(3)、_exit(2) 和 _Exit(2) 之间有什么区别呢？</p><p>第 4、5 条 等到第 11 章我们讨论线程的时候再说，总之进程就是线程的容器，最后一个线程的退出会导致整个进程的消亡。</p><p>第 6 条：abort(3) 函数一般用在程序中出现了不可预知的错误时，为了避免异常影响范围扩大，直接调用 abort(3) 函数自杀。实际上 abort(3) 函数也是通过信号实现的。</p><p>第 7 条：信号有很多种，有些默认动作是被忽略的，有些默认动作则是杀死进程。<br>比如程序接收到 SIGINT（Ctrl+C） 信号就会结束，Ctrl + C 是 SIGINT 的一个快捷方式，而不是 Ctrl + C 触发了 SIGINT 信号。第 10 章我们会详细的讨论信号。</p><p>第 8 条 也要等到第 11 章我们讨论线程的时候再详细说。</p><p>3.exit(2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exit - cause normal process termination</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><p> status 参数的取值范围并非是所有 int 的取值范围，计算方法是 status &amp; 0377，也就相当于一个有符号的 char 型数据，取值范围是 -128～127，最多256种可能。</p><p>所有通过 atexit(3) 和 on_exit(3) 注册的函数会被以注册的逆序来调用。</p><p>它在执行完钩子函数之后再执行IO清理，然后才使进程结束。</p><h3 id="atexit-3-钩子函数"><a href="#atexit-3-钩子函数" class="headerlink" title="atexit(3)  钩子函数"></a>atexit(3)  钩子函数</h3><blockquote><p>所有的函数由 atexit(3) 和  on_exit(3) 声明的，将会以他们注册的逆序来调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atexit - register a function to be called at normal process termination</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>用该函数注册过的函数会在程序正常终止之前被调用，被注册的函数称为“钩子函数”。</p><p>注册的钩子函数形式必须是这样：void (*function)(void)，因为它不会接收任何参数，也没有任何机会返回什么值，所以是一个无参数无返回值的函数。</p><p>当多次调用 atexit(3) 函数注册了多个钩子函数的时候，程序结束时钩子函数是以注册的逆序被调用的。</p><p>比如按照 a()、b()、c()、d() 的形式注册了 4 个钩子函数，那么程序结束时，它们的调用顺序是：d()、c()、b()、a()。</p><p>下面举个栗子来说明这个逆序调用是怎么回事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f1</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"f1"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f2</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"f2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"f3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    atexit(f1); <span class="comment">// 只是声明一个函数，相当于把一个函数挂在钩子上，并不调用</span></span><br><span class="line">    atexit(f2);</span><br><span class="line">   atexit(f3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Begin!</span><br><span class="line">End!</span><br><span class="line">f3</span><br><span class="line">f2</span><br><span class="line">f1</span><br></pre></td></tr></table></figure><p>这回小伙伴们明白逆序调用是怎么回事了吧。</p><p>为什么 “End!” 先输出了，而 “f3” 后输出了呢？因为使用 atexit(3) 函数注册钩子函数的时候并不会调用钩子函数，仅仅是注册而已，<em>只有在程序正常结束的时候钩子函数才会被调用</em>。</p><p>还记得我们上面提到的什么情况是正常结束吧？注意是只有正常结束才会调用钩子哟，异常结束是不会调用钩子函数的。</p><ul><li>疑问</li></ul><p>为什么main函数 return 非int型，还是调用了注册的钩子函数呢？</p><p>下面写几段伪代码来举栗子说明一下什么场景更适合使用钩子函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 这段代码要表现的是，当我们的程序需要申请很多资源的时候，</span></span><br><span class="line"><span class="comment">  * 比如打开文件、申请堆内存等。</span></span><br><span class="line"><span class="comment">  * 如果有一个资源申请失败时需要释放之前所有成功申请的资源并退出程序，</span></span><br><span class="line"><span class="comment">  * 那么就需要在申请每个资源之后都进行错误判断，并手工填写所有的资源释放代码。</span></span><br><span class="line"><span class="comment">  * 假如要申请的资源数量很庞大，而恰巧加班又加得老眼昏花</span></span><br><span class="line"><span class="comment">  * 结果手一抖，后果。。。 @...@</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> fd0 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (fd0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open(0)"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> fd1 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open(1)"</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd0);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd2 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open(1)"</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">   <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">fd10000 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (fd10000 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open(10000)"</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd9999);</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">close</span>(fd3);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd0);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法是不是太恐怖了，这还只是打开文件而已，如果中间有夹杂着 malloc(3) 和 free(3) 呢？想都不敢想了。。</p><p>其实想要解决也很简单，钩子函数帮你轻松搞定！下面是改版之后的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> fd0 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"> <span class="keyword">if</span> (fd0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     perror(<span class="string">"open(0)"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> atexit(closefd0); <span class="comment">// 一切都交给钩子函数来处理吧，它会以注册顺序的逆序逐一被调用。</span></span><br><span class="line"> </span><br><span class="line"> fd1 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"> <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open(1)"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">atexit(closefd1);</span><br><span class="line"></span><br><span class="line">fd2 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open(1)"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">atexit(closefd2);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">fd10000 = <span class="built_in">open</span>(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (fd10000 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open(10000)"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">atexit(closefd2);</span><br></pre></td></tr></table></figure><h3 id="exit-2-、-Exit-2"><a href="#exit-2-、-Exit-2" class="headerlink" title="_exit(2)、_Exit(2)"></a>_exit(2)、_Exit(2)</h3><blockquote><p>_exit() 和 _Exit(2) 为系统调用, exit 依赖于 _exit(2)或者_Exit(2)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _exit, _Exit - terminate the calling process</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><h4 id="exit-2-、-Exit-2-与-exit-3-的区别"><a href="#exit-2-、-Exit-2-与-exit-3-的区别" class="headerlink" title="_exit(2)、_Exit(2) 与 exit(3) 的区别"></a>_exit(2)、_Exit(2) 与 exit(3) 的区别</h4><p>在程序的任何地方调用 _exit(2) 或 _Exit(2) 函数程序都会立即结束，任何钩子函数都不会被调用，也不会做 IO 清理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"f1"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"f2"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"f3"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"f4"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     atexit(f4);</span><br><span class="line">     atexit(f3);</span><br><span class="line">     atexit(f2);</span><br><span class="line">     atexit(f1);</span><br><span class="line">     _exit(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 没有打印出 任何东西</span></span><br></pre></td></tr></table></figure><h4 id="什么时候用-exit-3-，什么时候用-exit-2-、-Exit-2"><a href="#什么时候用-exit-3-，什么时候用-exit-2-、-Exit-2" class="headerlink" title="什么时候用 exit(3)，什么时候用 _exit(2)、_Exit(2)"></a>什么时候用 exit(3)，什么时候用 _exit(2)、_Exit(2)</h4><p>下面我们写一段伪代码来查看 _exit(2) 函数的常用场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">function</span> <span class="params">(.........)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ()</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> ()</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = function();</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment">// 假定没有任何地方修改过 ret</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 出现这种情况的时候一定是上面的代码出现了逻辑问题，或程序中出现了越界等问题，所以不能调用钩子函数执行清理了，而且也不能做IO清理了。为了防止故障扩散，一定要让程序立即结束。（错的不行了，不敢动了。调_exit()杀掉进程）</span></span><br><span class="line">            <span class="comment">//exit(1);</span></span><br><span class="line">            _exit(<span class="number">1</span>); <span class="comment">// abort(); 发信号结束进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-命令行参数"><a href="#3-命令行参数" class="headerlink" title="3. 命令行参数"></a>3. 命令行参数</h2><p>我们在使用 shell 命令的时候经常为传递各种参数来完成不同的工作。这个参数实际上就是传递到程序 main() 函数的 argc 和 argv 两个参数中去了</p><p>我们再来看一下 main() 函数的原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>;</span><br></pre></td></tr></table></figure><p>参数列表：</p><p>　　argc：argv 中字符串的数量，也就是传递给程序的命令行参数的数量。</p><p>　　argv：在 shell 中传递给进程的命令行参数列表，argv[0] 永远是命令本身，第一个参数从 argv[1] 开始。</p><p>　　　　这是一个二维数组，其实就是一个字符串数组而已。很多童鞋不理解它为什么是一个二维数组，说明你的 C 语言基础没有学好。</p><p>　　　　字符串本身就是一个 char 数组，而保存多个字符串的数组自然就是一个 char 型二维素组了。</p><p>常见的命令行参数分类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ cmd [opt] [!opt]</span><br><span class="line">&gt;$ ls <span class="comment"># 无参数</span></span><br><span class="line">&gt;$ ls -l -a -i  <span class="comment"># 仅选项</span></span><br><span class="line"></span><br><span class="line">&gt;$ ls /etc/ /tmp  <span class="comment"># 非选项传参</span></span><br><span class="line">&gt;$ ls -l /tmp -a /etc</span><br><span class="line">&gt;$ ./myplayer -H 500 -W 500 a.avi <span class="comment"># 选项带参数</span></span><br><span class="line">&gt;$ ./myplayer -H -W a.avi <span class="comment"># 假设 H 和 W 选项必须带参数，这样传惨会报错，因为找不到任何参数修饰 -H 和 -W</span></span><br><span class="line">&gt;$ cmd [opt opt-arg] [!opt]</span><br><span class="line"></span><br><span class="line">&gt;$ ./myplayer -H 100 px -W 500 cm a.avi <span class="comment"># 选项带参数，参数又带参数，这种没有函数能搞定，只能自己写函数解析了。</span></span><br></pre></td></tr></table></figure><p>选项分为两种形式，一种是以 - 开头的短格式选项，只能是一个字母或一个数字；</p><p>另一种是长格式选项，以 – 开头，可以由多个字母和数字组成。</p><p>短格式最多支持 26个小写字母+26个大写字母+10个数字，共 62 个选项。这些选项足够一个程序的使用了，为什么还需要长格式的选项呢？</p><p>使用长格式选项是为了便于使用者记忆，辅助短格式参数的使用。如果有一些单词的缩写碰撞了或者不容易记忆，则可以选用长格式的参数。</p><p>这些命令行参数可以随意松散的传给命令，那么命令是如何解析这些参数的呢？别着急，其实已经有优秀的库函数供我们使用了。</p><h3 id="getopt-3"><a href="#getopt-3" class="headerlink" title="getopt(3)"></a>getopt(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getopt, optind - Parse command-line options</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br><span class="line"> <span class="keyword">extern</span> <span class="keyword">int</span> optind;</span><br></pre></td></tr></table></figure><p>该函数用于解析短格式参数。</p><p>参数列表：</p><p>　　argc、argv：就是 main() 函数的 argc 和 argv 参数；</p><p>　　optstring：想要从 argv 中解析的所有选项列表，不用加 - 前导符；例如程序支持 -y -m -d -h -M -s 参数，则 optstring 填写 “y:mdh:Ms” 即可。</p><p>加冒号表示某个选项后面要带参数，比如 y 和 h 后面都需要带参数，需要用到全局变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optind;</span><br></pre></td></tr></table></figure><p>optarg：表示选项后面的参数，也就是 -y 和 -h 后面的参数。例如：-y 4 -h 24。<br>optind：用于记录 getopt(3) 函数目前读到了 argv 的哪个下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FMTSTRSIZE 1024</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TIMESTRSIZE 1024</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * -y: year</span></span><br><span class="line"><span class="comment">  * -m: month</span></span><br><span class="line"><span class="comment">  *  -d: day</span></span><br><span class="line"><span class="comment">  *  -H: hour</span></span><br><span class="line"><span class="comment">  *  -M: minute</span></span><br><span class="line"><span class="comment">  *  -S: second</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">time_t</span> stamp;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>*<span class="title">tm</span>;</span></span><br><span class="line">     <span class="keyword">char</span> timestr[TIMESTRSIZE];</span><br><span class="line">     <span class="keyword">int</span> c;</span><br><span class="line">     <span class="keyword">char</span> fmtstr[FMTSTRSIZE];</span><br><span class="line">     stamp = time(<span class="literal">NULL</span>);</span><br><span class="line">     fmtstr[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">     tm = localtime(&amp;stamp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 命令行分析</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         c = getopt(argc,argv,<span class="string">"HMSymd"</span>);</span><br><span class="line">         <span class="keyword">if</span>(c&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">switch</span>(c)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">'H'</span>:</span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">strcmp</span>(optarg, <span class="string">"12"</span>)== <span class="number">0</span>)</span><br><span class="line">                     <span class="built_in">strncat</span>(fmtstr, <span class="string">"%I(%P)"</span>, FMTSTRSIZE);</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(optarg, <span class="string">"24"</span>)==<span class="number">0</span>)</span><br><span class="line">                          <span class="built_in">strncat</span>(fmtstr, <span class="string">"%H"</span>, FMTSTRSIZE);</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"incvalid arguments"</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                 <span class="built_in">strncat</span>(fmtstr, <span class="string">"%M "</span>, FMTSTRSIZE);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                 <span class="built_in">strncat</span>(fmtstr, <span class="string">"%S "</span>, FMTSTRSIZE);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">'y'</span>:</span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">strcmp</span>(optarg,<span class="string">"2"</span>)==<span class="number">0</span>)</span><br><span class="line">                     <span class="built_in">strncat</span>(fmtstr,<span class="string">"%y"</span>,FMTSTRSIZE);</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(optarg,<span class="string">"4"</span>)==<span class="number">0</span>)</span><br><span class="line">                     <span class="built_in">strncat</span>(fmtstr,<span class="string">"%Y"</span>,FMTSTRSIZE);</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"invalid arguments"</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line"> </span><br><span class="line">                 <span class="built_in">strncat</span>(fmtstr, <span class="string">"%m "</span>, FMTSTRSIZE);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                 <span class="built_in">strncat</span>(fmtstr, <span class="string">"%d "</span>, FMTSTRSIZE);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//根据命令行分析的结果 决定要输出什么格式的文本</span></span><br><span class="line">     strftime(timestr, TIMESTRSIZE, fmtstr, tm);</span><br><span class="line">    <span class="comment">// strftime(timestr, TIMESTRSIZE, "Now:%Y-%m-%d", tm);</span></span><br><span class="line">     <span class="built_in">puts</span>(timestr);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./myDate -H 12 <span class="comment"># 02(pm)</span></span><br><span class="line">./myDate -H 24 <span class="comment"># 14</span></span><br><span class="line">./myDate -y 2  <span class="comment">#20</span></span><br><span class="line">./myDate -y 4  <span class="comment">#2020</span></span><br></pre></td></tr></table></figure><p>下面伪代码演示了如何解析选项以及带参的选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> 　　op = getopt(argc, argv, <span class="string">"y:mdh:Ms"</span>); <span class="comment">// 支持的选项是 -y &lt;2|4&gt; -m -d -h &lt;12|24&gt; -M -s</span></span><br><span class="line"> </span><br><span class="line"> 　　<span class="keyword">if</span> (op &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line"> 　　　　<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">switch</span> (op) &#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 非选项传参，op 的值为 1</span></span><br><span class="line"></span><br><span class="line">　　　　　　<span class="comment">// &gt;$ ls /etc/ -a</span></span><br><span class="line"></span><br><span class="line">　　　　　　<span class="comment">// 当进入这个 case 的时候，optind 已经 +1 了，所以想要通过 optind 在 argv 中得到对应的参数应，应该进行 -1，但是不要去修改 optind 本身的值，否则下次读取就不准确了。</span></span><br><span class="line"></span><br><span class="line">　　　　　　fp = fopen(argv[optind<span class="number">-1</span>], <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">　　　　　　......</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'y'</span>:</span><br><span class="line"></span><br><span class="line">　　　　　　　<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(optarg, <span class="string">"2"</span>)) &#123; <span class="comment">// y 后面的参数是 2</span></span><br><span class="line">                ......</span><br><span class="line">　　　　　　　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(optarg, <span class="string">"4"</span>)) &#123; <span class="comment">// y 后面的参数是 4</span></span><br><span class="line">                ......</span><br><span class="line">　　　　　　　　&#125; <span class="keyword">else</span> &#123; <span class="comment">// y 后面的参数即不是 2 也不是 4</span></span><br><span class="line">                ......</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">　　　　......</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="comment">// 通常传入了不支持的参数，不响应就可以了，没必要结束程序，因为没有达到那种严重的程度。</span></span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数可以连写，但带参数的选项必须和参数是挨着的，不能分开，举几个栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 1. -x -z -v -f 可以连写</span></span><br><span class="line"> <span class="comment"># 2. -x -z -v 是不带参数的选项，-f 是带参数的选项，所以 -f 必须和后面的参数挨着</span></span><br><span class="line"> tar -xzvf xxx.tar.gz /home</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 下面这几个是错误的用法</span></span><br><span class="line"> tar -fxzv xxx.tar.gz /home</span><br><span class="line"> tar -xzvfxxxtar.gz /home</span><br><span class="line"> tar fxxxtar.gzxzvf /home</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 下面这种用法是可以的</span></span><br><span class="line">tar -f xxx.tar.gz -xzv /home</span><br></pre></td></tr></table></figure><h3 id="getopt-long-3-用于解析长格式参数，函数原型就不列出来了。"><a href="#getopt-long-3-用于解析长格式参数，函数原型就不列出来了。" class="headerlink" title="getopt_long(3) 用于解析长格式参数，函数原型就不列出来了。"></a>getopt_long(3) 用于解析长格式参数，函数原型就不列出来了。</h3><p>关于命令行参数要再补充一点，经常拷运维人员的一道面试题大概是这样的：如何使用 touch(1) 命令在当前目录创建一个名字叫做 -a 的文件？</p><p>通常有两个办法可以实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) touch -- -a      当命令行遇到两个 - 和空格时(-- )，会认为后面不会有任何选项，也就不会将 - 再作为参数的前导符。</span><br><span class="line"></span><br><span class="line">2) touch ./-a       ./ 表示当前目录</span><br></pre></td></tr></table></figure><h2 id="4-环境变量"><a href="#4-环境变量" class="headerlink" title="4. 环境变量"></a>4. 环境变量</h2><blockquote><p>KEY = VLAUE</p></blockquote><h3 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h3><p>export(1) 命令可以查看当前所有的环境变量或设置某个环境变量。</p><p>访问环境变量可以使用 getenv(3) 和 putenv(3) 函数，下面我们会提到它们。</p><p>环境表就是将环境变量保存在了一个字符指针数组中，很多 Unix 系统都支持三个参数的 main() 函数，第三个参数就是环境表。</p><p>环境变量是为了保存常用的数据。以当前 terminal 为例，把 terminal 当作是一个大的程序来跑，就可以将环境变量看作是这个程序的全局变量。</p><p>环境变量相当于在某个位置声明 extern char **environ;</p><p>上面说了，环境表就是一个字符指针数组，所以使用环境变量就相当于<br><code>environ[i] - &gt;name=value;</code></p><h3 id="如何查看环境变量"><a href="#如何查看环境变量" class="headerlink" title="如何查看环境变量"></a>如何查看环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span></span><br></pre></td></tr></table></figure><h3 id="输出环境变量"><a href="#输出环境变量" class="headerlink" title="输出环境变量"></a>输出环境变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;environ[i]!= <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="built_in">puts</span>(environ[i]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到了环境表，在这一节我们看看操作环境变量的两个函数如何使用。</p><p>环境变量的作用到底是什么？有很多小伙伴不明白环境变量是个什么东西，一听感觉好深奥啊，惧怕得不行。</p><p>就像我们使用 ls(1) 命令的时候是在任何位置都可以使用的，而没有用 /bin/ls 的方式来使用 ls(1)，是因为有 PATH 环境变量的存在，它会保存所有常用的可执行文件的路径。</p><p>其实环境变量无非就是一个字符串而已，它由 key(变量名) 和 value 两部分组成，我们可以通过 key 来读写 value。</p><p>我们通常所说的环境变量就是环境表，也就是由多个环境变量组成的一个字符指针数组，它的存在也就是为了方便我们在程序中获得一些经常使用的变量数据，仅此而已。</p><h3 id="getenv-3-获取某个环境变量"><a href="#getenv-3-获取某个环境变量" class="headerlink" title="getenv(3) 获取某个环境变量"></a>getenv(3) 获取某个环境变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getenv - get an environment variable</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(getenv(<span class="string">"PATH"</span>));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是获取一个环境变量，用法很简单，就是通过 name 获得 value， value 是返回值。</p><p>在这里补充一点，在程序中获得当前工作路径有两种办法，一种是通过环境变量，一种是通过专门的函数：</p><p>　　puts(getevn(“PWD”)); // 通过环境变量获取当前路径，也可以使用 getcwd(3) 函数获得当前路径。</p><h3 id="setenv-3"><a href="#setenv-3" class="headerlink" title="setenv(3)"></a>setenv(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setenv - change or add an environment variable</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数和 getenv(3) 函数的作用正好相反，是将 value 赋给 name 环境变量。</p><p>如果 name 不存在，则添加新的环境变量。</p><p>如果 name 存在：如果 overwrite 为真，就用 value 覆盖 name 原来的值；如果 overwrite 为假则保留 name 原来的值。</p><h3 id="putenv-3"><a href="#putenv-3" class="headerlink" title="putenv(3)"></a>putenv(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putenv - change or add an environment variable</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>用 “name=value” 的形式添加或修改环境变量的值。如果 name 已存在则会用新值覆盖原来的值。</p><p>小伙伴们要注意：参数不是 const 的，所以某些情况下可能会修改参数的值，所以还是使用 setenv(3) 更保险。</p><p>大家思考一个问题：如 图1 所示，环境表是存放在堆与内核空间之间的薄层中的，如果新字符串比原字符串长怎么办，会不会出现越界的情况呢？</p><p>其实不用担心这个问题，因为无论新的值与原来的值谁长谁短，都会先将原来的空间释放，在堆上新申请一块空间来存放新的值。</p><h2 id="5-C-程序的存储空间布局"><a href="#5-C-程序的存储空间布局" class="headerlink" title="5. C 程序的存储空间布局"></a>5. C 程序的存储空间布局</h2><p>一个C程序的虚拟空间是4GB，什么是虚拟空间，它跟实实在在4gb的内存空间是不一样的。</p><p>通常 malloc(3) 失败有两种情况，一种是内存真的耗尽了；另一种是不断的申请小的内存，即使堆上全部存放指针也有放满了的情况。</p><p>在 Linux 环境中内存是延时分配的，也就是说当 malloc(3) 分配内存时并没有真正的分配物理内存给你，只是给了你一个非空指针，当你真正使用内存的时候通过引发一个缺页异常，内核才真正分配内存给你。</p><p>好比有人跟你借100块钱，你也承诺了可以借，但是他并不马上要钱，等到当他跟你要的时候你已经花掉了50块钱，这时候你有两个选择：一是把借钱的人杀掉，这样就不用借钱给他了；二是去抢钱，抢够了足够的钱再给他。</p><p>如果让你选择，你会采用哪种方式呢？</p><p>内核采用的是第二种方式，当它发现内存不足够它承诺给你的容量时，它会结束某些不常用的后台进程，再将释放出来的内存分配给你。</p><p><img src="./jincheng_huanjing_01.png" alt=""><br>图1 32位系统 C 程序典型存储空间布局</p><p>另外使用 pmap(1) 命令可以查看进程的内存分配情况，查看的必须是正在运行的进程。使用方法很简单，具体请自行查询 man 手册，这里就不再赘述了。 </p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getpread.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(getenv(<span class="string">"PATH"</span>));</span><br><span class="line">  getchar(); <span class="comment">//阻塞进程</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axf  <span class="comment">#查看当前进程关系 找到 getpread 所在的进程</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap 64003  <span class="comment">#查看  getpread 进程 空间布局</span></span><br></pre></td></tr></table></figure><h3 id="pmap-1-查看进程空间分布-布局表"><a href="#pmap-1-查看进程空间分布-布局表" class="headerlink" title="pmap(1) 查看进程空间分布 布局表"></a>pmap(1) 查看进程空间分布 布局表</h3><h2 id="6-库"><a href="#6-库" class="headerlink" title="6. 库"></a>6. 库</h2><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><h3 id="手工装载库-（共享库）"><a href="#手工装载库-（共享库）" class="headerlink" title="手工装载库 （共享库）"></a>手工装载库 （共享库）</h3><p>类似于插件，当一个模块失败时不会影响其它模块。</p><p>内核采用插件的这种形式是有好处的，比如系统启动的时候，如果某个服务（如 ftp 服务、DHCP 等服务）启动未成功，系统会继续启动其它服务而不会立即关机。</p><p>否则如果因为 ftp 服务启动失败就关机那就坏了，想要修复 ftp 服务需要先开机，而开机需要成功启动 ftp 服务，那么系统就无法启动了。</p><p>内核中任何一个模块的加载都要以插件的形式运行，也就是尝试加载，即使加载失败也不能影响其它模块。</p><ul><li>dlopen</li><li>dlclose</li><li>dlerror</li><li>dlsym</li></ul><h4 id="dlopen-3"><a href="#dlopen-3" class="headerlink" title="dlopen(3)"></a>dlopen(3)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dlopen - programming interface to dynamic linking loader</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数就是用来手工装载共享库的。</span></span><br><span class="line"><span class="comment">// filename：加载的共享库文件路径</span></span><br><span class="line"><span class="comment">// flag：打开方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="7-函数跳转"><a href="#7-函数跳转" class="headerlink" title="7. 函数跳转"></a>7. 函数跳转</h2><blockquote><p>函数 setjmp(3) 和 longjmp(3)</p></blockquote><p>goto 语句想必大家都很熟悉了吧，但是它们有一个缺点，就是不能跨函数跳转。C 标准给我们提供了两个函数增强了程序跳转的能力，它们可以使程序跨函数跳转。</p><p><img src="./jincheng_huanjing_02.png" alt=""><br>图2 函数栈帧</p><p>很多人都忌讳跳转这种东西，认为它会破坏程序的结构。LZ 刚也反对在程序中随意使用跳转，跳转是把利刃，好钢要用到刀刃上，所以一定要把跳转用在合适的地方，这样能让你的程序写得非常漂亮。</p><p>那么长跳转的好处是什么呢？</p><p>见图2，如果 a() b() c() d() 是同一个函数，则是递归调用。</p><p>例如当利用递归在一个树状结构中查找一个数据时，查找到最深的层次发现没有找到想要的数据，这时候没有必要再一层一层的返回了，可以直接跳转回递归点。goto是做不到的，需要用 setjmp(3)或longjmp(3)函数安全的返回。</p><p>下面我们来看看这两个函数怎么使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setjmp - save stack context for nonlocal goto</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// longjmp, siglongjmp - nonlocal jump to a saved stack context</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>首先要通过 setjmp(3) 设置一个跳转点，然后可以通过 longjmp(3) 跳转到 setjmp(3) 所在的位置。</p><p>setjmp(3) 设置跳转点时返回值为0，被跳转过来时返回值为非零，也就是 longjmp(3) 的 val 参数。所以 setjmp(3) 下面一定跟着一组分支语句来根据不同的返回值做不同的操作。</p><p>longjmp(3) 无需返回值，因为执行的时候程序已经跳转了，无法获得返回值了。</p><p>参数列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env： 是指定条准到哪</span><br><span class="line">val：带回去的值，如果值为 0，则 setjmp(3) 收到的返回值是 1，避免跳转出现死循环。</span><br></pre></td></tr></table></figure><p>下面来看举个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> jmp_buf save;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Jump now.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="comment">// if longjmp() invoked with a second argument of 0, i will be returned will instead; 所以，该函数第二个函数 恶意传0 也不会造成死循环</span></span><br><span class="line">    longjmp(save,<span class="number">8</span>); <span class="comment">// 跳</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call d().\n"</span>,__FUNCTION__);</span><br><span class="line">    d();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():d() returned.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call c().\n"</span>,__FUNCTION__);</span><br><span class="line">    c();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():c() returned.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>,__FUNCTION__);</span><br><span class="line">    ret = setjmp(save);</span><br><span class="line">   <span class="keyword">if</span>(ret == <span class="number">0</span>) <span class="comment">// 设置跳转点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s():Call b().\n"</span>,__FUNCTION__);</span><br><span class="line">        b();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s():b() returned.\n"</span>,__FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 跳回到这</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s():Jumped back here with code %d\n"</span>,__FUNCTION__,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call a().\n"</span>,__FUNCTION__);</span><br><span class="line">    a();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():a() returned.\n"</span>,__FUNCTION__);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>,__FUNCTION__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ gcc jmp.c -Wall -o jmp</span><br><span class="line">&gt;$ ./jmp</span><br><span class="line">main():Begin.</span><br><span class="line">main():Call a().</span><br><span class="line">a():Begin.</span><br><span class="line">a():Call b().</span><br><span class="line">b():Begin.</span><br><span class="line">b():Call c().</span><br><span class="line">c():Begin.</span><br><span class="line">c():Call d().</span><br><span class="line">d():Begin.</span><br><span class="line">d():Jump now.</span><br><span class="line">a():Jumped back here with code 8</span><br><span class="line">a():End.</span><br><span class="line">main():a() returned.</span><br><span class="line">main():End.</span><br><span class="line">&gt;$</span><br></pre></td></tr></table></figure><p>注意：setjmp(3) 和 longjmp(3) 函数不能从信号处理函数中跳转，具体原因我们在后面讨论信号的时候会说明。</p><h2 id="8-资源的获取及控制"><a href="#8-资源的获取及控制" class="headerlink" title="8. 资源的获取及控制"></a>8. 资源的获取及控制</h2><p><code>ulimit -a</code> 关乎一个进程能使用的资源量是多少；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-m: resident <span class="built_in">set</span> size (kbytes)      unlimited</span><br><span class="line">-u: processes                       4096</span><br><span class="line">-n: file descriptors                1024   <span class="comment"># 一个进程能打开文件最多个数</span></span><br><span class="line">-l: locked-in-memory size (kbytes)  64</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 7144</span><br><span class="line">-q: bytes <span class="keyword">in</span> POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br></pre></td></tr></table></figure><p>13.函数 getrlimit(2) 和 setrlimit(2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getrlimit, setrlimit - get/set resource limits</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure><p>每个进程都有一组对资源使用的上限，通过这两个函数可以获取或设置这些上限。</p><p>ulimit(P) 命令就是使用这两个函数封装的。</p><p>getrlimit(2) 获取 resource 资源，并且把读取结果回填到 rlptr 中。</p><p>setrlimit(2) 设置 resource 资源，设置的值由用户填在 rlimit 中。</p><p>rlimit 结构体的内容也很简单，当然这些资源上限也不是随便可以修改的，下面的规则同样适用于 ulimit(P) 命令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">  <span class="keyword">rlim_t</span> rlim_cur; <span class="comment">/* 软限制。普通用户能提高和降低软限制，但是不能高过硬限制。超级用户也一样。 */</span></span><br><span class="line">  <span class="keyword">rlim_t</span> rlim_max; <span class="comment">/* 硬限制。普通用户只能降低自己的硬限制，不能提高硬限制。超级用户能提高硬限制也能降低硬限制。 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程关系与守护进程</title>
      <link href="2020/12/16/apue-5/"/>
      <url>2020/12/16/apue-5/</url>
      
        <content type="html"><![CDATA[<h1 id="进程关系与守护进程"><a href="#进程关系与守护进程" class="headerlink" title="进程关系与守护进程"></a>进程关系与守护进程</h1><h2 id="1-1-终端"><a href="#1-1-终端" class="headerlink" title="1.1 终端"></a>1.1 终端</h2><p>真正意义上的终端是“笨设备”，只能接收命令的输入并返回结果。你问它 1+1=? 它也不知道，它只能把你的问题传给计算机，再把计算机返回的结果显示给你。</p><p>它出现在计算机既昂贵又庞大的年代。那时候的计算机昂贵到了只有一部分公司买得起、另一部分公司买不起，而且有些公司只能买一台，买第二台就要破产了的程度。</p><p>所以这么昂贵的设备如果只能给一个人使用太浪费了，于是为了让计算机可以被多人使用，就出现了终端这种设备。</p><p>接下来我们简单的聊聊 Linux 是如何使用户登录的。</p><p><img src="./sh_thread_01.png" alt=""><br>图1 Linux 用户登录过程</p><p>如图1 所示，内核自举时创建 1 号 init 进程，init 对每一个终端执行 fork(2) + exec(3) + getty(1) 命令，getty(1) 命令的作用是要求用户输入用户名。</p><p>等待用户输入完成用户名后，getty(1) 会 exec(3) + login(1)。</p><p>login(1) 命令首先根据用户名通过 getpwnam(3) 函数得到用户的口令文件登录项，然后调用 getpass(3) 函数以屏蔽回显的形式获得用户的密码，最后再通过 crypt(3) 函数将加密后的用户口令与阴影口令文件用户登录项中的 pw_passwd 字段相比较，认证失败几次之后就会回到上图的第一步，init 进程将重新执行 fork(2) + exec(3) + getty(1)。</p><p>如果认证成功则启动用户登录 shell，并使用 chown(2) 更改当前登录终端的所有权，使登录用户成为它的所有者。登录之前的步骤都是 root 身份，所以真正用户权限被降下来就是在这个时候发生的。</p><p>当然 login 要做的事情不仅仅只有这点儿，它还要做许多其它需要为用户初始化的事情。</p><p>说句题外话，大家注意到了没有，如果获取用户名或密码的时候函数的编写者敢使用类似 scanf(3) 这样的函数读取用户输入，则很容易遭受缓冲区溢出攻击。</p><h2 id="1-2-会话-Session"><a href="#1-2-会话-Session" class="headerlink" title="1.2 会话(Session)"></a>1.2 会话(Session)</h2><p>一次成功的终端登录就是一个会话。现在一次 shell 的成功登录，相当于那时候终端的成功登录。会话相当于是进程组的容器，它能承载一个或多个进程组。</p><h2 id="1-3-进程组"><a href="#1-3-进程组" class="headerlink" title="1.3 进程组"></a>1.3 进程组</h2><blockquote><p>进程组用来承载进程，一个进程组中有一个或多个进程，它是一个或多个进程的集合（也可以看作是容器）。一个进程不但拥有唯一的 PID，同时也属于一个进程组。一个进程最少有一个线程在运行，</p></blockquote><p>如何产生一个进程组呢？很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用管道可以用一条命令产生一个进程组(多个进程)。</span></span><br><span class="line">ls | more <span class="comment"># 把第一个进程的标准输出作为第二个进程的标准输入</span></span><br></pre></td></tr></table></figure><h3 id="进程组分为前台进程组和后台进程组"><a href="#进程组分为前台进程组和后台进程组" class="headerlink" title="进程组分为前台进程组和后台进程组"></a>进程组分为前台进程组和后台进程组</h3><p><em>一个会话中只能有一个前台进程组，也可以没有前台进程组。</em></p><p>终端设备(如键盘)只能与前台进程通讯，不能与后台进程通讯，根据约定，如果终端设备与一个后台进程关联，就会杀掉这个后台进程。</p><p>什么是前台进程组呢？比如你正在使用 tar 命令进行打包的时候是无法再输入其它命令的。如果 tar 命令执行的时间很长，我们就会在命令后面添加一个 &amp; 参数，把它放到后台去运行。</p><p>ps(1) 命令的 SID(Session ID)列 就是程序运行的会话 ID。</p><p>进程是先出现的，后来人们发现进程可以拆分为多个小任务分别执行，于是便出现了线程的概念，这个到后面线程的章节会详细讨论。</p><p>如今进程已经退化为容器了，它的存在就是为了承载线程。PID 看似是进程号，实际上是线程在消耗它。<br>处理器在处理当前的调度的时候，其实是以线程为单位来进行调度的。所以多线程的并发要比多进程并发更加规范。因为多进程的并发是先成为事实标准，后来有标准化的。多线程不同，它是现有标准化，再有标准实现的。</p><p>进程和线程只是我们的说法，内核中只能看到线程，内核所谓的进程管理其实就是线程管理，内核永远以线程为单位执行任务。</p><p>总结来说：</p><p><em>会话用来承载进程组，进程组用来承载进程，进程用来承载线程。</em></p><p>第九章了解这几个概念就差不多了，还记得我们前面提到的 myshell 吗，用 fork(2) + exec(3) + wait(2) 来实现一个可以执行外部命令的 shell。如果你想实现一个支持内部命令的 shell 那么可以仔细学习一下第九章的内容，shell 内部命令处理的主要知识点都在第九章。</p><ul><li>setsid(2)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setsid - create session and set process group ID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>getpgrp();</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 返回当前进程所在进程组的id</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;<span class="comment">// 查看一个指定进程所在进程组的id</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>; <span class="comment">// 系统调用  // 获取某一个进程的 groupId</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;<span class="comment">// 把指定进程放到 指定的进程组中</span></span><br></pre></td></tr></table></figure><p>创建一个会话并设置进程组的ID。这个函数是我们在第 9 章最有价值的函数，没有这个函数，我们后面就无法创建守护进程。</p><p>调用者不能是进程组组长，调用者在调用之后自动变为新进程组组长，并且脱离控制终端，进程 ID 将被设为进程组 ID 和会话 ID，所以守护进程通常 PID、PGID、SID 是相同的。通常的用法是父进程 fork(2) 一个子进程，然后子进程调用 setsid(2) 将自己变成守护进程，父进程退出即可。</p><h2 id="1-4-守护进程"><a href="#1-4-守护进程" class="headerlink" title="1.4 守护进程"></a>1.4 守护进程</h2><blockquote><p>常常在系统自举时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以是在后台运行的。</p></blockquote><p>守护进程的特点：</p><p>1）脱离控制终端，ps(1) axj tty 为问号(?)。</p><p>2）是进程组的 leader，也就是 PID 和 PGID 相同。</p><p>3）通常没有父进程，由 1 号  init 接管。</p><p>4）创建了一个新会话，是 session 的 leader，所以 PID 与 SID 相同。</p><p>使用 ps(1) axj 命令查看，PID、PGID、SID 相同的进程就是守护进程。</p><p>守护进程也可以使用标准输出，但是不符合常理了，因为守护进程没有控制终端，所以守护进程一般会关闭或重定向标准输入输出流。</p><p> 写守护进程的时候我们会切换工作路径，把它切换到一个一定会存在的路径，比如 /。因为假设你的守护进程是在一个可卸载设备(如U盘)上被启动的，如果不修改工作路径，该设备无法被卸载。</p><p>调用 umask(2) 是为了将文件模式创建掩码设置为一个已知值，因为通过继承得来的掩码可能会被设置为拒绝某些权限，如果守护进程中需要这些权限则要设置它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps axj</span><br><span class="line"><span class="comment"># 守护进程的特点</span></span><br><span class="line"><span class="comment"># ppid 是1</span></span><br><span class="line"><span class="comment"># pid pgid sid 相同</span></span><br><span class="line"><span class="comment"># tty ？ 脱离控制终端</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PPID PID     PGID   SID    TTY   TPGID  STAT   UID   TIME   COMMAND</span><br><span class="line">1    2109    2109   2109    ?    -1     Ss     0     0:00   /usr/sbin/sshd</span><br></pre></td></tr></table></figure><p>对于书上的栗子，有两点要吐槽：</p><p>1）SIGHUP 信号用于通知服务进程软重启，比如修改了某服务的配置文件之后可以通过给服务进程发 SIGHUP 信号使它重新读取配置文件，所以如果没有特殊要求不必忽略该信号。</p><p>2）如果没有特殊要求，不必关闭所有的文件描述符，仅关闭标准输入、标准输出和标注错误即可。</p><h3 id="1-4-1-实现一个守护进程（信号章节结束后补充完整）"><a href="#1-4-1-实现一个守护进程（信号章节结束后补充完整）" class="headerlink" title="1.4.1 实现一个守护进程（信号章节结束后补充完整）"></a>1.4.1 实现一个守护进程（信号章节结束后补充完整）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid =  fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup2(fd, <span class="number">0</span>);</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    dup2(fd, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&gt;<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    setsid();</span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"><span class="comment">//  umask(0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>( daemonize())</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, i); <span class="comment">// 守护进程没办法使用标准输入输出了，应该放到系统日志里面了</span></span><br><span class="line">        fflush(fp);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tail -f /tmp/out <span class="comment"># 动态查看该文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 529</span></span><br><span class="line"><span class="comment"># 530</span></span><br><span class="line"><span class="comment"># 531</span></span><br><span class="line"><span class="comment"># 532</span></span><br><span class="line"><span class="comment"># 533</span></span><br><span class="line"><span class="comment"># 534</span></span><br><span class="line"><span class="comment"># 535</span></span><br><span class="line"><span class="comment"># 536</span></span><br><span class="line"><span class="comment"># 537</span></span><br><span class="line"><span class="comment"># 。</span></span><br><span class="line"><span class="comment"># 。</span></span><br><span class="line"><span class="comment"># 。</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-如何杀死一个守护进程"><a href="#1-4-2-如何杀死一个守护进程" class="headerlink" title="1.4.2 如何杀死一个守护进程"></a>1.4.2 如何杀死一个守护进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> pid</span><br></pre></td></tr></table></figure><h2 id="1-5-系统日志"><a href="#1-5-系统日志" class="headerlink" title="1.5 系统日志"></a>1.5 系统日志</h2><blockquote><p>每个程序都有必要写系统日志，但是写系统日志的权限没办法交给所有人。</p></blockquote><p>守护进程不应使用标准输出，那么当守护进程需要记录一些事件或者是错误的时候怎么办呢？那就要采用系统日志了。</p><p>系统日志一般保存在 <code>/var/log/</code> 目录下，但是这个目录下的日志文件权限几乎都是只有 root 才能读写，那么普通用户的日志如何写入呢？这就需要借助系统日志函数来写日志了。</p><h3 id="1-5-1-syslogd"><a href="#1-5-1-syslogd" class="headerlink" title="1.5.1 syslogd"></a>1.5.1 syslogd</h3><p>root 用户授权给 <code>syslogd</code> 服务专门写日志，然后其它程序都需要通过封装好的一系列函数调用 syslogd 服务来记录日志。这样就提高了日志的安全性了，可以防止日志文件被非法篡改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps axj | grep <span class="string">"syslogd"</span></span><br><span class="line"></span><br><span class="line">1   1203   1203   1203 ?     -1 Ssl      0   0:11 /usr/sbin/rsyslogd -n</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// closelog, openlog, syslog - send messages to the system logger</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>openlog(3) 函数并非是打开日志文件，而是与 syslogd 服务建立链接，表示当前进程要写日志。</p><p>参数列表：</p><p>　　ident：表明自己的身份，由程序员自行指定，写什么都行。</p><p>　　option：要在日志中附加什么内容，多个选项用按位或链接。LOG_PID 是附加 PID，这个是最常用的。</p><p>　　facility：消息来源。一般只能指定一个。</p><table><thead><tr><th align="left">消息来源</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">LOG_CRON</td><td align="center">消息来自定时任务</td></tr><tr><td align="left">LOG_DAEMON</td><td align="center">消息来自守护进程</td></tr><tr><td align="left">LOG_FTP</td><td align="center">消息来自 FTP 服务</td></tr><tr><td align="left">LOG_KERN</td><td align="center">消息来自内核</td></tr><tr><td align="left">LOG_USER</td><td align="center">默认，常规用户级别消息</td></tr><tr><td align="left">表1 facility 参数的常见需选项</td><td align="center"></td></tr></tbody></table><p>syslog(3) 函数用于提交日志内容，参数列表：</p><p>　　priority：优先级。详见下表：</p><table><thead><tr><th align="left">级别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">LOG_EMERG</td><td align="center">「严重」导致系统不可用的问题</td></tr><tr><td align="left">LOG_ALERT</td><td align="center">「严重」必须立即处理的情况</td></tr><tr><td align="left">LOG_CRIT</td><td align="center">「严重」临界条件</td></tr><tr><td align="left">LOG_ERR</td><td align="center">「严重」错误</td></tr><tr><td align="left">LOG_WARNING</td><td align="center">警告</td></tr><tr><td align="left">LOG_NOTICE</td><td align="center">正常</td></tr><tr><td align="left">LOG_INFO</td><td align="center">信息</td></tr><tr><td align="left">LOG_DEBUG</td><td align="center">调试</td></tr><tr><td align="left">表2 日志优先级</td><td align="center"></td></tr></tbody></table><p>以 LOG_ERR 为分界线，如果遇到了程序无法继续运行的问题，要报 LOG_ERR 以上的级别（包括 LOG_ERR）。</p><p>如果遇到的问题不会影响程序继续运行，报 LOG_ERR 以下级别的就可以了。</p><p>日志太多肯定对磁盘空间的要求就比较高，而且无用的日志太多会影响日志审计。日志文件中会记录哪些级别的日志是在配置文件中配置的，默认的情况是 LOG_DEBUG 以上级别的日志都会被记录。</p><p>　　format：类似于 printf(3) 函数的格式化字符串。注意不要使用转义字符 \n，否则日志中会记录一个字符串”\n”而不是记录一个换行符。</p><p>　　…：format 中占位符的参数。</p><p>closelog(3) 表示日志写入结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid =  fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup2(fd, <span class="number">0</span>);</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    dup2(fd, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&gt;<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    setsid();</span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"><span class="comment">//  umask(0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>, LOG_PID, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( daemonize())</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">"daemonize() failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_INFO, <span class="string">"daemonize() successed"</span>); <span class="comment">// 结尾写 \n 会被当作文本</span></span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">"fopen(): %s"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syslog(LOG_INFO, <span class="string">"%s was opend."</span>, FNAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, i);</span><br><span class="line">        fflush(fp);</span><br><span class="line">        syslog(LOG_DEBUG, <span class="string">"%d is printed."</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前执行不到下面这两句话，将来会用新的机制解决这个问题。把当前进程的异常终止改变为正常终止</span></span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    closelog();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tail /var/<span class="built_in">log</span>/messages</span><br><span class="line"></span><br><span class="line">Jul 14 21:06:13 localhost su: (to root) hy on pts/1</span><br><span class="line">Jul 14 21:06:13 localhost dbus[716]: [system] Activating service name=<span class="string">'org.freedesktop.problems'</span> (using servicehelper)</span><br><span class="line">Jul 14 21:06:13 localhost dbus[716]: [system] Successfully activated service <span class="string">'org.freedesktop.problems'</span></span><br><span class="line">Jul 14 21:06:17 localhost mydaemon[39494]: daemonize() successed</span><br><span class="line"></span><br><span class="line">Jul 14 21:06:17 localhost mydaemon[39494]: /tmp/out was opend.</span><br><span class="line">Jul 14 21:06:44 localhost chronyd[765]: Selected <span class="built_in">source</span> 119.28.206.193</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有两句被写进系统日志，原因在于 系统日志会根据文件优先级来决定要不要写进去。默认最少要是LOG_INFO以上才会被写进去。 这部分是可配置的，  配置文件好像在 /etc/sysconfig/rsyslog</span></span><br></pre></td></tr></table></figure><h3 id="1-5-2-单实例守护进程"><a href="#1-5-2-单实例守护进程" class="headerlink" title="1.5.2 单实例守护进程"></a>1.5.2 单实例守护进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ service vsftpd start  <span class="comment"># 确定</span></span><br><span class="line">$ service vsftpd start  <span class="comment"># 失败</span></span><br><span class="line"></span><br><span class="line">ps axj | grep <span class="string">"ftp"</span></span><br><span class="line"></span><br><span class="line">1 7204 7204 7204 ?  -1 Ss  0  0:00 /usr/sbin/vsftpd</span><br></pre></td></tr></table></figure><blockquote><p>有些守护进程需要在同一时间只能有一个实例在运行，它们称为单实例守护进程。它们在启动的时候会在 <code>/var/run</code> 下面创建一个进程锁文件，守护进程启动的时候会先判断这个锁文件是否存在，如果已存在就报错并退出，如果不存在就继续运行并创建一个锁文件，退出的时候再删除它。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /var/run/sshd.pid</span><br><span class="line"></span><br><span class="line">109</span><br></pre></td></tr></table></figure><p>守护进程如果想要开机自动启动，可以配置到自动启动脚本中：/etc/rc.d/rc.local</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="2020/12/16/apue-4/"/>
      <url>2020/12/16/apue-4/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>脉络</p><ul><li>进程是什么</li><li>进程是怎么产生的，怎么消亡的，父子进程是何关系</li><li>进程中的一种特殊方式 —— 守护进程</li><li>线程是什么</li><li>线程和进程的关系</li><li>多线程之间通信和多进程之间通信的区别</li></ul><ol><li>进程标识符 pid</li><li>进程的产生 fork vfork</li><li>进程的消亡及释放资源</li><li>exec函数族</li><li>用户权限及组权限</li><li>观摩：解释器文件</li><li>system(); (2,3,4的封装)</li><li>进程会计</li><li>进程时间</li><li>守护进程</li><li>系统日志</li></ol><h2 id="1-进程标识符-pid"><a href="#1-进程标识符-pid" class="headerlink" title="1. 进程标识符 pid"></a>1. 进程标识符 pid</h2><p>pid 是系统中进程的唯一标志，在系统中使用 pid_t 类型表示，它是一个非负整型， 严格来说是一个有符号的16位整型数。 一台机器同时能有3万多个进程；正常情况下有3万多个进程是够用的；不够用的话，结合现在的虚拟机技术，同一台机器上 弄多个虚拟机。</p><h3 id="1-1-ps-（当前进程的情况）"><a href="#1-1-ps-（当前进程的情况）" class="headerlink" title="1.1 ps （当前进程的情况）"></a>1.1 ps （当前进程的情况）</h3><p>ps(1) 命令可以帮助我们分析本章中的一些示例，所以简单介绍一些参数的组合方式，更详细的信息请查阅 man 手册。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axf <span class="comment">#主要用于查看当前系统中进程的 PID 以及执行终端(tty)和状态等信息，更重要的是它能显示出进程的父子关系。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PID TTY      STAT   TIME COMMAND</span><br><span class="line">  2 ?        S      0:00 [kthreadd]</span><br><span class="line">  4 ?        S&lt;     0:00  \_ [kworker/0:0H]</span><br><span class="line">  6 ?        S      0:04  \_ [ksoftirqd/0]</span><br><span class="line">  7 ?        S      0:00  \_ [migration/0]</span><br><span class="line">  8 ?        S      0:00  \_ [rcu_bh]</span><br></pre></td></tr></table></figure><p>TTY： 所占据终端</p><p>STAT： 进程状态</p><p>TIME： 消耗时间</p><p>COMMAND： 哪个命令触发的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axm <span class="comment">#显示进程的详细信息，PID 列下面的减号(-)是这个进程中的线程。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ax -L <span class="comment">#以 Linux 的形式显示当前系统中的进程列表。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PID    LWP TTY      STAT   TIME COMMAND</span><br><span class="line">   1      1 ?        Ss     0:18 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">   2      2 ?        S      0:00 [kthreadd]</span><br><span class="line">   4      4 ?        S&lt;     0:00 [kworker/0:0H]</span><br></pre></td></tr></table></figure><p>LWP: 轻量级进程编号，简单来说就是线程编号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axj  <span class="comment">#以查看当前系统中进程的 PPID、PID、PGID、SID、TTY 等信息。</span></span><br></pre></td></tr></table></figure><h3 id="1-2-进程号是顺次向下使用"><a href="#1-2-进程号是顺次向下使用" class="headerlink" title="1.2 进程号是顺次向下使用"></a>1.2 进程号是顺次向下使用</h3><blockquote><p>比如当前有个进程是10001，然后下一个就是 10002，再下就是10003，即使前面有进程号已经释放掉了，也不会回去去找。进程号是不断向后使用的，当进程号达到最大值的时候，再回到最小一个可用的数值重新使用。</p></blockquote><h3 id="1-3-getpid-获取当前进程号-getppid-获取当前进程父进程号"><a href="#1-3-getpid-获取当前进程号-getppid-获取当前进程父进程号" class="headerlink" title="1.3 getpid() 获取当前进程号  getppid() 获取当前进程父进程号"></a>1.3 getpid() 获取当前进程号  getppid() 获取当前进程父进程号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-进程的产生-fork-vfork"><a href="#2-进程的产生-fork-vfork" class="headerlink" title="2. 进程的产生 fork vfork"></a>2. 进程的产生 fork vfork</h2><p>今天讨论进程控制这一章，也是进程中最终要的一部分，其实主要就是围绕着 fork(2)、exec(2)、wait(2) 这三个函数来讨论 *nix 系统是如何管理进程的。</p><h3 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h3><blockquote><p>fork(2) 函数的作用就是创建子进程，creates a new process by duplication the calling process。 通过复制父进程来创建子进程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork - create a child process</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-fork函数返回值"><a href="#2-1-1-fork函数返回值" class="headerlink" title="2.1.1 fork函数返回值"></a>2.1.1 fork函数返回值</h4><blockquote><p>fork函数之后，在父进程中返回的是子进程的 pid。在子进程中返回值为0.如果失败返回值为 -1.fork语句下面一定跟分支语句。来确定父子关系是什么样的情况。</p></blockquote><p>注意理解关键字 duplication， 拷贝，一摸一样。</p><h4 id="2-1-2-init进程"><a href="#2-1-2-init进程" class="headerlink" title="2.1.2  init进程"></a>2.1.2  init进程</h4><blockquote><p>1号进程， init 进程是所有进程的祖先进程（但不一定是父进程），内核启动后会启动 init 进程，然后内核就会像一个库一样守在后台等待出现异常等情况的时候再出来处理一下，其它的事情都由 init 进程创建子进程来完成。</p></blockquote><p>调用 fork(2) 创建子进程的时候，刚开始父子进程是一模一样的，就连代码执行到的位置都是一模一样的。</p><p>fork(2) 执行一次，但返回两次。它在父进程中的返回值是子进程的 PID，在子进程中的返回值是 0。子进程想要获得父进程的 PID 需要调用 getppid(2) 函数。</p><p>一般来说调用fork后会执行 if(依赖fork的返回值) 分支语句，用来区分下面的哪些代码由父进程执行，哪些代码由子进程执行。</p><p>好了，既然父进程通过复制一份自己创建了子进程，难道父子进程就是一模一样的吗？只有下面这5点不一样。</p><h4 id="2-1-3-fork后父子进程的区别"><a href="#2-1-3-fork后父子进程的区别" class="headerlink" title="2.1.3  fork后父子进程的区别"></a>2.1.3  fork后父子进程的区别</h4><p>(1) fork(2) 的返回值不同；</p><p>(2) 父子进程的 PID 不相同；</p><p>(3) 父子进程的 PPID 不相同； // PPID 就是父进程 PID</p><p>(4) 在子进程中资源的利用量清零，否则如果父进程打开了很多资源，子进程能使用的资源量就很少了；</p><p>(5) 未决信号和文件锁不继承。</p><p>父进程与子进程谁先运行是不确定的，这个执行顺序是由进程调度器决定的，不过 vfork(2) 会保证子进程先运行。进程调度器不是一个工具，是在内核中的一块代码。</p><p>写个简单的小栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">pid_t</span> pid;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%d]Begin!\n"</span>, getpid());</span><br><span class="line"> </span><br><span class="line">     pid = fork();</span><br><span class="line">     <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         perror(<span class="string">"fork()"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"[%d] Child is working!\n"</span>, getpid());</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"[%d] parent is working!\n"</span>, getpid());</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%d]End!\n"</span>, getpid());</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[95852]Begin!</span><br><span class="line">[95852] parent is working!</span><br><span class="line">[95852]End!</span><br><span class="line">[95853] Child is working!</span><br><span class="line">[95853]End!</span><br></pre></td></tr></table></figure><p><strong>第一个结论</strong> </p><blockquote><p>永远不要猜测父子进程 谁先被调度。调度器的调度策略来决定哪个进程先运行</p></blockquote><ul><li>如果非得决定两个进程得执行顺序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line">   <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      perror(<span class="string">"fork()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"[%d] Child is working!\n"</span>, getpid());</span><br><span class="line">   &#125; <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      sleep(<span class="number">1</span>); <span class="comment">// 可以加sleep 来约定</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"[%d] parent is working!\n"</span>, getpid());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>阻塞程序 来查看它们的父子进程关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>();</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ ps axf</span><br><span class="line"></span><br><span class="line">11220 pts/0    Ss     0:10  \_ shell</span><br><span class="line">96877 pts/0    S+     0:00  |   \_ ./fork1</span><br><span class="line">96878 pts/0    S+     0:00  |       \_ ./fork1</span><br></pre></td></tr></table></figure><p> 从 ps(1) 命令可以看出来，96877 进程确实产生了一个子进程 96878。</p><p><strong>第二个结论</strong> </p><blockquote><p>当前的shell 创建了 fork1这个进程，因为是在 shell环境下， ./fork1 的。在fork1 这个进程中有产生了一个进程 fork1，（名字也是自己）有 shell/fork1/fork1 这种阶梯关系的，就能看出父子进程之间的关系。 我们发现还有很多进程 都类似 shell 前面的 <code>\</code> 这种顶格写的，他们的父进程都是1，即init。所以不是 1号 init进程直接 fork出来所有进程的。有可能 init fork出来A， Afork出来B，1号进程是所有进程的祖先进程。不能认为是所有进程的父进程。</p></blockquote><p>后面在讨论释放进程的时候，会涉及到 孤儿进程，僵尸进程。有些进程会父进程消亡，然后由init来接管。</p><p>重定向到文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork1.c</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%d]Begin!\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">     fflush(<span class="literal">NULL</span>); <span class="comment">//一定要在fork之前  刷新所有成功打开的流</span></span><br><span class="line"></span><br><span class="line">     pid = fork();</span><br><span class="line">     <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         perror(<span class="string">"fork()"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"[%d] Child is working!\n"</span>, getpid());</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"[%d] parent is working!\n"</span>, getpid());</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"[%d]End!\n"</span>, getpid());</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是这里面有一个问题，我们重新执行一遍这个程序，这次将输出重定向到文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &gt;$ ./fork1 &gt; result.txt</span><br><span class="line"> &gt;$ cat result.txt</span><br><span class="line">[97309]Begin!</span><br><span class="line">[97309] parent is working!</span><br><span class="line">[97309]End!</span><br><span class="line">[97309]Begin!</span><br><span class="line">[97310] Child is working!</span><br><span class="line">[97310]End!</span><br></pre></td></tr></table></figure><p><strong>第三个结论</strong></p><blockquote><p>fflush 的重要性</p></blockquote><p>发现有什么不同了吗？父进程竟然输出了两次 Start!，这是为什么呢？</p><p>其实第二次 Start! 并不是父进程输出的，而是子进程输出的。但是为什么 PID 却是父进程的呢？</p><p>其实这是因为行缓冲变成了全缓冲导致的，之前我们讲过，标准输出默认是行缓冲模式，而系统默认的是全缓冲模式。所以当我们将它输出到控制台的时候是可以得到预期结果的，但是一旦重定向到文件的时候就由行缓冲模式变成了全缓冲模式，全缓冲模式下， <code>\n</code> 只起到一个 换行的作用，是不刷新缓冲区的。</p><p>也就是说在 <code>Begin!</code>放到了缓冲区当中，还没来得及写到文件里面的时候。马上fork了。而子进程产生的时候是会复制父进程的缓冲区的数据的，所以子进程刷新缓冲区的时候子进程也会将从父进程缓冲区中复制到的内容刷新出来。这样，父子进程的缓冲区里面各自有了这句 <code>Begin!</code><br>同时这也印证了为什么两次输出的 <code>Begin</code> 都带着父进程的进程号<code>[97309]Begin!...[97309]Begin!</code>. 正是因为这个语句在第一次执行的时候已经固定了，后面直接复制的。</p><p>因此，在使用 fork(2) 产生子进程之前一定要使用 <code>fflush(NULL)</code> 刷新所有缓冲区！</p><p>那么再考虑一个问题，当程序运行的时候，为什么子进程的输出结果是在当前 shell 中，而没有打开一个新的 shell 呢？</p><p>这是因为子进程被创建的时候会复制父进程所有打开的文件描述符，所谓的“复制”是指就像执行了 dup(2) 函数一样，父子进程每个相同的打开的文件描述符共享一个文件表项。</p><p>而父进程默认开启了 0(stdin)、1(stdout)、2(stderr) 三个文件描述符，所以子进程中也同样存在这三个文件描述符。</p><p>既然子进程会复制父进程的文件描述符，也就是说如果父进程在创建子进程之前关闭了三个标准的文件描述符，那么子进程也就没有这三个文件描述符可以使用了。</p><p>从上面的 ps(1) 命令执行结果可以看出来，我们的父进程是 bash 的子进程，所以我们父进程的三个标准文件描述符是从 bash 中复制过来的。</p><h3 id="2-2-继续理解父子进程的关系"><a href="#2-2-继续理解父子进程的关系" class="headerlink" title="2.2 继续理解父子进程的关系"></a>2.2 继续理解父子进程的关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单机版程序</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i, j, mark;</span><br><span class="line">     <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         mark = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 mark = <span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (mark)</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./primer0</span><br><span class="line">30000001 is a primer</span><br><span class="line">30000023 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000041 is a primer</span><br><span class="line">30000049 is a primer</span><br><span class="line">30000059 is a primer</span><br><span class="line">30000071 is a primer</span><br><span class="line">30000079 is a primer</span><br><span class="line">30000083 is a primer</span><br><span class="line">30000109 is a primer</span><br><span class="line">30000133 is a primer</span><br><span class="line">30000137 is a primer</span><br><span class="line">30000149 is a primer</span><br><span class="line">30000163 is a primer</span><br><span class="line">30000167 is a primer</span><br><span class="line">30000169 is a primer</span><br><span class="line">30000193 is a primer</span><br><span class="line">30000199 is a primer</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./primer0| wc -l</span><br><span class="line">18</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ time ./primer0 &gt; /dev/null</span><br><span class="line">./primer0 &gt; /dev/null  </span><br><span class="line"></span><br><span class="line">0.97s  user</span><br><span class="line">0.00s  system</span><br><span class="line">101%   cpu</span><br><span class="line">0.958  total</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用201 个 子进程 来计算这201个等待计算的任务</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i, j, mark;</span><br><span class="line">     <span class="keyword">pid_t</span> pid;</span><br><span class="line">     <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         pid = fork();</span><br><span class="line">         <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           perror(<span class="string">"fork()"</span>);</span><br><span class="line">           <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span>(pid == <span class="number">0</span>)     <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">              mark = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                      mark = <span class="number">0</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line"></span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 子进程正常结束</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无序</span></span><br><span class="line">30000023 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000079 is a primer</span><br><span class="line">30000001 is a primer</span><br><span class="line">30000041 is a primer</span><br><span class="line">30000049 is a primer</span><br><span class="line">30000083 is a primer</span><br><span class="line">30000059 is a primer</span><br><span class="line">30000133 is a primer</span><br><span class="line">30000071 is a primer</span><br><span class="line">30000137 is a primer</span><br><span class="line">30000109 is a primer</span><br><span class="line">30000149 is a primer</span><br><span class="line">30000169 is a primer</span><br><span class="line">30000163 is a primer</span><br><span class="line">30000193 is a primer</span><br><span class="line">30000167 is a primer</span><br><span class="line">30000199 is a primer</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./primer1 | wc -l</span><br><span class="line">18</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">time  ./primer0</span><br><span class="line">./primer0  </span><br><span class="line"></span><br><span class="line">0.99s  user</span><br><span class="line">0.00s  system</span><br><span class="line">61%    cpu</span><br><span class="line">1.623  total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time ./primer1</span><br><span class="line">./primer1  </span><br><span class="line"></span><br><span class="line">0.00s  user</span><br><span class="line">0.01s  system</span><br><span class="line">7%     cpu</span><br><span class="line">0.186  total</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>严格来讲，primer0 是201个数，1个人在干活，要计算201个数值。它消耗合计是 1.623。primer1是201个人 干201个活。总耗时是 0.186。 要计算的话 相当于 1.623/500 才对。但事实上，0.186要远远大于 1.623/500的时长。然而事实并非如此。假设当前机器是单核处理器，尽管创建出来这么多进程。但并发还是取决于调度。那这201个任务，不知道先调度到谁，后调度到谁。但是只有一个处理器在工作。所以任务消耗的时间减少不到哪里去。 </p></blockquote><blockquote><p>而事实上,应该减少。因为本机是双核的处理器。最多的时候是两个任务在并列运行。相当于201个人在干活，要排队用处理器。 当前的时间就应该是 单进程的时间/2，所以一个 0.7到0.8的时间是靠谱的。但为啥小到只有 0.186呢？</p></blockquote><p>暂缓回答问题，先观察一个现象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, mark;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">     <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         pid = fork();</span><br><span class="line">         <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           perror(<span class="string">"fork()"</span>);</span><br><span class="line">           <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span>(pid == <span class="number">0</span>)     <span class="comment">// child</span></span><br><span class="line">         &#123;</span><br><span class="line"> </span><br><span class="line">              mark = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                      mark = <span class="number">0</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (mark)</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">              sleep(<span class="number">1000</span>); <span class="comment">// sleep 阻塞进程</span></span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 子进程正常结束</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">5468 pts/0    S      0:00 ./primer2</span><br><span class="line">5469 pts/0    S      0:00 ./primer2</span><br><span class="line">5470 pts/0    S      0:00 ./primer2</span><br><span class="line">5471 pts/0    S      0:00 ./primer2</span><br><span class="line">5472 pts/0    S      0:00 ./primer2</span><br><span class="line">5473 pts/0    S      0:00 ./primer2</span><br><span class="line">5474 pts/0    S      0:00 ./primer2</span><br><span class="line">5475 pts/0    S      0:00 ./primer2</span><br><span class="line">5476 pts/0    S      0:00 ./primer2</span><br><span class="line">5477 pts/0    S      0:00 ./primer2</span><br><span class="line">5478 pts/0    S      0:00 ./primer2</span><br><span class="line">5479 pts/0    S      0:00 ./primer2</span><br><span class="line">5480 pts/0    S      0:00 ./primer2</span><br><span class="line">5481 pts/0    S      0:00 ./primer2</span><br><span class="line">5482 pts/0    S      0:00 ./primer2</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line">。</span><br><span class="line"><span class="comment"># 观察到有201个 S状态的进程，它们的父进程是 init。</span></span><br></pre></td></tr></table></figure><p><code>“man ps  -&gt;  process state codes”</code>status  S 代表可中断的睡眠态</p><p><code>killall primer2</code> 杀掉相关进程</p><p>继续举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i, j, mark;</span><br><span class="line">       <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          perror(<span class="string">"fork()"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)     <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">             mark = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                     mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (mark)</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">           <span class="comment">//  sleep(1000); // sleep 阻塞进程</span></span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 子进程正常结束， 这里如果不结束的话，子进程还会继续fork，递归fork导致资源被占满，系统卡死</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1000</span>); <span class="comment">// sleep 阻塞父进程</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ ps axf</span><br><span class="line">  3115 pts/0    Ss     0:00  \_ zsh</span><br><span class="line">  7114 pts/0    S+     0:00  |   \_ ./primer3</span><br><span class="line">  7115 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7116 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7117 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7118 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7119 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7120 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7121 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7122 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7123 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  7124 pts/0    Z+     0:00  |       \_ [primer3] &lt;defunct&gt;</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br></pre></td></tr></table></figure><p>当前的 primer3是 S+ ,可中断的睡眠态，从执行结果来看，子进程的状态已经变为 Z+ 了，说明子进程执行完成之后变成了“僵尸进程”。在程序中，父进程在sleep 1000之后，会exit掉。那么这些 zombie 进程会变成 孤儿进程；这些孤儿进程将全部由init来接管。</p><p>在进程关系当中出现 zombie状态是一种正常的。在这里要把子进程看做是 父进程创建出来的资源。当然用完要释放资源。</p><p>那么为什么子进程会变为僵尸进程呢？是因为子进程比父进程先结束了，它们必须得等待父进程为其“收尸”才能彻底释放。</p><p>如果父进程先结束了，那么这些子进程的父进程会变成 1 号 init 进程，当这些子进程运行结束时会变成僵尸进程，然后 1 号 init 进程就会及时为它们收尸。</p><p>很多人会认为僵尸进程不应该出现，它们会占用大量的资源。其实不然，僵尸进程不是不应该存在，而是它可以存在。但它一定要是一闪即逝的。这表示及时收尸了。</p><p>zombie大量存在其实占据不了多少内存。一个zombie进程其实连那个4GB虚拟空间都不占据。 它们在内核中仅仅保留一个结构体，也就是自身的状态信息，其它的资源都释放了。但是它占用了一个重要的系统资源：PID，因为系统中 PID 的数量是有限的，所以及时释放僵尸进程还是很有必要的。</p><p>我们的父进程没有对子进程进行收尸，所以才会出现这样的情况。其实对于这种转瞬即逝的程序而言不会有什么危害，但是假设父进程是一个要不断执行一个月的程序，而它却又不为子进程收尸，那么子进程就会占用这些 PID 一个月之久，那么就可能出现问题了。</p><p>所以在一个完善的程序中，父进程是要为子进程收尸的.</p><h3 id="2-3-父进程为何要对子进程进行收尸"><a href="#2-3-父进程为何要对子进程进行收尸" class="headerlink" title="2.3 父进程为何要对子进程进行收尸"></a>2.3 父进程为何要对子进程进行收尸</h3><blockquote><p>为何不让子进程自行消亡，而是让父进程等待收尸。假如进程号1000的进程fork了一个子进程1001.（父进程空间里面，父进程fork的返回值会是子进程的进程号）还是因为进程消亡之后，如果不收尸，那么1001这个进程号有可能已经被别的进程征用了，导致当前进程里面重复调用1001进程引发其他程序的血崩。</p></blockquote><h3 id="2-4-fork的成本，引出vofork"><a href="#2-4-fork的成本，引出vofork" class="headerlink" title="2.4 fork的成本，引出vofork"></a>2.4 fork的成本，引出vofork</h3><p>父进程中从数据库导入30万条记录，我需要子进程帮我干另外一件事儿。 “打印一个helloworld 然后退出。” 这个消耗有点大， 首先子进程拷贝了这 30万条数据，然后子进程完全没用上。很显然fork的成本是很高的。</p><p>我们画幅图来辅助解释上面说的一大坨是什么意思。</p><p><img src="./jincheng_01.png" alt=""><br>图1 fork(2) 与写时拷贝</p><p>结合上图，我们来聊聊 fork(2) 的前世今生。</p><p>最初的 frok(2) 函数在创建子进程的时候会把父进程的数据空间、堆和栈的副本等数据统统给子进程拷贝一份，如果父进程携带的数据量特别大，那么这种情况创建子进程就会比较耗费资源。</p><p>这还不是最要命的，万一费了这么大劲创建了一个子进程出来，结果子进程没有使用父进程给它的数据，而只是打印了一句 “Hello World!” 就结束退出了，岂不是白白的浪费了之前的资源开销？</p><p>于是聪明的程序猿们想出了一个办法来替代：让父子进程共享同一块数据空间，这样创建子进程的时候就不必担心复制数据耗费的资源较高的问题了，这就是传说中的 vfork(2) 函数实现的效果。</p><p>那么问题来了，如果子进程修改了数据会发生什么情况呢？Sorry，这个标准里没说，天知道会发生什么事情，所以 vfork(2) 通常被认为是过时了的函数，已经不推荐大家使用了。</p><p>既然上面两个办法都不完美，程序猿们只好再次改良 fork(2) 函数，这次虽然效率稍微比 vfork(2) 稍稍低了那么一点点，但是安全性是可以保证的，这就是写时拷贝技术。</p><p>写时复制（Copy-On-Write，COW）简单来说就是，需要改变的时候，才复制一份进行改动。就是 图1 里下面的部分，fork(2) 函数刚刚创建子进程的时候父子进程的数据指向同一块物理内存，但是内核将这些内存的访问变为只读的了，当父子进程中的任何一个想要修改数据的时候，内核会为修改区域的那块内存制作一个副本，并将自己的虚拟地址映射到物理地址的指向修改为副本的地址，从此父子进程自己玩自己的，谁也不影响谁，效率也提高了许多。新分配的副本大小通常是虚拟存储系统中的一“页”。</p><p>当然，写是复制技术中所谓制作一个副本，这个是在物理地址中制作的，并非是我们在程序中拿到的那个指针所指向的地址，我们的指针所指向的地址其实是虚拟地址，所以这些动作对用户态程序员是透明的，不需要我们自己进行管理，内核会自动为我们打点好一切。</p><p><strong>fork别忘了写exit</strong></p><blockquote><p>子进程一定要exit， 否则会额外次数 创建 进程；甚至是阶乘次数</p></blockquote><h3 id="2-4-vfork-2-已废弃的方法"><a href="#2-4-vfork-2-已废弃的方法" class="headerlink" title="2.4 vfork(2) 已废弃的方法"></a>2.4 vfork(2) 已废弃的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfork - create a child process and block parent</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span></span><br><span class="line"></span><br><span class="line">       vfork():</span><br><span class="line">           Since glibc <span class="number">2.12</span>:</span><br><span class="line">               _BSD_SOURCE ||</span><br><span class="line">                   (_XOPEN_SOURCE &gt;= <span class="number">500</span> ||</span><br><span class="line">                       _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED) &amp;&amp;</span><br><span class="line">                   !(_POSIX_C_SOURCE &gt;= <span class="number">200809L</span> || _XOPEN_SOURCE &gt;= <span class="number">700</span>)</span><br><span class="line">           Before glibc <span class="number">2.12</span>:</span><br><span class="line">               _BSD_SOURCE || _XOPEN_SOURCE &gt;= <span class="number">500</span> ||</span><br><span class="line">               _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED</span><br></pre></td></tr></table></figure><p> vfork(2) 函数在上面介绍写时拷贝技术的时候我们就提到了它的工作方式，并且也说了这是一个过时的函数，不推荐大家使用了，简单了解一下就可以了。</p><p>使用 vfork(2) 函数创建的子进程除了与父进程共享数据外，vfork(2) 还保证子进程先运行，在子进程调用 exec(3) 函数族 或 exit(3)(_exit(2)、_Exit(2)) 函数前父进程处于休眠状态。</p><p>另外，使用 vfork(2) 创建的子进程是不允许使用 return 语句返回的，只能使用 exit(3) 函数族的函数结束，否则会被信号杀死，父进程则不受这个限制。</p><h2 id="3-进程的消亡及释放资源"><a href="#3-进程的消亡及释放资源" class="headerlink" title="3. 进程的消亡及释放资源"></a>3. 进程的消亡及释放资源</h2><blockquote><p>主要涉及的函数是 wait 和 waitpid， 另外还有waitid，wait3，wait4</p></blockquote><h3 id="3-1-收尸模块"><a href="#3-1-收尸模块" class="headerlink" title="3.1 收尸模块"></a>3.1 收尸模块</h3><blockquote><p>父进程创建完子进程，子进程干完活。在干活期间，父进程在等着。等子进程状态终止了，再把它收尸回来。收尸最主要的两件事，第一，你是否关心子进程的退出状态。如果关心的话，应该从它那个僵尸进程中把它的状态取过来。第二， 释放pid（这个资源相对重要）</p></blockquote><h3 id="3-2-wait-2-2是系统调用"><a href="#3-2-wait-2-2是系统调用" class="headerlink" title="3.2 wait(2) 2是系统调用"></a>3.2 wait(2) 2是系统调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait, waitpid, waitid - wait for process to change state</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><p>wait(2) 阻塞的等待子进程资源的释放，相当于上面提到的“收尸”。</p><p>每次调用 wait(2) 函数会为一个子进程收尸，而 wait(2) 函数并没有让我们指定是哪个特定的子进程。如果想要为特定的子进程收尸，需要调用 waitpid(2) 函数。</p><p>收尸这件事只能是父进程对子进程做，而且只能对自己的子进程做。子进程是不能为父进程收尸的，父进程也不能为别人的子进程收尸。</p><p>参数列表：</p><p>status：由函数回填，表示子进程的退出状态。如果填 NULL，表示仅回收资源，并不关心子进程的退出状态。</p><p>status 参数可以使用以下的宏进行解析：</p><table><thead><tr><th align="left">宏</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">WIFEXITED(status)</td><td align="center">返回真表示子进程正常终止，返回假表示子进程异常终止。正常与异常终止的8种方式上面讲过。</td></tr><tr><td align="left">WEXITSTATUS(status)</td><td align="center">返回子进程的退出码。只有上一个宏返回正常终止时才能使用，异常终止是不会有返回值的。</td></tr><tr><td align="left">WTERMSIG(status)</td><td align="center">可以获得子进程具体被哪个信号杀死了。</td></tr><tr><td align="left">WIFSTOPPED(status)</td><td align="center">子进程是否被信号 stop 了。stop 和杀死是不同的，stop 的进程可以被恢复(resumed)。</td></tr><tr><td align="left">WSTOPSIG(status)</td><td align="center">如果子进程是被信号 stop 了，可以查看具体是被哪个信号 stop 了。</td></tr><tr><td align="left">WIFCONTINUED(status)</td><td align="center">如果子进程被 stop 了，可以查看它是否被 resumed 了。</td></tr><tr><td align="left">表1 解析 wait(2) 函数 status 参数的宏</td><td align="center"></td></tr></tbody></table><p>pid：一共分为四种情况：</p><table><thead><tr><th align="center">pid参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">&lt; -1</td><td align="center">为归属于进程组 ID 为 pid 参数的绝对值的进程组中的任何一个子进程收尸</td></tr><tr><td align="center">== -1</td><td align="center">为任意一个子进程收尸</td></tr><tr><td align="center">== 0</td><td align="center">为与父进程同一个进程组中的任意一个子进程收尸</td></tr><tr><td align="center">&gt; 0</td><td align="center">为一个 PID 等于参数 pid 的子进程收尸</td></tr><tr><td align="center">表2 wait(2) 函数 pid 参数的取值说明</td><td align="center"></td></tr></tbody></table><p>　　options：为特殊要求；这个参数是这个函数的设计精髓。可以通过 WNOHANG 宏要求 waitpid(2) 函数以非阻塞的形式为子进程收尸，这个也是最常用的特殊要求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                fflush(<span class="literal">NULL</span>);</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"fork()"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"pid = %d\n"</span>, getpid());</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为所有的子进程收尸</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家有没有想过为什么要由父进程为子进程收尸呢，为什么不让子进程结束后自动释放所有资源？试想如果没有收尸这步会发生什么。</p><p>假设父进程需要创建一个子进程并且要让它做 3 秒钟的事情，很不巧子进程刚启动就出现了一个异常然后就挂掉了，并且直接释放了自己的资源。<br>而此时系统 PID 资源紧张，很快已死掉的子进程的 PID 被分配给了其它进程，而父进程此时并不知道手里的子进程的 PID 已经不属于它了。</p><p>如果这时候父进程后悔执行子进程了，它要 kill 掉这个子进程。。。。。后果就是系统大乱对吧。</p><p>而使用了收尸技术之后，子进程状态改变时会给父进程发送一个 SIGCHLD 信号，wait(2) 函数其实就是阻塞等待被这个信号打断，然后为子进程收尸。</p><p>系统通过收尸这种机制来保证父进程未执行收尸动作之前，手里拿到的子进程 PID 一定是有效的了（即使子进程已死掉，但是这个 PID 依然是属于父进程的子进程的，而不会归属于别人）。</p><h3 id="3-3-进程分配-——-交叉分配法"><a href="#3-3-进程分配-——-交叉分配法" class="headerlink" title="3.3 进程分配 —— 交叉分配法"></a>3.3 进程分配 —— 交叉分配法</h3><blockquote><p>从30000000 至 30000200 之间有201个等待计算的数，但是我们不可能每个数都创建出一个进程。因为如果这个等待计算的数进一步扩大时，因为 系统提供的pid 规模是固定的，所以这套方案是没法通用的。</p></blockquote><h4 id="3-3-1-分块法"><a href="#3-3-1-分块法" class="headerlink" title="3.3.1 分块法"></a>3.3.1 分块法</h4><blockquote><p>将被选数 等分为N份，这样的缺点在于可能某一块负载最重，是因为质数的分布是随着数值越大分布越少的</p></blockquote><h4 id="3-3-2-交叉分配"><a href="#3-3-2-交叉分配" class="headerlink" title="3.3.2 交叉分配"></a>3.3.2 交叉分配</h4><blockquote><p>依然将被选数分为N份，但是不再是整个数据集切片，而是发牌一样，每个块分一张，循环下去。缺点是，面对连续数据时候，每一块可能是某个数的倍数集合。这样会导致有些块可能一个质数都没有的情况。尽管如此，交叉分配仍然是一个相对合理的选择</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i, j, mark;</span><br><span class="line">     <span class="keyword">pid_t</span> pid;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="keyword">for</span>(n= <span class="number">0</span>; n&lt;N; n++)</span><br><span class="line">     &#123;</span><br><span class="line">         pid = fork();</span><br><span class="line">         <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             perror(<span class="string">"fork()"</span>);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (pid ==<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">for</span>(i = LEFT+n; i&lt;=RIGHT; i+=N)</span><br><span class="line">             &#123;</span><br><span class="line">                mark = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">                 &#123;</span><br><span class="line">                      <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">                     &#123;</span><br><span class="line">                          mark = <span class="number">0</span>;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (mark)</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">"[%d]%d is a primer\n"</span>,n, i);</span><br><span class="line">             &#125;</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 子进程正常结束</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> st;</span><br><span class="line">     <span class="keyword">for</span> (n = <span class="number">0</span>; n&lt;= N; n++)</span><br><span class="line">         wait(<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[1]30000001 is a primer</span><br><span class="line">[2]30000023 is a primer</span><br><span class="line">[1]30000037 is a primer</span><br><span class="line">[2]30000041 is a primer</span><br><span class="line">[1]30000049 is a primer</span><br><span class="line">[2]30000059 is a primer</span><br><span class="line">[1]30000079 is a primer</span><br><span class="line">[2]30000071 is a primer</span><br><span class="line">[2]30000083 is a primer</span><br><span class="line">[1]30000109 is a primer</span><br><span class="line">[1]30000133 is a primer</span><br><span class="line">[2]30000137 is a primer</span><br><span class="line">[1]30000163 is a primer</span><br><span class="line">[2]30000149 is a primer</span><br><span class="line">[1]30000169 is a primer</span><br><span class="line">[2]30000167 is a primer</span><br><span class="line">[1]30000193 is a primer</span><br><span class="line">[1]30000199 is a primer</span><br></pre></td></tr></table></figure><h3 id="3-4-池"><a href="#3-4-池" class="headerlink" title="3.4 池"></a>3.4 池</h3><blockquote><p>大致是上流的 父进程，将任何发布于池中，下流的N个进程（线程）轮番抢任务执行。具体后续再写标准进程池 和标准线程池 的标准写法 </p></blockquote><h2 id="4-exec函数族"><a href="#4-exec函数族" class="headerlink" title="4.exec函数族"></a>4.exec函数族</h2><p>终于轮到我们今天第三个主角：exec(3) 函数上场了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// execl, execlp, execle, execv, execvp, execvpe - execute a file</span></span><br><span class="line"><span class="comment">// the exec() family of functions replaces the current process image with a new process image.</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span></span><br><span class="line"> </span><br><span class="line">execvpe(): _GNU_SOURCE</span><br></pre></td></tr></table></figure><p>我们再来看上面第一个 fork(2) 代码的栗子执行时使用 ps -axf 命令查看父子依赖关系的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps axf</span><br><span class="line">  3565 pts/1    Ss     0:00  \_ bash</span><br><span class="line">  3713 pts/1    S+     0:00  |   \_ ./1fork</span><br><span class="line">  3714 pts/1    S+     0:00  |       \_ ./1fork</span><br><span class="line"> $</span><br></pre></td></tr></table></figure><p>我们知道 fork(2) 创建出来的子进程是通过复制父进程的形式实现的，但是我们的父进程又是 bash 的子进程，为什么 bash 没有创建出来一个与自己一模一样的子进程呢？</p><p>这就是 exec(3) 函数族的功劳了。</p><p>它可以使调用的它进程“外壳”不变，“内容物”改变为新的东西。“外壳”就是父子关系、PID 等东西，“内容物”其实是指一个新的可执行程序。也就是说 exec(3) 函数会将调用它的进程完全(整个4GB虚拟内存空间，即代码段、数据段、堆栈等等)变成另一个可执行程序，但父子关系、PID 等东西不会改变。</p><p>在执行了 exec(3) 函数族的函数之后，整个进程的地址空间会立即被替换，所以 exec(3) 下面的代码全部都不会再执行了，替代的是新程序的代码段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line">    fflush(<span class="literal">NULL</span>); <span class="comment">// 缓冲区也会被新的程序所替换，所以在执行 exec(3) 之前要使用 fflush(NULL) 刷新所有的缓冲区。这样父进程才会让它缓冲区中的数据到达它们该去的地方，而不是在数据到达目的地之前缓冲区就被覆盖掉。注意在调 execl函数之前，调用 fflush刷新一下缓冲区</span></span><br><span class="line">    execl(<span class="string">"/bin/date"</span>,<span class="string">"date"</span>,<span class="string">"+%s"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    execl 以下的函数不会再执行了，整个进程的虚拟空间换成（replace）另一个可执行程序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    perror(<span class="string">"execl()"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Begin!</span></span><br><span class="line"><span class="comment">// 1594308168</span></span><br></pre></td></tr></table></figure><p>参数列表：</p><p>　　path：要执行的二进制程序路径</p><p>　　arg：传递给 path 程序的 argv 参数，第一个是 argv[0]，其它参数从第二个开始。</p><p>　　…：argv 的后续参数，最后一个参数是 NULL，表示变长参数列表的结束。</p><p>看上去 execl(3)、execlp(3) 像是变参函数，execle(3) 像是定参函数，其实正好是反过来的，execl(3) 和 execlp(3) 是定参的，而 execle(3) 函数是变参的。</p><p>下面我们来看一个 fork(2) + exec(3) + wait(2) 最经典的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建子进程 date，参数是 +%s</span></span><br><span class="line"><span class="comment">   * 相当于在 shell 中执行 date +%s 命令</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">pid_t</span> pid;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"> </span><br><span class="line">     fflush(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">     pid = fork();</span><br><span class="line">     <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         perror(<span class="string">"fork()"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(pid == <span class="number">0</span>)    <span class="comment">// child</span></span><br><span class="line">     &#123;</span><br><span class="line">         execl(<span class="string">"/bin/date"</span>,<span class="string">"date"</span>,<span class="string">"+%s"</span>,<span class="literal">NULL</span>);</span><br><span class="line">         perror(<span class="string">"execl()"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     wait(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Begin!</span></span><br><span class="line"><span class="comment">// 1594309338</span></span><br><span class="line"><span class="comment">// End!</span></span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><p>fork(2)、exec(3)、wait(2) 函数可以让我们创建任何进程来执行任何命令了，如此看来，整个 *nix 世界都是由 fork(2)、exec(3)、wait(2) 这三个函数搭建起来的，现在大家可以尝试用这三个函数来执行一些命令了。</p></blockquote><h3 id="4-1-shell的工作模式"><a href="#4-1-shell的工作模式" class="headerlink" title="4.1 shell的工作模式"></a>4.1 shell的工作模式</h3><blockquote><p>以ls命令具体流程为例</p></blockquote><p>在当前shell下执行 <code>ls</code>这种二进制命令时，它是通过fork产生一个子进程。产生的这个子进程是shell本身。然后去 <code>execl</code> 让子进程摇身一变成 <code>ls</code>。然后在子进程运行的时候，父进程调用<code>wait(NULL)</code>等着给子进程收尸。然后父进程继续做别的任务。</p><p>所以这也解释为什么当执行 <code>ls</code>的时候，是 <code>ls</code>的结果列表先展示出来，然后才是 命令行 <code>$</code>展示出来。</p><p>由于你当前shell一定写的是个死循环。所以shell继续打印出来命令行等待你给终端的输入情况。这就是shell的工作模式；</p><h3 id="4-2-为什么父子进程的输出能打印到同一个终端上"><a href="#4-2-为什么父子进程的输出能打印到同一个终端上" class="headerlink" title="4.2 为什么父子进程的输出能打印到同一个终端上"></a>4.2 为什么父子进程的输出能打印到同一个终端上</h3><p><strong>实现一个sleep100的功能</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid== <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">"/usr/bin/sleep"</span>,<span class="string">"sleep"</span>,<span class="string">"100"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//     execl("/usr/bin/sleep","httpd","100", NULL); //  ps axf 查看进程列表的时候， 会显示重命名的 httpd。 所以 argv[0] 的基本操作；</span></span><br><span class="line"></span><br><span class="line">        perror(<span class="string">"execl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3115 pts/0    Ss     0:01  \_ zsh</span><br><span class="line">30803 pts/0    S+     0:00  |   \_ ./sleep</span><br><span class="line">30804 pts/0    S+     0:00  |       \_ sleep 100</span><br></pre></td></tr></table></figure><h3 id="4-3-shell命令行的实现"><a href="#4-3-shell命令行的实现" class="headerlink" title="4.3 shell命令行的实现"></a>4.3 shell命令行的实现</h3><blockquote><p> shell 的内部命令与外部命令,一个命令的二进制可执行文件，如果是存在磁盘上的。那么这个命令就叫做外部命令。其他的就叫内部命令。比如目录的管理，比如一个进程消亡，它的子进程如何去做。包括调度等等。全部都属于shell的内部命令处理。</p></blockquote><p>像 cd(1)、exit(2)、|、&gt; 牵涉到环境变量改变等动作这样的命令叫做内部命令，而使用 which(1) 命令能查询到的在磁盘上存在的命令就是外部命令。</p><p>学会了 fork(2)、exec(3)、wait(2) 函数的使用，大家已经可以尝试编写一个 shell 程序了，基本可以执行所有的外部命令了。</p><p>但是一个 shell 不仅仅支持外部命令，还支持很多内部命令，对内部命令的支持才是 shell 的难点。</p><p>关于内部命令的内容多数都在《APUE》第三版 的第九章中，感兴趣的童鞋可以自行查阅。</p><p><strong>外部命令实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myshell.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELIMS <span class="meta-string">" \t\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">glob_t</span> globres;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prompt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mysh-0.1$"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">line</span>, struct cmd_st *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tok;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tok = strsep(&amp;<span class="built_in">line</span>, DELIMS);</span><br><span class="line">        <span class="keyword">if</span>(tok == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(tok[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        glob(tok, GLOB_NOCHECK|GLOB_APPEND*i, <span class="literal">NULL</span>, &amp;res-&gt;globres);</span><br><span class="line">        i=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> linebuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span> <span class="title">cmd</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        prompt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf, &amp;linebuf_size, <span class="built_in">stdin</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        parse(linebuf, &amp;cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"fork()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                execvp(cmd.globres.gl_pathv[<span class="number">0</span>], cmd.globres.gl_pathv);</span><br><span class="line">                perror(<span class="string">"execvp()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-用户权限及组权限-u-s-g-s"><a href="#5-用户权限及组权限-u-s-g-s" class="headerlink" title="5. 用户权限及组权限(u+s, g+s)"></a>5. 用户权限及组权限(u+s, g+s)</h2><blockquote><p>用户权限和组权限是分作好几组来存放的，</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shadow</span><br><span class="line"><span class="comment"># 权限不够，  普通用户是没有权限去读写 shadow权限的；</span></span><br><span class="line">passwd</span><br><span class="line"><span class="comment"># 更改一个用户的口令， 超级用户改谁的口令都是可以的。普通用户能改自己的口令（普通用户在最早之前是不能改自己用户的口令）后来想了一系列办法把root权限开始一点点下放，当然shadow文件普通用户绝对没有权限去改变的。而更改口令是必须用改shadow文件的。 但是普通用户可以调用passwd 来更改自己的口令；</span></span><br></pre></td></tr></table></figure><p><strong>普通用户没有查看 /etc/shadow 文件，但是为什么有权限修改自己的密码呢</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ <span class="built_in">which</span> passwd</span><br><span class="line">/usr/bin/passwd</span><br><span class="line">&gt;$ ls -l /usr/bin/passwd </span><br><span class="line">-rwsr-xr-x 1 root root 47032  2月 17  2014 /usr/bin/passwd</span><br><span class="line">$ ls -l /etc/shadow</span><br><span class="line">---------- 1 root root 1899 Apr 1 16:25 /etc/shadow</span><br></pre></td></tr></table></figure><p><strong>passwd这个命令是如何实现的</strong></p><p>u+s</p><blockquote><p>如果一个可执行的文件有 U+S 权限，那就意味着当别的用户在调用当前这个可执行文件的时候，它的身份会切换成当前这个二进制文件的 user的身份来执行。</p></blockquote><p>g+s</p><blockquote><p>不管任何用户来调用这个二进制可执行文件的时候，当前这个用户的身份就会切换成这个二进制文件的同组用户的身份来进行执行。</p></blockquote><p><strong>更改用户 ID 和更改组 ID</strong> </p><p>在bash上执行一个命令是带着身份进行的，身份从何而来呢</p><p>在 *nux 系统中，特权和访问控制是基于用户 ID 和用户组 ID 的，所以当我们需要使用特权或访问无权访问的文件时需要切换 用户 ID 或 用户组 ID。</p><p>uid（userid）</p><p>　　r(real) 用于保存用户权限</p><p>　　e(effective) 鉴定用户权限时使用</p><p>　　s 与 real 相同，所以有些系统不支持</p><p>gid (groupid)</p><p>　　r(real) 用于保存用户组权限</p><p>　　e(effective) 鉴定用户组权限时使用</p><p>　　s 与 real 相同，所以有些系统不支持</p><ul><li>U+S</li></ul><p>这是因为 passwd(1) 命令是具有 U+S 权限的，用户在使用这个程序的时候身份会切换为这个程序文件所有者的身份。</p><ul><li>G+S</li></ul><p>G+S 与 U+S 类似，只不过执行的瞬间身份会切换为与程序归属用户组相同的组权限。</p><p>改变用户 ID 和组 ID 可以使用 setuid(2) 和 setgid(2) 函数实现。</p><h3 id="5-1-相关函数"><a href="#5-1-相关函数" class="headerlink" title="5.1 相关函数"></a>5.1 相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; <span class="comment">// sets the effective user ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>; <span class="comment">// sets the effective group ID</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> egid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</span><br><span class="line">setregid();</span><br></pre></td></tr></table></figure><h3 id="5-2-实现sudo-john-cat-home-john"><a href="#5-2-实现sudo-john-cat-home-john" class="headerlink" title="5.2 实现sudo john cat /home/john"></a>5.2 实现sudo john cat /home/john</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shadow</span><br><span class="line"><span class="comment"># 权限不够</span></span><br><span class="line"></span><br><span class="line">sudo john cat /home/john</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        setuid(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        execvp(argv[<span class="number">2</span>], argv+<span class="number">2</span>);</span><br><span class="line">        perror(<span class="string">"execvp"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line"></span><br><span class="line">chown root mysu</span><br><span class="line">chmod u+s mysu</span><br><span class="line"></span><br><span class="line">./mysu 0 cat /etc/shadow</span><br></pre></td></tr></table></figure><h2 id="6-观摩课：解释器文件"><a href="#6-观摩课：解释器文件" class="headerlink" title="6. 观摩课：解释器文件"></a>6. 观摩课：解释器文件</h2><h3 id="6-1-解释器文件"><a href="#6-1-解释器文件" class="headerlink" title="6.1 解释器文件"></a>6.1 解释器文件</h3><p>解释器文件其实就是脚本。</p><p>做一个系统级开发工程师需要具备的素质至少精通2门语言，一门面向过程，一门面向对象，还要精通至少一门脚本语言，如 shell、python等，还要具备扎实的网络知识和一点硬件知识。</p><p>解释器是一个二进制的可执行文件。就是为了用一个可执行的二进制文件解释执行解释器文件中的命令。</p><h3 id="6-2-脚本文件的标记"><a href="#6-2-脚本文件的标记" class="headerlink" title="6.2  脚本文件的标记"></a>6.2  脚本文件的标记</h3><p>#! 用于装载解释器</p><p>例如：</p><p>#!/bin/shell 装载了 /bin/shell 作为解释器</p><p>#!/bin/cat 装载了 /bin/cat 作为解释器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash   用什么解释器 执行 脚本体</span></span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">whoami</span><br><span class="line">cat /etc/shadow  # 报错的命令不会阻塞下面命令的执行</span><br><span class="line">ps</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x t.exec <span class="comment"># 将t.exec变成可执行文件</span></span><br><span class="line"></span><br><span class="line">./t.exec</span><br><span class="line"></span><br><span class="line">ex.c   fork1.c</span><br><span class="line">hy</span><br><span class="line">cat: /etc/shadow: 权限不够</span><br><span class="line"></span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  4734 pts/1    00:00:00 zsh</span><br><span class="line"> 27153 pts/1    00:00:00 t.exec</span><br><span class="line"> 27157 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><p>那么装载解释器之后为什么不会递归执行装载解释器这行代码呢？因为根据约定，脚本中的 # 表示注释，所以解释器在解析这个脚本的时候不会看到这行装载解释器的命令。</p><p>装载解释器的步骤由内核 exec(3) 系统调用来完成，如果使用 exec(3) 函数来调用解释器文件，实际上 exec(3) 函数并没有执行解释器文件，而是执行了解释器文件中装载的解释器，由它来执行解释器文件中的指令。</p><h2 id="7-system-fork-exec-wait的封装"><a href="#7-system-fork-exec-wait的封装" class="headerlink" title="7. system(); (fork,exec,wait的封装)"></a>7. system(); (fork,exec,wait的封装)</h2><h3 id="7-1-system-3"><a href="#7-1-system-3" class="headerlink" title="7.1 system(3)"></a>7.1 system(3)</h3><blockquote><p>理解： fork,exec,wait封装</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system - execute a shell command</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"date + %s &gt; /tmp/out"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该函数可以执行一条系统命令，是通过调用 /bin/sh -c command 实现的。</p><p>其实我们可以猜测一下 system(3) 命令是如何实现的，下面是伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">pid_t</span> pid;</span><br><span class="line"> </span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     perror(<span class="string">"fork()"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)    <span class="comment">// child</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// system("date +%s");</span></span><br><span class="line">   execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="string">"-c"</span>,<span class="string">"date +%s"</span>,<span class="literal">NULL</span>);</span><br><span class="line">   perror(<span class="string">"execl()"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="8-进程会计"><a href="#8-进程会计" class="headerlink" title="8. 进程会计"></a>8. 进程会计</h2><p>连 POSIX 标准都不支持，是方言中的方言。</p><p>它是典型的事实标准，各个系统的实现都不统一，所以建议少用为妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acct - switch process accounting on or off</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">acct</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure><p>作用是将进程的相关信息写入到 filename 所指定的文件中。</p><h2 id="9-进程时间"><a href="#9-进程时间" class="headerlink" title="9. 进程时间"></a>9. 进程时间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">times</span><span class="params">(struct tms *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_utime;  <span class="comment">/* user time */</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_stime;  <span class="comment">/* system time */</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_cutime; <span class="comment">/* user time of children */</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_cstime; <span class="comment">/* system time of children */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>用户标识</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getlogin, getlogin_r, cuserid - get username</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getlogin_r</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure><p>能够不受任何因素影响的获取当前终端的用户名。</p><p>不受任何因素影响是指，比如我们用 su(1) 等命令切换了用户，getlogin(3) 函数获得到的仍然是原始的用户名。</p><p>进程调度</p><p>用于控制进程调度优先级，一般不会调整进程的优先级。</p><p>进程调度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// times - get process and waited-for child process times</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">clock_t</span> <span class="title">times</span><span class="params">(struct tms *<span class="built_in">buffer</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数获得的是进程的执行时间。</p><p>clock_t 是滴答数。位于秒级以下，具体的与秒的换算值需要通过 sysconf(_SC_CLK_TCK) 宏获得</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程控制</title>
      <link href="2020/12/16/apue-8/"/>
      <url>2020/12/16/apue-8/</url>
      
        <content type="html"><![CDATA[<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><blockquote><p>之前我们在创建线程的时候都是使用的默认属性，本章主要讨论的是自定义线程的属性。使用默认属性基本上能解决掉遇到的大部分问题，所以自定义属性在实际项目中用得比较少。</p></blockquote><h2 id="1-1-线程属性"><a href="#1-1-线程属性" class="headerlink" title="1.1 线程属性"></a>1.1 线程属性</h2><p>《APUE》第三版 P341 表中的属性可以用来限定一个进程能创建线程的最大数量，但是限定线程数量的宏不必太当真，因为在上一篇博文中我们说过了一个线程能创建的线程的数量是受很多因素影响的，并非一定是以这几个宏值为准的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>线程属性使用 pthread_attr_t 类型表示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 见手册 man  pthread_attr_init 的 see also</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Thread is working."</span>);</span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err, i;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 修改每个线程的栈大小</span></span><br><span class="line">    pthread_attr_setstacksize(&amp;attr,<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 测试当前进程能创建多少个线程</span></span><br><span class="line">        err = pthread_create(&amp;tid,&amp;attr,func,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的栗子就是通过线程的属性修改了为每个线程分配的栈空间大小，这样创建出来的线程数量与默认的就不同了。</p><p>线程属性使用 pthread_attr_init(3) 函数初始化，用完之后使用 pthread_attr_destroy(3) 函数销毁。</p><p>线程属性不仅可以设定线程的栈空间大小，还可以创建分离的线程等等。</p><h3 id="1-1-1-互斥量属性"><a href="#1-1-1-互斥量属性" class="headerlink" title="1.1.1 互斥量属性"></a>1.1.1 互斥量属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure><p>互斥量属性使用 pthread_mutexattr_t 类型表示，与线程属性一样，使用之前要初始化，使用完毕要销毁。</p><p>pthread_mutexattr_init(3) 函数用于初始化互斥量的属性，用法跟线程的属性很相似。</p><h4 id="1-1-1-1-互斥量属性常用函数"><a href="#1-1-1-1-互斥量属性常用函数" class="headerlink" title="1.1.1.1 互斥量属性常用函数"></a>1.1.1.1 互斥量属性常用函数</h4><p>pthread_mutexattr_init();<br>pthread_mutexattr_destroy();<br>pthread_mutexattr_getpshared();<br>pthread_mutexattr_setpshared();</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_mutexattr_getpshared, pthread_mutexattr_setpshared  -  get  and set the process-shared attribute</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure><p>函数名称里面的 p 是指 process，这两个函数的作用是设定线程的属性是否可以跨进程使用。这条有点乱是吧，线程的属性怎么能跨进程使用呢？别急，我们先看看 clone(2) 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clone, __clone2 - create a child process</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *child_stack,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="comment">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>clone(2) 进程的 flags 如果设置了 CLONE_FILES 则父子进程共享文件描述符表，正常情况文件描述符表是线程之间共享的，因为多线程是运行在同一个进程的地址空间之内的。</p><p>虽然 clone(2) 函数的描述是创建子进程，但实际上如果将 flags 属性设置得极端分离(各种资源都独享)，相当于创建了一个子进程；</p><p>而如果 flags 属性设置得极端近似(各种资源都共享)，则相当于创建了兄弟线程。所以对于内核来讲并没有进程这个概念，只有线程的概念。你创建出来的到底是进程还是线程，并不影响内核进行调度。</p><p>如果需要创建一个“东西”与当前的线程既共享一部分资源，又独占一部分资源，就可以使用 clone(2) 函数创建一个既不是线程也不是进程的“东西”，因为对内核来说进程和线程本来就是模糊的概念。</p><p>现在能理解为什么上面说 pthread_mutexattr_setpshared(3) 函数的作用是设定线程的属性是否可以跨进程使用了吧？</p><p>互斥量分为四种，不同的互斥量在遇到不同的情况时效果是不同的，《APUE》第三版 P347 有图12-5 说明了这个现象，LZ 把它照搬到这里。</p><table><thead><tr><th align="center">互斥量类型</th><th align="center">没有解锁时重新加锁</th><th align="center">不占用时解锁</th><th align="center">在已解锁时解锁</th></tr></thead><tbody><tr><td align="center">PTHREAD_MUTEX_NORMAL（常规）</td><td align="center">死锁</td><td align="center">未定义</td><td align="center">未定义</td></tr><tr><td align="center">PTHREAD_MUTEX_ERRORCHECK（检错）</td><td align="center">返回错误</td><td align="center">返回错误</td><td align="center">返回错误</td></tr><tr><td align="center">PTHREAD_MUTEX_RECURSIVE（递归）</td><td align="center">允许</td><td align="center">返回错误</td><td align="center">返回错误</td></tr><tr><td align="center">PTHREAD_MUTEX_DEFAULT（默认，我们平时使用的就是这个）</td><td align="center">未定义</td><td align="center">未定义</td><td align="center">未定义</td></tr><tr><td align="center">表1 互斥量类型行为</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>LZ 解释一下表头上的描述是什么意思：</p><p>1）没有解锁时重新加锁：当前 mutex 已 lock，再次 lock 的情况；</p><p>2）不占用时解锁：他人锁定由你解锁的情况；</p><p>3）在已解锁时解锁：当前 mutex 已 unlock，再次 unlock 的情况；</p><h3 id="1-1-2-条件变量的属性"><a href="#1-1-2-条件变量的属性" class="headerlink" title="1.1.2 条件变量的属性"></a>1.1.2 条件变量的属性</h3><h4 id="1-1-2-1-条件变量常见属性"><a href="#1-1-2-1-条件变量常见属性" class="headerlink" title="1.1.2.1 条件变量常见属性"></a>1.1.2.1 条件变量常见属性</h4><p>pthread_condattr_init();<br>pthread_condattr_destroy();</p><h3 id="1-1-3-读写锁属性"><a href="#1-1-3-读写锁属性" class="headerlink" title="1.1.3 读写锁属性"></a>1.1.3 读写锁属性</h3><h2 id="1-2-重入"><a href="#1-2-重入" class="headerlink" title="1.2 重入"></a>1.2 重入</h2><p>第一次见到重入是在信号阶段是吧。</p><p>如果一个函数在相同的时间点可以被多个线程安全地调用，就称该函数是线程安全的。</p><p>POSIX 标准要求，在线程标准制定之后，所有的库必须支持线程安全，如果不支持线程安全需要在函数名添加 <code>_unlocked</code> 后缀，或发布一个支持线程安全的函数，函数名要添加 <code>_r</code> 后缀。</p><p>我们在 man 手册中已经见过很多带有 <code>_r</code> 后缀的函数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿puts举例</span></span><br><span class="line"></span><br><span class="line">puts('aaaaa');</span><br><span class="line">puts('bbbbb');</span><br><span class="line">puts('ccccc');</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbbbbcccccaaaaa</span></span><br><span class="line"><span class="comment">// 绝对不可能出现 abccbabac... 之类的</span></span><br></pre></td></tr></table></figure><p>为什么看不到 <code>abccbabac</code>, 是因为puts函数有这样的功能，</p><p>先锁住缓冲区，把内容填充进去，然后unlock。当三个puts几乎同时调用的时候。就看谁先抢到缓冲区。</p><h3 id="1-2-1-多线程IO"><a href="#1-2-1-多线程IO" class="headerlink" title="1.2.1 多线程IO"></a>1.2.1 多线程IO</h3><h3 id="1-2-2-线程与信号"><a href="#1-2-2-线程与信号" class="headerlink" title="1.2.2 线程与信号"></a>1.2.2 线程与信号</h3><h3 id="1-2-3-线程与fork"><a href="#1-2-3-线程与fork" class="headerlink" title="1.2.3 线程与fork"></a>1.2.3 线程与fork</h3><p>4.线程特定数据</p><p>就是为了某些数据支持多线程并发而做的改进。最典型的就是 errno，errno 最初是全局变量，现在早已变成宏定义了。</p><p>我们把 errno 预编译一下，看看它的庐山真面目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">errno;</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E errno.<span class="keyword">c</span></span><br><span class="line"># <span class="number">2</span> <span class="string">"errno.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"> (*__errno_location ());</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="1-3-线程的取消"><a href="#1-3-线程的取消" class="headerlink" title="1.3 线程的取消"></a>1.3 线程的取消</h2><p>在上一篇博文中我们说过，pthread_cancel(3) 函数只是提出取消请求，并不能强制取消线程。</p><p>线程的取消分为两种情况：允许取消 或 不允许取消。</p><p>pthread_cancel(3) 提出取消请求后，是否允许取消是由被请求取消的线程自己决定的。</p><p>不允许取消没什么好说的，我们说说允许取消。</p><p>允许取消分为两种情况：异步 cancel 和 推迟 cancel（默认）</p><p>1）异步 cancel：是内核的操作方式，这里不做解释。</p><p>2）推迟 cancel：推迟到取消点再响应取消操作。取消点其实就是一个函数，收到取消请求时取消点的代码不会执行。</p><p>《APUE》第三版 P362 图12-14 都是可能导致阻塞的系统调用，它们都是 POSIX 定义的一定存在的取消点。P363 图12-15 是 POSIX 定义的可选取消点，这些函数实际是否为取消点要看平台具体的实现。</p><p>为什么要采用推迟取消的策略，而不是收到请求在任何地方都立即取消呢？我们先举个栗子说明这个问题，大家请看下面的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">thr_func()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>();</span><br><span class="line"></span><br><span class="line">　　--------------------------&gt;收到了一个取消请求</span><br><span class="line"></span><br><span class="line">　　--------------------------&gt;pthread_cleanup_push();-&gt;<span class="built_in">free</span>(p); <span class="comment">// 不是取消点，继续执行</span></span><br><span class="line"></span><br><span class="line">fd1 = <span class="built_in">open</span>(); <span class="comment">// 是取消点，在取消点执行之前响应取消动作</span></span><br><span class="line"></span><br><span class="line">　　--------------------------&gt;pthread_cleanup_push();-&gt;<span class="built_in">close</span>(fd1);</span><br><span class="line"></span><br><span class="line">fd2 = <span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">　　--------------------------&gt;pthread_cleanup_push();-&gt;<span class="built_in">close</span>(fd2);</span><br><span class="line"></span><br><span class="line">pthread_exit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线程执行函数运行的任何时候都可能收到取消请求，假设上面的函数刚刚使用 malloc(3) 函数动态分配了一段内存，还没来得及挂钩子函数的时候就收到了一个取消请求，如果立即响应这个取消请求就会导致内存泄漏。而挂载钩子函数的宏 pthread_cleanup_push 不是取消点，所以会推迟这个取消请求继续工作。等它把钩子函数挂载完毕之后继续运行来到 open(2) 函数，由于 open(2) 函数时有效的取消点，所以响应了这个取消请求，线程被取消并且通过钩子函数释放了上面 malloc(3) 所申请的空间。这就是推迟取消最明显的作用。</p><p>pthread_setcancelstate(3) 函数的作用就是修改线程的可取消状态，可以将线程设置为可取消的或不可取消的。</p><p>pthread_setcanceltype(3) 函数用来修改取消类型，也就是可以选择 异步 cancel 和 推迟 cancel。</p><p>pthread_testcancel(3) 函数的作用是人为放置取消点。假如某个线程一启动就疯狂的做数学运算10分钟，没有调用任何函数，则这个线程无法响应取消，为了使这个线程可以响应取消就可以通过这个函数人为放置取消点。</p><h3 id="1-3-1-线程和信号"><a href="#1-3-1-线程和信号" class="headerlink" title="1.3.1 线程和信号"></a>1.3.1 线程和信号</h3><p><img src="./thread_01.png" alt=""><br>图1 线程级别的信号位图</p><p>在前面讨论信号的博文中，LZ 给大家画过一张信号处理过程的草图，在那幅图中简单的把一个线程的标准信号画成了两个位图。而实际上每个线程级别都持有一个 mask 位图和一个 padding 位图，每个进程级别持有一个 padding 位图而没有 mask 位图。从内核态回到用户态之前，当前线程先用自己的 mask 位图与进程级别的 padding 做按位与（&amp;）运算，如果有信号就要去处理；然后再用自己的 mask 位图与自己的 padding 位图做按位与运算，再处理相应的信号。</p><p>所以其实是哪个线程被调度，就由哪个线程响应进程级别的信号。</p><p>由此可见，线程之间也是可以互相发信号的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_kill - send a signal to a thread</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>pthread_kill(3) 函数的作用就是在线程阶段发信号，thread 表示给哪个线程发送信号，sig 是发送哪个信号。</p><p>由于这个函数使用起来很简单，这里 LZ 就不把栗子贴出来了，大家自己动手写写试试吧。</p><p>pthread_sigmask(3) 函数的作用时人为的干预线程级别的 mask 位图。与 sigsetmask(3) 函数很像，大家自己动手试试吧。</p><h3 id="1-3-2-线程和-fork"><a href="#1-3-2-线程和-fork" class="headerlink" title="1.3.2 线程和 fork"></a>1.3.2 线程和 fork</h3><p>这一小节主要说的是 fork(2) 在不同平台上实现有歧义。</p><p>在fork的发展过程中主要有两大阵营，一大阵营使用写时拷贝技术，另一大阵营使用类似 vfork(2) 的策略。</p><p>这两种策略在前面我们讨论进程关系的博文中都讨论过，感兴趣的童鞋可以自己看看书上的描述，这里就不做太多的介绍了。</p><h3 id="1-3-3-线程和-I-O"><a href="#1-3-3-线程和-I-O" class="headerlink" title="1.3.3 线程和 I/O"></a>1.3.3 线程和 I/O</h3><p>这一小节主要就是介绍了下 pread(2) 和 pwrite(2) 函数，这两个函数实际当中用得并不多，感兴趣的童鞋自己看看书上的介绍或者看看 man 手册里的说明吧，这里不做过多的讨论了。如果有什么问题可以在评论中留言。</p><p>到这里 POSIX 标准的线程就介绍完了。*nix 平台线程的标准不只有 POSIX 一家，还有像 OpenMP 等标准也定义了不同的线程实现方式。</p><h3 id="1-3-4-OpenMP-标准"><a href="#1-3-4-OpenMP-标准" class="headerlink" title="1.3.4 OpenMP 标准"></a>1.3.4 OpenMP 标准</h3><p>我们使用 OpenMP 标准写一个 Hello World 程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel sections</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]:Hello\n"</span>,omp_get_thread_num());</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]:World\n"</span>,omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenMP 标准的多线程就是使用 # 这种预处理标签实现的，使用 GCC 编译的时候需要加 -fopenmp 参数。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">make</span> hello</span><br><span class="line"><span class="keyword">cc</span> -fopenmp -Wall    hello.<span class="keyword">c</span>   -<span class="keyword">o</span> hello</span><br><span class="line">$ ./hello</span><br><span class="line">[<span class="number">0</span>]:Hello</span><br><span class="line">[<span class="number">1</span>]:World</span><br><span class="line">$ ./hello</span><br><span class="line">[<span class="number">1</span>]:World</span><br><span class="line">[<span class="number">0</span>]:Hello</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>从上面的运行结果可以看出来，线程已经创建，并且已经发生了竞争。</p><p>GCC 从 4.0 以上的版本开始支持 OpenMP 标准。</p><p>由于 OpenMP 标准不是 《APUE》里面介绍的，所以我们这里就不做过多的探讨了，感兴趣的小伙伴们可以去 <a href="http://www.openmp.org" target="_blank" rel="noopener">http://www.openmp.org</a> 了解更多内容</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级IO</title>
      <link href="2020/12/16/apue-9/"/>
      <url>2020/12/16/apue-9/</url>
      
        <content type="html"><![CDATA[<h1 id="高级IO"><a href="#高级IO" class="headerlink" title="高级IO"></a>高级IO</h1><p>非阻塞IO – 阻塞IO<br>补充： 有限状态机编程</p><ol><li>非阻塞io</li><li>io多路转接（文件描述符的监视）</li><li>其他读写函数</li><li>存储映射io</li><li>文件锁</li></ol><h2 id="1-1-非阻塞-I-O"><a href="#1-1-非阻塞-I-O" class="headerlink" title="1.1 非阻塞 I/O"></a>1.1 非阻塞 I/O</h2><blockquote><p>非阻塞本身非常容易，对比阻塞来讲，就是不再死等。能做就做，不能做就退出。</p></blockquote><p>高级 IO 部分有个很重要的概念是：非阻塞 I/O</p><p>在14章之前，我们讨论的所有函数都是阻塞的函数，例如 read(2) 函数读取设备时，设备中如果没有充足的数据，那么 read(2) 函数就会阻塞等待，直到有数据可读再返回。</p><p>当 IO 操作时出现了错误的时候，我们之前在讨论信号的博文中提到过会出现假错的情况。</p><p>那么从学了非阻塞 I/O 为止我们一共遇到了两种假错的情况：</p><p>EINTR：被信号打断，阻塞时会遇到。</p><p>EAGAIN：非阻塞形式操作失败。</p><p>遇到这两种假错的时候我们需要重新再操作一次，所以通常对假错的判断是放在循环中的。</p><p>例如 read(2) 函数使用非阻塞方式读取数据时，如果没有读取到数据，errno 为 EAGAIN，此时并不是说设备有问题或读取失败，只是表明采用的是非阻塞方式读取而已。</p><p>阻塞与非阻塞是使用的同一套函数，flags 特殊要求指定为 O_NONBLOCK 就可以了。</p><p>下面我们举个小栗子：（伪代码）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"/etc/service"</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line"><span class="comment">/* if error */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">read</span>(fd, buf, BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EAGAIN == errno) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        perror(<span class="string">"read()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do sth...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的小栗子， 首先在 open(2) 的时候使用特殊要求 O_NONBLOCK 指定以非阻塞形式打开文件。</p><p>当 read(2) 发生错误时要判断是否为假错，如果发生了假错就再试一次，如果是真错就做相应的异常处理。</p><h2 id="1-2-数据中继"><a href="#1-2-数据中继" class="headerlink" title="1.2 数据中继"></a>1.2 数据中继</h2><blockquote><p>假设有正在打开的两个设备，两个设备之间进行数据交换。专业的叫法可以唤做 数据中继</p></blockquote><p>  rl-wr-rr-wl 读左写右读右写左；（单个进程，单个线程干活场景， 循环一圈的话，相当于四个工作）<br>  那假设用阻塞来实现，会遇到什么问题呢？比如读左边的设备，但是设备上一直没有数据出现。如果用阻塞的机制，那么一定会卡在 读左的动作上， 假设右边不断有其他数据来源到来，那么先去读右再去写左，这个时候是一直没有做的。 结果你一直在读左，左边一直没有数据。就没有办法去读右写左了。所以可能导致右边的数据已经溢出了，但左边还一直是空着，而程序一直卡在左边的情况。如果是一个人或者一个任务（一个任务包括一个进程也好，一个线程也好）来干活。这个任务可以是一个线程去做，也可以是一个进程去做。总而言之，这个任务没有协同操作，就一个人来完成。</p><p>  其实可以把任务拆分为两个任务，第一个任务来负责读左，并且写右。 第二个任务读右并且写左。这是两个进程在通信也好，两个线程也好。这种方式解决问题的几率就更大。那边有数据，那个分支就先走。</p><ul><li>域名拦截</li></ul><blockquote><p>中介服务获取用户输入地址，中间插入广告页。而后拿真是请求去访问目标服务器，再返回给客户端。起到一个中介转发的服务。像这种拦截的服务都是中继模型的放大。</p></blockquote><blockquote><p>当同时有两万对设备在通信，作为一个server端可能会比较忙。fork子进程，每个子进程负责100对。当然要先确定自己能fork出来这么多子进程。考虑fork开销大，改成pthread，创建出来线程，每个线程负责若干对。</p></blockquote><p>其实这种机制，包括前面写的很多程序.慢慢滚雪球，最终变为一个工程。比如上面这种机制就能发展成负载均衡。之所以做不出来，在于外围知识不够。比如负载均衡需要对集群的概念有了解，比如<br>之前讲的流控，可以联系到解码器是如何实现的。比如一个mp3文件的头部如何去读取。用c来监视web上面的一些内容，做这些是需要理解web服务器是如何相应的，是需要理解http1.0 http1.1的语法。这都是周边知识的确实。apue讲的是机制，进程，线程，信号包括后面的进程间通信。</p><h2 id="1-3-有限状态机"><a href="#1-3-有限状态机" class="headerlink" title="1.3 有限状态机"></a>1.3 有限状态机</h2><h3 id="1-3-1-复杂流程与简单流程"><a href="#1-3-1-复杂流程与简单流程" class="headerlink" title="1.3.1 复杂流程与简单流程"></a>1.3.1 复杂流程与简单流程</h3><p>简单流程： 自然流程是结构化的</p><p>复杂流程： 自然流程不是结构化的</p><p>什么是自然流程： 作为人类来讲，解决问题最直观的思路</p><p>大家先考虑一个问题：把大象放到冰箱里需要几步？</p><p>1）打开冰箱门；</p><p>2）把大象放进去；</p><p>3）关闭冰箱门；</p><p>这就是解决这个问题的自然流程。</p><p><img src="./sio_01.png" alt=""><br>图1 简单流程与复杂流程</p><p>把一个问题的解决步骤（自然流程）摆出来发现是结构化的流程就是简单流程，如果不是结构化的流程就是复杂流程。所有的网络应用和需要与人交互的流程都是复杂流程。</p><p>结构化的流程就是作为人类的本能解决问题的思路。</p><p>在之前的博文中 LZ 提到过一个“口令随机校验”的策略大家还记得吗？就是要求用户必须连续两次输入正确的密码才认为校验通过。就算是这样小的模块也不会用一个单纯的顺序选择流程把它完成，它一定是一个非结构化的流程。</p><p>有限状态机就是程序设计的一种思路而已，大家刚开始接触觉得难以理解，那是因为还没有习惯这种设计思路。我们为什么觉得像原先那种流程化的程序设计思路好用？那是因为被虐惯了，你曾经被迫习惯用计算机的思路来考虑问题而不是用作为人解决问题的本能步骤来考虑问题。有限状态机就是让你以作为人的本能的解决问题的方式来解决问题，当你习惯了有限状态机的设计思想之后就不觉得这是什么难以理解的东西了。</p><p>有限状态机被设计出来的目的就是为了解决复杂流程的问题，所以更何况是简单流程的问题也一样能够轻松的解决。</p><p>作为程序猿最怕的是什么？</p><p>恐怕最怕的就是需求变更了吧。</p><p>为什么要使用有限状态机的设计思路呢？因为它能帮助我们从容的应对需求变更。</p><p>使用有限状态机编程的程序在面对需求变更的时候往往仅需要修改几条 case 语句就可以了，而没有使用有限状态机编程的程序面对需求变更往往要把大段的代码推倒重来。</p><p>所以如果你掌握了有限状态机的编程思想，那么在很多情况下都可以相对轻松的解决问题，而且程序具有较好强的健壮性。</p><p>说了这么多废话，有限状态机到底是什么呢？</p><p>使用有限状态机首先要把程序的需求分析出来（废话，用什么编程都得先分析需求），然后把程序中出现的各种状态抽象出来制作成一张状态机流程图，然后根据这个流程图把程序的框架搭建出来，接下来就是添枝加叶了。</p><p>下面我们通过一个栗子来说明有限状态机的设计思想。</p><p>假如有如下需求：从设备 tty11 读取输入并输出到 tty12 上，同样从 tyy12 读取输入并输出到 tty11 上。</p><p>首先我们把它的各种状态抽象出来画成一幅图。</p><p><img src="./sio_02.png" alt=""><br>图2 有限状态机</p><p>每个状态画成一个圆形节点，每个节点延伸出来有多少条线就表示有多少种可能性。</p><p>这些节点拿到我们的程序中就变成了一条条 case 语句，下面我们看看使用代码如何实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE        1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY1        <span class="meta-string">"/dev/tty11"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY2        <span class="meta-string">"/dev/tty12"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态机的各种状态 */</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    STATE_R=<span class="number">1</span>,</span><br><span class="line">    STATE_W,</span><br><span class="line">    STATE_Ex,</span><br><span class="line">    STATE_T</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态机，根据不同的需求设计不同的成员 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> state; <span class="comment">// 状态机当前的状态</span></span><br><span class="line">    <span class="keyword">int</span> sfd; <span class="comment">// 读取的来源文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> dfd; <span class="comment">// 写入的目标文件描述符</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE]; <span class="comment">// 缓冲</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// 一次读取到的实际数据量</span></span><br><span class="line">    <span class="keyword">int</span> pos; <span class="comment">// buf 的偏移量，用于记录坚持写够 n 个字节时每次循环写到了哪里</span></span><br><span class="line">    <span class="keyword">char</span> *errstr; <span class="comment">// 错误消息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态机驱动 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fsm_driver</span><span class="params">(struct fsm_st *fsm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(fsm-&gt;state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_R: <span class="comment">// 读态</span></span><br><span class="line">            fsm-&gt;len = <span class="built_in">read</span>(fsm-&gt;sfd,fsm-&gt;buf,BUFSIZE);</span><br><span class="line">            <span class="keyword">if</span>(fsm-&gt;len == <span class="number">0</span>) <span class="comment">// 读到了文件末尾，将状态机推向 T态</span></span><br><span class="line">                fsm-&gt;state = STATE_T;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fsm-&gt;len &lt; <span class="number">0</span>) <span class="comment">// 读取出现异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN) <span class="comment">// 如果是假错就推到 读态，重新读一次</span></span><br><span class="line">                    fsm-&gt;state = STATE_R;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果是真错就推到 异常态</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"read()"</span>;</span><br><span class="line">                    fsm-&gt;state = STATE_Ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 成功读取到了数据，将状态机推到 写态</span></span><br><span class="line">            &#123;</span><br><span class="line">                fsm-&gt;pos = <span class="number">0</span>;</span><br><span class="line">                fsm-&gt;state = STATE_W;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_W: <span class="comment">// 写态</span></span><br><span class="line">            ret = <span class="built_in">write</span>(fsm-&gt;dfd,fsm-&gt;buf+fsm-&gt;pos,fsm-&gt;len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) <span class="comment">// 写入出现异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN) <span class="comment">// 如果是假错就再次推到 写态，重新再写入一次</span></span><br><span class="line">                    fsm-&gt;state = STATE_W;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果是真错就推到 异常态</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"write()"</span>;</span><br><span class="line">                    fsm-&gt;state = STATE_Ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 成功写入了数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                fsm-&gt;pos += ret;</span><br><span class="line">                fsm-&gt;len -= ret;</span><br><span class="line">                <span class="keyword">if</span>(fsm-&gt;len == <span class="number">0</span>) <span class="comment">// 如果将读到的数据完全写出去了就将状态机推向 读态，开始下一轮读取</span></span><br><span class="line">                    fsm-&gt;state = STATE_R;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果没有将读到的数据完全写出去，那么状态机依然推到 写态，下次继续写入没写完的数据，实现“坚持写够 n 个字节”</span></span><br><span class="line">                    fsm-&gt;state = STATE_W;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_Ex: <span class="comment">// 异常态，打印异常并将状态机推到 T态</span></span><br><span class="line">            perror(fsm-&gt;errstr);</span><br><span class="line">            fsm-&gt;state = STATE_T;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_T: <span class="comment">// 结束态，在这个例子中结束态没有什么需要做的事情，所以空着</span></span><br><span class="line">            <span class="comment">/*do sth */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 程序很可能发生了溢出等不可预料的情况，为了避免异常扩大直接自杀</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推动状态机 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1,<span class="keyword">int</span> fd2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1_save,fd2_save;</span><br><span class="line">    <span class="comment">// 因为是读 tty1 写 tty2；读 tty2 写 tty1，所以这里的两个状态机直接取名为 fsm12 和 fsm21</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>,<span class="title">fsm21</span>;</span></span><br><span class="line"></span><br><span class="line">    fd1_save = fcntl(fd1,F_GETFL);</span><br><span class="line">    <span class="comment">// 使用状态机操作 IO 一般都采用非阻塞的形式，避免状态机被阻塞</span></span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK);</span><br><span class="line">    fd2_save = fcntl(fd2,F_GETFL);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在启动状态机之前将状态机推向 读态</span></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    <span class="comment">// 设置状态机中读写的来源和目标，这样状态机的读写接口就统一了。在状态机里面不用管到底是 读tty1 写tty2 还是 读tty2 写tty1 了，它只需要知道是 读src 写des 就可以了。</span></span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始推状态机，只要不是 T态 就一直推</span></span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用状态机驱动函数，状态机开始工作</span></span><br><span class="line">        fsm_driver(&amp;fsm12);</span><br><span class="line">        fsm_driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这里忘记将设备 tty1 以非阻塞的形式打开也没关系，因为推动状态机之前会重新设定文件描述符为非阻塞形式</span></span><br><span class="line">    fd1 = <span class="built_in">open</span>(TTY1,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd1,<span class="string">"TTY1\n"</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    fd2 = <span class="built_in">open</span>(TTY2,O_RDWR|O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd2,<span class="string">"TTY2\n"</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    relay(fd1,fd2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./relay</span><br><span class="line"></span><br><span class="line">ctrl+alt+F11</span><br></pre></td></tr></table></figure><p>大家先把这段代码读明白，下面我们还要用这段代码来修改示例。</p><p>如果只看上面的代码是很难理解程序是做什么的，因为都是一组一组的 case 语句，不容易理解。所以一般使用有限状态机开发的程序都会与图或相关的文档配套发行，看了图再结合代码就很容易看出来代码的目的了。</p><p>大家要对比着上面的图来看代码，这样思路就很清晰了。</p><p>使用状态机之前需要使两个待进行数据中继的文件描述符必须都是 O_NONBLOCK 的。</p><p>整个状态机中都没有使用循环来读写数据，因为状态机能确保每一种状态都是职责单一的，出现其它的任何状况的时候只要推动状态机问题就可以解决了。</p><p>所以这样的程序可维护性是不是高了很多？如果出现了需求变更，只需要简单的修改几条 case 语句就可以了，而不需要大段大段的修改代码了。</p><p>大家要多使用状态机的设计思想来写程序才能加深对这种设计思想的掌握程度。</p><h3 id="1-3-2-中继引擎库"><a href="#1-3-2-中继引擎库" class="headerlink" title="1.3.2 中继引擎库"></a>1.3.2 中继引擎库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 见 relayer 文件夹</span></span><br></pre></td></tr></table></figure><p>已完成中继引擎中的 <code>rel_addjob</code> 方法添加进去任务，并且使用状态机来管理当前非空任务的状态。只要当前这个任务是 <code>STATE_RUNNING</code> 态，那就推里面的两个状态机。当前就是一个server的状态，如果该程序达到最大的负载量, 比如 <code>REL_JOBMAX</code>达到上限，当前有10000对，20000个文件描述符在两秒做数据中继的话，那么看单机是否能承载，如果不能，采用集群，使下面的多个主机来帮助完成这个任务。即使没有多个主机，也能创建子进程或者线程，每个进程或者线程负责多少个状态机的推动。</p><p>该程序并不是一个重负载的程序，它最多算一个IO密集型的任务。一般IO密集的程序都不是负载重的程序，负载重，io又密集的话，这程序很难控制。</p><p>为什么说这个程序是io密集，它是获取内容然后进行传输。为什么不是重负载，是ftp传输快，还是手动打字快？肯定是FTP快，即使数量多，也是io密集型任务。（这句不是很懂，先留着，以后再理解）。</p><p>而io密集型任务，其实绝大多数都在空闲，这个程序的问题是，依然没有完成行为监视的部分，还是盲推。当启动程序时，cpu一下占满一个核，cpu使用率满栈。 没有内容的时候，也是在不停的推动试探。程序大多数时间盲在 <code>EAGAIN</code>。 比如现在初始状态是一个读态，如果没有内容的话，是没办法读的。现在的read返回的就是一个假错。然后在一个while循环中继续 碰到假错 推动到read，以此循环。对于一个io密集型的任务就可以使用io多路转接。如下</p><h2 id="1-4-I-O-多路转接"><a href="#1-4-I-O-多路转接" class="headerlink" title="1.4 I/O 多路转接"></a>1.4 I/O 多路转接</h2><blockquote><p>I/O 多路转接， 说白了就是监视文件描述符的行为。 这个技术针对io密集型模型的解决方案。当当前文件描述符发生感兴趣的行为时，我才去做后续操作。这个感兴趣的行为可以有相关的机制去订阅。</p></blockquote><p>上面那个 读tty11 写tty12，读tty12 写tty11 的栗子是采用忙等的方式实现的，I/O 多路转接这个小节讨论的就是怎么把上面那个栗子修改为非忙等的模式。</p><p>有些时候就是这样的，读取多个文件（一般是设备）的时候不能使用阻塞方式，因为一个阻塞了其它的就没法读了；而非阻塞方式如果采用忙等的形式又得不偿失，CPU满栈。你想想比如 telnet 服务在接收用户的命令的时候是不是这种情况呢？</p><p>对于处理这样的需求，Linux 系统为我们提供了 3 种方案：select(2)、poll(2) 和 epoll(7)，这些方案提供的函数可以同时监视多个文件描述符，当它们的状态没有变化时阻塞等待，当它们的状态发生变化时会给我们一个通知让我们继续处理任务，下面我们一个一个的介绍它们。</p><p><strong>select poll epoll</strong></p><p>共同点： 它们三个完成的任务是一致，就是io多路转接，实现文件描述符的监视。</p><p>区别</p><ul><li>select(2) 的优点是足够老，各个平台都支持它，这也是它相对于 poll(2) 唯一的优点。<br>劣势是本身接口设计的有缺陷，传参部位有问题。</li><li>poll跟 select 在监视文件描述符的组织思路是完全不一致的；select是以事件为单位组织文件描述符，poll以文件描述符来组织事件。这两个函数的出发点和组织形式是不太一致的。poll也是可以移植的。</li><li>很多平台依然觉得poll的效率不够高，所以以poll为基础上，在各个平台上开发的方言。epoll就是linux系统在poll的基础上做的方言，来完成文件描述符的监视。实际上poll和epoll的思路非常贴近，组织形式也一样。只不过换成poll需要用户自己维护一些内容，epoll是企图简化用户维护的这块内容。把poll在用户角度能看到的一些内容进行了封装组成了epoll的机制，所以epoll是没办法移植的。select poll是可移植的，select太古老。poll均衡三者的比较之中是相对不错的。</li></ul><h3 id="1-4-1-select-2"><a href="#1-4-1-select-2" class="headerlink" title="1.4.1 select(2)"></a>1.4.1 select(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select,  FD_CLR,  FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to POSIX.1-2001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">          fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 删除 set 中的 fd 这个文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 测试文件描述符 fd 是否在 set 集合中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 将文件描述符 fd 添加到 set 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 清空一个文件描述符集合</span></span><br></pre></td></tr></table></figure><p>select(2) 的优点是足够老，各个平台都支持它，这也是它相对于 poll(2) 唯一的优点。<br>劣势是本身接口设计的有缺陷，传参不稳定。</p><p>select(2)的缺陷，</p><ul><li>select函数布置监视任务的位置，也就是三个集合，分别为 readfds, writefds, exceptfds。但是它所监视结果所存在的位置也是这三个集合。举个例子，比如现在往 readfds放了10个文件描述符，writefds放10个，exceptfds放10个，要监视30个文件描述符不同的行为。这个时候，假如读集readfds有一个文件描述符可读了，那select函数一下就返回了。返回值为1.然后 readfds存放的就变成了可读的文件描述符了，而 writefds，exceptfds等两个集合则被清空了。监视现场和监视结果用的是一块内存空间，没有const修饰；</li><li>第一个参数nfds，当前监视文件描述符最大文件描述符再加1，在一个进程当中，能打开的文件描述符实际上是能够更改的。(ulimit -a)。nfds是int类型的，如果更改之后的打开文件描述符的大小理论上有超过有符号整型的大小风险。</li><li>select监视的事件太单一，readfds， writefds，和 exceptfds 除了读和写 就是 异常。异常包含的层面就太多了，包括套接字相关的一些东西 全部都算是异常的结果。</li></ul><p>返回值：<br>成功返回，文件描述符个数，现在发生你感兴趣行为的文件描述符个数。而这些发生感兴趣行为的文件描述符依然放在 读集， 写集， 以及异常集当中。<br>失败，返回值为-1，</p><p>参数列表：</p><p>　　nfds：当前监视文件描述符里面最大的文件描述符 + 1；<br>        （比如当前监视的文件描述符是 3，5，7，9。那这里就写10）</p><p>　　readfds：需要监视的输入文件描述符集合， 读集；</p><p>　　writefds：需要监视的输出文件描述符集合， 写集；</p><p>　　exceptfds：需要监视的会发生异常的文件描述符集合， 异常集；</p><p>　　timeout：超时设置，等待的超时时间，如果时间超时依然没有文件描述符状态发生变化那么就返回。设置为 0 会立即返回。<br>设置为 NULL 则一直阻塞等待，不会超时，直到发生 注册事件才会返回结果。</p><p>还记得我们之前提到过使用 select(2) 函数替代 sleep(3) 函数吗？</p><p>我们看到参数中的文件描述符集合是 fd_set 类型的，那么怎么把我们的 int 类型的文件描述符添加到 fd_set 当中去呢？</p><p>下面我们重构上面的栗子，通过把它修改成非忙等的形式来看看 select 是如何使用的。代码没有太大的区别，所以只贴出有差异的部分。完整版看 <code>relay_select.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    STATE_R=<span class="number">1</span>,</span><br><span class="line">    STATE_W,</span><br><span class="line">    STATE_AUTO, <span class="comment">// 添加这个值是为了起到分水岭的作用，小于这个值的时候才需要使用 select(2) 监视</span></span><br><span class="line">    STATE_Ex,</span><br><span class="line">    STATE_T</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1,<span class="keyword">int</span> fd2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1_save,fd2_save;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>,<span class="title">fsm21</span>;</span></span><br><span class="line">    fd_set rset,wset; <span class="comment">// 读写文件描述符集合</span></span><br><span class="line"></span><br><span class="line">    fd1_save = fcntl(fd1,F_GETFL);</span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK);</span><br><span class="line">    fd2_save = fcntl(fd2,F_GETFL);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//布置监视任务</span></span><br><span class="line">        FD_ZERO(&amp;rset);</span><br><span class="line">        FD_ZERO(&amp;wset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读态监视输入文件描述符；写态监视输出文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_R)</span><br><span class="line">            FD_SET(fsm12.sfd,&amp;rset);</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_W)</span><br><span class="line">            FD_SET(fsm12.dfd,&amp;wset);</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_R)</span><br><span class="line">            FD_SET(fsm21.sfd,&amp;rset);</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_W)</span><br><span class="line">            FD_SET(fsm21.dfd,&amp;wset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO)<span class="comment">// 异常态和T态就不需要 监听了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 以阻塞形式监视</span></span><br><span class="line">            <span class="keyword">if</span>(select(<span class="built_in">max</span>(fd1,fd2)+<span class="number">1</span>,&amp;rset,&amp;wset,<span class="literal">NULL</span>,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 这个continue 跳的是大圈。 正因为select 的三个集 的 存放现场和 反馈现场用的是同一块内存空间。所以 需要跳到外围 去重置 三个集合的内存空间</span></span><br><span class="line">                perror(<span class="string">"select()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看监视结果</span></span><br><span class="line">        <span class="keyword">if</span>( FD_ISSET(fd1,&amp;rset) || FD_ISSET(fd2,&amp;wset) || fsm12.state &gt; STATE_AUTO) <span class="comment">// 除了有感兴趣行为之外， 异常态和T态也需要重新推状态机</span></span><br><span class="line">            fsm_driver(&amp;fsm12);</span><br><span class="line">        <span class="keyword">if</span>( FD_ISSET(fd2,&amp;rset) || FD_ISSET(fd1,&amp;wset) || fsm21.state &gt; STATE_AUTO) <span class="comment">// 除了有感兴趣行为之外， 异常态和T态也需要重新推状态机</span></span><br><span class="line">            fsm_driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的栗子中，无论设备中是否有数据供我们读取我们都不停的推动状态机，所以导致出现了忙等的现象。</p><p>而在这个栗子中，我们在推状态机之前使用 select(2) 函数对文件描述符进行监视，如果文件描述状态没有发生变化就阻塞等待；而哪个状态机的文件描述符发生了变化就推动哪个状态机，这样就将查询法的实现改为通知法的实现了。是不是很简单呢？</p><h3 id="1-4-2-poll"><a href="#1-4-2-poll" class="headerlink" title="1.4.2 poll"></a>1.4.2 poll</h3><p>poll(2) 出现的时间没有 select(2) 那么悠久，所以在可移植性上来说没有 select(2) 函数那么好，但是绝大多数主流 *nix 平台都支持 poll(2) 函数，它比 select(2) 要优秀很多，下面我们来了解下它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll - wait for some event on a file descriptor</span></span><br><span class="line"><span class="comment">// 在文件描述符的基础上 等待一些事件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* 需要监视的文件描述符 */</span></span><br><span class="line">    short events;     <span class="comment">/* 要监视的事件 */</span></span><br><span class="line">    short revents;    <span class="comment">/* 该文件描述符发生了的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 参数列表：</p><p>　　fds：实际上是一个数组的首地址，因为 poll(2) 可以帮助我们监视多个文件描述符，而一个文件描述放到一个 struct pollfd 结构体中，多个文件描述符就需要一个数组来存储了。</p><p>　　nfds：fds 这个数组的长度。在参数列表中使用数组首地址 + 长度的做法还是比较常见的。</p><p>　　timeout：阻塞等待的超时时间。传入 -1 则始终阻塞，不超时。0 指非阻塞</p><p>结构体中的事件可以指定下面七种事件，同时监视多个事件可以使用按位或（|）添加：</p><table><thead><tr><th align="left">事件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">POLLIN</td><td align="center">文件描述符可读</td></tr><tr><td align="left">POLLPRI</td><td align="center">可以非阻塞的读高优先级的数据</td></tr><tr><td align="left">POLLOUT</td><td align="center">文件描述符可写</td></tr><tr><td align="left">POLLRDHUP</td><td align="center">流式套接字连接点关闭，或者关闭写半连接。</td></tr><tr><td align="left">POLLERR</td><td align="center">已出错</td></tr><tr><td align="left">POLLHUP</td><td align="center">已挂断（一般指设备）</td></tr><tr><td align="left">POLLNVAL</td><td align="center">参数非法</td></tr></tbody></table><p>表1 poll(2) 可以监视的 7 种事件</p><p> 使用 poll(2) 的步骤也很简单：</p><p>　　1）首先通过 struct pollfd 结构体中的 events 成员布置监视任务；</p><p>　　2）然后使用 poll(2) 函数进行阻塞的监视；</p><p>　　3）当从 poll(2) 函数返回时就可以通过 struct polfd 结构体中的 revents 成员与上面的 7 个宏中被我们选出来监视的宏进行按位与（&amp;）操作了，只要结果不为 1 就认为触发了该事件。</p><p>好了，这 3 步就是 poll(2) 函数的使用方法，简单吧。</p><p>下面我们修改一下上面的栗子，把上面用 select(2) 实现的部分修改为用 poll(2) 来实现。没有改过的地方就不贴出来了，其实也只有 relay() 函数被修改了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1,<span class="keyword">int</span> fd2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1_save,fd2_save;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>,<span class="title">fsm21</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>[2];</span> <span class="comment">// 一共监视两个文件描述符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fd1_save = fcntl(fd1,F_GETFL);</span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK);</span><br><span class="line">    fd2_save = fcntl(fd2,F_GETFL);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line">    pfd[<span class="number">0</span>].fd = fd1;</span><br><span class="line">    pfd[<span class="number">1</span>].fd = fd2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 布置监视任务</span></span><br><span class="line">        pfd[<span class="number">0</span>].events = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_R)</span><br><span class="line">            pfd[<span class="number">0</span>].events |= POLLIN; <span class="comment">// 第一个文件描述符可读</span></span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_W)</span><br><span class="line">            pfd[<span class="number">0</span>].events |= POLLOUT; <span class="comment">// 第一个文件描述符可写</span></span><br><span class="line"></span><br><span class="line">        pfd[<span class="number">1</span>].events = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_W)</span><br><span class="line">            pfd[<span class="number">1</span>].events |= POLLOUT; <span class="comment">// 第二个文件描述符可读</span></span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_R)</span><br><span class="line">            pfd[<span class="number">1</span>].events |= POLLIN; <span class="comment">// 第二个文件描述符可写</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要是可读写状态就进行监视</span></span><br><span class="line">        <span class="keyword">if</span>(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞监视</span></span><br><span class="line">            <span class="keyword">while</span>(poll(pfd,<span class="number">2</span>,<span class="number">-1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"poll()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看监视结果</span></span><br><span class="line">        <span class="keyword">if</span>( pfd[<span class="number">0</span>].revents &amp; POLLIN || \</span><br><span class="line">            pfd[<span class="number">1</span>].revents &amp; POLLOUT || \</span><br><span class="line">            fsm12.state &gt; STATE_AUTO)</span><br><span class="line">            fsm_driver(&amp;fsm12); <span class="comment">// 推状态机</span></span><br><span class="line">        <span class="keyword">if</span>( pfd[<span class="number">1</span>].revents &amp; POLLIN || \</span><br><span class="line">            pfd[<span class="number">0</span>].revents &amp; POLLOUT || \</span><br><span class="line">            fsm21.state &gt; STATE_AUTO)</span><br><span class="line">            fsm_driver(&amp;fsm21); <span class="comment">// 推状态机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-epoll"><a href="#1-4-3-epoll" class="headerlink" title="1.4.3 epoll"></a>1.4.3 epoll</h3><p>epoll(7) 不是一个函数，它在 man 手册的第 7 章里，它是 Linux 为我们提供的“加强版 poll(2)”，既然是加强版，那么一定有超越 poll(2) 的地方，下面就聊一聊 epoll(7)。 </p><p>在使用 poll(2) 的时候用户需要管理一个 struct pollfd 结构体或它的结构体数组，epoll(7) 则使内核为我们管理了这个结构体数组，我们只需要通过 epoll_create(2) 返回的标识引用这个结构体即可。</p><h4 id="1-4-3-1-使用epoll的三个步骤"><a href="#1-4-3-1-使用epoll的三个步骤" class="headerlink" title="1.4.3.1 使用epoll的三个步骤"></a>1.4.3.1 使用epoll的三个步骤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_create - open an epoll file descriptor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>调用<code>epoll_create</code>创建epoll实例</li></ol><p>调用 epoll_create(2) 时最初 size 参数给传入多少，kernel 在建立数组的时候就是多少个元素。但是这种方式不好用，所以后来改进了，只要 size 随便传入一个正整数就可以了，内核不会再根据大家传入的 size 直接作为数组的长度了，因为内核是使用 hash 来管理要监视的文件描述符的。</p><p>返回值是 epfd，从这里也可以体现出 Linux 一切皆文件的设计思想。失败时返回 -1 并设置 errno。</p><p>得到了内核为我们管理的结构体数组标识之后，接下来就可以用  epoll_ctl(2) 函数布置监视任务了。</p><ol start="2"><li>调用<code>epoll_ctl</code>函数进行 epoll实例的设置</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// epoll_ctl - control interface for an epoll descriptor</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * epfd  epoll_create创建出来的epoll实例</span></span><br><span class="line"><span class="comment"> * op    能做什么， EPOLL_CTL_ADD ｜ EPOLL_CTL_MOD ｜ EPOLL_CTL_DEL</span></span><br><span class="line"><span class="comment"> * fd    文件描述符</span></span><br><span class="line"><span class="comment"> * event  op这个操作，针对的是 fd文件描述符的 哪个事件</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对 epfd 这个实例当中的 fd文件描述符 进行 EPOLL_CTL_ADD  行为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll 监视的事件，这些事件与 poll(2) 能监视的事件差不多，只是宏名前面加了个E */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* 用户数据，除了能保存文件描述符以外，还能让你保存一些其它有关数据，比如你这个文件描述符是嵌在一棵树上的，你在使用它的时候不知道它是树的哪个节点，则可以在布置监视任务的时候将相关的位置都保存下来。这个联合体成员就是 epoll 设计的精髓。 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>epoll_ctl(2) 的作用是要对 fd 增加或减少（op） 什么行为的监视（event）。成功返回0，失败返回 -1 并设置 errno。</p><p>op 参数可以使用下面三个宏来指定操作：</p><table><thead><tr><th align="left">宏</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">EPOLL_CTL_ADD</td><td align="center">增加要监视的文件描述符</td></tr><tr><td align="left">EPOLL_CTL_MOD</td><td align="center">更改目标文件描述符的事件</td></tr><tr><td align="left">EPOLL_CTL_DEL</td><td align="center">删除要监视的文件描述符，event 参数会被忽略，可以传入 NULL。</td></tr></tbody></table><p>表2 epoll_ctl(2) 函数 op 参数的选项</p><p>与 select(2) 和 poll(2) 一样， 布置完监视任务之后需要取监视结果，epoll(7) 策略使用 epoll_wait(2) 函数进行阻塞监视并返回监视结果。</p><ol start="3"><li>使用<code>epoll_wait</code>函数进行监视，并返回监视结果</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_wait  -  wait  for  an  I/O  event on an epoll file descriptor</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>参数列表：</p><p>　　epfd：要操作的 epoll 实例；</p><p>　　events + maxevents：共同指定了一个结构体数组，数组的起始位置和长度。其实每次使用 epoll_ctl(2) 函数添加一个文件描述符时相当于向内核为我们管理的数组中添加了一个成员，所以当我们使用同一个 struct epoll_event 变量操作多个文件描述符时，只需传入该变量的地址和操作了多少个文件描述符即可，大家看看下面的栗子就明白了。</p><p>　　timeout：超时等待的时间，设置为 -1 则始终阻塞监视，不超时。0 非阻塞</p><p>跟上面的栗子一样，LZ 只贴出来被修改了的 relay() 函数，其它部分不变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整代码看  io/adv/epoll/relay_epoll.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1,<span class="keyword">int</span> fd2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1_save,fd2_save;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>,<span class="title">fsm21</span>;</span></span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"epfd()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd1_save = fcntl(fd1,F_GETFL);</span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK);</span><br><span class="line">    fd2_save = fcntl(fd2,F_GETFL);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line">    ev.events = <span class="number">0</span>;</span><br><span class="line">    ev.data.fd = fd1;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,fd1,&amp;ev);</span><br><span class="line"></span><br><span class="line">    ev.events = <span class="number">0</span>;</span><br><span class="line">        ev.data.fd = fd2;</span><br><span class="line">        epoll_ctl(epfd,EPOLL_CTL_ADD,fd2,&amp;ev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 布置监视任务</span></span><br><span class="line"></span><br><span class="line">        ev.events = <span class="number">0</span>;</span><br><span class="line">        ev.data.fd = fd1;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_R)</span><br><span class="line">            ev.events |= EPOLLIN;</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_W)    </span><br><span class="line">            ev.events |= EPOLLOUT;</span><br><span class="line">        epoll_ctl(epfd,EPOLL_CTL_MOD,fd1,&amp;ev);</span><br><span class="line"></span><br><span class="line">        ev.events = <span class="number">0</span>;</span><br><span class="line">        ev.data.fd = fd2;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_W)</span><br><span class="line">            ev.events |= EPOLLOUT;</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_R)</span><br><span class="line">            ev.events |= EPOLLIN;</span><br><span class="line">        epoll_ctl(epfd,EPOLL_CTL_MOD,fd2,&amp;ev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监视</span></span><br><span class="line">        <span class="keyword">if</span>(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(epoll_wait(epfd,&amp;ev,<span class="number">1</span>,<span class="number">-1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"epoll_wait()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看监视结果</span></span><br><span class="line">        <span class="keyword">if</span>( ev.data.fd == fd1 &amp;&amp; ev.events &amp; EPOLLIN || \</span><br><span class="line">            ev.data.fd == fd2 &amp;&amp; ev.events &amp; EPOLLOUT || \</span><br><span class="line">            fsm12.state &gt; STATE_AUTO)</span><br><span class="line">            fsm_driver(&amp;fsm12);</span><br><span class="line">        <span class="keyword">if</span>( ev.data.fd == fd2 &amp;&amp; ev.events &amp; EPOLLIN || \</span><br><span class="line">            ev.data.fd == fd1 &amp;&amp; ev.events &amp; EPOLLOUT  || \</span><br><span class="line">            fsm21.state &gt; STATE_AUTO)</span><br><span class="line">            fsm_driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(fd1,F_SETFL,fd1_save);</span><br><span class="line">    fcntl(fd2,F_SETFL,fd2_save);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.记录锁 </p><p>记录锁就是用 fcntl(2) 函数创建一个锁文件，比较麻烦，感兴趣的童鞋可以自己看看书上的介绍，在这里 LZ 就不做介绍了，我们在最后会讨论两个方便的文件锁和锁文件。</p><p>5.异步 I/O</p><p>这部分主要是说信号驱动 IO，不是真正意义上的异步 IO。</p><p>异步 I/O 分为 System V 异步 I/O 和 BSD 异步 I/O，Linux 模仿的是后者，这里我们不过多讨论了，后面 LZ 在讨论内核的博文中会继续讨论异步。</p><h2 id="1-5-其他读写函数"><a href="#1-5-其他读写函数" class="headerlink" title="1.5 其他读写函数"></a>1.5 其他读写函数</h2><h3 id="readv-2-和-writev-2"><a href="#readv-2-和-writev-2" class="headerlink" title="readv(2) 和 writev(2)"></a>readv(2) 和 writev(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// readv,  writev  -  read  or write data into multiple buffers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>  *iov_base;    <span class="comment">/* 起始地址 */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;     <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个函数的作用就是对多个碎片的读写操作，将所有的小碎片写到文件中。</p><p>readv(2) 当没有连续的空间存储从 fd 读取或写入的数据时，将其存储在 iovcnt 个 iov 结构体中，writev(2) 的作用相同。iov 是结构体数组起始位置，iovcnt 是数组长度。</p><h3 id="1-5-1-readn-和-writen"><a href="#1-5-1-readn-和-writen" class="headerlink" title="1.5.1 readn() 和 writen()"></a>1.5.1 readn() 和 writen()</h3><p>这两个函数可以从本书（《APUE》第三版）的光盘中找，它们并不是什么标准库的函数，也不是系统调用，只是本书作者自己封装的函数，算是方言中的方言，作用是坚持写够 n 个字节，之前我们在讨论 IO 的博文中实现过类似的效果。</p><p>对了，天朝在引入这本书的时候貌似没有引入配套光盘，需要的童鞋可以自己去网上搜索一下。</p><h2 id="1-6-存储映射-I-O"><a href="#1-6-存储映射-I-O" class="headerlink" title="1.6 存储映射 I/O"></a>1.6 存储映射 I/O</h2><blockquote><p>把某一块内存，或者是说某一个文件的存储内容映射到当前进程空间里面来。你在当前进程空间中访问一段char型的内容就如同访问该块内存或者该文件一样。它能帮助我非常好用的共享内存，非常快的共享内存。</p></blockquote><p>存储映射 I/O 是十四章的小重点。</p><p>在 *nix 系统中分配内存的方法有好几种，不一定非得使用 free(3) 函数。</p><p>通过 mmap(2) 和 unmap(2) 函数可以实现一个实时的类似于 malloc(3) 和 free(3) 函数的效果，我们在前面的博文中提到过，malloc(3) 和 free(3) 实际上是以打白条的形式实现的，就是在你调用函数的时候并没有立即分配内存给你，而是在你真正使用内存的时候才分配给你的。</p><p>存储映射I/O说的就是将一个文件的一部分或全部映射到内存中，用户拿到的就是这段内存的起始位置，访问这个文件就相当于访问一个大字符串一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// mmap, munmap - map or unmap files or devices into memory</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * addr： 你把空间放到哪里，如果 addr 参数传入 NULL 则由 kernel 帮我们选择一块空间并使用返回值返回这段内存的首地址。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * length， 要把多长的内容映射进来</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * prot： 你想对映射过来的这块内存做什么操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * flag： 特殊标记，特殊要求           // 匿名映射</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * fd 文件描述符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * offset 偏移量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>; <span class="comment">// 解除映射</span></span><br></pre></td></tr></table></figure><p>mmap(2) 函数的作用是把 fd 这个文件从 offset 偏移位置开始把 length 字节个长度映射到 addr 这个内存位置上，如果 addr 参数传入 NULL 则由 kernel 帮我们选择一块空间并使用返回值返回这段内存的首地址。</p><p>prot 参数是操作权限，可以使用下表中的宏通过按位或（|）来组合指定</p><table><thead><tr><th align="left">宏</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">PROT_READ</td><td align="center">映射区可读</td></tr><tr><td align="left">PROT_WRITE</td><td align="center">映射区可写</td></tr><tr><td align="left">PROT_EXEC</td><td align="center">映射区可执行</td></tr><tr><td align="left">PROT_NONE</td><td align="center">映射区不可访问</td></tr></tbody></table><p>表3 mmap(2) 函数的 prot 参数可选项</p><p>映射区不可访问（PROT_NONE）的含义是如果我映射的内存中有一块已经有某些数据了，绝对不能让我的程序越界覆盖了，就可以把这段空间设置为映射区不可访问。</p><p>flags 参数是特殊要求，以下二者必选其一：</p><table><thead><tr><th align="left">宏</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">MAP_SHARED</td><td align="center">对映射区进行存储操作相当于对原来的文件进行写入，会改变原来文件的内容。</td></tr><tr><td align="left">MAP_PRIVATE</td><td align="center">当对映射区域进行存储操作时会创建一个私有副本，所有后来再对映射区的操作都相当于操作这个副本，而不影响原来的文件。</td></tr></tbody></table><p>表4 mmap(2) 函数的 flags 参数可选项</p><p>其它常用选项：</p><p>MAP_ANONYMOUS：不依赖于任何文件，映射出来的内存空间会被清 0，并且 fd 和 offset 参数会被忽略，通常我们在使用的时候会把 fd 设置为 -1。</p><p>用这个参数可以很容易的做出一个最简单最好用的在具有亲缘关系的进程之间的共享内存，比后面第15章我们要讨论的共享内存还好用。后面 LZ 会给出一个小栗子让大家看看这种方式如何使用。</p><p>mmap(2) 在成功的时候返回一个指针，会指向映射的内存区域的起始地址。失败时返回 MAP_FAILED 宏定义，其实是这样定义的：(void *) -1。</p><p>首先我们写一个栗子看看如何把一个文件映射到内存中访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME        <span class="meta-string">"/etc/services"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd,i;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(FNAME,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 stat(2) 获得文件大小</span></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd,&amp;statres) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fstat()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str = mmap(<span class="literal">NULL</span>,statres.st_size,PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(str == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件映射到内存之后文件描述符就可以关闭了，直接访问映射的内存就相当于访问文件了。</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; statres.st_size; i++) &#123;</span><br><span class="line">        <span class="comment">// 因为访问的是文本文件，所以可以把映射的内存看作是一个大字符串处理</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'a'</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"count = %d\n"</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用完了别忘了解除映射，不然会造成内存泄漏！</span></span><br><span class="line">    munmap(str,statres.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会统计 /etc/services 文件中包含多少个字符 ‘a’。</p><p>mmap(2) 的返回值是 <code>void*</code> 类型的，这是一种百搭的类型，在映射了不同的东西的情况下我们可以使用不同的指针来接收，这样就能用不同的方式访问这段内存空间了。上面这个文件是文本文件，所以我们可以使用 <code>char*</code> 来接收它的返回值，这样就将整个文件看作是一个大字符串来访问了。</p><p>这个还是比较常规的用法，下面我们看一下如何使用 mmap(2) 函数制作一个好用的共享内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父读子写</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里在 flags 中添加 MAP_ANONYMOUS，为制作共享内存做准备</span></span><br><span class="line">    str = mmap(<span class="literal">NULL</span>,MEMSIZE,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(str == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程，父子进程使用共享内存进行通信</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// 子进程向共享内存中写入数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str,<span class="string">"Hello!"</span>);</span><br><span class="line">        munmap(str,MEMSIZE); <span class="comment">// 注意，虽然共享内存是在 fork(2) 之前创建的，但是 fork(2) 的时候子进程也拷贝了一份，所以子进程使用完毕之后也要解除映射</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 父进程从共享内存中读取子进程写入的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 保障子进程先运行起来，因为就算父进程先运行了也会在这里阻塞等待</span></span><br><span class="line">        <span class="built_in">puts</span>(str); <span class="comment">// 把从共享内存中读取出来的数据打印出来</span></span><br><span class="line">        munmap(str,MEMSIZE); <span class="comment">// 不要忘记解除映射</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享内存是进程间通信的一种手段，就是在内存中开辟一块空间让多个进程之间可以共同访问这段空间，从而实现进程之间的数据交换。在后面讨论 IPC 的博文中我们还会详细介绍共享内存，不过用 mmap(2) 制作的共享内存比后面介绍的共享内存使用起来更简便一些。</p><p>大家自己运行一下这段代码，可以看到父进程打印出了子进程写入的“Hello”字符串，说明这段内存确实是在父子进程之间共享的。</p><p>大家在使用的时候不要忘记父子进程最后都要做解除映射的动作。</p><p>从这个栗子中我们也可以看出来，这种共享内存的方式只适合在具有亲缘关系的进程之间使用，没有亲缘关系的进程是无法获得指向同一个映射内存空间的指针的。</p><h2 id="1-7-文件锁"><a href="#1-7-文件锁" class="headerlink" title="1.7 文件锁"></a>1.7 文件锁</h2><blockquote><p>文件为何要锁，建立一个下载任务，首先建一个跟目标大小相似的空洞文件。然后分块去多线程并发。每个线程负责一块。可以当前写的这一块如何避免别人没有过来发生竞争。就需要把这块内容加锁。加锁之后写文件就没问题了。</p></blockquote><p>fcntl()<br>flock()<br>lockf()</p><h3 id="1-7-1-flock-2-和-lockf-3-函数"><a href="#1-7-1-flock-2-和-lockf-3-函数" class="headerlink" title="1.7.1 flock(2) 和 lockf(3) 函数"></a>1.7.1 flock(2) 和 lockf(3) 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lockf - apply, test or remove a POSIX lock on an open file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lockf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">off_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flock - apply or remove an advisory lock on an open file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数可以实现好用的文件加锁。</p><p>我们这里只介绍 lockf(2) 函数，flock(2) 函数也差不多，都很简单，所以大家可以自己去查阅 man 手册。</p><p>lockf(3) 可以给文件进行局部加锁，简单来说就是从当前位置锁住 len 个字节。</p><p>参数列表：</p><p>　　fd：要加锁的文件描述符；</p><p>　　cmd：具体的命令见下表；</p><table><thead><tr><th align="left">宏</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">F_LOCK</td><td align="center">为文件的一段加锁，如果已经被加锁就阻塞等待，如果两个锁要锁定的部分有交集就会被合并，文件关闭时或进程退出时会自动释放，不会被子进程继承。</td></tr><tr><td align="left">F_TLOCK</td><td align="center">与 F_LOCK 差不多，不过是尝试加锁，非阻塞。</td></tr><tr><td align="left">F_ULOCK</td><td align="center">解锁，如果是被合并的锁会分裂。</td></tr><tr><td align="left">F_TEST</td><td align="center">测试锁，如果文件中被测试的部分没有锁定或者是调用进程持有锁就返回 0；如果是其它进程持有锁就返回 -1，并且 errno 设置为 EAGAIN 或 EACCES。</td></tr></tbody></table><p>图5 lockf(3) 函数的 cmd 参数可选值</p><p>　　len：要锁定的长度，如果为 0 表示文件有多长锁多长，从当前位置一直锁到文件结尾。</p><p>下面我们使用 lockf(3) 函数写一个栗子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"./p"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func_add</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = fileno(fp); <span class="comment">// fileno 从file流中把文件描述符挑出来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lockf(fd, F_LOCK, <span class="number">0</span>); <span class="comment">// 写0 指的是文件有多长 锁多长</span></span><br><span class="line">    fgets(linebuf,LINESIZE,fp); <span class="comment">// 将读取的内容放进 linebuf中</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET); <span class="comment">// 文件位置指针 指回去</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>, atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line">    fflush(fp);<span class="comment">// 因为文件是全缓冲模式，所以为了保证全部写到文件中去。这里需要刷新一下缓冲区</span></span><br><span class="line">    lockf(fd, F_ULOCK, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;PROCNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// 子进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            func_add();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// 父进程</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 博客版</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCNUM        20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME        <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE        1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func_add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">  </span><br><span class="line">  fp = fopen(FNAME,<span class="string">"r+"</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"fopen()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fd = fileno(fp);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">"fd"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用之前先锁定</span></span><br><span class="line">  lockf(fd,F_LOCK,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  fgets(buf,BUFSIZE,fp);</span><br><span class="line">  rewind(fp); <span class="comment">// 把文件位置指针定位到文件首</span></span><br><span class="line">  sleep(<span class="number">1</span>); <span class="comment">// 放大竞争</span></span><br><span class="line">  <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>,atoi(buf)+<span class="number">1</span>);</span><br><span class="line">  fflush(fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用之后释放锁</span></span><br><span class="line">  lockf(fd,F_ULOCK,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; PROCNUM ; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      pid = fork();</span><br><span class="line">      <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"fork()"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(pid == <span class="number">0</span>)    <span class="comment">// child</span></span><br><span class="line">      &#123;</span><br><span class="line">          func_add();</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; PROCNUM ; i++)</span><br><span class="line">      wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是用我么以前的栗子改的，大家还记得以前写过一个栗子，让 20 个进程同时向 1 个文件中累加数字吗。</p><p>在这里每个进程在读写文件之前先加锁，如果加不上就等待别人释放锁再加。如果加上了锁就读出文件中当前的值，+1 之后再写回到文件中。</p><p>获得锁之后 sleep(1) 是为了放大竞争，让进程之间一定要出现竞争的现象，便于我们分析调试。</p><p>在调试并发的程序时，如果有些问题很难复现，那么可以通过加长每一个并发单位的执行时间来强制它们出现竞争的情况，这样可以让我们更容易的分析问题。</p><p><img src="./sio_3.png" alt=""><br>图3 flock(2) 和 lockf(3) 的缺点</p><p>文件锁还有一个机制是把一个文件当作锁，比如要操作的是 /tmp/out 文件，那么父进程可以先创建一个 /tmp/lcok文件，然后再创建 20 个子进程同时对 /tmp/out 文件进行读写，但是子进程必须先锁定 /tmp/lock 文件才能操作 /tmp/out 文件，没抢到锁文件的需要等待其它进程解锁再抢锁，等父进程为所有的子进程收尸之后再关闭/tmp/lock，/tmp/lock 这个文件就被称为锁文件。</p><p>高级 IO 部分大概就这些内容了。</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab 使用</title>
      <link href="2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="软件开发阶段"><a href="#软件开发阶段" class="headerlink" title="软件开发阶段"></a>软件开发阶段</h2><blockquote><p>软件开发十个阶段在gitlab中对应的管理方式方法</p></blockquote><ol><li>IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了<code>Mattermost</code> 它类似一个聊天工具。</li><li>ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在工单追踪器<code>issue tracker</code>中帮助你去提升这个点子。</li><li>PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用工单看板<code>Issue Board</code>。</li><li>CODE： 现在，当一切准备就绪，我们可以开始写代码了。</li><li>COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。</li><li>TEST： 通过<code>GitLab CI</code>，我们可以运行脚本来构建和测试我们的应用。</li><li>REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行代码复审<code>code review</code>以及批准。</li><li>STAGING：： 预发布环境。</li><li>PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了。</li><li>FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 <code>Cycle Analytics</code>来对当前项目中关键的部分进行的反馈</li></ol><h2 id="issue-和-milestone"><a href="#issue-和-milestone" class="headerlink" title="issue 和 milestone"></a>issue 和 milestone</h2><blockquote><p>milestone里程碑，用来标识阶段性目标， 对目标进行细化，化整为零一个个的issues，然后根据每个issues的紧急程度选择性的完成。等所有issues解决完之后 就标志着阶段性目标已完成；</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>把实际问题转化为issue，这些问题可以标记为<code>正在解决</code>和<code>计划解决</code>；</li><li>milestone对应着阶段性项目计划，然后细分为多个issues，而且可以指定完成时间，gitlab会自动生成完成进度情况概略图。</li><li>issues也可以是一个建议，共给大家一起讨论；</li><li>milestone 和issue建立时我们通常可以对问题进行简单描述，并且记录问题的解决过程，包括他人提出的疑问也可以在这里记录，后期可以随时查看；</li></ol><h3 id="创建milestone"><a href="#创建milestone" class="headerlink" title="创建milestone"></a>创建milestone</h3><blockquote><p>可以在项目开始前创建milestone，后面建issues时关联它，也可以先建issues，后期由项目负责人建milestone，然后把所有issues关联过来；</p></blockquote><ol><li>创建一个名字</li><li>简单描述，简述创建的原因，这个里程碑最终的目的，编辑的时候可以直接贴图，也可以添加附件（支持markdown格式，可以预览）</li><li>指定计划的完成时间；</li></ol><h3 id="新建issues"><a href="#新建issues" class="headerlink" title="新建issues"></a>新建issues</h3><blockquote><p>一个issues表示一个功能、一个bug、一个建议; 新建议题很简单，标题+描述+计划时间+指定人+里程碑，里程碑一定要指定一下，还可以加标签。</p></blockquote><ol><li>功能：里程碑的细分，尽量小，方便merger时的代码审核；</li><li>bug：解决程序中存在的某些问题；</li><li>建议：可以作为一个讨论交流区，也可以实现它;</li><li>一个issues 对应一个指定人，一个git 分支；</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="2020/12/16/apue-11/"/>
      <url>2020/12/16/apue-11/</url>
      
        <content type="html"><![CDATA[<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p><img src="./socket_1.png" alt=""></p><blockquote><p>如图所示，socket 可以理解为中间层。底层是若干不同的协议来完成协议族的指定，上层可以是不同的网络实现方式（流失传输，报式传输等等）。在不同的协议族当中对于这些不同的网络实现方式都会有支持，比如IPv4既能支持流失套接字，也能支持报式套接字等等。这样的话，下层换一种协议，上层换一种实现方式，程序员都要新写一套代码。</p></blockquote><p>解决方法：</p><p>借助一种机制，把下面用什么协议族，上面用什么实现方式指定起来，这样的机制就是socket。socket函数抽象出来 是一个文件描述符，也就是说拿着一个文件描述符就能完成套接字传输的问题。</p><p>对文件描述符的操作无非：</p><p>打开<br>关闭<br>读写<br>定位</p><p>还有相关的函数能把文件描述符封装到流当中，封装成<code>FILE *</code>。 通过stream 的概念来操作，这个时候就能使用标准IO了。只要是文件，标准io和系统调用io都能拿来使用了。</p><p>说到守护进程，为什么写守护进程不把所有文件描述符关掉呢，因为守护进程脱离控制终端。（因为在apue某个版本上的demo上，有把1024个文件描述符都关闭掉的实现。）因为写守护进程，多半与传输有关系，和socket都会产生或多或少的关联。那关掉文件描述符的是没有必要的。所以写程序的时候主要还是要看目的。不要盲目的模仿</p><h2 id="1-1-跨主机的传输要注意的问题"><a href="#1-1-跨主机的传输要注意的问题" class="headerlink" title="1.1 跨主机的传输要注意的问题"></a>1.1 跨主机的传输要注意的问题</h2><blockquote><p>字节序， 对齐问题</p></blockquote><p>前面讨论了进程间通讯（IPC）的各种常用手段，但是那些手段都是指通讯双方在同一台机器上的情况。在现实生活中我们会经常接触到各种各样的网络应用程序，比如大家经常使用的 ftp、svn、甚至QQ、迅雷等等，它们的通讯双方通常都是在不同的机器上的，那么它们的通讯就是跨主机的进程间通讯了，所以网络通讯也是一种进程间通讯的手段。</p><p>跨主机的程序在传输数据之前要制定严谨的协议，不然对方可能会看不懂你发送的数据，从而导致数据传送失败，甚至造成安全类bug，所以跨主机的通讯就不像我们之前学习的在同一台主机上的进程间通讯那么简单了。</p><p>制定协议要考虑的问题至少包括以下几点：</p><p>1）告诉对方自己的 IP 和端口；</p><p>先来看看 IP 和端口的概念。</p><p>当我们的程序在进行网络通讯之前，需要先与自己的机器进行约定，告诉操作系统我需要使用哪个端口，这样操作系统的某个端口在收到数据的时候就会发送给我们的进程。当另一个程序也来通知操作系统它要使用这个端口时，操作系统要保证这个端口只有我们使用而不能再让别人使用，否则当它收到数据的时候就不知道应该发送给谁了。</p><p>当我们需要发送数据的时候，也会使用这个端口进行发送，只有特殊情况才会使用别的端口或者使用多个端口。</p><h3 id="1-1-1-类型长度问题"><a href="#1-1-1-类型长度问题" class="headerlink" title="1.1.1 类型长度问题"></a>1.1.1 类型长度问题</h3><p>2）还要考虑的问题是通信的双方应该采用什么数据类型呢？</p><p>假如通讯双方要传送一个 int 类型的数据，那么对方机器上 int 类型的位数与我们机器上的位数是否相同呢？</p><p>也就是说 int 类型在我的机器上是 32bit，但是在对方的机器上也是 32bit 吗？假设在对方机器上是 16bit，那么我发送给它的 int 值它能正确解析吗？</p><p><strong>解决方法</strong></p><blockquote><p>使用一些通用类型的数值</p></blockquote><p><code>int32_t</code></p><p><code>uint32_t</code></p><p><code>int64_t</code></p><p><code>int8_t</code></p><p><code>uint8_t</code></p><p>所以通信双方的数据类型要采用完全一致的约定，这个我们在下面会讨论如何让数据类型一致。</p><h3 id="1-1-2-字节序问题：-大端存储，小端存储"><a href="#1-1-2-字节序问题：-大端存储，小端存储" class="headerlink" title="1.1.2 字节序问题： 大端存储，小端存储"></a>1.1.2 字节序问题： 大端存储，小端存储</h3><p>大端存储： 低地址处放高字节<br>小端存储： 低地址处放低字节</p><blockquote><p>还要考虑字节序问题，这个说的是大小端的问题。</p></blockquote><p>大端格式是：低地址存放高位数据，高地址存放低位数据。</p><p>小端格式是：低地址存放低位数据，高地址存放高位数据。</p><p><img src="./socket_01.png" alt=""></p><p>图1 大小端</p><p>如图1 所示，假设要存放的数据是一个16进制的数值， 0x30313233，那么 33 是低位，30 是高位，在大端存储格式中，30 存放在低位，33 存放在高位；而在小端存储格式中，33 存放在低位，30 存放在高位。</p><p>大小端存储跟发送的区别，不管是文件传输的时候，还是io来实现的时候，永远是低地址的数据先出去，高地址的数据后出去。就这有问题了，比如我现在发出去的一个数据是小端格式存放的。结果发到你那里去之后，你将它当作大端格式来接收。0x30313233 当大端存储的格式来接收，和按小端格式来接收的结果是天差地别的。解决的思路是 不再严格的去区分到底是大端存储还是小端存储，区分主机字节序和网络字节序；</p><p>主机字节序： host<br>网络字节序： network</p><p>这个东西有什么作用呢？它其实就是我们使用的网络设备（计算机、平板电脑、智能手机等等）在内存当中存储数据的格式。所以如果通讯双方的设备存储数据的格式不同，那么一端发送过去的数据，另一端是无法正确解析的，这可怎么办呢？ </p><p>没关系，还好系统为我们准备了一组函数可以帮我们实现字节序转换，我们可以像使用公式一样使用它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// htonl,  htons,  ntohl,  ntohs - convert values between host and network byte order</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;  <span class="comment">// 主机到网络</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; <span class="comment">// 主机到网络</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;  <span class="comment">// 网络到主机</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>; <span class="comment">// 网络到主机</span></span><br></pre></td></tr></table></figure><p>_ to __:</p><p>当前pc机上的内容要上传网络传给对端的话，当前就应该是主机序转网络序；<br>如果数据是从网络上接收过来的话，那就是网络序转主机序；</p><p>这组函数的名字好奇怪是吧，所以为了便于记忆，在讨论它们的功能之前我们先来分析一下它们名字里的玄机：</p><p>h 是 host，表示主机；n 是 network，表示网络。l 表示 long，s 表示 short。<br>short为两个字节的， long为四个字节的</p><p>这样一来就好理解多了吧？它们的作用从名字中就可以看出来了，<br>就是把数据从主机序转换为网络序，<br>或者把数据从网络序转换为主机序。</p><p>网路字节序一般都是大端的，而主机字节序则根据硬件平台的不同而不同（在 x86 平台和绝大多数的 ARM 平台都是小端）。所以为了简化我们编程的复杂度，这些函数的内部会根据当前机器的结构自动为我们选择是否要转换数据的字节序。我们不用管到底我们自己的主机采用的是什么字节序，只要是从主机发送数据到网络就需要调用 hton 函数，从网络接收数据到主机就需要调用 ntoh 函数。</p><h3 id="1-1-3-对齐问题"><a href="#1-1-3-对齐问题" class="headerlink" title="1.1.3 对齐问题"></a>1.1.3 对齐问题</h3><p>4）最后一项约定是结构体成员不对齐，由于数据对齐也是与硬件平台相关的，所以不同的主机如果使用不同的对齐方式，就会导致数据无法解析。</p><p><strong>解决的办法</strong></p><blockquote><p>不对齐</p></blockquote><p>如何使数据不对齐呢，只需要在定义结构体的时候在结尾添加 <strong>attribute</strong>((packed)) 就可以了，见如下栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 struct msg_st</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">     <span class="keyword">uint32_t</span> math;</span><br><span class="line">     <span class="keyword">uint32_t</span> chinese;</span><br><span class="line"> &#125;__attribute__((packed));</span><br></pre></td></tr></table></figure><p>网络传输的结构体中的成员都是紧凑的，所以不能地址对齐，需要在结构体外面增加 <strong>attribute</strong>((packed))。</p><p>关于字节对齐的东西就足够写一篇博文了，LZ 在这里仅仅简单介绍一下什么是字节对齐，如果感兴趣大家可以去查阅专门的资料。</p><p>结构体的地址对齐是通过 起始地址 % sizeof(type) == 0 这个公式计算的，也就是说存放数据的起始地址位于数据类型本身长度的整倍数。<br>如果当前成员的起始地址能被 sizeof 整除，就可以把数据存放在这；否则就得继续看下一个地址能不能被 sizeof 整除，直到找到合适的地址为止。不适合作为起始地址的空间将被空(lang)闲(fei)。</p><p><img src="./socket_02.png" alt=""><br>图2 字节对齐</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-2-报式套接字-UDP"><a href="#1-2-报式套接字-UDP" class="headerlink" title="1.2 报式套接字(UDP)"></a>1.2 报式套接字(UDP)</h2><p>从进程间通信开始，我们写程序就是一步一步按部就班的写就可以了，编写网络应用也一样，网络通信本质上就是一种跨主机的进程间通信（IPC）。</p><p>前面我们了解了主动端和被动端的概念，那么接下来看看在 Socket 中主动端和被动端都要做什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">主动端（先发包的一方）</span><br><span class="line"></span><br><span class="line">1.取得 Socket</span><br><span class="line"></span><br><span class="line">2.给 Socket 取得地址（可省略， 给socket取得地址指的是绑定本地地址，不必与操作系统约定端口，由操作系统指定随机端口）</span><br><span class="line"></span><br><span class="line">3.发&#x2F;收消息</span><br><span class="line"></span><br><span class="line">4.关闭 Socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">被动端（先收包的一方，程序需要先运行）</span><br><span class="line"></span><br><span class="line">1.取得 Socket</span><br><span class="line"></span><br><span class="line">2.给 Socket 取得地址 （绑定地址）</span><br><span class="line"></span><br><span class="line">3.收&#x2F;发消息</span><br><span class="line"></span><br><span class="line">4.关闭 Socket</span><br></pre></td></tr></table></figure><p>proto.h 里面主要是通讯双方约定的协议，包含端口号、传送数据的结构体等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>rcver.c 是被动端的代码，也是通讯双方先启动的一端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ./rcver</span><br><span class="line">$&gt; netstat -anu   <span class="comment"># u代表 udp   -ant  t代表 tcp</span></span><br></pre></td></tr></table></figure><p>snder.c 是主动端，主动向另一端发送消息。这端可以不用向操作系统绑定端口，发送数据的时候由操作系统为我们分配可用的端口即可，当然如果想要自己绑定特定的端口也是可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    bind();    // 主动端可省略绑定端口的步骤</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sbuf,<span class="string">'\0'</span>,<span class="keyword">sizeof</span>(sbuf));</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由这三个文件组成的程序就可以进行网络通讯了，不知道大家有没有注意到，无论是发送端还是接收端，执行的步骤都是固定的，将来大家在开发更复杂的网络应用时也是基于这几个步骤进行扩展。</p><p>根据上面的代码中协议（proto.h）的定义，我们知道其中 msg_st 结构体中 name 成员的长度是固定的，这样并不好用，那么我们就把它修改为变长结构体。</p><p>修改成变长结构体很简单，只需把变长的部分放到结构体的最后面，然后通过 malloc(3) 动态内存管理来为它分配我们需要的大小。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">    <span class="keyword">uint8_t</span> name[<span class="number">1</span>];</span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure><p>UDP 包常规的最大尺寸是 512 字节，去掉包头的 8 个字节，再去掉结构体中除了最后一个成员以外其它成员大小的总和，剩下的就是我们最后一个成员最大能分配的大小。</p><p>大家还记得如何操作一个文件吗？</p><p>1.首先通过 open(2) 函数打开文件，并获得文件描述符；</p><p>2.通过 read(2)、write(2) 函数读写文件；</p><p>3.调用 close(2) 函数关闭文件，释放相关资源。</p><p>没错，在 Linux 的一切皆文件的设计理念中，网络也是文件，网络之间的通讯也可以像操作文件一样，对它进行读写。</p><p>在网络程序中，通常步骤是这样的：</p><p>1.首先通过 socket(2) 函数获得 socket 文件描述符；</p><p>2.通过 send(2)、sendto(2)、recv(2)、recvfrom(2) 等函数读写数据，这一步就相当于在网络上收发数据了。</p><p>3.调用 close(2) 函数关闭网络，释放相关资源。你没看错，这个函数就是我们关闭文件描述符的时候使用的函数。</p><p>下面我们依次介绍上面遇到的各种函数。</p><h3 id="1-2-1-socket函数"><a href="#1-2-1-socket函数" class="headerlink" title="1.2.1 socket函数"></a>1.2.1 socket函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket - create an endpoint for communication</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>socket(2) 函数是用来获取对网络操作的文件描述符的，就像 open(2) 函数一样。</p><p>参数列表：</p><p>　　domain：协议族/地址族；</p><p>　　type：上层如何进行实现/链接方式；</p><p>　　protocol：具体使用哪个协议。在 domain 的协议族中每一个对应的 type 都有一个或多个协议，使用协议族中默认的协议可以填写 0。</p><p><code>用 domain（协议族）中的 某种 protocol（具体哪个协议）进行 type类型的传输</code></p><p>返回值：如果成功，返回的是一个代表当前网络链接的文件描述符，你要保存好它，因为后续的网络操作都需要它。如果失败，返回 -1，并设置 errno。</p><p>下面就是 Linux 支持的协议族，也就是 <code>domain</code> 参数可以选择的宏，它们都定义在 sys/socket.h 头文件中，所以想要使用下面的宏不要忘记包含这个头文件哟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AF_UNIX、AF_LOCAL：本地协议；通过 man 7 unix 可以得到有关这个协议族更详细的描述。</span><br><span class="line"></span><br><span class="line">AF_INET：IPV4 协议；这是我们最常见的协议族，通过 man 7 ip 可以得到有关这个协议族更详细的描述。</span><br><span class="line"></span><br><span class="line">AF_INET6：IPV6 协议；，通过 man 7 ipv6 可以得到有关这个协议族更详细的描述。</span><br><span class="line"></span><br><span class="line">AF_IPX：Novell 当年是网络的代名词，是非常古老的操作系统，出现在 TCP&#x2F;IP 之前；</span><br><span class="line"></span><br><span class="line">AF_NETLINK：是用户态与内核态通信的协议；</span><br><span class="line"></span><br><span class="line">AF_X25：这是很早的协议，感兴趣的话可以自己去 Google 一下；</span><br><span class="line"></span><br><span class="line">AF_AX25：应用于业余无线电，也称为短波通信，都是一些无线电爱好者使用的协议。据说汶川地震时灾区所有通讯都瘫痪了，第一个求救信号就是短波发送出来的，因为这些无线电爱好者家里一般都有大大小小的发电机。</span><br><span class="line"></span><br><span class="line">AF_ATMPVC：当年如日中天，后来死于封闭。协议设计得非常好，后来几家公司都为了拿大头就僵持起来，谁都没有推广它，就在这时候以太网发展起来了，就把它打败了。以太网发展起来就是因为很简陋，所以更容易推广。</span><br><span class="line"></span><br><span class="line">AF_APPLETALK：苹果使用的一个局域网协议；</span><br><span class="line"></span><br><span class="line">AF_PACKET：底层 socket 所用到的协议，比如抓包器所遵循的协议一定要在网卡驱动层，而不能在应用层，否则无法见到包封装的过程。再比如 ping(1) 命令大家都熟悉吧，想要实现 ping(1) 命令就需要了解这个协议族，感兴趣的话大家可以自行 Google 一下。</span><br></pre></td></tr></table></figure><p>如果想要对网络编程进行更深入的学习，那么《APUE》作者写的《UNIX 网络编程》有必要读一遍；《TCP/IP详解》三卷也要读一下，但是这三卷都很难读，而且翻译质量也一般，可以买一本中文的再找一本英文电子版的，遇到中文的读不通的时候拿出来英文原文对照一下就可以了。</p><p>下面我们看一下 <code>type</code> 参数有哪些可选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SOCK_STREAM：流式套接字，特点是有序、可靠。有序、双工、基于链接的、以字节流为单位的。</span><br><span class="line"></span><br><span class="line">可靠不是指不丢包，而是流式套接字保证只要你能接收到这个包，那么包中的数据的完整性一定是正确的。</span><br><span class="line"></span><br><span class="line">双工是指双方都能收发。</span><br><span class="line"></span><br><span class="line">基于链接的是指：比如大街上张三、李四进行对话，一定不会说每句话之前都叫着对方的名字。也就是说通信双方是知道对方是谁的。</span><br><span class="line"></span><br><span class="line">字节流是指数据没有明显的界限，一端数据可以分为任意多个包发送。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SOCK_DGRAM：报式套接字，无链接的，固定的最大长度，不可靠的消息。</span><br><span class="line"></span><br><span class="line">就像写信，无法保证你发出的信对方一定能收到，而且无法保证内容不会被篡改。如果今天发了一封信，明天又发了一封信，不能保证哪封信先到。大家都能收到这个包，但是发现不是自己的之后就会丢弃，发现是自己的包再处理，有严格的数据分界线。更详细的解释可以参阅 man 手册。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SOCK_SEQPACKET：提供有序、可靠、双向基于连接的数据报通信。</span><br><span class="line"></span><br><span class="line">SOCK_RAW：原始的套接字，提供的是网络协议层的访问。</span><br><span class="line"></span><br><span class="line">SOCK_RDM：数据层的访问，不保证传输顺序。</span><br><span class="line"></span><br><span class="line">SOCK_PACKET：不好用，具体的 bug 要查 man 7 packet。</span><br></pre></td></tr></table></figure><p>bind(2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind - bind a name to a socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">  <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind(2) 函数用于绑定本机端口，就是提前跟操作系统约定好，来自 xx 端口的数据都要转交给我（当前进程）处理，并且我占用了这个端口号别人（其它进程）就不能再使用了。</p><p>参数列表：</p><p>　　sockfd：刚刚使用 socket(2) 函数得到的文件描述符，表示要对该网络链接绑定端口。</p><p>　　addr：要绑定到套接字上的地址。根据不同的协议要在 man 手册第 7 章查阅具体的章节，然后在 Address Types 一栏里面找到对应的结构体。比如你在调用 socket(2) 函数的时候，domain 参数选择的是 AF_INET，那么这个结构体就可以在 man 手册 ip(7) 章节中找到。</p><p>　　addrlen：addr 传递的地址结构体的长度。</p><p>以 AF_INET 为例，下面这两个结构体就是在 ip(7) 中找到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* 指定协议族，一定是 AF_INET，因为既然是 man ip(7)，那么一定是 AF_INET 协议族的 */</span></span><br><span class="line">  <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* 端口，需要使用 htons(3) 转换为网络序 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* 无符号32位大整数，可以使用 inet_pton(3) 将便于记忆的点分式 IP 地址表示法转换为便于计算机使用的大整数，inet_ntop(3) 的作用则正好相反。本机地址转换的时候可以使用万能IP：0.0.0.0(称为any address)，函数会自动将 0.0.0.0 解析为真实的本机 IP 地址。 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 大家可以看到，这个结构体的类型是 struct sockaddr_in，而 bind(2) 函数的第二个参数 的类型是 struct sockaddr，它们二者有什么关系呢？别瞎想，不是继承关系啦，C 语言中没有继承这种东东。在传参的时候直接把实参强转为 void* 类型即可，就像上面栗子中 rcver.c 写得那样。</p><p>recv(2) 和 recvfrom(2) 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recv, recvfrom - receive a message from a socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// src_addr 对端的地址</span></span><br><span class="line"><span class="comment">// addrlen  对端的地址长度</span></span><br></pre></td></tr></table></figure><p>这两个函数的作用是从网络上接收内容并写入 len 个字节长度的数据到 buf 中，且将发送端的地址信息填写到 src_addr 中。</p><p>返回值是真正能接收到的字节数，返回 -1 表示失败。</p><p>recv(2) 函数一般用在流式（SOCK_STREAM）套接字中，而 recvfrom(2) 则一般用在报式（SOCK_DGRAM）套接字中。很明显 recv(2) 函数并没有地址相关的参数，因为是提前建立好连接的一对一点对点的，所以不必记录每次对方是谁。</p><p>recvfrom 函数用在报式套接字当中，比如做一下现场答疑，有10个学生在提问问题，每个学生提问的问题不一致，也就说是说话的来源不一致，大家说话是带着自己身份来的。比如a同学的请求，要把回答信息准备回递给a同学。b同学的请求要回递给b同学，这点跟流式套接字不同，流式套接字已经建立一对一点对点的传输了。 需要记录对端的地址和地址长度。</p><p>为什么这么说呢，还记得上面我们提到过吗，流式套接字是基于链接的，而报式套接字是无链接的。<br>那么我们再来观察下这两个函数的参数列表，，而 recvfrom(2) 函数则会将对方的地址端口等信息回填给调用者。</p><p>网络中的数据只有单字节数据不用考虑字节序，从网络上接收过来的数据只要涉及到字节序就需要使用 ntoh 系列函数进行字节序转换。这一组函数我们上面介绍过了，没记住的童鞋可以往上翻。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小提示：通过 netstat(1) 命令 ant 参数可以查看 TCP 链接情况，或通过 netstat(1) 命令 anu 参数可以查看 UDP 链接情况。</span><br><span class="line"></span><br><span class="line">t 参数表示 TCP；</span><br><span class="line"></span><br><span class="line">u 参数表示 UDP；</span><br></pre></td></tr></table></figure><p>send(2) 和 sendto(2) 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send, sendto, sendmsg - send a message on a socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数与 recv(2) 和 recvfrom(2) 函数正好是对应的，它们的作用是向网络上发送数据。</p><p>参数列表：</p><p>　　sockfd：通过哪个 Socket 往外发数据，这个参数的值就是在调用 socket(2) 函数的时候取得的；</p><p>　　buf：要发送的数据；</p><p>　　len：要发送的数据的长度；</p><p>　　flags：特殊要求，没有填 0；</p><p>　　src_addr：目标地址；就像上面我们讨论 bind(2) 函数时一样，具体使用哪个结构体要根据你在调用 socket(2) 函数的时候使用的具体协议族有关系，然后到对应的 man 手册第 7 章去查找。</p><p>　　addrlen：目标地址的长度；</p><p>返回值是真正发送出去的数据的长度；出现错误返回 -1 并设置 errno。</p><ul><li>动态报式套接字</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ip 到 agrv的地方去指定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMEMAX     512-8-8 <span class="comment">// 512 是 udp包的 推荐长度， -8 是两个 固有字节 math 和 Chinese，再减8 是减去udp的包头</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">    <span class="keyword">uint8_t</span> name[<span class="number">1</span>]; <span class="comment">// 把当前的数组 设为一个 变长的内容, </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// uint8_t name[1]; 把name放在 结构体的首部 发送的名字只能接收第一个字符</span></span><br><span class="line">    <span class="comment">// uint32_t math;</span></span><br><span class="line">    <span class="comment">// uint32_t chinese;</span></span><br><span class="line">     </span><br><span class="line">&#125;__attribute__((packed)); <span class="comment">// 不对齐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> <span class="comment">// ./snder  IP  NAME</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> *<span class="title">sbufp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) <span class="comment">// ./snder  IP  NAME</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">2</span>]) &gt; NAMEMAX) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Name is too long"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = <span class="keyword">sizeof</span>(struct msg_st) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    sbufp = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sbufp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"malloc()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    bind();    // 主动端可省略绑定端口的步骤</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(sbufp-&gt;name, argv[<span class="number">2</span>]);</span><br><span class="line">    sbufp-&gt;math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbufp-&gt;chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd, sbufp, <span class="built_in">size</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> *<span class="title">rbufp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="built_in">size</span> = <span class="keyword">sizeof</span>(struct msg_st) + NAMEMAX <span class="number">-1</span>;</span><br><span class="line">    rbufp = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rbufp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"malloc()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>); <span class="comment">// 如果不太确定那个具体协议的名字是多少，</span></span><br><span class="line">    <span class="comment">// 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话，</span></span><br><span class="line">    <span class="comment">//一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * struct socket_in &#123;</span></span><br><span class="line"><span class="comment">     *    sa_family_t     sin_family;</span></span><br><span class="line"><span class="comment">     *    in_port_t       sin_port;  // 端口号</span></span><br><span class="line"><span class="comment">     *    struct_in_addr  sin_addr;   // ip地址</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * struct in addr &#123;</span></span><br><span class="line"><span class="comment">     *    uint32_t  s_addr; // 32位无符号的整型数</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // ip地址点分式和大整数之间的转换</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // 将ipv4 和 ipv6的地址转成二进制的格式</span></span><br><span class="line"><span class="comment">     * int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 跟本机约定哪个端口是给自己使用的；</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) <span class="comment">// bind 给socket取得地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr); <span class="comment">// addrlen 需要初始化一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd, rbufp,<span class="built_in">size</span>,<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>) <span class="comment">// 接收消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);<span class="comment">// 把一个大整数形式转成点分式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbufp-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbufp-&gt;math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbufp-&gt;chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后剩下 close(2) 函数就不需要 LZ 在这里介绍了吧，如果还有童鞋对 close(2) 函数不熟悉，那么请翻阅到前面 文件 IO 部分的博文中复习一遍。</p><h3 id="1-2-2-多点通讯"><a href="#1-2-2-多点通讯" class="headerlink" title="1.2.2 多点通讯"></a>1.2.2 多点通讯</h3><p>上面我们讨论的是单点通讯，多点通讯只能用报式套接字来实现。</p><p>一般多点通讯分为：广播 和 多播（组播）两种方式。</p><p>广播又分为 全网广播（255.255.255.255） 和 子网广播 两种形式。</p><p>多播：都是 D 类地址，以 224. 开头。224.0.0.1 是一个组播中的特殊地址，发到这个地址的消息会强制所有组播地址中的主机接收，类似于全网广播。</p><p>广播：往（255，255，255，255发送消息）范围非常大，愿不愿意接收都得接收到；</p><p>组播： 建立一个播组，如果想接收到消息，就加入这个组；不想收就退组。多播的使用权更加灵活，当然多播当中有一个特殊地址，如果往这个特殊地址发送消息的话。实际就如同发送一个广播，效果是一样的。从另外一个角度来实现广播的特点</p><p>注意：广播和组播仅在局域网内有效。</p><ul><li>一个广播实例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ip 到 agrv的地方去指定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed)); <span class="comment">// 不对齐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>); <span class="comment">// 如果不太确定那个具体协议的名字是多少，</span></span><br><span class="line">    <span class="comment">// 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话，</span></span><br><span class="line">    <span class="comment">//一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &amp;val, <span class="keyword">sizeof</span>(val))&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsocket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * struct socket_in &#123;</span></span><br><span class="line"><span class="comment">     *    sa_family_t     sin_family;</span></span><br><span class="line"><span class="comment">     *    in_port_t       sin_port;  // 端口号</span></span><br><span class="line"><span class="comment">     *    struct_in_addr  sin_addr;   // ip地址</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * struct in addr &#123;</span></span><br><span class="line"><span class="comment">     *    uint32_t  s_addr; // 32位无符号的整型数</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // ip地址点分式和大整数之间的转换</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * // 将ipv4 和 ipv6的地址转成二进制的格式</span></span><br><span class="line"><span class="comment">     * int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 跟本机约定哪个端口是给自己使用的；</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) <span class="comment">// bind 给socket取得地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr); <span class="comment">// addrlen 需要初始化一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>) <span class="comment">// 接收消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);<span class="comment">// 把一个大整数形式转成点分式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前广播默认要求是不能够发出的，组播其实也一样。</span></span><br><span class="line"><span class="comment">     * socket层上面的实现层也好 还是下面的协议层也好。打开来看实际上有很多薄的层，</span></span><br><span class="line"><span class="comment">     * IP层，TCP层，UDP层，甚至socket层面。在不同的层上会有不同的开关或选钮加以控制。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 全网广播实际上是禁止被发送的，而有一个开关是能够使当前的广播是能够实现的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sbuf,<span class="string">'\0'</span>,<span class="keyword">sizeof</span>(sbuf));</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"255.255.255.255"</span>,&amp;raddr.sin_addr);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./rcver</span><br><span class="line">./snder</span><br><span class="line">ok!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端并没有收到响应， 原因可能是防火墙的问题</span></span><br></pre></td></tr></table></figure><h2 id="1-4-抓包工具使用"><a href="#1-4-抓包工具使用" class="headerlink" title="1.4 抓包工具使用"></a>1.4 抓包工具使用</h2><p>过滤表达式</p><p><code>ip.dist == 255.255.255.255</code></p><p>getsockopt(2) 和 setsockopt(2) 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getsockopt, setsockopt - get and set options on sockets</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数用于读取和设置套接字的特殊要求。</p><p>对 sockfd 这个套接字的 level 层的 optname 选项进行设置，值放在 optval 里，大小是 optlen。</p><p>参数 sockfd、level 和 optname 的对应关系就是：一个 sock 有多个 level，每个 level 有多个选项。</p><p>所有的选项需要在不同协议的 man 手册(第7章) Socket options 一栏查找。</p><p>常用 optname 参数：</p><p>SO_BROADCAST：设置或获取广播标识，当这个标识被打开时才允许接收和发送报式套接字广播，所以大家使用广播的时候不要忘记设置这个 opt，但在流式套接字中无效。</p><p>IP_MULTICAST_IF：创建多播组，optval 参数应该使用 ip_mreqn 还是 ip_mreq 结构体，取决于 IP_ADD_MEMBERSHIP 选项。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">/* 多播组 IP 地址，大整数，可以用 inet_pton(3) 将点分式转换为大整数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_address</span>;</span> <span class="comment">/* 本机 IP 地址，可以用 0.0.0.0 代替，大整数，可以用 inet_pton(3) 将点分式转换为大整数 */</span></span><br><span class="line"><span class="keyword">int</span> imr_ifindex; <span class="comment">/* 当前使用的网络设备的索引号，ip ad sh 命令可以查看编号，用 if_nametoindex(3) 函数也可以通过网络设备名字获取编号，名字就是 ifconfig(1) 看到的名字，如 eth0、wlan0 等 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>IP_ADD_MEMBERSHIP：加入多播组</p><h3 id="1-4-1-多播-组播"><a href="#1-4-1-多播-组播" class="headerlink" title="1.4.1 多播/组播"></a>1.4.1 多播/组播</h3><blockquote><p>多播属于D类IP地址，都是224. 开头</p></blockquote><p><code>224.0.0.1</code> 表示所有支持多播的节点；默认都存在这个组当中，并且无法离开。所以在sender方往这个地址发消息相当于往 <code>255.255.255.255</code>上发消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MGROUP      <span class="meta-string">"224.2.2.2"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT     <span class="meta-string">"1989"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE    13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定多播组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 发送方应该创建多播组，并且发组间消息。而接收方应该是加入多播组，从这个多播组中来收消息。</span></span><br><span class="line"><span class="comment"> * 这个组就从为大家需要知道的内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed)); <span class="comment">// 不对齐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>); <span class="comment">// 如果不太确定那个具体协议的名字是多少，</span></span><br><span class="line">    <span class="comment">// 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话，</span></span><br><span class="line">    <span class="comment">//一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mreq</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, MGROUP, &amp;mreq.imr_multiaddr);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;mreq.imr_address);</span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq) )&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsocket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 跟本机约定哪个端口是给自己使用的；</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) <span class="comment">// bind 给socket取得地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr); <span class="comment">// addrlen 需要初始化一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len) &lt; <span class="number">0</span>) <span class="comment">// 接收消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);<span class="comment">// 把一个大整数形式转成点分式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM:%s:%d---\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前广播默认要求是不能够发出的，组播其实也一样。</span></span><br><span class="line"><span class="comment">     * socket层上面的实现层也好 还是下面的协议层也好。打开来看实际上有很多薄的层，</span></span><br><span class="line"><span class="comment">     * IP层，TCP层，UDP层，甚至socket层面。在不同的层上会有不同的开关或选钮加以控制。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 全网广播实际上是禁止被发送的，而有一个开关是能够使当前的广播是能够实现的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mrep</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, MGROUP, &amp;mrep.imr_multiaddr);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;mrep.imr_address);</span><br><span class="line">    mrep.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(sd, IPPROTO_IP, IP_MULTICAST_IF,&amp;mrep, <span class="keyword">sizeof</span>(mrep) ) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sbuf,<span class="string">'\0'</span>,<span class="keyword">sizeof</span>(sbuf));</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 约定多播组</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 发送方应该创建多播组，并且发组间消息。而接收方应该是加入多播组，从这个多播组中来收消息。</span></span><br><span class="line"><span class="comment">     * 这个组就从为大家需要知道的内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    inet_pton(AF_INET, MGROUP, &amp;raddr.sin_addr);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf),<span class="number">0</span>,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-wireShark"><a href="#1-4-2-wireShark" class="headerlink" title="1.4.2 wireShark"></a>1.4.2 wireShark</h3><blockquote><p>41:6c:61:6e:00:00:00:00:00:34:00:00:00:00:00:00:53:00:00:00:56</p></blockquote><p>这是<code>basic</code>包中程序 实际发出的数据包。看到6e 到 53 中间的 34 就是内存泄漏，泄漏的是栈上残留的数据；</p><p>处理方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"> * <span class="comment">// 把从 某某位置开始 到 某某位置结束 中间 n个位置的数值 清空为 '\0'</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3-udp-丢包"><a href="#1-4-3-udp-丢包" class="headerlink" title="1.4.3 udp 丢包"></a>1.4.3 udp 丢包</h3><p>下面来谈谈丢包和校验的问题</p><ul><li>TTl</li></ul><blockquote><p>TTL（time to leave） 是一个数据包能够经过的路由器数量的上限;</p></blockquote><p>UDP 会丢包，为什么会丢包呢？丢包由于阻塞造成的</p><blockquote><p>因为不同的请求会选择不同的路径经过不同的路由器，这些包到达路由器的时候会进入路由器的等待队列，当路由比较繁忙的时候队列就会满，当队列满了的时候各个路由会根据不同的“丢包算法（当队列达到80%的时候，选择随机丢包。或者当包占到这个队列百分之多少的时候，剩下的包不再接收等等）”丢弃多余的包（一般是丢弃新来的包或随机丢弃包）。所以丢包的根本原因是拥塞。</p></blockquote><p>ping 命令的 TTL（time to leave） 是一个数据包能够经过的路由器数量的上限，这个上限在 Linux 环境里默认是 64，在 Windows 里默认是 128。</p><p>假设从中国某个点发送一个包到美国的某个点，从发出开始到中国的总路由器需要大约十几跳，从中国总路由到美国总路由大约两三跳就到了，再从美国总路由到达目标点也经过大约十几跳，因此无论 TTL 是 64 还是 128 都足以从全球任何一个点发送数据到另一个点了，况且发出去的这几个包走的路径也是不一致的，因为当前在经过沿途路由队列，本身会有一个选择算法（寻找最短路径），很有可能每个包走的都是不同路径。所以丢包绝不是因为 TTL 值太小导致的。</p><ul><li>数据校验</li></ul><blockquote><p>网站图片显示不全打X，或者部分显示不全。类似web服务等，都会有一个断点续传的功能。这里不能做硬性数据校验（刷新发包请求）， 而应该是 尝试读-&gt;读不出来就跳一个字节-&gt; 依次循环，而不是读不到就卡住这种非硬性校验。在做一些网络操作的时候，网络的一些也不会做硬性的数据校验</p></blockquote><p>解决丢包的方法是使用流量控制，之前我们写过令牌桶还记得吧？流控分为开环式（没有校验的流控）和闭环式。</p><p>我们在这里介绍一种<code>停等式流控</code>：它是一种闭环式流控。它的实现方式很简单，一问一答即可。就是发送方每次发送一个数据包之后要等待接收方的响应，确认接收方收到了自己的数据包后再发送下一个数据包。这种方式的特点是每次等待的时间是不确定的，因为每次发包走的路径是不同的，所以包到达目的地的时间也是不同的，而且还要受网络等环境因素影响。</p><p><img src="./udp_01.png" alt=""></p><p>（发包之后等待ACK反馈之后再接着发）</p><p>并且停等式流控的缺点也很明显：<br>1.浪费时间，多数时间都花费在等待响应上面了。<br>2.双方发送包的数量增加了，这也意味着丢包率升高了。<br>3.为了降低错误率，实现的复杂度会变高。如果 s 端 data 包发过去了，但是 c 端响应的 ack 包丢了，s 端过了一会儿没收到 ack 认为 data 丢了再次发送 data，当 c 端再次收到一模一样的 data 包时不知道到底是有两段数据一模一样还是 s 端把包发重复了，所以需要给data包加编号，这样 c 端就知道当前这个 data 包是合法的数据还是多余的数据了。</p><p>停等式流控虽然上升了丢包率，但是能保证对方一定能收到数据包。</p><ul><li>rtt（解决发送data丢失的问题）</li></ul><p>平均等待时间，比如s第一次向c发送包就丢了，那又不可能一直傻等着根本来不了的ACK包。所以需要设置一个平均等待时间，初始化这个值设多大没有关系，只要发第一个data，收到ACK的时候，这个时间就作为一个完全的rrt。第二个ack到来的时候，又是一个时间。这两个rrt想办法做一个平均值。然后每一次的返回新的ack，都要拿新的时间汇总计算出平均值。所以第一次发包就丢的情况，在等待了一次rrt 之后就继续发一下包过去。等待ack返回在继续。然后依此类推。</p><ul><li>给data包加编号 （解决没有ack丢失的问题）</li></ul><p>同样，s第一次向c发送包成功了，但是c返回的ack包丢了。s在等待一个rtt时间之后，发现没见ack的踪迹。s没有能力去判断c那边到底是自己包没发成功，还是ack包丢包了。所以，s端只能认为是自己的data包丢了。所以就重新传了data包，这就有问题了，c那边接到两个一摸一样的data包。那c就怀疑两件事儿：1 自己的ack包是不是丢了，2 是不是就有两个一摸一样data包的情况呢。因此需要给data包添加编号。所以c端在处理刚才的情况的时候，发现两个data包编号一样的话，就知道自己丢ack包了，然后赶紧把给s端返回ack包，并顺带把重复的data给删除掉了。</p><p>web 传输通常采用两种校验方案：</p><p>1.不做硬性校验：交给用户来做。比如你在浏览网页，网页周边的广告都加载出来了，但是正文没有加载出来，你肯定会刷新页面吧？但是如果正文加载出来了，周边的广告没有加载出来，你会刷新网页一定要让整个网页全部都加载完整再看内容码？</p><p>2.延迟应答：下次通讯的时候把上次的 ack 带过来，表示上次的通讯是完整的。</p><ul><li>ack延迟</li></ul><p><img src="./socket_03.png" alt=""><br>图3 ack 延迟</p><p>不仅仅 data 包会出现延迟， ack 包也会出现延迟（见图3）。所以 ack 包也需要加编号。</p><p>为了防止被抓包，所以往往不会把原始的编号暴露出来，比如将编号+1或-1再发送。</p><p>网络的拥塞不仅仅会带来丢包的问题，还会带来延迟的问题。延迟并不可怕，可怕的是延迟抖动。比如在北京看新闻联播和在云南看新闻联播会是同时的吗？肯定会有相应的延迟吧，每一帧都延迟就没关系，就怕其中某些帧延迟，其它帧不延迟，这样看到的内容就全乱了。</p><p>上面说了用停等式流控可以保证数据一定能够让对方接收到，但是有没有觉得速度慢了点？</p><p>可以通过窗口或滑动窗口提高速度，见图4。</p><ul><li>滑动窗口（最大限度抢占路由资源）</li></ul><p><img src="./socket_04.png" alt=""><br>图4 窗口</p><p>使用窗口协议的停等式流控，不再是发送一个包之后等待 ack 然后再发送另一个包，而是一下子发送出去多个包（图中一次发送 5 个包），分别等待它们的响应后再发送下一批次的包。一次发送 5 个包，那么窗口的大小就是 5。使用窗口协议就可以尽可能多的抢占公共资源（交换机的等待队列等）了，这样传输效率相比简单的停等式流控就更高了。当然窗口的缺点也是显而易见的：窗口的大小不可变，对于复杂的网络情况并不灵活。那么只要对窗口稍加改变就可以更灵活的应对复杂多变的网络环境：动态改变窗口的大小，使之可以根据不同的网络情形动态的改变流控的速率，这样就可以平衡丢包率和传输速率之间的杠杆了，这种可以动态调整窗口大小的协议叫做“滑动窗口”。关于窗口和滑动窗口这里就不做过多介绍了，感兴趣的童鞋可以去查阅一些专门的资料。</p><p>新的问题</p><p>s第一次拿到的ack一定是第一个data包对应的ack吗？不一定把。所以s端和c端在进行对话之前，要进行编号的约定。</p><h2 id="1-5-TCP"><a href="#1-5-TCP" class="headerlink" title="1.5 TCP"></a>1.5 TCP</h2><p>说完了 UDP，接下来聊一聊 TCP。</p><p><img src="./tcp_00.png" alt=""></p><p>图x tcp三次握手原理</p><p>由报式套接字过渡到流式套接字(三次握手（中间两步合成一步，四步并三步）主要目的就是为了协同编号，实际上也是约定对话格式，指定协议的过程 )c端向s端说，我的编号从哪里开始，s端回收到并告诉自己从什么编号开始，c端发起第一次握手，s端回第二次握手，c端发起第三次握手。有了这三次握手之后，s端和c端就建立起一对一的，点对点的安全传输。这就是TCP三次握手的精髓所在。然后后面会有四次挥手，会把当前传输过程，或者传输的数据来进行总结，进行断开链接等操作。</p><p>说到 TCP 就不得不谈到 TCP 的三次握手，见图 5。</p><p><img src="./socket_05.png" alt=""></p><p>图5 TCP 三次握手</p><p>TCP 都是要客户端先发起请求，所以客户端可以称为“主动端”，而服务器被动接收请求，所以服务端也可以称为“被动端”。往往服务端要先运行起来，然后客户端再发送消息，否则客户端发送的包会因为找不到目的地而被丢弃。</p><ul><li>半连接状态</li></ul><p>如图x所示，1，2两步被称为半连接状态。然后在s端会有一个池，叫做半链接池；</p><p>服务端收到客户端发来的 SYN 报文后（第1步），会响应 SYN+ACK 报文给客户端（第2步），并将当前链接的一些信息放入一个叫做“半链接池”的缓冲区中，当对方发起第三次握手的时候（第3步），就在池中找到对方的信息（ip，port protocol等）。如果都存在的话，就说明前面已经建立了两个成功的握手。<br>那么就接收第三次握手，下面就进入正常的数据传输。当然如果超过一定时间后该客户端没有返回 ACK 报文给服务端，服务端再把这个半链接从半链接池中移除，释放相关资源。</p><ul><li>半链接洪水（无法从根本上进行防范）</li></ul><blockquote><p>占满你的链接池</p></blockquote><p>只要出现了“XX池”，那么该池的容量终归是有限的，所以有一种下流的拒绝服务攻击手段就是利用大量的半链接把服务端的半链接池沾满，以实现拒绝服务攻击。例如当很多肉鸡向某台服务器发送第一次握手（FIN）却永远不发送第三次握手（ACK），这样很快就把服务器的半链接池沾满了，有效的用户也就无法请求服务器了，这就是下流的半链接攻击手段的大致原理。</p><ul><li>取消链接池</li></ul><p>防范半链接的手段就是取消半链接池，然后通过一个算法为每个链接计算出一个独一无二的标识，再把这个标识放入 cookie 中通过 ACK 返回给客户端。cookie 由内核产生，仅保留这一秒和上一秒的 cookie。当用户再次请求时需要带着这个 cookie，用相同的 cookie 计算，只要与用户带来的 cookie 相同就认为是合法用户，如果不相同就用上一秒的cookie再次计算和比较，如果还不相同，就认为用户的cookie 是伪造的或是超时的，所以用户会立即重新建立第一次握手。</p><p>cookie计算公式：本机IP+本机端口+对端IP+对端端口 | Salt（由内核产生的，1秒变一次）</p><p>其实在实践当中也会保留半链接池，里面仅仅存放频繁访问的用户来优化 cookie 方式的链接。</p><p>简要的介绍了 TCP 的三次握手之后，我们来看看如何实现用 TCP 协议收发数据。有关更详细的 TCP 知识，感兴趣的童鞋可以参阅《TCP/IP 卷一：协议》。</p><h3 id="1-5-1-TCP实现"><a href="#1-5-1-TCP实现" class="headerlink" title="1.5.1 TCP实现"></a>1.5.1 TCP实现</h3><p>TCP 的步骤</p><p>S端（先运行）</p><p>1.取得 SOCKET (socket(2)) IPPROTO_SCTP 是一种新协议，也可以实现流式套接字<br>2.给 SOCKET 取得地址 (bind(2))<br>3.将 SOCKET 置为监听模式 (listen(2)) backlog 参数写什么正整数都行。<br>4.接受链接 (accept(2)) 如果成功返回接受链接的文件描述符，失败返回 -1 并设置 errno。注意不能直接用存放之前 socket(2) 返回的文件描述符变量来接收 accept(2) 的返回值，因为accept(2) 可能会遇到假错，这样之前变量里保存的文件描述符就丢了，会导致内存泄漏。<br>5.收/发消息 (send(2))<br>6.关闭 SOCKET (close(2))</p><p>C端（主动端）</p><p>1.取得 SOCKET (socket)<br>2.给 SOCKET 取得地址（可省） (bind)<br>3.发起链接 (connect)<br>4.收/发消息<br>5.关闭 SOCKET</p><p>proto.h，这个文件是客户端与服务端的协议，双方共同遵守的格式要定义在这里，所以两边都要包含这个头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端口号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVERPORT        <span class="meta-string">"12999"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FMT_STAMP        <span class="meta-string">"%lld\r\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>server.c 服务端，要先运行起来，监听指定的端口，操作系统指定的端口收到数据后就会送到服务端程序这里来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd,newsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>/*<span class="title">local</span> <span class="title">address</span>*/, <span class="title">raddr</span> /*<span class="title">remote</span> <span class="title">address</span>*/;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 TCP 协议</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动</span></span><br><span class="line">    <span class="comment">// 会导致 bind 端口短暂失效的情况</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>; <span class="comment">// bool值，除了0就是1；</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 指定服务端使用的端口号</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经</span></span><br><span class="line"><span class="comment">     * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个</span></span><br><span class="line"><span class="comment">     * 数值的上限。</span></span><br><span class="line"><span class="comment">     * 所以backlog 现在指能能够承受C端的全链接的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 开始监听端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待新消息传入</span></span><br><span class="line">        newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"newsd()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port)); <span class="comment">//知悉对方是谁</span></span><br><span class="line"></span><br><span class="line">        server_job(newsd); <span class="comment">// 解决sendto 问题的函数</span></span><br><span class="line">        <span class="built_in">close</span>(newsd); <span class="comment">// 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 正常情况下，执行不到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ./server</span><br><span class="line">$&gt; netstat -ant</span><br><span class="line"></span><br><span class="line">Proto Recv-Q Send-Q  Local Address    Foreign Address     State  </span><br><span class="line">tcp     0            0 0.0.0.0:1989   0.0.0.0:*           LISTEN  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提到这个 State状态，当通过ctrl+c的方式 LISTEN会变为 TIME_WAIT, 并且服务无法被客户端访问，当再次启动服务端程序时，报错，bind(): address already in use.说明 1989这个端口还在工作当中，ctrl+c属于异常结束，程序中没法正确把socket实例释放掉。</span></span><br><span class="line"><span class="comment">#当前被释放的资源 会被操作系统批量回收，也就是在说话期间，内核发现我们这个端口其实对应的socket已经被异常终止了。那么它就会帮你把这个资源释放掉。所以端口经过这个阶段就会变为一个free而可以使用的状态。再去bind就ok了。</span></span><br><span class="line"></span><br><span class="line">$&gt; nc 127.0.0.1 1989 <span class="comment"># 使用系统提供的客户端工具发送请求 没有nc 可以用 telnet代替</span></span><br><span class="line">1597216327</span><br><span class="line"></span><br><span class="line"><span class="comment">#server</span></span><br><span class="line">Client:127.0.0.1:59672</span><br></pre></td></tr></table></figure><p> client.c 是客户端，也就是主动端，它的发送端口可以不用手动指定而由操作系统来随机分配一个未被占用的端口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sd;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> stamp;    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 TCP 协议</span></span><br><span class="line">  sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">  <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">"socket()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  raddr.sin_family = AF_INET;</span><br><span class="line">  <span class="comment">// 指定服务器的端口号</span></span><br><span class="line">  raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">  <span class="comment">// 指定服务端 IP 地址</span></span><br><span class="line">  inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;raddr.sin_addr);</span><br><span class="line">  <span class="comment">// 发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">connect</span>(sd,(<span class="keyword">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">"connect()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp = fdopen(sd,<span class="string">"r+"</span>); <span class="comment">// 把scoket 返回的文件描述符 封装成一个文件流来使用</span></span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">"fdopen()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取服务端的响应，当然也可以使用 recv(3P) 函数来替代 fscanf(3) 函数。</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">fscanf</span>(fp,FMT_STAMP,&amp;stamp) &lt; <span class="number">1</span>) <span class="comment">// 标准IO来</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fscanf() failed.\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stamp = %lld\n"</span>,stamp);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-server端-并发版本重构"><a href="#1-5-2-server端-并发版本重构" class="headerlink" title="1.5.2 server端 并发版本重构"></a>1.5.2 server端 并发版本重构</h3><ul><li>发现问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c 大部分时间在此段代码中重复循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 阻塞等待新消息连接</span></span><br><span class="line">    newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perror(<span class="string">"newsd()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port)); <span class="comment">//输出连接信息</span></span><br><span class="line"></span><br><span class="line">    server_job(newsd); <span class="comment">// 主要处理请求函数， 阻塞10s，此函数阻塞10s的间隙，可能有几千个请求进来了。所以这个 请求函数应该变成一个并发的模式；</span></span><br><span class="line">    <span class="built_in">close</span>(newsd); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// sleep(10) // 假如在这里停顿10s，表示如果此函数阻塞了，那后面的请求就无法进来了</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd,newsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>/*<span class="title">local</span> <span class="title">address</span>*/, <span class="title">raddr</span> /*<span class="title">remote</span> <span class="title">address</span>*/;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 TCP 协议</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动</span></span><br><span class="line">    <span class="comment">// 会导致 bind 端口短暂失效的情况</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>; <span class="comment">// bool值，除了0就是1；</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 指定服务端使用的端口号</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经</span></span><br><span class="line"><span class="comment">     * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个</span></span><br><span class="line"><span class="comment">     * 数值的上限。</span></span><br><span class="line"><span class="comment">     * 所以backlog 现在指能能够承受C端的全链接的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 开始监听端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待新消息传入</span></span><br><span class="line">        newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"newsd()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(sd); <span class="comment">// 子进程由于会拷贝一份 父进程的所有资源，包含sd，但子进程没有用到sd，所以需要关闭</span></span><br><span class="line">            inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port)); <span class="comment">//知悉对方是谁</span></span><br><span class="line"></span><br><span class="line">            server_job(newsd); <span class="comment">// 解决sendto 问题的函数</span></span><br><span class="line">            <span class="built_in">close</span>(newsd); <span class="comment">// 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符，</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 子进程处理函数结果后，要结束进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(newsd); <span class="comment">// 同样的，newsd 复制了一份给子进程，在父进程的域内，newsd没有被引用到了，所以需要主动去释放掉；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd); <span class="comment">// 正常情况下，执行不到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结</li></ul><p>上面这个多进程版本虽然可以实现网络连接的并发问题，但假如请求服务端的客户端特别多的情况下，为每一个人都fork一个子进程。这个开销你能不能承受。又绕回去到老问题去了。实际情况下，根本没富裕的资源用来创造无限的进程空间来处理请求；</p><h3 id="1-5-3-静态进程池重构"><a href="#1-5-3-静态进程池重构" class="headerlink" title="1.5.3 静态进程池重构"></a>1.5.3 静态进程池重构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态进程池版本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCNUM   4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP,(<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_loop</span><span class="params">(<span class="keyword">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">int</span> newsd;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// server 端是作为一个守护进程在正常跑</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// accept 本身就能实现单一的链接，也就是说它本身就能实现互斥</span></span><br><span class="line">        newsd = accept(sd,(<span class="keyword">void</span> *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"newsd()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]Client:%s:%d\n"</span>,getpid(),ipstr,ntohs(raddr.sin_port)); <span class="comment">//知悉对方是谁</span></span><br><span class="line"></span><br><span class="line">        server_job(newsd); <span class="comment">// 解决sendto 问题的函数</span></span><br><span class="line">        <span class="built_in">close</span>(newsd); <span class="comment">// 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>/*<span class="title">local</span> <span class="title">address</span>*/;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 TCP 协议</span></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP,IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动</span></span><br><span class="line">    <span class="comment">// 会导致 bind 端口短暂失效的情况</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>; <span class="comment">// bool值，除了0就是1；</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 指定服务端使用的端口号</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd,(<span class="keyword">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经</span></span><br><span class="line"><span class="comment">     * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个</span></span><br><span class="line"><span class="comment">     * 数值的上限。</span></span><br><span class="line"><span class="comment">     * 所以backlog 现在指能能够承受C端的全链接的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 开始监听端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sd,<span class="number">200</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt; PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            server_loop(sd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结</li></ul><p>当前静态进程池中就四个进程，如果每个服务要10s才能完成处理函数。这四个人肯定在某个时刻都在忙着。假如C端当前来了一万+请求，其实该程序也只能忙完当前四个再去忙下四个。这个池缺乏弹性。闲时四个进程闲置，千万级别并发请求时，四个进程也没法忙过来。</p><p>该模型能优化为动态进程池，比如当前池中最少有10个进程，最多可以容纳100个进程。闲时10个进程，十个accept在等着，防止访问激增。当请求来了，这10个进程能马上进入工作。父进程来主宰进程池中的状态，当发现进程池中10个常规进程都忙去了，父进程就需要动态创建新的进程去处理新任务了。要保证进程池中至少保证有10个闲置的进程在待命，当然进程池上限不超过200个。假如客户端真的有1万+，也管不了拉。进程池上限就是200个。一万个请求总归是会服务完了，当一个用户都没有的时候，进程池资源是需要释放到掉只保留常规的10个进程即可。总之，父进程需要管理不同状态下的进程池的增删改查。</p><p>模型在大一些，可以服务一个集群，根据负载均衡将请求分发给不同的服务器去处理；</p><h3 id="1-5-4-动态进程池实现"><a href="#1-5-4-动态进程池实现" class="headerlink" title="1.5.4 动态进程池实现"></a>1.5.4 动态进程池实现</h3><p>通过这几个栗子可以看出来，TCP 一般使用 recv(3P)、send(3P) 等函数来收发数据，而 UDP 一般使用 recvfrom(3P)、sendto(3P) 等函数来收发数据。因为 TCP 一开始就创建了稳定的链接，所以在通讯的过程中就不需要每次都指定对方的地址了。而 UDP 是报式传输协议，并没有建立一个稳定的链接，所以通讯的过程中要始终指定当前这个数据报要发送到哪里，或者是指明它是从哪里来的。</p><p>最后再补充一点：如果 Ctrl+C 结束服务端，再次启动后执行 bind(2) 就会报错。</p><p>bind(): Address already in use</p><p>使用 netstat -ant 命令会发现之前的链接都没有释放，且端口也没有释放，所以由于无法监听一个没有被释放的端口就报错了。</p><p>有两种办法，一种是等一会儿就好了，另一种是使用 setsockopt(2) 函数，这个在上面 server.c 的注释中说明过了，没有注意到的童鞋请翻到上面去参考一下。</p><p>为什么等一会儿就好了呢？因为操作系统会经常检查有哪些端口被无效的进程占用了，找到了就会释放这个端口。</p><p>在 bind(2) 之前使用 setsockopt(2) 函数，将 optname 设置为 SO_REUSEADDR，它表示如果占用当前端口的程序已经消亡了，那么重新使用这个端口。</p><h3 id="1-5-5-抓包图片"><a href="#1-5-5-抓包图片" class="headerlink" title="1.5.5 抓包图片"></a>1.5.5 抓包图片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&gt; eog xy.png <span class="comment"># 打开一张图片</span></span><br><span class="line"></span><br><span class="line">$&gt; cp /home/hy/xy.png  /var/www/html/test.jpg</span><br><span class="line"></span><br><span class="line">$&gt; ls /var/www/html/test.jpg</span><br><span class="line"></span><br><span class="line">$&gt; service httpd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器</span></span><br><span class="line">127.0.0.1/test.jpg</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="2020/12/16/apue-6/"/>
      <url>2020/12/16/apue-6/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><ol><li>信号的概念</li><li>signal();</li><li>信号的不可靠</li><li>可重入函数</li><li>信号的响应过程（非常重要的图）</li><li>常用函数（kill raise alarm pause abort system sleep ）</li><li>信号集</li><li>信号屏蔽字/pending集的处理</li><li>扩展（sigsuspend sigaction setitimer）</li><li>实时信号</li></ol><h2 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h2><p>到目前为止，之前写的程序还没有一个是异步运行的，全部都是同步运行的。</p><blockquote><p>Linux 环境中的并发可以分为 多进程+信号 和 多线程两种，信号属于初级异步，多线程属于强烈异步。</p></blockquote><p>在实际项目中信号和多线程基本不会一块儿使用，要么使用 多进程+信号 的形式，要么采用多线程的形式。</p><h3 id="1-1-同步、异步，-异步意味着并发"><a href="#1-1-同步、异步，-异步意味着并发" class="headerlink" title="1.1  同步、异步， 异步意味着并发"></a>1.1  同步、异步， 异步意味着并发</h3><p>同步程序的特点是程序的执行流程、分支都是明确的。</p><p>异步事件的特点：事件到来的时间不确定，到来之后产生的结果是不确定的。比如在俄罗斯方块游戏中需要异步接收用户的方向控制输入，你永远无法知道用户什么时候按下方向键，以及按下哪个方向键。</p><h3 id="1-2-异步事件的获取方式通常只有两种：查询法，通知法"><a href="#1-2-异步事件的获取方式通常只有两种：查询法，通知法" class="headerlink" title="1.2  异步事件的获取方式通常只有两种：查询法，通知法"></a>1.2  异步事件的获取方式通常只有两种：查询法，通知法</h3><blockquote><p>如果当前这个异步时间发生的频率非常稀疏，就使用通知法。如果异步发生的频率高， 就使用主动的查询法；</p></blockquote><p>假如我们使用一个烟雾传感器监测库房中是否发生了火灾，火灾的到来的时间就是一种异步事件。</p><p>我们可以通过两种方式获取是否发生了火灾：</p><p>1）查询法：传感器将状态写到一个位图当中，我们不停的查询位图的状态来得到传感器的最新监测结果。</p><p>2）通知法：当检测到火灾时传感器推送一个消息给我们，这样我们就不用不停的查询位图了。</p><h3 id="1-3-那么什么情况使用查询法更好，什么情况使用通知法更好呢？"><a href="#1-3-那么什么情况使用查询法更好，什么情况使用通知法更好呢？" class="headerlink" title="1.3  那么什么情况使用查询法更好，什么情况使用通知法更好呢？"></a>1.3  那么什么情况使用查询法更好，什么情况使用通知法更好呢？</h3><p>异步事件到来的频率比较高的情况考虑使用查询法，因为撞到异步事件到来的概率比较高。</p><p>异步事件到来的频率比较稀疏的情况考虑通知法，因为比较经济实惠。</p><h3 id="1-4-没有严格意义上的通知法"><a href="#1-4-没有严格意义上的通知法" class="headerlink" title="1.4  没有严格意义上的通知法"></a>1.4  没有严格意义上的通知法</h3><blockquote><p>通知法的实现是需要在特定场景下的；因为通知法也必须满足一定的条件。比如订阅者需要保持接受的状态或者说保持能够准时接收到通知的状态。</p></blockquote><p>所有的通知法都需要配合一个监听机制才行。否则比如你在垂钓，放下一个鱼竿之后你就走了，就算鱼上钩了你也不可能知道。</p><p>即使计算机中没有连接任何外部硬件设备，内核每秒钟也会发生成百上千个中断来打断正在运行的程序。</p><h3 id="1-5-异步"><a href="#1-5-异步" class="headerlink" title="1.5  异步"></a>1.5  异步</h3><p>什么是真正的异步，单核的机器会出现真正意义的异步吗？</p><blockquote><p>回本溯源，不可打断的就是一条机器指令。在单核机器上，同时聊QQ，打游戏，听歌不是并发，而是大家轮流占用当前的处理器，但是每个人会有限定的时间片，当时间片耗尽，就需要进去就绪队列中排队。只不过操作系统的调度关系特别块，对于用户来讲，感知不到计算机做这样分时的实现。因此在单核机器上不会存在并发，不可能有两件事一起做的情况。</p></blockquote><p>所以在单核 CPU 上其实是不存在真正意义上的异步的，你感受到的异步无非就是时间片切换给你带来的错觉。你以为你边听音乐边写程序，这两件事是同时进行的吗？其实内核在快速的不断的打断其中一个程序，然后再让另一个程序运行一会儿，如此往复，给你一种两件事情在同时发生的错觉。</p><p>时间片调度其实就是通过中断打断程序的执行，把时间片耗尽的进程移动到队列中等待。所以任何一个进程在执行的过程中都是磕磕绊绊的不断被打断的，程序在任何地方都可能被打断，唯独一条机器指令是无法被打断的（机器指令是原子的）。</p><p>比如你在执行一句 printf(“Hello World!\n”); 的时候，看似是很流畅的打印出来了，但是执行过程中已经被打断很多次了。</p><h2 id="2-信号的概念"><a href="#2-信号的概念" class="headerlink" title="2. 信号的概念"></a>2. 信号的概念</h2><blockquote><p>信号是软件中断， 信号的响应依赖于中断</p></blockquote><p>信号不是中断，中断只能由硬件产生，信号是模拟硬件中断的原理在软件层面上进行的实现。设计信号这个机制的人，大概率有非常强的硬件中断的经验。所以在软件层面来模仿硬件的打断机制。可以使用 kill(1) 命令向其它进程查看或发送信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP          2) SIGINT          3) SIGQUIT         4) SIGILL          5) SIGTRAP         6) SIGABRT         7) SIGBUS          8) SIGFPE          9) SIGKILL        10) SIGUSR1         11) SIGSEGV        12) SIGUSR2        13) SIGPIPE        14) SIGALRM        15) SIGTERM</span><br><span class="line">16) SIGSTKFLT      17) SIGCHLD        18) SIGCONT        19) SIGSTOP        20) SIGTSTP</span><br><span class="line">21) SIGTTIN        22) SIGTTOU        23) SIGURG         24) SIGXCPU        25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM      27) SIGPROF        28) SIGWINCH       29) SIGIO          30) SIGPWR</span><br><span class="line">31) SIGSYS         34) SIGRTMIN       35) SIGRTMIN+1     36) SIGRTMIN+2     37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4     39) SIGRTMIN+5     40) SIGRTMIN+6     41) SIGRTMIN+7     42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9     44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9     56) SIGRTMAX-8     57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6     59) SIGRTMAX-5     60) SIGRTMAX-4     61) SIGRTMAX-3     62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1     64) SIGRTMAX</span><br><span class="line">$</span><br><span class="line"><span class="comment">#1 - 31 是标准信号，</span></span><br><span class="line"><span class="comment">#34 - 64 是实时信号。</span></span><br></pre></td></tr></table></figure><p><em>下面讨论的内容如果没有特殊说明则都是针对标准信号</em></p><p>信号有五种不同的默认行为：<code>终止、终止+core、忽略、停止进程、继续。</code></p><p> core 文件就是程序在崩溃时由操作系统为它生成的内存现场映像和调试信息，主要是用来调试程序的，可以使用 ulimit(1) 命令设置允许生成的 core 文件的最大大小。</p><p>1）终止：使程序异常结束。还记得我们在前面的博文中提到的程序的 3 种异常终止情况吗？其中被信号杀死就是异常终止的一种。</p><p>2）终止+core：杀死进程，并为其产生一个 core dump 文件，可以使用这个 core dump 文件获得程序被杀死的原因。</p><p>3）忽略：程序会忽略该信号，不作出任何响应。</p><p>4）停止进程：将运行中的程序中断。被停止的进程就像被下了一个断点一样，停止运行并不会再被调度，直到收到继续运行的信号。当按下 Ctrl+Z 时就会将一个正在运行的前台进程停止，其实就是向这个进程发送了一个 SIGTSTP 信号。</p><p>5）继续：使被停止的进程继续运行。只有 SIGCONT 信号具有这项功能。</p><p>这里介绍下常用的标准信号，但是有时间所有的信号都要仔细的看（见《APUE》第三版 P252 - P256）。</p><table><thead><tr><th align="left">信号</th><th align="center">默认动作</th><th align="right">说明</th></tr></thead><tbody><tr><td align="left">SIGABRT</td><td align="center">终止+core</td><td align="right">调用 abort(3) 函数会向自己发送该信号使程序异常终止，通常在程序自杀时使用。</td></tr><tr><td align="left">SIGALRM</td><td align="center">终止</td><td align="right">调用 alarm(2) 或 setitimer(2) 定时器超时时向自身发送的信号。setitimer(2) 设置 which 参数的值为 ITIMER_REAL 时，超时后会发送此信号。</td></tr><tr><td align="left">SIGCHLD（某些平台是 SIGCLD）</td><td align="center">忽略</td><td align="right">当子进程状态改变系统会将该信号发送给其父进程。状态改变是指由运行状态改变为暂停状态、由暂停状态改变为运行状态、由运行状态改变为终止状态等等。</td></tr><tr><td align="left">SIGHUP</td><td align="center">终止</td><td align="right">如果终端接口检测到链接断开则将此信号发送给该终端的控制进程，通常会话首进程就是该终端的控制进程。</td></tr><tr><td align="left">SIGINT</td><td align="center">终止</td><td align="right">当用户按下中断键(Ctrl+C)时，终端驱动程序产生此信号并发送给前台进程组中的每一个进程。大家经常使用 Ctrl + C 来杀死进程，这回知道是什么原理了吧？</td></tr><tr><td align="left">SIGPROF</td><td align="center">终止</td><td align="right">setitimer(2) 设置 which 参数的值为 ITIMER_PROF 时，超时后会发送此信号。</td></tr><tr><td align="left">SIGQUIT</td><td align="center">终止+core</td><td align="right">当用户在终端上按下退出键(Ctrl+)时，终端驱动程序产生此信号并发送给前台进程组中的所有进程。该信号与 SIGINT 的区别是，在终止进程的同时为它生成 core dump 文件。</td></tr><tr><td align="left">SIGTERM</td><td align="center">终止</td><td align="right">使用 kill(1) 命令发送信号时，如果不指定具体的信号，则默认发送该信号。</td></tr><tr><td align="left">SIGUSR1</td><td align="center">终止</td><td align="right">用户自定义的信号。有童鞋说不明白什么是用户自定义的信号，其实所谓自定义的信号就是系统不赋予它什么特殊的意义，你想用它来做什么都行，根据你的程序逻辑为它定义好相应的信号处理函数就行了。</td></tr><tr><td align="left">SIGUSR2</td><td align="center">终止</td><td align="right">另一个用户自定义的信号，作用同上。</td></tr><tr><td align="left">SIGVTALRM</td><td align="center">终止</td><td align="right">setitimer(2) 设置 which 参数的值为 ITIMER_VIRTUAL 时，超时后会发送此信号。</td></tr></tbody></table><p>表1 常见的标准信号</p><ol><li>signal(2)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal - ANSI C signal handling</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* man 手册中定义的写法 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* APUE 课本上的写法 */</span></span><br><span class="line"><span class="keyword">void</span> (*signal (<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func) (<span class="keyword">int</span>))) (<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>signal(2) 函数的作用是为某个信号注册一个信号处理函数。</p><p>课本上的写法比 man 手册中的写法更好，因为 sighandler_t 这个名字纯属手册捏造出来的，如果某一天标准库发布了一个函数的名字恰巧也叫 sighandler_t，那么手册就出问题了，这是C 语言名空间管理不善导致的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./star</span><br><span class="line"></span><br><span class="line">********** <span class="comment"># 打印十次之后进程结束，如果在没到10次时，ctrl+c 相当于SIGINT 的快捷方式</span></span><br></pre></td></tr></table></figure><p>参数列表：</p><p>　　singno：1 - 31 是标准信号，34 - 64 是实时信号，当然也可以使用 kill(1) -l 所列出的宏名；</p><p>　　func：收到信号时的处理行为，也就是信号处理函数；<br>  也可以使用 SIG_DEF 和  SIG_IGN 两个宏来替代。<br>  <code>SIG_DEF</code> 表示使用信号的默认处理行为。<br>  <code>SIG_IGN</code> 表示忽略该信号。</p><p>返回值：原来的信号处理函数。有时候我们在定义自己的信号处理函数之前会把原来的信号处理函数保存下来，这样当我们的库使用完之后需要还原原来注册的信号处理函数，避免因为调用了我们的库而导致别人的库失效的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 SIG_IGN 来忽略信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    signal(SIGINT, SIG_IGN); <span class="comment">// 忽略掉信号</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./star1</span><br><span class="line">******^C**** <span class="comment"># ctrl+c 无法阻断进程</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用回调函数来 反馈信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序运行起来之后，每秒钟会打印一个星号（*），当按下 Ctrl+C 时会打印一个感叹号（!），直到 10 秒钟后程序退出，下面是不停的按 Ctrl+C 的运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall signal.c</span><br><span class="line">$ time ./a.out</span><br><span class="line"></span><br><span class="line">*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C! <span class="comment"># 按住ctrl c不放，程序运行不到10秒就结束！</span></span><br><span class="line">real    0m1.656s</span><br><span class="line">user    0m0.000s</span><br><span class="line">sys     0m0.002s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="2-1-信号会打断阻塞的系统调用"><a href="#2-1-信号会打断阻塞的系统调用" class="headerlink" title="2.1 信号会打断阻塞的系统调用"></a>2.1 信号会打断阻塞的系统调用</h3><p>通过 time(1) 命令可以测试出来，程序并没有持续 10 秒钟才结束，这是因为信号会打断阻塞的系统调用，也就是说 SIGINT 这个信号打断了 sleep(3)。</p><p>如果加上信号机制的话，那么前面学习的例子没有一个是对的；</p><p>比如使用 read(2) 函数读取一个设备的时候，当设备中没有充足的数据供读取时，read(2) 函数会进入阻塞等待数据的状态，这时候如果收到了一个信号就会打断阻塞中的 read(2) 函数，它会设置 EINTR 的 errno。所以收到函数报错的时候往往需要判断一下是否被信号打断了，如果是被信号打断的，还要重新再执行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) <span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        dfd = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)<span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">          &#123;</span><br><span class="line">                <span class="built_in">close</span>(sfd);</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(dfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">read</span>(sfd,buf, BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)<span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR) <span class="comment">// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-竞争"><a href="#2-2-竞争" class="headerlink" title="2.2 竞争"></a>2.2 竞争</h3><p>当学习了信号之后，我们的程序中就出现异步的情况了，只要是异步的程序就可能会出现竞争，先来了解下什么是竞争。</p><p>竞争：一个十字路口没有红绿灯，两辆不同方向驶来车可能会发生碰撞，而且碰撞可能很严重也可能很轻微。当安装上红绿灯之后就相当于增加了一个协议，如果没有这个协议的限制，大家就可以随意的使用公共资源了，你在十字路口中间跳广场舞也可以。所以为了避免竞争带来的后果，我们会使用一些协议来避免竞争的发生。</p><p>当然，避免竞争的办法我们后面会讨论。</p><h2 id="3-信号的不可靠"><a href="#3-信号的不可靠" class="headerlink" title="3. 信号的不可靠"></a>3. 信号的不可靠</h2><blockquote><p>标准信号会丢失</p></blockquote><p><strong>不可靠的信号</strong></p><p>很多人看到了不可靠的信号这一章节，就认为因为额信号会丢失所以是不可靠的，其实这么理解是不对的，不可靠的信号是指信号的行为不可靠。</p><p>信号的处理就好比现在 LZ 正在写这篇博文，忽然来了一个电话，于是打断了手头的工作，先接电话去了。</p><p>信号处理函数的执行现场不是程序员布置的，而是内核布置的，因为程序中不会有调用信号处理函数的地方。 同一个信号处理函数的执行现场会被布置在同一个地方，所以当一次信号处理函数未执行完成时再次触发了相同的信号，信号处理函数发生了第二次调用，则第一次调用的执行现场会被覆盖。<br>基于此，出过各种馊主意。有用队列存的，还有不管多少信号只执行第一次的回调函数，其他时候执行默认行为的。（比如上上面的例子，第一次执行ctrl+c打印出 ！，第二次执行ctrl+c 直接取ctrl+c默认行为，把进程杀了 😳）</p><h2 id="4-可重入函数"><a href="#4-可重入函数" class="headerlink" title="4. 可重入函数"></a>4. 可重入函数</h2><blockquote><p>所有的系统调用都是可重入的，一部分库函数也是可重入的。尤其是返回值是一个指针的函数。比如说： memcpy</p></blockquote><p>函数重入乍一看上去像是递归，但又是有区别的，递归调用的现场是程序员布置的，而重入是在一个函数执行未结束时再次发生了调用并且进入了同一个函数现场。</p><p>重入时函数会发生错误的函数称为“不可重入函数”，重入不会出现错误的函数叫做“可重入函数”。</p><p>所有的系统调用都是可重入函数，所以信号处理函数中可以放心的使用系统调用。但并不是说所有的非系统调用都是不可重入的。</p><p>man 手册所有的函数中如果有一个同名的带 <code>_r</code> 后缀的函数，<br>那么不带<code>_r</code> 后缀的函数是不可重入的函数，<br>而带 <code>_r</code> 后缀的函数是可重入的函数。比如下面这两个常见的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// strerror,  strerror_r - return string describing error number</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strerror_r</span><span class="params">(<span class="keyword">int</span> errnum, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen)</span></span>;</span><br><span class="line"><span class="comment">/* XSI-compliant */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror_r</span><span class="params">(<span class="keyword">int</span> errnum, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen)</span></span>;</span><br><span class="line"><span class="comment">/* GNU-specific */</span></span><br></pre></td></tr></table></figure><h2 id="5-信号的响应过程"><a href="#5-信号的响应过程" class="headerlink" title="5. 信号的响应过程"></a>5. 信号的响应过程</h2><blockquote><p>这部分知识涉及调度问题，信号软件层面的中断，</p></blockquote><ul><li>信号从收到到响应是有一个不可避免的延迟，</li><li>思考： 如何忽略掉一个信号的？</li><li>思考： 标准信号为什么要丢失</li><li>标准信号的响应没有严格的顺序（先响应哪个不知道，可能会根据优先级大小决定响应顺序，碰到优先级差不多的响应顺序不确定）</li><li>不能从信号处理函数中随意的往外跳</li></ul><p><strong>信号从收到到响应是有一个不可避免的延迟</strong></p><p>因为只收到信号是体现在padding位图上，由0变成了1.要有中断来打断才能够去内核排队。从kernel回到user的时候，要做 mask&amp;padding 按位与才能看到这个信号。所以，信号就有一个不可避免的时延；</p><p><strong>如何忽略掉一个信号的？</strong></p><p>把某个信号的mask位永远置成0；</p><p><strong>标准信号为什么要丢失</strong></p><p>位图，一万次1还是1，最终在执行信号回调的时候是需要 mask&amp;padding的， 通过这个按位与的结果来决定是否有收到该信号的</p><ul><li>先把模型缩小</li></ul><p>当程序在正常运行的时候，mask为1，padding为0；突然接到一个信号，mask继续是1，padding 变成了1. 这个时候被中断打断了，加内核排队。等待调度的时候往外走，当从kernel态回到user态的时候。拿 mask&amp;padding 做一个按位与，发现收到了1个信号了。然后再执行信号响应回调的时候，把mask和padding都置成0的，然后去执行响应回调。等执行完响应之后，把mask置成1.padding继续保持是0. 然后再做一次按位与，ok，发现没有信号了。然后程序执行其他的去了。</p><ul><li>再把模型放大</li></ul><p>当前没有信号的时候，mask为1，padding为0（初始化的状态）。当执行过程中，收到信号了，mask继续是1，padding变成1. 然后继续 中断。。排队。。调度。。kernel -》user 。。按位与。。。发现有信号。。执行响应回调前， 把 mask 和 padding 都置成0. 在这个时候又来了一个或者十万个信号，那么 mask继续是0， 而padding 被反复置换成1（置1次1，或者十万次1，位图不会累加，不会计数，不管多少次1，最终还是1）.所以这里会丢失信号。</p><p><strong>标准信号的响应没有严格的顺序</strong></p><p><strong>不能从信号处理函数中随意的往外跳</strong></p><h3 id="6-1-可靠信号术语和语义"><a href="#6-1-可靠信号术语和语义" class="headerlink" title="6.1 可靠信号术语和语义"></a>6.1 可靠信号术语和语义</h3><p>这是信号这章比较重要的内容，通过这个我们来了解信号在 Linux 系统中是如何实现的。</p><p><img src="./signal_01.png" alt=""><br>图1 标准信号的处理过程（从进程角度来分析应该的响应过程）</p><p>进程线程并不分家，从内核的角度来看，当前操作的任务只有一个，叫线程。从开发者的角度来讲，先产生的概念叫进程，后来发现其实不是这么回事儿，其实细化到线程来进行调度。进程是容器。所以进程和线程其实是 开发者角度去区分的。从内核的角度来讲，内核只有进程一个概念。<br>进程线程不分家，开发者完全可以做出既不是线程也不是进程的东西来使用。</p><p>内核为每个进程维护了一组位图（两个位置），mask（信号屏蔽字）和 padding， 理论来讲， mask 和 padding都是 32位的。mask用来表示当前的信号的状态，padding是一个位图，用来记录当前这个进程收到哪些信号。</p><p>mask屏蔽字的值一般情况下都是1，padding位初始值一上来初始值为0。<br>都知道程序会被中断（打断），举个例子，比如说时间片耗尽了，实际上也可以理解为某种形式反映给你的中断。然后要抱着当前的执行现场扎内核（把当前的执行现场压栈存放，相当于整个进程暂停起来，然后去到内核）。内核中有个等待调度的就绪队列，然后在那里进行排队。排队等待调度到你的时候，别人把调度器出让给你。这个时候相当于你重新被调用。然后再从刚才（刚才已经压栈了一个现场）的现场进程恢复，来继续进行下面的程序。然后在执行过程当中，又被别人打断了。然后重复前面说的过程。继续压栈，排队，等待调度，恢复现场执行等等这样一个过程。</p><p>mask 和 padding 位图是一一对应的，它们用于反映当前进程信号的状态。每一位代表了一个标准信号。</p><p>mask 位图用于记录哪些信号可以响应。1 表示该信号可以响应，0 表示该信号不可响应（会被忽略）。</p><p>padding 位图用于记录收到了哪些信号。1 表示收到了该信号，0 表示没有收到该信号。</p><p>前面说过了，程序在执行的过程中会被内核打断无数次，也就是说程序被打断后要停止手头的工作，进入一个队列排队等待再次被调度才能继续工作。</p><p>当进程获得调度机会后，从内核态返回到用户态之前要做很多事情，其中一件事就是将 mask 位图和 padding 位图进行 &amp; 运算，当计算的结果不为 0 时就需要调用相应的信号处理函数或执行信号的默认动作。</p><p>这就是 Linux 的信号处理机制，从这个机制中，我们可以总结出几个信号的特点：</p><p>1）如果想要屏蔽某个信号，只需将对应的 mask 位 置为 0 即可。这样当程序从内核态返回用户态进行 mask &amp; padding 时，该信号位的计算结果一定为 0。</p><p>2）信号从收到到响应是存在延迟的，一般最长延迟 10 毫秒。因为只有程序被打断并且重新被调度的时候才有机会发现收到了信号，所以当我们向一个程序按下 Ctrl+C 时程序并没有立即挂掉，只不过这个时间非常短暂我们一般情况下感觉不到而已，我们自己以为程序是立即挂掉了。其实想要实验也很容易，写一个死循环不断打印一个字符，然后在它跑起来的时候按下 Ctrl+C，你会发现并不是打印了 ^C 之后程序会立即停止，而是继续打印了一些字符之后才停止。</p><p>3)当一个信号没有被处理时，无论再次接受到多少个相同的信号都只能保留一个，因为 padding 是位图，位图的特点就是只能保留最后一次的状态。这一点说的就是标准信号会丢失的特点，如果想要不丢失信号就只能使用实时信号了。</p><p>4）信号处理函数轻易不允许使用 longjmp(3) 进行跨函数跳转。因为处理信号之前系统会把 mask 对应的位设置为 0 来避免信号处理函数重入，当信号处理完成之后系统会把对应的 mask 位设置为 1 恢复进程对该信号的响应能力。如果进行了长跳转系统就不会恢复 mask 位图了，也就再也无法收到该信号了。其实这个图只是一个草图，信号实际上是线程级别的（这个我们在后面讲到线程的时候会详细讨论），所以即使 mask 位图在处理前被置为 0，依然有可能出现重入的现象，因为无法保证兄弟线程也同步屏蔽了相应的位。</p><p>5）信号处理函数的执行时间越短越好，因为信号处理函数是在用户态执行的，在它的执行过程中也会不停的被内核打断，所以如果信号处理函数执行的时间过长会使情况变得复杂。</p><p>6）信号的响应是嵌套执行的。就是说假设进程先收到了 SIGINT 信号，当它的信号处理函数还没有执行完毕时又收到了另一个信号 SIGQUIT，那么当进程从内核态返回到用户态时会优先执行 SIGQUIT 的信号处理函数，等 SIGQUIT 的信号处理函数执行完毕后再回到 SIGINT 信号处理函数上次被打断时的地方继续执行，函数调用栈看上去就像在 SIGINT 的信号处理函数中调用了 SIGQUIT 的信号处理函数一样。这也是上面所说的为什么信号处理函数的执行时间要越短越好，要尽量避免这种复杂的情况发生。</p><p>7）如果同时到来多个优先级差不多的信号，无法保证优先响应哪个信号，它们的响应没有严格意义上的顺序。除非是收到了优先级较高的信号，系统会保证高优先级的先被处理。</p><h3 id="6-2-信号处理函数"><a href="#6-2-信号处理函数" class="headerlink" title="6.2 信号处理函数"></a>6.2 信号处理函数</h3><blockquote><p>信号处理函数 尽量使用可重入的函数，系统调用可以，一部分库函数可以。然后由于在信号当中不能用到大家都在用的东西，防止产生竞争和冲突，比如标准IO是不能用在信号处理函数当中的。因为公用缓冲区，防止别人在用缓冲区，自己也在用缓冲区。就会存在问题。信号处理函数还应该做到尽量小，小到尽量能够一闪而过才好。</p></blockquote><h2 id="6-信号常用函数"><a href="#6-信号常用函数" class="headerlink" title="6. 信号常用函数"></a>6. 信号常用函数</h2><p><code>kill raise alarm pause abort system sleep</code></p><h3 id="6-1-kill-2"><a href="#6-1-kill-2" class="headerlink" title="6.1 kill(2)"></a>6.1 kill(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kill - send a signal to a process or a group of processes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>kill(2) 函数的作用是将指定的信号(sig)发送给指定的进程(pid)。</p><p>大家一看到 kill 就觉得有杀死进程的意味，其实未必如此，kill(3) 也负责给进程发送各种信号。</p><p>参数列表：</p><p>pid：接收信号的进程 ID。可填的内容详见下表：</p><table><thead><tr><th align="left">值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">&gt;0</td><td align="center">接收信号的进程 ID。</td></tr><tr><td align="left">==0</td><td align="center">发送信号给当前进程所在进程组的所有进程。</td></tr><tr><td align="left">==-1</td><td align="center">发送信号给当前进程有权向它们发送信号的所有进程，1 号 init 进程除外。相当于一个全局广播信号，发送这种信号一般只有 1 号 init 会做，比如在关机的时候 init 进程会发送全局广播信号通知大家该结束了。</td></tr><tr><td align="left">&lt;-1</td><td align="center">将 pid 的绝对值作为组 ID，给这个组中所有的进程发送信号。</td></tr><tr><td align="left">表2 kill(2) 函数 pid 参数的取值</td><td align="center"></td></tr></tbody></table><p>　　sig：要发送的信号，可以使用 kill(1) -l 所列出的信号。如果 sig 是 0 会执行所有的错误检查，但并不真正发送信号。所以通常使用 0 值检查一个进程是否仍然存在，如果该进程不存在则返回 -1 并将 errno 设置为 ESRCH。需要注意的是这种检查并不原子，当 kill(2) 返回测试结果的时候也许被测试的进程已经终止了。当然也可以测试当前进程是否对目标进程有权限发送信号，如果 errno 为 EPERM 表示被测试的进程存在但当前进程无权限访问。</p><p>返回值：成功为 0，失败为 -1，并设置 errno。</p><h3 id="6-2-raise"><a href="#6-2-raise" class="headerlink" title="6.2 raise"></a>6.2 raise</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send a signal to the caller 对当前进程发一个信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法 单线程模式 相当于</span></span><br><span class="line">kill(getpid(), sig); <span class="comment">// 以进程单位发信号</span></span><br><span class="line"><span class="comment">// 此方法 多线程模式 相当于</span></span><br><span class="line">pthread_kill(pthread_self());  <span class="comment">// 以线程为单位发</span></span><br></pre></td></tr></table></figure><h3 id="6-3-pause-3P"><a href="#6-3-pause-3P" class="headerlink" title="6.3 pause(3P)"></a>6.3 pause(3P)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pause - wait for signal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>专门用于阻塞当前进程，等待一个信号来打断它。</p><h3 id="6-4-alarm-3P"><a href="#6-4-alarm-3P" class="headerlink" title="6.4 alarm(3P)"></a>6.4 alarm(3P)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alarm - schedule an alarm signal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure><p>指定  seconds 秒，发送一个 SIGALRM 信号给自己。</p><p>seconds 为 0 的时候，表示取消这个定时器，并且新设置的值会覆盖上次设置的值。所以当程序中出现了多个对 alarm(3P) 的调用时，计时是不准确的。</p><p><strong>思考： 那如何用一个单一的计时器，来实现一个多任务的计时器</strong></p><p>注意，SIGALRM 信号默认动作是杀死进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    alarm(<span class="number">1</span>); <span class="comment">// 新设置的值会覆盖上次设置的值。</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 秒 之后结束程序</span></span><br><span class="line"><span class="comment">// alarm没办法实现多任务的 计时器</span></span><br></pre></td></tr></table></figure><p>上面提到 新设置的值会覆盖上次设置的值，当程序中出现了多个对 alarm(3P) 的调用时，计时是不准确的。</p><p>sleep -&gt; alarm + pause</p><p><strong>尽量不要用sleep的原因</strong></p><blockquote><p>是因为在有些环境下， sleep是用 alarm 和 pause 封装的。 有些环境的sleep是用nanosleep封装的。所以考虑移植的情况下，不要在程序中使用 sleep。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">5</span>); <span class="comment">// 5秒后 杀死进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        pause(); <span class="comment">// 阻塞当前进程，等待信号</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时循环实验</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5sec.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">end</span> = time(<span class="literal">NULL</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(time(<span class="literal">NULL</span>) &lt;= <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">time ./5sec &gt; /tmp/out</span><br><span class="line"></span><br><span class="line">5.49s user</span><br><span class="line">0.00s system</span><br><span class="line">94% cpu</span><br><span class="line">5.831 total</span><br><span class="line"></span><br><span class="line">cat /tmp/out</span><br><span class="line">2044174125</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line">    alarm(<span class="number">5</span>); <span class="comment">// 5秒钟后杀掉进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count); <span class="comment">// 5秒后进程被杀，没机会打印printf了</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该功能无法通过 这种方式来实现</span></span><br></pre></td></tr></table></figure><p>我们来看看代码 count_alarm.c、count_time.c，哪个效率更高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* count_alarm.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alarm_handler</span> <span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意 signal 再 alarm之前</span></span><br><span class="line">    signal(SIGALRM, alarm_handler); <span class="comment">// 先设置信号回调</span></span><br><span class="line">    alarm(<span class="number">5</span>);  <span class="comment">// 再设置时钟</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* count_time.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (time(<span class="literal">NULL</span>) &lt; t) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ make count_alarm count_time</span><br><span class="line">cc     count_alarm.c   -o count_alarm</span><br><span class="line">cc     count_time.c   -o count_time</span><br><span class="line">$ time ./count_alarm</span><br><span class="line">2374311494</span><br><span class="line"></span><br><span class="line">real    0m5.004s</span><br><span class="line">user    0m4.780s</span><br><span class="line">sys    0m0.194s</span><br><span class="line">$ time ./count_time</span><br><span class="line">2139947</span><br><span class="line"></span><br><span class="line">real    0m4.152s</span><br><span class="line">user    0m4.116s</span><br><span class="line">sys    0m0.021s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>通过执行结果可以看出来，alarm(3P) 的方式和 time(2) 的方式执行效率竟然差了 1000 多倍，当然这个简单的测试精度是不高的。</p><p>上面的代码通过 gcc count_alarm.c -O1 优化之后就无法正确执行了。</p><p>我们先把 count_alarm.c 编译成汇编代码再讨论它为什么被优化之后无法正确执行了。</p><p>优化前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ gcc -S count_alarm.c -o count_alarm.S</span><br><span class="line">&gt;$ vim count_alarm.S</span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">alarm_handler:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    <span class="variable">$0</span>, flag(%rip)   ; 修改 flag 的值</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    <span class="variable">$alarm_handler</span>, %esi</span><br><span class="line">    movl    <span class="variable">$14</span>, %edi</span><br><span class="line">    call    signal</span><br><span class="line">    movl    <span class="variable">$5</span>, %edi</span><br><span class="line">    call    alarm</span><br><span class="line">    movl    <span class="variable">$1</span>, flag(%rip)</span><br><span class="line">    jmp    .L4</span><br><span class="line">.L5:</span><br><span class="line">    movq    count(%rip), %rax</span><br><span class="line">    addq    <span class="variable">$1</span>, %rax</span><br><span class="line">    movq    %rax, count(%rip)</span><br><span class="line">.L4:</span><br><span class="line">    movl    flag(%rip), %eax</span><br><span class="line">    testl    %eax, %eax        ; 每次循环会检测 flag 的值是否改变</span><br><span class="line">    jne    .L5</span><br><span class="line">    movq    count(%rip), %rdx</span><br><span class="line">movl    $.LC0, %eax</span><br><span class="line">    movq    %rdx, %rsi</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    movl    <span class="variable">$0</span>, %eax</span><br><span class="line">    call    <span class="built_in">printf</span></span><br><span class="line">movl    <span class="variable">$0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">    ; ...... 省略不相关代码</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ gcc -S count_alarm.c -O1 -o count_alarm1.S</span><br><span class="line">&gt;$ vim count_alarm1.S</span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">alarm_handler:</span><br><span class="line">.LFB21:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    movl    <span class="variable">$0</span>, flag(%rip)    ; 修改 flag 的值</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">    ; ...... 省略不相关代码</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">.LFB22:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    subq    <span class="variable">$8</span>, %rsp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    movl    <span class="variable">$alarm_handler</span>, %esi</span><br><span class="line">    movl    <span class="variable">$14</span>, %edi</span><br><span class="line">    call    signal</span><br><span class="line">    movl    <span class="variable">$5</span>, %edi</span><br><span class="line">    call    alarm</span><br><span class="line">    movl    <span class="variable">$1</span>, flag(%rip)</span><br><span class="line">.L4:</span><br><span class="line">    jmp    .L4                ; 变成了死循环</span><br><span class="line">    .cfi_endproc</span><br><span class="line"></span><br><span class="line">; ...... 省略不相关代码</span><br></pre></td></tr></table></figure><p>从上面的代码不难看出，优化时编译器认为 flag 的值一直没有改变，所以直接把 flag 的值拿过来作为循环条件了，每次循环的时候不再从 flag 变量所在的内存位置取值了。</p><p>为了避免编译器犯这种错误，我们需要把 flag 定义成 volatile 变量，volatile 关键字表示一定要到变量定义的位置取变量的值，而不要轻信曾经拿到的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mycat 初步实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  do&#123;</span></span><br><span class="line"><span class="comment">//     dfd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0600);</span></span><br><span class="line"><span class="comment">//     if (dfd &lt; 0)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(errno != EINTR)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//                 close(sfd);</span></span><br><span class="line"><span class="comment">//                 perror("open()");</span></span><br><span class="line"><span class="comment">//                 exit(1);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">// &#125; while(dfd &lt; 0);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    len = <span class="built_in">read</span>(sfd,buf, BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perror(<span class="string">"read()"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"write()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        pos += ret;</span><br><span class="line">        len -= ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(dfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-流量控制（流控算法）"><a href="#6-5-流量控制（流控算法）" class="headerlink" title="6.5 流量控制（流控算法）"></a>6.5 流量控制（流控算法）</h3><p>播放音乐和电影的时候都要按照播放的速率读取文件，而不能像 cat(1) 命令一样，直接将交给它的文件用最快的速度读取出来，否则你听到的音乐就转瞬即逝了。</p><p>我们先通过一个栗子了解下什么是流量控制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slowcat 的实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    loop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!loop)</span><br><span class="line">        &#123;</span><br><span class="line">            pause();  <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len = <span class="built_in">read</span>(sfd,buf, BUFSIZE))&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 假如读取的 sfd 是一个设备，现在这个 设备没有数据，我们都知道程序中信号总会到来，所以 一直 continue， 程序就在这个while语句里面一直打转。</span></span><br><span class="line">        <span class="comment">// 另外，如果当前数据量非常大的话，那程序在这里也无能为力，因为1秒钟也只能读取 10个字节。</span></span><br><span class="line">        <span class="comment">// 这里是一个 漏桶的实现，可以看见 当前数据量不管有多少，这里只慢慢的10个字节10个字节的读。如果没有数据也只能闲着。读不到东西，假错，continue，死循环。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面文件 IO 的部分我们做过一个栗子 mycp，用来模仿 cp(1) 命令。这次我们把它修改为 mycat，用来模仿 cat(1) 命令，并且是慢慢的 cat，每秒钟输出 10 个字节的数据。</p><p>这个流控方案就是漏桶：当没有数据可读的时候就是闲着，并没有积攒权限，所以当数据再次可读的时候它的速率不会变。</p><p>我们前面提到过，stream 这种东西并非像小河流水一样是非常均匀的潺潺细流，而是要么没有数据，要么一下子来一大坨。如果用漏桶处理这种情况速度会非常慢，那么有没有什么更好的流控方案呢？当然有，用令牌桶来处理就可以很好的解决这种流量激增的情况。</p><p>令牌桶闲着的时候在积攒权限，既然有1秒钟可以传输10个字节的权限，那就攒着。如果暂停3秒钟，就攒下了传输30个字节的权限。这个时候突然来了一大波数据，然后瞬间就可以把这30个字节都解决掉。权限没有了，就只能一秒钟10个字节 10个字节的走。这种就叫做令牌桶</p><p>所以实际使用时令牌同比漏桶用得更普遍。</p><p>具体要用哪种桶需要根据实际需求来决定，比如在线听音乐的时候网速不好，不能等数据来了的时候用最快的速度把之前积攒了权限的数据一下子都播放出来，应当还保持原来的速率播放，所以这时候选择漏桶就更加合适了。</p><p>下面我们重构一下上面的漏桶流控代码，把它改成令牌桶的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10 <span class="comment">// 流量速率</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BURST 100 <span class="comment">// 令牌上限</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 积攒的令牌数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> token = <span class="number">0</span>; <span class="comment">// sig_atomic_t 信号原子类型，保证该类型的取值和赋值操作一定是一条机器指令</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    token++;</span><br><span class="line">    <span class="keyword">if</span>(token &gt; BURST)</span><br><span class="line">        token = BURST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (token &lt;= <span class="number">0</span>) &#123; <span class="comment">// 如果令牌数量不足则等待添加令牌</span></span><br><span class="line">            pause(); <span class="comment">// 因为添加令牌是通过信号实现的，所以可以使用 pause(2) 实现非忙等（通知法）</span></span><br><span class="line">        &#125;</span><br><span class="line">        token--; <span class="comment">// 每次读取 BUFSIZE 个字节的数据时要扣减令牌</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len = <span class="built_in">read</span>(sfd,buf, BUFSIZE))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这只是一个简单的令牌桶的雏形，不过已经足以让我们了解令牌桶的工作原理了。</p><p>令牌桶的三要素：令牌、令牌上限、流量速率（CPS）。</p><p>从上面的代码可以看出来：SIGALRM 的回调函数负责向令牌桶中添加令牌，而每次读取数据之前要先检查令牌的剩余数量。如果令牌充足则扣减令牌后开始读取数据，如果令牌数量不足则阻塞等待 SIGALRM 回调函数向令牌桶中补充令牌。</p><p>设计令牌上限是为了防止令牌桶溢出，通常没必要让令牌无限制的上涨。</p><h3 id="6-6-封装令牌桶库"><a href="#6-6-封装令牌桶库" class="headerlink" title="6.6 封装令牌桶库"></a>6.6 封装令牌桶库</h3><p>用户进行一个程序当中多个不同速率的流控的时候，该如何去做。</p><p><img src="./mytbf.png" alt=""></p><p>把行为封装起来，把更改属性的接口暴露给用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytbf.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span>* <span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> inited = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sighandler_t</span>  alrm_handler_save;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;</span><br><span class="line">    <span class="keyword">int</span> burst;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    signal(SIGALRM, alrm_handler_save);</span><br><span class="line">    alarm(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(job[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">get_free_pos</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i]!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">            <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alrm_handler_save = signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inited)</span><br><span class="line">    &#123;</span><br><span class="line">        module_load();</span><br><span class="line">        inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = get_free_pos();  <span class="comment">// 在数组中 找空位</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me; <span class="comment">//将该结构体存储至 数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> * ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    job[me -&gt; pos] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytbf.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTBF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_MAX 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">mytbf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> * <span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BURST 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>  **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd=<span class="number">1</span>;  <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">mytbf_t</span> *tbf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    tbf =  mytbf_init(CPS, BURST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tbf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mutbf_int() failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">        <span class="built_in">size</span> = mytbf_fetchtoken(tbf, BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mytbf_fetchtoken():%s"</span>, strerror(-<span class="built_in">size</span>));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len = <span class="built_in">read</span>(sfd,buf, <span class="built_in">size</span>))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> - len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mytbf_returntoken(tbf, <span class="built_in">size</span>-len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">write</span>(dfd, buf+pos, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(dfd);</span><br><span class="line">    mytbf_destroy(tbf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7-实现计时器"><a href="#6-7-实现计时器" class="headerlink" title="6.7 实现计时器"></a>6.7 实现计时器</h3><blockquote><p>使用单一计时器，利用alarm或setitimer构造一组函数，实现任意数量的计时器（alarm实现）</p></blockquote><p>什么是单一计时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alarm(<span class="number">1</span>);</span><br><span class="line">alarm(<span class="number">5</span>);</span><br><span class="line">alarm(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 比如三个 alarm，其实只有最后一个 alarm有效；</span></span><br><span class="line"><span class="comment">// 但能不能实现一个计时器，使 1分钟时 提示一下，5分钟时提示一下，10分钟时提示一下</span></span><br></pre></td></tr></table></figure><p>getitimer(3P) 和 setitimer(3P) 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getitimer, setitimer - get or set value of an interval timer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getitimer</span><span class="params">(<span class="keyword">int</span> which, struct itimerval *curr_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br></pre></td></tr></table></figure><p>setitimer(2) 函数可以用来替代 alarm(2) 函数。</p><p>setitimer(2) 函数主要有两点比 alarm(2) 函数更好：</p><p>setitimer 函数没有延迟累计的；</p><p>1）setitimer(2) 函数可以使用精度更高的微秒为计时单位； alarm只能按秒计数 </p><p>2）从 it_interval 赋值给 it_value 是采用原子操作的。</p><p>setitimer(2) 直接可以构成一个类似 alarm(2) 链的执行结构。也就是说当 it_value 的值被递减为 0 时会发送一个信号给当前进程，并且自动将 it_interval 的值赋给 it_value 使计时重新开始。</p><p>参数列表：</p><p>which：使用不同的时间，并发送不同的信号；详见下表（其实在 表1 中我们也提到它们了）</p><table><thead><tr><th align="left">which 可选宏值</th><th align="center">对应的信号</th></tr></thead><tbody><tr><td align="left">ITIMER_PROF</td><td align="center">SIGPROF</td></tr><tr><td align="left">ITIMER_REAL</td><td align="center">SIGALRM</td></tr><tr><td align="left">ITIMER_VIRTUAL</td><td align="center">SIGVTALRM</td></tr></tbody></table><p>表3 which 与对应的信号</p><p>　　new_value：新的定时器周期；这个结构体的定义可以见下面的说明。</p><p>　　old_value：由该函数回填以前设定的定时器周期，不需要保存可以设置为 NULL；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* next value */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递减的是 it_value 的值，当 it_value 被递减为 0 的时候将 it_interval 的值 原子化 的赋给 it_value。</p><p>tv_sec 表示以秒为单位；tv_usec 表示以微秒为单位。使用一种计时方式时，另一种必须设置为 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 setitimer 重构的漏桶程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//alarm(1);</span></span><br><span class="line">    loop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sfd, dfd = <span class="number">1</span>; <span class="comment">// 目标文件改成标准输出位，1号文件描述符即标准输出位</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage .... \n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">signal(SIGALRM, alrm_handler);</span><br><span class="line"><span class="comment">// alarm(1);</span></span><br><span class="line">itv.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">itv.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">itv.it_value.tv_sec = <span class="number">1</span>;</span><br><span class="line">itv.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (setitimer(ITIMER_REAL, &amp;itv, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"setitimer()"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">sfd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open()"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (sfd &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!loop)</span><br><span class="line">&#123;</span><br><span class="line">pause();</span><br><span class="line">&#125;</span><br><span class="line">loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((len = <span class="built_in">read</span>(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">perror(<span class="string">"read()"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">write</span>(dfd, buf + pos, len);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">perror(<span class="string">"write()"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">pos += ret;</span><br><span class="line">len -= ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  sleep(1);  sleep可以帮助程序实现这个功能，但是不建议在线上程序使用sleep函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(dfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-8-sleep"><a href="#6-8-sleep" class="headerlink" title="6.8 sleep"></a>6.8 sleep</h3><blockquote><p>有些平台的sleep 是 用alarm + pause封装的，因此当程序出现多个alarm函数时， sleep是会出错的</p></blockquote><h3 id="6-9-nanosleep"><a href="#6-9-nanosleep" class="headerlink" title="6.9 nanosleep"></a>6.9 nanosleep</h3><blockquote><p>可以用来替换sleep</p></blockquote><h3 id="6-10-usleep"><a href="#6-10-usleep" class="headerlink" title="6.10 usleep"></a>6.10 usleep</h3><h3 id="6-11-abort-3"><a href="#6-11-abort-3" class="headerlink" title="6. 11 abort(3)"></a>6. 11 abort(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abort - cause abnormal process termination</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>给调用者发送一个 SIGABRT 信号，收到这个信号的默认动作是终止 + 产生 coredump 文件。</p><p>我们在上面的 表1 中提到过它，一般都是程序发现自己出现了明显的异常，为了避免缺陷扩散，自杀的时候使用。</p><h3 id="6-12-system-3"><a href="#6-12-system-3" class="headerlink" title="6.12 system(3)"></a>6.12 system(3)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//system - execute a shell command</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure><p>在前面介绍进程相关的博文中我们介绍过 system(3) 函数，所以对于它的功能我们这里就不再赘述了，今天聊点关于它与信号的花边新闻。</p><p>对于它的使用有一些需要注意的内容，想要正确的使用 system(3) 函数，必须阻塞 SIGCHLD 信号并忽略 SIGINT、SIGQUIT 信号。</p><p>为什么使用 system(3) 函数之前要做这些动作呢？这与 shell 的内部命令处理有关系，如果想要了解更详细的内容，请自行参阅 《APUE》 第三版第九章。</p><h3 id="6-13-select-2"><a href="#6-13-select-2" class="headerlink" title="6.13 select(2)"></a>6.13 select(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select,  pselect - synchronous I/O multiplexing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to POSIX.1-2001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">        fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>其实 sleep(3) 函数是不好用的，因为某些平台上是使用 alarm(2) + pause(2) 封装它的，大家知道 alarm(2) 的计时是不太准确的。</p><p>在当前平台（Linux）sleep(3) 函数是使用 nanosleep 封装的，所以如果不考虑移植的话在当前平台上可以安全的使用 sleep(3) 函数。</p><p>其实 usleep(3)、nanosleep(2)、select(2) 这些函数都比 sleep(3) 好用。</p><p>select 我们在第14章还会讲，这里说一下利用它的副作用来为我们实现一个安全的定时器。</p><p>这样设定它的参数列表就可以了：-1, NULL, NULL, NULL, 定时结构体。</p><p>本来不打算贴出代码的，但是后来 LZ 发现用 select(2) 作为计数器使用的时候有几个坑，有必要在这里强调一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * struct timeval 结构体表示剩余的时间</span></span><br><span class="line"><span class="comment">        * select(2) 函数内部会修改这个结构体的值</span></span><br><span class="line"><span class="comment">        * 如果把这两行写在循环上面...</span></span><br><span class="line"><span class="comment">        * 效果大家可以自己测试一下</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        timeout.tv_sec = <span class="number">1</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 作为定时器使用时只给时间就行了，其它参数都填 0。</span></span><br><span class="line">        <span class="keyword">if</span> (select(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, &amp;timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"select()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果不写 \n，那么程序会在结束的时候把所有的haha显示出来，</span></span><br><span class="line"><span class="comment">        * 而不是在每次循环的时候都显示，</span></span><br><span class="line"><span class="comment">        * 原因很简单，在前面我们讨论 IO 的时候就讨论过，</span></span><br><span class="line"><span class="comment">        * 默认情况下标准输出是行缓冲模式。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hehe\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-信号集"><a href="#7-信号集" class="headerlink" title="7. 信号集"></a>7. 信号集</h2><p>信号集就是一种能表示一组信号的数据类型，一般都是用在批量设置信号掩码时使用。</p><p>信号集使用 sigset_t 类型表示，有一组函数可以操作它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal set operations</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure><p>这一组函数的作用无非就是对信号集中的信号进行曾删改差，具体的用法各位可以自行查阅 man 手册。</p><h2 id="8-信号屏蔽字-pending集的处理"><a href="#8-信号屏蔽字-pending集的处理" class="headerlink" title="8. 信号屏蔽字/pending集的处理"></a>8. 信号屏蔽字/pending集的处理</h2><h3 id="8-1-sigprocmask-2"><a href="#8-1-sigprocmask-2" class="headerlink" title="8.1 sigprocmask(2)"></a>8.1 sigprocmask(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigprocmask - examine and change blocked signals</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure><p>前面我们提到过我们可以人为的干扰信号 mask 位图，唯一的途径就是通过这个函数实现。但是 padding 位图是无法人为干扰的。</p><p>我们不能保证信号什么时候来，使用这个函数的目的就是为了让我们来决定什么时候响应信号。</p><p>参数列表：</p><p>how：指定如何来干扰 mask 位图，可以使用下表中三个宏中的任何一个来指定；</p><table><thead><tr><th align="left">宏</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">SIG_BLOCK</td><td align="center">将当前进程的信号屏蔽字和 set 信号集中的信号全部屏蔽，也就是将它们的 mask 位设置为 0</td></tr><tr><td align="left">SIG_UNBLOCK</td><td align="center">将 set 信号集中与当前信号屏蔽字重叠的信号解除屏蔽，也就是将它们的 mask 位设置为 1</td></tr><tr><td align="left">SIG_SETMASK</td><td align="center">将 set 信号集中的信号 mask 位设置为 0，其它的信号全部恢复为 1</td></tr><tr><td align="left">表4 干扰 mask 位图的方式</td><td align="center"></td></tr></tbody></table><p>　　set：需要被干扰 mask 位图的信号集；</p><p>　　oldset：由该函数回填之前被干扰的信号集。</p><p>使用这个函数，我们来重构上面那个打印星号和感叹号的程序，新需求是这样的：</p><p>每行打印 5 个星号，然后停止。期间如果收到了 SIGINT 信号不会立即响应，而是等待本行打印结束后再响应，并且在收到信号之后再打印下一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal(SIGINT, SIG_IGN);</span></span><br><span class="line">    signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原blog</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"!"</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oset,saveset; <span class="comment">// saveset 用来保存当前状态</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于下面三行的原子操作</span></span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sigset_t tmpset;</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK,&amp;oset,&amp;tmpset);</span></span><br><span class="line"><span class="comment">        pause();</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK,&amp;tmpset,NULL);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的实现思路是：开始打印每行星号之前先屏蔽信号，当打印完成之后再恢复信号，然后等待被信号打断，再重新屏蔽信号，打印星号。</p><p>但是在测试的时候会发现，这样只能实现当一行信号打印完毕时可以停住，然后按下 Ctrl+C 发送信号，可以继续打印下一行。但是当一行没有打印完成时就按 Ctrl+C 发送信号，下一行会在行首打印感叹号，但是却并不继续开始打印星号。</p><p>这是什么原因导致的呢？其实仔细分析一下信号的处理过程就明白了，在开始打印星号之前我们屏蔽了信号的 mask 位，当接收到信号时对应的 padding 位被置1，由于 mask 位是 0 所以程序不会响应信号。当星号打印完成时 mask 位被置为 1，程序会再次看到信号，所以会打印感叹号并进入 pause 状态等待被信号打断，所以程序只打印了一个感叹号却没有继续打印星号。</p><p>归根结底还是因为 解除信号屏蔽 — 等待被信号打断 — 屏蔽信号 的这三个步骤不原子导致的。</p><p>sigsuspend(2) 函数我们在这篇博文的最后面还会讲解。</p><p>当使用 sigsuspend(2) 函数使这三个步骤原子化时我们再来分析一下程序的执行过程：</p><p>开始打印星号之前将 mask 位设置为 0，开始打印星号，此时如果接收到了信号 padding 被设置为 1，但是由于 mask 为 0 所以程序不会响应信号。当程序打印完星号时将 mask 位设置为 1，此时响应信号打印出感叹号，并原子化的解除信号屏蔽 + 被信号打断 + 重新屏蔽信号，然后继续开始打印下一行星号。</p><p>我们再来看另一种情况：开始打印星号之前将 mask 位设置为 0 并开始打印星号，当一行星号打印完成时没有收到信号，那么原子化的解除信号屏蔽并等待被信号打断。当信号到来时重新屏蔽信号并继续开始打印下一行星号。</p><p>根据上面的分析，只要 解除信号屏蔽 — 等待被信号打断 — 屏蔽信号 的这三个步骤原子化后就没问题了。当某件事情需要信号驱动时，在该事件未处理完成时又不希望再次被信号打断的时候，就可以采用类似的这种方式。</p><p>当然，这个这个程序是用标准信号实现的，所以标准信号的特点也被它集成了下来：当连续接收到多个信号时只能驱动打印一行星号，而不能收到多少个信号就打印多少行星号，因为标准信号会丢失。</p><p>如果想要让程序收到多少个信号就打印多少行星号，其实代码别的地方都不用修改，直接把信号集中的标准信号替换成实时信号就可以了，因为实时信号的特点是不丢失。代码很简单 LZ 就不贴出来了，感兴趣的小伙伴可以自己实验一下。</p><h3 id="8-2-sigpending-3P"><a href="#8-2-sigpending-3P" class="headerlink" title="8.2 sigpending(3P)"></a>8.2 sigpending(3P)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigpending - examine pending signals</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>用于获取当前收到但是没有响应的信号。</p><p>它是一个系统调用，所以当它从内核中返回的时候需要对信号位图做 &amp; 操作，相应的信号已经被处理了，所以当它返回用户态的时候，它带回来的结果可能已经不准确了。</p><p>除非调用它之前先把所有的信号都 block 住，然后再调用它，返回的结果才是准确的。</p><p>目前还未发现这个函数在实际开发当中有什么作用，主要有两个理由：</p><p>　　1）该函数没有后续操作；</p><p>　　2）没有上面说的手段，取出来的信号集是不准确的。</p><h3 id="8-3-sigaction-2"><a href="#8-3-sigaction-2" class="headerlink" title="8.3 sigaction(2)"></a>8.3 sigaction(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigaction - examine and change a signal action</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数也是信号这章比较重要的一个函数。sigaction(2) 是用来替换 signal(2) 函数的。因为 signal(2) 有一些设计上的缺陷，所以小伙伴们学过了这个函数之后以后就尽量不要再使用 signal(2) 函数了。</p><p>参数列表：</p><p>　　signum：要设定信号处理函数的信号；</p><p>　　act：对信号处理函数的设定；</p><p>　　oldact：由函数回填之前的信号处理函数设定，备份用，如果不需要可以填 NULL。</p><p>下面看看 struct sigaction 这个结构体的成员表示什么意思：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前两个是信号处理函数，二选一，在某些平台上是一个共用体。</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>); <span class="comment">// 为了兼容 signal(2) 函数</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">// 第二个参数可以获得信号的来源和属性。第三个参数最原始时是 ucontext_t* 而不是 void*，与 setcontext(3) 有关，目前该参数已经禁止使用。</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask; <span class="comment">// 信号集位图，指定要处理的信号集，并且信号集中的任何一个信号被触发时，信号集中的其它成员同时会被 block，避免像 signal(2) 的信号处理函数一样当多个信号同时到来时发生重入。</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags; <span class="comment">// 特殊要求。如果使用三参的信号处理函数，需要指定为 SA_SIGINFO</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>); <span class="comment">// 基本被废弃了，不用管</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上一个参数的信号处理函数和三个参数的信号处理函数使用哪个都行，一般一个参数的就够用了。假设你的程序需要区分信号的来源或属性信息，那么就需要使用三参的信号处理函数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid =  fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup2(fd, <span class="number">0</span>);</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    dup2(fd, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&gt;<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    setsid();</span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"><span class="comment">//  umask(0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    closelog();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    sa.sa_handler = daemon_exit;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGTERM);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGINT);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//   signal(SIGINT, daemon_exit);</span></span><br><span class="line"><span class="comment">//   signal(SIGQUIT, daemon_exit);</span></span><br><span class="line"><span class="comment">//   signal(SIGTERM, daemon_exit);</span></span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>, LOG_PID, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(daemonize())</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">"daemonize() failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_INFO, <span class="string">"daemonize() successed"</span>); <span class="comment">// 结尾写 \n 会被当作文本</span></span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">"fopen(): %s"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syslog(LOG_INFO, <span class="string">"%s was opend."</span>, FNAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, i);</span><br><span class="line">        fflush(fp);</span><br><span class="line">        syslog(LOG_DEBUG, <span class="string">"%d is printed."</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下两句执行不到，因为守护进程一定是异常中止。因为守护进程脱离控制终端，一定会是kill pid的</span></span><br><span class="line">    <span class="comment">// 方式杀死。所以没办法做一个收尾的工作，释放资源等等。</span></span><br><span class="line">    <span class="comment">// fclose(fp);</span></span><br><span class="line">    <span class="comment">// closelog();</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们再来说说 signal(2) 函数哪里不靠谱。</p><p>还记得使用 signal(2) 函数注册的信号处理函数的原型吗？它的参数 s 的作用被设计出来的目的是为了让信号处理函数区别出来是哪个信号触发了它，也就是允许多个不同的信号共用同一个信号处理函数，并且动作可以不一样，可以根据 s 的不同做不同的事。</p><p>下面举一个简单的小栗子给大家演示一下如何使用 sigaction(2) 代替 signal(2)，以及为什么说 signal(2) 函数是不靠谱的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME        <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//      syslog(LOG_ERR,"fork():%s",strerror(errno));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">    dup2(fd,<span class="number">0</span>);</span><br><span class="line">    dup2(fd,<span class="number">1</span>);</span><br><span class="line">    dup2(fd,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &gt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    closelog();</span><br><span class="line">    syslog(LOG_INFO,<span class="string">"daemonize exited."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    如果使用 signal(2) 函数则是这样注册信号处理函数</span></span><br><span class="line"><span class="comment">//    signal(SIGINT,daemon_exit);</span></span><br><span class="line"><span class="comment">//    signal(SIGTERM,daemon_exit);</span></span><br><span class="line"><span class="comment">//    signal(SIGQUIT,daemon_exit);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  现在改用 sigaction(2) 来替代 signal(2) 函数</span></span><br><span class="line">    sa.sa_handler = daemon_exit;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGTERM);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGINT);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGINT,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line">    sigaction(SIGTERM,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line">    sigaction(SIGQUIT,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>,LOG_PID,LOG_DAEMON);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  启动守护进程</span></span><br><span class="line">    <span class="keyword">if</span>(daemonize())</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"daemonize() failed."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_INFO,<span class="string">"daemonize() successed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME,<span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"fopen():%s"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>,i);</span><br><span class="line">        fflush(fp);</span><br><span class="line">        syslog(LOG_DEBUG,<span class="string">"%d was printed."</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，就是启动一个守护进程每秒钟向 /tmp/out 文件输出一个序列。</p><p>上面的代码动机是好的，注册了三个信号处理函数，企图将异常结束行为改变为正常结束行为。但是信号处理函数中并不需要区分不同的信号，只要任何一个信号到来想要杀死进程的时候把资源释放掉再结束即可。</p><p>所以有一个重要的缺陷：当多个信号同时到来的时候，一定会发生内存泄漏。因为 signal(2) 函数在一个信号到来的时候不会把其它注册了同一个信号处理函数的信号屏蔽掉。</p><p>上面已经说过了，sigaction(2) 在收到信号集中的任何一个信号的时候，都会将信号集中的其它信号屏蔽掉，所以就会避免信号处理函数发生重入。上面的代码改成使用 sigaction(2) 的方式实现就变得安全了。</p><h3 id="8-4-setjmp-3-和-sigsetjmp-3-函数"><a href="#8-4-setjmp-3-和-sigsetjmp-3-函数" class="headerlink" title="8.4 setjmp(3) 和 sigsetjmp(3) 函数"></a>8.4 setjmp(3) 和 sigsetjmp(3) 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setjmp, sigsetjmp - save stack context for nonlocal goto</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br></pre></td></tr></table></figure><p>我们前面说过，在信号处理函数中是不能使用跨函数的长跳转的还记得吗？是因为进入处理函数之前系统会帮我们屏蔽对应的信号掩码，而当信号处理完成的时候系统会帮我们还原信号掩码。如果我们在信号处理函数中跳走了，那么信号掩码就不会被还原了，可能会造成当前进程再也无法接收到该信号了。</p><p>setjmp(3) 在 FreeBSD 平台上和其他平台上的实现不一致。FreeBSD 在跳转的时候还会保存信号掩码，并且在跳转的时候恢复信号掩码，所以在 FreeBSD 上使用 setjmp(3) 从信号处理函数中跳转是安全的。</p><p>由于其它平台的实现在跳转时不支持恢复信号掩码，大家一定猜到了为什么又出现了一个 sigsetjmp(3) 函数了。</p><p>果然标准再一次跳出来和稀泥了，制定了 sigsetjmp(3) 函数。</p><p>sigsetjmp(3) 函数的参数：如果 savesigs 为真，表示与 FreeBSD 平台的 setjmp(3) 实现相同，否则跳转时不保存信号掩码。就这么一点差别，仅此而已。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> sigjmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sigsetjmp(env, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before %s\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end %s\n"</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before %s\n"</span>, __FUNCTION__);</span><br><span class="line">    siglongjmp(env, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end %s\n"</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line">    fun();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, i);</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译运行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ gcc -Wall siglongjmp.c -o siglongjmp</span><br><span class="line">&gt;$ ./siglongjmp </span><br><span class="line">before fun</span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line"><span class="built_in">end</span> fun</span><br><span class="line"><span class="number">0</span></span><br><span class="line">^Cbefore handler</span><br><span class="line">before fun</span><br><span class="line"><span class="built_in">end</span> fun</span><br><span class="line"></span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br><span class="line">&gt;$</span><br></pre></td></tr></table></figure><p>从上面的执行结果可以看出来，第一次执行 fun() 函数的时候设置了跳转点，在 fun() 函数执行完成之前发送 SIGINT 信号使程序切换到 handler() 函数运行，并且在 handler() 函数中再次跳转到 fun() 函数。在 fun() 函数运行结束之前再次发送信号依然可以被程序看到，说明 siglongjmp(3) 在跳转的时候确实恢复信号掩码了。</p><p>但是继续往下看，当 fun() 函数执行完毕时再次发送 SIGINT 信号给程序，handler() 函数会再次被调用，但是当从 handler() 跳转到 fun() 函数的时候出现段错误了！</p><p>为什么呢？经过 LZ 实验发现：siglongjmp(3) 函数只能从信号处理函数中跳转到当前被打断的函数，而不能随意跳转到其它函数中！（信号处理的过程可以见上面的图1）</p><p>也就是说当 fun() 函数在运行时被打断，从内核态回到用户态时发现收到了信号，这时候跳转到信号处理函数中运行，这个信号处理函数如果使用 siglongjmp(3) 函数进行跳转，则只能跳转到 fun() 函数中，否则会报段错误。</p><p>同理，上面的代码当 fun() 函数运行结束时回到 main() 函数继续运行，在 main() 被打断后进入内核排队等待被调度，当它获得调度机会从内核态回到用户态时发现收到了信号并且需要处理，这个时候信号处理函数 handler() 开始运行，如果信号处理函数需要使用 siglongjmp(3) 进行跳转，那么它只能选择跳转到 main() 函数中，而不能跳转到其它函数中。因为前面 LZ 说了，当前被打断的是 main() 函数，谁被打断就只能跳转到谁那去。这时候信号处理函数依然选择跳转到 fun() 函数中，所以引发了段错误。</p><p>为什么会有这么奇怪的现象 LZ 也不明白，估计跟执行现场有关系，各位如果知道是什么原因的话请在留言中告诉 LZ 哈。</p><h3 id="8-5-sigsuspend-2"><a href="#8-5-sigsuspend-2" class="headerlink" title="8.5 sigsuspend(2)"></a>8.5 sigsuspend(2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sigsuspend - wait for a signal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>与pause之间的区别</li></ul><p>这个函数我们在上面已经见过了， 它就是为了解决解除信号阻塞和 pause(2) 之间不原子的问题。</p><p>如果本来程序期望的是解除该信号的阻塞之后用 pause(2) 来等待被该信号打断，结果这个信号在解除阻塞和 pause(2) 之间到来了，这就导致它无法打断 pause(2) 了，因为它是在进行 pause(2) 之前到来的。如果后面不会再见到该信号，那么 pause(2) 将永远阻塞下去。</p><p>我们用下面的栗子来说明这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"!"</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oset,saveset;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">   sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//  sigprocmask 和 pause 不原子</span></span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;oset,<span class="literal">NULL</span>);</span><br><span class="line">        pause();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oset,saveset;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">   sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line">   sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"\n"</span>,<span class="number">1</span>);</span><br><span class="line">        sigsuspend(&amp;oset); <span class="comment">// 原子操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sigset_t tmpset;</span></span><br><span class="line"><span class="comment">        //  sigprocmask 和 pause 不原子</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;oset, &amp;tmpset);</span></span><br><span class="line"><span class="comment">        pause();</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;tmpset, NULL);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序跟上面的栗子类似，每秒钟打印一个星号，每 5 个星号组成一行，只有当一行星号打印完毕时才响应 SIGINT 信号。</p><p>如果解除阻塞和等待信号打断不采用原子操作，那么在 pause(2) 之前收到了信号就无法驱动下一行星号的打印了。</p><p><strong>测试一个东西</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">cd</span>  /apue/parallel/signal/mytbf</span><br><span class="line">make</span><br><span class="line">./mytbf /etc/services</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">kill</span> - ALRM 45625 ; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 从user角度，给一个指定的进程发 alrm信号。你会发现流控已经不成立了。这个问题 signal 解决不了。问题是根源是 signal并没有管信号的来源，信号的属性信息，它要做的是，你只要来一个信号，我给这个信号注册一个行为了，那就执行这个信号的行为。它并没有区分信号的来源是哪儿，而直接执行这个信号的行为。如何能区分信号的来源了，那就好办了，可以只响应从kernel来的信号。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br><span class="line"><span class="comment">#kill: kill 45625 failed: 没有那个进程</span></span><br></pre></td></tr></table></figure><p>这个问题需要用到 sigaction 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef void (*sighandler_t)(int);</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span>* <span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> inited = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//static sighandler_t  alrm_handler_save;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">alrm_sa_save</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;</span><br><span class="line">    <span class="keyword">int</span> burst;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//   signal(SIGALRM, alrm_handler_save);</span></span><br><span class="line"><span class="comment">//   alarm(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM, &amp;alrm_sa_save, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    itv.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">    itv.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    itv.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">    itv.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;itv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(job[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">get_free_pos</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_action</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//    alarm(1);</span></span><br><span class="line">    <span class="keyword">if</span>(infop -&gt; si_code != SI_KERNEL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i]!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">            <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//   alrm_handler_save = signal(SIGALRM, alrm_handler);</span></span><br><span class="line"><span class="comment">//   alarm(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line"></span><br><span class="line">    sa.sa_sigaction = alrm_action;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM, &amp;sa, &amp;alrm_sa_save);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if error */</span></span><br><span class="line">    itv.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    itv.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    itv.it_value.tv_sec = <span class="number">1</span>;</span><br><span class="line">    itv.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;itv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*if error*/</span></span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inited)</span><br><span class="line">    &#123;</span><br><span class="line">        module_load();</span><br><span class="line">    inited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = get_free_pos();  <span class="comment">// 在数组中 找空位</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me; <span class="comment">//将该结构体存储至 数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> * ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    job[me -&gt; pos] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数可以指定 响应从 哪儿来的信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction * act,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sigaction * oldact)</span></span>;</span><br></pre></td></tr></table></figure><p>用sigaction 重构 mytbf库，在信号处理函数当中。<br>在alarm前面加 if判断，只有是kernel来的就响应，不是kernel来的一概不响应。</p><h3 id="8-6-实时信号"><a href="#8-6-实时信号" class="headerlink" title="8.6 实时信号"></a>8.6 实时信号</h3><blockquote><p>标准信号会丢失，因为是用位图来进行记录的。 标准信号的响应没有严格的顺序，实时信号的产生是为了解决标准信号的不足。<br>首先实时信号是需要排队的，其次实时信号的响应有一个顺序要求。标准信号的响应无顺序，不能说它是随机响应。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYRTSIG (SIGRTMIN+6)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mysig_handler</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line"></span><br><span class="line">    signal(MYRTSIG, mysig_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, MYRTSIG);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"*"</span>,<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给 17177 号进程发信号</span></span><br><span class="line"><span class="built_in">kill</span> -40 57245</span><br><span class="line"><span class="built_in">kill</span> -40 57245</span><br><span class="line"><span class="built_in">kill</span> -40 57245</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续发送三次信号，我们发现 程序连续执行了三次。</span></span><br><span class="line"><span class="comment"># 说明实时信号能做到 信号不丢失 （实时信号和标准信号的区别就在于此）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然这个信号也无法无休止的发的，也是有资源上限的</span></span><br><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line"></span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-m: resident <span class="built_in">set</span> size (kbytes)      unlimited</span><br><span class="line">-u: processes                       7144</span><br><span class="line">-n: file descriptors                1024</span><br><span class="line">-l: locked-in-memory size (kbytes)  64</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 7144  <span class="comment"># pending signals 实时信号上限</span></span><br><span class="line">-q: bytes <span class="keyword">in</span> POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以 ulimit -i 来更改这个最大实时信号的上限</span></span><br></pre></td></tr></table></figure><h3 id="8-7-有关信号的其它内容"><a href="#8-7-有关信号的其它内容" class="headerlink" title="8.7 有关信号的其它内容"></a>8.7 有关信号的其它内容</h3><p>除了 kill -l 可以查看所有的信号，还可以通过 /usr/include/bits/signum.h 文件查看。</p><p>实时信号会按照先到先响应的顺序处理，并且信号会排队，不会丢失。</p><p>信号是否排队、是否丢失，不取决于使用哪个函数，而是取决于使用哪种信号。</p><p>实时信号具有这些特点是因为它不是采用位图实现的，而是采用链式结构实现的。</p><p>其它方面与标准信号没有区别。</p><p>信号处理函数中只能安全的使用可重入函数（所有系统调用都是可重入函数）和所有的科学计算（科学计算都是可重入的），编写信号处理函数要时刻防止重入发生。</p><p>尽量不要大范围的混用信号和多线程，如果在小范围内信号 + 多线程可以方便的解决某个问题时才可以在小范围内混用它们</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>实际上，使用多线程并发要比信号并发简单的多。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="2020/12/16/apue-7/"/>
      <url>2020/12/16/apue-7/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>实际项目中多线程用得比较多，因为多线程是先有标准后有实现的，所以不会向多进程那样在不同平台上有许多不同的情况。</p></blockquote><ol><li>线程的概念</li><li>线程的创建、线程终止、 线程的取消、线程的清理</li><li>线程的同步（互斥量， 通知法，读写锁）</li><li>线程相关的属性 （线程同步属性）</li><li>重入，线程和信号的关系， 线程与fork</li></ol><h2 id="1-1-线程概念"><a href="#1-1-线程概念" class="headerlink" title="1.1 线程概念"></a>1.1 线程概念</h2><ol><li>线程就是一个正在运行函数</li><li>一个进程空间最少要有一个线程，一个进程里面最少有一个函数在运行。</li><li>线程没有主次之分，不分前后的，即使线程自己创建出来的线程反过来把自己取消或者收尸都是可以的。main函数产生的main进程并不是主线程</li><li>线程之间独立运行，而不是调用与被调用的关系。多个线程的内存是共享的。所以线程间通信依赖全局变量</li><li>线程是先有标准，然后才有标准实现的</li><li>一个新的库被开发出来，默认是需要支持多线程的，如果不能支持需要在函数的调用以及函数名上做说明。很多函数都是支持多线程的，比如getchar putchar等</li></ol><h3 id="1-1-1-线程有不同的标准"><a href="#1-1-1-线程有不同的标准" class="headerlink" title="1.1.1 线程有不同的标准"></a>1.1.1 线程有不同的标准</h3><blockquote><p>线程标准只是一套标准，而不是实现</p></blockquote><ul><li>POSIX标准<br>C 语言线程有很多标准，POSIX 是其中的一种。POSIX 是一套标准，而不是一种实现。</li><li>openmp标准<br>openmp是另外一种线程标准。约定了另外并发的方式，可以产生多线程的并发。它并发的方式不是从语言的角度了。</li></ul><h3 id="1-1-2-线程的标识"><a href="#1-1-2-线程的标识" class="headerlink" title="1.1.2 线程的标识"></a>1.1.2 线程的标识</h3><p><code>pthread_t (p 表示 POSIX, thread 线程)·</code></p><blockquote><p>pthread_t类型 是 POSIX 下的线程标识， pthread_t是什么类型，不清楚，正因为 POSIX 是一套标准而不是实现，所以 POSIX 只是规定了 pthread_t 作为线程标识符，但是并没有规定它必须是由什么类型组成的，所以在有的平台上它可能是 int，有些平台上它可能是 struct，还有些平台上它可能是 union，所以不要直接操作这个类型，而是要使用 POSIX 规定的各种线程函数来操作它。</p></blockquote><p>有木有觉得像标准 IO 里 FILE 的赶脚？没错，标准制定出来的很多东西都是这种风格的，它为你提供一个数据类型而不让你直接对这个类型操作，要通过它定义的一系列函数来实现对这个类型的操作，这样就在各个平台上实现统一的接口了，所以这样做才能让标准制定出来的东西具有较好的可移植性。</p><p>pthread_t 是个很重要的东西，我们所有使用 PSOIX 标准的线程操作都是围绕着它来进行的，通过它配合各种函数就可以对线程进行各种花样作死的玩了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ps ax -L <span class="comment"># 以linux方式查看进程</span></span><br><span class="line">PID   LWP TTY      STAT   TIME COMMAND</span><br><span class="line"> 1     1   ?        Ss     0:02 /sbin/init</span><br><span class="line"> 2     2   ?        S      0:00 [kthreadd]</span><br><span class="line"> 3     3   ?        S      0:00 [ksoftirqd/0]</span><br><span class="line"> 877   877 ?        Ss     0:06 dbus-daemon --system --fork</span><br><span class="line"> 948   948 ?        Ssl    0:00 /usr/sbin/ModemManager</span><br><span class="line"> 948   965 ?        Ssl    0:00 /usr/sbin/ModemManager</span><br><span class="line"> 948   975 ?        Ssl    0:00 /usr/sbin/ModemManager</span><br><span class="line"> 956   956 ?        Ss     0:00 /usr/sbin/bluetoothd</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>PID 是进程号。 LWP虚拟进程ID，即线程 ID。</p><p>在linux环境下，其实是以线程来消耗当前进程号的。当前所看到的线程号其实就是用进程标识来进行描述的。 尽管如此 依然不能 <code>printf(&quot;%d&quot;, pthread_t)</code>, 因为其他线程标准下的 pthread_t 并不一定是 int类型。</p><p>这里看到的 PID 为 948 的进程有三个 LWP，它们就是三个线程。</p><h3 id="1-1-3-多线程相比信号要简单不少"><a href="#1-1-3-多线程相比信号要简单不少" class="headerlink" title="1.1.3 多线程相比信号要简单不少"></a>1.1.3 多线程相比信号要简单不少</h3><blockquote><p>多线程太规范了，信号处理函数应该越短越好。里面不能用IO，不能用不可重入的函数。只能安全的在里面做一些计算和系统调用。其他都慎用。线程不存在这样的问题。线程里面可以io，也可以使用可重用和不可重用的函数。要做到线程的安全比做到信号的安全 条件要松散一些。具体原因还是 多线程是先有标准 后有实现。更像亲儿子。同样是解决异步的两种方式，多线程和信号。至少要对其中一种方式掌握的很熟练。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; vim makefile</span><br><span class="line"></span><br><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br></pre></td></tr></table></figure><ol><li>pthread_equal(3)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_equal - compare thread IDs</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>第一个要介绍的函数是 pthread_equal(3)，比较两个线程标识符是否相同。为什么不能使用 if (t1 == t2) 的方式比较两个线程标识符呢？就像我们上面说的，因为你不知道 pthread_t 是什么类型的，所以永远不要自己直接操作它。</p><ol start="2"><li>pthread_self(3)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_self - obtain ID of the calling thread</span></span><br><span class="line"><span class="comment">// 当前线程的ID</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>大家还记得一个进程可以通过 getpid(2) 函数获得当前进程的 ID 号吧？pthread_self(3) 就是获得当前线程 ID 的函数。</p><h2 id="1-2-线程操作"><a href="#1-2-线程操作" class="headerlink" title="1.2 线程操作"></a>1.2 线程操作</h2><h3 id="1-2-1-线程的创建"><a href="#1-2-1-线程的创建" class="headerlink" title="1.2.1 线程的创建"></a>1.2.1 线程的创建</h3><p><code>pthread_create(3)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_create - create a new thread</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>pthread_create(3) 函数的作用就是创建一个新线程。</p><p>参数列表：</p><p>　　thread：由函数回填的线程标识符，它来唯一的标识产生的新线程，后面我们只要需要操作新线程就需要用到它；</p><p>　　attr：线程属性，在本篇博文（第 11 章）中，所有的属性都是使用 NULL，也就是使用默认属性。</p><p>　　start_routine：线程的执行函数；入参是 void<em>，返回值是 void</em>，恭喜你，这两个值的类型都是百搭的，任何类型你都可以在这使用了。</p><p>　　arg：传递给 start_routine 的 void* 参数。</p><p>返回值：成功返回 0；失败返回 errno。<br>为什么线程函数返回的是 errno 呢？因为在一些平台上 error 是全局变量，如果大家都使用同一个全局变量，在多线程的情况下就可能会出现竞争，所以 POSIX 的线程函数一般在失败的时候都是直接返回 errno 的，这样就避免了某些平台 errno 的缺陷了。</p><p>新线程和当前的线程是两个兄弟线程，他们是平等的，没有父子关系。</p><p>新线程被创建之后，这两个线程哪个先执行是不确定的，由调度器来决定。如果你希望哪个线程一定先执行，那么就在其它线程中使用类似 sleep(3) 的函数让它们等一会儿再运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    error = pthread_create(&amp;tid, <span class="literal">NULL</span>,func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(error));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Begin!</span></span><br><span class="line"><span class="comment">// End!</span></span><br></pre></td></tr></table></figure><p><strong>为何没有打印 “Thread is working!”</strong></p><blockquote><p>线程的调度取决于调度器的策略,这个现象也不难理解，因为在虚拟机的环境上，没办法去模拟一个多核并发的内容。因为虚拟机本身在宿主机上跑的，一定是在一个核上运行。所以单个核上无法虚拟出多个核。</p></blockquote><p>回过头看代码，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    error = pthread_create(&amp;tid, <span class="literal">NULL</span>,func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(error));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 在创建的 func线程，还没来得及没调度的时候，就执行了exit(0) 结束掉了进程。在进程的任意位置 执行 exit 函数 都表示当前进程的结束。 所以没有机会打印出 Thread is working! 这句话了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个多核机器上，理论是可以打印出 “new pthread working!” 的，有时存在 begin 和 end之间，有时存在 end之后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macos</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Begin!</span></span><br><span class="line"><span class="comment"># end!</span></span><br><span class="line"><span class="comment"># new pthread working!</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-线程的终止"><a href="#1-2-2-线程的终止" class="headerlink" title="1.2.2 线程的终止"></a>1.2.2 线程的终止</h3><blockquote><p>线程的终止有三种方式</p></blockquote><ol><li>线程从启动例程返回，返回值就是线程的退出码</li><li>线程可以被同一进程中的其他线程取消（异常终止的一种方式）</li><li>线程调用 pthread_exit() 函数，</li></ol><p><code>pthread_exit(3)</code></p><blockquote><p>这个函数相当于进程阶段的 exit 函数，它表示结束当前正在跑的线程（函数），当然如果你 用 pthread_exit 调用的线程是当前进程的最后一个正在跑的线程，那么进程也会被结束。<br>最后一个线程从启动例程里面返回，也会导致进程结束。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_exit - terminate calling thread</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>在线程执行函数中调用，作用是退出当前线程，并将返回值通过 retval 参数返回给调用 pthread_join(3) 函数的地方，如果不需要返回值可以传入 NULL。</p><p>pthread_join(3) 是为线程收尸的函数，我们会在下面详细介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第二个参数不传，指的是 只收尸，不关心状态</span></span><br><span class="line"><span class="comment">// Compile and link with -pthread</span></span><br></pre></td></tr></table></figure><p>为线程收尸，在上面的栗子中大家已经见到了。不像 wait(2) 函数，线程之间谁都可以为别人收尸，它们之间是没有父子关系的。而 wait(2) 函数只能是由父进程对子进程收尸。</p><p>参数列表：</p><p>　　thread：指定为哪个线程收尸；</p><p>　　retval：这个二级指针是什么呢？它就是线程在退出的时候的返回值（pthread_exit(3) 的参数），它会把线程的返回值的地址回填到这个参数中。</p><p>我们先来看个小栗子，直观的了解下线程是如何被创建的，以及它是如何工作的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working."</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">// 延时是为了方便我们使用 ps(1) 命令验证线程是否被创建了</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//    return NULL;  return 指的是一个函数的结束。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程</span></span><br><span class="line">    err = pthread_create(&amp;tid,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为线程收尸</span></span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>); <span class="comment">// 这个等的动作相当于是等待创建完的线程执行完。所以最终控制台输出的结果，无论是单核还是双核，‘Thread is working.’都会在 ends 输出之前 输出出来。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译并运行，同时使用 LZ 上面介绍过的 ps(1) 命令验证线程是否被创建成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./create</span><br><span class="line">Begin!</span><br><span class="line">Thread is working.</span><br><span class="line">End!</span><br><span class="line">$</span><br><span class="line"><span class="comment"># 在线程结束之前打开另一个终端，验证线程的状态</span></span><br><span class="line">$ ps ax -L</span><br><span class="line">  PID   LWP TTY      STAT   TIME COMMAND</span><br><span class="line"> 4354  4354 pts/1    Sl+    0:00 ./create</span><br><span class="line"> 4354  4355 pts/1    Sl+    0:00 ./create</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>通过 ps(1) 命令的验证，可以看到这两个线程拥有同一个 PID 不同的 LWP，所以可以直观的看出来我们的线程创建成功了！</p><p>大家注意，编译 POSIX 线程程序的时候需要使用 -pthread 参数，这个其实在 man 手册里已经说得很清楚了.</p><h3 id="1-2-3-线程的清理"><a href="#1-2-3-线程的清理" class="headerlink" title="1.2.3 线程的清理"></a>1.2.3 线程的清理</h3><p><code>pthread_cleanup_push()</code><br><code>pthread_cheanup_pop()</code></p><p>7.线程清理处理程序（thread cleanup handler）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>就像在进程级别使用 atexit(3) 函数挂钩子函数一样，线程可能也需要在结束时执行一些清理工作，这时候就需要派出线程清理处理程序上场了。钩子函数的调用顺序也是逆序的，也就是执行顺序与注册顺序相反。</p><p>这两个是带参的宏而不是函数，所以必须成对使用，而且必须先使用 pthread_cleanup_push 再使用  pthread_cleanup_pop，否则会报语法错误，括号不匹配。</p><p>参数列表：</p><p>　　routine：钩子函数。</p><p>　　arg：传递给钩子函数的参数。</p><p>　　execute：0 不调用该钩子函数；1 调用该钩子函数。</p><p>pthread_cleanup_pop 写到哪都行，只要写了让语法不报错就行，就算你把它写到 pthread_exit(3) 下面也没问题，但是 execute 参数就看不到了，所以无论 pthread_cleanup_pop 的参数是什么，所有注册过的钩子函数都会被执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">routine</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun</span> <span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_cleanup_push(routine, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//这里是其它代码</span></span><br><span class="line">  pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预编译，查看宏替换的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E cleanup.c <span class="comment"># 预处理， 解决所有 #开发的语句</span></span><br><span class="line"></span><br><span class="line">void routine (void *p) &#123;&#125;</span><br><span class="line">void* fun (void *p)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123; __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (((void *)0)); int not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *) __cancel_buf.__cancel_jmp_buf, 0); <span class="keyword">if</span> (__builtin_expect (not_first_call, 0)) &#123; __cancel_routine (__cancel_arg); __pthread_unwind_next (&amp;__cancel_buf); &#125; __pthread_register_cancel (&amp;__cancel_buf); <span class="keyword">do</span> &#123;;</span><br><span class="line"> // 这里是其它代码</span><br><span class="line"> <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (0); &#125; <span class="keyword">while</span> (0); __pthread_unregister_cancel (&amp;__cancel_buf); <span class="keyword">if</span> (1) __cancel_routine (__cancel_arg); &#125; <span class="keyword">while</span> (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过预编译可以看出来 pthread_cleanup_push 和 pthread_cleanup_pop 两个宏被替换了，并且每个宏仅定义了一半，如果不成对写另一个宏编译的时候就会报括号不匹配的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:1"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:2"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"push over!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // pthread_cleanup_pop 和 pthread_cleanup_push 需要成双成对出现， 有多少个push 就的有多少个pop</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">// 参数  1表示调用，0表示只弹栈 不调用</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">// 栈方法，后进先出</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"begin"</span>);</span><br><span class="line"></span><br><span class="line">  err =  pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">Thread is working</span><br><span class="line">push over!</span><br><span class="line">cleanup:3</span><br><span class="line">cleanup:2</span><br><span class="line">cleanup:1</span><br><span class="line">End!</span><br></pre></td></tr></table></figure><h3 id="1-2-4-线程取消"><a href="#1-2-4-线程取消" class="headerlink" title="1.2.4 线程取消"></a>1.2.4 线程取消</h3><blockquote><p>linux 一共有8种终止进程的方式，其中5种正常终止和3种异常终止。 其中‘最后一个线程对取消请求作出响应；’ 是三种异常中止方式中的一种</p></blockquote><p><code>pthread_cancel(3)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cancel - send a cancellation request to a thread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p><code>setcanceltype</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>; <span class="comment">// 设置是否允许取消</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>;<span class="comment">// 设置取消方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 本函数什么都不做，就是一个取消点</span></span><br></pre></td></tr></table></figure><p><strong>取消有两种状态： 允许 和 不允许</strong></p><p>允许取消又分为  异步cancel 和 推迟 cancel(默认) -&gt; 推迟至cancel点再响应<br>cancel点： POSIX定义的cancel点，都是可能引发阻塞的系统调用；</p><p>pthread_cancel(3) 函数的作用是取消同一个进程中的其它线程线程。</p><p>为什么要取消线程呢？当一个线程没有必要继续执行下去时，我们又没法为它收尸，所以就需要先取消这个线程，然后再为它收尸。</p><p>比如在使用多线程遍历一个很大的二叉树查找一个数据时，其中某一个线程找到了要查找的数据，那么其它线程就没有必要继续执行了，所以就可以取消它们了。</p><p>注意 pthread_cancel(3) 并不等待线程终止，它仅仅提出请求。</p><p>而线程收到这个请求也不会立即终止，线程要执行到取消点才能被取消，关于取消点在下一篇博文中会介绍。</p><p><strong>线程分离</strong></p><p><code>pthread_detach(3)</code></p><blockquote><p>不想管它，扔到一边去，生死存亡各有天命</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_detach - detach a thread</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>pthread_detach(3) 函数用于分离线程，被分离的线程是不能被收尸的。</p><p><strong>primer</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, &amp;i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = *(<span class="keyword">int</span> *)p;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./primer</span><br><span class="line">30000023 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000049 is a primer</span><br><span class="line">30000071 is a primer</span><br><span class="line">30000059 is a primer</span><br><span class="line">30000079 is a primer</span><br><span class="line">30000133 is a primer</span><br><span class="line"><span class="comment"># 结果不对</span></span><br></pre></td></tr></table></figure><p>这种现象是因为线程发生了竞争；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单粗暴的更改</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i); <span class="comment">//主要处理这个 i 的问题，因为 prime0 程序里面这个 i 是地址传递</span></span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = (<span class="keyword">int</span>)p; <span class="comment">// 将p 强制 转换成int 类型</span></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">30000149 is a primer</span><br><span class="line">30000137 is a primer</span><br><span class="line">30000041 is a primer</span><br><span class="line">30000079 is a primer</span><br><span class="line">30000083 is a primer</span><br><span class="line">30000169 is a primer</span><br><span class="line">30000163 is a primer</span><br><span class="line">30000133 is a primer</span><br><span class="line">30000023 is a primer</span><br><span class="line">30000071 is a primer</span><br><span class="line">30000167 is a primer</span><br><span class="line">30000109 is a primer</span><br><span class="line">30000001 is a primer</span><br><span class="line">30000049 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000199 is a primer</span><br><span class="line">30000193 is a primer</span><br><span class="line">30000059 is a primer</span><br><span class="line"></span><br><span class="line">$ ./primer0 | wc -l</span><br><span class="line">18</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用更多的空间，优化策略是创建一个结构体数组用来存储</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i); <span class="comment">//主要处理这个 i 的问题，因为 prime0 程序里面这个 i 是地址传递</span></span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = (<span class="keyword">int</span>)p; <span class="comment">// 将p 强制 转换成int 类型</span></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建结构体用于接受</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"malloc()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;n = i;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime,p);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = ((struct thr_arg_st *)p) -&gt;n;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 及时回收，不然会造成内存泄露，且泄露200个结构体的空间</span></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然这个函数还有优化的空间，比如malloc 和 free 尽量放在一个函数当中</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将malloc 和free放在一个函数当中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT  30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">      <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 定义指针，接受线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"malloc()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;n = i;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime,p);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;=RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT], &amp;ptr);</span><br><span class="line">        <span class="built_in">free</span>(ptr); <span class="comment">// 收尸的同时调用 free ptr</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = ((struct thr_arg_st *)p) -&gt;n;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer\n"</span>, i);</span><br><span class="line">    pthread_exit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 目前的写法依然不科学，因为一个进程里面未必就能创建出来这么多的线程，那么如何测试一个进程能创建多少线程呢？</span></span><br></pre></td></tr></table></figure><p><strong>一个进程能创建多少线程</strong></p><blockquote><p>32位的机器，一个进程最多创建300个左右的线程</p></blockquote><p><code>thr_prime</code>这个函数，该函数实际被扔出去201次，201份同时跑。在资源的使用上，他们的代码段是公用的，它们的栈是独立的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">ulimit</span> -a</span><br><span class="line">stack size  10240  <span class="comment"># 栈大小是 10240 也就是10M</span></span><br></pre></td></tr></table></figure><p>c程序地址空间分布，32位环境上，c进程的虚拟空间是4GB，最高的一GB是给内核态使用的，用户态用的虚拟空间是不足3GB的。在这不足3GB的空间里面，代码段，静态区域，数据段，堆，栈都得预留出来。所以说，当前能创建多少个线程，也就要看在当前的进程空间里面能够创建多少个10MB大小的栈。所以能创建多少线程还是取决于资源量的</p><p>在64位的机器上，一个C程序的虚拟空间是128T。所以，是消耗不完的，纵使能消耗完，也是先消耗完<code>pid</code>号</p><h2 id="1-3-线程的同步"><a href="#1-3-线程的同步" class="headerlink" title="1.3 线程的同步"></a>1.3 线程的同步</h2><p>在介绍互斥量之前我们先思考一个问题：如何让 20 个线程同时从一个文件中读取数字，累加 1 然后再写入回去，并且保证程序运行之后文件中的数值比运行程序之前大 20？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">echo</span> 100 &gt; /tmp/out/  <span class="comment"># 往out文件里面写入一个 1个数</span></span><br><span class="line">cat /tmp/out</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20个线程，打开一个文件，读数 + 1，写回去。不要乱</span></span><br><span class="line"><span class="comment">// add.c,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(linebuf,LINESIZE,fp); <span class="comment">// 将读取的内容放进 linebuf中</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET); <span class="comment">// 文件位置指针 指回去</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>, atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在虚拟机上是正确的，因为虚拟机是运行在一个核上面的。没办法做到并行<br>而在macos上发现，结果是不正确的。</p><h3 id="1-3-1-互斥量"><a href="#1-3-1-互斥量" class="headerlink" title="1.3.1 互斥量"></a>1.3.1 互斥量</h3><p><code>pthead_mutex_t</code></p><blockquote><p>限制一段代码以独占的形势在实现</p></blockquote><p>互斥量是一种机制</p><p>多线程就是为了充分利用硬件资源，使程序可以并发的运行，但是只要是并发就会遇到竞争的问题，互斥量就是解决竞争的多种手段之一。</p><p>程序中每一个线程都要做：读取文件 — 累加 1 — 写入文件 的动作，如果 20 个线程同时做这件事，那么就很有可能多个线程读到的数据是相同的，这样累加的结果也就是相同的了，就没办法保证 20 个线程每个人读到的数据都是独一无二的了。</p><p>怎么样才能让 20 个线程读到独一无二的数值呢？很简单，让 读取文件 — 累加 1 — 写入文件 的这个动作同一时刻只能有一个线程来做，这样每个线程读取到的数值都是上一个线程写入的数值了。那么 读取文件 — 累加 1 — 写入文件 这段代码（也就是发生竞争的这段区域）就叫做“临界区”。</p><p>互斥量正如它的名字描述的一般，可以使各个线程实现互斥的效果。由它来保护临界区每次只能由一个线程进入，当一个线程想要进入临界区之前需要先抢锁（加锁），如果能抢到锁就进入临界区工作，并且要在离开的时候解锁以便让其它线程可以抢到锁进入临界区；如果没有抢到锁则进入阻塞状态等待锁被释放然后再抢锁。</p><p>要在进入临界区之前加锁，在退出临界区的时候解锁。</p><p>与 ptread_t 一样，互斥量也使用一种数据类型来表示，它使用 pthread_mutex_t 类型来表示。</p><p>初始化互斥量有两种方式：</p><p>1）用宏初始化：如同使用默认属性；</p><p>2）使用 pthread_mutex_init(3) 函数初始化，可以为互斥量指定属性。</p><p>pthread_mutex_t 使用完成之后需要使用 pthread_mutex_destroy(3) 函数销毁，否则会导致内存泄漏。</p><p>一般什么情况使用宏初始化，什么情况使用函数初始化互斥量呢？请看下面的伪代码：</p><p>前面说了，要在进入临界区之前加锁，在退出临界区的时候解锁。我们来了解一下加锁和解锁的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> pthread_mutexattr * <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_destroy();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock -  lock and unlock a mutex</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">// 尝试等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>_lock() 是阻塞加锁，当抢锁的时候被抢不到就死等，直到别人通过 _unlock() 把这把锁解锁再抢。</p><p>_trylock() 是尝试加锁，无论能否抢到锁都返回。</p><p>临界区是每个线程要单独执行的，所以临界区中的代码执行时间越短越好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add1.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"./p"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line">    fp = fopen(FNAME, <span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut);  <span class="comment">// 上锁</span></span><br><span class="line">    fgets(linebuf,LINESIZE,fp); <span class="comment">// 将读取的内容放进 linebuf中</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET); <span class="comment">// 文件位置指针 指回去</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>, atoi(linebuf)+<span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    pthread_mutex_unlock(&amp;mut); <span class="comment">// 开锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证临界区代码每次只有一个线程在运行</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;THRNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁解锁针对的是一段代码，而不是一个变量</p><p>了解了互斥量之后，我们再来看一道经典的面试题：用 4 个线程疯狂的打印 abcd 持续 5 秒钟，但是要按照顺序打印，不能是乱序的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abcd.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">'a'</span> + (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./abcd</span><br><span class="line">aaaaaaaa...</span><br><span class="line"><span class="comment">#  结果不对，连续打了满篇的a，然后b 然后c 然后d</span></span><br></pre></td></tr></table></figure><p>解决思路： 锁链，打印a的线程去解锁打印b的线程，b打印完解锁c，c打印完解锁d，d打印完解锁a；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a+<span class="number">1</span> == THRNUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">int</span> ch = n + <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mut+n);</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,&amp;ch,<span class="number">1</span>);</span><br><span class="line">        pthread_mutex_unlock(mut+next(n));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; THRNUM ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mut+i,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_lock(mut+i);</span><br><span class="line">        err = pthread_create(tid+i,<span class="literal">NULL</span>,thr_func,(<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(mut+<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; THRNUM ; i++)</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdabcdabcdabcdabcdabcd...</span><br></pre></td></tr></table></figure><p>上面这段代码是通过多个互斥量实现了一个锁链的结构巧妙的实现了要求的效果。</p><p>首先定义 4 个互斥量，然后创建 4 个线程，每个互斥量对应一个线程，每个线程负责打印一个字母。4 个线程刚刚被创建好时，4 把锁都处于锁定状态，4 个线程全部都阻塞在临界区之外，等 4 个线程全部都创建好之后解锁其中一把锁。被解锁的线程首先将自己的互斥量上锁，然后打印字符再解锁下一个线程对应的互斥量，然后再次等待自己被解锁。如此往复，使 4 个线程有条不紊的循环执行 锁定自己 — 打印字符 – 解锁下一个线程 的步骤，这样打印到控制台上的 abcd 就是有序的了。</p><p>从上面的栗子可以看出来：互斥量限制的是一段代码能否执行，而不是一个变量或一个资源。</p><p>上面的代码虽然使用锁链巧妙的完成了任务，但是它的实现方式并不是最漂亮的，更好的办法我们下面介绍条件变量（pthread_cond_t）的时候会讨论。</p><h4 id="1-3-1-1线程池"><a href="#1-3-1-1线程池" class="headerlink" title="1.3.1.1线程池"></a>1.3.1.1线程池</h4><p>在primer程序中，201个数字 用 201个线程去处理。<br>现在变幻一下思路，用201个数字对应 N个线程。（N可以是3/4/甚至更多）只要保证当前进程空间可以创建出来这么多线程即可</p><p>分块法/交叉分配/池类写法</p><h4 id="1-3-1-2-池类写法"><a href="#1-3-1-2-池类写法" class="headerlink" title="1.3.1.2 池类写法"></a>1.3.1.2 池类写法</h4><blockquote><p>非标准线程池写法，标准的进程池/线程池。 这个池并非标准线程池的写法。这里是任务池。</p></blockquote><p><img src="./xianchengchi.png" alt=""></p><p>简单描述一下， 就是main发牌到牌桌，线程池到牌桌抢牌，抢到之后，给num 写成0. main获取到num为0 之后，再次发牌。顺便把num写成一个非0的值。当main把最后一张牌扔下来，然后确定被某一个线程抢走之后。那main就负责把这一块写成 -1.这个 -1 提醒下游线程退出。上游线程等着收尸。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line"><span class="comment">//-------------------上游------------------ 期待num！=0</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="comment">// sleep(1); sleep会让当前进程进入 沉睡状态 用下面sched_yield</span></span><br><span class="line">            sched_yield();   <span class="comment">// sched 开头的全部是针对于调度器来操作的，sched_yield的作用是出让调度器给其他的线程，</span></span><br><span class="line">            <span class="comment">// 可以理解为一个非常短的sleep，不会引起当前进程的调度颠簸</span></span><br><span class="line">            <span class="comment">// 这里调用该函数是希望其他线程能拿到 num的值， 并有机会改写num的值</span></span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line">        num = i;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num!= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>; <span class="comment">// 当main发放 最后一张牌的时候，并不能直接置成 -1. 所以需要上面</span></span><br><span class="line">    <span class="comment">// 的sched_yield 出让出去，让其他线程抢到；</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>); <span class="comment">// 给线程收尸</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line"><span class="comment">//--------------------下游------------------------------期待变成非 0</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 临界区内的任何一个跳转语句，这个跳转如果是跳转到临界区以外的。一定不要忘了解锁再</span></span><br><span class="line">            <span class="comment">// 跳转。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何写多并发程序不会造成死锁。</span></span><br><span class="line"></span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]%d is a primer\n"</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[3]30000023 is a primer</span><br><span class="line">[1]30000037 is a primer</span><br><span class="line">[0]30000041 is a primer</span><br><span class="line">[2]30000001 is a primer</span><br><span class="line">[1]30000059 is a primer</span><br><span class="line">[3]30000049 is a primer</span><br><span class="line">[2]30000079 is a primer</span><br><span class="line">[0]30000071 is a primer</span><br><span class="line">[1]30000083 is a primer</span><br><span class="line">[3]30000109 is a primer</span><br><span class="line">[2]30000133 is a primer</span><br><span class="line">[0]30000137 is a primer</span><br><span class="line">[1]30000149 is a primer</span><br><span class="line">[3]30000163 is a primer</span><br><span class="line">[2]30000167 is a primer</span><br><span class="line">[0]30000169 is a primer</span><br><span class="line">[1]30000193 is a primer</span><br><span class="line">[3]30000199 is a primer</span><br></pre></td></tr></table></figure><ul><li>总结</li></ul><blockquote><p>细心会发现，在运行程序时，会有一些卡顿。而且cpu使用率一下上去了。该程序其实还是一个盲等的版本。 上下游都在等待。（代码中查看上下游位置）。<br>现在某一个任务已经被下游线程取走了，上游的main总是抢不到锁，一直阻塞在lock。下游的线程总是在被调度，不停的lock，发现是0 然后解锁， 因为下游线程较多。上游是一个人在抢，下游是4个人在抢。因此抢到的几率是不同的<br>所以该程序是个盲等版，盲在不停的在查看状态。确保这个状态是自己要的那个状态。可以尝试优化成通知法。上游等待num变成0，有人通知自己。就把新任务放进去。而下游等上游把任务放进去之后发一个通知或者消息，下游叫醒任何一个线程来计算这个任务。</p></blockquote><p>大家还记得我们在上一篇博文中提到过令牌桶吗？当时只是实现了一个简单的令牌桶，这次我们来写一个通用的多线程并发版的令牌桶。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mytbf.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTBF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTBF_MAX  1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">mytbf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps,<span class="keyword">int</span> burst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *,<span class="keyword">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mytbf.c  原博客 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个令牌桶 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> cps; <span class="comment">// 速率</span></span><br><span class="line">  <span class="keyword">int</span> burst; <span class="comment">// 令牌上限</span></span><br><span class="line">  <span class="keyword">int</span> token; <span class="comment">// 可用令牌数量</span></span><br><span class="line">  <span class="keyword">int</span> pos; <span class="comment">// 当前令牌桶在 job 数组中的下标</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> mut; <span class="comment">// 用来保护令牌竞争的互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有的令牌桶 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="comment">/* 用来保护令牌桶数组竞争的互斥量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">/* 添加令牌的线程 ID */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="comment">/* 初始化添加令牌的线程 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程处理函数：负责定时向令牌桶中添加令牌 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_alrm</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">      <span class="comment">// 遍历所有的桶</span></span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; MYTBF_MAX; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 为可用的桶添加令牌</span></span><br><span class="line">          <span class="keyword">if</span>(job[i] != <span class="literal">NULL</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">              job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">              <span class="comment">// 桶中可用的令牌不能超过上限</span></span><br><span class="line">              <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                  job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">              pthread_mutex_unlock(&amp;job[i]-&gt;mut);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 等待一秒钟后继续添加令牌</span></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  pthread_cancel(tid);</span><br><span class="line">  pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; MYTBF_MAX ; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(job[i] != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 互斥量使用完毕不要忘记释放资源</span></span><br><span class="line">          pthread_mutex_destroy(&amp;job[i]-&gt;mut);</span><br><span class="line">          <span class="built_in">free</span>(job[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  </span><br><span class="line">  err = pthread_create(&amp;tid,<span class="literal">NULL</span>,thr_alrm,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 为了不破坏调用者对令牌桶操作的原子性，</span></span><br><span class="line"><span class="comment">* 在该函数内加锁可能会导致死锁，</span></span><br><span class="line"><span class="comment">* 所以该函数内部无法加锁，</span></span><br><span class="line"><span class="comment">* 必须在调用该函数之前先加锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_free_pos_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; MYTBF_MAX; i++)</span><br><span class="line">      <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps,<span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">  pthread_once(&amp;init_once,module_load);</span><br><span class="line"></span><br><span class="line">  me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">  <span class="keyword">if</span>(me == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  me-&gt;cps = cps;</span><br><span class="line">  me-&gt;burst = burst;</span><br><span class="line">  me-&gt;token = <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_init(&amp;me-&gt;mut,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">  </span><br><span class="line">  pos = get_free_pos_unlocked();</span><br><span class="line">  <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 带锁跳转不要忘记先解锁再跳转</span></span><br><span class="line">      pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">      <span class="built_in">free</span>(me);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">  job[pos] = me;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">  <span class="comment">// 令牌数量不足，等待令牌被添加进来</span></span><br><span class="line">  <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 先解锁，出让调度器让别人先跑起来，然后再抢锁检查令牌是否够用</span></span><br><span class="line">      pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">      sched_yield();</span><br><span class="line">      pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n = <span class="built_in">min</span>(me-&gt;token,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">  me-&gt;token -= n;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令牌用不完要归还哟，可不能浪费了 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逗我玩呢？</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">  me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">  <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">      me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">  job[me-&gt;pos] = <span class="literal">NULL</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// me  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span>* <span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> tid_alrm;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> inited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;</span><br><span class="line">    <span class="keyword">int</span> burst;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mut;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    pthread_cancel(tid_alrm);</span><br><span class="line">    pthread_join(tid_alrm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mytbf_destroy(job[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">get_free_pos_unloaded</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_alrm</span><span class="params">(<span class="keyword">void</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MYTBF_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(job[i]!= <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">                job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">                <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                    job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">                pthread_mutex_unlock(&amp;job[i]-&gt;mut);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = pthread_create(&amp;tid_alrm, <span class="literal">NULL</span>, thr_alrm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(!inited)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//      module_load();</span></span><br><span class="line">    <span class="comment">//      inited = 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 用 pthread_once 代替上面语句</span></span><br><span class="line">    pthread_once(&amp;init_once, module_load);</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    pos = get_free_pos_unloaded();  <span class="comment">// 在数组中 找空位</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me; <span class="comment">//将该结构体存储至 数组中</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut); <span class="comment">// 盲在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= <span class="number">0</span>)   <span class="comment">// 这里一秒钟 循环数次</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> * ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    job[me -&gt; pos] = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序依然是盲等法，</p><p>上面这个令牌桶库可以支持最多 1024 个桶，也就是可以使用多线程同时操作这 1024 个桶来获得不同的速率，每个桶的速率是固定的。</p><p>这 1024 个桶保存在一个数组中，所以每次访问桶的时候都需要对它进行加锁，避免多个线程同时访问发生竞争。</p><p>同样每个桶也允许使用多个线程同时访问，所以每个桶中也需要一个互斥量来保障处理令牌的时候不会发生竞争。</p><p>写互斥量的代码一定要注意临界区内的所有的跳转，通常在跳转之前需要解锁，避免产生死锁。常见的跳转包括 continue; break; return; goto; longjmp(3); 等等，甚至函数调用也是一种跳转。</p><p>当某个函数内包含临界区，也就是需要加锁再进入临界区，但是从程序的布局来看该函数无法加锁，那么根据 POSIX 标准的约定，这种函数的命名规则是必须以 _unlocked 作为后缀，所以大家在看到这样的函数时在调用之前一定要先加锁。总结起来说就是以这个后缀命名的函数表示函数内需要加锁但是没有加锁，所以调用者需要先加锁再调用，例如上面代码中的 get_free_pos_unlocked() 函数。</p><p>LZ 来解释一下上面这个令牌桶中用过的几个没见过的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sched_yield — yield the processor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>sched_yield(2) 这个函数的作用是出让调度器。在用户态无法模拟它的实现，它会让出当前线程所占用的调度器给其它线程使用，而不必等待时间片耗尽才切换调度器，大家暂时可以把它理解成一个很短暂的 sleep(3) 。一般用于在使用一个资源时需要同时获得多把锁但是却没法一次性获得全部的锁的场景下，只要有任何一把锁没有抢到，那么就立即释放已抢到的锁，并让出自己的调度器让其它线程有机会获得被自己释放的锁。当再次调度到自己时再重新抢锁，直到能一次性抢到所有的锁时再进入临界区，这样就避免了出现死锁的情况。</p><p><strong>动态模块的单次初始化函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_once - dynamic package initialization</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure><p>pthread_once(3) 函数一般用于动态单次初始化，它能保证 init_routine 函数仅被调用一次。</p><p>pthread_once_t 只能使用 PTHREAD_ONCE_INIT 宏初始化，没有提供其它初始化方式。这个与我们前面见到的初始化 pthread_t 和 pthread_nutex_t 不一样。</p><p>上面的代码中，向令牌桶添加令牌的线程只需要启动一次，而初始化令牌桶的函数却在开启每个令牌桶的时候都需要调用。为了在初始化令牌桶的函数中仅启动一次添加令牌的线程，采用 pthread_once(3) 函数来创建线程就可以了。这样之后在第一次调用 mytbf_init() 函数的时候会启动新线程添加令牌，而后续再调用 mytbf_init() 的时候就不会启动添加令牌的线程了。</p><p>上面代码中调用 pthread_once(3) 相当于下面的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span> (init_flag)</span><br><span class="line">&#123;</span><br><span class="line">    init_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span>;</span><br><span class="line">pthread_mutex_init();</span><br><span class="line">pthread_mutex_destroy();</span><br><span class="line">pthread_mutex_lock();</span><br><span class="line">pthread_mutex_trylock();</span><br><span class="line">pthread_mutex_unlock();</span><br><span class="line">pthread_once();</span><br></pre></td></tr></table></figure><h3 id="1-3-2-通知法"><a href="#1-3-2-通知法" class="headerlink" title="1.3.2 通知法"></a>1.3.2 通知法</h3><blockquote><p>上面的几种方法是盲等法，下面介绍通知法。</p></blockquote><p>条件变量（pthread_cond_t）（通知法的一种机制）</p><p>上面的程序经过测试，发现 CPU 正在满负荷工作，说明程序中出现了忙等， 是哪里出现了忙等呢？其实就是 mytbf_fetchtoken() 函数获得锁的时候采用了忙等的方式。前面我们提到过，异步程序有两种处理方式，一种是通知法，一种是查询法，我们这里用的就是查询法，下面我们把它修改成个通知法来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mytbf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个令牌桶 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cps;             <span class="comment">// 速率</span></span><br><span class="line">    <span class="keyword">int</span> burst;           <span class="comment">// 令牌上限</span></span><br><span class="line">    <span class="keyword">int</span> token;           <span class="comment">// 可用令牌数量</span></span><br><span class="line">    <span class="keyword">int</span> pos;             <span class="comment">// 当前令牌桶在 job 数组中的下标</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mut; <span class="comment">// 用来保护令牌竞争的互斥量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 用于在令牌互斥量状态改变时发送通知</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有的令牌桶 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">job</span>[<span class="title">MYTBF_MAX</span>];</span></span><br><span class="line"><span class="comment">/* 用来保护令牌桶数组竞争的互斥量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">/* 添加令牌的线程 ID */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="comment">/* 初始化添加令牌的线程 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程处理函数：负责定时向令牌桶中添加令牌 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_alrm</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">        <span class="comment">// 遍历所有的桶</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MYTBF_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 为可用的桶添加令牌</span></span><br><span class="line">            <span class="keyword">if</span> (job[i] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">                job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">                <span class="comment">// 桶中可用的令牌不能超过上限</span></span><br><span class="line">                <span class="keyword">if</span> (job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                    job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">                <span class="comment">// 令牌添加完毕之后，通知所有等待使用令牌的线程准备抢锁</span></span><br><span class="line">                <span class="comment">// 因为 pthread_cond_sigal 只能唤醒一个等待，假如当前有10个令牌桶都在等待取token</span></span><br><span class="line">                pthread_cond_broadcast(&amp;job[i]-&gt;cond);</span><br><span class="line">                pthread_mutex_unlock(&amp;job[i]-&gt;mut);</span><br><span class="line">                <span class="comment">// 先broadcast/sigal 还是 先 unlock 区别并不大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        <span class="comment">// 等待一秒钟后继续添加令牌</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_unload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (job[i] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 互斥量和条件变量使用完之后不要忘记释放资源</span></span><br><span class="line">            pthread_mutex_destroy(&amp;job[i]-&gt;mut);</span><br><span class="line">            pthread_cond_destroy(&amp;job[i]-&gt;cond);</span><br><span class="line">            <span class="built_in">free</span>(job[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">module_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_alrm, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 为了不破坏调用者对令牌桶操作的原子性，</span></span><br><span class="line"><span class="comment">  * 在该函数内加锁可能会导致死锁，</span></span><br><span class="line"><span class="comment">  * 所以该函数内部无法加锁，</span></span><br><span class="line"><span class="comment">  * 必须在调用该函数之前先加锁。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_free_pos_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MYTBF_MAX; i++)</span><br><span class="line">        <span class="keyword">if</span> (job[i] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mytbf_t</span> *<span class="title">mytbf_init</span><span class="params">(<span class="keyword">int</span> cps, <span class="keyword">int</span> burst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    pthread_once(&amp;init_once, module_load);</span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;token = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pos = get_free_pos_unlocked();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_fetchtoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="comment">// 令牌数量不足，等待令牌被添加进来</span></span><br><span class="line">    <span class="keyword">while</span> (me-&gt;token &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 原子化的解锁、出让调度器再抢锁以便工作或等待</span></span><br><span class="line"><span class="comment">          * 它会等待其它线程发送通知再唤醒</span></span><br><span class="line"><span class="comment">          * 放在循环中是因为可能同时有多个线程再使用同一个桶，</span></span><br><span class="line"><span class="comment">          * 被唤醒时未必就能拿得到令牌，所以要直到能拿到令牌再出去工作</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="comment">// 发现 me-&gt;token &lt;= 0</span></span><br><span class="line">        <span class="comment">// 就解锁等待，等到什么时候。等待 pthread_cond_broadcast/pthread_cond_signal</span></span><br><span class="line">        <span class="comment">// pthread_cond_broadcast是发通知/发消息，来打断一个wait，signal是打断任意一个wait。</span></span><br><span class="line"></span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond, &amp;me-&gt;mut); <span class="comment">// 解锁等待</span></span><br><span class="line">        <span class="comment">// pthread_cond_wait 相当于下面三句话的功能，但不是等价封装；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        pthread_mutex_unlock(&amp;me-&gt;mut);</span></span><br><span class="line">        <span class="comment">//        sched_yield();</span></span><br><span class="line">        <span class="comment">//        pthread_mutex_lock(&amp;me-&gt;mut);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">min</span>(me-&gt;token, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 令牌用不完要归还哟，可不能浪费了 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_returntoken</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逗我玩呢？</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    me-&gt;token += <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span> (me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 令牌归还完毕，通知其它正在等待令牌的线程赶紧起床，准备抢锁</span></span><br><span class="line"><span class="comment">      * 这两行谁在上面谁在后面都无所谓</span></span><br><span class="line"><span class="comment">      * 如果先发通知再解锁，收到通知的线程发现锁没有释放会等待锁释放再抢；</span></span><br><span class="line"><span class="comment">      * 如果先解锁再发通知，反正已经出了临界区了，</span></span><br><span class="line"><span class="comment">      * 就算有线程在通知发出之前抢到了锁也不会发生竞争，</span></span><br><span class="line"><span class="comment">      * 大不了其它被唤醒的线程起床之后发现没有锁可以抢，那就继续睡呗。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mytbf_destroy</span><span class="params">(<span class="keyword">mytbf_t</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mytbf_st</span> *<span class="title">me</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    job[me-&gt;pos] = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 大家不难看出这两段代码的差别，把查询法（忙等）修改为通知法（非忙等）仅仅加一个条件变量（pthread_cond_t） 就行了。</p><p>条件变量的作用是什么？其实就是让线程以无竞争的形式等待某个条件的发生，当条件发生时通知等待的线程醒来去做某件事。</p><p>通知进程醒来有两种方式，一种是仅通知一个线程醒来，如果有多个线程都在等待，那么不一定是哪个线程被唤醒；另一种方式是把所有等待同一个条件的线程都唤醒。</p><p>在下面我们会介绍这两种方式，先从条件变量的初始化和销毁开始讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cond_destroy, pthread_cond_init - destroy and initialize condition variables</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure><p>与互斥量一样，条件变量也有两种方式初始化，一种是使用 pthread_cond_init(3) 函数，另一种是使用 PTHREAD_COND_INITIALIZER 宏。这两种方式的使用场景也与互斥量相同，这里就不再赘述了。</p><p>条件变量在使用完毕之后不要忘记用 pthread_cond_destroy(3) 函数释放资源，否则会导致内存泄漏！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cond_broadcast, pthread_cond_signal -  broadcast  or  signal  a condition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数就是条件变量的关键操作了，大家注意看。</p><p>pthread_cond_signal(3) 函数用于唤醒当前多个等待的线程中的任何一个。虽然名字上有 signal，但是跟系统中的信号没有任何关系。</p><p>pthread_cond_broadcast(3) 惊群，将现在正在等待的线程全部唤醒。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cond_timedwait, pthread_cond_wait - wait on a condition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>这几个函数与上面的两个函数的作用是成对的，上面的两个函数用于唤醒线程，唤醒什么线程呢？当然是唤醒 _wait() 等待条件满足的线程啦。</p><p>当一个线程做某件事之前发现条件不满足，那就使用这几个 _wait() 函数进入等待状态，当某个线程使条件满足了就要用上面的两个函数唤醒等待的线程继续工作了。</p><p>pthread_cond_wait(3) 在临界区外阻塞等待某一个条件发生变化，直到有一个通知到来打断它的等待。这种方式是死等。</p><p>pthread_cond_timedwait(3) 增加了超时功能的等待，超时之后无论能否拿到锁都返回。这种方式是尝试等。</p><p>pthread_cond_wait(3) 相当于下面三行代码的原子操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(mutex);</span><br><span class="line">sched_yield();</span><br><span class="line">pthread_mutex_lock(mutex);</span><br></pre></td></tr></table></figure><p>通常等待会放在一个循环中，就像上面的令牌桶栗子一样，因为可能有多个线程都在等待条件满足，当前的线程被唤醒时不代表执行条件一定满足，可能先被唤醒的线程发现条件满足已经去工作了，等轮到当前线程调度的时候条件可能就又不满足了，所以如果条件不满足需要继续进入等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primer0_pool.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT   30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 期待num 变成一个任务，然后就能去抢任务了。</span></span><br><span class="line"><span class="comment"> * 忙等，忙在哪里？</span></span><br><span class="line"><span class="comment"> * 忙在上流和下流在不停的 抢num， 看状态。下流在抢num ，期待它不是 0.</span></span><br><span class="line"><span class="comment"> * 变为通知法，逻辑应该是</span></span><br><span class="line"><span class="comment"> * 下流一直处于等待状态，上流往num中放了一个任务之后。发一个通知，下流的几个都在wait。</span></span><br><span class="line"><span class="comment"> * 上流其实 发一个 signal就可以，因为下游的任务长的一样，叫醒任何一个让它拿num的值去计算即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span>  cond_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pthread_mutex_unlock(&amp;mut_num);</span></span><br><span class="line">            <span class="comment">// // sleep(1); sleep会让当前进程进入 沉睡状态 造成调度颠簸，用下面sched_yield</span></span><br><span class="line">            <span class="comment">// sched_yield();   // sched 开头的全部是针对于调度器来操作的，sched_yield的作用是出让调度器给其他的线程，</span></span><br><span class="line">            <span class="comment">// // 可以理解为一个非常短的sleep，但不会引起当前进程的调度颠簸</span></span><br><span class="line">            <span class="comment">// // 这里调用该函数是希望其他线程能拿到 num的值， 并有机会改写num的值</span></span><br><span class="line">            <span class="comment">// pthread_mutex_lock(&amp;mut_num);</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num); <span class="comment">// 解锁在临界区外的等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        num = i;</span><br><span class="line">        pthread_cond_signal(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num!= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>; <span class="comment">// 当main发放 最后一张牌的时候，并不能直接置成 -1. 须先调用sched_yield 出让出去，让其他线程抢到；</span></span><br><span class="line">    pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>); <span class="comment">// 给线程收尸</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num); <span class="comment">// 销毁互斥量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond_num); <span class="comment">// 销毁条件变量</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pthread_mutex_unlock(&amp;mut_num);</span></span><br><span class="line">            <span class="comment">// sched_yield();</span></span><br><span class="line">            <span class="comment">// pthread_mutex_lock(&amp;mut_num);</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 临界区内的任何一个跳转到临界区以外的break。跳转之前须解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]%d is a primer\n"</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们上面提到的面试题吗？用锁链实现的疯狂的有序的打印 abcd 5 秒钟。</p><p>上面我们说了，锁链的办法并不是这道题的考点，这道题真正的考点其实是使用互斥量 + 条件变量的方式来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n+<span class="number">1</span> == THRNUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用条件变量将其变为通知法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">'a'</span> + n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut);</span><br><span class="line">        <span class="keyword">while</span>(num != n)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mut);</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        num = next(num);</span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-信号量（Semaphore）"><a href="#1-3-3-信号量（Semaphore）" class="headerlink" title="1.3.3 信号量（Semaphore）"></a>1.3.3 信号量（Semaphore）</h3><blockquote><p>一个控制同时访问一个资源的线程（进程）数量的抽象数据类型；</p><p>信号量 内部封装了一个整数（p）和一个睡眠线程集合（s），并提供两个原子操作</p></blockquote><ul><li>up()<ul><li>p = p+1</li><li>如果s.size() &gt; 0, 从s中选择一个唤醒并执行</li></ul></li><li>down()<ul><li>If(p==0){sleep(&amp;semaphore)}</li><li>p–</li></ul></li></ul><h4 id="如何理解TSL-Semaphore-Mutex的关系"><a href="#如何理解TSL-Semaphore-Mutex的关系" class="headerlink" title="如何理解TSL/Semaphore/Mutex的关系"></a>如何理解TSL/Semaphore/Mutex的关系</h4><ul><li>TSL/XCHG是基础能力（否则就得用忙等待算法）</li><li>Semaphore是一种基于TSL成立的算法和数据结构（理解成解决方案）<ul><li>Mutex是Semaphore的一种产出（特殊情况）</li></ul></li><li>算法数据结构当然无穷无尽，参考：AQS(Abstract Queued)</li></ul><h4 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare and Swap）"></a>CAS（Compare and Swap）</h4><p><img src="cas01.png" alt="image-20210525170024664"></p><p>线程1 和线程2 需要对需要访问的临界区变量a都保留了自己本地的一个copy；</p><p>当线程2，加1之后，并同步到临界区中。线程1也想将a+1， 因此先将本地a+1，为了不要出问题选择了将本地的101和临界区比较，因此发现了冲突；谁冲突谁解决，所以线程1需要自己解决；这种机制会唤做 乐观锁；</p><ul><li>读不需要同步</li><li>写需要同步</li><li>适用于写操作较少，读操作较多的场景</li><li>注意：临界区的操作依然需锁</li></ul><h3 id="1-3-4-读写锁"><a href="#1-3-4-读写锁" class="headerlink" title="1.3.4 读写锁"></a>1.3.4 读写锁</h3><blockquote><p>互斥量和信号量的综合使用</p></blockquote><p>读写锁： 读锁-&gt; 共享锁    写锁 -&gt; 互斥锁</p><p>那么应该在什么场景中选择使用 pthread_cond_signal(3) 还是使用 pthread_cond_broadcast(3) 呢？</p><p>这个其实没有固定的套路，要根据具体的场景来选择。一般只有一个线程在等待或者明确知道哪个线程应该被唤醒的时候使用 _signal() 函数，如果有多个线程在等待并且不确定应该由谁起来工作的时候使用惊群。</p><p>LZ 说的不确定是指业务上不能确定哪个线程应该工作，而不是你作为程序猿稀里糊涂的不知道哪个线程该工作。程序猿应该保证了解你的每一行代码在做什么，而不要写出一坨自己都不知道它在做什么的代码。</p><p>至于应该先发通知再解锁还是先解锁再发通知，效果上没有太大的区别，这一点在上面令牌桶的栗子中已经阐述了。</p><p>11.下面纯属吐槽： </p><p>处理常规任务时，是采用多线程比较快还是采用多进程比较快？</p><p>如果只回答多线程比较快，那么你歇了。</p><p>应该回答常规情况下是多线程较快，因为多进程需要重新布置进程的执行空间，还需要进行数据拷贝以及部分配置，所以会比创建线程慢xx倍。不要只回答一个大方向就完事了，而是要量化你的答案，这样才能体现出来你在平时学习工作中很注重这些细节问题。</p><p>12.一个进程最多能创建多少个线程</p><p>一个进程能够创建多少个线程呢？主要受两个因素影响，一个是 PID 耗尽，一个是我们在之前的博文中画 C 程序地址空间布局时的阴影区域被栈空间占满了 。（不记得那副图了，去前面的博文里找找。）</p><p>PID 看上去是进程 ID，但是在之前讨论进程的博文中我们讨论过，内核的最小执行单元其实是线程，实际上是线程在消耗 PID。一个系统中的线程可以有很多，所以 PID 被耗尽也是有可能的。</p><p>使用 ulimit(1) 命令可以查看栈空间的大小，阴影区剩余空间的大小 / 栈空间的大小 == 就是我们能创建的线程数量。</p><p>大家可以自己写个程序测试一下一个进程最多能够创建多少个线程，然后使用 ulimit(1) 命令修改栈的大小再测试几次，看看能有什么发现。代码很简单，LZ 就不贴出来了。</p><p>13.管道的特点</p><p>1）管道的同义词是队列；</p><p>2）管道是单工的；</p><p>3）管道必须凑齐读写双方，如果只有一方，则阻塞等待。</p><p>关于管道的详细内容，我们在后面讨论进程间通信（IPC）的时候还会再详细讨论。</p>]]></content>
      
      
      <categories>
          
          <category> apue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="2020/12/09/test/"/>
      <url>2020/12/09/test/</url>
      
        <content type="html"><![CDATA[<h2 id="配置hexo到阿里云"><a href="#配置hexo到阿里云" class="headerlink" title="配置hexo到阿里云"></a>配置hexo到阿里云</h2><blockquote><p>网上大多数教程问题不大，额外需要注意修改一些文件的写入权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将post-receive 设置为可执行文件</span></span><br><span class="line">chmod +x ~/hexo.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置博客源地址文件夹权限，不然git hooks写入不了，Unable to unlink 就是这种原因</span></span><br><span class="line">sudo chmod -R 777 /home/www/hexo</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
            <tag> markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo</title>
      <link href="2020/06/04/hello-world/"/>
      <url>2020/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloworld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(helloworld);</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
            <tag> markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
