<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C</title>
      <link href="2021/01/25/C/"/>
      <url>2021/01/25/C/</url>
      
        <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="1-如何写程序"><a href="#1-如何写程序" class="headerlink" title="1.如何写程序"></a>1.如何写程序</h2><blockquote><p>写程序前，先构想好程序的结构，而不是先从定义变量开始。</p></blockquote><ol><li>没有想好解决方案，不要急于动手写程序？</li><li>有了解决方案以后，可以按照“先粗后细，先抽象后具体”的办法，先有程序的轮廓，如有必要可以解决“建模工具”画一些图，而后再动手写程序；</li><li>写程序时，可以先写出程序轮廓，而后再补充变量定义等细节；</li></ol><p><strong>百元买百鸡问题：</strong></p><p>嘉定区小鸡每只5毛，公鸡每只2元，母鸡每只3元。现在有100元要求买100只鸡，编程列出所有可能的购鸡方案;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  x+y+z = <span class="number">100</span></span><br><span class="line">  <span class="number">3</span>x+<span class="number">2</span>y+<span class="number">0.5</span>z = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>穷举:  *</em></p><p>将可能出现的各种情况一一测试，判断是否满足条件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y,z;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">33</span>;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">50</span>;y++)&#123;</span><br><span class="line"><span class="keyword">for</span>(z=<span class="number">0</span>;z&lt;=<span class="number">100</span>;z++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x+y+z==<span class="number">100</span>)&amp;&amp;(<span class="number">3</span>*<span class="number">2</span>+<span class="number">2</span>*y+<span class="number">0.5</span>*z)==<span class="number">100</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;x&#125;</span> <span class="subst">$&#123;y&#125;</span> <span class="subst">$&#123;z&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>简化版: *</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y,z;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">33</span>;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">50</span>;y++)&#123;</span><br><span class="line">z=<span class="number">100</span>-x-y</span><br><span class="line"><span class="keyword">if</span>((<span class="number">3</span>*<span class="number">2</span>+<span class="number">2</span>*y+<span class="number">0.5</span>*z)==<span class="number">100</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;x&#125;</span> <span class="subst">$&#123;y&#125;</span> <span class="subst">$&#123;z&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，程序并不纠结于是否更优。<br>而在于程序结构是不是清楚，是不是容易被人看懂</p><h3 id="1-1-写程序的过程"><a href="#1-1-写程序的过程" class="headerlink" title="1.1 写程序的过程"></a>1.1 写程序的过程</h3><blockquote><p>按照由大到小，由粗到细，由抽象到具体的方法分析、编写程序</p></blockquote><ul><li>程序的结构 （基本思想）<ul><li>程序由若干个“模块”组成</li><li>模块之内“高内聚”（高内聚， 就是这个模块只做这个事情，不干别的。功能单一）</li><li>模块之间“低耦合” （当一个模块被改动的时候，只会印象它自己，而不会影响别的）</li></ul></li></ul><h3 id="1-2-如何学习编程语言-（语法）"><a href="#1-2-如何学习编程语言-（语法）" class="headerlink" title="1.2 如何学习编程语言 （语法）"></a>1.2 如何学习编程语言 （语法）</h3><p>程序设计语言的构成,语言种类千差万别，但是，一般来说，基本成分不外四种：</p><ol><li>数据成分， 用以描述程序中所涉及的数据 （数据类型）</li><li>运算成分，用以描述程序中所包含的运算；（运算符）</li><li>控制成分，用以表达程序中的控制构造；（三种类型的控制语句是如何写的，顺序，分支，循环）</li><li>传输成分，用以表达程序中数据的传输； （如何输入和输出数据）</li></ol><h3 id="1-3-为什么是C语言"><a href="#1-3-为什么是C语言" class="headerlink" title="1.3  为什么是C语言"></a>1.3  为什么是C语言</h3><p>虽然现代工业化语言如 Java、Golang 等已经足够强大，但是你要知道，在这些语言的背后，无一例外的总是有 C 语言的影子。C 语言是可以和系统直接交互的语言，无论是系统调用，还是内核实现，都和 C 语言有非常直接的联系，比如 Java 本身就是用 C++ 实现的，Golang 虽然现在可以自举，也就是可以使用 Golang 实现 Golang 本身，但是它的第一版也是用 C/C++ 实现的。</p><p>我不建议一开始就学习 C++ 语言，在我看来, C++ 语言在 C 语言原来的基础上做了很多语言层面的增强，而这些增强的语言特性，例如模板、继承、虚函数、boost 语言库等，对于刚开始接触底层的人显得有些艰深。</p><p>学习一门编程语言，显然不是学习这门语言的控制流或者变量类型，而是抓住这门语言的精髓。我认为 C 语言的精髓包括数组和指针、结构体和函数。</p><p>C 语言的地址、数组、指针可以帮助我们详细地理解计算机的体系结构，一段数据怎样在内存中摆放，怎么去访问等，你可以在学习它们的过程中得到锤炼，了解这些基础的编程理念。</p><h3 id="1-4-C语言特点："><a href="#1-4-C语言特点：" class="headerlink" title="1.4. C语言特点："></a>1.4. C语言特点：</h3><ol><li>基础性语言</li><li>语法简洁，紧凑，方便，灵活（指针的存在）</li><li>运算符，数据结构丰富</li><li>结构化，模块化编程</li><li>移植性好，执行效率高（语言比较低级，类汇编语言）</li><li>允许直接对硬件操作 （贴着硬件编程）</li></ol><h3 id="1-5-学习建议"><a href="#1-5-学习建议" class="headerlink" title="1.5 学习建议"></a>1.5 学习建议</h3><ol><li>掌握正确的概念</li><li>动手能力，多写码</li><li>阅读优秀的程序段（先写，再去看别人的精华，养成编程的习惯）</li><li>大量的练习，面试题。（面试题一般考察的是语言中容易弄混淆的点，具有代表性）</li></ol><h3 id="1-6-大纲"><a href="#1-6-大纲" class="headerlink" title="1.6 大纲"></a>1.6 大纲</h3><ol><li>基本概念</li><li>数据类型，运算符，表达式</li><li>IO</li><li>流程控制（顺序，分支，循转）</li><li>数组</li><li>指针</li><li>函数</li><li>构造类型</li><li>动态内存管理</li><li>调试工具，（gdb，make）</li><li>常用库函数</li></ol><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><blockquote><p>把内存想象成一个长长的带子,带子上面有很多小方格，每个格子都是一个字节（存储单元）。每个小方格都有它对应的地址，每个字节（单元）有八位，1B（byte） = 8b（bit）每一个位存储一个二进制的数。</p></blockquote><h3 id="2-1-变量与常量"><a href="#2-1-变量与常量" class="headerlink" title="2.1 变量与常量"></a>2.1 变量与常量</h3><h4 id="2-1-1-常量"><a href="#2-1-1-常量" class="headerlink" title="2.1.1 常量"></a>2.1.1 常量</h4><blockquote><p>在程序执行过程中值不会发生变化的量，数组名是一个典型的常量，一旦数组定义了，gcc为当前的数组分配了一段空间了。然后数组的位置就定死了。数组名就是一个数组的起始位置。是一个常量，如果你在=左边写上一个常量，就表示企图更改一个常量的值；比如<code>1=f</code> ，显然不成立；</p></blockquote><p><strong>常量的分类</strong></p><ul><li><p>整型常量</p></li><li><p>实型常量</p><p>3.14,  5.26;</p></li><li><p>字符常量</p><p>由单引号印起来的单个字符或者转义字符，如’a’</p><p>转义字符： ‘\n’, ‘\r’, ‘\t’ ，’\015’(八进制数)， ‘\x7f’(十六进制数)</p></li><li><p>字符串常量</p><p>由双引号印起来的一个或多个字符组成的序列，如: “”(空串)</p><p>一个字符串在存储的时候，最末尾会有一个结束标记，通常称作尾0<code>\0</code>.所以<code>&quot;&quot;</code>是占空间的，空字符占一个字节的空间；</p><ul><li>合法的字符串 （””, “a”, “abXYZ”）</li><li>暂时不确定是否合法的字符 （”abc\n\021\018”) 因为<code>\018</code>不是八进制，因为出现了8，而我们知道<code>\0</code>是字符串数组的末尾。所以<code>\0</code>到底能否插入进字符串中间，这个需要后续字符数组专题揭秘；</li><li>字符串常量需要借助构造类型——数组来保存</li><li><code>&#39;a&#39;和&quot;a&quot;的区别</code>：前者是字符常量，后者是字符串常量。</li></ul></li><li><p>标识常量</p><ul><li><p>#define， 程序中一改全改 <code>#define PI 3.14</code>，在程序预处理之后，宏名被宏体完整的替换；<code>define ADD 2+3 ADD*ADD</code> = <code>2+3*2+3而不是(2+3)*(2+3)</code>。 #define，处理在程序的预处理阶段，占编译时间。不占运行时间。一改全改；缺点： 不检查语法，只是单纯的宏体与宏名之间的替换；</p><ol><li>带参数的#define</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX(a, b)  a&gt;b?a:b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  i = <span class="number">5</span>;</span><br><span class="line">  j=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"/d\n"</span>, MAX(i, j));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -E define.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  i = <span class="number">5</span>;</span><br><span class="line">  j=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"/d\n"</span>, (i&gt;j?i:j));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>一个特殊问题的解决方式</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max = %d\n"</span>, MAX(i++, j++));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i=%d\tj=%d\n"</span>, i, j);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((i++) &gt; (j++) ? (i++) : (j++))</span><br><span class="line"></span><br><span class="line"><span class="comment">// max = 6</span></span><br><span class="line"><span class="comment">// i=7     j=4</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>首先，max和MAX的区别，MAX只占用预编译时间，等运行的时候，实际上已经将所有宏体替换到程序中去了。不会再需要额外的时间了。而max则不同，在函数的调用位置，对当前的一个执行现场做一个压栈保存。然后去到指定的函数去执行。（跳往另外一个入口地址）然后再回来，弹栈恢复当前现场的过程。这个过程 占用了运行的时间；</p></li><li><p>什么时候用宏，什么时候用函数？在需要极致性能的场景用宏，前提是宏能满足；比如内核。在应用层面，系统层面，多用函数。因为应用层要求更高的是稳定性，而非实时性。</p></li><li><p>解决方案，需要找一个变量来接受；而不是让其继续做加运算；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (&#123;typeof(a) A = a, B = b;((A) &gt; (B) ? (A) : (B)); &#125;)</span></span><br><span class="line"><span class="comment">// typeof(a) 用a的类型定义A，就很灵性了。有点泛型的意思了；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max = %d\n"</span>, MAX(i++, j++));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i=%d\tj=%d\n"</span>, i, j);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// max = 5</span></span><br><span class="line"><span class="comment">// i=6     j=4</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-变量"><a href="#2-1-2-变量" class="headerlink" title="2.1.2 变量"></a>2.1.2 变量</h4><blockquote><p>用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量；</p></blockquote><p>当计算机执行到 <code>int max=0</code> 这句程序时，计算机会在内存里面找到一片存储空间（几个连续的存储单元），然后给该片存储空间取个名字叫 <code>Max</code>， 再把 <code>0</code> 这个初始值放在这个存储空间中来。<code>并记下这个名字（Max）和这片连续的存储空间的起始的地址之间的对应关系</code></p><p>定义： [存储类型]  数据类型  标识符 =  值 </p><p><code>TYPE NAME = VALUE;</code></p><p>存储类型 可选</p><h5 id="2-1-2-1-标识符"><a href="#2-1-2-1-标识符" class="headerlink" title="2.1.2.1 标识符"></a>2.1.2.1 标识符</h5><p>当定义一个某种类型的标识符的时候，编译器会为当前的值分配一块内存空间；如何称呼这块空间，就是<code>房间号</code>。房间号就是标识符。编译器会给标识符（房间号）和内存地址标识做关联。当搜索变量名的时候，编译器知道要去到哪块内存地址去搜索；简单说，标识符就是这块空间的临时别名；</p><h4 id="2-1-3-存储类型"><a href="#2-1-3-存储类型" class="headerlink" title="2.1.3 存储类型"></a>2.1.3 存储类型</h4><blockquote><p>auto, static register extern(说明型)</p></blockquote><h5 id="2-1-3-1-auto"><a href="#2-1-3-1-auto" class="headerlink" title="2.1.3.1 auto"></a>2.1.3.1 auto</h5><blockquote><p>默认，自动分配空间，自动回收空间</p></blockquote><p>auto类型分配在栈上，堆主要是来进行动态内存分配的空间；堆栈不挨着</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">int</span> i; <span class="comment">// 原则上不会 对 i所在这块空间进行初始化</span></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i); <span class="comment">// 随机的结果，当然有的编译器会置为0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"j= %d\n"</span>, j); <span class="comment">// 0  编译器会初始化为0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x =<span class="number">0</span>;</span><br><span class="line">  x = x+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明： 这三个地址未必一致，但一致的原因是 auto类型的变量都存放在栈上，栈上的空间按正常理论来讲，它实际上是连续分配的。而当前x在  func函数被调用的时候，它才会被产生。然后在当前函数执行结束的时候，这块空间被释放掉了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="2-1-3-2-register"><a href="#2-1-3-2-register" class="headerlink" title="2.1.3.2 register"></a>2.1.3.2 register</h5><blockquote><p>建议型关键字；</p></blockquote><p>寄存器类型，资源少，速度快，寄存器存放在CPU当中，寄存器的数据比较吃紧，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i =<span class="number">1</span>; <span class="comment">// 除非i在程序中，超高频率被使用，才建议编译器将i分配到寄存器中；至于有没有被放到寄存器中，由gcc来决定；</span></span><br></pre></td></tr></table></figure><p><strong>register的苛刻条件；</strong></p><ol><li>只能定义局部变量，不能定义全局变量；</li><li>大小有限制，只能定义 32 位大小的数据类型，如double 就不可以</li><li>寄存器中没有地址，所以一个寄存器类型变量无法打印出地址查看或者使用；</li></ol><h5 id="2-1-3-3-static"><a href="#2-1-3-3-static" class="headerlink" title="2.1.3.3 static"></a>2.1.3.3 static</h5><blockquote><p>静态型，自动初始化为0值或空值，并值其变量的值有继承性。另外，常用于修饰变量或函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> x =<span class="number">0</span>;</span><br><span class="line">  x = x+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;1</span></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;2</span></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;3</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明： static类型的变量，只用一块空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>static 修饰函数：</strong></p><p>防止该函数对外扩展，（简单说就是该函数只能在当前文件下使用，在别的文件下没法使用；）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello func"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_func</span><span class="params">()</span>  <span class="comment">// 外界可以通过 call_func 这个桥梁函数来引用 func</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-3-4-extern"><a href="#2-1-3-4-extern" class="headerlink" title="2.1.3.4 extern"></a>2.1.3.4 extern</h5><blockquote><p>说明型， 意味着不能改变被说明的变量的值或类型；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proj.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">  func();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proj.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proj.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">// 我的i不是自己定义的，是引用其他文件里面的i，编译器自己去找</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-编译"><a href="#3-编译" class="headerlink" title="3. 编译"></a>3. 编译</h2><h3 id="3-1-C编译"><a href="#3-1-C编译" class="headerlink" title="3.1 C编译"></a>3.1 C编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c  <span class="comment"># 把test.c 编译成一个可执行文件 test</span></span><br><span class="line">gcc hello.c -Wall   <span class="comment"># 显示编译警告，原则上编码过程当中把程序调到没有警告为止；</span></span><br><span class="line">./<span class="built_in">test</span>              <span class="comment"># 执行 test</span></span><br></pre></td></tr></table></figure><h3 id="3-2-多个-c文件"><a href="#3-2-多个-c文件" class="headerlink" title="3.2 多个.c文件"></a>3.2 多个.c文件</h3><ul><li>main() 里的代码太长了 适合分成几个函数</li><li>一个源文件太长适合分成几个文件</li><li>两个独立的源文件不能编译形成可执行的程序</li></ul><h3 id="3-3-头文件"><a href="#3-3-头文件" class="headerlink" title="3.3 头文件"></a>3.3 头文件</h3><blockquote><p>把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件(.c文件)中  #include 这个头文件，就能让编译器在编译的时候知道函数的原型</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.c  max.c  max.h</span></span><br><span class="line">gcc  main.c  max.c</span><br></pre></td></tr></table></figure><h2 id="4-C程序"><a href="#4-C程序" class="headerlink" title="4. C程序"></a>4. C程序</h2><h3 id="4-1-程序规范"><a href="#4-1-程序规范" class="headerlink" title="4.1 程序规范"></a>4.1 程序规范</h3><blockquote><p>以helleworld为例对写程序的思路提出如下要求:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void main(void);</span></span><br><span class="line"><span class="comment">//void main(int argc, char **argv); // char * argv[]</span></span><br><span class="line"><span class="comment">//int main(int argc, char **argv);</span></span><br><span class="line"><span class="comment">//int main(void);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello c!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>头文件正确包含的重要性；</li><li>知道程序中的所有警告<code>gcc file.c -Wall</code></li><li>如何调试段错误，先把程序中的所有警告调好；</li><li>以函数为单位来进行程序编写；</li><li>声明部分 和  实现部分（变量先定义，后使用）</li><li>return 0 （exit(0) 在单进程单线程的程序中 和 return 0意义一样的，exit(0)是给它父进程看的，当前main函数的父进程是shell）</li><li>多用空格空行</li><li>添加注释</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $? <span class="comment"># 上一条语句执行的状态</span></span><br></pre></td></tr></table></figure><h3 id="4-2-注释"><a href="#4-2-注释" class="headerlink" title="4.2 注释"></a>4.2 注释</h3><blockquote><p>#if #endif 注释</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(0)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-3-编译"><a href="#4-3-编译" class="headerlink" title="4.3 编译"></a>4.3 编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gcc hello.c</span></span><br><span class="line">.c -&gt; .out</span><br></pre></td></tr></table></figure><p><strong>gcc过程(c源文件到可执行文件需要经过的顺序)</strong></p><p>c源文件 - 预处理 - 编译 - 汇编  - 链接 - 可执行文件</p><ul><li>预处理 <code>gcc -E hello.c &gt; hello.i</code> (预处理hello.c，保存至 hello.i 文件)<pre><code>以#开头的语句部分都是在预处理阶段解决掉的；`include`或者 `if define`</code></pre></li><li>编译阶段<code>gcc -S hello.i</code> (编译hello.i)<pre><code>默认会生成一个 .s文件，编译成汇编文件；</code></pre></li><li>汇编阶段<code>gcc -c hello.s</code><pre><code>生成一个 .o文件；</code></pre></li><li>链接阶段<code>gcc hello.o -o hello</code> (链接.o文件 生成可执行文件 hello)<pre><code>生成可执行文件hello;</code></pre></li></ul><h2 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5. 数据类型"></a>5. 数据类型</h2><ul><li>不同数据类型所占字节数</li><li>存储区别</li><li>不同类型的数据间转换</li><li>特殊性：</li></ul><h3 id="5-1-基本类型"><a href="#5-1-基本类型" class="headerlink" title="5.1 基本类型"></a>5.1 基本类型</h3><ul><li>数值类型 <ul><li>整型<ul><li>短整型 short   （2个字节，16位）</li><li>整型 int      （4个字节，32位）</li><li>长整型 long    （4个字节，32位）</li></ul></li><li>浮点型<ul><li>单精度型 float   （4个字节，32位）</li><li>双精度型 double    （8个字节，64位）</li></ul></li></ul></li><li>字符类型 char           （1个字节，8位）</li></ul><h4 id="1-1-1-整形存储"><a href="#1-1-1-整形存储" class="headerlink" title="1.1.1 整形存储"></a>1.1.1 整形存储</h4><p><strong>整型的存储都是以补码的形势来存储的</strong></p><p>补码：正数的补码是它二进制本身，负数的补码是它绝对值的那个数的二进制形式取反再加1的结果；</p><p>254 -&gt; unsigned int(无符号 int) -&gt; 32位</p><p>-254 -&gt; 254-&gt; 1111 1110 取反 +1  </p><ul><li>有无符号的区别，最高位到底代表是符号还是正常有效值；有符号的话，为0表示正数，为1表示负数；</li></ul><p>(254)10 =&gt; (11111110)2</p><p>方法： 除2取余倒序排列；（转2进制）11111110</p><pre><code>除8取余倒序排列；（转8进制）376除16取余倒序排列；（转16进制） FE</code></pre><p><strong>进制表示</strong></p><ul><li>254                 十进制</li><li>B11111110    二进制</li><li>0376               八进制</li><li>0xFE               十六进制</li></ul><h4 id="1-1-2-浮点型存储"><a href="#1-1-2-浮点型存储" class="headerlink" title="1.1.2  浮点型存储"></a>1.1.2  浮点型存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span> * <span class="number">10</span>^<span class="number">0</span></span><br><span class="line"><span class="number">0.314</span> * <span class="number">10</span>^<span class="number">1</span></span><br><span class="line"><span class="number">0.0314</span> * <span class="number">10</span>^<span class="number">2</span></span><br><span class="line"><span class="number">314</span> * <span class="number">10</span>^<span class="number">-2</span></span><br></pre></td></tr></table></figure><p><strong>浮点数是以0.314 * 10^1的方式来存储3.14的</strong></p><p><code>整数部分为0，只是在意精度部分是多少。然后在意指数部分是多少。</code></p><ul><li>浮点数在32 个bit上是如何存放的<br>0～22位（共23个bit）用来记录精度部分。 22位～30位（共8个bit） 用来存储的是指数部分。最高位（第31位） 表示的是符号位置，表示是正数还是负数；</li></ul><p><strong>举例</strong></p><p>0.000789 -&gt; 0.789 -&gt; 10^3</p><p><code>精度部分存储 789的二进制形式，8个位存储3</code></p><ul><li>float 32位</li><li>double 64位 ，比float多出来的32位完全放在精度的控制上</li></ul><h4 id="1-1-3-char存储"><a href="#1-1-3-char存储" class="headerlink" title="1.1.3 char存储"></a>1.1.3 char存储</h4><ul><li>char 8位。                    -128～127</li><li>unsigned char 8位。   0～255</li></ul><h4 id="1-1-4-不同类型的数据间转换"><a href="#1-1-4-不同类型的数据间转换" class="headerlink" title="1.1.4 不同类型的数据间转换"></a>1.1.4 不同类型的数据间转换</h4><h5 id="1-1-4-1-精度丢失"><a href="#1-1-4-1-精度丢失" class="headerlink" title="1.1.4.1 精度丢失"></a>1.1.4.1 精度丢失</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.9</span>;</span><br><span class="line"><span class="keyword">int</span> i = f; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h5 id="1-1-4-2-隐式转换"><a href="#1-1-4-2-隐式转换" class="headerlink" title="1.1.4.2 隐式转换"></a>1.1.4.2 隐式转换</h5><p><strong>编译器默认做的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">ch + i   --&gt; i  <span class="comment">// 默认往精度高，或者所占字节长比较高的那一种数据类型去靠拢的</span></span><br><span class="line">f -d     --&gt; d  <span class="comment">// 精度高的 double</span></span><br><span class="line">(ch + i) - (<span class="keyword">float</span> - <span class="keyword">double</span>) --&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><h5 id="1-1-4-3-显式转换"><a href="#1-1-4-3-显式转换" class="headerlink" title="1.1.4.3 显式转换"></a>1.1.4.3 显式转换</h5><p><strong>强制类型转换</strong></p><h5 id="1-1-4-4-特殊性："><a href="#1-1-4-4-特殊性：" class="headerlink" title="1.1.4.4 特殊性："></a>1.1.4.4 特殊性：</h5><ol><li>布尔型bool</li><li>float类型； <code>1.0/3*3 ！= 1</code></li><li>char型是否有符号，不知道，一个未定义的行为</li><li>不同形式的0值；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="string">'0'</span>;</span><br><span class="line"><span class="string">"0"</span>;</span><br><span class="line"><span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾）</li></ol><h3 id="1-2-构造类型"><a href="#1-2-构造类型" class="headerlink" title="1.2 构造类型"></a>1.2 构造类型</h3><ul><li>数组</li><li>结构体 struct</li><li>共用体  union</li><li>枚举类型 enum</li></ul><h4 id="1-2-1-enum"><a href="#1-2-1-enum" class="headerlink" title="1.2.1  enum"></a>1.2.1  enum</h4><p>*<em>语法: *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum 标识符</span><br><span class="line">&#123;</span><br><span class="line">  成员1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> day</span><br><span class="line">&#123;</span><br><span class="line">  MON,  <span class="comment">//默认从0 开始往下排</span></span><br><span class="line">  TUS,</span><br><span class="line">  THR,</span><br><span class="line">  WES,</span><br><span class="line">  FRI = <span class="number">1</span>,  <span class="comment">// 如果给FRI赋值为1的话，那么接下来会从1继续排</span></span><br><span class="line">  SAT,</span><br><span class="line">  SUN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main () &#123;</span><br><span class="line">  <span class="keyword">enum</span> day a = FRI;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>把enum当宏使用: *</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    STATE_RUNNING = <span class="number">1</span>,</span><br><span class="line">    STATE_CANCELED,</span><br><span class="line">    STATE_OVER</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">char</span> start;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_st</span> <span class="title">job1</span>;</span></span><br><span class="line">   <span class="comment">// job1.state = STATE_CANCELED;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (job1.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_CANCELED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_OVER:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_RUNNING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 信号，操作系统后续会讲</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 这种场景可以用 enum代替宏的使用: **</p><p>因为宏经过预编译之后被替换掉了，宏的部分会被替换。影响调试。<br>当然enum不是万能，并不能替代宏；宏还可以传递参数</p><h4 id="1-2-2-结构体类型"><a href="#1-2-2-结构体类型" class="headerlink" title="1.2.2 结构体类型"></a>1.2.2 结构体类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span>  <span class="comment">// student 不是变量名而是类型</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>]</span><br><span class="line">  .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>** 定义结构体变量的方式: **</p><p><code>student tudent1,student2;</code><br>(结构体类型名) (结构体变量名)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>]</span><br><span class="line">  .....</span><br><span class="line">&#125; lige_1, lige_2;</span><br></pre></td></tr></table></figure><p>** 结构体赋值: **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike2</span> = <span class="title">mike</span>;</span>  <span class="comment">// 结构体赋值相当于copy一份给对方</span></span><br><span class="line">    mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike2.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">        mike2.name[i] = <span class="built_in">toupper</span>(mike2.name[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike2.id_num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike2.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 结构体内存 ** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 看上去是10个字节，结果打印出来的是16个字节；</span></span><br><span class="line"><span class="comment">// 地址对齐， 结构体对齐的概念；</span></span><br></pre></td></tr></table></figure><ul><li>一个公式</li></ul><p>address（当前准备存储的变量的地址）%（你当前要存放变量的sizeOf）<br>如果能整除的话，那么这个变量就存放在这里，如果这个表达式不成立，那么address就得 + 1；</p><p>举例子说明,首先下面是一段内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">0</span><br><span class="line">----------</span><br><span class="line">1</span><br><span class="line">----------</span><br><span class="line">2</span><br><span class="line">----------</span><br><span class="line">3</span><br><span class="line">----------</span><br><span class="line">4</span><br><span class="line">----------</span><br><span class="line">5</span><br><span class="line">----------</span><br><span class="line">6</span><br><span class="line">----------</span><br><span class="line">7</span><br><span class="line">----------</span><br><span class="line">8</span><br><span class="line">----------</span><br><span class="line">9</span><br><span class="line">----------</span><br><span class="line">10</span><br><span class="line">----------</span><br><span class="line">11</span><br><span class="line">----------</span><br><span class="line">12</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>解释 *</em></p><p>首先内存第一个地址的值是0，结构体的第一个属性是int，我们知道int占4个字节。0/4 能整除，因此第一个int占据从0-3 这个几个内存中，然后 char占1个字节，4/1能整除，因此第二个char占据了4这个内存中。接着结构体第三个属性为float，占据4个字节。内存地址5/4没法整除，当前内存++，分别到6，7，都无法整除4.到了8，8/4能整除，所以，从8打11这一段内存就存放着float这个属性，接下来又是char12/1能整除，所以char属性占据了char12这个内存地址； </p><p><code>值得注意的是，不同的操作系统内存对齐的方式是不同的；因此在socket编程中，我们传过去的结构体数据在末端一定不能做对齐；因为不知道不同平台到底是什么字节对齐的</code></p><p>** 结构体对齐 **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure><p>这个操作在网络编程当中很常用；</p><p>总结</p><p>如果没有内存对齐，就是指定<strong>attribute</strong>((packed))的话，那么结构体内存的大小就是各个属性的sizeof累加的结果。如果没加就需要考虑内存对齐的问题，不同的机器内存对齐的方式是不同的。因为在跨机器编程比如socket编程当中，是需要指定<strong>attribute</strong>((packed))来确保数据的完整性和 安全性；</p><h4 id="1-2-2-1-结构体作为函数参数传递给函数（值传递，地址传递）"><a href="#1-2-2-1-结构体作为函数参数传递给函数（值传递，地址传递）" class="headerlink" title="1.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）"></a>1.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span> <span class="params">(struct student mike)</span> </span>&#123;</span><br><span class="line">    mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">           mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    renew(mike);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="number">20130123</span></span><br><span class="line">#MIKE</span><br><span class="line">#<span class="number">123</span></span><br><span class="line"><span class="meta">#mike</span></span><br></pre></td></tr></table></figure><ul><li>结论</li></ul><p>结构体的传入是 值拷贝，函数内部执行的是副本</p><h4 id="1-2-2-2-当把结构体当成形参传递的时候，意味着什么"><a href="#1-2-2-2-当把结构体当成形参传递的时候，意味着什么" class="headerlink" title="1.2.2.2 当把结构体当成形参传递的时候，意味着什么"></a>1.2.2.2 当把结构体当成形参传递的时候，意味着什么</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(struct simp_st b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 内存总是要分配一个完整的 结构体 体积所占的空间用来接受这个形参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(b)); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> *<span class="title">p</span> = &amp;<span class="title">a</span>;</span></span><br><span class="line">    func(a);</span><br><span class="line">    <span class="comment">// func(a.i, a.ch, a.f)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>小结： 所以我们一般不会这么去用。会有非常严重的性能浪费；一般我们会传递结构体指针；</li></ul><h4 id="1-2-2-3-结构体作为函数返回值时"><a href="#1-2-2-3-结构体作为函数返回值时" class="headerlink" title="1.2.2.3 结构体作为函数返回值时"></a>1.2.2.3 结构体作为函数返回值时</h4><p> 总结： 结构体作为函数返回值时，相当于copy一份给调用者</p><h4 id="1-2-2-4-指向结构体变量的指针"><a href="#1-2-2-4-指向结构体变量的指针" class="headerlink" title="1.2.2.4  指向结构体变量的指针"></a>1.2.2.4  指向结构体变量的指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> = &amp;<span class="title">mike</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*p).id_num);  <span class="comment">// 123</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 123   另外一种写法  -&gt; 指向运算符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// mike  另外一种写法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (*p).name);  <span class="comment">// mike</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-5-指向结构体变量的指针作为参数传入函数"><a href="#1-2-2-5-指向结构体变量的指针作为参数传入函数" class="headerlink" title="1.2.2.5 指向结构体变量的指针作为参数传入函数"></a>1.2.2.5 指向结构体变量的指针作为参数传入函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span> <span class="params">(struct student mike)</span> </span>&#123;</span><br><span class="line">   mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">          mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">   renew(&amp;mike);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num); <span class="comment">// 20130123    值被篡改</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);  <span class="comment">// MIKE         值被篡改</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-6-结构体数组"><a href="#1-2-2-6-结构体数组" class="headerlink" title="1.2.2.6 结构体数组"></a>1.2.2.6 结构体数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">myclass</span>[3] =</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="number">123</span>, &#123;<span class="string">'m'</span>,<span class="string">'k'</span>,<span class="string">'k'</span>,<span class="string">'e'</span>&#125;,</span><br><span class="line">        <span class="number">133</span>, &#123;<span class="string">'j'</span>,<span class="string">'o'</span>,<span class="string">'y'</span>&#125;,</span><br><span class="line">        <span class="number">143</span>, &#123;<span class="string">'t'</span>,<span class="string">'o'</span>,<span class="string">'m'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> * <span class="title">p</span> = &amp;<span class="title">myclass</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 123 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// mkke</span></span><br><span class="line">    p++; <span class="comment">// 跳一个结构体 体积的内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 133</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// joy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-7-链表"><a href="#1-2-2-7-链表" class="headerlink" title="1.2.2.7 链表"></a>1.2.2.7 链表</h4><ul><li>动态地 申请内存空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pint = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);   <span class="comment">// 开辟一片内存存储空间并返回起始地址； </span></span><br><span class="line"><span class="keyword">delete</span> pint;  <span class="comment">// 释放掉指针所指向的内存空间；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">// 申请一个 4个整型小数组的空间；并返回起始地址；</span></span><br><span class="line"><span class="keyword">delete</span> [] pia; <span class="comment">// 开个方括号，指的是释放掉的是一个数组区域</span></span><br></pre></td></tr></table></figure><ul><li>动态地 建立链表节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    student *next;</span><br><span class="line">&#125;</span><br><span class="line">student *head;</span><br><span class="line">head = <span class="keyword">new</span> student;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-共用体"><a href="#1-2-3-共用体" class="headerlink" title="1.2.3 共用体"></a>1.2.3 共用体</h4><blockquote><p>共用体和结构体语法很像，但截然不同的是，结构体各个成员会占用不同的内存，结构体整体内存 &gt;= sizeof（所有属性）， 因为有内存缝隙的 概念，所以有时候会大一些；而结构体的内存体积取决于最大属性的体积；共用体所有成员占据同一段内存；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来的值覆盖掉。</p></blockquote><p>** 语法** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 共用体名 &#123;</span><br><span class="line">  成员列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>产生</li><li>意义</li><li>类型嵌套</li><li>定义变量（变量，数组，指针），初始化及成员引用 (变量名.成员 指针名-&gt;成员)</li><li>占用内存大小</li><li>函数传参（值，地址）</li><li>位域</li></ul><h3 id="1-3-指针类型"><a href="#1-3-指针类型" class="headerlink" title="1.3 指针类型"></a>1.3 指针类型</h3><h3 id="1-4-空类型-void"><a href="#1-4-空类型-void" class="headerlink" title="1.4 空类型 void"></a>1.4 空类型 void</h3><h2 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6. 类型转换"></a>6. 类型转换</h2><p>存储涉及到2进制，8进制，10进制，16进制。这几种进制之间的转换首先要区别开，如何去获得一个二进制</p><h3 id="2-1-十进制转二进制"><a href="#2-1-十进制转二进制" class="headerlink" title="2.1  十进制转二进制"></a>2.1  十进制转二进制</h3><blockquote><p>除2取余，余数倒序排列</p></blockquote><p>254 -&gt; unsigned int -&gt; 32位 （4个字节）</p><p>254（10进制）-&gt; 11111110 (2进制) -&gt; 376 (8进制) -&gt; FE(16进制)</p><p>c语言程序当中是不识别二进制的</p><p>254         默认10进制<br>B11111110   二进制<br>0376        八进制<br>0xFE        十六进制</p><h3 id="2-2-补码"><a href="#2-2-补码" class="headerlink" title="2.2 补码"></a>2.2 补码</h3><blockquote><p>一个正数的补码形式就是 它二进制本身,负数的补码是它绝对值的二进制形式取反 + 1</p></blockquote><p>254 -&gt; unsigned int -&gt; 32位<br>-254 -&gt; 254 -&gt; 1111 1110 取反 + 1</p><h2 id="7-运算符和表达式"><a href="#7-运算符和表达式" class="headerlink" title="7. 运算符和表达式"></a>7. 运算符和表达式</h2><p>表达式与语句的区别</p><ul><li>运算符部分：</li></ul><ol><li>每个运算符所需要的参与运算的操作个数</li><li>结合性</li><li>优先级</li><li>运算符的特殊性</li></ol><ul><li>% 要求 除数，被除数都是整型</li></ul><ol start="5"><li>位运算的重要性</li></ol><h3 id="8-1-自增和自减"><a href="#8-1-自增和自减" class="headerlink" title="8.1 自增和自减"></a>8.1 自增和自减</h3><blockquote><p>运算符在前，先进行计算，再取变量值使用变量在前， 先取变量值使用，再进行计算</p></blockquote><h2 id="8-位运算"><a href="#8-位运算" class="headerlink" title="8. 位运算"></a>8. 位运算</h2><h3 id="3-1-gt-gt-lt-lt"><a href="#3-1-gt-gt-lt-lt" class="headerlink" title="3.1  &gt;&gt; &lt;&lt;"></a>3.1  &gt;&gt; &lt;&lt;</h3><blockquote><p>位运算（左移右移）基本等同于乘2除2运算,像汇编当中乘以多少，除以多少，几乎按这种方式来实现的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100 = <span class="number">12</span></span><br><span class="line">~i -&gt; B0011  <span class="comment">// 取反</span></span><br><span class="line"><span class="comment">// 把i往右移一位，1100  变成 110， 转化为10进制就是12</span></span><br><span class="line">i &gt;&gt; <span class="number">1</span>  --&gt; <span class="number">110</span> = <span class="number">6</span>  </span><br><span class="line"><span class="comment">// 把i往左移一位， 1100变成11000， 转化为10进制就是24</span></span><br><span class="line">i &lt;&lt; <span class="number">1</span> --&gt; <span class="number">11000</span> = <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="3-2-（取反）"><a href="#3-2-（取反）" class="headerlink" title="3.2  ~ （取反）"></a>3.2  ~ （取反）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100 = <span class="number">12</span></span><br><span class="line">~i -&gt; B0011  <span class="comment">// 取反</span></span><br></pre></td></tr></table></figure><h3 id="3-3-按位或"><a href="#3-3-按位或" class="headerlink" title="3.3  按位或"></a>3.3  按位或</h3><blockquote><p>按位或的计算原则是，同一个位上，两者有一者为1就为真，两者都为假才为假</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i|j</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">｜ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1101</span> -&gt; <span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="3-4-按位与"><a href="#3-4-按位与" class="headerlink" title="3.4  按位与"></a>3.4  按位与</h3><blockquote><p>按位与的计算原则是，同一个位上，两者有都为1就为真，否则为假</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i&amp;j</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">&amp; <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="3-5-相同为0，-不同为1"><a href="#3-5-相同为0，-不同为1" class="headerlink" title="3.5  ^ (相同为0， 不同为1)"></a>3.5  ^ (相同为0， 不同为1)</h3><blockquote><p>亦或计算原则， 同一个位上，相同为0， 不同为1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i^j</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">^ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="3-6-位运算的重要意义"><a href="#3-6-位运算的重要意义" class="headerlink" title="3.6  位运算的重要意义"></a>3.6  位运算的重要意义</h3><ul><li>将操作数中第N位 置1， 其他位不变；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num = num | 1 &lt;&lt; n // 把某一位 置1的话，把1左移 N个位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如将i 的第二位 置1</span></span><br><span class="line"><span class="keyword">int</span> i = B1011;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i = i | i &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">| <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>   <span class="comment">// 注意是把 1 左移动 N个位。 1  -&gt;  0100  空位补0</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>将操作数中第N位 清0， 其他位不变；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num = num &amp; ~(1 &lt;&lt; n) // 把某一位 置1的话，把1左移 N个位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如将i 的第1位 置0</span></span><br><span class="line"><span class="keyword">int</span> i = B1011;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i = i | i &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">| <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   <span class="comment">// -&gt; 把1左移N位取反</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li><p>测试第n位： if (num &amp; i 1 &lt;&lt; n)</p></li><li><p>从一个指定宽度的数中取出其中的某几位 （练习题）</p></li></ul><h2 id="9-内核代码位置"><a href="#9-内核代码位置" class="headerlink" title="9.  内核代码位置"></a>9.  内核代码位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /linux/include/linux</span><br><span class="line">vim list.h</span><br></pre></td></tr></table></figure><h2 id="10-宏"><a href="#10-宏" class="headerlink" title="10.  宏"></a>10.  宏</h2><ul><li>#开头的是编译预处理指令</li><li>它们不是C语言的成分，但是C语言程序离不开它们</li><li>#define 用来定义一个宏；</li><li>define (定义一个宏)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(<span class="string">"%d\n"</span>, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言程序在编译之前，会做一次编译预处理；</span></span><br><span class="line"><span class="comment">// 会把程序中所有的PI都替换成 3.14159</span></span><br></pre></td></tr></table></figure><h3 id="4-1-save-temps"><a href="#4-1-save-temps" class="headerlink" title="4.1 save-temps"></a>4.1 save-temps</h3><p>对一个 .c 文件执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 02.c --save-temps</span><br></pre></td></tr></table></figure><p>生成 四个文件</p><p><code>02.i</code><br><code>02.s</code><br><code>02.o</code><br><code>a.out</code></p><p>过程依次是</p><p><code>.c -&gt; .i -&gt; .s -&gt; .o -&gt; a.out</code></p><p>.c是源代码，经过编译预处理之后变成 .i 这种中间结果文件，<br>当中所有编译预处理指令都执行完，比如 define 宏需要替换掉;<br>然后由于编译器对 .i文件进行编译 生成汇编代码 .s文件；<br>然后汇编代码文件，进行汇编变成目标文件， 目标文件再经过链接<br>之后形成一个可执行的东西；</p><ul><li>查看 .i 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail  03.i</span><br><span class="line">tail -n 50 03.i <span class="comment"># 看03.i文件 最后 50行</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"># <span class="number">943</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">3</span> <span class="string">"03.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">2</span>*<span class="number">3.1415927</span>*<span class="number">3.0</span>); <span class="comment">// 这里明显把宏替换成了值；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 同样的可以把 “%f\n” 也替换成宏**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(FORMATTER, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-宏的缺点"><a href="#4-2-宏的缺点" class="headerlink" title="4.2 宏的缺点"></a>4.2 宏的缺点</h3><blockquote><p>不检查语法，在预处理或者编译阶段是不报错的；</p></blockquote><h3 id="4-3-define"><a href="#4-3-define" class="headerlink" title="4.3 define"></a>4.3 define</h3><ul><li>#define &lt;名字&gt; &lt;值&gt;</li><li>结尾没有 分号，因为不是C的语句</li><li>名字必须是一个单词，值可以是各种东西</li><li>在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值；</li><li>完全的文本替换</li><li>gcc –save-temps</li><li>如果一个宏的值中有其他的宏的名字，也是会被替换的</li><li>如果一个宏的值超过一行，最后一行之前的行末需要加\</li><li>宏的值后面出现的注释不会被当作宏的一部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159        <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI          <span class="comment">// PI * 2</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(FORMATTER, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159        <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI          <span class="comment">// PI * 2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRT printf(<span class="meta-string">"%f"</span>, PI)\</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI2)</span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PRT;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-没有值的宏"><a href="#4-4-没有值的宏" class="headerlink" title="4.4 没有值的宏"></a>4.4 没有值的宏</h3><ul><li>#define_DEBUG</li><li>这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了；</li></ul><h3 id="4-5-预定义的宏"><a href="#4-5-预定义的宏" class="headerlink" title="4.5 预定义的宏"></a>4.5 预定义的宏</h3><blockquote><p>用来表示一些特殊的东西，可以让编译器替我们插入一些特殊的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_LINE_     <span class="comment">//这个源代码所在当前的行号；</span></span><br><span class="line">_FILE_     <span class="comment">// 源代码的文件名</span></span><br><span class="line">_DATE_     <span class="comment">// 编译时候的日期</span></span><br><span class="line">_TIME_     <span class="comment">// 编译时候的时间</span></span><br><span class="line">_STDC_</span><br></pre></td></tr></table></figure><h3 id="4-6-像函数的宏"><a href="#4-6-像函数的宏" class="headerlink" title="4.6 像函数的宏"></a>4.6 像函数的宏</h3><p><code>#define cube(x) ((x)*(x)*(x))</code></p><p>宏可以带参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cube(x) ((x)*(x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cube(<span class="number">5</span>));  <span class="comment">// 125</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 .i 文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((<span class="number">5</span>)*(<span class="number">5</span>)*(<span class="number">5</span>)));  <span class="comment">// 被预处理成这样了；</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">2</span>*<span class="number">3.1415927</span>*<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-错误定义的宏"><a href="#4-7-错误定义的宏" class="headerlink" title="4.7 错误定义的宏"></a>4.7 错误定义的宏</h3><p><code>#define RADTODEG(x) (x*57.29578)</code><br><code>#define RADTODEG(x) (x)*57.29578</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADTODEG(x) (x*57.29578)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADTODEG(x) (x)*57.29578</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, RADTODEG(<span class="number">5</span>+<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">180</span>/RADTODEG2(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被预处理的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, (<span class="number">5</span>+<span class="number">2</span> * <span class="number">57.29578</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">180</span>/<span class="number">1</span>*<span class="number">57.29678</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 被预处理的结果是不符合我们的要求的；</p><h3 id="4-8带参数的宏的原则"><a href="#4-8带参数的宏的原则" class="headerlink" title="4.8带参数的宏的原则"></a>4.8带参数的宏的原则</h3><ul><li><p>一切都要有括号</p><ul><li>整个值要有括号，指的是整个宏的值有括号</li><li>参数出现的每个地方都要括号 </li></ul></li><li><p>#define RADTODEG(x) ((x)*57.29578)</p></li><li><p>可以带多个参数</p><ul><li>#define MIN((a,b) ((a)&gt;(b)?(b):(a))</li></ul></li><li><p>也可以组合（嵌套）使用其他宏</p></li><li><p>在大型程序的代码中使用非常普遍</p></li><li><p>可以非常复杂，如“产生”函数</p><ul><li>在# 和 ## 这两个运算符的帮助下</li></ul></li><li><p>存在中西方文化差异</p></li><li><p>部分宏会被inline函数替代 </p></li></ul><h3 id="4-9-什么时候用宏-什么时候用函数"><a href="#4-9-什么时候用宏-什么时候用函数" class="headerlink" title="4.9 什么时候用宏 什么时候用函数"></a>4.9 什么时候用宏 什么时候用函数</h3><p>应用求稳定，用函数<br>追求极致性能，用宏</p><h3 id="4-10-include-“”-还是-lt-gt"><a href="#4-10-include-“”-还是-lt-gt" class="headerlink" title="4.10 include  “” 还是 &lt;&gt;"></a>4.10 include  “” 还是 &lt;&gt;</h3><p>include 做了什么？</p><blockquote><p>include就是把头文件里头所有的文本插入到include所在.c文件的那一行.</p></blockquote><ul><li>#include有两种形式来指出要插入的文件<ul><li>“”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找</li><li>&lt;&gt; 让编译器只在指定的目录去找</li></ul></li><li>编译器自己知道自己的标准库的头文件在哪里</li><li>环境变量和编译器命令行参数也可以指定寻找头文件的目录</li></ul><h3 id="4-11-头文件-（-h文件）"><a href="#4-11-头文件-（-h文件）" class="headerlink" title="4.11 头文件 （.h文件）"></a>4.11 头文件 （.h文件）</h3><ul><li>在使用和定义这个函数的地方都应该 #include 这个头文件</li><li>一般的做法就是任何.c都有对应的同名的.h,把所有对外公开的函数的原型和全局变量的声明都放进去</li><li>在函数前面加上static 就使得它成为只能在所在的编译单元中被使用的函数</li><li>在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量</li></ul><h3 id="4-12-变量的声明"><a href="#4-12-变量的声明" class="headerlink" title="4.12 变量的声明"></a>4.12 变量的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> gAll;   <span class="comment">// 全局声明一个 变量</span></span><br></pre></td></tr></table></figure><ul><li>int i； 是变量的定义</li><li>extern int i； 是变量的声明</li></ul><h3 id="4-13声明和定义"><a href="#4-13声明和定义" class="headerlink" title="4.13声明和定义"></a>4.13声明和定义</h3><ul><li>声明是不产生的代码的东西<ul><li>函数原型</li><li>变量声明</li><li>结构声明</li><li>宏声明</li><li>枚举声明</li><li>类型声明</li><li>inline函数</li></ul></li><li>定义是产生代码的东西</li></ul><h2 id="11-typedef"><a href="#11-typedef" class="headerlink" title="11. typedef"></a>11. typedef</h2><blockquote><p>为已有的数据类型改名</p></blockquote><p><code>typedef  已有的数据类型 新名字;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  INT i;</span><br><span class="line">  <span class="built_in">printf</span>(D, i); </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-typedef-和-define的区别"><a href="#5-1-typedef-和-define的区别" class="headerlink" title="5.1  typedef 和 define的区别"></a>5.1  typedef 和 define的区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *IP;</span><br><span class="line"></span><br><span class="line">IP p,q  --&gt; <span class="keyword">int</span> *p, q;</span><br><span class="line">IP p,q  --&gt; <span class="keyword">int</span> *p, *q;</span><br></pre></td></tr></table></figure><p>** 更多示例** </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ARR[<span class="number">6</span>];    ---&gt; <span class="keyword">int</span> [<span class="number">6</span>] -&gt; ARR;</span><br><span class="line">ARR a; --&gt; <span class="keyword">int</span> a[<span class="number">6</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> <span class="title">NODE</span>;</span></span><br><span class="line">NODE a; --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> <span class="title">a</span>;</span></span><br><span class="line">NODE *p; --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">NODEP</span>;</span></span><br><span class="line">NODEP p --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;NODE, *NODEP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">FUNC</span><span class="params">(<span class="keyword">int</span>)</span></span>; --&gt; <span class="keyword">int</span>(<span class="keyword">int</span>)  FUNC;</span><br><span class="line">FUNC f; --&gt; <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> *<span class="title">FUNCP</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNCP p; ---&gt;  <span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *(*FUNCP)(<span class="keyword">int</span>);</span><br><span class="line">FUNCP p; ---&gt; <span class="keyword">int</span> *(*p)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>类型      数组名[常量表达式]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>    sheep[<span class="number">10</span>]</span><br><span class="line"><span class="keyword">int</span>      a2001[<span class="number">1000</span>]</span><br></pre></td></tr></table></figure><h2 id="12-一唯数组"><a href="#12-一唯数组" class="headerlink" title="12.  一唯数组"></a>12.  一唯数组</h2><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h3><p>  【存储类型】 数据类型 标识符 【下标】</p><h3 id="1-1-2-初始化"><a href="#1-1-2-初始化" class="headerlink" title="1.1.2 初始化"></a>1.1.2 初始化</h3><p>不初始化<br>全部初始化<br>部分初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">// 不给长度也行</span></span><br><span class="line">  <span class="keyword">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;   <span class="comment">// [1,2,0,0]   部分元素初始化</span></span><br><span class="line">  <span class="keyword">int</span> c[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;   <span class="comment">// [0,0,0,0]     部分元素初始化</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;  <span class="comment">// compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-3-元素引用"><a href="#1-1-3-元素引用" class="headerlink" title="1.1.3 元素引用"></a>1.1.3 元素引用</h3><p>  数组名【下标】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arr[M];</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">      <span class="keyword">for</span>(; i&lt;M; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;arr[i], arr[i]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x7ffee4394940-&gt;-466007712</span></span><br><span class="line"><span class="comment">// 0x7ffee4394944-&gt;32766</span></span><br><span class="line"><span class="comment">// 0x7ffee4394948-&gt;201064485</span></span><br></pre></td></tr></table></figure><ul><li><p>下标</p><p>查找块</p></li></ul><h3 id="1-1-4-数组名"><a href="#1-1-4-数组名" class="headerlink" title="1.1.4 数组名"></a>1.1.4 数组名</h3><blockquote><p>当前数组的起始位置，数组名本身就是表示地址的一个常量。</p></blockquote><p>常量： 程序执行过程当中不会发生变化的量；正因为数组名是常量，所以它不能无条件出现在数组的左边；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arr[M] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      arr[M] = &#123;<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 语法错误，数组名是常量，无法被直接赋值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">      <span class="keyword">for</span>(; i&lt;M; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;arr[i], arr[i]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-5-数组越界"><a href="#1-1-5-数组越界" class="headerlink" title="1.1.5 数组越界"></a>1.1.5 数组越界</h3><blockquote><p>溢出数组所在内存区域</p></blockquote><h4 id="1-1-6-fb"><a href="#1-1-6-fb" class="headerlink" title="1.1.6 fb"></a>1.1.6 fb</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fib[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">2</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">         fib[i] = fib[i<span class="number">-1</span>] + fib[i<span class="number">-2</span>];</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fb加个排序</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fib[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> j;</span><br><span class="line">     <span class="keyword">int</span> tmp;</span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">2</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">         fib[i] = fib[i<span class="number">-1</span>] + fib[i<span class="number">-2</span>];</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">     i=<span class="number">0</span>;</span><br><span class="line">     j=<span class="keyword">sizeof</span>(fib)/<span class="keyword">sizeof</span>(fib[<span class="number">0</span>]) <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">     &#123;</span><br><span class="line">         tmp = fib[i];</span><br><span class="line">         fib[i] = fib[j];</span><br><span class="line">         fib[j] = tmp;</span><br><span class="line">         i++;</span><br><span class="line">         j--;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="13-二维数组"><a href="#13-二维数组" class="headerlink" title="13.  二维数组"></a>13.  二维数组</h2><h3 id="1-2-1-定义，初始化"><a href="#1-2-1-定义，初始化" class="headerlink" title="1.2.1 定义，初始化"></a>1.2.1 定义，初始化</h3><p>   【存储类型】  数据类型   标识符  【行下标】 【列下标】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> b[][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[M][N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-二维数组元素引用"><a href="#1-2-2-二维数组元素引用" class="headerlink" title="1.2.2 二维数组元素引用"></a>1.2.2 二维数组元素引用</h3><p>数组名[行标][列标]<br>int a[3][4]   // 定一个三行四列的二维数组</p><h3 id="1-2-3-存储形式"><a href="#1-2-3-存储形式" class="headerlink" title="1.2.3 存储形式"></a>1.2.3 存储形式</h3><blockquote><p>顺序存储，按行存储,二维数组在内存中的存储， 是拉平的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">a[0][0]</span><br><span class="line">----------</span><br><span class="line">a[0][1]</span><br><span class="line">----------</span><br><span class="line">a[0][2]</span><br><span class="line">----------</span><br><span class="line">a[0][3]</span><br><span class="line">----------</span><br><span class="line">a[1][0]</span><br><span class="line">----------</span><br><span class="line">a[1][1]</span><br><span class="line">----------</span><br><span class="line">a[1][2]</span><br><span class="line">----------</span><br><span class="line">a[1][3]</span><br><span class="line">----------</span><br><span class="line">a[2][0]</span><br><span class="line">----------</span><br><span class="line">a[2][1]</span><br><span class="line">----------</span><br><span class="line">a[2][2]</span><br><span class="line">----------</span><br><span class="line">a[2][3]</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><ol><li>深入理解二维数组</li></ol><table><thead><tr><th>1 a[0][0]</th><th>2 a[0][1]</th><th>3 a[0][2]</th><th>4 a[0][3]</th></tr></thead><tbody><tr><td>5 a[1][0]</td><td>6 a[1][1]</td><td>7 a[1][2]</td><td>8 a[1][3]</td></tr><tr><td>9 a[2][0]</td><td>10 a[2][1]</td><td>11 a[2][2]</td><td>12 a[2][3]</td></tr></tbody></table><h3 id="1-2-4-二维数组练习题"><a href="#1-2-4-二维数组练习题" class="headerlink" title="1.2.4 二维数组练习题"></a>1.2.4 二维数组练习题</h3><h4 id="1-2-4-1-行列互换"><a href="#1-2-4-1-行列互换" class="headerlink" title="1.2.4.1 行列互换"></a>1.2.4.1 行列互换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N][M];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[j][i] = arr[i][j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-2-求最大值及其所在位置"><a href="#1-2-4-2-求最大值及其所在位置" class="headerlink" title="1.2.4.2 求最大值及其所在位置"></a>1.2.4.2 求最大值及其所在位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">max</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[M][N] = &#123;<span class="number">43</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">89</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>][<span class="number">0</span>], row =<span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]&gt;<span class="built_in">max</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">max</span>= a[i][j];</span><br><span class="line">               row = i;</span><br><span class="line">               col = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">max</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d --- %d\n"</span>, row, col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N][M];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">max</span>();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-3-求各行与各列的和"><a href="#1-2-4-3-求各行与各列的和" class="headerlink" title="1.2.4.3 求各行与各列的和"></a>1.2.4.3 求各行与各列的和</h4><p><img src="./2_arr.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sum</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[<span class="number">4</span>][<span class="number">3</span>] += a[i][j];</span><br><span class="line">            a[<span class="number">4</span>][j] += a[i][j];</span><br><span class="line">            a[i][<span class="number">3</span>] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-4-矩阵乘积"><a href="#1-2-4-4-矩阵乘积" class="headerlink" title="1.2.4.4 矩阵乘积"></a>1.2.4.4 矩阵乘积</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 2</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; ;</span><br><span class="line">     <span class="keyword">int</span> b[N][K]= &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> c[M][K];</span><br><span class="line">     <span class="keyword">int</span> i,j,k;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;N; k++)</span><br><span class="line">             &#123;</span><br><span class="line">                 c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%4d"</span>,c[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     mul();</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-5-深入理解二维数组"><a href="#1-2-5-深入理解二维数组" class="headerlink" title="1.2.5 深入理解二维数组"></a>1.2.5 深入理解二维数组</h3><p><img src="./arr_2.png" alt=""></p><h4 id="1-2-5-1-三维数组"><a href="#1-2-5-1-三维数组" class="headerlink" title="1.2.5.1 三维数组"></a>1.2.5.1 三维数组</h4><p>a[5][3][4]    数据立方体  </p><p>5 -&gt; 片<br>3 -&gt; 行<br>4 -&gt; 列</p><p>在内存中依然是打平存放；</p><h2 id="14-字符数组"><a href="#14-字符数组" class="headerlink" title="14. 字符数组"></a>14. 字符数组</h2><h3 id="1-3-1-定义，初始化，存储特点"><a href="#1-3-1-定义，初始化，存储特点" class="headerlink" title="1.3.1 定义，初始化，存储特点"></a>1.3.1 定义，初始化，存储特点</h3><p> 【存储类型】 数据类型  标识符 【下标】。。。</p><h4 id="1-3-1-1-单个字符初始化"><a href="#1-3-1-1-单个字符初始化" class="headerlink" title="1.3.1.1 单个字符初始化"></a>1.3.1.1 单个字符初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br></pre></td></tr></table></figure><p>char c[] = {‘C’, ‘h’, ‘i’, ‘n’, ‘a’};<br>// c[0] = C   c[1] = h  c[2]= i  c[3]=n  c[4]=a</p><h4 id="1-3-1-2-用字符串常量初始化"><a href="#1-3-1-2-用字符串常量初始化" class="headerlink" title="1.3.1.2 用字符串常量初始化"></a>1.3.1.2 用字符串常量初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">6</span>] = <span class="string">"hello"</span>;  <span class="comment">// 最后一位 以 '\0' 结尾</span></span><br></pre></td></tr></table></figure><p>char c[] = “China”<br>// c[0] = C   c[1] = h  c[2]= i  c[3]=n  c[4]=a  c[5]=\0</p><h3 id="1-3-2-输入输出"><a href="#1-3-2-输入输出" class="headerlink" title="1.3.2 输入输出"></a>1.3.2 输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[N], str1[N], str2[N];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>, str, str1,str2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n%s\n%s\n"</span>, str, str1,str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// how are you</span></span><br><span class="line"><span class="comment">// how</span></span><br><span class="line"><span class="comment">// are</span></span><br><span class="line"><span class="comment">// you</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-1-单词计数"><a href="#1-3-2-1-单词计数" class="headerlink" title="1.3.2.1 单词计数"></a>1.3.2.1 单词计数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">     <span class="keyword">int</span> count =<span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     gets(str);</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">             flag = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 count++;</span><br><span class="line">                 flag=<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"count = %d\n"</span>, count);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-字符数组注意事项"><a href="#1-3-3-字符数组注意事项" class="headerlink" title="1.3.3 字符数组注意事项"></a>1.3.3 字符数组注意事项</h3><blockquote><p>所有字符串都是以  \0 来结尾的；所有以 \0结尾 的字符数组都可以被看为字符串</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>] = <span class="string">"China"</span>; <span class="comment">//只可以在数组定义并初始化的时候</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用赋值语句将一个字符串常量或字符数组直接赋给另一个字符数组</span></span><br><span class="line">str1[] = <span class="string">"China"</span>   <span class="comment">// 赋值，不合法</span></span><br><span class="line">str1 = <span class="string">"China"</span>     <span class="comment">// 赋值，不合法</span></span><br><span class="line">str2 = str1        <span class="comment">// 赋值，不合法</span></span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol><li>变量与地址</li><li>指针与指针变量</li><li>直接访问与间接访问</li><li>空指针与野指针</li><li>空类型指针</li><li>定义，初始化，书写规则</li><li>指针运算</li><li>指针与数组<ol><li>指针与一维数组</li><li>指针与二维数组</li><li>指针与字符数组</li></ol></li><li>const与指针</li><li>指针数组和数组指针</li><li>多级指针</li></ol><h2 id="15-变量与地址"><a href="#15-变量与地址" class="headerlink" title="15. 变量与地址"></a>15. 变量与地址</h2><p>变量名： 变量名就是用户对某一块内存空间的抽象表示；想把这块儿内存置成100，就写<code>int i = 100;</code>变量名就是某个内存空间的别名；</p><p>地址： 指针就是地址，指针就是指向某个内存空间地址的地址值；</p><h3 id="1-1-变量的三要素"><a href="#1-1-变量的三要素" class="headerlink" title="1.1  变量的三要素"></a>1.1  变量的三要素</h3><p><code>int a = 3</code> 在内存中， 即产生 0x0012FF78，3，a 三个要素。</p><ol><li>0x0012FF78即变量的地址， 把这个变量的地址称为“指向该变量的指针”；</li><li>3即变量值；</li><li>a即变量的签名；</li></ol><h3 id="1-2-输出变量的地址"><a href="#1-2-输出变量的地址" class="headerlink" title="1.2  输出变量的地址"></a>1.2  输出变量的地址</h3><p>地址运算符 “&amp;” </p><p><code>int a = 3; printf(&quot;%x&quot;, &amp;a)</code></p><h2 id="16-指针与指针变量"><a href="#16-指针与指针变量" class="headerlink" title="16. 指针与指针变量"></a>16. 指针与指针变量</h2><p><strong>语法</strong></p><p><code>TYPE NAME = VALUE；</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;    <span class="comment">// type 为 int</span></span><br><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// type 为 int *, 而不是 int</span></span><br></pre></td></tr></table></figure><h3 id="2-1-非法操作（野指针）"><a href="#2-1-非法操作（野指针）" class="headerlink" title="2.1 非法操作（野指针）"></a>2.1 非法操作（野指针）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// 合法操作，指针一旦定义出来，就要给一个明确指向；没有的话，下回分解</span></span><br><span class="line"><span class="keyword">int</span> * p = <span class="number">0x7fffa37eac60</span>; <span class="comment">// 可能这个地址已经被占用了，一般情况下，是个非法操作；</span></span><br></pre></td></tr></table></figure><h3 id="2-2-指针变量"><a href="#2-2-指针变量" class="headerlink" title="2.2 指针变量"></a>2.2 指针变量</h3><blockquote><p>专门用于存放指针（某个变量的地址）的变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> * pointer;  <span class="comment">//定义名字为pointer的指针变量；只能存放地址！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int *pointer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) int 是指针变量的基类型  所谓基类型：指针变量指向的变量的类型</span></span><br><span class="line"><span class="comment">// 2) *   是指针运算符，表示pointer这个变量的类型</span></span><br><span class="line"><span class="comment">// 3) pointer   是指指针变量的名字</span></span><br><span class="line"></span><br><span class="line">pointer = &amp;c;</span><br><span class="line"><span class="comment">// 将变量c 的地址赋值给指针变量pointer；</span></span><br><span class="line"><span class="comment">// 赋值后，称指针变量pointer指向了变量c；</span></span><br></pre></td></tr></table></figure><p>则<code>*pointer</code>： 为pointer所指向的存储单元的内容；是变量c。<br>因此<code>*pointer</code>可以当作 变量c 来使用</p><h3 id="2-3-指针变量的地址"><a href="#2-3-指针变量的地址" class="headerlink" title="2.3 指针变量的地址"></a>2.3 指针变量的地址</h3><blockquote><p>指针变量也是变量，是变量就有地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(P, p);</span><br><span class="line">    <span class="built_in">printf</span>(P, &amp;p);   <span class="comment">// 指针变量也有地址；</span></span><br><span class="line"><span class="comment">// 0x7ffee6a26ac8</span></span><br><span class="line"><span class="comment">// 0x7ffee6a26ac0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-指针变量示例"><a href="#2-4-指针变量示例" class="headerlink" title="2.4 指针变量示例"></a>2.4 指针变量示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b=<span class="number">3</span>, temp;</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>, *p2 = <span class="literal">NULL</span>;</span><br><span class="line">    p1 = &amp;a;</span><br><span class="line">    p2 = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">if</span>(*p1 &lt; *p2) &#123;</span><br><span class="line">        temp = *p1; *p1 = *p2; *p2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p1);  <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p2);  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-指针作运算-取地址-和-取-和关系运算"><a href="#2-5-指针作运算-取地址-和-取-和关系运算" class="headerlink" title="2.5 指针作运算 (取地址 和 取 * 和关系运算)"></a>2.5 指针作运算 (取地址 和 取 * 和关系运算)</h3><p><img src="./point_01.png" alt=""></p><h4 id="2-5-1-取地址"><a href="#2-5-1-取地址" class="headerlink" title="2.5.1 取地址"></a>2.5.1 取地址</h4><blockquote><p>要获取某个变量在内存中的房间号</p></blockquote><h4 id="2-5-2-取"><a href="#2-5-2-取" class="headerlink" title="2.5.2 取*"></a>2.5.2 取*</h4><blockquote><p>找到现在给定房间号里面存放的内容</p></blockquote><h2 id="17-直接访问和间接访问"><a href="#17-直接访问和间接访问" class="headerlink" title="17. 直接访问和间接访问"></a>17. 直接访问和间接访问</h2><h3 id="3-1一级间接访问和-二级间接访问"><a href="#3-1一级间接访问和-二级间接访问" class="headerlink" title="3.1一级间接访问和 二级间接访问"></a>3.1一级间接访问和 二级间接访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">     <span class="keyword">int</span> **q = &amp;p;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(P, p); <span class="comment">// 0x7ffee92579b8</span></span><br><span class="line">     <span class="built_in">printf</span>(P, q); <span class="comment">// 0x7ffee92579b0</span></span><br><span class="line">     <span class="built_in">printf</span>(P, *q); <span class="comment">// 0x7ffee92579b8</span></span><br><span class="line"> printt(D, i); <span class="comment">// 1 直接访问</span></span><br><span class="line">     <span class="built_in">printf</span>(D, *p); <span class="comment">// 1  一级间接访问</span></span><br><span class="line">     <span class="built_in">printf</span>(D, **q);<span class="comment">// 1 二级间接访问</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-指针关系运算"><a href="#3-2-指针关系运算" class="headerlink" title="3.2 指针关系运算"></a>3.2 指针关系运算</h3><blockquote><p>当两个指针指向的是一块连续内存空间的时候， 比如两个指针指向同一个数组。在这种情况下，两个指针可以做一个关系上的比较；</p></blockquote><p><code>++ --</code></p><blockquote><p>++ – 运算实际上改变指针位置；</p></blockquote><h3 id="3-3-指针变量类型与指针变量大小"><a href="#3-3-指针变量类型与指针变量大小" class="headerlink" title="3.3  指针变量类型与指针变量大小"></a>3.3  指针变量类型与指针变量大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">float</span> *q;</span><br><span class="line"><span class="keyword">double</span> *d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(i)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(p)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(q)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(d)); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 结构体指针的大小也是8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">不管指针是多少级的指针，不管指针是什么样的类型。指针在某个平台下所占的地址空间是确定的。那既然如此为何 要给指针变量加类型呢，比如 int *p, float *q.</span></span><br><span class="line"><span class="comment">那是因为有 *p 取* 的操作，比如*q的时候，怎么就能知道去对应地址读取 4个字节呢？ 这个时候就要靠 指针变量的 变量类型加持了。所以这个变量类型之间的意义 就不尽相同了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * s;</span><br><span class="line">s = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(D, *s); <span class="comment">// 这个时候，不知道要去读取 4个字节，所以结果不是1；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-空指针与野指针"><a href="#18-空指针与野指针" class="headerlink" title="18. 空指针与野指针"></a>18. 空指针与野指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> * p = <span class="literal">NULL</span>;<span class="comment">// 指针被定义出来，还未决定指向哪里的时候，可以先指向NULL，系统上 0 号不分配给任何进程；把指针置为空是为了预防野指针；</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-野指针"><a href="#4-1-野指针" class="headerlink" title="4.1 野指针"></a>4.1 野指针</h3><blockquote><p>当前这个指针的指向是不确定的，或者压根就没有指向；但是直接使用这个指针了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p --&gt; %d\n"</span>, p ,*p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffee67879d8---&gt;0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p --&gt; %d\n"</span>, p ,*p);</span><br><span class="line"></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 段错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-1-如何杜绝野指针"><a href="#4-1-1-如何杜绝野指针" class="headerlink" title="4.1.1 如何杜绝野指针"></a>4.1.1 如何杜绝野指针</h4><blockquote><p>指针一经定义，就必须有一个明确的指向，没有暂时没有指向的话，就先指向NULL；</p></blockquote><h2 id="19-空类型"><a href="#19-空类型" class="headerlink" title="19. 空类型"></a>19. 空类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * p = <span class="literal">NULL</span>; <span class="comment">// 即 空类型 void * 是一个百搭的类型，任何类型的指针值都可以赋值给它。void * 也可以把自己的值赋值给任何类型的指针；</span></span><br></pre></td></tr></table></figure><h3 id="5-1-空类型的使用场景"><a href="#5-1-空类型的使用场景" class="headerlink" title="5.1 空类型的使用场景"></a>5.1 空类型的使用场景</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="20-运算符优先级"><a href="#20-运算符优先级" class="headerlink" title="20. 运算符优先级"></a>20. 运算符优先级</h2><blockquote><p>上面优先级比下面高</p></blockquote><ul><li>后置++ –<ul><li>前置++ – 逻辑非 (!) * &amp;   // 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高<ul><li>算术运算符<ul><li>关系运算符<ul><li>&amp;&amp;和｜｜<ul><li>赋值运算符</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li>同级别，优先级由右往左结合顺序， 离目标越近，优先级越高</li></ul><p>如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;*pointer = &amp;(*pointer)</span><br><span class="line">*&amp;a = *(&amp;a)</span><br></pre></td></tr></table></figure><p><code>(*pointer)++ 不等于 *pointer++</code></p><p>(<em>pointer)++ 是先 做取</em>运算，得到的int类型自增， <em>pointer++ 则是 指针变量移位，然后再取</em>运算</p><p><code>*pointer++ 的含义</code></p><p>假设： pointer当前所存的地址是0x00000100</p><ul><li>若pointer 的指针变量基类型是 指向一个 int或实型（占4个字节），则pointer++ 等于 iptr + 1*4 = 0x00000104</li><li>若pointer 指向一个 字符型（占1个字节），则pointer++ 等于 iptr + 1*1 = 0x00000101</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">33</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(P, a); <span class="comment">// 0x7ffee0eeda20</span></span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(P, p); <span class="comment">// 0x7ffee0eeda20</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p); <span class="comment">//  5</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p++); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p++); <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p);   <span class="comment">// 19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*p++ 是地址移动</span><br></pre></td></tr></table></figure><p>** 小结** </p><p>  指针和指针变量是不同的。指针是地址，指针变量就是一个普通的变量。<br><em>pointer指的是这个指针变量 所指向的那片内存空间里面的内容。<br>(</em>pointer)++ 不等于 *pointer++</p><h2 id="21-指针与数组"><a href="#21-指针与数组" class="headerlink" title="21. 指针与数组"></a>21. 指针与数组</h2><blockquote><p>数组名代表数组首元素的地址 （<em>数组名相当于指向数组第一个元素的指针</em>）；<br>数组名不是变量，不能给a赋值；<br><code>int *p = &amp;a[0];</code> <code>a++</code>是没有意义的（a只是个常量），但<code>p++</code>会引起p变化。<br>p可以指向数组最后一个元素以后的元素。<br>指针做加减运算时一定注意有效的范围；（指针理论上能够在内存中自由的漂移，很可能移除某一个数组的范围，有的时候就比较危险了）</p></blockquote><p><img src="./arr_1.png" alt=""></p><h3 id="7-1-数组名代表数组首元素的地址"><a href="#7-1-数组名代表数组首元素的地址" class="headerlink" title="7.1 数组名代表数组首元素的地址"></a>7.1 数组名代表数组首元素的地址</h3><blockquote><p>数组名是指向数组第一个元素的指针；</p></blockquote><ul><li>对于数组a[10], 数组名 a代表数组 a[10]中第一个元素a[0]的地址； 即  a 与 a[0]等价</li><li>注意： a是地址常量，不是变量，不能给a赋值；</li></ul><h3 id="7-2-创建一个匿名数组"><a href="#7-2-创建一个匿名数组" class="headerlink" title="7.2  创建一个匿名数组"></a>7.2  创建一个匿名数组</h3><blockquote><p>指针和数组的关系，其实就是一种引用方式而已。你的一维数组名和一级指针之间的关系其实除了一个是变量，一个是常量之外。完全可以等价代换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> [<span class="number">3</span>])&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(D, p[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-利用指针变量引用数组元素"><a href="#7-3-利用指针变量引用数组元素" class="headerlink" title="7.3 利用指针变量引用数组元素"></a>7.3 利用指针变量引用数组元素</h3><ul><li>若定义<ul><li>数组 int a[10]; 指针 int * pointer;</li></ul></li><li>则:<ul><li>pointer =a; 等价于pointer = &amp;a[0];</li></ul></li><li>数组访问<br>  pointer+ i; 等价于 a+i; 等价于 &amp;a[i];<br>  *(pointer+i);  等价于 *(a+i); 等价于a[i];</li><li>表示形式<br>  pointer[i] 等价于 *(pointer+i);</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = a; <span class="comment">// a 是 数组的地址，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);   <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p++);  <span class="comment">// 4    ++的含义是先使用p，然后再++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);     <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *++p);   <span class="comment">// 6   前+ 和 后+ 跟js一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">0</span>]); <span class="comment">// 因为p=a了，所以p[0] 即a[0]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-抽象公式"><a href="#7-4-抽象公式" class="headerlink" title="7.4 抽象公式"></a>7.4 抽象公式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a[i]: a[i] = *(a+i) = *(p+i) = p[i];</span></span><br><span class="line"><span class="comment">// &amp;a[i]: &amp;a[i] = a+i = p+i = &amp;p[i];</span></span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><h3 id="7-5-重置指针变量"><a href="#7-5-重置指针变量" class="headerlink" title="7.5 重置指针变量"></a>7.5 重置指针变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d/n"</span>, p++);</span><br><span class="line"></span><br><span class="line">p = a; <span class="comment">// 这里需要 重置一下 p的指针；不然会数组越界；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *p++);</span><br></pre></td></tr></table></figure><h3 id="7-6-需要注意的问题"><a href="#7-6-需要注意的问题" class="headerlink" title="7.6 需要注意的问题"></a>7.6 需要注意的问题</h3><blockquote><p><code>int * p = &amp;a[0];</code> , <code>* a++</code>是没有意义的（因为a是个常量），但<code>p++</code>会引起<code>p</code>变化；<code>* p</code>可以指向数组最后一个元素以后的元素；（因为p是内存中的一个指针），所以指针做加减运算时一定注意有效的范围。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],</span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;a[<span class="number">1</span>];</span><br><span class="line">iPtr--;     <span class="comment">// 指向&amp;a[0]</span></span><br><span class="line">*iPtr = <span class="number">3</span>;  <span class="comment">// a[0] = 3</span></span><br><span class="line">iPtr--;     <span class="comment">// 指向&amp;a[-1], dangerous</span></span><br><span class="line">*iPtr = <span class="number">6</span>;  <span class="comment">// (damage)  对内存造成损坏，影响内存中其他的变量</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a[<span class="number">3</span>];</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p++); <span class="comment">// 100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p--); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *--p); <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7-指向二维数组的指针"><a href="#7-7-指向二维数组的指针" class="headerlink" title="7.7 指向二维数组的指针"></a>7.7 指向二维数组的指针</h3><h4 id="7-7-1-遍历数组元素"><a href="#7-7-1-遍历数组元素" class="headerlink" title="7.7.1 遍历数组元素"></a>7.7.1 遍历数组元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">for</span> (p= &amp;a[<span class="number">0</span>][<span class="number">0</span>]   ;p &lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">12</span>; p++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x7ffeefbff4f0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4f4</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4f8</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4fc</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff500</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff504</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff508</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff50c</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff510</span></span><br><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff514</span></span><br><span class="line"><span class="comment">// 19</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff518</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff51c</span></span><br><span class="line"><span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>如上所示， 会将这个数组的内容都打印出来了，因为二维数组会被拉平存储到一段连续的内存空间当中</p><h4 id="7-7-2-二维数组行列指针"><a href="#7-7-2-二维数组行列指针" class="headerlink" title="7.7.2 二维数组行列指针"></a>7.7.2 二维数组行列指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> D <span class="meta-string">"%d\n"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> P <span class="meta-string">"%p\n"</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"&amp;a = %p, &amp;a+1 = %p\n"</span>, &amp;a, &amp;a+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%&amp;a[0][0] = %p, &amp;a[1][0] = %p\n"</span>, &amp;a[<span class="number">0</span>][<span class="number">0</span>], &amp;a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%p---&gt;%d\n"</span>, &amp;a[i][j], a[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;a = 0x7ffefe385370,            &amp;a+1 = 0x7ffefe3853a0</span></span><br><span class="line"><span class="comment">// %&amp;a[0][0] = 0x7ffefe385370, &amp;a[1][0] = 0x7ffefe385380</span></span><br><span class="line"><span class="comment">// 0x7ffefe385370---&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffefe385374---&gt;2</span></span><br><span class="line"><span class="comment">// 0x7ffefe385378---&gt;3</span></span><br><span class="line"><span class="comment">// 0x7ffefe38537c---&gt;4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffefe385380---&gt;5</span></span><br><span class="line"><span class="comment">// 0x7ffefe385384---&gt;6</span></span><br><span class="line"><span class="comment">// 0x7ffefe385388---&gt;7</span></span><br><span class="line"><span class="comment">// 0x7ffefe38538c---&gt;8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffefe385390---&gt;9</span></span><br><span class="line"><span class="comment">// 0x7ffefe385394---&gt;10</span></span><br><span class="line"><span class="comment">// 0x7ffefe385398---&gt;11</span></span><br><span class="line"><span class="comment">// 0x7ffefe38539c---&gt;12</span></span><br></pre></td></tr></table></figure><p>小结：</p><blockquote><p>所以a除了是二维数组的数组名（地址常量）之外，在使用上比较偏向一个指向行指针。</p></blockquote><h4 id="7-7-3-能够接收二维数组指针的指针变量"><a href="#7-7-3-能够接收二维数组指针的指针变量" class="headerlink" title="7.7.3 能够接收二维数组指针的指针变量"></a>7.7.3 能够接收二维数组指针的指针变量</h4><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">     p  =&amp;a[i][j]; <span class="comment">// *(a+0) , *a</span></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++,p++) <span class="comment">// for (i=0; i&lt;12; i++)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);  <span class="comment">//     printf("%d ", p[i]);</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 1 2 3 4 5 6 7 8 9 10 11 12</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="7-7-4-另一段程序"><a href="#7-7-4-另一段程序" class="headerlink" title="7.7.4 另一段程序"></a>7.7.4 另一段程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>], i,j;</span><br><span class="line">p = a;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;    <span class="comment">// i&lt;3 代表行号， j&lt;4 代表列号；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; *(*(p+i)+j); <span class="comment">// 正误判断： 访问元素 a[i][j]</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>程序分析</em></p><p>从 p = a 开始</p><ul><li><p>a相当于指向a[3][4]的“第一个元素”的指针；</p></li><li><p>所谓“第一个元素”是指一个“包含4个int型元素的一维数组”；</p></li><li><p>所以，a相当于一个“包含4个int型元素的一维数组”的地址；</p></li><li><p>因此，p的基类型应该是： “包含4个int型元素的一维数组”</p></li><li><p>变量定义语句的语法为： int (*p)[4];</p></li></ul><p>*p(数组)</p><p>p -&gt; |    (<em>p)[0] | (</em>p)[1] | (<em>p)[2] | (</em>p)[3] |</p><h4 id="7-7-5-利用指针变量引用多维数组中的数组"><a href="#7-7-5-利用指针变量引用多维数组中的数组" class="headerlink" title="7.7.5 利用指针变量引用多维数组中的数组"></a>7.7.5 利用指针变量引用多维数组中的数组</h4><p><em>(</em>(p+i)+j)是什么？</p><ul><li><p>p 是指向一个“包含4个int型元素的一维数组”；</p></li><li><p>p+i 是第i+1个“包含4个int型元素的一维数组”的地址;</p></li><li><p>p+i 等价于&amp;a[i]；</p></li><li><p>*(p+i)等价于a[i]；</p></li><li><p>*(p+i)+j 等价于 a[i]+j; // 这里把a[i] 当作一个指针来看 因此， a[i]+j 等价于 &amp;a[i][j];</p></li><li><p><em>(</em>(p+i)+j) 等价于 a[i][j];</p></li></ul><h3 id="7-8-指针与字符数组"><a href="#7-8-指针与字符数组" class="headerlink" title="7.8  指针与字符数组"></a>7.8  指针与字符数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> s[] = <span class="string">"i love coding!"</span>; <span class="comment">// codeing</span></span><br><span class="line"> <span class="keyword">char</span> *p = s+<span class="number">7</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s+<span class="number">7</span>);</span><br><span class="line"> <span class="built_in">puts</span>(s);</span><br><span class="line"> <span class="built_in">puts</span>(p); <span class="comment">// puts(p) 相当于把p的起始位置拿进来， 依次输出，直到碰到\0 为止；</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// coding!</span></span><br><span class="line"><span class="comment">// i love coding!</span></span><br><span class="line"><span class="comment">// coding!</span></span><br></pre></td></tr></table></figure><h4 id="7-8-1-字符数组拼接"><a href="#7-8-1-字符数组拼接" class="headerlink" title="7.8.1  字符数组拼接"></a>7.8.1  字符数组拼接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// str = "world"  false</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"world123"</span>); <span class="comment">// 覆盖原来数组空的每一项</span></span><br><span class="line"><span class="built_in">puts</span>(str); <span class="comment">// world123</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// world123</span></span><br></pre></td></tr></table></figure><h4 id="7-8-2-字符串长度和字符串字节数"><a href="#7-8-2-字符串长度和字符串字节数" class="headerlink" title="7.8.2 字符串长度和字符串字节数"></a>7.8.2 字符串长度和字符串字节数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d ,%d"</span>, <span class="keyword">sizeof</span>(str), <span class="built_in">strlen</span>(str));  <span class="comment">// 6, 5</span></span><br></pre></td></tr></table></figure><h4 id="7-8-3-字符指针跟字符数组的区别"><a href="#7-8-3-字符指针跟字符数组的区别" class="headerlink" title="7.8.3 字符指针跟字符数组的区别"></a>7.8.3 字符指针跟字符数组的区别</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(str); <span class="comment">// 8   指针变量不分类型 ， 64位系统下长度都是8个字节， 32位系统为4个字节；</span></span><br><span class="line"><span class="built_in">strlen</span>(str); <span class="comment">// 5   字符串长度</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"world"</span>); <span class="comment">// 段错误， 字符指针跟字符数组的区别就在于此。因为str 指向的是一个 字符串常量的地址， strcpy是一个覆盖写操作，显然，企图去更改一个常量是无效的。之所以是常量，是串常量，这个串在当前存储位置是特殊的。在使用上不允许被改变和覆盖。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line">str = <span class="string">"world123"</span>; <span class="comment">//更改指针指向；</span></span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h2 id="22-字符串与指针"><a href="#22-字符串与指针" class="headerlink" title="22. 字符串与指针"></a>22. 字符串与指针</h2><blockquote><p>指向字符串的指针</p></blockquote><ul><li>指向字符串的指针变量： char a[10]; char *p; p=a;</li></ul><p>数组和字符串太接近了。那怎么去定义指向字符串的指针呢？也很简单， 我首先定义一个字符数组，它就是用来存放字符串的。 我们以前讲过字符串和字符数组其实区别就在于有没有最后的反斜杠零， 本质上都是字符数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *s = c;</span><br><span class="line"><span class="built_in">printf</span>(P, s); <span class="comment">// 0x7ffee2066aba</span></span><br><span class="line"><span class="built_in">printf</span>(P, c); <span class="comment">// 0x7ffee2066aba</span></span><br><span class="line"><span class="built_in">printf</span>(S, s); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">printf</span>(S, c); <span class="comment">// hello </span></span><br><span class="line">s++;</span><br><span class="line"><span class="built_in">printf</span>(S, s); <span class="comment">// ello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-字符串指针举例"><a href="#8-1-字符串指针举例" class="headerlink" title="8.1  字符串指针举例"></a>8.1  字符串指针举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>] = <span class="string">"ABC"</span>;</span><br><span class="line"><span class="keyword">char</span> *pc;</span><br><span class="line">pc = <span class="string">"hello"</span>; <span class="comment">// 虽然 hello赋值给了pc，但是却不能通过pc去改变hello， 因为hello是常量，常量在内存中被放在特殊的地方了；这片区域不允许修改；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// hello</span></span><br><span class="line">pc++;                  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ello</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// e</span></span><br><span class="line">pc = <span class="built_in">buffer</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc;           <span class="comment">// ABC</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-const与指针"><a href="#23-const与指针" class="headerlink" title="23. const与指针"></a>23. const与指针</h2><blockquote><p>const是把某些内容常量化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>; <span class="comment">// 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针常量</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><h3 id="9-1-变量值常量化"><a href="#9-1-变量值常量化" class="headerlink" title="9.1  变量值常量化"></a>9.1  变量值常量化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>; <span class="comment">// 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure><h3 id="9-2-常量指针"><a href="#9-2-常量指针" class="headerlink" title="9.2  常量指针"></a>9.2  常量指针</h3><blockquote><p>指针的指向可以发生变化，但是指针所指向当前的那块内存的值是不可以发生变化的；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">  <span class="comment">//   float *p = &amp;pi;  // 警告： initialization discards ‘const’ qualifier from pointer target type</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">float</span> *p = &amp;pi;</span><br><span class="line">    *p = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, *p);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> chart * pathname, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 常量指针，保护pathname值不被篡改</span></span><br></pre></td></tr></table></figure><h3 id="9-3-指针常量"><a href="#9-3-指针常量" class="headerlink" title="9.3  指针常量"></a>9.3  指针常量</h3><p><code>int *const p;</code></p><blockquote><p>指针常量指 指针的指向永远不能发生变化；但是指针指向的值可以有变化；</p></blockquote><h3 id="9-4-如何区分到底是-常量指针，还是指针常量"><a href="#9-4-如何区分到底是-常量指针，还是指针常量" class="headerlink" title="9.4  如何区分到底是 常量指针，还是指针常量"></a>9.4  如何区分到底是 常量指针，还是指针常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p; <span class="comment">// 如果先碰到const关键字，就把常量先念出来</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p; <span class="comment">// 如果先看到 *，就把指针先念出来</span></span><br></pre></td></tr></table></figure><h3 id="9-5-两个const修饰"><a href="#9-5-两个const修饰" class="headerlink" title="9.5  两个const修饰"></a>9.5  两个const修饰</h3><p><code>const int *const p;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;i;</span><br><span class="line"></span><br><span class="line">p = &amp;j; <span class="comment">// warning 因为p是只读的，不能更改指向；</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// warning 因为*p 也是只读的；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-6-指向符号常量的指针"><a href="#9-6-指向符号常量的指针" class="headerlink" title="9.6  指向符号常量的指针"></a>9.6  指向符号常量的指针</h3><p><code>const int * p;</code></p><p>当把p定义成一个指向符号常量的指针的时侯， 然后再让这个p指向什么东西， 它所指向的那个东西就不能被修改了。我们就不能通过p再去修改 它所指向的那个东西了。</p><ul><li>深坑啊,要留意</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">78</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a;</span><br><span class="line">*p1 = <span class="number">58</span>;   <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line">p1 = &amp;b;    <span class="comment">// （可以给 p1 重新赋值）</span></span><br><span class="line">*p1 = <span class="number">68</span>;    <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line"><span class="built_in">printf</span>(D, *p1);  <span class="comment">// 28</span></span><br><span class="line">p1 = &amp;c;      <span class="comment">// （可以给 p1 重新赋值）</span></span><br><span class="line">*p1 = <span class="number">88</span>;     <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line"><span class="built_in">printf</span>(D, *p1)  <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-7-再谈一维数组的地址"><a href="#9-7-再谈一维数组的地址" class="headerlink" title="9.7 再谈一维数组的地址"></a>9.7 再谈一维数组的地址</h3><p><em>数组名相当于指向数组第一个元素的指针</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// a[1]的地址，管辖范围只有a[1]</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// a[1]的地址，管辖范围是整个a的内存空间</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// a[2]的地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 跳出了a的内存范围，理论上是 a[5]的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(P, a);           <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, a+<span class="number">1</span>);         <span class="comment">// 0x7ffee42adab4   跨越4个字节</span></span><br><span class="line"><span class="built_in">printf</span>(P, &amp;a);          <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, &amp;a+<span class="number">1</span>);        <span class="comment">// 0x7ffee42adac0  // 跨越16个字节</span></span><br><span class="line"><span class="built_in">printf</span>(P, *(&amp;a));       <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, *(&amp;a) + <span class="number">1</span>);   <span class="comment">// 0x7ffee42adab4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据C语言的规范 *(&amp;a)  等同于 a; 即a数组第一个元素的内存地址<br>*(&amp;a) + 1 等同于 a+1; 即a数组第二个元素的内存地址</p><p>&amp;a的管辖范围是整个数组a。c语言规范中，当它前面出现*时，管辖范围降级，即堕落成了 a[0]的地址；</p><h3 id="9-8-总结"><a href="#9-8-总结" class="headerlink" title="9.8  总结"></a>9.8  总结</h3><blockquote><p>数组名相当于指向数组第一个元素的指针</p></blockquote><ul><li>&amp;运算符 - 升级</li></ul><p>若 a 是指向数组第一个元素的指针，即a相当于 &amp;a[0];</p><ul><li>&amp;a是“指向数组”的指针；&amp;a+1将跨越16个字节；</li><li>&amp;a相当于管辖范围 “上升” 了一级;</li></ul><ul><li>*运算符 - 降级<br>*a是数组的第一个元素a[0]；即 *a等价于a[0]；</li></ul><ul><li>*a 相当于管辖范围“下降”了一级；      </li></ul><h3 id="9-9-指向二维数组的指针"><a href="#9-9-指向二维数组的指针" class="headerlink" title="9.9  指向二维数组的指针"></a>9.9  指向二维数组的指针</h3><ul><li><p>二维数组的定义</p><ul><li>二维数组a[3][4]包含三个元素： a[0] a[1] a[2]</li><li>每个元素都是一个“包含四个整型元素”的数组</li></ul></li></ul><p>| 1 a[0][0]  | 2 a[0][1] | 3 a[0][2] | 4 a[0][3] |<br>| 5 a[1][0]  | 6 a[1][1] | 7 a[1][2] | 8 a[1][3] |<br>| 9 a[2][0]  | 10 a[2][1]| 11 a[2][2]| 12 a[2][3]| </p><pre><code>- 二维数组的第一个元素是a[0];- a[0]是一个“包含四个整形元素”的一维数组；</code></pre><p><img src="./pointer_1.png" alt=""></p><p>推论</p><p>a 与 &amp;a[0] 等价<br>a[0] 与  &amp;a[0][0] 等价<br>a[0] 与 <em>a 等价<br>a[0][0] 与 *</em>a 等价</p><h3 id="9-10-总结"><a href="#9-10-总结" class="headerlink" title="9.10  总结"></a>9.10  总结</h3><p>三条规律<br>1） 数组名相当于指向数组第一个元素的指针；<br>2） &amp;E相当于把E的管辖范围上升了一个级别；<br>3） *E相当于把E的管辖范围下降了一个级别；</p><h2 id="24-指针与函数"><a href="#24-指针与函数" class="headerlink" title="24. 指针与函数"></a>24. 指针与函数</h2><h3 id="10-1-指针用作函数参数"><a href="#10-1-指针用作函数参数" class="headerlink" title="10.1 指针用作函数参数"></a>10.1 指针用作函数参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> *q1, <span class="keyword">int</span> *q2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (*q1 &lt; *q2)&#123;</span><br><span class="line">        temp = *q1;</span><br><span class="line">        *q1 = *q2;</span><br><span class="line">        *q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, *p1, *p2;</span><br><span class="line">    <span class="built_in">scanf</span>(a);</span><br><span class="line">    <span class="built_in">scanf</span>(b);</span><br><span class="line">    p1 = &amp;a; p2 = &amp;b;</span><br><span class="line">    Rank(p1, p2); <span class="comment">// 指针传递，即地址传递</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-将数组名作为实参"><a href="#10-2-将数组名作为实参" class="headerlink" title="10.2 将数组名作为实参"></a>10.2 将数组名作为实参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">total += *p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, total); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">sum(a, <span class="number">3</span>); <span class="comment">// 将数组名作为实参赋给指针型形参</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-“数组名”-做形参"><a href="#10-3-“数组名”-做形参" class="headerlink" title="10.3  “数组名” 做形参"></a>10.3  “数组名” 做形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 编译器将形参数组名 作为 指针变量来处理！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span><span class="number">-1</span>; i++) &#123;</span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>) = *<span class="built_in">array</span> + *(<span class="built_in">array</span>+<span class="number">1</span>); <span class="comment">// 数组从第二项开始，每一项都等于自己加上前一项的和；</span></span><br><span class="line"><span class="built_in">array</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(a, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序里，把一个指针变量或者是数组的名字，传递给一个函数的时候，是挺危险的，因为这个函数拿到的，是这个变量或者是数组的地址， 它拿到了地址，它就可以直接对地址里面存放的这些值，进行肆意的修改，那有没有一种办法，可以呢 使我既能够把这个地址传递给某个函数，又能够确保不让这个函数随意的修改这片地址里面的值呢？ </p><ul><li>如何 “限制” 指针的功能<ul><li>如何“限制”指针实参的功能</li></ul></li></ul><h3 id="10-4-即指向符号常量的指针"><a href="#10-4-即指向符号常量的指针" class="headerlink" title="10.4  即指向符号常量的指针"></a>10.4  即指向符号常量的指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 补充为const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span><span class="number">-1</span>; i++) &#123;</span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>) = *<span class="built_in">array</span> + *(<span class="built_in">array</span>+<span class="number">1</span>); <span class="comment">//  array变成常量之后，无法修改</span></span><br><span class="line"><span class="built_in">array</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(a, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符号常量声明语句</p><ol><li>const 数组类型 常量名 = 常量值；</li><li>数据类型 const 常量名 = 常量值；</li></ol><h3 id="10-5-指针用作函数返回值"><a href="#10-5-指针用作函数返回值" class="headerlink" title="10.5  指针用作函数返回值"></a>10.5  指针用作函数返回值</h3><p>函数的返回值可以是多种类型</p><ol><li>返回整形数据的函数<br> <code>int max(int x, int y);</code></li><li>返回指针类型数据的函数<br> <code>int *min(int x, int y)</code><ul><li>函数名字前面表示函数的类型 *</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int arr[][4] 除了这么定义，还可以 int *(arr)[4]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *pt;</span><br><span class="line">pt = *(arr+n<span class="number">-1</span>) + m<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> (pt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="built_in">get</span>(a, <span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析一下返回结果， 又一个需要注意的深坑</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = getInt1();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">// 这里会打印未知数，也可能会打印20；为什么呢，因为随着getInt1的运行时完毕，导致它函数内部的所有引用被释放了。所以返回的地址&amp;value1 指向的内存空间被释放掉了；所以谁也不会知道这个地址现在存放的是个啥，如果该块内存没有被新写入值，那么还是20；新写入的话，那就是新的未知量了；</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value2 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p, *q;</span><br><span class="line">p = getInt1();</span><br><span class="line">q = getInt2();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);  <span class="comment">// 这里大概率会是30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那既然如此，有什么办法解决这个问题</p><ul><li>静态局部变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value2 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p, *q;</span><br><span class="line">p = getInt1();</span><br><span class="line">q = getInt2();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *q);  <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>什么是静态局部变量</li></ul><p>** 静态局部变量 ** </p><blockquote><p>函数中局部变量的值在函数调用结束后不消失而保留原值</p></blockquote><p>即其占用的存储单元不释放，在下一次该函数调用时，仍可以继续使用该变量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;  <span class="comment">// 有点像 hooks，只初始化一次，后续不再重新将其赋值为0；</span></span><br><span class="line">    a = a+<span class="number">1</span>;</span><br><span class="line">    b = b+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i&lt;<span class="number">3</span>;i--)&#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>小结</li></ul><p>指针与函数</p><pre><code>指针用做函数参数    函数拿到地址可对其所指内容进行修改；    可以使用const来“限制”指针的功能；指针用做函数返回值    必须确保函数返回的地址是有意义的；    返回全局变量或静态局部变量；</code></pre><h2 id="25-指针数组和数组指针"><a href="#25-指针数组和数组指针" class="headerlink" title="25. 指针数组和数组指针"></a>25. 指针数组和数组指针</h2><h3 id="11-1-数组指针"><a href="#11-1-数组指针" class="headerlink" title="11.1 数组指针"></a>11.1 数组指针</h3><blockquote><p>归根结底是一个指针，是指向数组的指针。</p></blockquote><p>【存储类型】 数据类型 （*指针名）【下标】 = 值；</p><p>如： <code>int (*p)[3]; ---&gt; type name  ----&gt;  int[3] *p</code></p><p>解析：</p><blockquote><p>定义一个指针变量 p, 用来指向 <code>int[3]</code> 类型的元素的起始位置。原来 <code>int * p</code> 的时候，<code>p+1</code> 的操作是移动一个 <code>int</code> 的大小。如果p的类型 变成了 <code>int [3]</code>的话，<code>p+1</code>的操作是一下移动三个 int 元素的大小。所以数组指针是在某种 大小的数组中进行移动。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = *a;</span><br><span class="line">     <span class="keyword">int</span> (*q)[N]= a;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p %p\n"</span>, a, a+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p %p\n\n"</span>, q, q+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt;M; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%p -&gt; %d\n"</span>, *(a+i)+j, *(*(a+i)+j));</span><br><span class="line">            <span class="comment">//  printf("%p -&gt; %d\n", *(q+i)+j, *(*(q+i)+j)); // a 和 q现在是等价的，区别只是一个是常量，一个是变量；</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 0x7ffd6f5ad200</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 0x7ffd6f5ad200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 -&gt; 1</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f4 -&gt; 2</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f8 -&gt; 3</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1fc -&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad200 -&gt; 5</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad204 -&gt; 6</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad208 -&gt; 7</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad20c -&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad210 -&gt; 9</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad214 -&gt; 10</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad218 -&gt; 11</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad21c -&gt; 12</span></span><br></pre></td></tr></table></figure><h3 id="11-2-指针数组"><a href="#11-2-指针数组" class="headerlink" title="11.2 指针数组"></a>11.2 指针数组</h3><blockquote><p>归根结底是一个数组</p></blockquote><p>【存储类型】 数据类型 * 数组名 【长度】</p><p>如： <code>int * arr[3]; ---&gt; TYPE NAME ---&gt; int *[3] arr;</code></p><h3 id="11-3-指针数组与数组指针的区别"><a href="#11-3-指针数组与数组指针的区别" class="headerlink" title="11.3 指针数组与数组指针的区别"></a>11.3 指针数组与数组指针的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, k, j;</span><br><span class="line">  <span class="comment">//  指针数组</span></span><br><span class="line">  <span class="keyword">char</span> *name[<span class="number">5</span>] = &#123;<span class="string">"Follow me"</span>, <span class="string">"Basic"</span>, <span class="string">"Great"</span>, <span class="string">"Fortran"</span>, <span class="string">"Computer"</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> *tmp;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span> - <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    k = i;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name[k], name[j]) &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != i)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp = name[i];</span><br><span class="line">      name[i] = name[k];</span><br><span class="line">      name[k] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(name[i]);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-多级指针"><a href="#26-多级指针" class="headerlink" title="26 .多级指针"></a>26 .多级指针</h2><p><img src="./point_01.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line1 <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Line2 <span class="keyword">int</span> *p = &amp;num</span><br><span class="line">Line3 <span class="keyword">int</span> *p1 = p;</span><br><span class="line">Line4 <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">Line5 <span class="keyword">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure><p>多级指针的本质，只是C语言的一个书写规范<br>，事实上任何指针都可以保存任何地址；</p><ul><li>多级指针的存储的值的推理过程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line1 <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Line2 <span class="keyword">int</span> *p = &amp;num</span><br><span class="line">Line3 <span class="keyword">int</span> *p1 = p;</span><br><span class="line">Line4 <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">Line5 <span class="keyword">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li>函数的定义</li><li>函数的传参</li><li>函数的调用 （嵌套和递归）</li><li>函数与数组</li><li>函数与指针 （指针函数， 函数指针， 函数指针数组）</li></ol><h2 id="27-函数的定义"><a href="#27-函数的定义" class="headerlink" title="27. 函数的定义"></a>27. 函数的定义</h2><p>  数据类型  函数名 （【数据类型 形参名 。。。】）</p><blockquote><p>函数的类型是指 函数的返回值的数据类型</p></blockquote><h3 id="1-1-1-main函数"><a href="#1-1-1-main函数" class="headerlink" title="1.1.1 main函数"></a>1.1.1 main函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  argc： 参数计数器，统计终端上多少个参数传进来</span></span><br><span class="line"><span class="comment">  *argv[]： 列表，用来传递刚才命令行传递进来的参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *argv[]是一个数组；</span></span><br><span class="line"><span class="comment">  argv 是数组名；</span></span><br><span class="line"><span class="comment">  char* 指数组中每个元素的类型为 char*；即字符指针</span></span><br><span class="line"><span class="comment">  argv 即字符数组指针的首地址；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"argc=%d\n"</span>, argc);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main /etc/a*.conf</span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>因为shell 会自动解析通配符，把结果都解析出来。</p><p><img src="./function_01.png" alt=""><br>图示：char * argv 数组模型</p><p>** 输出argv** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">// for (i=0; i&lt;argc; i++)</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; argv[i] !=<span class="literal">NULL</span>; i++)</span><br><span class="line">    <span class="built_in">puts</span>(argv[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-C语言使用函数之前也需要先声明"><a href="#1-1-2-C语言使用函数之前也需要先声明" class="headerlink" title="1.1.2 C语言使用函数之前也需要先声明"></a>1.1.2 C语言使用函数之前也需要先声明</h3><blockquote><p>函数在使用前都要声明，除非被调用函数的定义部分已经出现在主调函数之前, 在C语言中，函数声明就是函数原型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 需要先声明，因为main函数在 printf_hello函数上面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  printf_hello();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-函数的传参"><a href="#28-函数的传参" class="headerlink" title="28. 函数的传参"></a>28. 函数的传参</h2><h3 id="1-2-1-值传递"><a href="#1-2-1-值传递" class="headerlink" title="1.2.1 值传递"></a>1.2.1 值传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_value</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="comment">// 参数i j 随着 print_value 调用栈执行结束就释放掉了。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d%d\n"</span>, i,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i =<span class="number">3</span>; l = <span class="number">5</span>;</span><br><span class="line">  printf_value(i,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-地址传递"><a href="#1-2-2-地址传递" class="headerlink" title="1.2.2 地址传递"></a>1.2.2 地址传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> * i, <span class="keyword">int</span> * j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  tmp = *i;</span><br><span class="line">  *i = *j;</span><br><span class="line">  *j = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i =<span class="number">3</span>; l = <span class="number">5</span>;</span><br><span class="line">  swap(&amp;i,&amp;l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29-函数的调用（嵌套调用-和-递归调用）"><a href="#29-函数的调用（嵌套调用-和-递归调用）" class="headerlink" title="29. 函数的调用（嵌套调用 和 递归调用）"></a>29. 函数的调用（嵌套调用 和 递归调用）</h2><h3 id="1-3-1-函数的调用方式"><a href="#1-3-1-函数的调用方式" class="headerlink" title="1.3.1 函数的调用方式"></a>1.3.1 函数的调用方式</h3><ol><li>函数调用作为独立语句，<code>stringPrint();</code></li><li>函数作为表达式的一部分,<code>number = max(numA,numB)/2;</code></li><li>以实参形式出现在其他函数的调用中,<code>number = min(sum(-5, 100), numC);</code></li></ol><h3 id="1-3-2-嵌套调用"><a href="#1-3-2-嵌套调用" class="headerlink" title="1.3.2 嵌套调用"></a>1.3.2 嵌套调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">max</span>(a,b,c) - <span class="built_in">min</span>(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = a &lt; b? a :b;</span><br><span class="line">  <span class="keyword">return</span> tmp &lt; c ? tmp : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = a &gt; b? a :b;</span><br><span class="line">  <span class="keyword">return</span> tmp &gt; c ? tmp : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>, c = <span class="number">10</span>;</span><br><span class="line">  result = minus(a,b,c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-函数与数组"><a href="#30-函数与数组" class="headerlink" title="30. 函数与数组"></a>30. 函数与数组</h2><h3 id="1-4-1-函数与一唯数组"><a href="#1-4-1-函数与一唯数组" class="headerlink" title="1.4.1 函数与一唯数组"></a>1.4.1 函数与一唯数组</h3><p>问题：封装一个printf_arr方法来遍历数组；应该如何定义 printf_arr 的行参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_arr</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"printf_arr ---&gt; %p\n"</span>, a); <span class="comment">// 传入的是 数组 a的 起始地址；</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++) <span class="comment">// 是因为 a的 sizeof为 8， 所以只能访问数组前2位</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);   <span class="comment">// 1， 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main ---&gt; %p\n"</span>,a ); <span class="comment">// a 即 &amp;a, 即 &amp;a[0];</span></span><br><span class="line">  printf_arr(a);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main       ---&gt; 0x7ffd84a62eb0</span></span><br><span class="line"><span class="comment">// printf_arr ---&gt; 0x7ffd84a62eb0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(p));<span class="comment">// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(a)); <span class="comment">// 20，整个数组所占内存的大小，因为每个int是 4个字节；</span></span><br><span class="line">  print_arr(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 解决方法**</p><p>将数组的长度，当做第二个参数传入给 子函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(p));<span class="comment">// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]); <span class="comment">// p[i] 与 *(p+i) 等价</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(a)); <span class="comment">// 20，整个数组所占内存的大小，因为每个int是 4个字节；</span></span><br><span class="line">  print_arr(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_arr</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 当 p[] 作为行参时， [] 等同于 * 因此 int p[] 即为 int *p</span></span><br></pre></td></tr></table></figure><p>** 示例** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>  a[N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">   a            -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  *a即*(a+<span class="number">0</span>)    -&gt;  <span class="keyword">int</span></span><br><span class="line">  a[<span class="number">0</span>]          -&gt;  <span class="keyword">int</span></span><br><span class="line">  &amp;a[<span class="number">3</span>]         -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  p[i]          -&gt;  <span class="keyword">int</span></span><br><span class="line">  p             -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  *p            -&gt;  <span class="keyword">int</span></span><br><span class="line">  p+<span class="number">1</span>           -&gt;  <span class="keyword">int</span> *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 逆序** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j, m, tmp;</span><br><span class="line">  m = (n <span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;=m;i++) &#123;</span><br><span class="line">    j = n <span class="number">-1</span> -i;</span><br><span class="line">    tmp = p[i];</span><br><span class="line">    p[i] = p[j];</span><br><span class="line">    p[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">0</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  func(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a));</span><br><span class="line">   <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-函数与二维数组"><a href="#1-4-2-函数与二维数组" class="headerlink" title="1.4.2 函数与二维数组"></a>1.4.2 函数与二维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; M; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure><p>问题： 同样的把输出放到一个独立的函数中去，也就是考察一下 二维数组应该如何给函数传参</p><blockquote><p>这个问题实际考察点在于 二维数组如何 过实参给函数，以及函数的二维数组行参应该如何定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种, 用一个二维数组的指针去接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> (*p) [N], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(*p+i)); <span class="comment">// 关键点在这里， 首先 p 指向的是 int [3] 这个类型。所以需要降级 为列指针</span></span><br><span class="line">      &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M*N); <span class="comment">// *a  === a[0] === *(a+0)</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种，用一个普通一维数组指针去接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n);</span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(p+i));</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(&amp;a[<span class="number">0</span>][<span class="number">0</span>], M*N); <span class="comment">// 传递的是列指针</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span>  <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> (*p)[N],<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(*(p+i)+j));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M,N);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四种</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> p[][N],<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>, p[i][j]);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M,N);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>** 小结 ** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[M][N] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">int</span> * p = *a;</span><br><span class="line"><span class="keyword">int</span> (*q)[N] = a;</span><br></pre></td></tr></table></figure><p>二维数组 参与传参的一些基本内容</p><table><thead><tr><th align="left">a[i][j]</th><th align="center">*(a+i)+j</th><th align="right">a[i]+j</th><th align="center">p[i]</th><th align="right">*p</th></tr></thead><tbody><tr><td align="left">q[i][j]</td><td align="center">*q === *(q+0)</td><td align="right">q</td><td align="center">p+3</td><td align="right">q+2</td></tr><tr><td align="left">int</td><td align="center">int *</td><td align="right">int *</td><td align="center">int</td><td align="right">int</td></tr><tr><td align="left">int</td><td align="center">int *</td><td align="right">int (*)[N]</td><td align="center">int *</td><td align="right">int (*)[N]</td></tr></tbody></table><h4 id="1-4-2-1-示例：-求平均数"><a href="#1-4-2-1-示例：-求平均数" class="headerlink" title="1.4.2.1 示例： 求平均数"></a>1.4.2.1 示例： 求平均数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">average_score</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum/n;</span><br><span class="line">&#125;</span><br><span class="line">find_num(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+num)+i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">  average_score(*a, M*N);</span><br><span class="line">  find_num(a, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-2-二维数组什么时候传行指针，什么时候传列指针"><a href="#1-4-2-2-二维数组什么时候传行指针，什么时候传列指针" class="headerlink" title="1.4.2.2  二维数组什么时候传行指针，什么时候传列指针"></a>1.4.2.2  二维数组什么时候传行指针，什么时候传列指针</h4><blockquote><p>当不区分行列的时候，可以把它当作一个大的一维数组。那就传递指针。 如果要区分行列来做某件事情的时候，那就需要把行指针传递过去。</p></blockquote><h3 id="1-4-3-函数与字符数组"><a href="#1-4-3-函数与字符数组" class="headerlink" title="1.4.3 函数与字符数组"></a>1.4.3 函数与字符数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(str2, str1);  <span class="comment">//实现了拷贝</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">mystrcpy</span><span class="params">(<span class="keyword">char</span> * dest, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ret = dest;</span><br><span class="line">  <span class="keyword">if</span> (dest != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">while</span>((*dest++ = *src++) != <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  mystrcpy(str2, str1);  <span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line">  <span class="built_in">puts</span>(str2); <span class="comment">// 测试一下</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个 mystrncpy 用于拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">mystrncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i&lt;n &amp;&amp; (dest[i] = src[i]); i++)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">for</span> (; i&lt;n; i++)</span><br><span class="line">    dest[i] = <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  mystrncpy(str2, str1, <span class="number">5</span>);  <span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line">  <span class="built_in">puts</span>(str2); <span class="comment">// 测试一下</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-函数与指针"><a href="#31-函数与指针" class="headerlink" title="31.  函数与指针"></a>31.  函数与指针</h2><blockquote><p>指针函数, 函数指针, 函数指针数组</p></blockquote><h3 id="1-5-1-指针函数"><a href="#1-5-1-指针函数" class="headerlink" title="1.5.1 指针函数"></a>1.5.1 指针函数</h3><blockquote><p>一个函数的返回值为指针，即为指针函数</p></blockquote><p><code>返回值 * 函数名(形参);</code><br><code>如： int * fun(int);</code></p><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从find_num 这个函数说起，这个函数并不纯，而且没有实现它的功能；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, *(*(p+num)+i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">  <span class="keyword">float</span> ave;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  find_num(a, num); <span class="comment">// find_num 的设计不应该没有返回值；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span> <span class="comment">// 将find_num 设计成为一个指针函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; M <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> *(p+num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> * res;</span><br><span class="line">    <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> ave;</span><br><span class="line">    <span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line">    res = find_num(a, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d"</span>,res[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-函数指针"><a href="#1-5-2-函数指针" class="headerlink" title="1.5.2 函数指针"></a>1.5.2 函数指针</h3><blockquote><p>一个指针指向的是函数， 在C语言里面。你并不能用一个普通变量去接收 函数啊，或者结构体等等数据类型，必须要使用相同的类型变量去接收相同的类型。比如函数要用函数指针变量去接收；</p></blockquote><p>  类型  (<em>指针名) （形参）<br>  如： int (</em>p)(int);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个函数指针</span></span><br><span class="line"></span><br><span class="line">  p = add; <span class="comment">// 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址， 也可以写成 p = &amp;add;这里之所以省略，是因为函数名(add)本身就是一个地址。所以在指针和函数的指向关系当中，地址符可以省略。同样的 `ret = *p(a, b)`； p前面的 *也可以省略。 `ret = p(a, b)`。指向函数的指针，让这个指针指向某一个函数的入口地址。下面通过指针来传参数就如同通过函数名来传参数是一样的；</span></span><br><span class="line">  ret = p(a, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-函数指针数组"><a href="#1-5-3-函数指针数组" class="headerlink" title="1.5.3 函数指针数组"></a>1.5.3 函数指针数组</h3><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret1, ret2;</span><br><span class="line">  <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个函数指针</span></span><br><span class="line">  <span class="keyword">int</span> (*q)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 这里面定义两个相同的 函数指针有点浪费</span></span><br><span class="line"></span><br><span class="line">  p = add; <span class="comment">// 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址</span></span><br><span class="line">  ret1 = p(a, b);</span><br><span class="line">  ret2 = q(a, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret2;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-引出函数指针数组"><a href="#1-5-4-引出函数指针数组" class="headerlink" title="1.5.4 引出函数指针数组"></a>1.5.4 引出函数指针数组</h3><p>语法：</p><p>类型 （<em>数组名[下标]）（形参）；<br>如: int (</em>arr[N])(int);<br>arr是一个数组，这个数组有N个元素。这N个元素都是指向函数的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret1, ret2;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">// int (int, int) *funcp[2];  funcp这个数组有两个指针，两个指针都是指向 int (int, int) 类型的函数； 转换一种写法就是</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> (*funcp[<span class="number">2</span>])(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// p = add;</span></span><br><span class="line">  <span class="comment">// q = sub;</span></span><br><span class="line">  <span class="comment">// ret1 = p(a, b);</span></span><br><span class="line">  <span class="comment">// ret2 = q(a, b);</span></span><br><span class="line"></span><br><span class="line">  funcp[<span class="number">0</span>] = add;</span><br><span class="line">  funcp[<span class="number">1</span>] = sub;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret1 = funcp[i](a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf("%d\n",ret1);</span></span><br><span class="line">  <span class="comment">// printf("%d\n",ret2;</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-指向指针函数的函数指针数组"><a href="#1-5-5-指向指针函数的函数指针数组" class="headerlink" title="1.5.5 指向指针函数的函数指针数组"></a>1.5.5 指向指针函数的函数指针数组</h3><p>  <code>int *(*func[N])(int)</code></p><h2 id="32-函数的执行过程"><a href="#32-函数的执行过程" class="headerlink" title="32. 函数的执行过程"></a>32. 函数的执行过程</h2><h3 id="1-6-1-main函数-——-函数执行的入口"><a href="#1-6-1-main函数-——-函数执行的入口" class="headerlink" title="1.6.1 main函数 —— 函数执行的入口"></a>1.6.1 main函数 —— 函数执行的入口</h3><ul><li>遇到函数，开辟内存空间；</li><li>在内存空间再碰到函数时候，<ul><li>初始化内嵌函数；</li><li>传递参数</li><li>保存外层函数执行空间</li><li>执行完毕后。。。。释放函数执行栈</li><li>接收函数的返回值</li><li>恢复现场，从断点处继续执行</li></ul></li></ul><h3 id="1-6-2-参数的传递"><a href="#1-6-2-参数的传递" class="headerlink" title="1.6.2 参数的传递"></a>1.6.2 参数的传递</h3><ul><li><p>实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”。即拷贝</p></li><li><p>函数调用时，系统给行参分配存储单元，并将实参对应的值传递给形参；</p><p>P.S. 实参与形参的类型必须相同或可以兼容；</p></li></ul><h3 id="1-6-3-变量的作用范围"><a href="#1-6-3-变量的作用范围" class="headerlink" title="1.6.3 变量的作用范围"></a>1.6.3 变量的作用范围</h3><p>局部变量与全局变量</p><blockquote><p>根据变量在程序中作用范围的不同，可以将变量分为局部变量和全局变量</p></blockquote><ul><li><p>局部变量<br>在函数内或块内定义，只在这个函数或块内其作用的变量；</p></li><li><p>全局变量<br>在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。</p></li><li><p>当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量</p></li></ul><h2 id="33-数组与函数"><a href="#33-数组与函数" class="headerlink" title="33. 数组与函数"></a>33. 数组与函数</h2><ul><li>数组名 做函数参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">30</span>;</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  change(a);  <span class="comment">// 地址传递， 数组的名字代表着数组所在的地址；</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d, %d,"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>]); <span class="comment">// 30 50</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-缓冲区"><a href="#34-缓冲区" class="headerlink" title="34.  缓冲区"></a>34.  缓冲区</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// __FUNCTION__ 当前所在的函数，</span></span><br><span class="line">    <span class="comment">// __LINE__ 当前所在的行数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s:%d]before"</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s:%d]after"</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">./<span class="built_in">printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发现两个printf都没打印出来东西</span></span><br></pre></td></tr></table></figure><p>** 缓冲机制 **</p><blockquote><p>由于使用了终端设备，所以原本默认是全缓冲模式变成了行缓冲模式。所以printf是遇到了 \n 才去刷新缓冲区的。或者是当前等缓冲区满了去自动刷新。\n 是去强制刷新缓冲区。 没有加\n  那个“before”这句话就放到了输出缓冲区当中，什么时候刷新呢？ 要么等程序结束自动刷新IO，要么就是遇到一些强制刷新的函数iflush 这种，要么就等到缓冲区攒满了一次性去刷新。</p></blockquote><h2 id="35-动态内存管理"><a href="#35-动态内存管理" class="headerlink" title="35. 动态内存管理"></a>35. 动态内存管理</h2><blockquote><p>在编写程序时，通常并不知道需要处理的数据量，或者难以评估所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，就需要动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存管理原理；</p></blockquote><p>以下几个函数都存在标准 stdlib.h 中</p><h3 id="1-9-1-malloc-calloc-（分配新的内存区域）"><a href="#1-9-1-malloc-calloc-（分配新的内存区域）" class="headerlink" title="1.9.1 malloc  calloc （分配新的内存区域）"></a>1.9.1 malloc  calloc （分配新的内存区域）</h3><p><code>void *malloc(size_t, size);</code></p><p>它会在堆上分配这块连续的内存空间，并返回起始地址；</p><p><code>void *calloc(size_t nmemb, size_t size)</code></p><p>一个成员 size个大小，nmemb这么多成员的空间；连续申请多块 size大的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// 用完记得释放掉内存， 在同一个函数中做到 malloc 和 free一一对应</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span> ;i&lt;num; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>** 一道面试题 (提示： 这个程序当中已经产生了内存泄漏) **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// p在这个函数当中是一个局部变量，随着func执行完毕之后，这块内存空间会丢失。导致内存泄漏，只有随着操作系统中这个进程结束掉，才会释放这100个单位的内存</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  func(p, num);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> **p, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 用一个二级指针来接受</span></span><br><span class="line">  *p = <span class="built_in">malloc</span>(n);           <span class="comment">// 此时*p 就是main函数中的p</span></span><br><span class="line">  <span class="keyword">if</span> (*p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  func(&amp;p, num);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改法二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  p = func(p, num);  <span class="comment">// 用p 来接触返回值</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-2-realloc-（调整已分配的内存区域）"><a href="#1-9-2-realloc-（调整已分配的内存区域）" class="headerlink" title="1.9.2   realloc  （调整已分配的内存区域）"></a>1.9.2   realloc  （调整已分配的内存区域）</h3><p><code>void *realloc(void *ptr, size_t size);</code></p><p>重新分配一块动态的内存空间 ,比如之前用malloc calloc分配的内存空间太大或者太小，现在把 起始地址传进去(第一个参数); 然后要size 大小的这么一段(第二个参数)；所以 realloc会在当前地址往下继续扩展，凑足size返回回来；当然，如果*ptr 开始的这个区段，没有一整块size大小的空间，那么就会去别的内存上面去寻找。直到找到之后，再返回那块空间的起始地址回来；</p><h3 id="1-9-3-free-（释放已分配的内存区域）"><a href="#1-9-3-free-（释放已分配的内存区域）" class="headerlink" title="1.9.3  free  （释放已分配的内存区域）"></a>1.9.3  free  （释放已分配的内存区域）</h3><blockquote><p>原则， 谁申请谁释放， （防止内存泄露）；如果不能做到在同一函数中做到谁申请谁释放 就在同一模块中做到这些；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 测试地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p--&gt;%d\n"</span>, *p); <span class="comment">// 0xa--&gt;0</span></span><br><span class="line"><span class="built_in">free</span>(p);                 <span class="comment">// 正确的做法是</span></span><br><span class="line">p = <span class="literal">NULL</span>;                <span class="comment">// 正确的做法是，一个指针free了之后，立即赋值 NULL</span></span><br><span class="line"><span class="comment">// free 代表着 变量p对于那片 内存空间 没有了 控制权限；所以free之后要 p = NULL</span></span><br><span class="line">*p = <span class="number">123</span>;                <span class="comment">// 实际上这是个野指针，该块内存释放掉了，有可能被其他人用来声明变量了。这里重新赋值，相当于可能把别人的变量给覆盖了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);      <span class="comment">// 123</span></span><br><span class="line">                         <span class="comment">// 测试地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p--&gt;%d\n"</span>, *p); <span class="comment">// 0x7b--&gt;145574408</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts declaration files</title>
      <link href="2021/01/21/ts-declaration-files/"/>
      <url>2021/01/21/ts-declaration-files/</url>
      
        <content type="html"><![CDATA[<h2 id="10-Declaration-Files"><a href="#10-Declaration-Files" class="headerlink" title="10. Declaration Files"></a>10. Declaration Files</h2><h3 id="10-1-Declaration-Reference"><a href="#10-1-Declaration-Reference" class="headerlink" title="10. 1 Declaration Reference"></a>10. 1 Declaration Reference</h3><p>本节显示一些API的文档以及该API的示例用法，并说明如何编写相应的声明。</p><h4 id="10-1-1-具有属性的对象"><a href="#10-1-1-具有属性的对象" class="headerlink" title="10.1.1 具有属性的对象"></a>10.1.1 具有属性的对象</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">let</span> result = myLib.makeGreeting(<span class="string">"hello, world"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"The computed greeting is:"</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = myLib.numberOfGreetings;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeGreeting</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">let</span> <span class="title">numberOfGreetings</span>: <span class="title">number</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-2-Overloaded-Functions"><a href="#10-1-2-Overloaded-Functions" class="headerlink" title="10.1.2  Overloaded Functions"></a>10.1.2  Overloaded Functions</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="keyword">let</span> x : Widget = getWidget(<span class="number">43</span>);</span><br><span class="line"><span class="keyword">let</span> arr: Widget[] = getWidget(<span class="string">"all of them"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getWidget</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">Widget</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getWidget</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">Widget</span>[]</span>;</span><br></pre></td></tr></table></figure><h4 id="10-1-3-Reusable-Types-Interfaces"><a href="#10-1-3-Reusable-Types-Interfaces" class="headerlink" title="10.1.3 Reusable Types (Interfaces)"></a>10.1.3 Reusable Types (Interfaces)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line">greet(&#123;</span><br><span class="line">  greeting: <span class="string">"hello world"</span>,</span><br><span class="line">  duration: <span class="number">4000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">interface</span> GreetingSettings &#123;</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  duration?: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">setting: GreetingSettings</span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h4 id="10-1-4-Reusable-Types-Type-Aliases"><a href="#10-1-4-Reusable-Types-Type-Aliases" class="headerlink" title="10.1.4 Reusable Types (Type Aliases)"></a>10.1.4 Reusable Types (Type Aliases)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"howdy"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MyGreeter <span class="keyword">extends</span> Greeter &#123;&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">"hello"</span>);</span><br><span class="line">greet(getGreeting);</span><br><span class="line">greet(<span class="keyword">new</span> MyGreeter());</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用类型别名来简化类型：</span></span><br><span class="line"><span class="keyword">type</span> GreetingLike = <span class="built_in">string</span> | <span class="function">(<span class="params">(<span class="params"></span>)=&gt; <span class="built_in">string</span></span>) | <span class="params">MyGreeter</span>;</span></span><br><span class="line"><span class="function"><span class="params">declare</span> <span class="params">function</span> <span class="params">greet</span>(<span class="params">g: GreetingLike</span>): <span class="params">void</span>;</span></span><br></pre></td></tr></table></figure><h4 id="10-1-5-组织类型"><a href="#10-1-5-组织类型" class="headerlink" title="10.1.5 组织类型"></a>10.1.5 组织类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Greeter(<span class="string">"Hello"</span>);</span><br><span class="line">g.log(&#123; verbose: <span class="literal">true</span> &#125;);</span><br><span class="line">g.alert(&#123; modal: <span class="literal">false</span>, title: <span class="string">"Current Greeting"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用命名空间去组织类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> GreetingLib &#123;</span><br><span class="line">  <span class="keyword">interface</span> LogOptions &#123;</span><br><span class="line">    verbose?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> AlertOptions &#123;</span><br><span class="line">    modal: <span class="built_in">boolean</span>;</span><br><span class="line">    title?: <span class="built_in">string</span>;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用嵌套的命名空间来声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> GreetingLib.Options &#123;</span><br><span class="line">  <span class="comment">// Refer to via GreetingLib.Options.Log</span></span><br><span class="line">  <span class="keyword">interface</span> Log &#123;</span><br><span class="line">    verbose?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> Alert &#123;</span><br><span class="line">    modal: <span class="built_in">boolean</span>;</span><br><span class="line">    title?: <span class="built_in">string</span>;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-6-Classes"><a href="#10-1-6-Classes" class="headerlink" title="10.1.6 Classes"></a>10.1.6 Classes</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">const</span> myGreeter = <span class="keyword">new</span> Greeter(<span class="string">"hello, world"</span>);</span><br><span class="line">myGreeter.greeting = <span class="string">"howdy"</span>;</span><br><span class="line">myGreeter.showGreeting();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SpecialGreeter <span class="keyword">extends</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"Very special greetings"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用 declare class 来描述类或类对象。类可以具有属性和方法以及构造函数。</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">greeting: <span class="built_in">string</span></span>);</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  showGreeting(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-7-Global-Variables"><a href="#10-1-7-Global-Variables" class="headerlink" title="10.1.7 Global Variables"></a>10.1.7 Global Variables</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="built_in">console</span>.log(f00/<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> foo: <span class="built_in">number</span></span><br></pre></td></tr></table></figure><h4 id="10-1-8-Global-Functions"><a href="#10-1-8-Global-Functions" class="headerlink" title="10.1.8 Global Functions"></a>10.1.8 Global Functions</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line">greet(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">str: <span class="built_in">string</span></span>):<span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h3 id="10-2-Library-Structures"><a href="#10-2-Library-Structures" class="headerlink" title="10.2 Library Structures"></a>10.2 Library Structures</h3><p>针对不同类型的库，编写对应类型的声明文件。你是通过cdn获取这些库还是通过npm获取；你是require引入还是import引入；</p><h4 id="10-2-1-模块化的库"><a href="#10-2-1-模块化的库" class="headerlink" title="10.2.1 模块化的库"></a>10.2.1 模块化的库</h4><p>几乎每个现代的Node.js库都属于模块家族。这些类型的库仅在带有模块加载器的JS环境中工作。例如，express仅在Node.js中有效，并且必须使用CommonJS require函数加载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someLib = <span class="built_in">require</span>(<span class="string">"someLib"</span>);</span><br><span class="line">define(..., [<span class="string">'someLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">someLib</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>从代码中识别模块库</strong></p><ul><li>Unconditional calls to <code>require</code> or <code>define</code></li><li>Declarations like <code>import * as a from &#39;b&#39;;</code> or <code>export c;</code></li><li>Assignments to <code>exports</code> or <code>module.exports</code></li></ul><p>They will rarely have:</p><ul><li>Assignments to properties of <code>window</code> or <code>global</code></li></ul><h5 id="10-2-1-1-Modules-d-ts"><a href="#10-2-1-1-Modules-d-ts" class="headerlink" title="10.2.1.1 Modules.d.ts"></a>10.2.1.1 Modules.d.ts</h5><ul><li>常见的Commonjs 模式</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getArrayLength,</span><br><span class="line">  maxInterval,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This can be described by the following .d.ts:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br></pre></td></tr></table></figure><ul><li>Es  module</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This would have the following .d.ts equivalent:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Default Exports</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="regexp">/hello( world)?/</span>;</span><br><span class="line"><span class="comment">// .d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> helloWorld: <span class="built_in">RegExp</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> helloWorld;</span><br></pre></td></tr></table></figure><p>CommonJS中的一种导出样式是导出函数。由于函数也是对象，因此可以在导出中添加额外的字段。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.slice;</span><br><span class="line">&#125;</span><br><span class="line">getArrayLength.maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = getArrayLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Which can be described with:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 需要在 tsconfig.json 中设置 esModuleInterop: true</span></span><br></pre></td></tr></table></figure><p>如果没有在 tsconfig.json 中设置 esModuleInterop: true</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> getArrayLength &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 export= 语法</span></span><br><span class="line"><span class="keyword">export</span> = getArrayLength;</span><br></pre></td></tr></table></figure><ul><li>模块中的类型</li></ul><p>可能需要提供一种不存在的JavaScript代码类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    length: getArrayLength(arr),</span><br><span class="line">    firstObject: arr[<span class="number">0</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getArrayMetadata,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// described</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayMetadata = &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  firstObject: <span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>):<span class="title">ArrayMetadata</span></span>;</span><br><span class="line"><span class="comment">// 泛型优化版</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayMetadata&lt;ArrType&gt; = &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  firstObject: ArrType | <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>&lt;<span class="title">ArrType</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  arr: ArrType[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ArrayMetadata</span>&lt;<span class="title">ArrType</span>&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li>Namespaces in Module Code</li></ul><p>试图描述JavaScript运行时的关联可能很棘手。如果类似ES模块的语法没有提供足够的工具来描述导出，则可以使用名称空间。</p><p>您可能有足够复杂的类型来描述，因此您选择在.d.ts中对它们进行命名空间：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时可用的JavaScript类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> API &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">baseURL: <span class="built_in">string</span></span>);</span><br><span class="line">  getInfo(opts: API.InfoRequest): API.InfoResponse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This namespace is merged with the API class and allows for consumers, and this file</span></span><br><span class="line"><span class="comment">// to have types which are nested away in their own sections.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> API &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> InfoRequest &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> InfoResponse &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用<code>export as namespace</code>声明模块将在UMD上下文中的全局范围内可用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> namespaces moduleName;</span><br></pre></td></tr></table></figure><ul><li>Template</li></ul><p>为了让您了解所有这些部分如何组合在一起，这里是制作新模块时的参考.d.ts。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果此模块是在模块加载程序环境之外加载时公开全局变量“ myLib”的UMD模块，请在此处声明该全局变量。</span></span><br><span class="line"><span class="comment">否则，删除此声明。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module exports functions, declare them like so.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myOtherFunction</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ You can declare types that are available via importing the module */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ You can declare properties of the module using const, let, or var */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myField: <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><ul><li>库文件布局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myLib</span><br><span class="line">  +---- index.js</span><br><span class="line">  +---- foo.js</span><br><span class="line">  +---- bar</span><br><span class="line">         +---- index.js</span><br><span class="line">         +---- baz.js</span><br></pre></td></tr></table></figure><ul><li>声明文件布局应为</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@types&#x2F;myLib</span><br><span class="line">  +---- index.d.ts</span><br><span class="line">  +---- foo.d.ts</span><br><span class="line">  +---- bar</span><br><span class="line">         +---- index.d.ts</span><br><span class="line">         +---- baz.d.ts</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thest could be imported as</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"myLib"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"myLib/foo"</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">require</span>(<span class="string">"myLib/bar"</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">require</span>(<span class="string">"myLib/bar/baz"</span>);</span><br></pre></td></tr></table></figure><ul><li>Testing your types</li></ul><p>If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:</p><blockquote><ol><li>Create a new folder in <code>node_modules/@types/[libname]</code></li><li>Create an <code>index.d.ts</code> in that folder, and copy the example in</li><li>See where your usage of the module breaks, and start to fill out the index.d.ts</li><li>When you’re happy, clone <a href="https://github.com/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped/DefinitelyTyped</a> and follow the instructions in the README.</li></ol></blockquote><p>Otherwise</p><blockquote><ol><li>Create a new file in the root of your source tree: <code>[libname].d.ts</code></li><li>Add <code>declare module &quot;[libname]&quot; { }</code></li><li>Add the template inside the braces of the declare module, and see where your usage breaks</li></ol></blockquote><h5 id="10-2-1-2-module-function"><a href="#10-2-1-2-module-function" class="headerlink" title="10.2.1.2  module:function"></a>10.2.1.2  module:function</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greeter <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line">greeter(<span class="number">2</span>);</span><br><span class="line">greeter(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></table></figure><p>如果模块可以像一个函数一样被调用，需使用module-function 模版</p><p>要同时通过UMD和模块引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file for function modules.</span></span><br><span class="line"><span class="comment"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that ES6 modules cannot directly export class objects.</span></span><br><span class="line"><span class="comment">// This file should be imported using the CommonJS-style:</span></span><br><span class="line"><span class="comment">//   import x = require('[~THE MODULE~]');</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Alternatively, if --allowSyntheticDefaultImports or</span></span><br><span class="line"><span class="comment">// --esModuleInterop is turned on, this file can also be</span></span><br><span class="line"><span class="comment">// imported as a default import:</span></span><br><span class="line"><span class="comment">//   import x from '[~THE MODULE~]';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Refer to the TypeScript documentation at</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require</span></span><br><span class="line"><span class="comment">// to understand common workarounds for this limitation of ES6 modules.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when</span></span><br><span class="line"><span class="comment"> *~ loaded outside a module loader environment, declare that global here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this declaration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myFuncLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This declaration specifies that the function</span></span><br><span class="line"><span class="comment"> *~ is the exported object from the file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> = Greeter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This example shows how to have multiple overloads for your function */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">Greeter</span>.<span class="title">NamedReturnType</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">length: <span class="built_in">number</span></span>): <span class="title">Greeter</span>.<span class="title">LengthReturnType</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want to expose types from your module as well, you can</span></span><br><span class="line"><span class="comment"> *~ place them in this block. Often you will want to describe the</span></span><br><span class="line"><span class="comment"> *~ shape of the return type of the function; that type should</span></span><br><span class="line"><span class="comment"> *~ be declared in here, as this example shows.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ Note that if you decide to include this namespace, the module can be</span></span><br><span class="line"><span class="comment"> *~ incorrectly imported as a namespace object, unless</span></span><br><span class="line"><span class="comment"> *~ --esModuleInterop is turned on:</span></span><br><span class="line"><span class="comment"> *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> LengthReturnType &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> NamedReturnType &#123;</span><br><span class="line">    firstName: <span class="built_in">string</span>;</span><br><span class="line">    lastName: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*~ If the module also has properties, declare them here. For example,</span></span><br><span class="line"><span class="comment">   *~ this declaration says that this code is legal:</span></span><br><span class="line"><span class="comment">   *~   import f = require('super-greeter');</span></span><br><span class="line"><span class="comment">   *~   console.log(f.defaultName);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> defaultName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> defaultLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-1-2-module-class"><a href="#10-2-1-2-module-class" class="headerlink" title="10.2.1.2  module:class"></a>10.2.1.2  module:class</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeter = <span class="built_in">require</span>(<span class="string">"super-greeter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">new</span> Greeter();</span><br><span class="line">greeter.greet();</span><br></pre></td></tr></table></figure><p>如果导出的对象是一个类的话；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file for class modules.</span></span><br><span class="line"><span class="comment"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that ES6 modules cannot directly export class objects.</span></span><br><span class="line"><span class="comment">// This file should be imported using the CommonJS-style:</span></span><br><span class="line"><span class="comment">//   import x = require('[~THE MODULE~]');</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Alternatively, if --allowSyntheticDefaultImports or</span></span><br><span class="line"><span class="comment">// --esModuleInterop is turned on, this file can also be</span></span><br><span class="line"><span class="comment">// imported as a default import:</span></span><br><span class="line"><span class="comment">//   import x from '[~THE MODULE~]';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Refer to the TypeScript documentation at</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require</span></span><br><span class="line"><span class="comment">// to understand common workarounds for this limitation of ES6 modules.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when</span></span><br><span class="line"><span class="comment"> *~ loaded outside a module loader environment, declare that global here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this declaration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myClassLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This declaration specifies that the class constructor function</span></span><br><span class="line"><span class="comment"> *~ is the exported object from the file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> = MyClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Write your module's methods and properties in this class */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> MyClass &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">customGreeting?: <span class="built_in">string</span></span>);</span><br><span class="line"></span><br><span class="line">  greet: <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  myMethod(opts: MyClass.MyClassMethodOptions): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want to expose types from your module as well, you can</span></span><br><span class="line"><span class="comment"> *~ place them in this block.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ Note that if you decide to include this namespace, the module can be</span></span><br><span class="line"><span class="comment"> *~ incorrectly imported as a namespace object, unless</span></span><br><span class="line"><span class="comment"> *~ --esModuleInterop is turned on:</span></span><br><span class="line"><span class="comment"> *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> MyClass &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> MyClassMethodOptions &#123;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    height?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-1-3-Module-plugin"><a href="#10-2-1-3-Module-plugin" class="headerlink" title="10.2.1.3  Module: plugin"></a>10.2.1.3  Module: plugin</h5><p>If you have a module which when imported, makes changes to other modules use template</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jest = <span class="built_in">require</span>(<span class="string">'jest'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jest-matchers-files"</span>);</span><br></pre></td></tr></table></figure><p>when you want to work with JavaScript code which extends another library.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normal Greeter API</span></span><br><span class="line">greeter(<span class="number">2</span>);</span><br><span class="line">greeter(<span class="string">"Hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we extend the object with a new function at runtime</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"hyper-super-greeter"</span>;</span><br><span class="line">greeter.hyperGreet();</span><br></pre></td></tr></table></figure><p>The definition for “super-greeter”</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ This example shows how to have 多个重载 for your function */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> GreeterFunction &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">  (time: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This example shows how to export 一个接口指定的function  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> greeter: GreeterFunction;</span><br></pre></td></tr></table></figure><p>We can extend the existing module like the following:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module plugin template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ On this line, import the module which this module adds to */</span></span><br><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Here, declare the same module as the one you imported above</span></span><br><span class="line"><span class="comment"> *~ then we expand the existing declaration of the greeter function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> "super-greeter" &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> GreeterFunction &#123;</span><br><span class="line">    <span class="comment">/** Greets even better! */</span></span><br><span class="line">    hyperGreet(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2-Global-Libraries"><a href="#10-2-2-Global-Libraries" class="headerlink" title="10.2.2 Global Libraries"></a>10.2.2 Global Libraries</h4><p>全局库是可以从全局范围访问的库（即，无需使用任何形式的导入）。许多库只是公开一个或多个全局变量供使用。例如jquery;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(() =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--一般情况，全局库的使用方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://a.great.cdn.for/someLib.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，最流行的可全局库 实际上是作为 UMD标准 编写的（请参见下文）。 UMD库文档很难与全局库文档区分开。在编写全局声明文件之前，请确保该库不是UMD。</p><p><strong>从代码中识别Global Library</strong></p><p>查看全局库的代码时，通常会看到：</p><ul><li>Top-level <code>var</code> statements or <code>function</code> declarations</li><li>One or more assignments to <code>window.someName</code></li><li>Assumptions that DOM primitives like <code>document</code> or <code>window</code> exist</li></ul><p>You <em>won’t</em> see:</p><ul><li>Checks for, or usage of, module loaders like <code>require</code> or <code>define</code></li><li>CommonJS/Node.js-style imports of the form <code>var fs = require(&quot;fs&quot;);</code></li><li>Calls to <code>define(...)</code></li><li>Documentation describing how to <code>require</code> or import the library</li></ul><h5 id="10-2-2-1-Global-d-ts"><a href="#10-2-2-1-Global-d-ts" class="headerlink" title="10.2.2.1  Global.d.ts"></a>10.2.2.1  Global.d.ts</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this library is callable (e.g. can be invoked as myLib(3)),</span></span><br><span class="line"><span class="comment"> *~ include those call signatures here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this section.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">myLib</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">myLib</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want the name of this library to be a valid type name,</span></span><br><span class="line"><span class="comment"> *~ you can do so here.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ For example, this allows us to write 'var x: myLib';</span></span><br><span class="line"><span class="comment"> *~ Be sure this actually makes sense! If it doesn't, just</span></span><br><span class="line"><span class="comment"> *~ delete this declaration and add types inside the namespace below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> myLib &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your library has properties exposed on a global variable,</span></span><br><span class="line"><span class="comment"> *~ place them here.</span></span><br><span class="line"><span class="comment"> *~ You should also place types (interfaces and type alias) here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="comment">//~ We can write 'myLib.timeout = 50;'</span></span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can access 'myLib.version', but not change it</span></span><br><span class="line">  <span class="keyword">const</span> version: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ There's some class we can create via 'let c = new myLib.Cat(42)'</span></span><br><span class="line">  <span class="comment">//~ Or reference e.g. 'function f(c: myLib.Cat) &#123; ... &#125;</span></span><br><span class="line">  <span class="keyword">class</span> Cat &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">number</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~ We can read 'c.age' from a 'Cat' instance</span></span><br><span class="line">    readonly age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~ We can invoke 'c.purr()' from a 'Cat' instance</span></span><br><span class="line">    purr(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can declare a variable as</span></span><br><span class="line">  <span class="comment">//~   'var s: myLib.CatSettings = &#123; weight: 5, name: "Maru" &#125;;'</span></span><br><span class="line">  <span class="keyword">interface</span> CatSettings &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    tailLength?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can write 'const v: myLib.VetID = 42;'</span></span><br><span class="line">  <span class="comment">//~  or 'const v: myLib.VetID = "bob";'</span></span><br><span class="line">  <span class="keyword">type</span> VetID = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkCat</span>(<span class="params">c: Cat, s?: VetID</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-2-2-Global-Modifying-Module"><a href="#10-2-2-2-Global-Modifying-Module" class="headerlink" title="10.2.2.2 Global: Modifying Module"></a>10.2.2.2 Global: Modifying Module</h5><p>导入全局变量的模块会在全局范围内更改现有值。例如，可能存在一个库，该库在导入时将新成员添加到String.prototype。由于存在运行时冲突的可能性，该模式有些危险，但是我们仍然可以为其编写声明文件。</p><p><strong>识别全局修改模块</strong></p><p>全局修改模块通常易于从其文档中识别，它们类似全局插件，但是需要require方法的调用 才能激活它们的副作用；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'require' call that doesn't use its return value</span></span><br><span class="line"><span class="keyword">var</span> unused = <span class="built_in">require</span>(<span class="string">"magic-string-time"</span>);</span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"magic-string-time"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"hello, world"</span>;</span><br><span class="line"><span class="comment">// Creates new methods on built-in types</span></span><br><span class="line"><span class="built_in">console</span>.log(x.startsWithHello());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// Creates new methods on built-in types</span></span><br><span class="line"><span class="built_in">console</span>.log(y.reverseAndSort());</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the global-modifying module template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Note: If your global-modifying module is callable or constructable, you'll</span></span><br><span class="line"><span class="comment"> *~ need to combine the patterns here with those in the module-class or module-function</span></span><br><span class="line"><span class="comment"> *~ template files</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="comment">/*~ Here, declare things that go in the global namespace, or augment</span></span><br><span class="line"><span class="comment">   *~ existing declarations in the global namespace</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> String &#123;</span><br><span class="line">    fancyFormat(opts: StringFormatOptions): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your module exports types or values, write them as usual */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringFormatOptions &#123;</span><br><span class="line">  fancinessLevel: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ For example, declaring a method on the module (in addition to its global side effects) */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-UMD"><a href="#10-2-3-UMD" class="headerlink" title="10.2.3 UMD"></a>10.2.3 UMD</h4><p>UMD模块既可以用作模块（通过import），也可以用作全局模块（在没有模块加载器的环境中运行时）。这样编写了许多流行的库，例如Moment.js。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs 环境下</span></span><br><span class="line"><span class="keyword">import</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="comment">// 浏览器环境下</span></span><br><span class="line"><span class="built_in">console</span>.log(mement.format());</span><br></pre></td></tr></table></figure><p><strong>umd模版</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([<span class="string">"libName"</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"libName"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.returnExports = factory(root.libName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span> ? self : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Use b in some fashion.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Just return a value to define the module export.</span></span><br><span class="line">    <span class="comment">// This example returns an object, but the module</span></span><br><span class="line">    <span class="comment">// can return a function as the exported value.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>UMD库的文档通常还会演示一个显示require的“在Node.js中使用”示例，以及一个使用<code>script</code>标记加载该脚本的“在浏览器中使用”示例。</p><h4 id="10-2-4-Consuming-Dependencies"><a href="#10-2-4-Consuming-Dependencies" class="headerlink" title="10.2.4 Consuming Dependencies"></a>10.2.4 Consuming Dependencies</h4><p>你的库可能具有集中依赖关系，下面会说明如何将它们导入声明文件；</p><ul><li>Dependencies on Global Libraries</li></ul><p>If your library depends on a global library, use a <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> directive:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="someLib" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">someLib</span>.<span class="title">thing</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Dependencies on Modules</li></ul><p>If your library depends on a module, use an <code>import</code> statement:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">"moment"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">moment</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Dependencies on UMD libraries</li></ul><p>From a Global Library</p><p>If your global library depends on a UMD module, use a <code>/// &lt;reference types</code> directive:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="moment" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">moment</span></span>;</span><br></pre></td></tr></table></figure><p>From a Module or UMD Library</p><p>If your module or UMD library depends on a UMD library, use an <code>import</code> statement:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> someLib <span class="keyword">from</span> <span class="string">"someLib"</span>;</span><br></pre></td></tr></table></figure><p>Do <em>not</em> use a <code>/// &lt;reference</code> directive 来声明对UMD库的依赖！</p><h4 id="10-2-5-Preventing-Name-Conflicts"><a href="#10-2-5-Preventing-Name-Conflicts" class="headerlink" title="10.2.5 Preventing Name Conflicts"></a>10.2.5 Preventing Name Conflicts</h4><p>编写全局声明文件时，可以在全局范围内定义许多类型。强烈不建议这样做，因为当项目中有许多声明文件时，它可能导致无法解决的名称冲突。</p><p>库定义的任何全局变量只声明 namespaces</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> cats &#123;</span><br><span class="line"><span class="keyword">interface</span> KittySettings &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// But not</span></span><br><span class="line"> <span class="comment">// at top-level</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span> CatsKittySettings&#123;&#125;</span><br></pre></td></tr></table></figure><p>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</p><h3 id="10-3-Do’s-and-Don’ts"><a href="#10-3-Do’s-and-Don’ts" class="headerlink" title="10.3 Do’s and Don’ts"></a>10.3 Do’s and Don’ts</h3><h4 id="10-3-1-基本类型"><a href="#10-3-1-基本类型" class="headerlink" title="10.3.1 基本类型"></a>10.3.1 基本类型</h4><p>不要使用<code>Number,String,Boolean, Symbol, or Object</code> 等类型；</p><h4 id="10-3-2-any"><a href="#10-3-2-any" class="headerlink" title="10.3.2 any"></a>10.3.2 any</h4><p>any类型你懂得，尽量别用。anyScript毫无意义；</p><h4 id="10-3-3-Callback-Types"><a href="#10-3-3-Callback-Types" class="headerlink" title="10.3.3 Callback Types"></a>10.3.3 Callback Types</h4><p>对于返回值被忽略的回调，别使用any, 使用void更好；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: () =&gt; <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: () =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-4-重载和回调函数"><a href="#10-3-4-重载和回调函数" class="headerlink" title="10.3.4 重载和回调函数"></a>10.3.4 重载和回调函数</h4><p>不要编写仅在回调函数上有所不同的单独重载：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params">action: () =&gt; <span class="built_in">void</span>, timeout?: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (done: DoneFn) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Do write a single overload using the maximum arity:</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (done: DoneFn) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><p>原因：回调忽略参数始终是合法的，因此不需要较短的重载。首先提供一个较短的回调允许输入错误类型的函数，因为它们与第一个重载匹配。</p><h4 id="10-3-5-function-重载"><a href="#10-3-5-function-重载" class="headerlink" title="10.3.5 function 重载"></a>10.3.5 function 重载</h4><p>不要在更具体的重载之前放置更一般的重载；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLElement</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLDivElement</span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem: HTMLDivElement;</span><br><span class="line"><span class="keyword">var</span> x = fn(myElem); <span class="comment">// x: any, wat?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过将更一般的签名放在更具体的签名之后来对重载进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLDivElement</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLElement</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem: HTMLDivElement;</span><br><span class="line"><span class="keyword">var</span> x = fn(myElem); <span class="comment">// x: string, :)</span></span><br></pre></td></tr></table></figure><p>原因：TypeScript在解决函数调用时选择第一个匹配的重载。当较早的过载比较晚的过载“更普遍”时，较晚的过载实际上是隐藏的，无法调用。</p><h4 id="10-3-6-Use-Optional-Parameters"><a href="#10-3-6-Use-Optional-Parameters" class="headerlink" title="10.3.6 Use Optional Parameters"></a>10.3.6 Use Optional Parameters</h4><p>不要写一些仅在尾随参数上有所不同的重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">interface</span> Example &#123;</span><br><span class="line">  diff(one: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two: <span class="built_in">string</span>, three: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">interface</span> Example &#123;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two?: <span class="built_in">string</span>, three?: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-7-Union-Types"><a href="#10-3-7-Union-Types" class="headerlink" title="10.3.7 Union Types"></a>10.3.7 Union Types</h4><p>不要只在一个参数位置编写因类型而异的重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">interface</span> Moment &#123;</span><br><span class="line">  utcOffset(): <span class="built_in">number</span>;</span><br><span class="line">  utcOffset(b: <span class="built_in">number</span>): Moment;</span><br><span class="line">  utcOffset(b: <span class="built_in">string</span>): Moment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">interface</span> Moment &#123;</span><br><span class="line">  utcOffset(): <span class="built_in">number</span>;</span><br><span class="line">  utcOffset(b: <span class="built_in">number</span> | <span class="built_in">string</span>): Moment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// When written with separate overloads, incorrectly an error</span></span><br><span class="line">  <span class="comment">// When written with union types, correctly OK</span></span><br><span class="line">  <span class="keyword">return</span> moment().utcOffset(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-Deep-Dive"><a href="#10-4-Deep-Dive" class="headerlink" title="10.4 Deep Dive"></a>10.4 Deep Dive</h3><h4 id="10-4-1-Namespaces"><a href="#10-4-1-Namespaces" class="headerlink" title="10.4.1 Namespaces"></a>10.4.1 Namespaces</h4><p>类型可以存在于名称空间中。例如，如果我们有声明let x：A.B.C，则说类型C来自A.B命名空间。A， B 不一定必须是类型或者值</p><h4 id="10-4-2-简单组合，一个名字多种含义"><a href="#10-4-2-简单组合，一个名字多种含义" class="headerlink" title="10.4.2 简单组合，一个名字多种含义"></a>10.4.2 简单组合，一个名字多种含义</h4><p>给定名称A，我们最多可以找到A的三种不同含义：类型，值或名称空间。名称的解释方式取决于所使用的上下文。例如，在一个声明文件中 中 <code>let m：A.A = A ;</code>，首先将A用作namespaces，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！</p><h5 id="10-4-2-1-User-Combinations"><a href="#10-4-2-1-User-Combinations" class="headerlink" title="10.4.2.1 User Combinations"></a>10.4.2.1 User Combinations</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> SomeVar: &#123; a: SomeType &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumed</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">"./foo"</span>;</span><br><span class="line"><span class="keyword">let</span> x: foo.SomeType = foo.SomeVar.a;</span><br><span class="line"><span class="built_in">console</span>.log(x.count);</span><br></pre></td></tr></table></figure><p>这种方法不错，但我们可能会认为 SomeType 和 SomeVar 紧密相关，因此您希望它们具有相同的名称。我们可以使用合并相同的名称Bar呈现这两个不同的对象；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> Bar: &#123;a : Bar&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Bar &#123;</span><br><span class="line">count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumed</span></span><br><span class="line"><span class="keyword">import</span> &#123; Bar &#125; <span class="keyword">from</span> <span class="string">"./foo"</span>;</span><br><span class="line"><span class="keyword">let</span> x: Bar = Bar.a;</span><br><span class="line"><span class="built_in">console</span>.log(x.count);</span><br></pre></td></tr></table></figure><p>我们在这里使用Bar作为类型和值。请注意，我们不必将Bar值声明为Bar类型，它们是独立的。</p><h5 id="10-4-2-2-Advanced-Combinations"><a href="#10-4-2-2-Advanced-Combinations" class="headerlink" title="10.4.2.2 Advanced Combinations"></a>10.4.2.2 Advanced Combinations</h5><p>某些声明可以跨多个声明进行组合，比如 class C {}  和 interface C{} 可以共存，并且都给类型C贡献了属性。 只要不造成冲突，就是合法的，一般的经验法则是， 值始终会与同名的其他值发生冲突，除非将它们声明为namespaces,；</p><p>s, types will conflict if they are declared with a type alias declaration (<code>type s = string</code>), and namespaces never conflict.</p><ul><li>Adding using an `interface</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: Foo = ...;</span><br><span class="line"><span class="built_in">console</span>.log(a.x + a.y); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this also works with classes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: Foo = ...;</span><br><span class="line"><span class="built_in">console</span>.log(a.x + a.y); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that we cannot add to type aliases (type s = string;) using an interface.</span></span><br></pre></td></tr></table></figure><ul><li>Adding using a namespace</li></ul><p>可以使用namespace声明以任何不会造成冲突的方式添加新的类型，值和namespace。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给class添加一个静态成员</span></span><br><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">let</span> y = C.x; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>在此示例中，我们向C的静态侧（其构造函数）添加了一个值。这是因为我们添加了一个值，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。</p><p>We could also add a namespaced type to a class:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> D &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y: C.D; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>在我们为其编写 namespace 声明之前，没有 <code>namespace C</code>。作为命名空间的C的含义与该类创建的C的值或类型的含义不冲突。</p><p>我们可以使用名称空间声明执行许多不同的合并;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Y &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Z &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> Y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Z &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> C &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> X = <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>In this example, the first block creates the following name meanings:</p><ul><li>A value <code>X</code> (because the <code>namespace</code> declaration contains a value, <code>Z</code>)</li><li>A namespace <code>X</code> (because the <code>namespace</code> declaration contains a type, <code>Y</code>)</li><li>A type <code>Y</code> in the <code>X</code> namespace</li><li>A type <code>Z</code> in the <code>X</code> namespace (the instance shape of the class)</li><li>A value <code>Z</code> that is a property of the <code>X</code> value (该class的构造函数)</li></ul><p>The second block creates the following name meanings:</p><ul><li>A value <code>Y</code> (of type <code>number</code>) that is a property of the <code>X</code> value</li><li>A namespace <code>Z</code></li><li>A value <code>Z</code> that is a property of the <code>X</code> value</li><li>A type <code>C</code> in the <code>X.Z</code> namespace</li><li>A value <code>C</code> that is a property of the <code>X.Z</code> value</li><li>A type <code>X</code></li></ul><h3 id="10-5-Publish-to-npm"><a href="#10-5-Publish-to-npm" class="headerlink" title="10.5 Publish to npm"></a>10.5 Publish to npm</h3><h4 id="10-5-1-两种发布方法"><a href="#10-5-1-两种发布方法" class="headerlink" title="10.5.1 两种发布方法"></a>10.5.1 两种发布方法</h4><ol><li>bundling with your npm package</li><li>publishing to the <a href="https://www.npmjs.com/~types" target="_blank" rel="noopener">@types organization</a> on npm.</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="..." /&gt;</span></span><br><span class="line"><span class="comment">// Don’t use /// &lt;reference path="..." /&gt; in your declaration files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference path="../typescript/lib/typescriptServices.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do use /// &lt;reference types="..." /&gt; instead.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types="typescript" /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="10-5-2-Packaging-dependent-declarations"><a href="#10-5-2-Packaging-dependent-declarations" class="headerlink" title="10.5.2 Packaging dependent declarations"></a>10.5.2 Packaging dependent declarations</h4><p>If your type definitions depend on another package:</p><ul><li><em>Don’t</em> combine it with yours, keep each in their own file.</li><li><em>Don’t</em> copy the declarations in your package either.</li><li><em>Do</em> depend on the npm type declaration package if it doesn’t package its declaration files.</li></ul><h4 id="10-5-3-Publish-to-types"><a href="#10-5-3-Publish-to-types" class="headerlink" title="10.5.3 Publish to @types"></a>10.5.3 Publish to @types</h4><p>Packages under the <a href="https://www.npmjs.com/~types" target="_blank" rel="noopener">@types</a> organization are published automatically from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a> using the <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher" target="_blank" rel="noopener">types-publisher tool</a>. To get your declarations published as an @types package, please submit a pull request to <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a>. You can find more details in the <a href="http://definitelytyped.org/guides/contributing.html" target="_blank" rel="noopener">contribution guidelines page</a>.</p><h3 id="10-6-Find-and-Install-Declaration-Files"><a href="#10-6-Find-and-Install-Declaration-Files" class="headerlink" title="10.6 Find and Install Declaration Files"></a>10.6 Find and Install Declaration Files</h3><ul><li>loadsh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/lodash</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 npm install 了 类型声明</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line">_.padStart(<span class="string">"hi"</span>, <span class="number">20</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or if you’re not using modules, you can just use the global variable _.</span></span><br><span class="line">_.padStart(<span class="string">"Hello TypeScript!"</span>, <span class="number">20</span>, <span class="string">" "</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts modules</title>
      <link href="2021/01/20/ts-modules/"/>
      <url>2021/01/20/ts-modules/</url>
      
        <content type="html"><![CDATA[<h2 id="6-Modules"><a href="#6-Modules" class="headerlink" title="6. Modules"></a>6. Modules</h2><h3 id="6-1-import-export"><a href="#6-1-import-export" class="headerlink" title="6.1 import/export"></a>6.1 import/export</h3><p>模块是在自己的范围内执行的，而不是在全局范围内执行的；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用导出形式之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种导入形式将其导入。</p><p>模块是声明性的，模块之间的关系是根据文件级别的导入和导出指定的；</p><p>模块使用模块加载器相互导入， 在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。</p><h4 id="6-1-1-export"><a href="#6-1-1-export" class="headerlink" title="6.1.1 export"></a>6.1.1 export</h4><p>可以通过添加export关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重命名导出</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure><p><strong>重新导出不会将其导入本地，也不会引入局部变量。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParseIntBasedZipCodeValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(s).toString() === s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export original validator but rename it</span></span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> RegExpBasedZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br></pre></td></tr></table></figure><p><strong>导出所有</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./StringValidator"</span>; <span class="comment">// exports 'StringValidator' interface</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>; <span class="comment">// exports 'ZipCodeValidator' class and 'numberRegexp' constant value</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./ParseIntBasedZipCodeValidator"</span>; <span class="comment">//  exports the 'ParseIntBasedZipCodeValidator' class</span></span><br><span class="line"><span class="comment">// and re-exports 'RegExpBasedZipCodeValidator' as alias</span></span><br><span class="line"><span class="comment">// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'</span></span><br><span class="line"><span class="comment">// module.</span></span><br></pre></td></tr></table></figure><h4 id="6-1-2-import"><a href="#6-1-2-import" class="headerlink" title="6.1.2 import"></a>6.1.2 import</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single export</span></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="comment">// renamed</span></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> ZCV &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZCV();</span><br><span class="line"><span class="comment">// 将整个模块导入单个变量，并使用它来访问模块导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.ZipCodeValidator();</span><br><span class="line"><span class="comment">// 某些模块会设置一些可由其他模块使用的全局状态。这些模块可能没有任何出口</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./my-module.js"</span></span><br></pre></td></tr></table></figure><h4 id="6-1-3-default-exports"><a href="#6-1-3-default-exports" class="headerlink" title="6.1.3 default exports"></a>6.1.3 default exports</h4><blockquote><p>默认导出</p></blockquote><p>​        每个模块可以选择导出默认导出。默认导出用关键字<code>default</code>标记；每个模块只能有一个默认导出。默认导出使用其他导入形式导入。</p><p>​        默认出口真的很方便。例如，像jQuery之类的库可能具有jQuery或$的默认导出，我们也可能以$或jQuery的名称导入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> $:JQuery</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.ts</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">"jquery"</span>;</span><br><span class="line">$(<span class="string">"button"</span>).html(<span class="string">"xxx"</span>)</span><br></pre></td></tr></table></figure><h4 id="6-1-4-Export-all-as-x"><a href="#6-1-4-Export-all-as-x" class="headerlink" title="6.1.4 Export all as x"></a>6.1.4 Export all as x</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> utilities <span class="keyword">from</span> <span class="string">"./utilities"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;utilities&#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br></pre></td></tr></table></figure><h4 id="6-1-4-export-import-require"><a href="#6-1-4-export-import-require" class="headerlink" title="6.1.4 export =      import = require()"></a>6.1.4 export =      import = require()</h4><p>TypeScript supports <code>export =</code> to model the traditional CommonJS and AMD workflow.</p><p><code>export =</code>语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。</p><p>当使用<code>export =</code>导出模块时, 必须用 <code>import module = require(&quot;module&quot;)</code> 导入模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// z.ts</span></span><br><span class="line"><span class="keyword">let</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> = ZipCodeValidator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t.ts</span></span><br><span class="line"><span class="keyword">import</span> zip = <span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> zip();</span><br></pre></td></tr></table></figure><h3 id="6-2-code-generation-for-Modules"><a href="#6-2-code-generation-for-Modules" class="headerlink" title="6.2 code generation for Modules"></a>6.2 code generation for Modules</h3><p>typescript 会依据不同的模块规则，生成不同的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleModule.ts</span></span><br><span class="line"><span class="keyword">import</span> m = <span class="built_in">require</span>(<span class="string">"mod"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = m.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>AMD / RequireJS SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"./mod"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, mod_1</span>) </span>&#123;</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>CommonJS / Node SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>UMD SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> v = factory(<span class="built_in">require</span>, exports);</span><br><span class="line">  <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">module</span>.exports = v;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">  define([<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"./mod"</span>], factory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>System SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.register([<span class="string">"./mod"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">exports_1</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> mod_1;</span><br><span class="line"><span class="keyword">var</span> t;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  setters: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">mod_1_1</span>) </span>&#123;</span><br><span class="line">      mod_1 = mod_1_1;</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    exports_1(<span class="string">"t"</span>, (t = mod_1.something + <span class="number">1</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Native ECMAScript 2015 modules SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">"./mod"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> t = something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="6-3-可选模块加载和其他高级加载方案"><a href="#6-3-可选模块加载和其他高级加载方案" class="headerlink" title="6.3 可选模块加载和其他高级加载方案"></a>6.3 可选模块加载和其他高级加载方案</h3><p>为了保持类型安全，我们可以使用typeof关键字。当在类型位置中使用typeof关键字时，将产生值的类型，在这种情况下为模块的类型。</p><h4 id="6-3-1-Dynamic-Module-Loading-in-Node-js"><a href="#6-3-1-Dynamic-Module-Loading-in-Node-js" class="headerlink" title="6.3.1 Dynamic Module Loading in Node.js"></a>6.3.1 Dynamic Module Loading in Node.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line"><span class="keyword">let</span> ZipCodeValidator: <span class="keyword">typeof</span> Zip = <span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line"><span class="keyword">if</span> (validator.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-2-Sample-Dynamic-Module-Loading-in-require-js"><a href="#6-3-2-Sample-Dynamic-Module-Loading-in-require-js" class="headerlink" title="6.3.2 Sample: Dynamic Module Loading in require.js"></a>6.3.2 Sample: Dynamic Module Loading in require.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">moduleNames: <span class="built_in">string</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">onLoad: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Zip <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"./ZipCodeValidator"</span>], <span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (validator.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-3-Sample-Dynamic-Module-Loading-in-System-js"><a href="#6-3-3-Sample-Dynamic-Module-Loading-in-System-js" class="headerlink" title="6.3.3 Sample: Dynamic Module Loading in System.js"></a>6.3.3 Sample: Dynamic Module Loading in System.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> System: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">System.import(<span class="string">"./ZipCodeValidator"</span>).then(<span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (x.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-使用其他js库"><a href="#6-4-使用其他js库" class="headerlink" title="6.4 使用其他js库"></a>6.4 使用其他js库</h3><p>为了描述非ts编写的库，我们需要声明该库公开的API；通常将这些声明定义在<code>.d.ts</code>文件中，就类似c/c++程序中的 <code>.h</code>文件；</p><p>Ts程序在开发过程中，会不可避免的引用到第三方js库，但是无法使用Typescript诸如类型检查等特性功能，为了解决这个问题，需要将这些库的函数和方法去掉后只保留导出类型声明，而产生一个描述js库和模块信息的声明文件，通过引用这个声明文件，就可以借用TS的各种特性来使用库文件；</p><h4 id="6-4-1-声明文件的存放方式"><a href="#6-4-1-声明文件的存放方式" class="headerlink" title="6.4.1 声明文件的存放方式"></a>6.4.1 声明文件的存放方式</h4><ol><li>在tsconfig include 字段包含 的范围内编写.d.ts，都能被自动识别</li><li>在x.js 相同目录创建同名声明文件x.d.ts，这样也会被自动识别；</li><li>node_modules/@types/ 下存放的各个第三方模块声明文件，自己编写的声明文件不要放这里；</li><li>作为npm模块发布时，声明文件可捆绑发布，需在package.json中指明“types”：”./types/index.d.ts”</li></ol><h4 id="6-4-1-无配置使用js"><a href="#6-4-1-无配置使用js" class="headerlink" title="6.4.1 无配置使用js"></a>6.4.1 无配置使用js</h4><p>在tsconfig.json中关闭”noImplicitAny”: false时，可直接在Ts中引用js的库，所有的引入都会被默认为any类型。此方法不推荐使用；</p><h4 id="6-4-2-Ts中引入js"><a href="#6-4-2-Ts中引入js" class="headerlink" title="6.4.2 Ts中引入js"></a>6.4.2 Ts中引入js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hello = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;hello&#125; <span class="keyword">from</span> <span class="string">'./hello'</span></span><br><span class="line"><span class="comment">// 无法找到模块'./hello'的声明文件</span></span><br><span class="line"><span class="comment">// 这就告诉用户，需要为hello.js编写声明文件了；</span></span><br><span class="line"><span class="comment">// hello.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">const</span> hello: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>  上面的例子稍微简单一些，下面写一个相对复杂点的demo</p><p><strong>tsconfig.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist/"</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>],</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"./src/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-src</span><br><span class="line">-swap</span><br><span class="line">-index.js</span><br><span class="line">-index.d.ts</span><br><span class="line">-index.ts</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap/index.js</span></span><br><span class="line"><span class="keyword">const</span> NAME = <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line">  temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;NAME&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  swap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> swap &#123; <span class="comment">// ts 编译运行时的 swap命名空间, 增加命名空间放置被全局污染。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T, b: T</span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> swap; <span class="comment">// 注意这里要导出，有export/import 语句的文件 才是模块</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> swap <span class="keyword">from</span> <span class="string">"./swap"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"3"</span>,</span><br><span class="line">  b = <span class="string">"4"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(swap.swap&lt;<span class="built_in">string</span>&gt;(a, b));</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure><h4 id="6-4-3-declare"><a href="#6-4-3-declare" class="headerlink" title="6.4.3 declare"></a>6.4.3 declare</h4><p><strong>var和declare的区别</strong></p><p>​        var表示创建一个新变量，declare用来告诉ts编译器这个变量已经在别处被创建过了， 如果你用declare，什么都不会添加到生成的js中， 它只是对编译器一个简单的提示；</p><p>​        举例说明，如果你引入的第三方js文件中有 <code>var externalModule</code>，你需要定义<code>declare var externalModule</code> 去提示ts编译器，externalModule这个变量已经被创建了；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">class</span> Action &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个class  Action的具体实现应该在其他什么地方，可以在个 .js文件里面</p><p>​        </p><h4 id="6-4-4-Ts中导入-png-json等"><a href="#6-4-4-Ts中导入-png-json等" class="headerlink" title="6.4.4 Ts中导入.png .json等"></a>6.4.4 Ts中导入.png .json等</h4><p>导入.png .json 等文件时，同样也需要去编写声明文件；</p><p>提供一种方式，可以创建一个声明文件 <code>src/@types/definition.d.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.png' &#123;</span><br><span class="line"><span class="keyword">const</span> value: <span class="built_in">string</span></span><br><span class="line"><span class="keyword">export</span> = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="comment">// 之后在TS中导入也不会有问题</span></span><br><span class="line"><span class="keyword">import</span> avatar <span class="keyword">from</span> <span class="string">'./img/avatar.png'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> avatar = <span class="built_in">require</span>(<span class="string">'./img/avatar.png'</span>)</span><br><span class="line">  <span class="comment">// 可能会提示 require 未定义，有两种方式：</span></span><br><span class="line">  <span class="comment">//  1. 自行声明：declare const require: any</span></span><br><span class="line">  <span class="comment">//  2. yarn add -D @types/node</span></span><br></pre></td></tr></table></figure><h4 id="6-4-5-第三方模块没有可用的声明文件"><a href="#6-4-5-第三方模块没有可用的声明文件" class="headerlink" title="6.4.5  第三方模块没有可用的声明文件"></a>6.4.5  第三方模块没有可用的声明文件</h4><p>有些模块没有对应的声明文件时，需要我们自己编写声明文件，以rc-form为例子，需要在<code>src/@types/defintion.d.ts</code>中添加声明代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defintion.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "rc-form" &#123;</span><br><span class="line"><span class="comment">// 再次简单进行类型声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createForm: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createFormField: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formShape: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-6-webpack-别名-aliases"><a href="#6-4-6-webpack-别名-aliases" class="headerlink" title="6.4.6  webpack  别名  aliases"></a>6.4.6  webpack  别名  aliases</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">aliases: &#123;</span><br><span class="line">  <span class="comment">// 公共的工具类、容器和组件</span></span><br><span class="line">  utils: path.resolve(<span class="string">'../utils'</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;ua&#125; <span class="keyword">from</span> <span class="string">'utils/broswer'</span></span><br><span class="line"><span class="comment">// cannot find module 'utils/browser'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要在tsconfig.json 添加baseUrl 和 paths</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 添加配置</span></span><br><span class="line">  <span class="string">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">  <span class="string">"paths"</span>: &#123;</span><br><span class="line">    <span class="string">"utils/*"</span>: [<span class="string">"../utils/*"</span>],</span><br><span class="line">    <span class="string">"components/*"</span>: [<span class="string">"../components/*"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"include"</span>: [<span class="string">"./src/*"</span>, <span class="string">"./src/**/*"</span>],</span><br><span class="line"><span class="string">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-7-类型Window上不存在属性“X”"><a href="#6-4-7-类型Window上不存在属性“X”" class="headerlink" title="6.4.7 类型Window上不存在属性“X”"></a>6.4.7 类型Window上不存在属性“X”</h4><p>需要对window进行扩展，直接在<code>src/@types/definition.d.ts</code>中扩展</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">x: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(Window.x) <span class="comment">// success</span></span><br></pre></td></tr></table></figure><ul><li>注意全局声明和局部声明</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;IPerson&#125; <span class="keyword">from</span> <span class="string">'./intefaces/index.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">X: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.X); <span class="comment">// fail: 类型“Window"上不存在属性“X”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决思路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;IPerson&#125; <span class="keyword">from</span> <span class="string">'./intefaces/index.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="keyword">interface</span> Window &#123;</span><br><span class="line">    X: <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.X) <span class="comment">// success </span></span><br><span class="line"><span class="comment">// 原因在于当一个 .ts文件加入import/export 语句的时候，该文件会变为一个模块；因为这个模块中的声明也会变为局部声明； 因此需要加到global的域上</span></span><br></pre></td></tr></table></figure><h3 id="6-5-Ambient-Modules"><a href="#6-5-Ambient-Modules" class="headerlink" title="6.5 Ambient Modules"></a>6.5 Ambient Modules</h3><p>在nodejs中，很多任务的完成都需要引入一个或多个模块，我们可以给每个模块在他们的根目录建立一个.d.ts文件用来声明类型，但合并这些声明到一个大的.d.ts文件往往更方便一些。使用module关键字和 引号名 。这些引号名的名称将在以后的导入中使用；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "url" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Url &#123;</span><br><span class="line">  protocol?: <span class="built_in">string</span>;</span><br><span class="line">  hostname?: <span class="built_in">string</span>;</span><br><span class="line">  pathname?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  urlStr: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  parseQueryString?,</span></span></span><br><span class="line"><span class="function"><span class="params">  slashesDenoteHost?</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Url</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "path" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> sep: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we can <code>/// &lt;reference&gt;</code> <code>node.d.ts</code> and then load the modules using <code>import url = require(&quot;url&quot;);</code> or <code>import * as URL from &quot;url&quot;</code>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="node.d.ts"/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> URL <span class="keyword">from</span> <span class="string">"url"</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = URL.parse(<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure><h4 id="6-5-1-不想为第三方js写声明"><a href="#6-5-1-不想为第三方js写声明" class="headerlink" title="6.5.1 不想为第三方js写声明"></a>6.5.1 不想为第三方js写声明</h4><p>If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declarations.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "hot-new-<span class="keyword">module</span>";</span><br><span class="line"></span><br><span class="line">// All imports from shorthand <span class="keyword">module</span> will have the any type;</span><br><span class="line">import x, &#123;y&#125; <span class="keyword">from</span> <span class="string">"hot-new-module"</span>;</span><br><span class="line">x(y);</span><br></pre></td></tr></table></figure><h4 id="6-5-2-通配符"><a href="#6-5-2-通配符" class="headerlink" title="6.5.2 通配符"></a>6.5.2 通配符</h4><p>一些模块加载器（例如SystemJS和AMD）允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declareations.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*!text" &#123;</span><br><span class="line"><span class="keyword">const</span> content: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Some do it the other way around.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "json!*" &#123;</span><br><span class="line"><span class="keyword">const</span> value: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now you can import things that match "*!text" or "json!*".</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">"./xyz.txt!text"</span>;</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">"json!http://example.com/data.json"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data, fileContent);</span><br></pre></td></tr></table></figure><h4 id="6-5-3-UMD-modules"><a href="#6-5-3-UMD-modules" class="headerlink" title="6.5.3 UMD modules"></a>6.5.3 UMD modules</h4><p>一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为UMD模块。可以通过导入或全局变量访问这些库。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math-lib.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPreme</span>(<span class="params">x: <span class="built_in">number</span></span>):<span class="title">boolean</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> mathLib;</span><br></pre></td></tr></table></figure><p>The library can then be used as an import within modules:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">"math-lib"</span>;</span><br><span class="line">isPrime(<span class="number">2</span>);</span><br><span class="line">mathLib.isPrime(<span class="number">2</span>); <span class="comment">// ERROR: can't use the global definition from inside a module</span></span><br></pre></td></tr></table></figure><p>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathLib.isPrime(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="6-7-Guidance-for-structuring-modules"><a href="#6-7-Guidance-for-structuring-modules" class="headerlink" title="6.7 Guidance for structuring modules"></a>6.7 Guidance for structuring modules</h3><h4 id="6-7-1-Export-as-close-to-top-level-as-possible"><a href="#6-7-1-Export-as-close-to-top-level-as-possible" class="headerlink" title="6.7.1 Export as close to top-level as possible"></a>6.7.1 Export as close to top-level as possible</h4><p>如果要导入大量内容，请使用名称空间导入模式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLargeModule.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Dog &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Cat &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Tree &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Flower &#123; ... &#125;</span><br><span class="line"><span class="comment">// Consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myLargeModule <span class="keyword">from</span> <span class="string">"./MyLargeModule.ts"</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure><h4 id="6-7-2-Re-export-to-extend"><a href="#6-7-2-Re-export-to-extend" class="headerlink" title="6.7.2 Re-export to extend"></a>6.7.2 Re-export to extend</h4><p>通常，您将需要扩展模块上的功能。常见的JS模式是使用扩展来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样合并。推荐的解决方案是不要变更原始对象，而是导出提供新功能的新对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Calculator &#123;</span><br><span class="line"><span class="keyword">private</span> current = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> operator: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 只能做10以内的计算；</span></span><br><span class="line">  <span class="keyword">if</span> (digit &gt;= <span class="string">"0"</span> &amp;&amp; digit &lt;= <span class="string">"9"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue * <span class="number">10</span> + (digit.charCodeAt(<span class="number">0</span>) - <span class="string">"0"</span>.charCodeAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processOperator(operator: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>].indexOf(operator) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> operator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> evaluateOperator(</span><br><span class="line">  operator: <span class="built_in">string</span>,</span><br><span class="line">  left: <span class="built_in">number</span>,</span><br><span class="line">  right: <span class="built_in">number</span></span><br><span class="line">): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>.operator) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">      <span class="keyword">return</span> left - right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">      <span class="keyword">return</span> left * right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">      <span class="keyword">return</span> left / right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> evaluate() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.operator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">this</span>.evaluateOperator(</span><br><span class="line">      <span class="keyword">this</span>.operator,</span><br><span class="line">      <span class="keyword">this</span>.memory,</span><br><span class="line">      <span class="keyword">this</span>.current</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">this</span>.current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.current = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> handleChar(char: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (char === <span class="string">"="</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.evaluate();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.processDigit(char, <span class="keyword">this</span>.current);</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">this</span>.processOperator(char);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.evaluate();</span><br><span class="line">        <span class="keyword">this</span>.operator = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Unsupported input: '<span class="subst">$&#123;char&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> getResult() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.memory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c: Calculator, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">  c.handleChar(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`result of '<span class="subst">$&#123;input&#125;</span>' is '<span class="subst">$&#123;c.getResult()&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">import</span> &#123;Calculator,  test&#125; <span class="keyword">from</span> <span class="string">'./ProgrammerCalculator'</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">"1+2*33/11="</span>);</span><br></pre></td></tr></table></figure><p><strong>新需求： 要求计算超过9的值</strong></p><p>这个时候不在原类上更改，而是在继承类上做新功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Calculator &#125; <span class="keyword">from</span> <span class="string">"./Calculator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ProgrammerCalculator <span class="keyword">extends</span> Calculator &#123;</span><br><span class="line"><span class="keyword">static</span> digits = [</span><br><span class="line">  <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"2"</span>,</span><br><span class="line">  <span class="string">"3"</span>,</span><br><span class="line">  <span class="string">"4"</span>,</span><br><span class="line">  <span class="string">"5"</span>,</span><br><span class="line">  <span class="string">"6"</span>,</span><br><span class="line">  <span class="string">"7"</span>,</span><br><span class="line">  <span class="string">"8"</span>,</span><br><span class="line">  <span class="string">"9"</span>,</span><br><span class="line">  <span class="string">"A"</span>,</span><br><span class="line">  <span class="string">"B"</span>,</span><br><span class="line">  <span class="string">"C"</span>,</span><br><span class="line">  <span class="string">"D"</span>,</span><br><span class="line">  <span class="string">"E"</span>,</span><br><span class="line">  <span class="string">"F"</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> base: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">const</span> maxBase = ProgrammerCalculator.digits.length;</span><br><span class="line">  <span class="keyword">if</span> (base &lt;= <span class="number">0</span> || base &gt; maxBase) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`base has to be within 0 to <span class="subst">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      currentValue * <span class="keyword">this</span>.base + ProgrammerCalculator.digits.indexOf(digit)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export the new extended calculator as Calculator</span></span><br><span class="line"><span class="keyword">export</span> &#123; ProgrammerCalculator <span class="keyword">as</span> Calculator &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also, export the helper function</span></span><br><span class="line"><span class="keyword">export</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">"./Calculator"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Calculator, test &#125; <span class="keyword">from</span> <span class="string">"./ProgrammerCalculator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">"001+010="</span>); <span class="comment">// prints 3</span></span><br></pre></td></tr></table></figure><h4 id="6-7-3-Do-not-use-namespaces-in-modules"><a href="#6-7-3-Do-not-use-namespaces-in-modules" class="headerlink" title="6.7.3  Do not use namespaces in modules"></a>6.7.3  Do not use namespaces in modules</h4><p>当首次转向基于模块的组织时，一种普遍的趋势是将导出包装在命名空间的附加层中。模块具有自己的作用域，并且从模块外部仅可见导出的声明。考虑到这一点，名称空间在使用模块时几乎没有价值。</p><h2 id="7-Namespaces"><a href="#7-Namespaces" class="headerlink" title="7. Namespaces"></a>7. Namespaces</h2><p>在TypeScript 1.5中，模块命名法则已更改。 “Internal modules”现在是“namespaces”。为了与ECMAScript 2015的术语保持一致，“External modules”现在简称为“modules”（module X {}  等同于 namespaceX {}）</p><p>在声明内部模块时，在使用module关键字的任何地方，可以并且应该改用namespace关键字。</p><h3 id="7-1-多个相似对象添加namespaces"><a href="#7-1-多个相似对象添加namespaces" class="headerlink" title="7.1 多个相似对象添加namespaces"></a>7.1 多个相似对象添加namespaces</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      validators[name].isAcceptable(s) ? <span class="string">"matches"</span> : <span class="string">"does not match"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Splitting-Across-Files"><a href="#7-2-Splitting-Across-Files" class="headerlink" title="7.2  Splitting Across Files"></a>7.2  Splitting Across Files</h3><p>​    随着应用程序的扩展，我们希望将代码拆分为多个文件，以使其易于维护;</p><h5 id="7-2-1-Multi-file-namespaces"><a href="#7-2-1-Multi-file-namespaces" class="headerlink" title="7.2.1 Multi-file namespaces"></a>7.2.1 Multi-file namespaces</h5><p>  我们将Validation名称空间拆分为多个文件。即使文件是分开的，它们每个都可以贡献相同的名称空间，并且可以像将它们全部定义在一个位置一样使用。由于文件之间存在依赖性，因此我们将添加参考标记，以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。</p><ul><li>Validation.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LettersOnlyValidator.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ZipCodeValidator.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Test.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="LettersOnlyValidator.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="ZipCodeValidator.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      validators[name].isAcceptable(s) ? <span class="string">"matches"</span> : <span class="string">"does not match"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦涉及到多个文件，需要确保所有已编译的代码都已加载，有两种方法可以做到这点</p><h6 id="7-2-1-1-级联输出"><a href="#7-2-1-1-级联输出" class="headerlink" title="7.2.1.1 级联输出"></a>7.2.1.1 级联输出</h6><p>使用 –outFile，将所有输入文件编译为单个js输出文件</p><p><code>tsc --outFile sample.js Test.ts</code></p><h6 id="7-2-1-2-自动排序输出"><a href="#7-2-1-2-自动排序输出" class="headerlink" title="7.2.1.2 自动排序输出"></a>7.2.1.2 自动排序输出</h6><p>编译器将根据文件中存在的参考标记自动排序输出文件。您还可以分别指定每个文件：</p><p><code>tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</code></p><h6 id="7-2-1-3-单个编译"><a href="#7-2-1-3-单个编译" class="headerlink" title="7.2.1.3 单个编译"></a>7.2.1.3 单个编译</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc test.ts</span><br><span class="line">tes Validation.ts</span><br></pre></td></tr></table></figure><h3 id="7-3-Aliases"><a href="#7-3-Aliases" class="headerlink" title="7.3 Aliases"></a>7.3 Aliases</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Square &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = Shapes.Polygons;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.Square(); </span><br><span class="line"><span class="comment">// Same as 'new Shapes.Polygons.Square()'</span></span><br></pre></td></tr></table></figure><h4 id="7-3-1-使用第三方JavaScript库"><a href="#7-3-1-使用第三方JavaScript库" class="headerlink" title="7.3.1 使用第三方JavaScript库"></a>7.3.1 使用第三方JavaScript库</h4><p>为了描述不是用TypeScript编写的库的形状，我们需要声明该库公开的API。因为大多数JavaScript库仅公开一些顶级对象，所以namespaces是表示它们的好方法。</p><p>D3在名为d3的全局对象中定义其功能。由于此库是通过script标签加载的，因此可以使用命名空间来声明它的shape。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> namspace D3 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Selectors &#123;</span><br><span class="line">  select: &#123;</span><br><span class="line">    (selector: <span class="built_in">string</span>): Selection;</span><br><span class="line">    (element: EventTarget): Selection;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Event &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Base <span class="keyword">extends</span> Selectors &#123;</span><br><span class="line">  event: Event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> d3: D3.Base;</span><br></pre></td></tr></table></figure><h2 id="8-三斜杠指令"><a href="#8-三斜杠指令" class="headerlink" title="8. 三斜杠指令"></a>8. 三斜杠指令</h2><p>三斜杠指令是包含单个XML标签的单行注释。注释的内容用作编译器指令。</p><p>三斜杠指令仅在其包含文件的顶部有效。三斜杠指令只能在单行或多行注释之前，包括其他三斜杠指令。如果在声明或声明之后遇到它们，则将它们视为常规的单行注释，并且没有特殊含义。</p><ul><li><code>/// &lt;reference path=&quot;./lib/index.d.ts&quot; /&gt;</code>：表示对一个文件的依赖。</li><li><code>/// &lt;reference types=&quot;jye&quot; /&gt;</code>：表示对一个库的依赖。</li></ul><p>三斜线的<code>path</code> &amp; <code>types</code>，和<code>es6</code>的<code>import</code>语义相似，同时<strong>三斜线指令必须放在文件的最顶端</strong>。例如，当我们的声明文件过于庞大，一般都会采用三斜线指令，将我们的声明文件拆分成若干个，然后由一个入口文件引入。</p><h3 id="8-1-文件之间的依赖声明"><a href="#8-1-文件之间的依赖声明" class="headerlink" title="8.1  文件之间的依赖声明"></a>8.1  文件之间的依赖声明</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path="..."/&gt;</span></span><br><span class="line"><span class="comment">///&lt;reference path="..."/&gt;   是这个group中最常见的，它用作文件之间依赖关系的声明；</span></span><br></pre></td></tr></table></figure><p>三斜杠指令指示编译器在编译过程中包括其他文件；</p><p>当使用 –out 或 –outFile时，它们还可以用作对输出进行排序的方法。预处理通过后，文件以与输入相同的顺序输出到目标文件位置。</p><h3 id="8-2-input-files-预处理"><a href="#8-2-input-files-预处理" class="headerlink" title="8.2  input files 预处理"></a>8.2  input files 预处理</h3><p>编译器对输入文件进行预处理，以解析所有三斜杠引用指令。在此过程中，其他文件将添加到编译过程中。</p><p>该过程从一组根文件开始；这些是在命令行或tsconfig.json文件的“files”列表中指定的文件名。这些根文件将按照指定的顺序进行预处理。在将文件添加到列表之前，必须先处理其中的所有三斜杠引用及其目标。按照在文件中出现的顺序，深度优先地解析三斜杠引用</p><p>A triple-slash reference path is resolved relative to the containing file, if unrooted.</p><h3 id="8-3-types"><a href="#8-3-types" class="headerlink" title="8.3 types"></a>8.3 types</h3><p><code>types=&quot;...&quot; 与 path=&quot;...&quot;</code> 类似，前者声明对包的依赖，后者声明对一个文件的依赖</p><p>这些程序包名称的解析过程与import语句中的模块名称解析过程相似。考虑三重斜杠引用类型指令的一种简单方法是将其作为声明包的导入。</p><p>在一个声明文件中包括 <code>types=&quot;node&quot;</code> 则该声明文件使用<code>@types/node/index.d.ts</code>中声明的名称，因此，此包需要与声明文件一起包含在编译中; </p><p>仅当您书写d.ts文件时，才使用这些指令；</p><p>对于编译期间生成的声明文件，编译器会自动添加<code>types=&quot;...&quot;</code>。当且仅当reslulting file使用 referenced package中 任何声明的时候，才会在生成的声明文件中添加 <code>types=&quot;...&quot;</code> ；</p><p>在 .ts 文件声明对 一个@types 包的依赖， 使用命令行 –types 或者 tsconfig.json中设置；</p><h3 id="8-4-lib"><a href="#8-4-lib" class="headerlink" title="8.4 lib"></a>8.4 lib</h3><p><code>lib=&quot;...&quot;</code> </p><p>此指令允许文件显式包括现有的内置lib文件。</p><p>例如，在编译中的一个文件中添加/// &lt;reference lib =“ es2017.string” /&gt;等效于使用–lib es2017.string进行编译。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference lib="es2017.string" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">"foo"</span>.padStart(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="9-Namespaces-and-Modules"><a href="#9-Namespaces-and-Modules" class="headerlink" title="9. Namespaces and Modules"></a>9. Namespaces and Modules</h2><h3 id="9-1-使用modules"><a href="#9-1-使用modules" class="headerlink" title="9.1 使用modules"></a>9.1 使用modules</h3><p>模块可以包含代码和声明</p><p>从es6开始，模块是语言的原生机制，新的项目，模块将是推荐的代码组织机制；</p><h3 id="9-2-使用namespaces"><a href="#9-2-使用namespaces" class="headerlink" title="9.2 使用namespaces"></a>9.2 使用namespaces</h3><p>命名空间是TypeScript特定的组织代码的方式。</p><p>命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。与模块不同，它们可以跨越多个文件，并且可以使用–outFile进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都作为script标记包含在HTML页面中。</p><p>就像所有全局命名空间污染一样，很难识别组件依赖性，尤其是在大型应用程序中。</p><h3 id="9-3-使用namespaces-和-modules-遇到的一些坑"><a href="#9-3-使用namespaces-和-modules-遇到的一些坑" class="headerlink" title="9.3 使用namespaces 和 modules 遇到的一些坑"></a>9.3 使用namespaces 和 modules 遇到的一些坑</h3><h4 id="9-3-1-不需要namespaces的时候"><a href="#9-3-1-不需要namespaces的时候" class="headerlink" title="9.3.1 不需要namespaces的时候"></a>9.3.1 不需要namespaces的时候</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `shapes.ts`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Square &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `shapeConsumer.ts`</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">"./shapes"</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.Shapes.Triangle(); <span class="comment">// shapes.Shapes?</span></span><br></pre></td></tr></table></figure><p>推荐的做法，当一个文件中定义了import/export 的时候，那么它就变成了一个模块。模块中，命名空间显然多此一举了</p><p><strong>推荐做法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Square &#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shapeConsumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">"./shapes"</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.Triangle();</span><br></pre></td></tr></table></figure><h4 id="9-3-2-reference-和import-的使用时机"><a href="#9-3-2-reference-和import-的使用时机" class="headerlink" title="9.3.2 reference 和import 的使用时机"></a>9.3.2 reference 和import 的使用时机</h4><p>一个常见的错误是尝试使用<code>/// reference ...</code>语法来引用模块文件，而不是使用<code>import</code>语句；</p><p>编译器如何 基于 <code>path of an import path(import X from &#39;xxx&#39;; import x = require(&#39;...&#39;))</code> 找到模块的类型信息；</p><p>编译器将尝试查找.ts，.tsx，然后找到具有适当路径的.d.ts。如果找不到特定的文件，然编译器会去找<code>ambient module declaration</code> 记得这些需要在 .d.ts 文件中声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myModules.d.ts</span></span><br><span class="line"><span class="comment">// In a .d.ts file or .ts file that is not a module:</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "SomeModule" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// myOtherModule.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference path="myModules.d.ts" /&gt;  记得添加依赖</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">"SomeModule"</span>; <span class="comment">// 这里并不是导入 文件名，而是模块名，因为 myModules.d.ts 不是一个模块；</span></span><br></pre></td></tr></table></figure><p><code>/// reference path=&quot;myModules.d.ts&quot;</code> 使我们能够找到包含环境模块声明的声明文件，This is how the <code>node.d.ts</code> file that several of the TypeScript samples use is consumed.</p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts generics</title>
      <link href="2021/01/20/ts-generics/"/>
      <url>2021/01/20/ts-generics/</url>
      
        <content type="html"><![CDATA[<h2 id="5-Generics"><a href="#5-Generics" class="headerlink" title="5. Generics"></a>5. Generics</h2><p>泛型，创建可重用组件的工具。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// Property 'length' does not exist on type 'T'.</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-泛型定义"><a href="#5-1-泛型定义" class="headerlink" title="5.1 泛型定义"></a>5.1 泛型定义</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">  &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity1: &#123; &lt;T&gt;(arg: T): T &#125; = identity;</span><br><span class="line"><span class="keyword">let</span> myIdentity2: GenericIdentityFn = identity;</span><br></pre></td></tr></table></figure><h3 id="5-2-泛型类"><a href="#5-2-泛型类" class="headerlink" title="5.2 泛型类"></a>5.2 泛型类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-泛型约束"><a href="#5-3-泛型约束" class="headerlink" title="5.3 泛型约束"></a>5.3 泛型约束</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-Using-Type-Parameters-in-Generic-Constraints"><a href="#5-3-1-Using-Type-Parameters-in-Generic-Constraints" class="headerlink" title="5.3.1 Using Type Parameters in Generic Constraints"></a>5.3.1 Using Type Parameters in Generic Constraints</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">"a"</span>);</span><br><span class="line">getProperty(x, <span class="string">"m"</span>);</span><br><span class="line"><span class="comment">// Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.</span></span><br></pre></td></tr></table></figure><h4 id="5-3-2-泛型类"><a href="#5-3-2-泛型类" class="headerlink" title="5.3.2 泛型类"></a>5.3.2 泛型类</h4><p>使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c: &#123; <span class="keyword">new</span> (): T &#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">  hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">  nametag: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  numLegs: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c: <span class="keyword">new</span> () =&gt; A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;</span><br><span class="line">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts doc</title>
      <link href="2021/01/19/ts-doc/"/>
      <url>2021/01/19/ts-doc/</url>
      
        <content type="html"><![CDATA[<h1 id="handbook"><a href="#handbook" class="headerlink" title="handbook"></a>handbook</h1><p><strong>A reader who completes the walkthrough should be able to:</strong></p><ul><li>Read and understand commonly-used TypeScript syntax and patterns</li><li>Explain the effects of important compiler options</li><li>Correctly predict type system behavior in most cases</li><li>Write a .d.ts declaration for a simple function, object, or class</li></ul><h2 id="1-basic-Types"><a href="#1-basic-Types" class="headerlink" title="1. basic Types"></a>1. basic Types</h2><p> 在TypeScript中，我们支持与JavaScript中期望的类型相同的类型，并添加了一个额外的枚举类型以帮助处理问题。</p><p>Boolean, Number, String, Array,Tuple,Enum,Unkown,Any,Void, Null and Undefined, Never, Object,</p><ul><li>Tuple</li></ul><p>元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对字符串和一个数字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">"hello"</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">"hello"</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><ul><li>Enum</li></ul><p>枚举是JavaScript标准数据类型集的一个有用补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays 'Green'</span></span><br><span class="line"><span class="built_in">console</span>.log(colorName);</span><br></pre></td></tr></table></figure><ul><li>Unknown</li></ul><p>我们可能需要描述编写应用程序时不知道的变量类型。这些值可能来自动态内容，例如来自用户-或者我们可能要有意接受我们API中的所有值。在这些情况下，我们希望提供一种类型，该类型告诉编译器和将来的读者此变量可以是任何变量，因此我们将其赋予未知类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: unknown = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, definitely a boolean</span></span><br><span class="line">notSure = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果您有一个类型未知的变量，则可以通过进行typeof检查，比较检查或更高级的类型防护来将其范围缩小到更具体的范围;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> maybe: unknown;</span><br><span class="line"><span class="comment">// 'maybe' could be a string, object, boolean, undefined, or other types</span></span><br><span class="line"><span class="keyword">const</span> aNumber: <span class="built_in">number</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'unknown' is not assignable to type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (maybe === <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TypeScript knows that maybe is a boolean now</span></span><br><span class="line">  <span class="keyword">const</span> aBoolean: <span class="built_in">boolean</span> = maybe;</span><br><span class="line">  <span class="comment">// So, it cannot be a string</span></span><br><span class="line">  <span class="keyword">const</span> aString: <span class="built_in">string</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'boolean' is not assignable to type 'string'.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> maybe === <span class="string">"string"</span>) &#123;</span><br><span class="line">  <span class="comment">// TypeScript knows that maybe is a string</span></span><br><span class="line">  <span class="keyword">const</span> aString: <span class="built_in">string</span> = maybe;</span><br><span class="line">  <span class="comment">// So, it cannot be a boolean</span></span><br><span class="line">  <span class="keyword">const</span> aBoolean: <span class="built_in">boolean</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'string' is not assignable to type 'boolean'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Any</li></ul><p>在某些情况下，并非所有类型信息都可用。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况，可能要选择退出类型检查。将这些值标记为any类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="comment">// OK, return value of 'getValue' is not checked</span></span><br><span class="line"><span class="keyword">const</span> str: <span class="built_in">string</span> = getValue(<span class="string">"myString"</span>);</span><br></pre></td></tr></table></figure><p>与 unknown 不同，any类型的变量使您可以访问任意属性，甚至是不存在的属性。这些属性包括函数，并且TypeScript不会检查它们的存在或类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> looselyTyped: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// OK, ifItExists might exist at runtime</span></span><br><span class="line">looselyTyped.ifItExists();</span><br><span class="line"><span class="comment">// OK, toFixed exists (but the compiler doesn't check)</span></span><br><span class="line">looselyTyped.toFixed();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strictlyTyped: unknown = <span class="number">4</span>;</span><br><span class="line">strictlyTyped.toFixed();</span><br><span class="line"><span class="comment">// Object is of type 'unknown'.</span></span><br></pre></td></tr></table></figure><ul><li>Void</li></ul><p>void有点像任何其他的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Null and Undefined</li></ul><p>在TypeScript中，undefined和null实际上实际上分别将其类型命名为undefined和null。就像void一样，它们本身并不是非常有用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>Never</li></ul><p>The <code>never</code> type is a subtype of, and assignable to, every type; however, <em>no</em> type is a subtype of, or assignable to, <code>never</code> (except <code>never</code> itself). Even <code>any</code> isn’t assignable to <code>never</code>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function returning never must not have a reachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred return type is never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function returning never must not have a reachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object</li></ul><p>object是代表非基本类型的类型，即不是数字，字符串，布尔值，bigint，symbol，null或undefined的任何类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With object type, APIs like Object.create can be better represented.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">create(&#123; prop: <span class="number">0</span> &#125;);</span><br><span class="line">create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//Argument of type '42' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="string">"string"</span>);</span><br><span class="line"><span class="comment">//Argument of type '"string"' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//Argument of type 'false' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">//Argument of type 'undefined' is not assignable to parameter of type 'object | null'.</span></span><br></pre></td></tr></table></figure><ul><li>Type assertions</li></ul><p>类型断言是一种告诉编译器“相信我，我知道我在做什么”的方法。类型断言就像其他语言中的类型转换一样，但是它不执行数据的特殊检查或重构。它对运行时没有影响，仅由编译器使用。 TypeScript假定您（程序员）已经执行了所需的任何特殊检查。</p><p>类型断言的两种形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型1: as 语句</span></span><br><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"><span class="comment">// 类型2: 尖括号</span></span><br><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><p>jsx中无法使用 类型2；</p><ul><li>About Number, String, Boolean, Symbol and Object</li></ul><p>可能会认为数字，字符串，布尔值，符号或对象类型与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎永远不应将其用作类型。</p><h2 id="2-interface"><a href="#2-interface" class="headerlink" title="2. interface"></a>2. interface</h2><h3 id="2-1-readonly"><a href="#2-1-readonly" class="headerlink" title="2.1 readonly"></a>2.1 readonly</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript具有与Array <T>相同的ReadonlyArray <T>类型，并且删除了所有变异方法，因此可以确保创建后不更改数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Index signature in type 'readonly number[]' only permits reading.</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Property 'push' does not exist on type 'readonly number[]'.</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Cannot assign to 'length' because it is a read-only property.</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.</span></span><br></pre></td></tr></table></figure><p>在代码片段的最后一行，您可以看到，即使将整个ReadonlyArray分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><ul><li>ReadOnly or const</li></ul><p>记住是使用只读还是const的最简单方法是询问是否在变量或属性上使用它。变量使用const，而属性使用只读。</p><h3 id="2-2-Optional"><a href="#2-2-Optional" class="headerlink" title="2.2 Optional"></a>2.2 Optional</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Excess-Property-Checks"><a href="#2-3-Excess-Property-Checks" class="headerlink" title="2.3 Excess Property Checks"></a>2.3 Excess Property Checks</h3><p>但是，TypeScript认为此代码中可能存在错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行过多的属性检查。如果对象文字具有“目标类型”所没有的任何属性，则会出现错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    color: config.color || <span class="string">"red"</span>,</span><br><span class="line">    area: config.width ? config.width * config.width : <span class="number">20</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="comment">//Argument of type '&#123; colour: string; width: number; &#125;' is not assignable to parameter of type 'SquareConfig'.</span></span><br><span class="line"> <span class="comment">// Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?</span></span><br></pre></td></tr></table></figure><ul><li>解决方案</li></ul><ol><li>解决这些检查实际上非常简单。最简单的方法是只使用类型断言：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySquare = createSquare(&#123;width: <span class="number">100</span>, opacity: <span class="number">0.5</span>&#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure><ol start="2"><li>如果对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mySquare = createSquare(&#123;width: <span class="number">100</span>, opacity: <span class="number">0.5</span>&#125;);</span><br><span class="line"><span class="comment">// 只要您在squareOptions和SquareConfig之间具有一个公共属性，上述变通办法就会起作用。但是，如果变量没有任何公共对象属性，它将失败。</span></span><br><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">"red"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br><span class="line"><span class="comment">// Type '&#123; colour: string; &#125;' has no properties in common with type 'SquareConfig'.</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Function-Types"><a href="#2-4-Function-Types" class="headerlink" title="2.4 Function Types"></a>2.4 Function Types</h3><p>为了描述带有接口的函数类型，我们给接口一个调用签名。这就像只声明参数列表和返回类型的函数声明。参数列表中的每个参数都需要名称和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch2: SearchFunc;</span><br><span class="line"><span class="comment">// 参数不定义string，ts会自动推断</span></span><br><span class="line">mySearch2 = <span class="function"><span class="keyword">function</span> (<span class="params">src, sub</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">src, sub</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回值需要遵守interface</span></span><br><span class="line"><span class="comment">//Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.</span></span><br><span class="line"><span class="comment">//  Type 'string' is not assignable to type 'boolean'.</span></span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"string"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-5-Indexable-Types"><a href="#2-5-Indexable-Types" class="headerlink" title="2.5 Indexable Types"></a>2.5 Indexable Types</h3><p>可索引类型具有索引签名，该签名描述了可用于索引对象的类型以及建立索引时对应的返回类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为在用数字索引时，JavaScript实际上会在将其索引到对象之前将其转换为字符串。这意味着使用100（一个数字）进行索引与使用“ 100”（一个字符串）进行索引是同一回事，因此两者必须保持一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: indexing with a numeric string might get you a completely separate type of Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">  [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">Numeric index <span class="keyword">type</span> <span class="string">'Animal'</span> is not assignable to <span class="built_in">string</span> index <span class="keyword">type</span> <span class="string">'Dog'</span>.</span><br><span class="line">  [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管字符串索引签名是描述“字典”模式的强大方法，但它们还强制所有属性与其返回类型匹配。这是因为字符串索引声明obj.property也可以作为obj [“ property”]使用。在以下示例中，名称的类型与字符串索引的类型不匹配，并且类型检查器给出错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>; <span class="comment">// ok, length is a number</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// error, the type of 'name' is not a subtype of the indexer</span></span><br><span class="line"><span class="comment">// Property 'name' of type 'string' is not assignable to string index type 'number'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果索引签名是属性类型的并集，则可以接受不同类型的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberOrStringDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span> | <span class="built_in">string</span>; <span class="comment">// 属性类型</span></span><br><span class="line">  length: <span class="built_in">number</span>; <span class="comment">// ok, length is a number</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// ok, name is a string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，您可以将索引签名设为只读，以防止分配给它们的索引：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">  readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">"Mallory"</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">// Index signature in type 'ReadonlyStringArray' only permits reading.</span></span><br></pre></td></tr></table></figure><h3 id="2-6-Class-Types"><a href="#2-6-Class-Types" class="headerlink" title="2.6 Class Types"></a>2.6 Class Types</h3><h4 id="2-6-1-Implement"><a href="#2-6-1-Implement" class="headerlink" title="2.6.1 Implement"></a>2.6.1 Implement</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为当类实现接口时，仅检查该类的实例侧。由于构造函数位于静态端，因此它不包含在此检查中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">  <span class="comment">// Class 'Clock' incorrectly implements interface 'ClockConstructor'.</span></span><br><span class="line"> <span class="comment">//  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.</span></span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> Clock(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>需要直接使用类的静态方面。在此示例中，我们定义了两个接口，用于构造函数的ClockConstructor和用于实例方法的ClockInterface。然后，为方便起见，我们定义了一个构造函数createClock，该函数创建传递给它的类型的实例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: ClockConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">  hour: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  minute: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure><p>另一种简单的方法是使用类表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Clock: ClockConstructor = <span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clock = <span class="keyword">new</span> Clock(<span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line">clock.tick();</span><br></pre></td></tr></table></figure><h3 id="2-7-Extending-Interfaces"><a href="#2-7-Extending-Interfaces" class="headerlink" title="2.7 Extending Interfaces"></a>2.7 Extending Interfaces</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h3 id="2-8-Hybrid-Types"><a href="#2-8-Hybrid-Types" class="headerlink" title="2.8 Hybrid Types"></a>2.8 Hybrid Types</h3><p>an object that acts as both a function and an object, with additional properties:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125; <span class="keyword">as</span> Counter;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><p>与第三方JavaScript交互时，您可能需要使用上述模式来完全描述类型的形状</p><h3 id="2-9-Interfaces-Extending-Classes"><a href="#2-9-Interfaces-Extending-Classes" class="headerlink" title="2.9 Interfaces Extending Classes"></a>2.9 Interfaces Extending Classes</h3><p>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</p><p>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ImageControl <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line"><span class="comment">//Class 'ImageControl' incorrectly implements interface 'SelectableControl'.</span></span><br><span class="line"> <span class="comment">// Types have separate declarations of a private property 'state'.</span></span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        In the above example, <code>SelectableControl</code> contains all of the members of <code>Control</code>, including the private <code>state</code> property. Since <code>state</code> is a private member it is only possible for descendants of <code>Control</code> to implement <code>SelectableControl</code>. This is because only descendants of <code>Control</code> will have a <code>state</code> private member that originates in the same declaration, which is a requirement for private members to be compatible.</p><p>​        Within the <code>Control</code> class it is possible to access the <code>state</code> private member through an instance of <code>SelectableControl</code>. Effectively, a <code>SelectableControl</code> acts like a <code>Control</code> that is known to have a <code>select</code> method. The <code>Button</code> and <code>TextBox</code> classes are subtypes of <code>SelectableControl</code> (because they both inherit from <code>Control</code> and have a <code>select</code> method). The <code>ImageControl</code> class has it’s own <code>state</code> private member rather than extending <code>Control</code>, so it cannot implement <code>SelectableControl</code>.</p><h2 id="3-Functions"><a href="#3-Functions" class="headerlink" title="3. Functions"></a>3. Functions</h2><p>在TypeScript中，尽管有类，名称空间和模块，但是函数仍然在描述操作方式中起着关键作用。 TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。</p><h3 id="3-1-this"><a href="#3-1-this" class="headerlink" title="3.1 this"></a>3.1 this</h3><p>Learning how to use <code>this</code> in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use <code>this</code> and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of <code>this</code> with a couple of techniques. If you need to learn how <code>this</code> works in JavaScript, though, first read Yehuda Katz’s <a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">Understanding JavaScript Function Invocation and “this”</a>. Yehuda’s article explains the inner workings of <code>this</code> very well, so we’ll just cover the basics here.</p><p><strong><code>this</code> and arrow functions</strong></p><p>In JavaScript, <code>this</code> is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</p><p>Let’s look at an example:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Notice that <code>createCardPicker</code> is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the <code>this</code> being used in the function created by <code>createCardPicker</code> will be set to <code>window</code> instead of our <code>deck</code> object. That’s because we call <code>cardPicker()</code> on its own. A top-level non-method syntax call like this will use <code>window</code> for <code>this</code>. (Note: under strict mode, <code>this</code> will be <code>undefined</code> rather than <code>window</code>).</p><p>We can fix this by making sure the function is bound to the correct <code>this</code> before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original <code>deck</code> object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the <code>this</code> where the function is created rather than where it is invoked:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture 'this' right here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Even better, TypeScript will warn you when you make this mistake if you pass the <code>--noImplicitThis</code> flag to the compiler. It will point out that <code>this</code> in <code>this.suits[pickedSuit]</code> is of type <code>any</code>.</p><p><strong><code>this</code> parameters</strong></p><p>Unfortunately, the type of <code>this.suits[pickedSuit]</code> is still <code>any</code>. That’s because <code>this</code> comes from the function expression inside the object literal. To fix this, you can provide an explicit <code>this</code> parameter. <code>this</code> parameters are fake parameters that come first in the parameter list of a function:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// make sure `this` is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s add a couple of interfaces to our example above, <code>Card</code> and <code>Deck</code>, to make the types clearer and easier to reuse:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">  suit: <span class="built_in">string</span>;</span><br><span class="line">  card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">  suits: <span class="built_in">string</span>[];</span><br><span class="line">  cards: <span class="built_in">number</span>[];</span><br><span class="line">  createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Now TypeScript knows that <code>createCardPicker</code> expects to be called on a <code>Deck</code> object. That means that <code>this</code> is of type <code>Deck</code> now, not <code>any</code>, so <code>--noImplicitThis</code> will not cause any errors.</p><p><strong><code>this</code> parameters in callbacks</strong></p><p>You can also run into errors with <code>this</code> in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, <code>this</code> will be <code>undefined</code>. With some work you can use <code>this</code> parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">  addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type. Second, annotate your calling code with <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickBad(<span class="keyword">this</span>: Handler, e: Event) &#123;</span><br><span class="line">    <span class="comment">// oops, used `this` here. using this callback would crash at runtime</span></span><br><span class="line">    <span class="keyword">this</span>.info = e.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'.</span></span><br><span class="line">  <span class="comment">//The 'this' types of each signature are incompatible.</span></span><br><span class="line">   <span class="comment">// Type 'void' is not assignable to type 'Handler'.Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'.</span></span><br><span class="line"> <span class="comment">// The 'this' types of each signature are incompatible.</span></span><br><span class="line"> <span class="comment">//   Type 'void' is not assignable to type 'Handler'.</span></span><br></pre></td></tr></table></figure><p>With <code>this</code> annotated, you make it explicit that <code>onClickBad</code> must be called on an instance of <code>Handler</code>. Then TypeScript will detect that <code>addClickListener</code> requires a function that has <code>this: void</code>. To fix the error, change the type of <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickGood(<span class="keyword">this</span>: <span class="built_in">void</span>, e: Event) &#123;</span><br><span class="line">    <span class="comment">// can't use `this` here because it's of type void!</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"clicked!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickGood);</span><br></pre></td></tr></table></figure><p>Because <code>onClickGood</code> specifies its <code>this</code> type as <code>void</code>, it is legal to pass to <code>addClickListener</code>. Of course, this also means that it can’t use <code>this.info</code>. If you want both then you’ll have to use an arrow function:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.info = e.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This works because arrow functions use the outer <code>this</code>, so you can always pass them to something that expects <code>this: void</code>. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler.</p><h3 id="3-2-Overloads"><a href="#3-2-Overloads" class="headerlink" title="3.2 Overloads"></a>3.2 Overloads</h3><p>JavaScript本质上是一种非常动态的语言。一个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">  <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">    <span class="keyword">return</span> pickedCard;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure><h2 id="4-Classes"><a href="#4-Classes" class="headerlink" title="4. Classes"></a>4. Classes</h2><h3 id="4-1-abstract"><a href="#4-1-abstract" class="headerlink" title="4.1 abstract"></a>4.1 abstract</h3><p> abstract关键字用于定义抽象类以及抽象类中的抽象方法。</p><p>抽象类， 是可以从中派成出其他类的基类；简单说就是只能被继承，不能new出实例；与interface不同的是，抽象类中可以有成员实现的详细信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> App &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> setTargetProps&lt;T&gt; (target: T, source: Partial&lt;T&gt;): T &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(target).forEach(<span class="function">(<span class="params">property: keyof T</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setTargetPropsByProperty(target, property, source[property])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> App();</span><br><span class="line"><span class="comment">// Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> App&#123;&#125;;</span><br><span class="line"><span class="comment">// 非抽象类“ B”未实现从类“ App”继承的抽象成员“ make”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C <span class="keyword">extends</span> App&#123;</span><br><span class="line">  make()&#123;&#125; <span class="comment">// 需要实现抽象类中定义的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含abstract关键字，并且可以选择包括访问修饰符。</p><h3 id="4-2-public-private-and-protected"><a href="#4-2-public-private-and-protected" class="headerlink" title="4.2 public,private, and protected"></a>4.2 public,private, and protected</h3><h4 id="4-2-1-类型兼容"><a href="#4-2-1-类型兼容" class="headerlink" title="4.2.1 类型兼容"></a>4.2.1 类型兼容</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"Rhino"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Goat"</span>);</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; </span><br><span class="line"><span class="comment">// Type 'Employee' is not assignable to type 'Animal'. 没有继承关系的类型无法做赋值操作；</span></span><br><span class="line"><span class="comment">//  Types have separate declarations of a private property 'name'</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-protected"><a href="#4-2-2-protected" class="headerlink" title="4.2.2 protected"></a>4.2.2 protected</h4><p>protected修饰符的行为与private修饰符非常相似，除了声明为protected的成员也可以在派生类中访问之外；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">    <span class="comment">// 派生类中可以访问到 基类中的 protected 属性；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch());</span><br><span class="line"><span class="comment">// 虽然我们不能从Person外部使用name，但仍可以在Employee的实例方法中使用它，因为Employee源自Person。</span></span><br><span class="line"><span class="built_in">console</span>.log(howard.name);</span><br><span class="line"><span class="comment">// Property 'name' is protected and only accessible within class 'Person' and its subclasses.</span></span><br></pre></td></tr></table></figure><p>构造函数也可能被标记为受保护的。这意味着该类不能在其包含的类之外实例化，但是可以扩展。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee can extend Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>);</span><br><span class="line"><span class="comment">// Constructor of class 'Person' is protected and only accessible within the class declaration. 因为 new Person的时候是需要调 Person的构造函数，由于其构造函数添加了 protected关键字。实例是无法调类的构造函数的，所以就无法被实例化了；</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-Readonly"><a href="#4-2-3-Readonly" class="headerlink" title="4.2.3 Readonly"></a>4.2.3 Readonly</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">readonly theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dad = <span class="keyword">new</span> Octopus(<span class="string">"Man with the 8 strong legs"</span>);</span><br><span class="line">dad.name = <span class="string">"Man with the 3-piece suit"</span>;</span><br><span class="line"><span class="comment">// Cannot assign to 'name' because it is a read-only property.</span></span><br><span class="line"><span class="built_in">console</span>.log(dad.name)</span><br></pre></td></tr></table></figure><h4 id="4-2-4-accessors"><a href="#4-2-4-accessors" class="headerlink" title="4.2.4 accessors"></a>4.2.4 accessors</h4><p>TypeScript支持getters / setter方法，以拦截对对象成员的访问。这使您可以更好地控制如何访问每个对象上的成员的方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  fullName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此版本中，我们添加了一个setter来检查newName的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是这样，我们会抛出错误通知客户端代码出了点问题。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullNameMaxLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span> = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"fullName has a max length of "</span> + fullNameMaxLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><p>首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。</p><p>其次，带有get和no set的访问器会自动推断为只读。当代码生成.d.ts文件时很有用，因为用户通过ide可以看到这些无法进行更改。</p><h4 id="4-2-5-Static"><a href="#4-2-5-Static" class="headerlink" title="4.2.5 Static"></a>4.2.5 Static</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Grid &#123;</span><br><span class="line">  <span class="keyword">static</span> origin = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  calculateDistanceFromOrigin(point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDist = point.x - Grid.origin.x;</span><br><span class="line">    <span class="keyword">let</span> yDist = point.y - Grid.origin.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>); <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>); <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;));</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;));</span><br></pre></td></tr></table></figure><h4 id="4-2-6-Using-a-class-as-an-interface"><a href="#4-2-6-Using-a-class-as-an-interface" class="headerlink" title="4.2.6 Using a class as an interface"></a>4.2.6 Using a class as an interface</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="5-Decorators"><a href="#5-Decorators" class="headerlink" title="5. Decorators"></a>5. Decorators</h2><p>随着TypeScript和ES6中类的引入，现在存在某些情况，这些情况需要附加功能来支持  annotating or modifying classes and class members。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的第2阶段提议，可作为TypeScript的实验功能使用。</p><p>JavaScript引入class之后，我们需要在不同的类之间共享或者扩展一些方法或行为的时候，代码会变得很复杂，不够优雅，这也是装饰器被提出的一个很重要原因之一；</p><p>要为装饰器启用实验性支持，必须在命令行或tsconfig.json中启用experimentalDecorators编译器选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰器是一种特殊的声明，可以附加到类声明，方法，访问器，属性或参数上。装饰器使用<code>@expression</code>形式，其中expression求值之后必须也是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入；</p><h3 id="5-1-class-decorators"><a href="#5-1-class-decorators" class="headerlink" title="5.1 class decorators"></a>5.1 class decorators</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.age = 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addName</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.name = "leo";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span></span><br><span class="line"><span class="meta">@addName</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age, person.name); <span class="comment">// 18 ,'age'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line"><span class="keyword">var</span> __decorate = <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length,</span><br><span class="line">    r =</span><br><span class="line">      c &lt; <span class="number">3</span></span><br><span class="line">        ? target</span><br><span class="line">        : desc === <span class="literal">null</span></span><br><span class="line">        ? (desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key))</span><br><span class="line">        : desc;</span><br><span class="line">  <span class="keyword">var</span> d;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">"function"</span>) &#123;</span><br><span class="line">    r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> ((d = decorators[i]))</span><br><span class="line">        <span class="comment">// 核心代码就是 d(r) r为构造函数Person</span></span><br><span class="line">        r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.age = 18;</span><br><span class="line">&#125;</span><br><span class="line">function addName(<span class="keyword">constructor</span>) &#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.name = "leo";</span><br><span class="line">&#125;</span><br><span class="line">var Person = /** @class */ (function () &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Person = __decorate([addAge, addName], Person);</span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.age, person.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-reflect-metadata"><a href="#5-2-reflect-metadata" class="headerlink" title="5.2 reflect-metadata"></a>5.2 reflect-metadata</h3><p><strong>install</strong></p><p><code>npm install reflect-metadata</code></p><p><strong>demo</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span>;</span><br><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>, <span class="string">"alex"</span>, target);</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>, <span class="string">"world"</span>, target, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getOwnMetadata(<span class="string">"name"</span>, target)); <span class="comment">// alex</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getOwnMetadata(<span class="string">"name"</span>, target, <span class="string">"hello"</span>)); <span class="comment">// world</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classMetadata</span>(<span class="params">key: <span class="built_in">any</span>, value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    Reflect.defineMetadata(key, value, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodMetadata</span>(<span class="params">key: <span class="built_in">any</span>, value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyName: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Person.prototype.hello.name=world</span></span><br><span class="line">    Reflect.defineMetadata(key, value, target, propertyName);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给类本身增加元数据</span></span><br><span class="line"><span class="comment">//@Reflect.metadata('name','Person')</span></span><br><span class="line"><span class="meta">@classMetadata</span>(<span class="string">"name"</span>, <span class="string">"Person"</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">//给类的原型增加元数据</span></span><br><span class="line">  <span class="comment">//@Reflect.metadata('name', 'world')</span></span><br><span class="line">  <span class="meta">@methodMetadata</span>(<span class="string">"name"</span>, <span class="string">"world"</span>)</span><br><span class="line">  hello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>, Person)); <span class="comment">// Person</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>, <span class="keyword">new</span> Person(), <span class="string">"hello"</span>)); <span class="comment">// world</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html5vedio</title>
      <link href="2021/01/04/html5vedio/"/>
      <url>2021/01/04/html5vedio/</url>
      
        <content type="html"><![CDATA[<h4 id="html5-播放器加速"><a href="#html5-播放器加速" class="headerlink" title="html5 播放器加速"></a>html5 播放器加速</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"></span><br><span class="line">video.playbackRate = <span class="number">2</span> <span class="comment">// 播放器播放速度</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browser-sync</title>
      <link href="2020/12/21/browser-sync/"/>
      <url>2020/12/21/browser-sync/</url>
      
        <content type="html"><![CDATA[<h2 id="全局安装1231312312312123"><a href="#全局安装1231312312312123" class="headerlink" title="全局安装1231312312312123"></a>全局安装1231312312312123</h2><p><code>sudo npm install -g browser-sync</code></p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器 监听所有的html文件</span></span><br><span class="line">$ browser-sync start --server --files <span class="string">"*.html"</span></span><br><span class="line"><span class="comment"># 启动服务器 监听所有的文件</span></span><br><span class="line">$ browser-sync start --server --files <span class="string">"**"</span></span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>browser-sync start --server --port 3333 --files &quot;*.css,*.html,*.js&quot;</code></p><h2 id="start-options"><a href="#start-options" class="headerlink" title="start options"></a>start options</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">help</span>                 <span class="comment">#输出使用信息</span></span><br><span class="line">--version               <span class="comment">#输出的版本号</span></span><br><span class="line">--browser               <span class="comment">#选择哪个浏览器应该是自动打开</span></span><br><span class="line">--files                 <span class="comment">#文件路径看</span></span><br><span class="line">--exclude               <span class="comment">#文件模式忽视</span></span><br><span class="line">--server               <span class="comment">#运行本地服务器（使用您的CWD作为Web根）</span></span><br><span class="line">--index                 <span class="comment">#指定哪些文件应该被用作索引页</span></span><br><span class="line">--extensions           <span class="comment">#指定文件扩展名回退</span></span><br><span class="line">--startPath             <span class="comment">#指定起始路径，打开浏览器</span></span><br><span class="line">--https                 <span class="comment">#启用S​​SL地方发展</span></span><br><span class="line">--directory             <span class="comment">#显示服务器的目录列表</span></span><br><span class="line">--proxy                 <span class="comment">#代理现有的服务器</span></span><br><span class="line">--xip                   <span class="comment">#使用xip.io域路由</span></span><br><span class="line">--tunnel               <span class="comment">#使用公共网址</span></span><br><span class="line">--open                 <span class="comment">#选择哪个URL是自动打开（本地，外部或隧道）</span></span><br><span class="line">--config               <span class="comment">#指定为BS-config.js文件的路径</span></span><br><span class="line">--host                 <span class="comment">#指定主机名使用</span></span><br><span class="line">--logLevel             <span class="comment">#设置记录器输出电平（沉默，信息或调试）</span></span><br><span class="line">--port                <span class="comment">#指定要使用的端口</span></span><br><span class="line">--reload-delay        <span class="comment">#以毫秒为单位的时间延迟重装事件以下文件的变化</span></span><br><span class="line">--reload-debounce      <span class="comment">#限制在浏览器中的频率：刷新事件可以被发射到连接的客户机</span></span><br><span class="line">--ui-port              <span class="comment">#指定端口的UI使用</span></span><br><span class="line">--no-notify            <span class="comment">#禁用浏览器的通知元素</span></span><br><span class="line">--no-open              <span class="comment">#不要打开一个新的浏览器窗口</span></span><br><span class="line">--no-online            <span class="comment">#强制离线使用</span></span><br><span class="line">--no-ui                <span class="comment">#不要启动用户界面</span></span><br><span class="line">--no-ghost-mode        <span class="comment">#禁用幽灵模式</span></span><br><span class="line">--no-inject-changes    <span class="comment">#刷新上的每个文件更改</span></span><br><span class="line">--no-reload-on-restart<span class="comment">#不要自动重新加载在重新启动所有浏览器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab3</title>
      <link href="2020/12/17/gitlab3/"/>
      <url>2020/12/17/gitlab3/</url>
      
        <content type="html"><![CDATA[<h2 id="gitlab-分支策略"><a href="#gitlab-分支策略" class="headerlink" title="gitlab 分支策略"></a>gitlab 分支策略</h2><blockquote><p>考虑到gitlab一般在企业内部使用，一般不存在社区开发者，所以在管理上不会采用github的upstream/origin双仓库模式。gitlab下，开发者们面向一个仓库进行提交即可；</p></blockquote><h3 id="设置对分支的保护权限"><a href="#设置对分支的保护权限" class="headerlink" title="设置对分支的保护权限"></a>设置对分支的保护权限</h3><blockquote><p>顾名思义，分支的权限必不可少，它可以约束开发者们的提交行为和提交策略。避免失误操作将未测试过的代码强制提交到生产分支；developer可以不关心；</p></blockquote><p><img src="branch.png" alt="Protected Branches"></p><h3 id="issue与Milestones"><a href="#issue与Milestones" class="headerlink" title="issue与Milestones"></a>issue与Milestones</h3><blockquote><p>issue可以理解为一个最小原子的任务，多个任务组成一个 milestones；Milestones 可以理解为某个时间区间内的任务集；一个Milestones可包含多个issue； 当该Milestones中所有issue完成，则标志着此Milestones的结束；</p></blockquote><h4 id="创建issue和mr"><a href="#创建issue和mr" class="headerlink" title="创建issue和mr"></a>创建issue和mr</h4><ol><li>创建一个issue</li></ol><p><img src="issue.png" alt="issue"></p><ol start="2"><li>关联一个mr</li></ol><p><img src="mr.png" alt="mr"></p><ol start="3"><li>branch name</li></ol><blockquote><p>branch name 会以issue的序号开始，然后抓取title中的英文和数字做连接。</p></blockquote><p>可采用<code>index-categroy-content-[username]-[time]</code>的自定义方式，括号部分可选</p><ul><li><p>category</p><ul><li>feature</li><li>bugfix</li><li>chore</li><li>enhance</li></ul></li><li><p>content，一到三个词简述任务</p></li><li><p>username，任务认领人</p></li><li><p>time，创建分支的时间，一般 <code>201217</code>或者<code>1225</code></p></li></ul><ol start="4"><li>source</li></ol><p>基于什么分支创建当前分支，<code>feature/chore/enhance</code>选择<code>dev-0.3</code>, <code>bugfix</code>选择<code>env-dev</code></p><h3 id="提交代码流程"><a href="#提交代码流程" class="headerlink" title="提交代码流程"></a>提交代码流程</h3><p><img src="flow.jpg" alt="flow"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch <span class="comment"># 获取issue关联的分支名</span></span><br><span class="line">git checkout -b 6-feature-pivotDrill origin/6-feature-pivotDrill <span class="comment"># 基于远端新建一个本地开发分支</span></span><br><span class="line"></span><br><span class="line">git rebase dev-0.3 <span class="comment"># 在开发过程中，不定时rebase 宿主分支，防止版本隔断</span></span><br><span class="line">git push origin 6-feature-pivotDrill <span class="comment"># 提交至远程映射</span></span><br><span class="line"><span class="comment"># 通知maintainer完成代码合并，并关闭issue</span></span><br></pre></td></tr></table></figure><h3 id="commits规范"><a href="#commits规范" class="headerlink" title="commits规范"></a>commits规范</h3><p><code>&#39;type(module) some desc&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type = [</span><br><span class="line">  <span class="string">"build"</span>, <span class="comment">// 构建执行</span></span><br><span class="line">  <span class="string">"chore"</span>, <span class="comment">// 构建工具相关</span></span><br><span class="line">  <span class="string">"ci"</span>, <span class="comment">// CI 相关</span></span><br><span class="line">  <span class="string">"docs"</span>, <span class="comment">// 文档更新</span></span><br><span class="line">  <span class="string">"feat"</span>, <span class="comment">// 新功能</span></span><br><span class="line">  <span class="string">"fix"</span>, <span class="comment">// bug 修复</span></span><br><span class="line">  <span class="string">"perf"</span>, <span class="comment">// 性能优化</span></span><br><span class="line">  <span class="string">"refactor"</span>, <span class="comment">// 功能重构</span></span><br><span class="line">  <span class="string">"release"</span>,</span><br><span class="line">  <span class="string">"revert"</span>, <span class="comment">// 回滚操作</span></span><br><span class="line">  <span class="string">"style"</span>, <span class="comment">// 样式变动</span></span><br><span class="line">  <span class="string">"test"</span>, <span class="comment">// 单元测试</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">moduele = [</span><br><span class="line">  <span class="comment">// 以davinci为例,只列出前端模块</span></span><br><span class="line">  <span class="string">"project"</span>,</span><br><span class="line">  <span class="string">"dashboard"</span>,</span><br><span class="line">  <span class="string">"display"</span>,</span><br><span class="line">  <span class="string">"widget"</span>,</span><br><span class="line">  <span class="string">"schdule"</span>,</span><br><span class="line">  <span class="string">"view"</span>,</span><br><span class="line">  <span class="string">"source"</span>,</span><br><span class="line">  <span class="string">"user"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="review代码的参考标准"><a href="#review代码的参考标准" class="headerlink" title="review代码的参考标准"></a>review代码的参考标准</h3><ol><li>格式化后的代码，在vscode中安装<code>prettier</code>工具，设置<code>ctrl+s</code>默认对当前页进行<code>prettier</code>格式化；</li><li>所有commits必须要关联issue，如果没有issue要新建issue然后关联mr（merge request），基于当前mr提交代码；</li><li>原则上，不能有肉眼可见的bug，一般review代码时会进行简单的测试；</li><li>其他规则（代码规范）</li></ol><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><blockquote><p>原则上，所有新提交的代码参考项目代码风格即可。简述为下面几个方面</p></blockquote><ol><li>原则上，变量名含义精准，（ps：严禁全局作用域中出现单字符命名空间；）</li><li>不要求一定要加注释或者不加注释，我们的愿景是能够书写无注释就能看懂的代码。根据业务逻辑难易程度，自行决定。 尽量英文注释；</li><li>不建议提交大量重复代码，须做好代码的抽象复用；</li><li>尽量使用被主流浏览器支持的的es规范书写代码，原则上新es规范下已有的工具类和函数，不重复造轮子；</li><li>其他涉及<code>html/css/javascript</code>相关的推荐规范会渐进式纳入规范集；</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab2</title>
      <link href="2020/12/16/gitlab2/"/>
      <url>2020/12/16/gitlab2/</url>
      
        <content type="html"><![CDATA[<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p><img src="label.png" alt="label"></p><h3 id="标签组"><a href="#标签组" class="headerlink" title="标签组"></a>标签组</h3><blockquote><p>标签组的意义就是定义一次，多个项目统一使用</p></blockquote><h4 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h4><blockquote><p>前端还是后端，ios 还是 android</p></blockquote><ul><li>angular</li><li>node</li></ul><h4 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h4><blockquote><p>目前产品中存在的问题，以及该问题的优先级程度</p></blockquote><ul><li>bug： 常规bug</li><li>security： 安全漏洞</li><li>production： 涉及到生产环境</li></ul><h4 id="Mindless"><a href="#Mindless" class="headerlink" title="Mindless"></a>Mindless</h4><blockquote><p>影响较小的任务，比如更改文件夹目录，适配规范</p></blockquote><ul><li>chore</li><li>legal</li></ul><h4 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h4><blockquote><p>影响用户体验，或者用户对产品的理解. These can be both opportunities and “UX bugs”.</p></blockquote><ul><li>copy</li><li>design</li><li>ux: User Experience</li></ul><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><blockquote><p>服务器环境，开发环境，生产环境或者测试环境</p></blockquote><ul><li>staging</li><li>test</li></ul><h4 id="Feedback"><a href="#Feedback" class="headerlink" title="Feedback"></a>Feedback</h4><blockquote><p>待确认的问题，比如一些拍脑袋的需求；或者某个需求我们还没决定怎么实现</p></blockquote><ul><li>discussion</li><li>question： 还没到需要讨论的情况</li><li>rfc</li></ul><h4 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h4><blockquote><p>现有功能或基础架构上的迭代。</p></blockquote><ul><li>enhancement: 现有模块有更高的完成度</li><li>optimization: 现有功能代码层面的重构，或者交互流程上的梳理</li></ul><h4 id="Additions"><a href="#Additions" class="headerlink" title="Additions"></a>Additions</h4><blockquote><p>新功能，新页面</p></blockquote><ul><li>feature</li></ul><h4 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h4><blockquote><p>现在不好说，未来肯定有结果，可能做成功， 可能做不成；</p></blockquote><ul><li>in progress： 进行中的需求</li><li>watchlist： 先拖着的需求，有可能就拖掉了</li></ul><h4 id="Inactive"><a href="#Inactive" class="headerlink" title="Inactive"></a>Inactive</h4><blockquote><p>无需采取任何行动或可能采取任何行动。该问题已解决，可以通过其他问题更好地解决；</p></blockquote><ul><li>invalid： 无效的</li><li>wontfix： 不会修复</li><li>duplicate： 重复</li><li>on hold： 等待候听</li></ul>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab 使用</title>
      <link href="2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="软件开发阶段"><a href="#软件开发阶段" class="headerlink" title="软件开发阶段"></a>软件开发阶段</h2><blockquote><p>软件开发十个阶段在gitlab中对应的管理方式方法</p></blockquote><ol><li>IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了<code>Mattermost</code> 它类似一个聊天工具。</li><li>ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在工单追踪器<code>issue tracker</code>中帮助你去提升这个点子。</li><li>PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用工单看板<code>Issue Board</code>。</li><li>CODE： 现在，当一切准备就绪，我们可以开始写代码了。</li><li>COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。</li><li>TEST： 通过<code>GitLab CI</code>，我们可以运行脚本来构建和测试我们的应用。</li><li>REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行代码复审<code>code review</code>以及批准。</li><li>STAGING：： 预发布环境。</li><li>PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了。</li><li>FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 <code>Cycle Analytics</code>来对当前项目中关键的部分进行的反馈</li></ol><h2 id="issue-和-milestone"><a href="#issue-和-milestone" class="headerlink" title="issue 和 milestone"></a>issue 和 milestone</h2><blockquote><p>milestone里程碑，用来标识阶段性目标， 对目标进行细化，化整为零一个个的issues，然后根据每个issues的紧急程度选择性的完成。等所有issues解决完之后 就标志着阶段性目标已完成；</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>把实际问题转化为issue，这些问题可以标记为<code>正在解决</code>和<code>计划解决</code>；</li><li>milestone对应着阶段性项目计划，然后细分为多个issues，而且可以指定完成时间，gitlab会自动生成完成进度情况概略图。</li><li>issues也可以是一个建议，共给大家一起讨论；</li><li>milestone 和issue建立时我们通常可以对问题进行简单描述，并且记录问题的解决过程，包括他人提出的疑问也可以在这里记录，后期可以随时查看；</li></ol><h3 id="创建milestone"><a href="#创建milestone" class="headerlink" title="创建milestone"></a>创建milestone</h3><blockquote><p>可以在项目开始前创建milestone，后面建issues时关联它，也可以先建issues，后期由项目负责人建milestone，然后把所有issues关联过来；</p></blockquote><ol><li>创建一个名字</li><li>简单描述，简述创建的原因，这个里程碑最终的目的，编辑的时候可以直接贴图，也可以添加附件（支持markdown格式，可以预览）</li><li>指定计划的完成时间；</li></ol><h3 id="新建issues"><a href="#新建issues" class="headerlink" title="新建issues"></a>新建issues</h3><blockquote><p>一个issues表示一个功能、一个bug、一个建议; 新建议题很简单，标题+描述+计划时间+指定人+里程碑，里程碑一定要指定一下，还可以加标签。</p></blockquote><ol><li>功能：里程碑的细分，尽量小，方便merger时的代码审核；</li><li>bug：解决程序中存在的某些问题；</li><li>建议：可以作为一个讨论交流区，也可以实现它;</li><li>一个issues 对应一个指定人，一个git 分支；</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="2020/12/09/test/"/>
      <url>2020/12/09/test/</url>
      
        <content type="html"><![CDATA[<h2 id="配置hexo到阿里云"><a href="#配置hexo到阿里云" class="headerlink" title="配置hexo到阿里云"></a>配置hexo到阿里云</h2><blockquote><p>网上大多数教程问题不大，额外需要注意修改一些文件的写入权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将post-receive 设置为可执行文件</span></span><br><span class="line">chmod +x ~/hexo.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置博客源地址文件夹权限，不然git hooks写入不了，Unable to unlink 就是这种原因</span></span><br><span class="line">sudo chmod -R 777 /home/www/hexo</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> doc </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo</title>
      <link href="2020/06/04/hello-world/"/>
      <url>2020/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloworld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(helloworld);</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> doc </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
