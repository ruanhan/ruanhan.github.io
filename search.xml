<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go_web</title>
      <link href="2021/03/16/go-web/"/>
      <url>2021/03/16/go-web/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><p>处理请求</p><p>模版</p><p>中间件</p><p>存储数据</p><p>HTTPS，HTTP2</p><p>测试</p><p>部署</p><h2 id="2-处理请求"><a href="#2-处理请求" class="headerlink" title="2. 处理请求"></a>2. 处理请求</h2><h3 id="2-1-Create-pro"><a href="#2-1-Create-pro" class="headerlink" title="2.1 Create pro"></a>2.1 Create pro</h3><p>创建模块</p><p><code>GO111MODULE=on go mod init pro name</code> </p><p>helloworld</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hi go web"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8999"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-如何处理web请求"><a href="#2-2-如何处理web请求" class="headerlink" title="2.2 如何处理web请求"></a>2.2 如何处理web请求</h3><p>http.Handle 函数</p><p>http.HandleFunc 函数</p><h4 id="2-2-1-创建web-Server"><a href="#2-2-1-创建web-Server" class="headerlink" title="2.2.1 创建web Server"></a>2.2.1 创建web Server</h4><p>两种方式</p><p>方式一</p><p>http.ListenAndServer()</p><p>http.ListenAndServeTLS()  https 服务</p><ul><li>第一个参数是网络地址，</li><li>第二个参数为handler<ul><li>如果为nil，那么就是DefaultServeMux</li></ul></li><li>DefaultServeMux 是一个multiplexer（可以看作是一个路由器）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">"localhost:8989"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>方式二</p><p>http.Server可配置</p><p>server.ListenAndServe()</p><p>server.ListenAndServeTLS()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:= http.Server &#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br></pre></td></tr></table></figure><h4 id="2-2-2-DefaultServeMux"><a href="#2-2-2-DefaultServeMux" class="headerlink" title="2.2.2 DefaultServeMux"></a>2.2.2 DefaultServeMux</h4><p>它是一个multiplexer 多路复用器</p><p>它也是一个handler</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/handler00.png" alt="image-20210317103838883"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"myHandler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu := myHandler&#123;&#125;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: &amp;mu,</span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个handler</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/handler01.png" alt="image-20210317104736194"></p><p>不指定Server struct里面的Handler字段值</p><p>可以使用http.Handle将某个Handler附加到DefaultServeMux</p><ul><li>http包有一个Handle函数</li><li>ServerMux struct也有一个Handle方法</li></ul><p>如果你调用http.Handle，实际上调用的是DefaultServeMux上的Handle方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(patten <span class="keyword">string</span>, handler Handler)</span> // 注册函数</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"myHandler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hiHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *hiHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello handler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu := myHandler&#123;&#125;</span><br><span class="line">hi:= hiHandler&#123;&#125;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/mu"</span>, &amp;mu)</span><br><span class="line">http.Handle(<span class="string">"/hi"</span>, &amp;hi)</span><br><span class="line"></span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-Handler-函数-http-HandleFunc"><a href="#2-2-3-Handler-函数-http-HandleFunc" class="headerlink" title="2.2.3 Handler 函数 - http.HandleFunc"></a>2.2.3 Handler 函数 - http.HandleFunc</h4><p>handler是一个接口（interface）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler函数就是那些行为与handler类似的函数：</p><p>Handler函数的签名与ServeHTTP方法的签名一样，接收：</p><ul><li>一个http.ResponseWriter</li><li>一个指向http.Request的指针</li></ul><p>Go有一个函数类型： HandlerFunc，可以将某个具有适当签名的函数f， 适配成为一个Handler，而这个Handler具有方法 f</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"myHandler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hiHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *hiHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello handler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"weclome"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu := myHandler&#123;&#125;</span><br><span class="line">hi:= hiHandler&#123;&#125;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8989"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/mu"</span>, &amp;mu)</span><br><span class="line">http.Handle(<span class="string">"/hi"</span>, &amp;hi)</span><br><span class="line"><span class="comment">//http.HandleFunc("/weclome", welcome)</span></span><br><span class="line">http.Handle(<span class="string">"/wel"</span>, http.HandlerFunc(welcome)) <span class="comment">// handleFunc 函数内部有适配器 handlerFunc</span></span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器HandlerFunc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-五个内置handler"><a href="#2-2-4-五个内置handler" class="headerlink" title="2.2.4 五个内置handler"></a>2.2.4 五个内置handler</h4><p>NotFoundHandler 404</p><p>RedirectHandler  返回一个handler，把每个请求使用给定的状态吗跳转到指定的URl</p><ul><li>url，要跳转到的URL</li><li>code，跳转的状态吗（3XX），常见的 StatusMovedPermanently， StatusFound 或 StatusSeeOther</li></ul><p>StripPrefix 返回一个handler，它从请求URL中去掉指定的前缀，然后再调用另一个handler</p><p>TimeoutHandler</p><p>FileServer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileServer</span><span class="params">(root FileSystem)</span> <span class="title">Handler</span></span></span><br></pre></td></tr></table></figure><p>返回一个handler，使用基于root的文件系统来相应请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileSystem <span class="keyword">interface</span> &#123;</span><br><span class="line">Open(name <span class="keyword">string</span>)(File, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时需要用到操作系统的文件系统，所以还需要委托给操作系统的文件系统来获取文件；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dir <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dir)</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span><span class="params">(File,error)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) &#123;</span></span><br><span class="line"><span class="comment">//fmt.Printf(request.URL.Path)</span></span><br><span class="line"><span class="comment">//http.ServeFile(writer, request, "/webroot"+request.URL.Path)</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"><span class="comment">//http.ListenAndServe(":8000", nil)</span></span><br><span class="line">http.ListenAndServe(<span class="string">":8000"</span>, http.FileServer(http.Dir(<span class="string">"webroot"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-Request"><a href="#2-2-5-Request" class="headerlink" title="2.2.5 Request"></a>2.2.5 Request</h4><p>HTTP请求</p><p>Request</p><p>URL</p><p>Header</p><p>Body</p><h5 id="2-2-5-1-HTTP消息"><a href="#2-2-5-1-HTTP消息" class="headerlink" title="2.2.5.1 HTTP消息"></a>2.2.5.1 HTTP消息</h5><p>HTTP Request 和 HTTP Response</p><p>它们具有相同的结构</p><ul><li>请求（响应）行</li><li>0个或多个Header</li><li>空行</li><li>可选的消息体（Body）</li></ul><p>net/http 包提供了用于表示HTTP消息的结构</p><p>Request（是个struct），代表了客户端发送的HTTP请求消息</p><p>Request（是个struct），代表了客户端发送的HTTP请求消息</p><p>重要字段：</p><ul><li>URL</li><li>Header</li><li>Body</li><li>Form，PostForm，MultipartForm</li></ul><p>也可以通过Request的方法访问请求中的Cookie、URL、User Agent等消息</p><p>Request即可代表发送到服务器的请求，又可代表客户端发出的请求；</p><h5 id="2-2-5-2-请求URL"><a href="#2-2-5-2-请求URL" class="headerlink" title="2.2.5.2 请求URL"></a>2.2.5.2 请求URL</h5><p>Request的URL字段就代表了请求行（请求信息第一行）里面的部分内容</p><p>URL字段是指向url.URL类型的一个指针，url.URL是一个struct：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> &#123;</span><br><span class="line">  Scheme <span class="keyword">string</span></span><br><span class="line">  Opaque <span class="keyword">string</span></span><br><span class="line">  User *Userinfo</span><br><span class="line">  Host <span class="keyword">string</span></span><br><span class="line">  Path <span class="keyword">string</span></span><br><span class="line">  RawQuery <span class="keyword">string</span></span><br><span class="line">  Fragment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>URL通用形式</p><p><code>scheme://[userinfo@]host/path[?query][#fragment]</code></p><p>不可以斜杠开头的URL被解释为：</p><p><code>scheme:opaque[?query][#fragment]</code></p><h5 id="2-2-5-3-URL-Query"><a href="#2-2-5-3-URL-Query" class="headerlink" title="2.2.5.3 URL Query"></a>2.2.5.3 URL Query</h5><p>RawQuery 会提供实际查询的字符串</p><p><code>http://www.example/com/post?id=123&amp;thread_id=456</code></p><ul><li>它的RawQuery的值就是id=123&amp;thread_id=456</li></ul><p>还有一个简便的方法可以得到Key-Value对： 通过Request的Form字段</p><h5 id="2-2-5-4-URL-Fragment"><a href="#2-2-5-4-URL-Fragment" class="headerlink" title="2.2.5.4 URL Fragment"></a>2.2.5.4 URL Fragment</h5><p>如果从浏览器发出的请求， 那么你无法提取出Fragment字段的值；</p><ul><li>浏览器在发送请求时会把fragment部分去掉</li></ul><p>但不是所有的请求都是从浏览器发出的（例如从HTTP客户端包）</p><h5 id="2-2-5-5-Request-Header"><a href="#2-2-5-5-Request-Header" class="headerlink" title="2.2.5.5 Request Header"></a>2.2.5.5 Request Header</h5><p>请求和响应（Request、Response）的headers是通过Header类型来描述的，它是一个map，用来表述HTTP Header里的 Key-Value对；</p><p>Header map的key是string类型，value是[]string</p><p>设置key的时候会创建一个空的[]string 作为value，value里面第一个元素就是新header的值；</p><p>为指定的key添加一个新的header值，执行append操作即可</p><p> res.Header</p><ul><li>返回map</li></ul><p>r.Header[“Accept-Encoding”]</p><ul><li>返回：<code>[gzip,deflate]([]string类型)</code></li></ul><p>r.Header.Get(“Accept-Encoding”)</p><ul><li>返回： gzip，deflate(string类型)</li></ul><h5 id="2-2-5-6-Request-Body"><a href="#2-2-5-6-Request-Body" class="headerlink" title="2.2.5.6 Request Body"></a>2.2.5.6 Request Body</h5><p>请求和响应的bodies都是使用Body字段来表示的</p><p>Body是一个io.ReadCloser接口</p><ul><li>一个是Reader接口</li><li>一个是Closer接口</li></ul><p>Reader接口定义了一个Open方法：</p><ul><li>参数： []byte</li><li>返回：byte的数量、可选的错误</li></ul><p>Closer接口定义了一个Close方法：</p><ul><li>没有参数，返回可选的错误；</li></ul><p>想要读取请求body的内容，可以调用Body的Read方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8989"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/header"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, r.Header)</span><br><span class="line">fmt.Fprintln(w, r.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">fmt.Fprintln(w, r.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/post"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">length := r.ContentLength</span><br><span class="line">body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length) <span class="comment">// 创建一个长度为ContentLength的 byte slice</span></span><br><span class="line">r.Body.Read(body) <span class="comment">// 将Body里面的内容，通过Read方法读取到body中</span></span><br><span class="line">fmt.Fprintln(w, <span class="keyword">string</span>(body))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-5-7-查询参数（Query-Parameters）"><a href="#2-2-5-7-查询参数（Query-Parameters）" class="headerlink" title="2.2.5.7 查询参数（Query Parameters）"></a>2.2.5.7 查询参数（Query Parameters）</h5><p>URL Query</p><p><code>http://www/example.com/post?id=123&amp;thread_id=456</code></p><p>r.URL.RawQuery会提供实际查询的原始字符串</p><ul><li>上例的RawQuery的值就是 id=123&amp;thread_id=456</li></ul><p>r.URL.Query() 会提供查询字符串对应的 <code>map[string][]string</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url := r.URL</span><br><span class="line">query := url.Query() <span class="comment">// map[string][]string</span></span><br><span class="line">id := query[<span class="string">"id"</span>] <span class="comment">// []string&#123;"123"&#125;</span></span><br><span class="line">threadID := query.Get(<span class="string">"thread_id"</span>) <span class="comment">// "456"</span></span><br></pre></td></tr></table></figure><h4 id="2-2-6-Form"><a href="#2-2-6-Form" class="headerlink" title="2.2.6 Form"></a>2.2.6 Form</h4><h5 id="2-2-6-1-通过表单发送请求"><a href="#2-2-6-1-通过表单发送请求" class="headerlink" title="2.2.6.1 通过表单发送请求"></a>2.2.6.1 通过表单发送请求</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个HTML表单里面的数据会以<code>name-value</code>对的形式，通过POST请求发送出去</p><p>它的数据内容会放在POST请求的Body里面</p><p>但name-value对在Body里面的格式是什么样的？</p><p><strong>表单Post请求的数据格式</strong></p><p>通过POST发送的name-value数据对的格式可以通过表单的Content Type来指定，也就是enctype属性</p><p><strong>表单的enctype属性</strong></p><p>默认值是：application/x-www-form-urlencoded</p><p>浏览器被要求至少要支持： application/x-www-form-urlencoded、multipart/form-data</p><ul><li>html5的话，还需要支持text/plain</li></ul><p>如果enctype是application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。</p><p><code>first_name=alex&amp;last_name=chang</code></p><p>如果enctype是multipart/form-data，那么</p><ul><li>每一个name-value对都会被转换为一个MIME消息部分</li><li>每一个部分都有自己的Content Type 和Content Disposition</li></ul><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/content.png" alt="image-20210317170418395"></p><p><strong>如何选择？</strong></p><p>简单的文本：  application/x-www-form-urlencoded</p><p>大量数据，（文件上传）： multipart-MIME</p><ul><li>甚至可以把二进制数据通过选择Base64编码，来当作文本进行发送</li></ul><p><strong>表单的GET</strong></p><p>通过表单的method属性，可以设置POST还是GET</p><p>GET请求没有Body，所有的数据都通过URL的name-value对 来发送</p><h5 id="2-2-6-2-字段"><a href="#2-2-6-2-字段" class="headerlink" title="2.2.6.2 字段"></a>2.2.6.2 字段</h5><p>Request上的函数允许我们从URL或/和Body中提取数据，通过这些字段：Form，PostForm，MultipartForm</p><p>Form里面的数据是key-value对</p><p>通常的做法是：</p><ul><li>先调用ParseForm 或 ParseMultipartForm来解析Request</li><li>然后相应的访问Form、PostForm或MultipartForm字段</li></ul><p><strong>Form</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">r.ParseForm() <span class="comment">// 解析form</span></span><br><span class="line">fmt.Fprintln(w, r.Form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>PostForm</strong></p><p>上例中，如果只想得到first_name 这个key 的value，可使用r.Form[“first_name”],它返回含有一个元素的slice: [“Dave”]</p><p>如果表单和URL里有同样的Key，那么它们都会放在一个slice里：表单里的值靠前，URL的值靠后；</p><p>如果只想要表单的key-value对，不要URL的，可以使用PostForm字段；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm() <span class="comment">// 解析form</span></span><br><span class="line">  fmt.Fprintln(w, r.Form) </span><br><span class="line">  <span class="comment">// map[first_name:[alex Leo] last_name:[ruan]]</span></span><br><span class="line">  fmt.Fprintln(w, r.PostForm) </span><br><span class="line">  <span class="comment">// map[first_name:[alex] last_name:[ruan]]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>PostForm只支持application/x-www-form-urlencoded，必须使用MultipartForm</p><p><strong>MultipartForm</strong></p><p>想要使用MultipartForm 这个字段，首先需要调用ParseMultipartForm这个方法；</p><ul><li>该方法会在必要时调用ParseForm方法</li><li>参数是需要读取数据的长度</li></ul><p>MultipartForm只包含表单的key-value对</p><p>返回的类型是一个struct而不是map，这个struct里有两个map：</p><ul><li>key是string，value是[]string</li><li>空的（key是string， value是文件）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseMultipartForm(<span class="number">1024</span>) <span class="comment">//1024 为字节数</span></span><br><span class="line">  fmt.Fprintln(w, r.MultipartForm)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &amp;&#123;map[first_name:[alex] last_name:[ruan]] map[]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>MultipartReader</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span><span class="title">MultipartReader</span><span class="params">()</span><span class="params">(*multipart.Reader,error)</span></span></span><br></pre></td></tr></table></figure><p>如果是multipart/form-data或multipart混合的POST请求：</p><ul><li>MultipartReader 返回一个MIME multipart reader</li><li>否则返回nil和一个错误</li></ul><p>可以使用该函数代替ParseMultipartForm来把请求的body作为stream进行处理</p><ul><li>不是把表单作为一个对象来处理的，不是一次性获得整个map</li></ul><p>逐个检查来自表单的值，然后每次处理一个；</p><h5 id="2-2-6-3-FormValue-amp-PostFormValue方法"><a href="#2-2-6-3-FormValue-amp-PostFormValue方法" class="headerlink" title="2.2.6.3 FormValue &amp; PostFormValue方法"></a>2.2.6.3 FormValue &amp; PostFormValue方法</h5><p>FormValue方法会返回Form字段中指定key对应的第一个value</p><ul><li>无需调用ParseForm或ParseMultipartForm</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8000/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, r.FormValue(<span class="string">"first_name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Leo  来自于查询字符串，来自表单里面的值靠前，来自url的靠后，FormValue只取一个值（如果enctype为application/x-www-form-urlencoded的话）；</span></span><br></pre></td></tr></table></figure><p>PostFormValue方法也一样，但只能读取PostForm</p><p>FormValue和PostFormValue都会调用ParseMultipartForm方法</p><p>但如果表单的enctype设为multipart/form-data，那么即使你调用ParseMultipartForm方法，也无法通过FormValue获得想要的值；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8000/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseMultipartForm(<span class="number">1024</span>) <span class="comment">//1024 为字节数</span></span><br><span class="line">  fmt.Fprintln(w, r.FormValue(<span class="string">"first_name"</span>))</span><br><span class="line">  fmt.Fprintln(w,r.PostFormValue(<span class="string">"first_name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Leo</span></span><br><span class="line"><span class="comment">// alex</span></span><br></pre></td></tr></table></figure><h5 id="2-2-6-4-上传文件（Files）"><a href="#2-2-6-4-上传文件（Files）" class="headerlink" title="2.2.6.4 上传文件（Files）"></a>2.2.6.4 上传文件（Files）</h5><p>Multipart/form-data最常见的应用场景就是上传文件（例子）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8000/process?first_name=Leo"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"first_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"last_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">r.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fileHeader:= r.MultipartForm.File[<span class="string">"uploaded"</span>][<span class="number">0</span>]</span><br><span class="line">file,err := fileHeader.Open() <span class="comment">// 从File字段 获得的FileHeader，调用其Open获得文件。</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file) <span class="comment">// 读取文件内容到byte切片里</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8000"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Printf(request.URL.Path)</span><br><span class="line">http.ServeFile(writer, request, <span class="string">"webroot2"</span>+request.URL.Path)</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FormFile方法</p><ul><li>上传文件还有一个简便方法：FormFile</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">  file,_,err := r.FormFile(<span class="string">"uploaded"</span>)</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    data, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Fprintln(w, <span class="keyword">string</span>(data))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无需调用ParseMultipartForm方法</p><p>返回指定key对应的第一个value</p><p>同时返回File和FileHeader，以及错误信息</p><p>如果只上传一个文件，那么这种方式会快一些</p><h5 id="2-2-6-5-POST-JSON"><a href="#2-2-6-5-POST-JSON" class="headerlink" title="2.2.6.5 POST JSON"></a>2.2.6.5 POST JSON</h5><p>不是所有的POST请求都来自Form</p><p>有很多不同的方式对POST请求编码</p><ul><li>application/x-www-form-urlencoded</li><li>application/json</li></ul><p>ParseForm方法无法处理application/json</p><h4 id="2-2-7-ResponseWriter"><a href="#2-2-7-ResponseWriter" class="headerlink" title="2.2.7 ResponseWriter"></a>2.2.7 ResponseWriter</h4><p>从服务器向客户端返回响应需要使用ResponseWriter</p><p>ResponseWriter是一个接口，handler用它来返回响应</p><p>真正支撑ResponseWriter的幕后struct是非导出的http.response</p><p>问题：</p><p>为什么Handler的ServeHTTP（w ResponseWriter, r*Request）,只有一个是指针类型？而w是按值传递的吗？</p><p>ResponseWriter本身是一个interface，而它代表了一个指针，这个指针指向response这个struct的。所以它也可以看作是一个指针。所以它的传递也是按引用进行传递的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">  Header() Header</span><br><span class="line">  Write([]<span class="keyword">byte</span>)(<span class="keyword">int</span> error)</span><br><span class="line">  WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> response <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span> <span class="title">Header</span><span class="params">()</span><span class="title">Header</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span> <span class="title">Write</span><span class="params">()</span><span class="title">Writer</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span> <span class="title">WriteHeader</span><span class="params">()</span><span class="title">WriteHeader</span></span></span><br><span class="line"><span class="comment">// 所以说 response指针就是实现了ResponseWriter接口，所以ResponseWriter接口就代表着 response指针；</span></span><br></pre></td></tr></table></figure><h5 id="2-2-7-1-写入到ResponseWriter"><a href="#2-2-7-1-写入到ResponseWriter" class="headerlink" title="2.2.7.1 写入到ResponseWriter"></a>2.2.7.1 写入到ResponseWriter</h5><p>write方法接收一个byte切片作为参数，然后把它写入到HTTP响应的Body里面；</p><p>如果在Write方法被调用时，header里面没有设定content type，那么数据的前512字节就会被用来检测content type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">str := <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;&lt;go web&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8000"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/write"</span>, writeExample)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i localhost:8000/write</span><br></pre></td></tr></table></figure><h5 id="2-2-7-2-WriteHeader方法"><a href="#2-2-7-2-WriteHeader方法" class="headerlink" title="2.2.7.2 WriteHeader方法"></a>2.2.7.2 WriteHeader方法</h5><p>WriteHeader方法接收一个整数类型（HTTP状态码）作为参数，并把它作为HTTP响应的状态码返回</p><p>如果该方法没有显式调用，那么在第一次调用Write方法前，会隐式的调用WriteHeader(http.StatusOK)</p><ul><li>所以WriteHeader主要用来发送错误类的HTTP状态吗</li></ul><p>调用完WriteHeader方法之后，仍然可以写入到ResponseWriter，但无法再修改header了；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">str := <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;go cProgramming&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeaderExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">w.WriteHeader(<span class="number">501</span>)</span><br><span class="line">fmt.Fprintln(w, <span class="string">"No such service, try next port"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">":8000"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/write"</span>, writeExample)</span><br><span class="line">http.HandleFunc(<span class="string">"/writeheader"</span>, writeHeaderExample)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-7-3-Header方法"><a href="#2-2-7-3-Header方法" class="headerlink" title="2.2.7.3 Header方法"></a>2.2.7.3 Header方法</h5><p>Header方法返回headers的map，可以进行修改</p><p>修改后的headers将会体现在返回给客户端的HTTP响应里；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headerExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">w.Header().Set(<span class="string">"Location"</span>,<span class="string">"https://reactnative.dev/"</span>)</span><br><span class="line">w.WriteHeader(<span class="number">302</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/red.png" alt="image-20210317232645674"></p><p>json</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">w.Header().Set(<span class="string">"Content-Type"</span>,<span class="string">"application/json"</span>)</span><br><span class="line">post:= &amp;Post&#123;</span><br><span class="line">User: <span class="string">"alex"</span>,</span><br><span class="line">Threads: []<span class="keyword">string</span>&#123;<span class="string">"first"</span>,<span class="string">"second"</span>,<span class="string">"third"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">json,_ := json2.Marshal(post)</span><br><span class="line">w.Write(json)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;"User":"alex","Threads":["first","second","third"]&#125;</span></span><br></pre></td></tr></table></figure><h5 id="2-2-7-4-内置的Response"><a href="#2-2-7-4-内置的Response" class="headerlink" title="2.2.7.4 内置的Response"></a>2.2.7.4 内置的Response</h5><p>NotFound函数，包装一个404状态吗和一个额外的信息</p><p>ServeFile函数，从文件系统提供文件，返回请求者</p><p>ServerContent函数，它可以把实现了io.ReadSeeker接口的任何东西里面的内容返回给请求者</p><ul><li>还可以处理Range请求（范围请求），如果只请求了资源的一部分内容，那么ServeContent就可以如此响应，而ServeFile或io.Copy则不行</li></ul><p>Redirect函数，告诉客户端重定向到另一个URL</p><h2 id="3-connect-sql"><a href="#3-connect-sql" class="headerlink" title="3.connect sql"></a>3.connect sql</h2><h3 id="3-1-Open"><a href="#3-1-Open" class="headerlink" title="3.1 Open"></a>3.1 Open</h3><p>sql.Open()</p><ul><li>参数1 数据库驱动名称</li><li>参数2 数据源名称</li><li>返回值 得到一个指向sql.DB这个struct的指针</li></ul><p>sql.DB是用来操作数据库的，它代表了0个或者多个底层连接的池，这些连接由sql包来维护，sql包会自动的创建和释放这些连接；</p><p>它对于多个goroutine并发的使用是安全的；</p><p>Open()函数并不会连接数据库，甚至不回验证其参数，它只是把后续连接到数据库所必需的structs给设置好了；</p><p>而真正的连接是在被需要的时候才进行懒设置的；</p><p>sql.DB不需要进行关闭（当然你想关闭也是可以的）</p><p>它就是用来处理数据库的，而不是实际的连接</p><p>这个抽象包含了数据库连接的池，而且会对此进行维护</p><p>在使用sql.DB的时候，可以定义它的全局变量进行使用，也可以将它传递函数/方法里；</p><h3 id="3-2-如何获得驱动"><a href="#3-2-如何获得驱动" class="headerlink" title="3.2 如何获得驱动"></a>3.2 如何获得驱动</h3><p>正常的做法是使用sql.Register()函数、数据库驱动的名称和一个实现了driver.Driver接口的struct，来注册数据库的驱动。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql.Register(<span class="string">"sqlserver"</span>, &amp;drv&#123;&#125;)</span><br></pre></td></tr></table></figure><p>但是之前的例子却没有写这句话，为什么？</p><ul><li>因为Sql Server的驱动，是在这个包被引入的时候进行了自我注册</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当go-sql-driver包被引入的时候，它的init函数将会运行并进行自我注册（在Go语言里，每个包的init函数都会在自动的调用）</p><p>在引入go-sql-driver 包的时候，把该包的名称设置为下划线_，这是因为我们不直接使用数据库驱动（只需要它起的“副作用”），我们只使用database/sql</p><p>这样，如果未来升级驱动，也无需改变代码</p><p>Go语言没有提供官方的数据库驱动，所有的数据库驱动都是第三方驱动，但是它们都遵循sql.driver包里面定义的接口</p><h3 id="3-3-下载驱动"><a href="#3-3-下载驱动" class="headerlink" title="3.3 下载驱动"></a>3.3 下载驱动</h3><p><code>go get github.com/go-sql-driver/mysql</code></p><h3 id="3-4-PingContext"><a href="#3-4-PingContext" class="headerlink" title="3.4 PingContext"></a>3.4 PingContext</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DB)</span> <span class="title">PingContext</span></span></span><br></pre></td></tr></table></figure><p>db.PingContext 函数是用来验证与数据库的连接是否仍然有效，如有必要则建立一个连接</p><p>这个函数需要一个Context（上下文）类型的参数，这种类型可以携带截止时间，取消信息和其它请求范围的值，并且可以横跨API边界和进程。</p><p>上例中，创建context使用的是context.Background()函数，该函数返回一个非nil的空Context，它不会被取消，它没有值，没有截止时间；</p><p>它通常在main函数，初始化或测试中，作为传入请求的顶级Context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">err = db.PingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalln(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Connected"</span>)</span><br></pre></td></tr></table></figure><h3 id="3-5-查询"><a href="#3-5-查询" class="headerlink" title="3.5 查询"></a>3.5 查询</h3><p>sql.DB类型上用于查询的方法有：</p><ul><li>Query</li><li>QueryRow （返回一行）</li><li>QueryContext</li><li>QueryRowContext</li></ul><h4 id="3-5-1-Query"><a href="#3-5-1-Query" class="headerlink" title="3.5.1 Query"></a>3.5.1 Query</h4><p>返回的类型是 type Rows struct{}</p><p>Rows的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回结果的列的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">ColumnTypes</span><span class="params">()</span><span class="params">([]*ColumnType, error)</span></span></span><br><span class="line"><span class="comment">// 返回所有列名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Columns</span><span class="params">()</span><span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="comment">// 查询遍历中的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 遍历结果集，每次读取一行，返回true说明还有数据 false表示读到最后一行了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 如果查询包含多个结果集，使用NextResultSet。它会准备好下一个结果集用来读取。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">NextResultSet</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Scan</span><span class="params">(dest...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><h4 id="3-5-2-QueryRow"><a href="#3-5-2-QueryRow" class="headerlink" title="3.5.2 QueryRow"></a>3.5.2 QueryRow</h4><p>返回类型是 type Row struct{}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询遍历中的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Row)</span> <span class="title">Scan</span><span class="params">(dest...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><h3 id="3-6-更新"><a href="#3-6-更新" class="headerlink" title="3.6 更新"></a>3.6 更新</h3><p>sql.DB类型上用于更新（执行命令）的方法有：</p><p>Exec</p><p>ExecContext</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a * app)</span><span class="title">Update</span><span class="params">()</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">  _,err := db.Exc(<span class="string">"sql 语句"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-其它"><a href="#3-7-其它" class="headerlink" title="3.7 其它"></a>3.7 其它</h3><p>Ping</p><p>PingContext</p><p>Prepare</p><p>PrepareContext</p><p>Transactions</p><ul><li>Begin</li><li>BeginTx</li></ul><h2 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h2><p>需要给架构增加Controller层</p><p>Controller的角色</p><ul><li>main(): 设置类工作，比如设置http server</li><li>Controller:<ul><li>静态资源 （比如css，js文件）</li><li>把不同的请求送到不同的controller进行处理</li></ul></li></ul><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/ctrl.png" alt="image-20210318180336477"></p><p>go语言提供一个前置的ctrl，所有进来的请求都会经过ctrl，然后由ctrl分发</p><h2 id="5-json"><a href="#5-json" class="headerlink" title="5. json"></a>5. json</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span> <span class="string">`json:"id"`</span></span><br><span class="line">User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Threads []<span class="keyword">string</span> <span class="string">`json:"thread"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-类型映射"><a href="#5-1-类型映射" class="headerlink" title="5.1 类型映射"></a>5.1 类型映射</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Go <span class="keyword">bool</span>: JSON boolean</span><br><span class="line">Go <span class="keyword">float64</span>: JSON 数值</span><br><span class="line">Go <span class="keyword">string</span>; JSON strings</span><br><span class="line">Go <span class="literal">nil</span>: JSON null</span><br></pre></td></tr></table></figure><h3 id="5-2-未知结构的JSON如何映射"><a href="#5-2-未知结构的JSON如何映射" class="headerlink" title="5.2 未知结构的JSON如何映射"></a>5.2 未知结构的JSON如何映射</h3><p>Map[string]interface{} 可以存储任意json对象</p><p>[]interface{} 可以存储任意的JSON数组</p><h3 id="5-3-读取JSON"><a href="#5-3-读取JSON" class="headerlink" title="5.3 读取JSON"></a>5.3 读取JSON</h3><p>需要一个解码器： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dec := json.NewDecoder(r.Body)</span><br></pre></td></tr></table></figure><p>参数需要实现Reader接口</p><p>在解码器上进行编码： dec.Decode(&amp;query)</p><h3 id="5-4-写入JSON"><a href="#5-4-写入JSON" class="headerlink" title="5.4 写入JSON"></a>5.4 写入JSON</h3><p>需要一个编码器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enc := json.NewEncoder(w)</span><br></pre></td></tr></table></figure><p>参数需要实现Writer接口</p><p>编码 ： enc.Encode(results)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">json</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line">dec := json2.NewDecoder(r.Body)</span><br><span class="line">company := Company&#123;&#125;</span><br><span class="line">err:= dec.Decode(&amp;company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc := json2.NewEncoder(w)</span><br><span class="line">err = enc.Encode(company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Marshal 和 Unmarshal</strong></p><p>Marshal （编码）： 把go struct转化为json格式</p><ul><li>Marshalindent, 带缩进</li></ul><p>Unmarshal（解码）： 把json转化为go struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span> <span class="string">`json:"id"`</span></span><br><span class="line">User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Threads []<span class="keyword">string</span> <span class="string">`json:"thread"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  jsonStr := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"id": 123,</span></span><br><span class="line"><span class="string">"name": "alex",</span></span><br><span class="line"><span class="string">"thread": "asia"</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">c:= Company&#123;&#125;</span><br><span class="line">_ = json2.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;c)</span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line">bytes,_ := json2.Marshal(c)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">bytes1, _ := json2.MarshalIndent(c,<span class="string">""</span>,<span class="string">"  "</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;123 alex [asia]&#125;</span></span><br><span class="line"><span class="comment">//&#123;"id":123,"user":"alex","thread":["asia"]&#125;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="string">"user"</span>: <span class="string">"alex"</span>,</span><br><span class="line">  <span class="string">"thread"</span>: [</span><br><span class="line">    <span class="string">"asia"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式的区别</strong></p><p>针对string或bytes：</p><ul><li>Marshal =&gt; string</li><li>Unmarshal &lt;= string</li></ul><p>针对stream：</p><ul><li>Encode =&gt; Stream, 把数据写入到 io.Writer</li><li>Decode &lt;= Stream, 从io.Reader 读取数据</li></ul><h2 id="6-中间件"><a href="#6-中间件" class="headerlink" title="6. 中间件"></a>6. 中间件</h2><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/middleware.png" alt="image-20210319133248463"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(addr <span class="keyword">string</span>, handler Handler)error</span><br><span class="line"><span class="comment">// handler 如果是nil： DefaultServeMux</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想创建handler，必须实现handler接口，需要实现ServeHTTP这个方法</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-创建中间件"><a href="#6-1-创建中间件" class="headerlink" title="6.1 创建中间件"></a>6.1 创建中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">  Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyMiddleware)</span> <span class="title">ServeHTTP</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在next handler之前做一些事情</span></span><br><span class="line">  m.Next.ServeHTTP(w, r) <span class="comment">// 将该请求转发到下一个handler中</span></span><br><span class="line">  <span class="comment">// 在 next handler之后做一些其它事情（对响应进行处理，中间件中创建的资源进行处理，此时响应仍然是没有返回至客户端的）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m.Next.ServeHTTP(w, r) 将该请求转发到下一个handler中。至于下一个handler是什么，这个Next设置成什么，下一个handler就是什么，有可能是nil。在web应用中，如果只有一个中间件的话。那么next就是DefaultServeMux。它就会将这个请求 进行路由。然后进程的处理。</p><p>中间件的用途</p><p>Logging</p><p>安全（请求超时，用户身份认证）</p><p>响应压缩</p><h3 id="6-2-使用请求上下文"><a href="#6-2-使用请求上下文" class="headerlink" title="6.2 使用请求上下文"></a>6.2 使用请求上下文</h3><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/ctx.png" alt="image-20210319144135404"></p><p>比如中间件设置了请求超时，而这个请求到数据库的时候，这个数据库将会花费很长时间。这个时候就需要让访问数据库的代码知道设置了查询超时时间。这就需要使用到上下文来解决；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Request)</span> <span class="title">Context</span><span class="params">()</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">// 返回当前请求的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Request)</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span><span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">// 基于Context 进行 修改，（实际上）创建一个新的Context</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">  <span class="comment">// 返回一个channel，用来做取消操作的。一旦context取消了。它就会接收到一个信号。这个channel也就关闭了；。比如在操作截止时间就会接到这个信号</span></span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 取消操作</span></span><br><span class="line">  <span class="comment">// 如果 Done 这个channel没有关闭的话，error就是nil，如果它关闭了，也就是context被取消了。那么error就存放被取消的原因；以后每次调用error都会显示同一个错误；</span></span><br><span class="line">  Err()error</span><br><span class="line">  <span class="comment">// 使用参数key从context获取一些信息，得到的这些信息可以从架构中的一个层传给另一个层；</span></span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法都是用于读取，不能进行设置；</p><p>Context API - 可以返回新Context</p><ul><li>WithCancal() ,它有一个CancelFunc</li><li>WithDeadline(), 带有一个时间戳 （time.Time）</li><li>WithTimeout(), 带有一个具体的时间段（time.Duration）</li><li>WithValue(), 在里面可以添加一些值；</li></ul><h2 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h2><p>HTTP请求的过程</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/http.png" alt="image-20210319155909596"></p><p>在http里面，参数都是以明文进行传输的。在客户端和服务端之间其它的东西，比如某个中间人/中间服务器也能懂得传输的信息。所以说，这种传输是非常不安全的 ；</p><p>HTTPS</p><p>https会稍微给传输层做一点改变，它不是直接在TCP上面传输数据的。会添加一个TLS层，在传输数据的时候，数据首先会被加密。加密之后只有客户端和服务器能够懂得这个加密数据里面真实的内容。中间人/中间服务器即使能获得数据，但是依然无法解析出来内容；也就无法懂得它真正代表的意思了；</p><h3 id="7-1-HTTP-ListenAndServeTLS"><a href="#7-1-HTTP-ListenAndServeTLS" class="headerlink" title="7.1 HTTP.ListenAndServeTLS"></a>7.1 HTTP.ListenAndServeTLS</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServeTLS 四个参数</span></span><br><span class="line">addr</span><br><span class="line">certFile</span><br><span class="line">keyFile</span><br><span class="line">handler</span><br><span class="line">http.ListenAndServeTLS()</span><br></pre></td></tr></table></figure><p>go 提供了生成证书的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go run /usr/<span class="built_in">local</span>/go/src/crypto/tls/generate_cert.go -h</span><br><span class="line"></span><br><span class="line">go run /usr/<span class="built_in">local</span>/go/src/crypto/tls/generate_cert.go -host localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># time  wrote cert.pem</span></span><br><span class="line"><span class="comment"># time  wrote key.pem</span></span><br><span class="line"></span><br><span class="line">http.ListenAndServeTLS(<span class="string">":8080"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, nil)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Request Headers</span><br><span class="line">  :authority: localhost:8080</span><br><span class="line">  :method: GET</span><br><span class="line">  :path: /json</span><br><span class="line">  :scheme: https</span><br><span class="line">  accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">  accept-encoding: gzip, deflate, br</span><br><span class="line">  accept-language: zh-CN,zh;q=0.9</span><br><span class="line">  cache-control: no-cache</span><br><span class="line">  cookie: </span><br><span class="line">  pragma: no-cache</span><br><span class="line">  sec-ch-ua: "Google Chrome";v="89", "Chromium";v="89", ";Not A Brand";v="99"</span><br><span class="line">  sec-ch-ua-mobile: ?0</span><br><span class="line">  sec-fetch-dest: document</span><br><span class="line">  sec-fetch-mode: navigate</span><br><span class="line">  sec-fetch-site: none</span><br><span class="line">  sec-fetch-user: ?1</span><br><span class="line">  upgrade-insecure-requests: 1</span><br><span class="line">  user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36</span><br></pre></td></tr></table></figure><p>Headers 以：开头，在go web应用里面，如果从http转到https，那么此应用会自动从http1.1 升级到http2协议。</p><h2 id="8-HTTP-2"><a href="#8-HTTP-2" class="headerlink" title="8. HTTP/2"></a>8. HTTP/2</h2><p>http2带来效率提升的原因</p><p>Http1.1发送请求</p><ol><li>首先建立tcp连接</li><li>发送请求时，通常header 和 body捆绑在一起发送的。尽管有时候body比较大，会被分到不同的包中发送。</li><li>响应返回的时候，基本和请求类似，也是header和body捆绑发送；</li></ol><p>这就导致header无法被压缩，header描述了请求或者响应里面的内容比如content-type，length等等，有些时候header比较大。</p><p>HTTP2</p><ol><li>依旧建立TCP服务</li><li>在TCP里建立stream，stream是在TCP里面独立通信的管道。各个stream不会相互影响。但是允许在同一个链接里面让多个信息来回发送但不相互干扰。在stream里面是通过Frame来发送消息的；所以它在发送请求的时候，不是将header和body绑在一起发送；而是将消息拆成多个Frame进行发送的；而每个Frame又可以单独的进行优化；</li></ol><p>有哪些Frame</p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/http2.png" alt="image-20210319172332556"></p><p>客户端往服务端发送header的时候，服务器知道它将接收到header。这个过程就能使用到一些压缩算法。</p><h3 id="8-1-http2的特点"><a href="#8-1-http2的特点" class="headerlink" title="8.1 http2的特点"></a>8.1 http2的特点</h3><ul><li>请求多路复用，可以在同一个TCP连接使用stream发送多个请求；</li><li>Header压缩</li><li>默认安全<ul><li>HTTP， 但很多决定不支持HTTP</li><li>HTTPS</li></ul></li><li>Server Push</li></ul><p><strong>没有Server push</strong></p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/noserverpush.png" alt="image-20210319172951647"></p><p>没有Server push的时候，请求是一来一回的。</p><p><strong>server push</strong></p><p><img src="/Users/ruanhan/hexoblog/rh/source/_posts/go-web/serverpush.png" alt="image-20210319173601377"></p><p>节省了一个步骤，从客户端往服务端请求app.css的部分；</p><h2 id="9-部署"><a href="#9-部署" class="headerlink" title="9. 部署"></a>9. 部署</h2><p>Nohup</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./it &amp;</span><br></pre></td></tr></table></figure><p>守护进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; vim /etc/systemd/system/go-web.service</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Go web App running on xxx</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/solenovex/it/it</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">RestartSec=10</span><br><span class="line">KillSignal=SINGINT</span><br><span class="line">SyslogIdentifier=go-web-example</span><br><span class="line">User=solenovex</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start go-web.service</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">sudo systemctl status go-web.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust</title>
      <link href="2021/03/16/rust/"/>
      <url>2021/03/16/rust/</url>
      
        <content type="html"><![CDATA[<h2 id="1-rust"><a href="#1-rust" class="headerlink" title="1. rust"></a>1. rust</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br><span class="line">rustup doc <span class="comment"># 离线文档</span></span><br><span class="line">rustc main.rs <span class="comment"># 编译main.rs  c为compiler</span></span><br></pre></td></tr></table></figure><h2 id="2-cargo"><a href="#2-cargo" class="headerlink" title="2. cargo"></a>2. cargo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo --version</span><br><span class="line">cargo new hello_cargo <span class="comment"># 创建一个 hello_cargo的项目</span></span><br></pre></td></tr></table></figure><h3 id="2-1-cargo-toml"><a href="#2-1-cargo-toml" class="headerlink" title="2.1 cargo.toml"></a>2.1 cargo.toml</h3><blockquote><p>TOML (Tom’s Obvious Minimal Language) 格式，是Cargo是配置格式</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span>  <span class="comment"># 区域标题，表示下方内容是用来配置包（package）的</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"hello_cargo"</span>  <span class="comment"># 项目名</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"ruanhan1988 &lt;2856197796@qq.com&gt;"</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">"2018"</span> <span class="comment"># 使用的rust版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> <span class="comment"># 区域标题， 另一个区域的开始，它会列出项目的依赖项</span></span><br></pre></td></tr></table></figure><h3 id="2-2-crate"><a href="#2-2-crate" class="headerlink" title="2.2 crate"></a>2.2 crate</h3><blockquote><p>在rust里面， 代码的包称为crate</p></blockquote><h3 id="2-3-非cargo创建的项目"><a href="#2-3-非cargo创建的项目" class="headerlink" title="2.3 非cargo创建的项目"></a>2.3 非cargo创建的项目</h3><blockquote><p>非cargo创建的项目，转化为使用cargo</p></blockquote><ol><li>把源代码文件移动到src下</li><li>创建Cargo.html并填写相应的配置</li></ol><h3 id="2-4-Cargo-构建项目"><a href="#2-4-Cargo-构建项目" class="headerlink" title="2.4 Cargo 构建项目"></a>2.4 Cargo 构建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build <span class="comment"># 构建</span></span><br><span class="line"><span class="comment"># 会创建出来一个可执行文件: target/debug/hello_cargo 或 target\debug\hello_cargo.exe</span></span><br></pre></td></tr></table></figure><h4 id="2-4-1-cargo-lock"><a href="#2-4-1-cargo-lock" class="headerlink" title="2.4.1 cargo.lock"></a>2.4.1 cargo.lock</h4><blockquote><p>第一次运行 cargo build会在项目目录生成 cargo.lock文件</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is automatically @generated by Cargo.</span></span><br><span class="line"><span class="comment"># It is not intended for manual editing.</span></span><br><span class="line"><span class="section">[[package]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"hello_cargo"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br></pre></td></tr></table></figure><p>该文件负责追踪项目以来的精确版本</p><p>不需要手动修改该文件</p><h3 id="2-5-构建和运行cargo项目"><a href="#2-5-构建和运行cargo项目" class="headerlink" title="2.5 构建和运行cargo项目"></a>2.5 构建和运行cargo项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p>如果源代码没有更改，直接运行上次生成的二进制文件；</p><h3 id="2-6-cargo-check"><a href="#2-6-cargo-check" class="headerlink" title="2.6 cargo check"></a>2.6 cargo check</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check <span class="comment"># 检查代码，确保能通过编译，但是不产生任何可执行文件；</span></span><br></pre></td></tr></table></figure><p>cargo check效率较build命令高很多，编写代码时，可反复使用cargo check检查代码，提高效率；</p><h3 id="2-7-发布"><a href="#2-7-发布" class="headerlink" title="2.7 发布"></a>2.7 发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br><span class="line"><span class="comment"># 编译时会进行优化, 代码会运行更快，但是编译时间更长</span></span><br><span class="line"><span class="comment"># 会在 target/release 而不是 target/debug 生成可执行文件</span></span><br></pre></td></tr></table></figure><h3 id="2-8-添加依赖包"><a href="#2-8-添加依赖包" class="headerlink" title="2.8 添加依赖包"></a>2.8 添加依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.html</span></span><br><span class="line">[package]</span><br><span class="line">name = <span class="string">"guessing_number"</span></span><br><span class="line">version = <span class="string">"0.1.0"</span></span><br><span class="line">authors = [<span class="string">"ruanhan1988 &lt;2856197796@qq.com&gt;"</span>]</span><br><span class="line">edition = <span class="string">"2018"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">rand = <span class="string">"0.3.14"</span>   <span class="comment"># 添加依赖包</span></span><br></pre></td></tr></table></figure><p>在dependencies区域下，直接填写 rand = “0.3.14”即可；</p><h2 id="3-guess-number-pro"><a href="#3-guess-number-pro" class="headerlink" title="3. guess number-pro"></a>3. guess number-pro</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess number"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess a number"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> guess =  <span class="built_in">String</span>::new(); <span class="comment">// 创建一个可变的变量，rust中变量默认是 immutable的</span></span><br><span class="line">    <span class="comment">// String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码</span></span><br><span class="line">    <span class="comment">// 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数</span></span><br><span class="line">    <span class="comment">// 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法</span></span><br><span class="line">    </span><br><span class="line">    io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br><span class="line">    <span class="comment">// rust中，引用默认也是不可变的，添加mut关键字，使其变为可变</span></span><br><span class="line">    <span class="comment">// &amp;mut guess 即指guess的引用  .expect 如果读取发生错误，程序崩溃退出；</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"you guess the number is: &#123;&#125;"</span>, guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-read-line"><a href="#3-1-read-line" class="headerlink" title="3.1 read_line"></a>3.1 read_line</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_line</span></span>(&amp;<span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">usize</span>&gt;</span><br><span class="line"><span class="comment">// read_line 有一个叫 io::Result 类型的返回值，在rust标准库中，有很多类型都叫做Result。既有通用的result（范型的result），也有特定版本，子模块的Result，比如io::Result, Result类型实际上枚举类型，一个枚举类型有几个固定的值，这些值称做是这些枚举类型的变体。而io::Result枚举类型一共两个变体，Ok和Err</span></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2-完整代码"><a href="#3-2-完整代码" class="headerlink" title="3.2 完整代码"></a>3.2 完整代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering; <span class="comment">// Ording 枚举类型</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="comment">// 默认情况下，rust会将 一个叫 prelude的模块 导入到每个程序的作用域中，</span></span><br><span class="line"><span class="comment">// 如果需要使用的类型不在 prelude里面，就需要显式的导入 比如 use std::io</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"guess number"</span>);</span><br><span class="line">    <span class="keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// loop 添加一个无限循环</span></span><br><span class="line">    <span class="keyword">loop</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"guess a number"</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guess =  <span class="built_in">String</span>::new(); <span class="comment">// 创建一个可变的变量，rust中变量默认是 immutable的</span></span><br><span class="line">        <span class="comment">// String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码</span></span><br><span class="line">        <span class="comment">// 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数</span></span><br><span class="line">        <span class="comment">// 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">"can not read_line"</span>);</span><br><span class="line">        <span class="comment">// rust中，引用默认也是不可变的，添加mut关键字，使其变为可变</span></span><br><span class="line">        <span class="comment">// &amp;mut guess 即指guess的引用  .expect 如果读取发生错误，程序崩溃退出；</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"you guess the number is: &#123;&#125;"</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在rust中允许使用同名的新变量来 shadow原来同名的旧变量，也就是说从声明新guess之后，</span></span><br><span class="line">        <span class="comment">// 代码中出现的guess变量都将是这个 u32类型的变量；这种用法通常使用在需要有类型转换的场景</span></span><br><span class="line">        <span class="comment">// 中，我们复用guess这个名而无需创建新的变量名；</span></span><br><span class="line">       <span class="comment">// let guess:u32 = guess.trim().parse().expect("plase type a number"); // parse返回值是Result，所以可以使用expect处理未来可能存在的异常</span></span><br><span class="line">       <span class="keyword">let</span> guess:<span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse()&#123;<span class="comment">// 使用match 提高程序健壮性</span></span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"valid number"</span>);</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="comment">// 非合法数字，直接continue</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match关键字， 根据cmp返回的Ordering 这个枚举类型的值来决定下一步来做什么。</span></span><br><span class="line">        <span class="comment">// 而match表达式 是有多个 arm /分支 组成的；</span></span><br><span class="line">        <span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123; <span class="comment">// cmp  compare 返回值 Ordering</span></span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"Too small!"</span>), <span class="comment">// arm</span></span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"To big!"</span>), <span class="comment">// arm</span></span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"you win"</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出 match</span></span><br><span class="line">            &#125;, <span class="comment">// arm</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-通用编程概念"><a href="#4-通用编程概念" class="headerlink" title="4. 通用编程概念"></a>4. 通用编程概念</h2><h3 id="4-1-变量与可变性"><a href="#4-1-变量与可变性" class="headerlink" title="4.1 变量与可变性"></a>4.1 变量与可变性</h3><p>声明变量用let</p><p>默认情况，变量是immutable</p><p>声明变量，在变量前面加上mut，就可以使变量可变；</p><h4 id="4-1-1-变量与常量"><a href="#4-1-1-变量与常量" class="headerlink" title="4.1.1 变量与常量"></a>4.1.1 变量与常量</h4><blockquote><p>常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别：</p></blockquote><p>不可以使用mut，常量永远都是不可变的；</p><p>声明变量使用const关键字，它的类型必须被标注；</p><p>常量可以在任何作用域内进行声明，包括全局作用域</p><p>常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值；</p><p>在程序运行期间，常量在其声明的作用域内一直有效</p><p>命名规范： Rust里常量使用全大写字母，每个单词之间用下划线分开；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_POINTS:<span class="built_in">u32</span> = <span class="number">100_00</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-Shadowing-隐藏"><a href="#4-1-2-Shadowing-隐藏" class="headerlink" title="4.1.2 Shadowing(隐藏)"></a>4.1.2 Shadowing(隐藏)</h4><blockquote><p> 可以使用相同的名字声明新的变量，新的变量就会shadow（隐藏）之前声明的同名变量</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> x = x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = x*<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 在后续的代码中这个变量名代表的就是新的变量；</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"value is &#123;&#125;"</span>, x); <span class="comment">// 12  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-shadow与mut"><a href="#4-1-3-shadow与mut" class="headerlink" title="4.1.3 shadow与mut"></a>4.1.3 shadow与mut</h4><blockquote><p> Shadow和把变量标记为mut是不一样的，</p></blockquote><p>如果不使用let关键字，那么重新给非mut的变量赋值会导致编译时错误</p><p>而使用let声明的同名新变量，也是不可变的；</p><p>使用let声明的同名新变量，它的类型可以与之前不同；</p><h3 id="4-2-数据类型"><a href="#4-2-数据类型" class="headerlink" title="4.2 数据类型"></a>4.2 数据类型</h3><p>Rust是静态编译语言，在编译时必须知道所有变量的类型；</p><p>基于使用的值，编译器通常能够推断出它的具体类型；</p><p>但如果可能的类型比较多（例如把String转为整数的parse方法），就必须添加类型的</p><p>标注，否则编译会报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = '<span class="number">42</span>'.parse(); <span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> num:<span class="built_in">u32</span> = '<span class="number">42</span>'.parse <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h4 id="4-2-1-标量类型"><a href="#4-2-1-标量类型" class="headerlink" title="4.2.1 标量类型"></a>4.2.1 标量类型</h4><blockquote><p>一个标量类型代表一个单个的值；</p></blockquote><p>Rust有四个主要的标量类型：</p><h5 id="4-2-1-1-整数类型"><a href="#4-2-1-1-整数类型" class="headerlink" title="4.2.1.1 整数类型"></a>4.2.1.1 整数类型</h5><p>整数类型没有小数部分</p><p>例如u32就是一个无符号的整数类型，占据32位的空间</p><p>无符号 以u开头</p><p>有符号 以i开头</p><p><strong>Rust的整数类型列表如图</strong></p><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p><strong>isize 和 usize类型</strong></p><p>isize 和 usize类型的位数由程序运行的计算机的架构所决定</p><p>如果是64位计算机，那就是64位，如果32位计算机，就是32位；</p><p>使用isize和usize 的主要场景是针对某中集合进行索引操作；</p><h5 id="4-2-1-2-浮点类型"><a href="#4-2-1-2-浮点类型" class="headerlink" title="4.2.1.2 浮点类型"></a>4.2.1.2 浮点类型</h5><p>f32</p><p>f64</p><h5 id="4-2-1-3-布尔类型"><a href="#4-2-1-3-布尔类型" class="headerlink" title="4.2.1.3 布尔类型"></a>4.2.1.3 布尔类型</h5><p>true</p><p>false</p><h5 id="4-2-1-4-字符类型"><a href="#4-2-1-4-字符类型" class="headerlink" title="4.2.1.4 字符类型"></a>4.2.1.4 字符类型</h5><p>char 4个字节</p><h4 id="4-2-2-复合类型"><a href="#4-2-2-复合类型" class="headerlink" title="4.2.2 复合类型"></a>4.2.2 复合类型</h4><blockquote><p>复合类型可以将多个值放在一个类型里</p></blockquote><p>Rust提供了两种基础的复合类型： 元祖（Tuple）、数组</p><h5 id="4-2-2-1-Tuple"><a href="#4-2-2-1-Tuple" class="headerlink" title="4.2.2.1 Tuple"></a>4.2.2.1 Tuple</h5><p>Tuple可以将多个类型的多个值放在一个类型里</p><p>Tuple的长度是固定的：一旦声明就无法改变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;, &#123;&#125;"</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h5 id="4-2-2-2-数组"><a href="#4-2-2-2-数组" class="headerlink" title="4.2.2.2 数组"></a>4.2.2.2 数组</h5><p>数组中每个元素的类型必须相同</p><p>数组的长度也是固定的</p><p><strong>数组的用处</strong></p><p>如果想让你的数据存放在stack上而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处；</p><p><strong>数组的类型</strong></p><p>[类型;  长度]</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>另一种声明数组的方法</p><p>如果数组的每个元素都相同，那么可以在：</p><p>在中括号里制定初始值；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>;<span class="number">5</span>]; </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>访问数组的元素</strong></p><p>数组是stack上分配的单个块的内存</p><p>可以使用索引来访问数组的元素（例子）</p><p>如果访问的索引超出了数组的范围，那么；</p><ul><li>编译会通过</li><li>运行会报错（runtime时会panic）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> mouths = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> index = [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> month = months[index[<span class="number">1</span>]]; <span class="comment">// 编译时不会报错，只有运行时才会检测</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, month); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust不会允许其继续访问相应的地址的内存；</p><h3 id="4-3-函数"><a href="#4-3-函数" class="headerlink" title="4.3 函数"></a>4.3 函数</h3><p>函数名  多个单词用下划线连接；</p><p>parameter 行参</p><p>arguments 实参</p><h4 id="4-3-1-函数的返回值"><a href="#4-3-1-函数的返回值" class="headerlink" title="4.3.1 函数的返回值"></a>4.3.1 函数的返回值</h4><p>在-&gt; 符号后边声明函数返回值的类型，但是不可以为返回值命名；</p><p>在rust里面，返回值</p><h3 id="4-4-注释"><a href="#4-4-注释" class="headerlink" title="4.4 注释"></a>4.4 注释</h3><h3 id="4-5-控制流"><a href="#4-5-控制流" class="headerlink" title="4.5 控制流"></a>4.5 控制流</h3><h4 id="4-5-1-if-else"><a href="#4-5-1-if-else" class="headerlink" title="4.5.1 if else"></a>4.5.1 if else</h4><p>match 重构多重if else语句</p><h4 id="4-5-2-循环"><a href="#4-5-2-循环" class="headerlink" title="4.5.2 循环"></a>4.5.2 循环</h4><p>Rust 提供了三种循环： loop， while 和 for</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">loop</span>&#123; <span class="comment">// 无限循环；</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">   <span class="keyword">while</span> number !== <span class="number">0</span> &#123;</span><br><span class="line">     <span class="comment">///</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-2-1-使用for循环遍历集合"><a href="#4-5-2-1-使用for循环遍历集合" class="headerlink" title="4.5.2.1 使用for循环遍历集合"></a>4.5.2.1 使用for循环遍历集合</h5><p>由于for循环的安全，简洁性，所以它在Rust里用的最多；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子： 用for循环显示倒计时的例子</strong></p><p>载入标准库</p><p>Range</p><p>指定一个开始数字和一个结束数字，Range可以生成它们之间的数字（不含结束）</p><p>rev方法可以反转Range</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"LIFTOFF!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-所有权"><a href="#5-所有权" class="headerlink" title="5. 所有权"></a>5. 所有权</h2><p>所有权是Rust最独特的特性，它让Rust无需GC就可以保证内存安全；</p><p>所有程序在运行时都必须管理它们使用计算机内存的方式</p><ul><li>有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存</li><li>在其他语言中，程序员必须显式地分配和释放内存；</li></ul><p>Rust采用了第三种方式</p><ul><li>内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则；</li><li>当程序运行时，所有权特性不会减慢程序的运行速度；</li></ul><h3 id="5-1-stack-vs-heap"><a href="#5-1-stack-vs-heap" class="headerlink" title="5.1 stack vs heap"></a>5.1 stack vs heap</h3><p>在像Rust这样的系统级编程语言里，一个值是在stack上还是在heap上对语言的行为和你为什么要做某些决定是有更大的影响的；</p><p>在你的代码运行的时候，stack 和 heap都是你可用的内存，但他们的结构很不相同；</p><p><strong>存储数据</strong></p><p>stack按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO）</p><ul><li>添加数据叫做压入栈</li><li>移除数据叫做弹出栈</li></ul><p>所有存储在Stack上的数据必须拥有已知的固定的大小；</p><ul><li>编译时大小未知的数据或运行时大小可能发生变化的数据必须存在heap上</li></ul><p>heap内存组织性差一点；</p><ul><li>当你把数据放入heap时，你会请求一定数量的空间</li><li>操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址</li><li>这个过程叫做heap上进行分配，有时仅仅称为“分配”</li></ul><p>把值压到stack上不叫分配</p><p>因为指针是已知固定大小的，可以把指针存放在stack上。</p><ul><li>但如果想要实际数据，你必须使用指针来定位；</li></ul><p>把数据压到stack上要比在heap上分配快得多：</p><ul><li>因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在stack的顶端</li></ul><p>在heap上分配空间需要做更多的工作：</p><ul><li>操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配；</li></ul><p><strong>访问数据</strong></p><p>访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据；</p><ul><li>对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快</li><li>如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack上）</li><li>如果数据之间的距离比较远，那么处理速度就会慢一些（heap上）<ul><li>在heap上分配大量的空间也是需要时间的；</li></ul></li></ul><p><strong>函数调用</strong></p><p>调用函数时，值被传入到函数（也包括指向heap的指针），函数本地的变量被压到stack上，当函数结束后，这些值会从stack上弹出；</p><h3 id="5-2-所有权存在的原因"><a href="#5-2-所有权存在的原因" class="headerlink" title="5.2 所有权存在的原因"></a>5.2 所有权存在的原因</h3><h4 id="5-2-1-所有权解决的问题"><a href="#5-2-1-所有权解决的问题" class="headerlink" title="5.2.1 所有权解决的问题"></a>5.2.1 所有权解决的问题</h4><p>跟踪代码的哪些部分正在使用heap的哪些数据；</p><p>最小化heap上的重复数据量</p><p>情理heap上未使用的数据以避免空间不足</p><p>一旦懂得所有权，那么就不需要经常去想stack或heap了；</p><p>但是知道管理heap数据是所有权存在的原因，这有助于理解它为什么会这样工作；</p><h3 id="5-3-所有权规则"><a href="#5-3-所有权规则" class="headerlink" title="5.3 所有权规则"></a>5.3 所有权规则</h3><p>每个值都有一个变量，这个变量是该值的所有者；</p><p>每个值同时只能有一个所有者；</p><p>当所有者超出作用域（scope）时，该值将被删除；</p><h4 id="5-3-1-变量作用域"><a href="#5-3-1-变量作用域" class="headerlink" title="5.3.1 变量作用域"></a>5.3.1 变量作用域</h4><p>scope就是程序中一个项目的有效范围</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="comment">// s不可用</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">"hello"</span>; <span class="comment">// s 可用</span></span><br><span class="line">  <span class="comment">// 可以对s进行相关操作</span></span><br><span class="line">&#125; <span class="comment">// s作用域到此结束， s不再可用；</span></span><br></pre></td></tr></table></figure><h4 id="5-3-2-String类型"><a href="#5-3-2-String类型" class="headerlink" title="5.3.2 String类型"></a>5.3.2 String类型</h4><p>Rust还有第二种字符串类型： String</p><ul><li>在heap上分配，能够存储在编译时未知数量的文本；</li></ul><h5 id="5-3-2-1-创建String类型的值"><a href="#5-3-2-1-创建String类型的值" class="headerlink" title="5.3.2.1 创建String类型的值"></a>5.3.2.1 创建String类型的值</h5><blockquote><p>可以使用from函数从字符串字面值创建出String类型</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">// :: 表示from是String类型下的函数</span></span><br><span class="line"><span class="comment">// 这类字符串是可以被修改的；</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">  s.push_str(<span class="string">", world"</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s); <span class="comment">// hi, world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-2-内存和分配"><a href="#5-3-2-2-内存和分配" class="headerlink" title="5.3.2.2 内存和分配"></a>5.3.2.2 内存和分配</h5><p><strong>为什么string类型的值可以修改，而字符串字面值不能修改</strong></p><ul><li>因为它们处理内存的方式不同；</li></ul><p>字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里；</p><ul><li>速度快、高效，是因为其不可变性；</li></ul><p>String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容：</p><ul><li><p>操作系统必须在运行时来请求内存，</p><ul><li>这步通过调用String::from来实现</li></ul></li><li><p>当用完String之后，需要使用某种方式将内存返回给操作系统</p><ul><li><p>这步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存</p></li><li><p>没有GC，就需要我们去识别内存何时不再使用，并调用代码将它返回；</p><ul><li>如果忘了，那就浪费内存</li><li>如果提前做了，变量就会非法</li><li>如果做了两次，就是Bug，必须一次分配对应一次释放；</li></ul></li></ul></li></ul><p>Rust采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统；</p><ul><li>drop函数</li></ul><p>当变量走出作用域的时候，会调用drop函数</p><h3 id="5-4-变量和数据交互的方式"><a href="#5-4-变量和数据交互的方式" class="headerlink" title="5.4 变量和数据交互的方式"></a>5.4 变量和数据交互的方式</h3><h4 id="5-4-1-移动（Move）"><a href="#5-4-1-移动（Move）" class="headerlink" title="5.4.1 移动（Move）"></a>5.4.1 移动（Move）</h4><blockquote><p>多个变量可以与同一个数据使用一种独特的方式来交互；</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// borrow of moved value: `s`</span></span><br><span class="line">    <span class="keyword">let</span> s2 = s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s2); <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个String由3部分组成：<ul><li>一个指向存放字符串内容的内存的指针 ptr</li><li>一个长度 len</li><li>一个容量 capacity</li></ul></li></ul><p><img src="heap01.png" alt="image-20210302114049906"></p><ul><li>上面这些东西放在stack上</li><li>存放字符串内容的部分在heap上</li><li>长度len，就是存放字符串内容所需的字节数；</li></ul><p><img src="heap02.png" alt="image-20210302130115114"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure><p>当把s1赋给s2，String的数据被复制了一份：</p><ul><li>在stack上复制了一份指针、长度、容量</li><li>并没有复制指针所指向的heap上的数据</li></ul><p>当变量离开作用域时，Rust会自动调用drop函数，并将变量使用的heap内存释放；</p><p>当s1、s2离开作用域时，它们都会尝试释放相同的内存</p><ul><li>会引起二次释放（double free）的bug</li></ul><p>rust为了保证内存安全：</p><ul><li>Rust没有尝试复制被分配的内存</li><li>Rust让s1失效<ul><li>当s1离开作用域的时候，rust不需要释放任何东西；</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// borrow of moved value: `s`</span></span><br><span class="line">    <span class="keyword">let</span> s2 = s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s2); <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-2-浅拷贝和深拷贝"><a href="#5-4-2-浅拷贝和深拷贝" class="headerlink" title="5.4.2 浅拷贝和深拷贝"></a>5.4.2 浅拷贝和深拷贝</h4><p>浅拷贝</p><p>深拷贝</p><p>你也许会将复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以我们用一个新的术语：移动（Move）</p><p>隐含的一个设计原则： Rust不会自动创建数据的深拷贝</p><ul><li>就运行时性能而言，任何自动赋值的操作都是廉价的；</li></ul><h4 id="5-4-3-变量和数据交互的方式：克隆（Clone）"><a href="#5-4-3-变量和数据交互的方式：克隆（Clone）" class="headerlink" title="5.4.3 变量和数据交互的方式：克隆（Clone）"></a>5.4.3 变量和数据交互的方式：克隆（Clone）</h4><p>如果真想对heap上面的String数据进行深度拷贝，而不仅仅是Stack上的数据，可以使用clone方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; borrow of moved value: &#96;s&#96;</span><br><span class="line">    let s2 &#x3D; s;</span><br><span class="line">    let s3 &#x3D; s2.clone();</span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, s2, s3); &#x2F;&#x2F; hello hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clone 相当于无论是Stack上还是heap上的数据，都统统复制一遍</p><p><img src="heap03.png" alt="image-20210302131623712"></p><h4 id="5-4-4-复制"><a href="#5-4-4-复制" class="headerlink" title="5.4.4 复制"></a>5.4.4 复制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x, y); <span class="comment">// 5, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clone 比较消耗资源；主要还是针对heap上的数据操作。</p><p>而针对Stack上的数据，只需要复制就好了；</p><h5 id="5-4-4-1-Copy-trait"><a href="#5-4-4-1-Copy-trait" class="headerlink" title="5.4.4.1 Copy trait"></a>5.4.4.1 Copy trait</h5><p>Rust 提供了一个名为Copy的 trait，trait简单理解为接口</p><p>Copy trait，可以用于像整数这样完全存放在stack上面的类型；</p><p>如果一个类型实现了Copy这个trait，那么旧的变量在赋值后仍然可用；</p><p>如果一个类型或者该类型的一部分实现了Drop trait，那么Rust不允许让它再实现Copy trait了</p><h5 id="5-4-4-2-一些拥有Copy-trait的类型"><a href="#5-4-4-2-一些拥有Copy-trait的类型" class="headerlink" title="5.4.4.2 一些拥有Copy trait的类型"></a>5.4.4.2 一些拥有Copy trait的类型</h5><p>任何简单标量的组合类型都可以是Copy的</p><p>任何需要分配内存或某种资源的都不是Copy的</p><p>一些拥有Copy trait的类型</p><ul><li>所有整数类型，例如 u32</li><li>bool</li><li>char</li><li>所有浮点类型 例如f64</li><li>Tuple（元组），如果其所有的字段都是Copy的<ul><li>(i32,i32)是</li><li>(I32, String) 不是</li></ul></li></ul><h3 id="5-5-所有权与函数"><a href="#5-5-所有权与函数" class="headerlink" title="5.5 所有权与函数"></a>5.5 所有权与函数</h3><p>在语义上，将值传递给函数和把值赋给变量是类似的：</p><h4 id="5-5-1-将值传递给函数将发生移动或复制"><a href="#5-5-1-将值传递给函数将发生移动或复制" class="headerlink" title="5.5.1 将值传递给函数将发生移动或复制"></a>5.5.1 将值传递给函数将发生移动或复制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"alex"</span>);</span><br><span class="line">    take_ownership(s);</span><br><span class="line">    <span class="comment">// 从这里之后，s的值被移动到函数里面；</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    makes_copy(x);</span><br><span class="line">    <span class="comment">// x值是被拷贝到函数里面</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;"</span>, x);</span><br><span class="line">    <span class="comment">// x 被回收；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_ownership</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125; <span class="comment">// rust会调用drop ，str占用的内存会被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">makes_copy</span></span>(<span class="built_in">str</span>: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125; <span class="comment">// 对于i32这种基础类型，不会有额外的事情发生</span></span><br></pre></td></tr></table></figure><h4 id="5-5-2-返回值与作用域"><a href="#5-5-2-返回值与作用域" class="headerlink" title="5.5.2 返回值与作用域"></a>5.5.2 返回值与作用域</h4><p>函数在返回值的过程中同样也会发生所有权的转移</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个变量的所有权总是遵循同样的模式：</p><ul><li>把一个值赋给其它变量时就会发生移动</li><li>当一个包含heap数据的变量离开作用域时，它的值就会被drop函数清理，除非数据的所有权移动到另一个变量上了；</li></ul><h3 id="5-6-引用"><a href="#5-6-引用" class="headerlink" title="5.6 引用"></a>5.6 引用</h3><p>如果让函数使用某个值，但不获得其所有权？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"alex"</span>);</span><br><span class="line">  <span class="keyword">let</span> (s2, len) = calculate_length(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;"</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;<span class="comment">// usize 跟架构有关的无符号整数类型</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">str</span>.len();</span><br><span class="line">  (<span class="built_in">str</span>, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust有一个特性叫做 <code>引用（Reference)</code></p><h4 id="5-6-1-引用"><a href="#5-6-1-引用" class="headerlink" title="5.6.1 引用"></a>5.6.1 引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="symbol">'hi</span>');</span><br><span class="line">  <span class="keyword">let</span> len = calcuate_length(&amp;s1); <span class="comment">//&amp;s1并不拥有s1，所有不会转移s1的所有权，而是将s1的引用传给了 函数， 当作用域结束之后，s1并不会被清理掉</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calcuate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125; <span class="comment">// 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，</span></span><br><span class="line"><span class="comment">// 所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权</span></span><br><span class="line"><span class="comment">// 这种将引用作为函数参数的行为，我们就将其称为借用；</span></span><br></pre></td></tr></table></figure><p><img src="yinyong01.png" alt="image-20210303150138448"></p><p>如上图，s就是s1的引用，</p><p>s实际上是一个指针，它指向s1。</p><p>s1也是一个指针，它指向存在heap上的真实的内容；</p><p><code>calcuate_length</code> 参数的类型是 &amp; String而不是String， &amp;符号就表示引用：允许你引用某些值而不取得其所有权</p><h4 id="5-6-2-借用"><a href="#5-6-2-借用" class="headerlink" title="5.6.2 借用"></a>5.6.2 借用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calcuate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125; <span class="comment">// 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，</span></span><br></pre></td></tr></table></figure><ul><li>所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权</li><li>这种将引用作为函数参数的行为，我们就将其称为借用；</li></ul><p><strong>是否可以修改借用的东西？</strong></p><ul><li>不行</li><li>和变量一样，引用默认也是不可变的</li><li>只要设置mut，就可以修改借用的东西</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// 设置为可变的</span></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-3-可变引用"><a href="#5-6-3-可变引用" class="headerlink" title="5.6.3 可变引用"></a>5.6.3 可变引用</h4><p>可变引用有一个重要的限制： 在特定作用域内，对某一块数据，只能有一个可变的引用；</p><p>这样做的好处是可在编译时防止数据竞争；</p><p><strong>数据竞争是如何发生的</strong></p><ul><li>两个或多个指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有使用任何机制来同步对数据的访问</li></ul><p><strong>可以通过创建新的作用域，来允许非同时的创建多个可变引用（例子）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="symbol">'alex</span>');</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> s2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可以同时拥有一个可变引用和一个不变的引用</strong></p><ul><li>多个不变的引用是可以的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="symbol">'alex</span>');</span><br><span class="line">  <span class="keyword">let</span> r1 = &amp;s;</span><br><span class="line">  <span class="keyword">let</span> r2 = &amp;s;</span><br><span class="line">  <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s; <span class="comment">// error! 不可以同时拥有可变引用和不可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-4-悬垂引用-Dangling-References"><a href="#5-6-4-悬垂引用-Dangling-References" class="headerlink" title="5.6.4 悬垂引用 Dangling References"></a>5.6.4 悬垂引用 Dangling References</h4><blockquote><p>一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了；</p></blockquote><p>Rust里，编译器可保证引用永远都不是悬空引用；</p><ul><li>如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域；</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> r = dangle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// compiler error：</span></span><br><span class="line">  <span class="keyword">let</span> s = Sring::from(<span class="symbol">'alex</span>');</span><br><span class="line">  &amp;s</span><br><span class="line">&#125;<span class="comment">// 随着s离开作用域，会调用drop释放内存，而对它的引用 &amp;s 却继续返回了。所以这个引用指向了一个被释放掉了的内存地址；即悬空指针，但Rust在编译阶段就规避掉了；</span></span><br></pre></td></tr></table></figure><h4 id="5-6-5-引用的规则"><a href="#5-6-5-引用的规则" class="headerlink" title="5.6.5 引用的规则"></a>5.6.5 引用的规则</h4><p>在任何给定的时刻，只能满足下列条件之一：</p><ul><li>一个可变的引用</li><li>任意数量不可变的引用</li></ul><p>引用必须一直有效</p><h3 id="5-7-切片-slice"><a href="#5-7-切片-slice" class="headerlink" title="5.7 切片 slice"></a>5.7 切片 slice</h3><blockquote><p>Rust的另外一种不持有所有权的数据类型：切片（slice）</p></blockquote><p>编写一个函数：</p><ul><li>它接收字符串作为参数</li><li>返回它在这个字符串里找到的第一个单词</li><li>如果函数没找到任何空格，那么整个字符串就被返回；</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello alex"</span>);</span><br><span class="line">    <span class="keyword">let</span> name_index = first_world(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, name_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes(); <span class="comment">// 转成字节数组</span></span><br><span class="line">  <span class="comment">// iter 方法为bytes创建一个迭代器，这个方法依次返回集合中的每个元素。然后</span></span><br><span class="line">  <span class="comment">// 调用的enumerate方法，它会将iter方法的结果进行包装，并把结果作为tuple的一部分进行返回。</span></span><br><span class="line">  <span class="comment">// 元祖的第一个元素，就是enumerate遍历的索引 i，第二个元素就是引用 item。</span></span><br><span class="line">  <span class="comment">// (i, &amp;item) 实际上是模式匹配之后的解构</span></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而上面的函数设计是有问题的， name_index 和 s 太过耦合了。当s被清空之后，name_index的值就不再有意义了；</p><p>那如何确保 s 和 name_index 之间的同步性呢；</p><p><strong>解决方案： 字符串切片</strong></p><h4 id="5-7-1-字符串切片"><a href="#5-7-1-字符串切片" class="headerlink" title="5.7.1 字符串切片"></a>5.7.1 字符串切片</h4><blockquote><p>字符串切片是指向字符串中一部分内容的引用</p></blockquote><p>形式： [开始索引…结束索引]</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>几个语法糖</p><p>注意：</p><ul><li>字符串切片的范围索引必须发生在有效的UTF-8字符边界内；</li><li>如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello alex"</span>);</span><br><span class="line">    <span class="keyword">let</span> name_index = first_world(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, name_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;str 字符串切片</span></span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-7-2-字符串字面值是切片"><a href="#5-7-2-字符串字面值是切片" class="headerlink" title="5.7.2 字符串字面值是切片"></a>5.7.2 字符串字面值是切片</h4><p>字符串字面值被直接存储在二进制程序中；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"he"</span> <span class="comment">// s 为 &amp;str类型，即字符串切片</span></span><br><span class="line"><span class="comment">// s就是一个指向二进制程序 特定位置的切片，而&amp;str是不可变的引用；</span></span><br></pre></td></tr></table></figure><p>变量s的类型是&amp;str， 它是一个指向二进制程序特定位置的切片</p><ul><li>&amp;str是不可变引用，所以字符串字面值也是不可变的；</li></ul><h4 id="5-7-3-将字符串切片作为参数传递"><a href="#5-7-3-将字符串切片作为参数传递" class="headerlink" title="5.7.3 将字符串切片作为参数传递"></a>5.7.3 将字符串切片作为参数传递</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_string = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> my_string_literal = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入字符串字面值的 slice</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值 **就是** 字符串 slice，</span></span><br><span class="line">    <span class="comment">// 这样写也可以，即不使用 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> word = first_word(my_string_literal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_world</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;str 字符串切片</span></span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能；</p><h2 id="6-struct"><a href="#6-struct" class="headerlink" title="6. struct"></a>6. struct</h2><h3 id="6-1-定义并实例化struct"><a href="#6-1-定义并实例化struct" class="headerlink" title="6.1 定义并实例化struct"></a>6.1 定义并实例化struct</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    emila: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"alex"</span>),</span><br><span class="line">        emila: <span class="built_in">String</span>::from(<span class="string">"123@qq.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">12</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦struct的实例是可变的，那么实例中所有的字段都是可变的。不允许部分可变，部分不可变</p><h4 id="6-1-1-tuple-struct"><a href="#6-1-1-tuple-struct" class="headerlink" title="6.1.1 tuple struct"></a>6.1.1 tuple struct</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>black和origin是不同的类型，是不同tuple struct的实例</p><h4 id="6-1-2-Unit-Like-Struct（没有任何字段）"><a href="#6-1-2-Unit-Like-Struct（没有任何字段）" class="headerlink" title="6.1.2 Unit-Like Struct（没有任何字段）"></a>6.1.2 Unit-Like Struct（没有任何字段）</h4><ul><li>可以定义没有任何字段的struct，叫做Unit-Like Struct（因为与（），单元类型类似）</li><li>适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据</li></ul><h4 id="6-1-3-struct-数据的所有权"><a href="#6-1-3-struct-数据的所有权" class="headerlink" title="6.1.3 struct 数据的所有权"></a>6.1.3 struct 数据的所有权</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    emila: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的字段使用了String 而不是 &amp;str<ul><li>该struct实例拥有其所有的数据</li><li>只要struct实例是有效的，那么里面的字段数据也是有效的</li></ul></li><li>struct里也可以存放引用，但这需要使用生命周期；<ul><li>声明周期保证只要struct实例是有效的，那么里面的引用也是有效的；</li><li>如果struct里面存储引用，而不使用生命周期，就会报错</li></ul></li></ul><h4 id="6-1-4-计算面积的例子"><a href="#6-1-4-计算面积的例子" class="headerlink" title="6.1.4 计算面积的例子"></a>6.1.4 计算面积的例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rect: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rect.height * rect.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, area(&amp;rect));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-5-几种模式"><a href="#6-1-5-几种模式" class="headerlink" title="6.1.5 几种模式"></a>6.1.5 几种模式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::fmt::Display</span><br><span class="line">std::fmt::<span class="built_in">Debug</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line">&#123;:?&#125;</span><br><span class="line">&#123;:#?&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-struct的方法"><a href="#6-2-struct的方法" class="headerlink" title="6.2 struct的方法"></a>6.2 struct的方法</h3><p>方法和函数类似： fn关键字、名称、参数、返回值</p><p>方法与函数不同之处：</p><ul><li>方法是在struct（或enum、trait对象）的上下文中定义</li><li>第一个参数是self，表示方法被调用的struct实例</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123; <span class="comment">// impl块中定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 方法第一个参数可以是 &amp;self</span></span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-1-方法调用的运算符"><a href="#6-2-1-方法调用的运算符" class="headerlink" title="6.2.1 方法调用的运算符"></a>6.2.1 方法调用的运算符</h4><p>在调用方法时， Rust根据情况自动添加 &amp;、 &amp;mut 或 *， 以便object可以匹配方法的签名；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两行代码效果相同：</span></span><br><span class="line">p1.dis(&amp;p2);</span><br><span class="line">(&amp;p1).dis(&amp;p2);</span><br></pre></td></tr></table></figure><h4 id="6-2-2-方法参数"><a href="#6-2-2-方法参数" class="headerlink" title="6.2.2 方法参数"></a>6.2.2 方法参数</h4><p>方法可以有多个参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hole</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height &gt; other.height &amp;&amp; <span class="keyword">self</span>.width &gt; other.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect.area());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect1.can_hole(&amp;rect1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-关联函数"><a href="#6-3-关联函数" class="headerlink" title="6.3 关联函数"></a>6.3 关联函数</h3><p>可以在impl块里定义不把self作为第一个参数的函数，它们叫关联函数（不是方法）</p><ul><li>例如： String::from()</li></ul><p>关联函数通常用于构造器</p><ul><li>::符号<ul><li>关联函数</li><li>模块创建的命名空间</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = Rectangle::square(<span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-枚举与模式匹配"><a href="#7-枚举与模式匹配" class="headerlink" title="7. 枚举与模式匹配"></a>7. 枚举与模式匹配</h2><h3 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ip</span></span> &#123;</span><br><span class="line">V4,V6</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Ip::V4;</span><br><span class="line"><span class="keyword">let</span> b = Ip::V6;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"::1"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-1-1-将数据附加到枚举的变体中"><a href="#7-1-1-将数据附加到枚举的变体中" class="headerlink" title="7.1.1 将数据附加到枚举的变体中"></a>7.1.1 将数据附加到枚举的变体中</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure><p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p><p>优点：</p><ul><li>不需要额外使用struct</li><li>每个变体可以拥有不同的类型以及关联的数据量</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ip</span></span> &#123;</span><br><span class="line">V4(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>),</span><br><span class="line">V6(<span class="built_in">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-option枚举"><a href="#7-2-option枚举" class="headerlink" title="7.2 option枚举"></a>7.2 option枚举</h3><p>定义于标准库中</p><p>在Prelude中</p><p>描述了： 某个值可能存在（某种类型）或不存在的情况</p><h4 id="7-2-1-Option"><a href="#7-2-1-Option" class="headerlink" title="7.2.1 Option"></a>7.2.1 Option<T></h4><p>Rust中类似Null概念的枚举 - Option<T></p><p>Rust没有Null</p><p>其它语言中：</p><ul><li>Null是一个值，它表示“没有值”</li><li>一个变量可以处于两种状态： 空值（null）、非空</li></ul><p>Null引用： Billion Dollar Mistake</p><p>Null的问题在于： 当你尝试像使用非Null值那样使用Null值的时候，就会引起某种错误</p><p>Null的概念还是有用的：因某种原因而变为无效或缺失的值；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库中的定义：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它包含在Prelude（预导入模块）中，可直接使用；</p><ul><li>Option<T></li><li>Some<T></li><li>None</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure><p><strong>Option<T>比Null好在哪？</strong></p><p>Option<T>和T是不同的类型，不可以把Option<T>直接当成T</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> x:<span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> sum = x + y; <span class="comment">// error: cannot add Option&lt;i8&gt; to i8;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若想使用Option<T>中的 T，必须将它转换为 T；</p><p>这就避免了其它语言中最常见的那个错误；那就是假设某个值存在，但它实际上为Null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比如在C#</span><br><span class="line">string a &#x3D; null;</span><br><span class="line">string b &#x3D; a + &quot;12345&quot;; &#x2F;&#x2F; error</span><br></pre></td></tr></table></figure><h3 id="7-3-match"><a href="#7-3-match" class="headerlink" title="7.3 match"></a>7.3 match</h3><p>控制流运算符 - match</p><ul><li>match允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码；</li><li>模式可以是字面量、变量名、通配符</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-1-绑定值的模式"><a href="#7-3-1-绑定值的模式" class="headerlink" title="7.3.1 绑定值的模式"></a>7.3.1 绑定值的模式</h4><p>匹配的分支可以绑定到被匹配对象的部分值</p><ul><li>因此，可以从enum变体中提取值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"penny"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = Coin::Quarter(UsState::Alabama);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value_in_cents(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2-匹配Option"><a href="#7-3-2-匹配Option" class="headerlink" title="7.3.2 匹配Option"></a>7.3.2 匹配Option<T></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">  <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-3-match必须穷举所有可能"><a href="#7-3-3-match必须穷举所有可能" class="headerlink" title="7.3.3 match必须穷举所有可能"></a>7.3.3 match必须穷举所有可能</h4><p>_ 通配符： 替代其余没有列出的值；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-if-let"><a href="#7-4-if-let" class="headerlink" title="7.4 if let"></a>7.4 if let</h3><p>处理只关心一种匹配而忽略其它匹配的情况</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="comment">// match 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if let 相当于只处理一种匹配的情况，其它的分支就不关心了</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>if let 优缺点</strong></p><p>更少的代码，更少的锁紧，更少的模版代码</p><p>放弃了穷举的可能</p><p>可以把 if let 看作是 match的语法糖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if let 搭配 else</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"others"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Package-Crate-和-Module"><a href="#8-Package-Crate-和-Module" class="headerlink" title="8. Package, Crate 和 Module"></a>8. Package, Crate 和 Module</h2><p>模块系统：</p><ul><li>Package（包）， Cargo的特性，让你构建、测试、共享crate；</li><li>Crate（单元包）， 一个模块树，它可产生一个library或执行文件；</li><li>Module（模块）， use： 让你控制代码的组织、作用域、私有路径；</li><li>path（路径）： 为struct、function 或module 等项命名的方式；</li></ul><h3 id="8-1-Package-和-Crate"><a href="#8-1-Package-和-Crate" class="headerlink" title="8.1 Package 和 Crate"></a>8.1 Package 和 Crate</h3><p>crate上面是package，</p><p><strong>Crate的类型</strong></p><ul><li>binary</li><li>library</li></ul><p><strong>Crate Root</strong></p><ul><li>是源代码文件</li><li>Rust编译器从这里开始，组成你的Crate的根Module</li></ul><p><strong>一个Package</strong></p><ul><li>包含1个Cargo.toml, 它描述了如何构建这些Crates；</li><li>只能包含0-1个library crate；</li><li>可以包含任意数量的binary crate；</li><li>必须至少包含一个crate（library或binary）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; cargo new my-pro</span><br><span class="line"><span class="comment"># create binary (application) `my-pro` package</span></span><br></pre></td></tr></table></figure><h4 id="8-1-1-Cargo的惯例"><a href="#8-1-1-Cargo的惯例" class="headerlink" title="8.1.1 Cargo的惯例"></a>8.1.1 Cargo的惯例</h4><p>src/main.rs</p><ul><li>src/main.rs    // package 的入口文件<ul><li>Binary crate 的 crate root （cargo会默认让 main.rs做为crate的根）</li><li>crate名与package名相同 （也是指这个binary crate的名和包名相同，都是my-pro）</li></ul></li><li>src/lib.rs<ul><li>Package 包含一个library crate</li><li>library crate 的 crate root</li><li>crate名与package名相同 （也都是my-pro）</li></ul></li></ul><p>复习：</p><p>如果有main.rs,就说明有一个 binary crate。</p><p>如果有lib.rs , 就说明有一个library crate。</p><p>两个都是入口文件，都是crate的根。而crate名都与package名相同。</p><p>cargo会把crate root文件交给rustc 来构建library 或 binary</p><p>一个Package可以同时包含main.rs 和 lib.rs, </p><ul><li>表明，这个package含有一个 binary crate，一个library crate。名称都与package名相同</li><li>一个package可以有多个binary crate<ul><li>文件都放在src/bin</li><li>每个文件是单独的binary crate</li></ul></li></ul><h3 id="8-2-Crate的作用"><a href="#8-2-Crate的作用" class="headerlink" title="8.2 Crate的作用"></a>8.2 Crate的作用</h3><blockquote><p>将相关功能组合到一个作用域内，便于在项目间进行共享，也能防止命名冲突</p></blockquote><p>例如： rand crate，访问它的功能需要通过它的名字： rand</p><h3 id="8-3-定义module来控制作用域和私有性"><a href="#8-3-定义module来控制作用域和私有性" class="headerlink" title="8.3 定义module来控制作用域和私有性"></a>8.3 定义module来控制作用域和私有性</h3><p><strong>Module</strong></p><p>在一个crate内，将代码进行分组；</p><p>增加可读性，易于复用；</p><p>控制项目（item）的私有性，public、private</p><h4 id="8-3-1-建立module"><a href="#8-3-1-建立module" class="headerlink" title="8.3.1 建立module"></a>8.3.1 建立module</h4><ul><li>mod 关键字{}</li><li>可嵌套</li><li>可包含其它项（struct、enum、常量、trait、函数等）的定义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cargo new my-pro</span></span><br><span class="line">|- crate</span><br><span class="line">|- front_of_house</span><br><span class="line">|- hosting</span><br><span class="line">|- add_to_waitlist</span><br><span class="line">|- seat_at_table</span><br><span class="line">|- serving</span><br><span class="line">|- take_over</span><br><span class="line">|- serve_order</span><br><span class="line">|- take_payment</span><br></pre></td></tr></table></figure><p>main.rs   lib.rs 都叫crate roots；</p><ul><li>这两个文件（任意一个）的内容形成了名为crate的模块，位于整个模块树的根部；</li><li>整个模块树在隐式的crate模块下</li></ul><h3 id="8-4-path"><a href="#8-4-path" class="headerlink" title="8.4 path"></a>8.4 path</h3><p>根其它语言里面的命名空间有点类似</p><ul><li>为了在Rust的模块中找到某个条目，需要使用路径</li><li>路径的两种形式<ul><li>绝对路径： 从crate root开始，使用crate名或字面值crate</li><li>相对路径： 从当前模块开始，使用self，super或当前模块的标识符；</li></ul></li><li>路径至少由一个标识符组成，标识符之间使用::</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟级别可以不加 pub 互相调用</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pub 关键字 设置该module为公共的</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Absolute path</span></span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Relative path</span></span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-1-私有边界（private-boundary）"><a href="#8-4-1-私有边界（private-boundary）" class="headerlink" title="8.4.1 私有边界（private boundary）"></a>8.4.1 私有边界（private boundary）</h4><p>模块不仅可以组织代码，还可以定义私有边界</p><p>如果想把 函数 或 struct 等设为私有，可以将它放到某个模块中；</p><p>Rust中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的；</p><ul><li>父级模块无法访问子模块中的私有条目<ul><li>私有条目都是隐藏实现细节，不允许其它模块进行访问。</li><li>子模块里可以使用所有祖先模块中的条目</li></ul></li></ul><h4 id="8-4-2-super关键字"><a href="#8-4-2-super关键字" class="headerlink" title="8.4.2 super关键字"></a>8.4.2 super关键字</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ls..</span><br><span class="line">$&gt; hello hello.c</span><br><span class="line">$&gt; ../hello <span class="comment"># hello</span></span><br></pre></td></tr></table></figure><ul><li>super关键字</li></ul><p>在Rust中，用来访问父级模块路径中的内容，类似文件系统中的..</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fix_incorrect_order</span></span>()&#123;</span><br><span class="line">    cook_order();</span><br><span class="line">    super::serve_order(); <span class="comment">// 上一级模块的 serve_order 方法</span></span><br><span class="line">    crate::serve_order(); <span class="comment">// 绝对路径的写法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">cook_order</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-3-use关键字"><a href="#8-4-3-use关键字" class="headerlink" title="8.4.3 use关键字"></a>8.4.3 use关键字</h4><p>可以使用use关键字将路径导入到作用域内</p><ul><li>仍遵循私有性规则</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用use来指定相对路径</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 函数 指定到父级模块； hosting</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用use来指定绝对路径</span></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting;</span><br></pre></td></tr></table></figure><ul><li>struct, enum 其它： 指定完整路径（指定到本身）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"> map.insert(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同名条目： 指定到父级</li></ul><h5 id="8-4-3-1-使用pub-use重新导出名称"><a href="#8-4-3-1-使用pub-use重新导出名称" class="headerlink" title="8.4.3.1 使用pub use重新导出名称"></a>8.4.3.1 使用pub use重新导出名称</h5><p>使用use将路径（名称）导入到作用域内后，该名称在此作用域内是私有的；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting; <span class="comment">// 从此，外部模块也能访问 hosting了</span></span><br><span class="line"><span class="comment">// 函数 指定到父级模块； hosting</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-4-3-2-使用嵌套路径清理大量的use语句"><a href="#8-4-3-2-使用嵌套路径清理大量的use语句" class="headerlink" title="8.4.3.2 使用嵌套路径清理大量的use语句"></a>8.4.3.2 使用嵌套路径清理大量的use语句</h5><p>如果使用同一个包或模块下的多个条目（例子）</p><p>可使用嵌套路径在同一行内将上述条目进行引入：</p><ul><li>路径相同的部分::{路径差异的部分}</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use std::cmp::Ordering;</span></span><br><span class="line"><span class="comment">// use std::io;</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use std::io;</span></span><br><span class="line"><span class="comment">// use std::io::Write</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-4-4-通配符"><a href="#8-4-4-通配符" class="headerlink" title="8.4.4 通配符 *"></a>8.4.4 通配符 *</h4><p>使用 * 可以把路径中所有的公共条目都引入到作用域</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*</span><br></pre></td></tr></table></figure><p>谨慎使用</p><p>应用场景：</p><ul><li>测试，将所有被测试代码引入到tests模块</li><li>有时被用于预导入（prelude）模块</li></ul><h4 id="8-4-5-as关键字"><a href="#8-4-5-as关键字" class="headerlink" title="8.4.5  as关键字"></a>8.4.5  as关键字</h4><p>as关键字可以为引入的路径指定本地的别名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f2</span></span>() -&gt; IoResult&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-4-6-使用外部包（package）"><a href="#8-4-6-使用外部包（package）" class="headerlink" title="8.4.6 使用外部包（package）"></a>8.4.6 使用外部包（package）</h4><ol><li>cargo.toml 添加依赖的包（package）</li><li>use将特定条目引入作用域；</li></ol><h5 id="8-4-6-1-切换国内镜像"><a href="#8-4-6-1-切换国内镜像" class="headerlink" title="8.4.6.1 切换国内镜像"></a>8.4.6.1 切换国内镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; <span class="built_in">where</span> cargo</span><br><span class="line">$&gt; <span class="built_in">cd</span> /Users/xx/.cargo/</span><br><span class="line">$&gt; ls -a</span><br><span class="line">$&gt; vim config</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = <span class="string">"https://github.com/rust-lang/crates.io-index"</span></span><br><span class="line"></span><br><span class="line">replace-with = <span class="string">'tuna'</span></span><br><span class="line">[source.tuna]</span><br><span class="line">registry = <span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"</span></span><br><span class="line"></span><br><span class="line">[net]</span><br><span class="line">git-fetch-with-cli = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="8-5-将模块拆分为不同文件"><a href="#8-5-将模块拆分为不同文件" class="headerlink" title="8.5 将模块拆分为不同文件"></a>8.5 将模块拆分为不同文件</h3><p>将模块内容移动到其它文件</p><p>模块定义时，如果模块名后边是； ，而不是代码块</p><ul><li>Rust 会从与模块同名的文件中加载内容</li><li>模块树的结构不会变化</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- src</span><br><span class="line">|- /front_of_house</span><br><span class="line">|- hosting.rs</span><br><span class="line">|- front_of_houre.rs</span><br><span class="line">|- lib.rs</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"><span class="comment">// hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>随着模块逐渐变大，该技术让你可以把模块的内容移动到其它文件中；</p><h2 id="9-集合"><a href="#9-集合" class="headerlink" title="9. 集合"></a>9. 集合</h2><h3 id="9-1-Vector"><a href="#9-1-Vector" class="headerlink" title="9.1 Vector"></a>9.1 Vector</h3><p> Vec<T>,叫作vector</p><ul><li>由标准库提供</li><li>可存储多个值</li><li>只能存储相同类型的数据</li><li>值在内存中连续存放</li></ul><h4 id="9-1-1-创建"><a href="#9-1-1-创建" class="headerlink" title="9.1.1 创建"></a>9.1.1 创建</h4><p>Vec<T>  使用 vec! 宏</p><h4 id="9-1-2-所有权和借用规则"><a href="#9-1-2-所有权和借用规则" class="headerlink" title="9.1.2 所有权和借用规则"></a>9.1.2 所有权和借用规则</h4><p>不能在同一作用域内同时拥有可变和不可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line">  <span class="keyword">let</span> first = &amp;v[<span class="number">0</span>]; <span class="comment">// 不可变借用</span></span><br><span class="line">  v.push(<span class="number">6</span>); <span class="comment">// 可变的借用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector的工作原理： vec里面的元素在内存中的摆放是连续的，所以再往vec中添加一个元素的时候，在内存中就没有这么大的连续内存块。就可能将内存重新分配一下了，再找一个足够大的内存来放置这些添加了元素之后的vector，原来那块内存可能被释放掉或者重新分配，而first变量仍然指向原来的内存地址，这样的话，程序必然出现问题了；所以，借用规则防止类似的情况发生</p><h4 id="9-1-3-遍历"><a href="#9-1-3-遍历" class="headerlink" title="9.1.3 遍历"></a>9.1.3 遍历</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-4-vector-enum"><a href="#9-1-4-vector-enum" class="headerlink" title="9.1.4 vector+enum"></a>9.1.4 vector+enum</h4><p>使用enum来存储多种数据类型</p><ul><li>enum的变体可以附加不同类型的数据</li><li>enum的变体定义在同一个enum类型下</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="9-2-String"><a href="#9-2-String" class="headerlink" title="9.2 String"></a>9.2 String</h3><p>字符串困扰</p><ul><li>Rust倾向于暴露可能的错误</li><li>字符串数据结构复杂</li><li>UTF-8</li></ul><h4 id="9-2-1-定义"><a href="#9-2-1-定义" class="headerlink" title="9.2.1 定义"></a>9.2.1 定义</h4><p>Rust的核心语言层面，只有字符串类型：字符串切片 str （&amp;str）</p><ul><li>字符串切片： 对存储在其它地方、utf-8编码的字符串引用<ul><li>字符串字面值： 存储在二进制文件中，也是字符串切片</li></ul></li></ul><h4 id="9-2-2-String类型"><a href="#9-2-2-String类型" class="headerlink" title="9.2.2 String类型"></a>9.2.2 String类型</h4><p>来自标准库 而不是核心语言</p><ul><li>可增长，可修改，可拥有</li><li>UTF-8 编码</li></ul><h4 id="9-2-3-其它类型的字符串"><a href="#9-2-3-其它类型的字符串" class="headerlink" title="9.2.3 其它类型的字符串"></a>9.2.3 其它类型的字符串</h4><p>Rust标准库还包含了很多其它的字符串类型， OsString、OsStr、CString、CStr</p><ul><li>String vs Str后缀： 拥有或借用的变体</li><li>可存储不同编码的文本或在内存中以不同的形式展现</li></ul><h4 id="9-2-4-使用初始值创建String"><a href="#9-2-4-使用初始值创建String" class="headerlink" title="9.2.4 使用初始值创建String"></a>9.2.4 使用初始值创建String</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">"initial contents"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = data.to_string();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">"initial contents"</span>.to_string();</span><br><span class="line"><span class="comment">// 字符串字面值创建String</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"initial contents"</span>);</span><br></pre></td></tr></table></figure><h4 id="9-2-5-更新"><a href="#9-2-5-更新" class="headerlink" title="9.2.5 更新"></a>9.2.5 更新</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"bar"</span>);</span><br><span class="line">  s.push_str(&amp;s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">   <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"bar"</span>);</span><br><span class="line">   <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">   <span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// // 注意 s1 被移动了，不能继续使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为在使用了 +，实际上使用了类似 下面 add这样的方法,当然标准库里面是泛型方法，这里为了理解，给替换成string类型先</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, s:&amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span>&#123;...&#125; <span class="comment">// 参数1是 String，而不是切片，所以s1失去了所有权；</span></span><br></pre></td></tr></table></figure><p>标准库中的add使用了泛型</p><p>只能把&amp;str添加到String</p><p>解引用强制转换（deref coercion）</p><h4 id="9-2-6-format-连接多个字符串"><a href="#9-2-6-format-连接多个字符串" class="headerlink" title="9.2.6 format! 连接多个字符串"></a>9.2.6 format! 连接多个字符串</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="symbol">'tic</span>');</span><br><span class="line">  <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="symbol">'tac</span>');</span><br><span class="line">  <span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="symbol">'toe</span>');</span><br><span class="line">  <span class="keyword">let</span> s3 = s1 + <span class="string">"-"</span> + &amp;s2 + <span class="string">"-"</span> + &amp;s3;</span><br><span class="line">  <span class="comment">// 类似于</span></span><br><span class="line">  <span class="built_in">format!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3); <span class="comment">// format! 宏不会取得后续所有参数的所有权</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>format! 宏不会取得后续所有参数的所有权</p><h4 id="9-2-7-索引字符串"><a href="#9-2-7-索引字符串" class="headerlink" title="9.2.7 索引字符串"></a>9.2.7 索引字符串</h4><p>Rust字符串不支持索引；</p><h4 id="9-2-8-bytes，scalar-Values，-Grapheme-Clusters-字节、标量值、字形簇"><a href="#9-2-8-bytes，scalar-Values，-Grapheme-Clusters-字节、标量值、字形簇" class="headerlink" title="9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇"></a>9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> w = <span class="string">"नमस्ते"</span>;</span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> w.bytes()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    <span class="comment">// [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> w.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    <span class="comment">// ['न', 'म', 'स', '्', 'त', 'े']</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-9-Rust不允许对String进行索引最后一个原因"><a href="#9-2-9-Rust不允许对String进行索引最后一个原因" class="headerlink" title="9.2.9 Rust不允许对String进行索引最后一个原因"></a>9.2.9 Rust不允许对String进行索引最后一个原因</h4><ul><li>索引操作应消耗一个常量时间（O（1））</li><li>而String无法保证，需要遍历所有内容，来确定有多少个合法的字符</li></ul><h4 id="9-2-10-字符串切割"><a href="#9-2-10-字符串切割" class="headerlink" title="9.2.10 字符串切割"></a>9.2.10 字符串切割</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure><h3 id="9-3-HashMap"><a href="#9-3-HashMap" class="headerlink" title="9.3 HashMap"></a>9.3 HashMap</h3><p>对于实现Copy trait的类型（i32），值会被复制到HashMap中</p><p>对于拥有所有权的值（String），值会被移动，所有权会转移给HashMap</p><p>如果将值的引用插入到HashMap，值本身就不会移动</p><ul><li>在hashMap有效的期间，被引用的值必须保持有效</li></ul><h4 id="9-3-1-get"><a href="#9-3-1-get" class="headerlink" title="9.3.1 get"></a>9.3.1 get</h4><p>可以通过get方法并提供对应的键来从哈希map中获取值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">  scores.insert(<span class="built_in">String</span>::from(<span class="string">"blue"</span>), <span class="number">10</span>);</span><br><span class="line">  scores.insert(<span class="built_in">String</span>::from(<span class="string">"yellow"</span>), <span class="number">50</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"blue"</span>);</span><br><span class="line">  <span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">match</span> score &#123;</span><br><span class="line">    <span class="literal">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s), <span class="comment">// 10</span></span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"team not exist"</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-2-更新HashMap"><a href="#9-3-2-更新HashMap" class="headerlink" title="9.3.2 更新HashMap"></a>9.3.2 更新HashMap</h3><ul><li><p>K已经存在，对应一个V</p><ul><li>替换现有的V</li><li>保留现有的V，忽略新的V</li><li>合并现有的V和新的V</li></ul></li><li><p>K不存在</p><ul><li>添加一对K，V</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure><h5 id="9-3-2-1-entry"><a href="#9-3-2-1-entry" class="headerlink" title="9.3.2.1 entry"></a>9.3.2.1 entry</h5><p>entry方法： 检查指定的K是否对应一个V</p><ul><li>参数为K</li><li>返回enum Entry：代表值是否存在</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure><p>Entry的 or_insert 方法</p><ul><li>返回<ul><li>如果K存在，返回到对应的V的一个可变引用</li><li>如果K不存在，将方法参数作为K的新值插进去，返回到这个值的可变引用；</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据旧值更新一个值</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, map);</span><br></pre></td></tr></table></figure><h2 id="10-panic"><a href="#10-panic" class="headerlink" title="10. panic"></a>10. panic</h2><p>  Rust错误分类</p><ul><li>可恢复<ul><li>例如文件未找到，可再次尝试</li></ul></li><li>不可恢复<ul><li>bug，例如访问的索引超出范围</li></ul></li></ul><p>Rust没有类似异常的机制</p><ul><li>可恢复错误： Result&lt;T,E&gt;</li><li>不可恢复： painc！</li></ul><p>当执行painc！时，程序立即结束执行</p><p>不可恢复的错误与panic！</p><p>当panic！宏执行：</p><ul><li><p>你的程序会打印一个错误信息</p></li><li><p>展开（unwind）、清理调用栈（Stack）</p></li><li><p>退出程序</p></li></ul><p>为应对panic，展开或中止（abort）调用栈</p><ul><li><p>默认情况下，当panic发生：</p><ul><li>-程序展开调用栈（工作量大）<ul><li>rust沿着调用栈往回走</li><li>清理每个遇到的函数中的数据</li></ul></li><li>或立即中止调用栈：<ul><li>不进行清理，直接停止程序</li><li>内存需要OS进行清理</li></ul></li></ul></li><li><p>想让二进制文件更小，把设置从“展开”改为“中止”：</p><ul><li>在Cargo.toml中适当的profile部分设置：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = <span class="string">'abort'</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可恢复的错误与panic！</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">"crash and burn"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-1-Result-与可恢复的错误"><a href="#10-1-Result-与可恢复的错误" class="headerlink" title="10.1 Result 与可恢复的错误"></a>10.1 Result 与可恢复的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="literal">Ok</span>(T),</span><br><span class="line">  <span class="literal">Err</span>(E)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T: 操作成功情况下，Ok变体里返回的数据的类型</p><p>E： 操作失败情况下，Err变体里返回的错误的类型</p><p>处理Result的一种方式： match表达式</p><p>和Option枚举一样，Result及其变体也是有prelude带入作用域</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"./0.txt"</span>);</span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Error opening file &#123;:?&#125;"</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-匹配不同的错误"><a href="#10-2-匹配不同的错误" class="headerlink" title="10.2 匹配不同的错误"></a>10.2 匹配不同的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">"hello.txt"</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: &#123;:?&#125;"</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: &#123;:?&#125;"</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例使用了很多match</p><p>match很有用，但是很原始</p><p>闭包（closure）。Result&lt;T,E&gt;有很多方法</p><ul><li>它们接收闭包作为参数</li><li>使用match实现</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(<span class="string">"hello.txt"</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: &#123;:?&#125;"</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: &#123;:?&#125;"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-1-unwrap"><a href="#10-2-1-unwrap" class="headerlink" title="10.2.1 unwrap"></a>10.2.1 unwrap</h4><p>unwrap： match表达式的一个快捷方法；</p><ul><li>如果Result结果是Ok，返回Ok里面的值</li><li>如果Result结果是Err，调用panic！宏</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"0.txt"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Error opening file &#123;:?&#125;"</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> f = File::open(<span class="string">"0.txt"</span>).unwrap(); <span class="comment">// 相当于上面的match表达式</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2-expect"><a href="#10-2-2-expect" class="headerlink" title="10.2.2 expect"></a>10.2.2 expect</h4><p>expect： 和unwrap类似，但可指定错误信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-传播错误"><a href="#10-3-传播错误" class="headerlink" title="10.3 传播错误"></a>10.3 传播错误</h3><p>当编写一个其实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 <strong>传播</strong>（<em>propagating</em>）错误，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">match</span> f.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="literal">Ok</span>(s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>?运算符</p><p>?运算符： 传播错误的一种快捷方式</p><p>？与from函数</p><ul><li>Trait std::convert::From 上的from函数：<ul><li>用于错误之间的转换</li></ul></li><li>被？所应用的错误，会隐士的被from函数处理</li><li>当？调用from函数时：<ul><li>它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</li></ul></li></ul><p>用于： 针对不同错误的原因，返回同一种错误类型</p><ul><li>只要每个错误类型实现了转换为所返回的错误类型的from函数</li></ul><p>链式操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    File::open(<span class="string">"hello.txt"</span>)?.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>?运算符只能用于返回Result的函数</p><p>?运算符与main函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main中使用？</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()-&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">  <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数返回类型是：()</p><p>main函数的返回类型也可以是： Result&lt;T,E&gt;</p><p>Box<dyn Error>是trait对象</p><ul><li>简单理解： “任何可能的错误类型”</li></ul><h3 id="10-4-什么时候应该用panic"><a href="#10-4-什么时候应该用panic" class="headerlink" title="10.4 什么时候应该用panic!"></a>10.4 什么时候应该用panic!</h3><p>见示例</p><h2 id="11-泛型，Trait-生命周期"><a href="#11-泛型，Trait-生命周期" class="headerlink" title="11. 泛型，Trait 生命周期"></a>11. 泛型，Trait 生命周期</h2><h3 id="11-1-泛型"><a href="#11-1-泛型" class="headerlink" title="11.1 泛型"></a>11.1 泛型</h3><p>你编些的代码不是最终的代码，而是一种模版，里面有一些“占位符”；</p><p>编译器在编译时将“占位符”替换为具体的类型；</p><p>在编译的时候，会将泛型的类型参数编译成具体的类型。这个过程叫单态化；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> char_list = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-Trait"><a href="#11-2-Trait" class="headerlink" title="11.2 Trait"></a>11.2 Trait</h3><ul><li>Trait告诉rust编译器：<ul><li>某种类型具有哪些并且可以与其它类型共享的功能</li></ul></li><li>Trait：抽象的定义共享行为</li><li>Trait bounds（约束）泛型类型参数指定为实现了特定行为的类型；</li><li>Trait 与其它语言的接口（interface）类似，但有些区别；</li></ul><h4 id="11-2-1-如何定义一个trait"><a href="#11-2-1-如何定义一个trait" class="headerlink" title="11.2.1 如何定义一个trait"></a>11.2.1 如何定义一个trait</h4><p>类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。</p><p>trait 定义： 是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p><ul><li>关键字： trait</li><li>只有方法签名，没有具体实现</li><li>trait可以有多个方法： 每个方法签名占一行，以；结尾</li><li>实现该trait的类型必须提供具体的方法实现；</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123; <span class="comment">// 一个trait， 可以有多个方法的签名 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sunmmary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-2-2-在类型上实现trait"><a href="#11-2-2-在类型上实现trait" class="headerlink" title="11.2.2 在类型上实现trait"></a>11.2.2 在类型上实现trait</h4><p>与为类型实现方法类似</p><p>不同之处：</p><ul><li>impl  类型  for  trait名{}  // 为类型实现方法则是   <code>impl 类型 {...}</code></li><li>在impl的块里，需要对Trait里的方法签名进行具体的实现</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123; <span class="comment">// 一个trait， 可以有多个方法的签名 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-2-3-实现trait的约束"><a href="#11-2-3-实现trait的约束" class="headerlink" title="11.2.3 实现trait的约束"></a>11.2.3 实现trait的约束</h4><p>可以在某个类型上实现某个trait的前提条件是：</p><ul><li>这个类型或这个trait是在本地crate里定义的</li></ul><p>无法为外部类型来实现外部的trait；</p><ul><li>这个限制是程序属性的一部分（也就是一致性）</li><li>更具体地说是孤儿规则： 之所以这样命名是因为父类型不存在；</li><li>此规则确保其它人的代码不能破坏您的代码，反之亦然；</li><li>如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了；</li></ul><h4 id="11-2-4-默认实现"><a href="#11-2-4-默认实现" class="headerlink" title="11.2.4 默认实现"></a>11.2.4 默认实现</h4><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123;</span><br><span class="line">  <span class="comment">// 一个trait， 可以有多个方法的签名</span></span><br><span class="line">  <span class="comment">// fn summarize(&amp;self) -&gt; String;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize1</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">"(...)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Sunmmary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">  <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Sunmmary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认实现的方法可以调用trait中其它的方法，即使这些方法没有默认实现</p><p>注意： 无法从方法的重写实现里面调用默认的实现</p><h4 id="11-2-5-Trait作为参数"><a href="#11-2-5-Trait作为参数" class="headerlink" title="11.2.5 Trait作为参数"></a>11.2.5 Trait作为参数</h4><p><strong>impl Trait语法</strong></p><p>适用于简单情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sunmmary</span></span> &#123;</span><br><span class="line">  <span class="comment">// 一个trait， 可以有多个方法的签名</span></span><br><span class="line">  <span class="comment">// fn summarize(&amp;self) -&gt; String;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">summarize1</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">"(...)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123; <span class="comment">// 类型区域 添加 impl Summary</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Trait bound语法</strong></p><p>可用于复杂情况</p><ul><li>impl Trait 语法是 Trait bound的语法糖</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用  +  ，指定多个 Trait bound</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display) &#123; <span class="comment">// 类型区域 添加 impl Summary</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item1: T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Trait bound 使用where子句</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T, U&gt;(a: T, b: U) -&gt; <span class="built_in">String</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, a.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现Trait作为返回类型</li></ul><p>impl Trait 语法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify1</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">  NewsArticle &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>::from(<span class="string">""</span>),</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错</p><p>使用Trait Bound的例子</p><ul><li>例子： 使用Trait Bound修复largest函数</li></ul><ul><li>使用Trait Bound有条件的实现方法<ul><li>在使用泛型类型参数的impl块上使用 Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以为实现了其它Trait的任意类型有条件的实现某个Trait</li><li>为满足Trait Bound 的所有类型上实现Trait叫做覆盖实现；</li></ul><h3 id="11-3-生命周期"><a href="#11-3-生命周期" class="headerlink" title="11.3 生命周期"></a>11.3 生命周期</h3><p>Rust的每个引用都有自己的生命周期</p><p>声明周期： 引用保持有效的作用域</p><p>大多数情况： 声明周期是隐式的、可被推断的</p><p>当引用的声明周期可能以不同的方式互相关联时： 手动标注声明周期</p><h4 id="11-3-1-生命周期——避免悬垂引用"><a href="#11-3-1-生命周期——避免悬垂引用" class="headerlink" title="11.3.1 生命周期——避免悬垂引用"></a>11.3.1 生命周期——避免悬垂引用</h4><p>生命周期的主要目标： 避免悬垂引用（dangling reference）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> r;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    r = &amp;x; <span class="comment">// error , x走出作用域之后被释放掉了；</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"r: &#123;&#125;"</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust如何识别上面代码不合法呢？答案是 借用检查器</p><h4 id="11-3-2-借用检查器"><a href="#11-3-2-借用检查器" class="headerlink" title="11.3.2 借用检查器"></a>11.3.2 借用检查器</h4><p>Rust编译器的借用检查器： 比较作用域来判断所有的借用是否合法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r;                <span class="comment">// ---------+-- 'a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">5</span>;        <span class="comment">// -+-- 'b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r: &#123;&#125;"</span>, r); <span class="comment">// ---------+         </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-3-函数中的泛型生命周期"><a href="#11-3-3-函数中的泛型生命周期" class="headerlink" title="11.3.3 函数中的泛型生命周期"></a>11.3.3 函数中的泛型生命周期</h4><h5 id="11-3-3-1-生命周期标注"><a href="#11-3-3-1-生命周期标注" class="headerlink" title="11.3.3.1 生命周期标注"></a>11.3.3.1 生命周期标注</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"abc"</span>; <span class="comment">// 字符串字面量，也就是字符串切片类型</span></span><br><span class="line">    <span class="keyword">let</span> result = longest(&amp;string1, string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"longest -&gt; &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要让参数 x，y 和 返回值 做生命周期的关联</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-3-3-2-生命周期标注"><a href="#11-3-3-2-生命周期标注" class="headerlink" title="11.3.3.2 生命周期标注"></a>11.3.3.2 生命周期标注</h5><p>生命周期标注语法</p><ul><li>生命周期的标注不会改变引用的生命周期长度</li><li>当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用</li><li>生命周期的标注： 描述了多个引用的生命周期间的关系，但不影响生命周期</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"abc"</span>; <span class="comment">// 字符串字面量，也就是字符串切片类型</span></span><br><span class="line">    <span class="keyword">let</span> result = longest(&amp;string1, string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"longest -&gt; &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要让参数 x，y 和 返回值 做生命周期的关联</span></span><br><span class="line"><span class="comment">// 'a 为生命周期的标注： 描述了多个引用的生命周期的关系</span></span><br><span class="line"><span class="comment">// 不影响生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期参数名：</p><ul><li>以 单引号 开头</li><li>通常全小写非常短</li><li>很多使用’a</li></ul><p>生命周期标注的位置</p><ul><li>在引用的 &amp; 符号后</li><li>使用空格将标注 和 引用类型 分开</li></ul><p>生命周期的标注</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span> <span class="comment">// 一个引用</span></span><br><span class="line">&amp; <span class="symbol">'a</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp; <span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><p>单个生命周期标注本身没有意义</p><p>标注之所以存在，是为了向rust描述多个泛型生命周期参数之间的关系</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  'a 生命周期取决于 x 和 y中 存活时间较短的那个</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure><h4 id="11-3-4-深入理解生命周期"><a href="#11-3-4-深入理解生命周期" class="headerlink" title="11.3.4 深入理解生命周期"></a>11.3.4 深入理解生命周期</h4><p>指定生命周期参数的方式依赖于函数所做的事情</p><p>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配；</p><p>如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值：</p><ul><li>这就是悬垂引用，该值在函数结束时就走出了作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">  <span class="keyword">let</span> string2 = <span class="string">"xyz"</span>;</span><br><span class="line">  <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"the longest string is&#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp; <span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"abc"</span>);</span><br><span class="line"> <span class="comment">// result.as_str() // 报错，字符串切片引用会随着函数执行完毕被释放，所以会导致 悬垂引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法一：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp; <span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"abc"</span>);</span><br><span class="line"> result <span class="comment">// 把函数所有权移交给调用者；然后这块内存清理就交由调用者来清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个例子看出，生命周期语法就是用来关联函数的不同参数以及返回值之间生命周期的。一旦它们取得某种联系，rust就获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其它违反内存安全的行为；</p><h5 id="11-3-4-1-Struct定义中的生命周期标注"><a href="#11-3-4-1-Struct定义中的生命周期标注" class="headerlink" title="11.3.4.1 Struct定义中的生命周期标注"></a>11.3.4.1 Struct定义中的生命周期标注</h5><p>Struct里可包括：</p><ul><li>自持有的类型 </li><li>引用： 需要在每个引用上添加生命周期标注</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"call me inhmael, Some years age..."</span>);</span><br><span class="line">  <span class="comment">// first_sentence 的生命周期反问大于 结构体内的 first_sentence；所以此段代码可以编译通过</span></span><br><span class="line">  <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not found a '.'"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> i = ImportantExcerpt&#123;</span><br><span class="line">    part: first_sentence</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-3-4-2-生命周期的省略"><a href="#11-3-4-2-生命周期的省略" class="headerlink" title="11.3.4.2 生命周期的省略"></a>11.3.4.2 生命周期的省略</h5><p>每个引用都有生命周期</p><p>需要为使用生命周期的函数或struct指定生命周期参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有指定生命周期参数却通过编译</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">  <span class="keyword">for</span>(i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">b' '</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而之前的例子告诫我们应该写成下面这种才能编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s : &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp; <span class="symbol">'a</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p> Rust发现，在某些特定情况下。程序员总是一遍又一遍编写同样的生命周期标注。而且这种场景是可预测的。它有一些明确的模式</p><p>于是，rust团队就将这些模式写入了编译器代码。就使得借用检查器在这些情况下可以自动的对生命周期进行推导，而无需显式的标注。</p><p>了解这段历史是有必要的，因为在未来可能会有更多的特定模式被直接添加到编译器当中；也就是说在未来需要手动标注生命周期的地方可能会越来越少；</p><h5 id="11-3-4-3-生命周期省略规则"><a href="#11-3-4-3-生命周期省略规则" class="headerlink" title="11.3.4.3 生命周期省略规则"></a>11.3.4.3 生命周期省略规则</h5><p>这个在Rust引用分析中所编入的模式就称为生命周期省略规则；</p><ul><li>这些规则无需开发者来遵守</li><li>它们是一些特殊情况，由编译器来考虑</li><li>如果你的代码复合这些情况，那么久无需显式标注生命周期</li></ul><p>生命周期省略规则不会提供完整的推断：</p><p>如果应用规则后，引用的生命周期仍然模糊不清-&gt; 编译错误</p><p>解决方法： 添加生命周期标注，表明引用间的相互关系</p><h5 id="11-3-4-4-输入、输出生命周期"><a href="#11-3-4-4-输入、输出生命周期" class="headerlink" title="11.3.4.4 输入、输出生命周期"></a>11.3.4.4 输入、输出生命周期</h5><p>生命周期在</p><ul><li>函数/方法的参数： 输入生命周期</li><li>函数/方法的返回值： 输出生命周期</li></ul><h5 id="11-3-4-5-生命周期省略的三个规则"><a href="#11-3-4-5-生命周期省略的三个规则" class="headerlink" title="11.3.4.5 生命周期省略的三个规则"></a>11.3.4.5 生命周期省略的三个规则</h5><p>编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期；</p><ul><li>规则1 应用于输入生命周期</li><li>规则2、3 应用于输出生命周期</li><li>如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用 -&gt; 报错</li><li>这些规则适用于fn定义 和 impl块</li></ul><p><strong>规则1: 每个引用类型的参数都有自己的生命周期</strong></p><p>换句话说，单参数的函数它就拥有一个生命周期参数，而拥有两个参数的函数就拥有两个不同的生命周期参数。</p><p><strong>规则2: 如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数</strong></p><p><strong>规则3： 如果有多个输入生命周期参数，但其中一个是 &amp;self 或者 &amp; mut self（是方法），那么self的生命周期会被赋给所有的输出生命周期参数</strong></p><p>demo1</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 首先适用第一条规则，单参数函数它拥有一个生命周期参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 第二条规则，如果只有1个输入生命周期参数，该生命周期被赋给所有输出生命周期参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">'a</span>&gt;(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp; <span class="symbol">'a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure><p>demo2</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">//首先应用规则1，两个参数都有自己的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>,<span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>)-&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="comment">// 因为有两个参数，所以第二条规则已经不适用了</span></span><br><span class="line"><span class="comment">// 没有self，所有第三条也不适用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在应用完三条规则之后，依然无法计算出返回类型的生命周期。所以编译器报错。</span></span><br></pre></td></tr></table></figure><h4 id="11-3-5-方法定义中的生命周期标注"><a href="#11-3-5-方法定义中的生命周期标注" class="headerlink" title="11.3.5 方法定义中的生命周期标注"></a>11.3.5 方法定义中的生命周期标注</h4><p>在struct上使用生命周期实现方法，语法和泛型参数的语法一样</p><ul><li>在哪儿声明和使用生命周期参数 依赖于<ul><li>生命周期参数是否和字段、方法的参数或返回值有关</li></ul></li></ul><p>struct字段的生命周期名：</p><ul><li>在impl后声明</li><li>在struct名后使用</li><li>这些生命周期是struct类型的一部分</li></ul><p>impl块内的方法签名中：</p><ul><li><p>引用必须绑定于struct字段引用的生命周期，或者引用是独立的也可以</p></li><li><p>生命周期省略规则经常使用方法中的生命周期标注不是必须的；</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// impl 后面 和结构体后面 的生命周期参数不能省略</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"Call me Ishmael,Some..."</span>);</span><br><span class="line">  <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not found a '.'"</span>);</span><br><span class="line">  <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">    part: first_sentence</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-6-静态生命周期"><a href="#11-3-6-静态生命周期" class="headerlink" title="11.3.6 静态生命周期"></a>11.3.6 静态生命周期</h4><p>‘static 是一个特殊的生命周期： 整个程序的持续时间；</p><ul><li>例如： 所有的字符串字面值都拥有 ‘static 生命周期</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"i have a static lifetime"</span></span><br><span class="line"><span class="comment">// 这个字符串字面值，它是被直接存储在二进制程序里面。所以它总是可用的。所以所有字符串字面值的生命周期都是 'static</span></span><br></pre></td></tr></table></figure><p>为引用指定 ‘static 生命周期前要三思</p><ul><li>是否需要引用在程序整个生命周期内都存活</li></ul><p>因为在大部分情况下，错误的原因都在于尝试创建一个悬垂引用或者是可用生命周期不匹配。这个时候应该去尝试解决这些问题，而不是指定一个 ‘static </p><p><strong>一个涉及泛型参数类型、Trait Bound、生命周期的例子</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_announcement</span></span>&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line">(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, ann: T) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">where</span> T: Display,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"Announcement! &#123;&#125;"</span>, ann);</span><br><span class="line">  <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="12-编写自动化测试"><a href="#12-编写自动化测试" class="headerlink" title="12 编写自动化测试"></a>12 编写自动化测试</h2><h3 id="12-1-编写和运行测试"><a href="#12-1-编写和运行测试" class="headerlink" title="12.1 编写和运行测试"></a>12.1 编写和运行测试</h3><p>测试</p><ul><li>函数</li><li>验证非测试代码的功能是否和预期一致</li></ul><p>测试函数体（通常）执行的3个操作 （3A操作）</p><ul><li>准备数据/状态 Arrange</li><li>运行被测试的代码  Act</li><li>断言（Assert）结果 Assert</li></ul><p>解剖测试函数</p><p>测试函数需要使用test属性（attribute）进行标注</p><ul><li>Attribute 就是一段Rust代码的元数据，它不会被改变被它修饰代码的逻辑，它只是被代码进行修饰或标注</li><li>在函数上面一行加上 #[test]，可以函数变为测试函数</li></ul><p>运行测试</p><ul><li>使用cargo test命令运行所有测试函数<ul><li>Rust会构建一个Test Runner可执行文件<ul><li>它会运行标注了test的函数，并报错其运行是否成功</li></ul></li></ul></li><li>当使用cargo 创建library项目的时候，会生成一个test module，里面有一个test函数；<ul><li>你可以添加任意数量的test module或函数</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$&gt; cargo new adder --lib <span class="comment"># 创建一个库项目 adder</span></span><br><span class="line">$&gt; <span class="built_in">cd</span> adder &amp;&amp; cargo <span class="built_in">test</span> <span class="comment"># 运行测试</span></span><br><span class="line"></span><br><span class="line">$&gt; Compiling adder v0.1.0 (/Users/ruanhan/rust_pro/adder)</span><br><span class="line"></span><br><span class="line">Finished <span class="built_in">test</span> [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 1.25s</span><br><span class="line"></span><br><span class="line">Running target/debug/deps/adder-710a662a5bf33e5e</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 tests::it_works </span></span><br><span class="line"><span class="built_in">test</span> tests::it_works ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br><span class="line"></span><br><span class="line">Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br></pre></td></tr></table></figure><p>测试失败</p><ul><li>测试函数panic就表示失败</li><li>每个测试运行在一个新线程</li><li>当主线程看见某个测试线程挂掉了，那个测试标记为失败了；</li></ul><h3 id="12-2-断言宏（Assert）"><a href="#12-2-断言宏（Assert）" class="headerlink" title="12.2 断言宏（Assert）"></a>12.2 断言宏（Assert）</h3><p>使用assert! 宏检查测试结果</p><p>assert！ 宏，来自标准库，用来确定某个状态是否为true</p><ul><li>true 测试通过</li><li>false 调用panic！，测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">larger_can_hold_smaller</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> larger = Rectangle &#123;</span><br><span class="line">            width: <span class="number">8</span>,</span><br><span class="line">            height: <span class="number">7</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> smaller = Rectangle &#123;</span><br><span class="line">            width: <span class="number">5</span>,</span><br><span class="line">            height: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(larger.can_hold(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用assert_eq! 和 assert_ne! 测试相等性</strong></p><p>都来自标准库</p><p>判断两个参数是否 相等或不等；</p><p>实际上，它们使用的就是 == 和 != 运算符</p><p>断言失败： 自动打印出两个参数的值；</p><ul><li>使用debug格式打印参数<ul><li>要求参数实现了 PartiaEq 和 Debug Traits（所有的基本类型和标准库里大部分类型都实现了）</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests1 &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, add_two(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-自定义错误信息"><a href="#12-3-自定义错误信息" class="headerlink" title="12.3 自定义错误信息"></a>12.3 自定义错误信息</h3><p>可以向 assert!    assert_eq!   assert_ne! 添加可选的自定义信息</p><ul><li>这些自定义消息和失败消息都会打印出来</li><li>assert!: 第1参数必填，自定义消息作为第2个参数</li><li>assert_eq!   assert_ne! ： 前2个参数必填，自定义消息作为第3个参数；</li><li>自定义消息参数会被传递给 format!  宏，可以使用{} 占位符</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">greeting</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Hello &#123;&#125;!"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greeting_contain_name</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = greeting(<span class="string">"Carol"</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(result.contains(<span class="string">"Caro1l"</span>), <span class="string">"错误信息是 '&#123;&#125;'"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-用should-panic检查恐慌"><a href="#12-4-用should-panic检查恐慌" class="headerlink" title="12.4 用should_panic检查恐慌"></a>12.4 用should_panic检查恐慌</h3><p>验证错误处理的情况</p><ul><li>测试除了验证代码的返回值是否正确，还需验证代码是否如预期的处理了发生错误的情况；</li><li>可验证代码在特定情况下是否发生了panic</li><li>这种测试需要添加 should_panic 属性</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be between 1 and 100, got &#123;&#125;."</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为should_panic 属性添加一个可选的expected参数，让should_panic更精确；将检查失败信息中是否包含所指定文字；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[should_panic(expected=<span class="meta-string">"guess value must be less than ..."</span>)]</span></span><br></pre></td></tr></table></figure><h3 id="12-5-在测试中使用Result-lt-T-E-gt"><a href="#12-5-在测试中使用Result-lt-T-E-gt" class="headerlink" title="12.5 在测试中使用Result&lt;T,E&gt;"></a>12.5 在测试中使用Result&lt;T,E&gt;</h3><p>无需panic，可使用Result&lt;T,E&gt; 作为返回类型编写测试：</p><ul><li>返回Ok： 测试通过</li><li>返回Err： 测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line">mode test &#123;</span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span> -&gt; <span class="title">Result</span></span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>+<span class="number">2</span> ==<span class="number">4</span> &#123;</span><br><span class="line">      <span class="literal">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">"not equal"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 不要在使用Result&lt;T,E&gt; 编写的测试上标注</p><p>#[should_panic]</p><h3 id="12-6-控制测试如何运行"><a href="#12-6-控制测试如何运行" class="headerlink" title="12.6 控制测试如何运行"></a>12.6 控制测试如何运行</h3><p>改变cargo test的行为： 添加命令行参数</p><p>不添加任何参数就是默认行为</p><ul><li>并行运行</li><li>所有测试</li><li>捕获（不显示）所有输出，使读取与测试结果相关的输出更容易</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示cargo test命令 所用的参数有哪些</span></span><br><span class="line">cargo <span class="built_in">test</span> --<span class="built_in">help</span> </span><br><span class="line"><span class="comment"># 显示出所有可以用在-- 后的参数，给二进制程序添加的参数</span></span><br><span class="line">cargo <span class="built_in">test</span> -- --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="12-7-并行-连续运行测试"><a href="#12-7-并行-连续运行测试" class="headerlink" title="12.7 并行/连续运行测试"></a>12.7 并行/连续运行测试</h3><p>运行多个测试： 默认使用多个线程并行运行；</p><ul><li>运行快</li></ul><p>确保测试之间</p><ul><li>不会互相依赖</li><li>不依赖于某个共享状态（环境、工作目录、环境变量等）</li></ul><p>显式函数输出</p><p>默认，如测试通过，rust的test库会捕获所有打印到标准输出的内容</p><p>例如： 如果被测试代码中用到了println!</p><ul><li>如果测试通过： 不会在终端看到println! 打印的内容</li><li>如果测试失败： 会看到println! 打印的内容和失败信息</li></ul><p>如果想在成功的测试中看到打印的内容： –show-output</p><h3 id="12-8-按名称运行测试"><a href="#12-8-按名称运行测试" class="headerlink" title="12.8 按名称运行测试"></a>12.8 按名称运行测试</h3><p>运行单个测试： 指定测试名</p><p>运行多个测试： 指定测试名的一部分（模块名也可以）</p><h3 id="12-9-忽略测试"><a href="#12-9-忽略测试" class="headerlink" title="12.9 忽略测试"></a>12.9 忽略测试</h3><p>忽略某些测试，运行剩余测试</p><ul><li>ignore属性（attribute）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">  <span class="meta">#[ignore]</span> <span class="comment">// 忽略 expensive_test这个测试</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cargo test – –ignore  单独执行此忽略的测试</p><h3 id="12-10-测试的分类"><a href="#12-10-测试的分类" class="headerlink" title="12.10 测试的分类"></a>12.10 测试的分类</h3><p>Rust对测试的分类</p><ul><li>单元测试</li><li>集成测试</li></ul><p>单元测试</p><ul><li>小、专注</li><li>一次对一个模块进行隔离的测试</li><li>可测试private接口</li></ul><p>集成测试：</p><p>在库外部，和其它外部代码一样使用你的代码</p><p>只能使用public接口</p><p>可能在每个测试中使用多个模块</p><p>#[cfg(test)] 标注</p><p>test 模块上的 #[cfg(test)]标注</p><ul><li>只有运行 cargo test 才编译和运行代码</li><li>运行cargo build则不会</li></ul><p>集成测试在不同的目录，它不需要 #[cfg(test)] 标注</p><p>cfg：configuration</p><ul><li>告诉rust下面的条目只有在特定的配置选项下才被包含</li><li>配置选项test： 由Rust提供，用来编译和运行测试<ul><li>只有cargo test才会编译代码，包括模块中的helper函数和 #[test]标注的函数</li></ul></li></ul><p>测试私有函数</p><ul><li>rust允许测试私有函数</li></ul><h3 id="12-11-集成测试"><a href="#12-11-集成测试" class="headerlink" title="12.11 集成测试"></a>12.11 集成测试</h3><p>在Rust里，集成测试完全位于被测试库的外部</p><p>目的：是测试被测试库的多个部分是否能正确在一起工作</p><p>集成测试的覆盖率很重要；</p><h2 id="13-rustlings"><a href="#13-rustlings" class="headerlink" title="13 rustlings"></a>13 rustlings</h2><p>Thanks for installing Rustlings!</p><p>Is this your first time? Don’t worry, Rustlings was made for beginners! We are<br>going to teach you a lot of things about Rust, but before we can get<br>started, here’s a couple of notes about how Rustlings operates:</p><ol><li>The central concept behind Rustlings is that you solve exercises. These<br>exercises usually have some sort of syntax error in them, which will cause<br>them to fail compliation or testing. Sometimes there’s a logic error instead<br>of a syntax error. No matter what error, it’s your job to find it and fix it!<br>You’ll know when you fixed it because then, the exercise will compile and<br>Rustlings will be able to move on to the next exercise.</li><li>If you run Rustlings in watch mode (which we recommend), it’ll automatically<br>start with the first exercise. Don’t get confused by an error message popping<br>up as soon as you run Rustlings! This is part of the exercise that you’re<br>supposed to solve, so open the exercise file in an editor and start your<br>detective work!</li><li>If you’re stuck on an exercise, there is a helpful hint you can view by typing<br>‘hint’ (in watch mode), or running <code>rustlings hint myexercise</code>.</li><li>If an exercise doesn’t make sense to you, feel free to open an issue on GitHub!<br>(<a href="https://github.com/rust-lang/rustlings/issues/new" target="_blank" rel="noopener">https://github.com/rust-lang/rustlings/issues/new</a>). We look at every issue,<br>and sometimes, other learners do too so you can help each other out!</li></ol><p>Got all that? Great! To get started, run <code>rustlings watch</code> in order to get the first<br>exercise. Make sure to have your editor open!</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go1</title>
      <link href="2021/03/09/go1/"/>
      <url>2021/03/09/go1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-编译型语言"><a href="#1-编译型语言" class="headerlink" title="1. 编译型语言"></a>1. 编译型语言</h2><p>Go 语言是一门编译语言</p><ul><li>在运行程序之前，GO首先使用编译器把代码编译成机器可以识别的1和0</li><li>它会把代码编译成一个可执行文件，在编译的过程中，编译器能捕获一些错误；</li></ul><p>解释型语言</p><ul><li>python，js等都是使用解释器，随着程序运行，一个语句一个语句进行翻译，但也这意味着bug可能就潜伏在你还没测试过的路径上。这些就是解释型语言；</li></ul><h2 id="2-install-go"><a href="#2-install-go" class="headerlink" title="2. install go"></a>2. install go</h2><p>go 代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h2 id="3-const-var"><a href="#3-const-var" class="headerlink" title="3. const var"></a>3. const var</h2><p>常量与变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> distance, speed = <span class="number">56</span>, <span class="number">108</span></span><br><span class="line"><span class="keyword">const</span> hours, minutes = <span class="number">24</span>, <span class="number">60</span></span><br></pre></td></tr></table></figure><h3 id="3-1-短声明"><a href="#3-1-短声明" class="headerlink" title="3.1 短声明"></a>3.1 短声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种声明效果一样</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span></span><br><span class="line">count:= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短声明可以在无法使用var的地方使用</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> count= <span class="number">10</span>; count&gt;<span class="number">0</span>; count-- &#123;</span><br><span class="line">  fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> count:=<span class="number">10</span>; count&gt;<span class="number">0</span>; count-- &#123;</span><br><span class="line">  fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num:=rand.Intn(<span class="number">3</span>);num==<span class="number">0</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> num:=rand.Intn(<span class="number">10</span>); num&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Printls(<span class="string">"1"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>,<span class="number">3</span>:</span><br><span class="line">  fmt.Printls(<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短声明不能用来声明 package作用域的变量</p><ul><li>era变量在main函数外声明的<ul><li>它拥有package作用域</li><li>如果main package有多个函数，那么era对它们都可见</li><li>package作用域的变量不能用短声明</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> era = <span class="string">"AD"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  year := <span class="number">2018</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下3个等价</span></span><br><span class="line">age = age + <span class="number">1</span></span><br><span class="line">age += <span class="number">1</span></span><br><span class="line">age++</span><br><span class="line">++age <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="4-1-逻辑运算符"><a href="#4-1-逻辑运算符" class="headerlink" title="4.1 逻辑运算符"></a>4.1 逻辑运算符</h3><p>|| 或</p><p> &amp;&amp; 与</p><p>！ 可以把true 变为 false，反之亦然</p><h2 id="5-包"><a href="#5-包" class="headerlink" title="5. 包"></a>5. 包</h2><p>引用多个包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> number = rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">fmt.Println(number)</span><br><span class="line"></span><br><span class="line">number = rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">fmt.Println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-循环-分支"><a href="#6-循环-分支" class="headerlink" title="6 循环 分支"></a>6 循环 分支</h2><h3 id="6-1-Boolean类型"><a href="#6-1-Boolean类型" class="headerlink" title="6.1 Boolean类型"></a>6.1 Boolean类型</h3><p>true 和false</p><p>go中，” “ 空串不会自动转为false </p><h3 id="6-2-strings-Contains"><a href="#6-2-strings-Contains" class="headerlink" title="6.2 strings.Contains"></a>6.2 strings.Contains</h3><p>来自strings包的Contains函数可以判断某个字符串是否包含另外要给字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"you find yourself in a dimlu lit cavern"</span>)</span><br><span class="line"><span class="keyword">var</span> command = <span class="string">"walk outside"</span></span><br><span class="line"><span class="keyword">var</span> exit = strings.Contains(command, <span class="string">"outside"</span>)</span><br><span class="line">fmt.Println(<span class="string">"you leave the cave: "</span>, exit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-compare"><a href="#6-3-compare" class="headerlink" title="6.3 compare"></a>6.3 compare</h3><p>如果比较两个值，得到的结果也是 true 或false</p><p>比较运算符：</p><p><code>== &lt;= &lt; != &gt;= &gt;</code></p><h3 id="6-4-if"><a href="#6-4-if" class="headerlink" title="6.4 if"></a>6.4 if</h3><p>判断条件不加括号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> command == <span class="string">"alex"</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> command == <span class="string">"let"</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-swtch"><a href="#6-6-swtch" class="headerlink" title="6.6 swtch"></a>6.6 swtch</h3><p>条件不加括号，不需要break关键字</p><p>还有一个fallthrough关键字，它用来执行下一个case的body部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">"alex"</span></span><br><span class="line"><span class="keyword">switch</span> command &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"gi"</span>:</span><br><span class="line">  ..</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"go"</span>,<span class="string">"run"</span>:</span><br><span class="line">  ..</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> room = <span class="string">"cave"</span></span><br><span class="line"><span class="keyword">switch</span> room &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"cave"</span>:</span><br><span class="line">    fmt.Printls(<span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"go"</span>,<span class="string">"run"</span>:</span><br><span class="line">  fmt.Printls(<span class="string">"2"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 1，2</span></span><br></pre></td></tr></table></figure><h3 id="6-7-循环"><a href="#6-7-循环" class="headerlink" title="6.7 循环"></a>6.7 循环</h3><p>for关键字让代码重复执行</p><p>for后边没有根条件，那就是无限循环</p><ul><li>可以使用break跳出循环</li></ul><p><strong>遍历数组</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">numbers := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">fmt.Println(i, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-8-变量的作用域"><a href="#6-8-变量的作用域" class="headerlink" title="6.8 变量的作用域"></a>6.8 变量的作用域</h3><p>当变量被声明以后，它就进入了作用域</p><ul><li>只要变量在作用域内，你就可以访问它</li><li>否则，访问它会报错的</li></ul><p>变量声明的位置，决定了它的作用域</p><p>作用域的好处？</p><ul><li>可以在不通的作用域内使用相同的变量名</li></ul><p>在Go里面， 作用域的范围就是{}之间的部分</p><h2 id="7-数据类型"><a href="#7-数据类型" class="headerlink" title="7. 数据类型"></a>7. 数据类型</h2><h3 id="7-1-声明浮点型变量"><a href="#7-1-声明浮点型变量" class="headerlink" title="7.1 声明浮点型变量"></a>7.1 声明浮点型变量</h3><p>下面这三个语句的效果是一样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">days := <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">var</span> days = <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">var</span> days <span class="keyword">float64</span> = <span class="number">365.2425</span></span><br></pre></td></tr></table></figure><p>只要数字含有小数部分，那么它的类型就是float64</p><p>如果你使用一个整数来初始化某个变量，那么你必须指定它的类型为float64，否则它就是一个整数类型</p><h3 id="7-2-单精度浮点数类型"><a href="#7-2-单精度浮点数类型" class="headerlink" title="7.2 单精度浮点数类型"></a>7.2 单精度浮点数类型</h3><p>Go语言有两种浮点数类型</p><p>默认是float64</p><ul><li>64位的浮点类型</li><li>占用8字节内存</li><li>某些编程语言把这种类型叫做double（双精度）</li></ul><p>float32</p><ul><li>占用4字节内存</li><li>精度比float64低</li><li>有时叫做单精度类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi64 = math.Pi</span><br><span class="line"><span class="keyword">var</span> pi32 <span class="keyword">float32</span> = math.Pi</span><br><span class="line"></span><br><span class="line">fmt.Println(pi64)</span><br><span class="line">fmt.Println(pi32)</span><br></pre></td></tr></table></figure><h3 id="7-3-单双精度的使用场景"><a href="#7-3-单双精度的使用场景" class="headerlink" title="7.3 单双精度的使用场景"></a>7.3 单双精度的使用场景</h3><ul><li>当处理大量数据时，例如3D游戏中的数千个顶点，使用float32牺牲精度来节省内存是很有意义的；</li><li>math包里面的函数操作的都是float64类型，所以应该首选使用float64，除非你有足够的理由不去使用它；</li></ul><h3 id="7-4-零值"><a href="#7-4-零值" class="headerlink" title="7.4 零值"></a>7.4 零值</h3><p>Go里面每个类型都有一个默认值，称作零值</p><p>当你声明却不对它进行初始化的时候，它的值就是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price <span class="keyword">float64</span></span><br><span class="line">fmt.Println(price)</span><br><span class="line"></span><br><span class="line">price := <span class="number">0.0</span></span><br></pre></td></tr></table></figure><h3 id="7-5-显示浮点类型"><a href="#7-5-显示浮点类型" class="headerlink" title="7.5 显示浮点类型"></a>7.5 显示浮点类型</h3><ul><li>使用Print或Println打印浮点类型的时候，默认的行为是尽可能的多显示几位小数</li><li>结合%f格式显示小数的位置</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">third := <span class="number">1.0</span>/<span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%f\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%.3f\n"</span>, third)</span><br><span class="line">fmt.Printf(<span class="string">"%4.2f\n"</span>, third)</span><br></pre></td></tr></table></figure><p>%4.2f</p><p>%4 标识宽度</p><p>2f 表示precision</p><ul><li>宽度： 会显示出的最少字符个数（包括小数点和小数）<ul><li>如果宽度大于数字的个数，那么左边会填充空格</li><li>如果没指定宽度，那么就按实际的位数进行显示</li></ul></li><li>精度： 小数点后边显示的位数</li></ul><h3 id="7-6-整数类型"><a href="#7-6-整数类型" class="headerlink" title="7.6 整数类型"></a>7.6 整数类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> year <span class="keyword">int</span> = <span class="number">2018</span>  <span class="comment">// 常用整型</span></span><br><span class="line"><span class="keyword">var</span> month <span class="keyword">uint</span> = <span class="number">2</span> <span class="comment">// 无符号整数类型</span></span><br></pre></td></tr></table></figure><h4 id="7-6-1-int-和-uint"><a href="#7-6-1-int-和-uint" class="headerlink" title="7.6.1 int 和 uint"></a>7.6.1 int 和 uint</h4><p>int和uint是针对目标设备优化的类型</p><ul><li>在old 的移动设备上，int 和 uint都是32位的</li><li>比较新的计算机上，int 和 uint都是64位的</li><li>虽然在某些设备上int可以看作int32，在某些设备上可以看作是int64，但他们其实是3种不同的类型</li><li>int并不是其它类型的别名</li></ul><p>tip</p><p>如果你在较老的32位设备上，使用了超过20亿的整数，而且代码还能运行，那么最好使用int64 和 uint64 来代替 int和uint</p><h4 id="7-6-2-uint8"><a href="#7-6-2-uint8" class="headerlink" title="7.6.2 uint8"></a>7.6.2 uint8</h4><p>uint8 可以表示8位的颜色（红绿蓝： 0-255）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue <span class="keyword">uint8</span> = <span class="number">0</span>,<span class="number">141</span>,<span class="number">213</span></span><br></pre></td></tr></table></figure><p>为什么不使用int</p><ul><li>uint8取值范围正好合适，而int则多出来几十亿不合理的数字</li><li>如果很多颜色数据连续存储，例如未被压缩的图片，那么使用uint8可以节省很多内存</li></ul><h3 id="7-7-输出数据类型"><a href="#7-7-输出数据类型" class="headerlink" title="7.7 输出数据类型"></a>7.7 输出数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:= <span class="number">1.0</span></span><br><span class="line">fmt.Println(<span class="string">"%T"</span>, a)</span><br></pre></td></tr></table></figure><h3 id="7-8-文本"><a href="#7-8-文本" class="headerlink" title="7.8 文本"></a>7.8 文本</h3><h3 id="7-8-1-声明字符串"><a href="#7-8-1-声明字符串" class="headerlink" title="7.8.1 声明字符串"></a>7.8.1 声明字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peace := <span class="string">"peace"</span></span><br><span class="line"><span class="keyword">var</span> peace = <span class="string">"peace"</span></span><br><span class="line"><span class="keyword">var</span> peace <span class="keyword">string</span> = <span class="string">"peace"</span></span><br></pre></td></tr></table></figure><p>字符串的零值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blank <span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="7-9-类型转换"><a href="#7-9-类型转换" class="headerlink" title="7.9 类型转换"></a>7.9 类型转换</h3><p>连接两个字符串，使用+运算符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout:= <span class="string">"alex"</span> + <span class="string">"leo"</span> <span class="comment">// compiler success</span></span><br></pre></td></tr></table></figure><p>如果想连接字符串和数值，是会报错的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout:= <span class="string">"alex"</span> + <span class="number">10</span> + <span class="string">"leo"</span> <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure><p>整数和浮点数也不能直接连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想把age转化成浮点类型，需要使用目标类型将其“包裹”起来</span></span><br><span class="line">age := <span class="number">41</span></span><br><span class="line">marsAge := float(age)</span><br></pre></td></tr></table></figure><p>从浮点类型转为整数类型</p><ul><li>可以从浮点类型转化为整数类型，小数点后面的部分会被截断，而不是舍入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">earthDays := <span class="number">365.2425</span></span><br><span class="line"><span class="keyword">int</span>(earthDays)</span><br></pre></td></tr></table></figure><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><h3 id="8-1-函数声明"><a href="#8-1-函数声明" class="headerlink" title="8.1 函数声明"></a>8.1 函数声明</h3><p>在go里，大写字母开头的函数、变量或其它标识符都会被导出，对其它包可用；</p><p>小写字母开头的就不行；</p><h3 id="8-2-方法"><a href="#8-2-方法" class="headerlink" title="8.2 方法"></a>8.2 方法</h3><p>也是一个函数，但是它根某一个类型相关联的；</p><p><strong>声明新类型</strong></p><p>关键字type可以用来声明新类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> temperature celsius = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>虽然celsius 是一种全新的类型，但是由于它和float64具有相同的行为和表示，所以赋值操作能顺利执行；</p><p>例如加法等运算，也可以像float64那样使用；</p><h4 id="8-2-1-通过方法添加行为"><a href="#8-2-1-通过方法添加行为" class="headerlink" title="8.2.1 通过方法添加行为"></a>8.2.1 通过方法添加行为</h4><p>在C#、java里，方法属于类</p><p>在Go里，它提供了方法，但是没提供类和对象</p><p>go比其它语言的方法要灵活</p><p>可以将方法与同包中声明的任何类型相关联、但不可以是int、float64等预声明的类型进行关联；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 两种类型不能混用，哪怕底层指向的是同一类型</span></span><br><span class="line">  <span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line">  <span class="keyword">var</span> w <span class="keyword">float64</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> k kelvin = <span class="number">20</span></span><br><span class="line">  k+=w <span class="comment">// compiler error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">float64</span></span><br><span class="line">y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p为接收者， 类似this 的作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">distance</span><span class="params">(q Point)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q.y &gt; p.y &amp;&amp; q.X &gt; p.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> point = Point&#123;<span class="number">3.12</span>, <span class="number">3.14</span>&#125;</span><br><span class="line"><span class="keyword">var</span> point1 = Point&#123;<span class="number">4.10</span>, <span class="number">3.12</span>&#125;</span><br><span class="line">fmt.Println(point.y)</span><br><span class="line">fmt.Println(point.distance(point1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个方法可以有多个参数，但只能有一个接收者</p><p>在方法体中，接收者的行为和其它参数一样；</p><h4 id="8-2-2-方法调用"><a href="#8-2-2-方法调用" class="headerlink" title="8.2.2 方法调用"></a>8.2.2 方法调用</h4><p>变量.方法()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">float64</span></span><br><span class="line">y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p为接收者， 类似this 的作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">distance</span><span class="params">(q Point)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> q.y &gt; p.y &amp;&amp; q.X &gt; p.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> point = Point&#123;<span class="number">3.12</span>, <span class="number">3.14</span>&#125;</span><br><span class="line"><span class="keyword">var</span> point1 = Point&#123;<span class="number">4.10</span>, <span class="number">3.12</span>&#125;</span><br><span class="line">fmt.Println(point.distance(point1)) <span class="comment">// 变量.方法()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-一等函数"><a href="#8-3-一等函数" class="headerlink" title="8.3 一等函数"></a>8.3 一等函数</h3><p>在go里，函数是头等的，它可以用在整数、字符串或其它类型能用的地方；</p><ul><li>将函数赋给变量</li><li>将函数作为函数的返回类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  sensor:= fakeSensor</span><br><span class="line">  sensor()</span><br><span class="line">  sensor:= realSensor</span><br><span class="line">  sensor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将函数作为参数传递给函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> kelvin <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, sensor <span class="keyword">func</span>()</span> <span class="title">kelvin</span>)</span>  &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSensor</span> <span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  measureTemperature(<span class="number">3</span>, fakeSensor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明函数类型</strong></p><p>为函数声明类型有助于精简和明确调用者的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sensor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">kelvin</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, s <span class="keyword">func</span>()</span> <span class="title">kelvin</span>)</span></span><br><span class="line"><span class="comment">// 可以优化为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measureTemperature</span> <span class="params">(samples <span class="keyword">int</span>, s sensor )</span></span></span><br></pre></td></tr></table></figure><p><strong>闭包和匿名函数</strong></p><p>匿名函数就是没有名字的函数，在Go里也称作函数字面值；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"&gt;&gt;."</span>)</span><br><span class="line">&#125;</span><br><span class="line">  f() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"&gt;&gt;."</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> k <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> sensor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realSensor</span><span class="params">()</span> <span class="title">k</span></span> &#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calibrate</span><span class="params">(s sensor, offset k)</span> <span class="title">sensor</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">kelvin</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s() + offset</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  sensor := calibrate(realSensor, <span class="number">5</span>)</span><br><span class="line">  sensor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包就是由于怒名函数封闭并包围作用域中的变量而得名的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> k <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">type</span> sersor <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span></span><br><span class="line"><span class="keyword">var</span> f k = <span class="number">3</span></span><br><span class="line">ser := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">k</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(ser()) <span class="comment">// 3</span></span><br><span class="line">f++</span><br><span class="line">fmt.Println(ser()) <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9 数组"></a>9 数组</h2><h3 id="9-1-数组的复制"><a href="#9-1-数组的复制" class="headerlink" title="9.1 数组的复制"></a>9.1 数组的复制</h3><p>无论数组赋值给新的变量还是将它传递给函数，都会产生一个完整的数组副本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">plants := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">clones := plants</span><br><span class="line">plants[<span class="number">0</span>] = <span class="string">"alex"</span></span><br><span class="line">fmt.Println(plants)</span><br><span class="line">fmt.Println(clones)</span><br><span class="line"><span class="comment">// [alex b c]</span></span><br><span class="line"><span class="comment">// [a b c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组也是一种值，函数通过值传递来接收参数，所以数组作为函数的参数就非常低效</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func clonefunc(p [<span class="number">3</span>]string) [<span class="number">3</span>]string &#123;</span><br><span class="line"><span class="keyword">for</span> i := range p &#123;</span><br><span class="line">p[i] = <span class="string">"pruffix"</span> + p[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">plants := [...]string&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(clonefunc(plants))</span><br><span class="line">fmt.Println(plants)</span><br><span class="line"><span class="comment">// [pruffixa pruffixb pruffixc]</span></span><br><span class="line"><span class="comment">// [a b c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的长度也是数组类型的一部分</p><ul><li>尝试将长度不符的数组作为参数传递，将会报错</li><li>函数一般使用slice而不是数组作为参数</li></ul><h2 id="10-slice"><a href="#10-slice" class="headerlink" title="10 slice"></a>10 slice</h2><p>指向数组的窗口</p><p>假如p 是一个数组，那么 p[0:4] 就是一个切片，它切分出数组里面前4个元素</p><p>切分数组不会导致数组被修改，它只是创建了指向数组的一个窗口或视图，这种视图就是slice类型；</p><p>默认索引</p><p>[:10]</p><p>[1:]</p><p>[:]</p><p>切分数组的语法也可以用于切分字符串</p><ul><li>切分字符串时，索引代表的是字节数而非 字符串的数；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">que := <span class="string">"汉字^&amp;COMasf"</span></span><br><span class="line">fmt.Println(que[:<span class="number">3</span>]) <span class="comment">// 汉</span></span><br></pre></td></tr></table></figure><h3 id="10-1-slice的字面值"><a href="#10-1-slice的字面值" class="headerlink" title="10.1 slice的字面值"></a>10.1 slice的字面值</h3><p>Go里面很多函数都倾向于使用slice而不是数组作为参数</p><p>想要获得与底层数组相同元素的slice，那么可以使用[:]进行切分</p><h3 id="10-2-声明slice"><a href="#10-2-声明slice" class="headerlink" title="10.2 声明slice"></a>10.2 声明slice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明slice</span></span><br><span class="line">d := []<span class="keyword">string</span> &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line"><span class="comment">// 声明array</span></span><br><span class="line">f := [...]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"c"</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hyper</span><span class="params">(worlds []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> worlds &#123;</span><br><span class="line">worlds[i] = strings.TrimSpace(worlds[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;<span class="string">"a   "</span>, <span class="string">"   b"</span>, <span class="string">" c "</span>&#125;</span><br><span class="line">hyper(planets)</span><br><span class="line">fmt.Println(planets) <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-带有方法的切片"><a href="#10-3-带有方法的切片" class="headerlink" title="10.3 带有方法的切片"></a>10.3 带有方法的切片</h3><p>在go里，可以将slice或数组作为底层类型，然后绑定其它方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>,</span><br><span class="line">&#125;</span><br><span class="line">sort.StringSlice(planets).Sort()</span><br><span class="line">fmt.Println(planets) <span class="comment">// [Ear Mer Ven]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-append函数"><a href="#10-4-append函数" class="headerlink" title="10.4 append函数"></a>10.4 append函数</h3><p>append函数也是内置函数，它可以将元素添加到slice里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>,</span><br><span class="line">&#125;</span><br><span class="line">sort.StringSlice(planets).Sort()</span><br><span class="line">planets = <span class="built_in">append</span>(planets, <span class="string">"Xyy"</span>)</span><br><span class="line">fmt.Println(planets) <span class="comment">// [Ear Mer Ven Xyy]</span></span><br></pre></td></tr></table></figure><p>思考一个问题</p><p>当直接声明<code>planets := []string{&quot;Mer&quot;, &quot;Ven&quot;, &quot;Ear&quot;,}</code>的时候，会创建一个数组。该数组有3个元素。后面append又给 planets添加了1个元素。因为声明的数组是定长，那么append的这个元素被添加到哪里了呢？</p><h3 id="10-5-长度和容量"><a href="#10-5-长度和容量" class="headerlink" title="10.5 长度和容量"></a>10.5 长度和容量</h3><blockquote><p>长度就是切片里有多少个元素，</p><p>容量就是指切片对应的底层数组，底层数组的容量是多少，那么切片的容量就是多少</p></blockquote><p>slice中元素的个数决定slice的长度</p><p>如果slice底层数组比slice还大，那么就说该slice还有容量可供增长</p><ul><li>获取切片的长度 len(slice)</li><li>获取切片的容量 cap(slice)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dump</span><span class="params">(label <span class="keyword">string</span>, slice []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v: length %v, cap %v \n"</span>, label, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">&#125;</span><br><span class="line">dump(<span class="string">"planets"</span>, planets)</span><br><span class="line">dump(<span class="string">"planets[1:2]"</span>, planets[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// planets: length 5, cap 5 </span></span><br><span class="line"><span class="comment">// planets[1:2]: length 1, cap 4</span></span><br></pre></td></tr></table></figure><p>当往一个切片append元素的时候，要看一下底层数组的长度够不够，如果不够的话，新声明一个长度为当前数组长度两倍长度的数组，然后将老数组的值依次复制到新数组里面，再追加append的元素。<br>如果够的话，直接追加不创建新数组；</p><p>planets[1:2] cap为何是 4 ？</p><h3 id="10-6-三个索引的切分操作"><a href="#10-6-三个索引的切分操作" class="headerlink" title="10.6 三个索引的切分操作"></a>10.6 三个索引的切分操作</h3><p>Go1.2 引入了能够限制新建切片容量的三索引切分操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">&#125;</span><br><span class="line">  ter := planets[<span class="number">0</span>:<span class="number">4</span>:<span class="number">4</span>] <span class="comment">// 第三个指定切片容量为4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-7-使用make函数对slice进行预分配"><a href="#10-7-使用make函数对slice进行预分配" class="headerlink" title="10.7 使用make函数对slice进行预分配"></a>10.7 使用make函数对slice进行预分配</h3><p>当slice的容量不足以执行append操作时，Go必须创建新数组并复制旧数组中的内容</p><p>但通过内置的make函数，可以对slice进行预分配策略</p><ul><li>尽量避免额外的内存分配和数组复制操作</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dump</span><span class="params">(label <span class="keyword">string</span>, slice []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v: length %v, cap %v \n"</span>, label, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">10</span>) <span class="comment">// 设置 长度 容量</span></span><br><span class="line">dump(<span class="string">"aa"</span>, planets) <span class="comment">// aa: length 0, cap 10</span></span><br><span class="line">planets = <span class="built_in">append</span>(planets,</span><br><span class="line"><span class="string">"Mer"</span>, <span class="string">"Ven"</span>, <span class="string">"Ear"</span>, <span class="string">"Xyy"</span>, <span class="string">"Z@@"</span>,</span><br><span class="line">)</span><br><span class="line">dump(<span class="string">"bb"</span>, planets) <span class="comment">// bb: length 5, cap 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-8-声明可变参数的函数"><a href="#10-8-声明可变参数的函数" class="headerlink" title="10.8 声明可变参数的函数"></a>10.8 声明可变参数的函数</h3><p>声明Printf append 这样的可变参数函数，需要在函数的最后一个参数前面加上 … 符号；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...string 行参</span></span><br><span class="line"><span class="comment">// planets... 实参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">terraform</span><span class="params">(prefix <span class="keyword">string</span>, worlds ...<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">newWorlds := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(worlds))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> worlds &#123;</span><br><span class="line">newWorlds[i] = prefix + <span class="string">" "</span> + worlds[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newWorlds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">twoWorlds := terraform(<span class="string">"New"</span>, <span class="string">"Venus"</span>, <span class="string">"Mars"</span>)</span><br><span class="line">fmt.Println(twoWorlds)</span><br><span class="line"><span class="comment">// [New Venus New Mars]</span></span><br><span class="line"></span><br><span class="line">planets := []<span class="keyword">string</span>&#123;<span class="string">"Venus"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>&#125;</span><br><span class="line">newPlanets := terraform(<span class="string">"New"</span>, planets...)</span><br><span class="line">fmt.Println(newPlanets)</span><br><span class="line"><span class="comment">// [New Venus New Mars New Jupiter]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-map"><a href="#11-map" class="headerlink" title="11. map"></a>11. map</h2><h3 id="11-1-声明"><a href="#11-1-声明" class="headerlink" title="11.1 声明"></a>11.1 声明</h3><p><code>map[string]int</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temperature := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">  <span class="string">"E"</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="string">"M"</span>: <span class="number">-65</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-map不会被复制"><a href="#11-2-map不会被复制" class="headerlink" title="11.2 map不会被复制"></a>11.2 map不会被复制</h3><p>数组，int 等类型在赋值给新变量或传递至函数/方法的时候会创建相应的副本</p><p>map不会, </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"E"</span>:    <span class="string">"Sector zz9"</span>,</span><br><span class="line"><span class="string">"Mars"</span>: <span class="string">"Sector zz9"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">planetsMark := planets</span><br><span class="line">planets[<span class="string">"Earth"</span>] = <span class="string">"whoops"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(planets)     <span class="comment">// map[E:Sector zz9 Earth:whoops Mars:Sector zz9]</span></span><br><span class="line">fmt.Println(planetsMark) <span class="comment">// map[E:Sector zz9 Earth:whoops Mars:Sector zz9]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(planets, <span class="string">"Earth"</span>)</span><br><span class="line">fmt.Println(planetsMark) <span class="comment">// map[E:Sector zz9 Mars:Sector zz9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-使用make对map进行预分配"><a href="#11-3-使用make对map进行预分配" class="headerlink" title="11.3 使用make对map进行预分配"></a>11.3 使用make对map进行预分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temperature := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>创建map时，make函数可以接受一个或者两个参数</p><ul><li>第二个参数用于为指定数量的key预先分配空间</li><li>使用make函数创建的map初始长度为0</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">temperatures := []<span class="keyword">float64</span>&#123;</span><br><span class="line"><span class="number">-28.0</span>, <span class="number">32.0</span>, <span class="number">-31.0</span>, <span class="number">-29.0</span>, <span class="number">-23.0</span>, <span class="number">-29.0</span>, <span class="number">-28.0</span>, <span class="number">-33.0</span>,</span><br><span class="line">&#125;</span><br><span class="line">frequency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>) <span class="comment">// key 为float64 value为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, t := <span class="keyword">range</span> temperatures &#123;</span><br><span class="line">frequency[t]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t, num := <span class="keyword">range</span> frequency &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%+.2f occurs %d times\n"</span>, t, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-struct"><a href="#12-struct" class="headerlink" title="12. struct"></a>12. struct</h2><p>struct允许将不同的类型的东西组合在一起</p><h3 id="12-1-声明"><a href="#12-1-声明" class="headerlink" title="12.1 声明"></a>12.1 声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">  lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-将struct编码为JSON"><a href="#12-2-将struct编码为JSON" class="headerlink" title="12.2 将struct编码为JSON"></a>12.2 将struct编码为JSON</h3><p>json包的Marshal函数可以将struct中的数据转化为JSON格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curiosity := location&#123;<span class="number">-4.12</span>, <span class="number">123.23</span>&#125;</span><br><span class="line">bytes, err := json.Marshal(curiosity)</span><br><span class="line">exitOnError(err)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes)) <span class="comment">// &#123;"Lat":-4.12,"Long":123.23&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitOnError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-使用struct标签来自定义JSON"><a href="#12-3-使用struct标签来自定义JSON" class="headerlink" title="12.3 使用struct标签来自定义JSON"></a>12.3 使用struct标签来自定义JSON</h3><p>go语言中的json包要求struct中的字段必须以大写字母开头，类似驼峰命名；</p><p>但有时候需要snake_case蛇形命名规范，那么该怎么办？</p><p>可以为字段标注标签，使得json包在进行编码的时候能够按照标签里的样式修改字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat  <span class="keyword">float64</span> <span class="string">`json:"latitude"xml:"latitude"`</span></span><br><span class="line">Long <span class="keyword">float64</span> <span class="string">`json:"longitude"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curiosity := location&#123;<span class="number">-4.12</span>, <span class="number">123.23</span>&#125;</span><br><span class="line">bytes, err := json.Marshal(curiosity)</span><br><span class="line">exitOnError(err)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes)) <span class="comment">// &#123;"latitude":-4.12,"longitude":123.23&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitOnError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-将方法关联到struct"><a href="#12-4-将方法关联到struct" class="headerlink" title="12.4 将方法关联到struct"></a>12.4 将方法关联到struct</h3><p>方法可以关联到声明的类型上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">  d,m,s <span class="keyword">float64</span></span><br><span class="line">  h <span class="keyword">rune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c coordinate)</span> <span class="title">decimal</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-4-1-构造函数"><a href="#12-4-1-构造函数" class="headerlink" title="12.4.1 构造函数"></a>12.4.1 构造函数</h4><p>可以使用struct复合字面值来初始化你所要的数据</p><p>但如struct初始化的时候还要做很多事情，那就可以考虑写一个构造用的函数</p><p>Go语言没有专用的构造函数，但以new或者New开头的函数，通常是用来构造数据的，例如 newPerson NewPerson</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">  d,m,s <span class="keyword">float64</span></span><br><span class="line">  h <span class="keyword">rune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c coordinate)</span> <span class="title">decimal</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  sign := <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">switch</span> c.h &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>, <span class="string">'W'</span>,<span class="string">'s'</span>,<span class="string">'w'</span>:</span><br><span class="line">    sign = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sign * (c.d + c.m/<span class="number">60</span> + c.s/<span class="number">3600</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造用的函数,在go中没有专业的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLocation</span><span class="params">(lat, long coordinate)</span> <span class="title">location</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> location&#123;lat.decimal(), long.decimal()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">  lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  lat := coordinate&#123;...&#125;</span><br><span class="line">  long := coordinate&#123;...&#125;</span><br><span class="line">  curiosity := newLocation(lat, long)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-4-2-New函数"><a href="#12-4-2-New函数" class="headerlink" title="12.4.2 New函数"></a>12.4.2 New函数</h4><p>有一些用于构造的函数的名称就是New （例如errors包里面的New函数）</p><p>这是因为函数调用时使用 包名.函数名 的形式</p><p>如果该函数叫NewError，那么调用的时候就是errors.NewError()， 这就不如errors.New() 简洁</p><h3 id="12-5-class的替代方案"><a href="#12-5-class的替代方案" class="headerlink" title="12.5 class的替代方案"></a>12.5 class的替代方案</h3><p>Go语言没有class，但使用struct并配备几个方法也可以达到同样的效果</p><h2 id="13-组合和转发"><a href="#13-组合和转发" class="headerlink" title="13. 组合和转发"></a>13. 组合和转发</h2><h3 id="13-1-组合"><a href="#13-1-组合" class="headerlink" title="13.1 组合"></a>13.1 组合</h3><p>在面向对象的世界中，对象由更小的对象组合而成</p><p>术语： 对象组合或组合</p><p>Go通过结构体视线组合（composition）</p><p>Go提供了“嵌入”（embedding） 特性，他可以实现方法的转发（forwarding）</p><p>组合是一种更简单，灵活的方式</p><p><strong>拆分类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">å<span class="keyword">type</span> report <span class="keyword">struct</span> &#123;</span><br><span class="line">sol       <span class="keyword">int</span></span><br><span class="line">high, low <span class="keyword">float64</span></span><br><span class="line">lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol         <span class="keyword">int</span></span><br><span class="line">temperature temperature</span><br><span class="line">location    location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br></pre></td></tr></table></figure><p><strong>duck type</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol         <span class="keyword">int</span></span><br><span class="line">temperature temperature</span><br><span class="line">location    location</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t temperature)</span> <span class="title">averae</span><span class="params">()</span> <span class="title">celsius</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (t.high + t.low) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reportNew)</span> <span class="title">averae</span><span class="params">()</span> <span class="title">celsius</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.temperature.averae()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := temperature&#123;high: <span class="number">12.4</span>, low: <span class="number">134.5</span>&#125;</span><br><span class="line">loc := location&#123;lat: <span class="number">22.3</span>, long: <span class="number">34.9</span>&#125;</span><br><span class="line">report := reportNew&#123;</span><br><span class="line">sol:         <span class="number">12</span>,</span><br><span class="line">temperature: t,</span><br><span class="line">location:    loc,</span><br><span class="line">&#125;</span><br><span class="line">t.averae()</span><br><span class="line">report.temperature.averae() <span class="comment">// duck type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-转发方法"><a href="#13-2-转发方法" class="headerlink" title="13.2 转发方法"></a>13.2 转发方法</h3><p>Go可以通过struct嵌入 来实现方法的转发</p><p>在struct中只给定字段类型，不给定字段名即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol         <span class="keyword">int</span></span><br><span class="line">temperature temperature <span class="comment">// 字段名 类型</span></span><br><span class="line">location    location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reportNew <span class="keyword">struct</span> &#123;</span><br><span class="line">sol <span class="keyword">int</span></span><br><span class="line">temperature <span class="comment">// struct 嵌入</span></span><br><span class="line">location <span class="comment">// 只有类型，没有字段名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struct的嵌入之后，被嵌入的类型可以直接使用 嵌入类型上的方法了</p><p>在struct中，可以转发任意类型</p><h3 id="13-3-命名冲突"><a href="#13-3-命名冲突" class="headerlink" title="13.3 命名冲突"></a>13.3 命名冲突</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> report <span class="keyword">struct</span> &#123;</span><br><span class="line">sol</span><br><span class="line">temperature</span><br><span class="line">location</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> temperature <span class="keyword">struct</span> &#123;</span><br><span class="line">high, low celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long celsius</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> sol <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">days := <span class="keyword">int</span>(s2 - s)</span><br><span class="line"><span class="keyword">if</span> days &lt; <span class="number">0</span> &#123;</span><br><span class="line">days = -days</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> days</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">days</span><span class="params">(l2 location)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">report := report&#123;sol: <span class="number">15</span>&#125;</span><br><span class="line">fmt.Println(report.sol.days(<span class="number">1446</span>))</span><br><span class="line">fmt.Println(report.days(<span class="number">1446</span>)) <span class="comment">// error 发生歧义， 编译器不知道该调 location类型还是sol类型下面的days方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">days := <span class="keyword">int</span>(s2 - s)</span><br><span class="line"><span class="keyword">if</span> days &lt; <span class="number">0</span> &#123;</span><br><span class="line">days = -days</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> days</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">days</span><span class="params">(l2 location)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r report)</span> <span class="title">days</span><span class="params">(s2 sol)</span> <span class="title">int</span></span> &#123; <span class="comment">// 顶级类型，可以调用report.days直接访问</span></span><br><span class="line">  <span class="keyword">return</span> r.sol.days(s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">report := report&#123;sol: <span class="number">15</span>&#125;</span><br><span class="line">fmt.Println(report.sol.days(<span class="number">1446</span>))</span><br><span class="line">fmt.Println(report.days(<span class="number">1446</span>)) <span class="comment">// compiler success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-4-继承还是组合"><a href="#13-4-继承还是组合" class="headerlink" title="13.4 继承还是组合"></a>13.4 继承还是组合</h3><p>优先使用对象组合而不是类的继承</p><p>对传统的继承不是必须额，所有使用继承解决的问题都可以通过其它方法解决；</p><h2 id="14-接口"><a href="#14-接口" class="headerlink" title="14. 接口"></a>14. 接口</h2><p>接口关注于类型可以做什么，而不是存储了什么</p><p>接口通过列举类型必须满足的一组方法来进行声明</p><p>在Go语言中，不需要显式声明接口；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 多态</span></span><br><span class="line">t = martian&#123;&#125; <span class="comment">// martian 类型实现了talk方法，所以可以直接赋值</span></span><br><span class="line">fmt.Println(t.talk())</span><br><span class="line">t = laser(<span class="number">3</span>) <span class="comment">// laser 类型实现了talk方法，所以可以直接赋值</span></span><br><span class="line">fmt.Println(t.talk())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-1-接口类型"><a href="#14-1-接口类型" class="headerlink" title="14.1 接口类型"></a>14.1 接口类型</h3><p>为了复用，通常会把接口声明为类型</p><p>按约定，接口名称通常以er结尾</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">shout(martian&#123;&#125;) <span class="comment">// martian 实现了 talker 类型，可以直接调用</span></span><br><span class="line">shout(laser(<span class="number">2</span>)) <span class="comment">// laser实现了 talker类型，可以直接调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口可以和struct嵌入特性一同使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> starship <span class="keyword">struct</span> &#123;</span><br><span class="line">laser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := starship&#123;laser(<span class="number">3</span>)&#125; <span class="comment">// starship 类型包含了laser</span></span><br><span class="line">fmt.Println(s.talk()) <span class="comment">// 因为laser实现talk方法，所以 starship可以调用talk方法</span></span><br><span class="line">shout(s) <span class="comment">// starship有talk方法，满足了 talker类型，而talker类型又能作为 shout函数的参数，所以可以将 starship 传入shout方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时使用组合和接口将构成非常强大的设计工具；</p><h3 id="14-2-探索接口"><a href="#14-2-探索接口" class="headerlink" title="14.2 探索接口"></a>14.2 探索接口</h3><p>Go语言的接口都是隐式满足的</p><p>Go允许在实现代码的过程中，随时创建新的接口。任何代码都能实现接口。包括已经存在的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stardater <span class="keyword">interface</span> &#123;</span><br><span class="line">YearDay() <span class="keyword">int</span></span><br><span class="line">Hour() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> sol <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">YearDay</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(s % <span class="number">668</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sol)</span> <span class="title">Hour</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func stardate(t time.Time) float64 &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stardate</span><span class="params">(t stardater)</span> <span class="title">float64</span></span> &#123; <span class="comment">// 既然 stardater实现了 YearDay和Hour，可以更改此类型</span></span><br><span class="line">doy := <span class="keyword">float64</span>(t.YearDay())</span><br><span class="line">h := <span class="keyword">float64</span>(t.Hour()) / <span class="number">24.0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1000</span> + doy + h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">day := time.Date(<span class="number">2012</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Printf(<span class="string">"%.1f Has\n"</span>, stardate(day))</span><br><span class="line"></span><br><span class="line">s := sol(<span class="number">1422</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%.1f Happy\n"</span>, stardate(s)) <span class="comment">// 因为sol类型也实现了stardater接口，所以可以传入stardate方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-3-满足接口"><a href="#14-3-满足接口" class="headerlink" title="14.3 满足接口"></a>14.3 满足接口</h3><p>Go标准库导出了很多只有单个方法的接口；</p><p>Go通过简单的、通常只有单个方法的接口… 来鼓励组合而不是继承，这些接口在各个组件之间形成了简明易懂的界限</p><p>例如在fmt包 声明的Stringer接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> location <span class="keyword">struct</span> &#123;</span><br><span class="line">lat, long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l location)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v, %v"</span>, l.lat, l.long)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">curiosity := location&#123;<span class="number">-4.5895</span>, <span class="number">137.4417</span>&#125;</span><br><span class="line">fmt.Println(curiosity) <span class="comment">// location实现了String方法，满足了 Stringer接口。 所以就能被fmt.Println 调用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库中常用的接口还包括: io.Reader, io.Write, json.Marshaler</p><h2 id="15-指针"><a href="#15-指针" class="headerlink" title="15 指针"></a>15 指针</h2><p>指针是指向另一个变量地址的变量</p><p>Go语言的指针同时也强调安全性，不会出现迷途指针（dangling pointers）</p><h3 id="15-1-amp-和"><a href="#15-1-amp-和" class="headerlink" title="15.1 &amp; 和 *"></a>15.1 &amp; 和 *</h3><p>变量会将它们的值存储在计算机的RAM里，存储位置就是该变量的内存地址；</p><p>&amp; ： 获得变量的内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">answer := <span class="number">42</span></span><br><span class="line">fmt.Println(&amp;answer) <span class="comment">// 0xc000014090</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp; 操作符无法获得字符串/数值/布尔字面值的地址；</p><ul><li>&amp;42， &amp;”hello” 这些都会导致编译器报错</li></ul><p><code>*操作符</code>与&amp;的作用相反，它用来解引用，提供内存地址指向的值；</p><p>C语言中的内存地址可以通过 address++ 这样的指针运算进行操作，在Go里面不允许这种不安全的操作</p><h3 id="15-2-指针类型"><a href="#15-2-指针类型" class="headerlink" title="15.2 指针类型"></a>15.2 指针类型</h3><p>指针存储的是内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">answer := <span class="number">42</span></span><br><span class="line">address := &amp;answer    <span class="comment">// *int address就是一个指向int类型的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针类型和其它普通类型一样，出现在所有需要用到类型的地方，如变量声明、函数行参、返回值类型、结构体字段等</p><p>将*放在类型前面表示声明指针类型</p><p>将*放在变量前面表示解引用操作</p><h3 id="15-3-指针就是用来指向的"><a href="#15-3-指针就是用来指向的" class="headerlink" title="15.3 指针就是用来指向的"></a>15.3 指针就是用来指向的</h3><p>两个指针变量持有相同的内存地址，那么它们就是相等的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 说明下面语句的作用</span></span><br><span class="line">a = *b; <span class="comment">// 将b指针解引用，赋值给a，这个是值拷贝</span></span><br><span class="line">*b = <span class="string">'alex'</span> <span class="comment">// b地址解引用，重复赋值</span></span><br></pre></td></tr></table></figure><h3 id="15-4-指向结构的指针"><a href="#15-4-指向结构的指针" class="headerlink" title="15.4 指向结构的指针"></a>15.4 指向结构的指针</h3><p>与字符串和数值不一样，复合字面量的前面可以放置&amp;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name, superpower <span class="keyword">string</span></span><br><span class="line">age              <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">timmy := &amp;person&#123;</span><br><span class="line">name: <span class="string">"alex"</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (*timmy).superpower = "flying" // 访问字段时， 解引用不是必须要做的</span></span><br><span class="line">timmy.superpower = <span class="string">"flying"</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, timmy) <span class="comment">// &amp;&#123;name:alex superpower:flying age:10&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问字段时，对结构体进行解引用并不是必须的；</p><h3 id="15-5-指向数组的指针"><a href="#15-5-指向数组的指针" class="headerlink" title="15.5 指向数组的指针"></a>15.5 指向数组的指针</h3><p>和结构体一样，可以把&amp; 放在数组的复合字面值前面来创建指向数组的指针</p><p>数组在执行索引或切片操作时会自动解引用。没有必要写(*array)[0]这种形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  arr := &amp;[<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line">  arr[<span class="number">0</span>]</span><br><span class="line">  arr[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与C语言不一样，Go里面数组和指针是两种完全独立的类型</p><p>slice和map的复合字面值前面也可以放置 &amp;操作符，但是Go并没有为它们提供自动解引用的功能；</p><h4 id="15-5-1-修改数组"><a href="#15-5-1-修改数组" class="headerlink" title="15.5.1  修改数组"></a>15.5.1  修改数组</h4><p>函数通过指针对数组的元素进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rune指的是？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">(board *[8][8]<span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'r'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> board [<span class="number">8</span>][<span class="number">8</span>]<span class="keyword">rune</span></span><br><span class="line">reset(&amp;board)</span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, board[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">// r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-5-2-什么情况下应该使用指向数组的指针"><a href="#15-5-2-什么情况下应该使用指向数组的指针" class="headerlink" title="15.5.2 什么情况下应该使用指向数组的指针"></a>15.5.2 什么情况下应该使用指向数组的指针</h4><p>隐式的指针</p><p>Go语言里一些内置的集合类型就在暗中使用指针</p><p>map在被赋值或者被作为参数传递的时候不会被复制</p><ul><li>map就是一种隐式指针</li><li>这种写法就是多此一举： func demo(planets *map[string]string) 应该去掉🌟</li></ul><p>map的键值都可以是指针类型</p><p>需要将指针指向map的情况并不多见</p><h4 id="15-5-3-slice指向数组"><a href="#15-5-3-slice指向数组" class="headerlink" title="15.5.3 slice指向数组"></a>15.5.3 slice指向数组</h4><p>之前说过slice是指向数组的窗口，实际上slice在指向数组元素的时候也使用了指针；</p><p>每个slice内部都会被表示为一个包含3个元素的结构，它们分别指向：</p><ul><li>数组的指针</li><li>slice的容量</li><li>slice的长度</li></ul><p>当slice被直接传递至函数或方法时，slice的内部指针就可以对底层数据进行修改 </p><p>指向slice的显式指针的唯一作用就是修改slice本身： slice的长度、容量以及起始偏移量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reclassify</span><span class="params">(p *[]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">*p = (*p)[<span class="number">0</span>:<span class="number">8</span>] <span class="comment">// 修改切片本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">planets := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"m"</span>, <span class="string">"v"</span>, <span class="string">"E"</span>, <span class="string">"MA"</span>, <span class="string">"ju"</span>, <span class="string">"sa"</span>, <span class="string">"ur"</span>, <span class="string">"ne"</span>, <span class="string">"pl"</span>,</span><br><span class="line">&#125;</span><br><span class="line">reclassify(&amp;planets)</span><br><span class="line">fmt.Println(planets) <span class="comment">// [m v E MA ju sa ur ne]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-5-4-指针和接口"><a href="#15-5-4-指针和接口" class="headerlink" title="15.5.4 指针和接口"></a>15.5.4 指针和接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">shout(martian&#123;&#125;)</span><br><span class="line">shout(&amp;martian&#123;&#125;)</span><br><span class="line"><span class="comment">// NACK NACK</span></span><br><span class="line"><span class="comment">// NACK NACK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是martian 还是指向martian的指针，都可以满足talker接口</p><p>如果方法使用的指针接收者，那么情况会有所不同；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">louder := strings.ToUpper(t.talk())</span><br><span class="line">fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"nack nack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Repeat(<span class="string">"pew"</span>, <span class="keyword">int</span>(*l))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pew := laser(<span class="number">2</span>)</span><br><span class="line">shout(&amp;pew) <span class="comment">// PEWPEW</span></span><br><span class="line">shout(pew) <span class="comment">// compiler error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-6-实现修改"><a href="#15-6-实现修改" class="headerlink" title="15.6 实现修改"></a>15.6 实现修改</h3><p>Go语言的函数和方法都是按值传递参数的，这意味着函数总是操作于被传递参数的副本；</p><p>当指针被传递到函数时，函数将接收传入的内存地址的副本，之后函数可以通过解引用内存地址来修改指针指向的值；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name, superpower <span class="keyword">string</span></span><br><span class="line">age              <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">birthday</span><span class="params">(p *person)</span></span> &#123;</span><br><span class="line">p.age++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">rebecca := person&#123;</span><br><span class="line">name:       <span class="string">"alex"</span>,</span><br><span class="line">age:        <span class="number">10</span>,</span><br><span class="line">superpower: <span class="string">"imagination"</span>,</span><br><span class="line">&#125;</span><br><span class="line">birthday(&amp;rebecca) <span class="comment">// 传入的虽然是指针副本，但是指向同一地址</span></span><br><span class="line"><span class="comment">// birthday(rebecca) // 传入的是引用类型副本，等于复制了一个引用类型，性能差</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, rebecca) <span class="comment">// &#123;name:alex superpower:imagination age:11&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-7-指针接收者"><a href="#15-7-指针接收者" class="headerlink" title="15.7 指针接收者"></a>15.7 指针接收者</h3><p>方法的接收者和方法的参数在处理指针方面是很相似的</p><p>Go语言在变量通过点标记法进行调用的时候，自动使用&amp;取得变量的内存地址</p><ul><li>所以不用写 (&amp;nathan).birthday() 这种形式也可以正常运行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">birthday</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">terry := &amp;person&#123;</span><br><span class="line">name: <span class="string">"alex"</span>,</span><br><span class="line">age:  <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line">terry.birthday()</span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, terry) <span class="comment">// &amp;&#123;name:alex age:16&#125;</span></span><br><span class="line"></span><br><span class="line">nathan := person&#123;</span><br><span class="line">name: <span class="string">"leo"</span>,</span><br><span class="line">age:  <span class="number">17</span>,</span><br><span class="line">&#125;</span><br><span class="line">nathan.birthday()</span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, nathan) <span class="comment">// &#123;name:leo age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指针作为接收者的策略应该始终如一：</p><p>如果一种类型的某些方法需要用到指针作为接收者，就应该为这种类型的所有方法都是用指针作为接收者；</p><h3 id="15-8-内部指针"><a href="#15-8-内部指针" class="headerlink" title="15.8 内部指针"></a>15.8 内部指针</h3><p>Go语言提供了内部指针这种特性</p><p>它用于确定结构体中指定字段的内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stats <span class="keyword">struct</span> &#123;</span><br><span class="line">level             <span class="keyword">int</span></span><br><span class="line">endurance, health <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelUp</span><span class="params">(s *stats)</span></span> &#123;</span><br><span class="line">s.level++</span><br><span class="line">s.endurance = <span class="number">42</span> + (<span class="number">15</span> * s.level)</span><br><span class="line">s.health = <span class="number">5</span> * s.endurance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> character <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">stats stats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">player := character&#123;name: <span class="string">"alex"</span>&#125;</span><br><span class="line">levelUp(&amp;player.stats)            <span class="comment">//  结构体某个字段的地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, player.stats) <span class="comment">// &#123;level:1 endurance:57 health:285&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;操作符不仅可以获得结构体的内存地址，还可以获得结构体中指定字段的内存地址；</p><h3 id="15-9-小结"><a href="#15-9-小结" class="headerlink" title="15.9 小结"></a>15.9 小结</h3><p>应合理使用指针，不要过度使用指针</p><h2 id="16-nil"><a href="#16-nil" class="headerlink" title="16. nil"></a>16. nil</h2><p>nil是一个名字，表示“无” 或“零”</p><p>Go里面，nil是一个零值</p><p>如果一个指针没有明确的指向，那么它的值就是nil</p><p>除了指针，nil还是slice、map和接口的零值</p><p>Go语言的nil，比以往语言中的null更为友好，并且用的没那么频繁，但是仍需谨慎使用</p><h3 id="16-1-nil会导致panic"><a href="#16-1-nil会导致panic" class="headerlink" title="16.1 nil会导致panic"></a>16.1 nil会导致panic</h3><p>如果指针没有明确的指向，那么程序将无法对其实施的解引用。</p><p>尝试解引用一个nil指针将导致程序崩溃</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nowhere *<span class="keyword">int</span></span><br><span class="line">fmt.Println(nowhere) <span class="comment">//  &lt;nil&gt;</span></span><br><span class="line">fmt.Println(*nowhere) <span class="comment">// compiler error</span></span><br><span class="line">  <span class="comment">// 防范代码</span></span><br><span class="line">  <span class="keyword">if</span> nowhere != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(*nowhere)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">days</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.age++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为值为nil的接收者和值为nil的参数在行为上并没有区别，所以go语言即使在接收者为nil的情况下，也会继续调用方法；</p><h3 id="16-2-nil函数值"><a href="#16-2-nil函数值" class="headerlink" title="16.2 nil函数值"></a>16.2 nil函数值</h3><p>当变量被声明为函数类型时，它的默认值是nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">fmt.Println(fn == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查函数值是否为nil，并在有需要时提供默认行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortStrings</span><span class="params">(s []<span class="keyword">string</span>, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> less == <span class="literal">nil</span> &#123;</span><br><span class="line">less = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(s, less)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">food := []<span class="keyword">string</span>&#123;<span class="string">"onion"</span>, <span class="string">"carrot"</span>, <span class="string">"celery"</span>&#125;</span><br><span class="line">sortStrings(food, <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(food) <span class="comment">// [carrot celery onion]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-nil-slice"><a href="#16-3-nil-slice" class="headerlink" title="16.3 nil slice"></a>16.3 nil slice</h3><p>如果slice 在声明之后没有使用复合字面值或内置的make 函数进行初始化，那么它的值就是nil</p><p>幸运的是，range、len、append等内置数都可以正常处理值为nil的slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> soup []<span class="keyword">string</span></span><br><span class="line">fmt.Println(soup == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> _, ingredient := <span class="keyword">range</span> soup &#123;</span><br><span class="line">fmt.Println(ingredient)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(soup)) <span class="comment">// 0</span></span><br><span class="line">soup = <span class="built_in">append</span>(soup, <span class="string">"onion"</span>, <span class="string">"carrort"</span>, <span class="string">"celery"</span>)</span><br><span class="line">fmt.Println(soup) <span class="comment">// [onion carrort celery]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然空slice和值为nil的slice并不相等，但它们通常可以替换使用；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirepoix</span><span class="params">(ingredients []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(ingredients, <span class="string">"onion"</span>, <span class="string">"carrot"</span>, <span class="string">"celery"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">soup := mirepoix(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(soup) <span class="comment">// [onion carrort celery]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-4-nil-map"><a href="#16-4-nil-map" class="headerlink" title="16.4 nil map"></a>16.4 nil map</h3><p>和slice一样，如果map在声明后没有使用复合字面值或内置的make函数进行初始化，那么它的值将会是默认的nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> soup <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(soup == <span class="literal">nil</span>)         <span class="comment">// true</span></span><br><span class="line">measurement, ok := soup[<span class="string">"onion"</span>] <span class="comment">// 对值为nil的map读取不会报错</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(measurement)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ingredient, measurement := <span class="keyword">range</span> soup &#123; <span class="comment">// 对值为nil的 map进行 range操作依然不会报错</span></span><br><span class="line">fmt.Println(ingredient, measurement)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-5-nil接口"><a href="#16-5-nil接口" class="headerlink" title="16.5 nil接口"></a>16.5 nil接口</h3><p>声明为接口类型的变量在未被赋值时，它的零值是nil</p><p>对于一个未被赋值的接口变量来说，它的接口类型和值都是nil，并且变量本身也等于nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// %T 接口类型</span></span><br><span class="line"><span class="comment">// %v 值</span></span><br></pre></td></tr></table></figure><p>当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">v = p</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// *int &lt;nil&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。</p><p>在Go中，接口类型的变量只有在类型和值都为nil时才等于nil</p><ul><li>即使接口变量的值仍为nil，但只要它的类型不是nil，那么该变量就不等于nil；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T %v %v\n"</span>, v, v, v == <span class="literal">nil</span>) <span class="comment">// &lt;nil&gt; &lt;nil&gt; true</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">v = p</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, v) <span class="comment">//(*int)(nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-6-nil之外的另一个选择"><a href="#16-6-nil之外的另一个选择" class="headerlink" title="16.6 nil之外的另一个选择"></a>16.6 nil之外的另一个选择</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> number <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="keyword">int</span></span><br><span class="line">valid <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNumber</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">number</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> number&#123;value: v, valid: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n number)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !n.valid &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"not set"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>, n.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := newNumber(<span class="number">42</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 42</span></span><br><span class="line">e := number&#123;&#125;</span><br><span class="line">fmt.Println(e) <span class="comment">// not set</span></span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><h2 id="17-处理错误"><a href="#17-处理错误" class="headerlink" title="17 处理错误"></a>17 处理错误</h2><p>Go语言允许函数和方法同时返回多个值</p><p>按照惯例，函数在返回错误时，最后边的返回值应用来表示错误</p><p>调用函数后，应立即检查是否发生错误；</p><ul><li>如果没有错误发生，那么返回的错误值为nil</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">files, err := ioutil.ReadDir(<span class="string">"."</span>) <span class="comment">// . 表示当前目录</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">fmt.Println(file.Name()) <span class="comment">// 00.go</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> </p><p>当错误发生时候，函数返回的其它值通常就不再可信</p><h3 id="17-1-优雅的错误处理"><a href="#17-1-优雅的错误处理" class="headerlink" title="17.1 优雅的错误处理"></a>17.1 优雅的错误处理</h3><p>减少错误处理代码是一种策略是： 将程序中不会出错的部分和包含潜在错误隐患的部分隔离开来</p><p>对于不得不返回错误的代码，应尽力简化相应的错误处理代码</p><h3 id="17-2-go的谚语"><a href="#17-2-go的谚语" class="headerlink" title="17.2 go的谚语"></a>17.2 go的谚语</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Errors are value， </span><br><span class="line">Do not just check erros， handle them gracefully <span class="comment"># 除了检查错误，还要优雅的处理它们</span></span><br><span class="line">Do not panic</span><br><span class="line"></span><br><span class="line">Make the zero value useful</span><br><span class="line"></span><br><span class="line">the bigger the interface, the weaker the abstraction <span class="comment"># interface越大，抽象度越差</span></span><br><span class="line"></span><br><span class="line">interface &#123;&#125; says nothing <span class="comment"># interface&#123;&#125; 相当于什么都没定义，可以表示任意类型</span></span><br><span class="line"></span><br><span class="line">Gofmt is style is no one is favorite, yet gofmt is everyone is favorite <span class="comment"># gofmt的样式所有人都不喜欢，但gofmt 所有人都喜欢</span></span><br><span class="line"></span><br><span class="line">Doc is <span class="keyword">for</span> users</span><br><span class="line"></span><br><span class="line">a litter copying is better than a little dependency <span class="comment"># 少许的拷贝要比少许的依赖要好</span></span><br><span class="line"></span><br><span class="line">clear is better than clever</span><br><span class="line"><span class="comment"># 清晰比聪明更好</span></span><br><span class="line"></span><br><span class="line">concurrency is not parallelism</span><br><span class="line"><span class="comment"># 并发并不是并行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> not communicate by sharing memory, share memory by communicating</span><br><span class="line"><span class="comment"># 不要通过共享内存来进行通信,通过通信来共享内存</span></span><br><span class="line"></span><br><span class="line">channels orchestrate； mutexes serialize</span><br><span class="line"><span class="comment"># channels 应该进行编排，mutexes（互斥量）按序列化执行</span></span><br></pre></td></tr></table></figure><h3 id="17-3-文件写入"><a href="#17-3-文件写入" class="headerlink" title="17.3 文件写入"></a>17.3 文件写入</h3><p>写入文件的时候可能出错：</p><ul><li>路径不正确</li><li>权限不够</li><li>磁盘空间不足</li></ul><p>文件写入完毕后，必须被关闭，确保文件被刷到磁盘上，避免资源的泄漏；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到 f文件内</span></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Errors are values."</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// write error</span></span><br><span class="line">f.Close()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Do not just check erros, handle them gracefully"</span>)</span><br><span class="line">f.Close()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := proverbs(<span class="string">"proverbs.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-4-内置类型-error"><a href="#17-4-内置类型-error" class="headerlink" title="17.4 内置类型 error"></a>17.4 内置类型 error</h3><p>内置类型error用来表示错误</p><h2 id="18-defer关键字"><a href="#18-defer关键字" class="headerlink" title="18 defer关键字"></a>18 defer关键字</h2><p>使用defer关键字，Go可以确保<code>所有deferred的动作可以在函数返回前执行</code>；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入到 f文件内</span></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Errors are values."</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// write error</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = fmt.Fprintln(f, <span class="string">"Do not just check erros, handle them gracefully"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := proverbs(<span class="string">"proverbs.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以defer任意的函数和方法</p><p>defer并不是专门做错误处理的；</p><p>defer可以消除必须时刻惦记执行资源释放的负担</p><h3 id="18-1-defer的动作什么时候会被执行"><a href="#18-1-defer的动作什么时候会被执行" class="headerlink" title="18.1 defer的动作什么时候会被执行"></a>18.1 defer的动作什么时候会被执行</h3><p>有创意的错误处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> safeWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">w   io.Writer</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *safeWriter)</span> <span class="title">writeln</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> sw.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, sw.err = fmt.Fprintln(sw.w, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proverbs</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">sw := safeWriter&#123;w: f&#125;</span><br><span class="line">sw.writeln(<span class="string">"Errors are values"</span>)</span><br><span class="line">sw.writeln(<span class="string">"Do not juse check errors, handle them gracefully"</span>)</span><br><span class="line">sw.writeln(<span class="string">"do not panic"</span>)</span><br><span class="line"><span class="keyword">return</span> sw.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-2-New-error"><a href="#18-2-New-error" class="headerlink" title="18.2 New error"></a>18.2 New error</h3><p>erros包里有一个构造用New函数，它接收string作为参数用来表示错误信息。该函数返回error类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An error occurred: %v, \n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// An error occurred: out of bounds,</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>错误信息应具有信息性</p><p>可以把错误信息当作用户界面的一部分，无论对最终用户还是开发者；</p><h3 id="18-3-按需返回错误"><a href="#18-3-按需返回错误" class="headerlink" title="18.3 按需返回错误"></a>18.3 按需返回错误</h3><p>按照惯例，包含错误信息的变量名应以Err开头</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// 按惯例，包含错误信息的变量名应以Err开头</span></span><br><span class="line">ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrBounds</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrBounds, ErrDigit:</span><br><span class="line">fmt.Println(<span class="string">"Les erreurs de parametres hors limites."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>errors.New 这个构造函数是使用指针实现的，所以上例中的switch语句比较的是内存地址，而不是错误包含的文字信息</p><h3 id="18-4-自定义错误类型"><a href="#18-4-自定义错误类型" class="headerlink" title="18.4 自定义错误类型"></a>18.4 自定义错误类型</h3><p>error类型是一个内置的接口：任何类型只要实现了返回string的Error()方法就满足了该接口；</p><p>可以创建新的错误类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SudokuError []error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(se SudokuError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> se &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strings.Join(s, <span class="string">", "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errs SudokuError</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrBounds)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !validDigit(digit) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrDigit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">int8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> digit &gt;= <span class="number">1</span> &amp;&amp; digit &lt;= <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">12</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrBounds, ErrDigit:</span><br><span class="line">fmt.Println(<span class="string">"Les erreurs de parametres hors limites."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out of bounds, invalid digit</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br></pre></td></tr></table></figure><p>按照惯例， 自定义错误类型的名字应以Error结尾</p><ul><li>有时候名字就是Error，例如 url.Error</li></ul><h3 id="18-5-类型断言"><a href="#18-5-类型断言" class="headerlink" title="18.5 类型断言"></a>18.5 类型断言</h3><p>上例中，我们可以使用类型断言来访问每一种错误；</p><p>使用类型断言，你可以把接口类型转化成底层的具体类型</p><ul><li>例如： err.(SudokuError)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rows, columns = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grid [rows][columns]<span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrBounds = errors.New(<span class="string">"out of bounds"</span>)</span><br><span class="line">ErrDigit  = errors.New(<span class="string">"invalid digit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SudokuError []error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(se SudokuError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> se &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strings.Join(s, <span class="string">", "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Grid)</span> <span class="title">Set</span><span class="params">(row, column <span class="keyword">int</span>, digit <span class="keyword">int8</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errs SudokuError</span><br><span class="line"><span class="keyword">if</span> !inBounds(row, column) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrBounds)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !validDigit(digit) &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, ErrDigit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line">g[row][column] = digit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">int8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> digit &gt;= <span class="number">1</span> &amp;&amp; digit &lt;= <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inBounds</span><span class="params">(row, column <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> row &lt; <span class="number">0</span> || row &gt;= rows &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> column &lt; <span class="number">0</span> || column &gt;= columns &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g Grid</span><br><span class="line">err := g.Set(<span class="number">10</span>, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 使用类型错误断言，</span></span><br><span class="line"><span class="keyword">if</span> errs, ok := err.(SudokuError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d error(s) occurred: \n"</span>, <span class="built_in">len</span>(errs))</span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> errs &#123;</span><br><span class="line">fmt.Printf(<span class="string">"- %v\n"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - out of bounds</span></span><br><span class="line"><span class="comment">// - invalid digit</span></span><br><span class="line"><span class="comment">// exit status 1</span></span><br></pre></td></tr></table></figure><p>如果类型满足多个接口，那么类型断言使它从一个接口类型转化为另一个接口类型</p><h3 id="18-6-do-not-panic（不要恐慌）"><a href="#18-6-do-not-panic（不要恐慌）" class="headerlink" title="18.6 do not panic（不要恐慌）"></a>18.6 do not panic（不要恐慌）</h3><p>Go没有异常，它有个类似机制panic</p><p>当panic发生，那么程序就会崩溃</p><h3 id="18-7-其它语言的异常-vs-Go的错误值"><a href="#18-7-其它语言的异常-vs-Go的错误值" class="headerlink" title="18.7 其它语言的异常 vs Go的错误值"></a>18.7 其它语言的异常 vs Go的错误值</h3><p>其它语言的异常在行为和实现上与Go语言的错误值有很大的不同</p><ul><li>如果函数抛出异常，并且附近没人捕获它，那么它就会 冒泡 到函数的调用者那里，如果还没有人进行捕获，那么就继续“冒泡”到更上层的调用者。。。直到达到栈（Stack）的顶部（例如main函数）</li><li>异常这种错误处理方式可被看作是可选的；<ul><li>不处理异常，就不需要加入其它代码；</li><li>想要处理异常，就需要加入相当数量的专用代码</li></ul></li><li>Go语言中错误值更简单灵活；<ul><li>忽略错误是有意识的决定，从代码上看也是显而易见的；</li></ul></li></ul><h3 id="18-8-如何panic"><a href="#18-8-如何panic" class="headerlink" title="18.8 如何panic"></a>18.8 如何panic</h3><p>Go里有一个和其它语言异常类似的机制： panic</p><p>实际上，panic很少出现</p><p>创建panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="string">"i forgot my towel"</span>)</span><br></pre></td></tr></table></figure><p>panic的参数可以是任意类型</p><h3 id="18-9-错误值、panic、os-Exit"><a href="#18-9-错误值、panic、os-Exit" class="headerlink" title="18.9 错误值、panic、os.Exit"></a>18.9 错误值、panic、os.Exit</h3><p>通常，更推荐使用错误值，其次才是panic</p><p>panic比Os.Exit更好： panic后会执行所有defer的动作，而Os.Exit则不会</p><p>有时候Go程序会panic而不是返回错误值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> zero <span class="keyword">int</span></span><br><span class="line">_ = <span class="number">42</span> / zero</span><br><span class="line"><span class="comment">// panic: runtime error: integer divide by zero</span></span><br><span class="line"><span class="comment">// exit status 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止panic导致程序崩溃，Go提供了recover函数(恢复)</p><p>defer的动作会在函数返回前执行，即使发生了panic</p><p>但如果defer的函数调用了recover，panic就会停止，程序将继续运行；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// defer会在函数返回前执行，即使发生panic</span></span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;<span class="comment">// defer调用recover，panic就会停止，程序将继续执行</span></span><br><span class="line">fmt.Println(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"i forgot my towel"</span>)</span><br><span class="line"><span class="comment">// i forgot my towel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-goroutine和并发（concurrent）"><a href="#19-goroutine和并发（concurrent）" class="headerlink" title="19 goroutine和并发（concurrent）"></a>19 goroutine和并发（concurrent）</h2><h3 id="19-1-goroutine"><a href="#19-1-goroutine" class="headerlink" title="19.1 goroutine"></a>19.1 goroutine</h3><p>在Go中，独立的任务叫做goroutine</p><ul><li>虽然goroutine与其它语言中的协程、进程、线程都有相似之处，但goroutine和它们并不完全相同</li><li>goroutine和它们并不完全相同，</li><li>Goroutine创建效率非常高</li><li>Go能直截了当的协同多个并发（concurrent）操作</li></ul><p>在某些语言中，将顺序式代码转化为并发式代码需要做大量修改。</p><p>在Go里，无需修改现有顺序式的代码，就可以通过goroutine以并发的方式运行任意数量的任务；</p><h3 id="19-2-启动goroutine"><a href="#19-2-启动goroutine" class="headerlink" title="19.2 启动goroutine"></a>19.2 启动goroutine</h3><p>只需在调用前面加一个go关键字；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher() <span class="comment">// go 关键字相当于启动一个 goroutine,另开辟了一条道路，在那条道路里面执行。然后main函数是一条主干道。主干道继续往下执行，当main函数返回的时候，该程序运行的所有goroutine都会立即停止，无论有没有走完。所以想在main函数返回之前让 sleepGopher 函数输出 ...snore... 的话，就需要多等待一段时间，已知 sleepGopher sleep了3秒，所以选择让main函数sleep了4秒</span></span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">// 3*time.Second = 3s</span></span><br><span class="line">fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-3-不止一个goroutine"><a href="#19-3-不止一个goroutine" class="headerlink" title="19.3 不止一个goroutine"></a>19.3 不止一个goroutine</h3><p>每次使用go关键字都会产生一个新的goroutine</p><p>表面上看，goroutine似乎在同时运行，但由于计算机处理单元有限，其实技术上来说，这些goroutine不是真的在同时运行；</p><ul><li>计算机处理器会使用“分时”技术，在多个goroutine上轮流花费一些时间；</li><li>在使用goroutine时，各个goroutine的执行顺序无法确定；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="19-3-1-goroutine的参数"><a href="#19-3-1-goroutine的参数" class="headerlink" title="19.3.1 goroutine的参数"></a>19.3.1 goroutine的参数</h4><p>向goroutine传递参数就根向函数传递参数一样，参数都是按值传递的（传入的是副本）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"...snore..."</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...snore... 2</span></span><br><span class="line"><span class="comment">// ...snore... 3</span></span><br><span class="line"><span class="comment">// ...snore... 0</span></span><br><span class="line"><span class="comment">// ...snore... 1</span></span><br><span class="line"><span class="comment">// ...snore... 4</span></span><br></pre></td></tr></table></figure><p>在使用goroutine时，各个goroutine的执行顺序无法确定；</p><h2 id="20-channel"><a href="#20-channel" class="headerlink" title="20. channel"></a>20. channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher() <span class="comment">// 已知该程序3秒后结束，返回</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second) <span class="comment">// 所以main函数中，尽量大于3秒的时间来保证所有 goroutine能够足够时间执行完；但有些时候并不能显式的知道 goroutine需要耗费的时间，那么这个时候main函数无法确定什么时间点会有返回值回来；所以也无法确定需要等待的时长。 解决这个问题就需要引入 channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second) </span><br><span class="line">fmt.Println(<span class="string">"...snore..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel可以在多个goroutine之间安全的传值；</p><p>通道可以用作变量、函数参数、结构体字段。。。</p><p>创建通道用make函数，并指定其传递数据的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h3 id="20-1-channel（通道）发送、接收"><a href="#20-1-channel（通道）发送、接收" class="headerlink" title="20.1 channel（通道）发送、接收"></a>20.1 channel（通道）发送、接收</h3><p>使用左箭头操作符 <code>&lt;-</code> 向channel发送值或从channel接收值；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- <span class="number">99</span> <span class="comment">// 向通道发送值， 把值为 99 的值 发送给通道c</span></span><br><span class="line">r:= &lt;- c <span class="comment">// 从通道接收值  从通道c接收一个值，并将此值赋给 r变量</span></span><br></pre></td></tr></table></figure><p>发送操作会等待直到另一个goroutine尝试对该channel进行接收操作为止；</p><ul><li>执行发送操作的goroutine在等待期间将无法执行其它操作</li><li>未在等待channel操作的goroutine仍然可以继续自由的运行</li></ul><p>执行接收操作的goroutine将等待直到另一个goroutine尝试向该channel进行发送操作为止；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 一个有5个 </span></span><br><span class="line">    <span class="comment">//gopher会往此通道发送值；</span></span><br><span class="line">gopherID := &lt;-c <span class="comment">// 当i=0时，等待大约3s之后，有其它gopher给它发送值了。</span></span><br><span class="line"><span class="comment">// 可能是 0 1 2 3 4 任意一个值，因为goroutine的顺序无法确定</span></span><br><span class="line">fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"..."</span>, id, <span class="string">"snore ..."</span>)</span><br><span class="line">c &lt;- id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-2-使用select处理多个通道"><a href="#20-2-使用select处理多个通道" class="headerlink" title="20.2 使用select处理多个通道"></a>20.2 使用select处理多个通道</h3><p>前面的例子中是使用一个channel来等待多个 goroutine，这种做法在所有goroutine都产生相同类型值的时候是好用的。但实际开发中，情况并不只是如此；程序通常需要等待不同类型的值；</p><p>当等待通道中某些值的时候，不想等太久。或者想在网络请求等待数秒之后就将其设置为超时而不是白白等待好几分钟。go标准库提供了一个time.After函数，该函数返回一个channel，该channel在指定时间后会接收到一个值（这个值是由go运行时的一个goroutine发送的 ）；</p><p>如果程序想继续从goroutine接收值，那必须等到所有goroutine都结束睡眠或我们耐心耗尽为止。这意味着程序必须同时等到time.After这个计时器channel 和其它channel。这个时候就能使用select语句。select语句能做到这一点。</p><p>select语句与switch有点像</p><ul><li>该语句包含的每个case都持有一个通道，用来发送或接收数据；</li><li>select会等待直到某个case分支的操作就绪，然后就会执行该case 分支；</li><li>select语句不包含任何case的情况下将永远等下去</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// create a channel</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> sleepGopher(i, c)</span><br><span class="line">&#125;</span><br><span class="line">timeout := time.After(<span class="number">2</span> * time.Second) </span><br><span class="line">  <span class="comment">// 创建一个超时时间2s 的 channel</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> gopherID := &lt;-c: <span class="comment">// 从通道接收值</span></span><br><span class="line">fmt.Println(<span class="string">"gopher"</span>, gopherID, <span class="string">"has finished sleeping"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout: <span class="comment">//等2s 超时 还未接收到</span></span><br><span class="line">fmt.Println(<span class="string">"my patience ran out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepGopher</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">4000</span>)) * time.Millisecond) <span class="comment">// 生成一个0-4s的随机时间</span></span><br><span class="line">c &lt;- id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 即使已经停止等待goroutine，但只要main函数还没返回，仍在运行的goroutine将会继续占用内存；（有条件，尽量清理掉）</p><h3 id="20-3-nil通道"><a href="#20-3-nil通道" class="headerlink" title="20.3 nil通道"></a>20.3 nil通道</h3><blockquote><p>值为nil的通道</p></blockquote><p>如果不使用make初始化channel，那么channel变量的值就是nil(零值)</p><p>对nil通道进行发送或接收不会引起panic，但会导致永久阻塞；</p><p>对nil通道执行close函数，那么会引起panic</p><h4 id="20-3-1-nil通道的用处："><a href="#20-3-1-nil通道的用处：" class="headerlink" title="20.3.1 nil通道的用处："></a>20.3.1 nil通道的用处：</h4><p>对于包含select语句的循环，如果不希望每次循环都等待select所涉及的所有通道，那么可以先将某些channel设置为nil，等到发送值准备就绪之后，再将channel变成一个非nil值并执行发送操作；</p><h2 id="21-阻塞和死锁"><a href="#21-阻塞和死锁" class="headerlink" title="21 阻塞和死锁"></a>21 阻塞和死锁</h2><p>当goroutine在等待channel的发送或接收时，我们就说它被阻塞了；</p><p>除了goroutine本身占用少量的内存外，被阻塞的goroutine并不消耗任何其它资源；</p><ul><li>goroutine静静地停在那里，等到导致其阻塞的事情来解除阻塞</li></ul><p>当一个或多个goroutine因为某些永远无法发生的事情被阻塞时，我们称这种情况为死锁，而出现死锁的程序通常会崩溃或挂起；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引发死锁的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"><span class="comment">// goroutine 1 [chan receive]:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用goroutine 解决死锁问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="number">2</span> &#125;()</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-2-地鼠装配线"><a href="#21-2-地鼠装配线" class="headerlink" title="21.2 地鼠装配线"></a>21.2 地鼠装配线</h3><p>Go允许在没有值可供发送的情况下通过close函数关闭通道</p><ul><li>例如close(c)</li></ul><p>通道被关闭后无法写入任何值，如果尝试写入将引发panic</p><p>尝试读取被关闭的通道会获得与通道类型对应的零值；</p><p>注意： 如果循环里读取一个已关闭的通道，并没有检查通道是否关闭，那么该循环可能会一直运转下去，耗费大量CPU时间</p><p>执行以下代码可得知通道是否被关闭</p><p><code>v,ok := &lt;-c</code> v为通道得到的值，ok bool类型，如果ok为false，那么说明此通道已关闭；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">downstream &lt;- v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// downstream &lt;- ""</span></span><br><span class="line"><span class="comment">// 重构为</span></span><br><span class="line"><span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">item, ok := &lt;-upstream</span><br><span class="line"><span class="comment">// if item == "" &#123; 重构</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">//downstream &lt;- ""</span></span><br><span class="line"><span class="built_in">close</span>(downstream)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">downstream &lt;- item</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v := &lt;-upstream</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line"><span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">printGopher(c1)</span><br><span class="line"><span class="comment">// hello, world</span></span><br><span class="line"><span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-3-常用模式"><a href="#21-3-常用模式" class="headerlink" title="21.3 常用模式"></a>21.3 常用模式</h3><p>从通道读取值，直到它关闭为止（常用）</p><ul><li>可以使用range关键字达到该目的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sourceGopher</span><span class="params">(downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello, world"</span>, <span class="string">"a bad apple"</span>, <span class="string">"goodbye all"</span>&#125; &#123;</span><br><span class="line">downstream &lt;- v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// downstream &lt;- ""</span></span><br><span class="line"><span class="comment">// 重构为</span></span><br><span class="line"><span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGopher</span><span class="params">(upstream, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> upstream &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(item, <span class="string">"bad"</span>) &#123;</span><br><span class="line">downstream &lt;- item</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(downstream) <span class="comment">// 关闭下游通道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGopher</span><span class="params">(upstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> upstream &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sourceGopher(c0)</span><br><span class="line"><span class="keyword">go</span> filterGopher(c0, c1)</span><br><span class="line">printGopher(c1)</span><br><span class="line"><span class="comment">// hello, world</span></span><br><span class="line"><span class="comment">// goodbye all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>homework</p><ol><li>编写一个流水线部件（一个goroutine），他需要记住前面出现的所有值，并且只有在值之前从未出现过的情况下才会将值传递至流水线的下一个阶段，假定第一个值永远不是空字符串</li><li>编写一个流水线部件，它接收字符串并将它们拆分成单词，然后向流水线的下一阶段一个接一个发送这些单词（可以用strings.Fields函数）</li></ol><h2 id="22-并发状态"><a href="#22-并发状态" class="headerlink" title="22 并发状态"></a>22 并发状态</h2><h3 id="22-1-共享值与竞争条件（race-condition）"><a href="#22-1-共享值与竞争条件（race-condition）" class="headerlink" title="22.1 共享值与竞争条件（race condition）"></a>22.1 共享值与竞争条件（race condition）</h3><p>工厂某些生产线出现库存不足的情况，它们需要订购更多的原材料。尽管每条生产线都有固定电话，但是工厂只有一条共享的电话路线。当一个工人拿起电话下订单的时候，另一只地鼠可能会拿起电话拨号。对正在讲话的前一个工人产生干扰，而之后可能还会有其它的工人尝试使用电话。最终就是所有工人一头雾水，订单也无法下达。</p><p>为了解决这个问题，工厂工人必须达成某些协议。使得同一时间之内只有一只地鼠使用电话。而go语言里共享值的概念就跟共享电话有些相似。</p><p>当有两个或者多个goroutine同时使用共享值的时候，程序可能出错。把这种多个goroutine争相使用值的情况称之为竞争条件或者竞争状态（race condition）而go的compiler实际上包含了尝试在代码里发现静态条件这个功能。</p><p>两个goroutine同时读取，并不会产生 race condition。</p><h3 id="22-2-Go的互斥锁-mutex"><a href="#22-2-Go的互斥锁-mutex" class="headerlink" title="22.2 Go的互斥锁(mutex)"></a>22.2 Go的互斥锁(mutex)</h3><p>Mutex= mutual exclusive</p><p>​                相互的  独占的</p><p>一个工厂想出一个很好的主意，在工厂地板中间放置一个玻璃罐，并在玻璃罐中放置了一个金属令牌。每次想要打电话的地鼠都需要从罐子里面取出令牌。然后在打电话的过程中一直持有它。然后打完电话再把它放回到罐子里面。如果有一只地鼠想打电话，但是没有在罐子里面发现令牌。就需要轮训等待直到令牌归还为止。go语言的互斥锁就相当于此玻璃罐。goroutine就可以通过互斥锁阻止其它的goroutine在同一时间进行某些事情。为了保护互斥锁的互斥性质，程序在访问被保护的东西的时候必须得非常的小心。互斥锁有两个方法 <code>Lock</code> 和 <code>Unlock</code>, Lock相当于从金属罐里面取出令牌，Unlock相当于把令牌放回玻璃罐；</p><p>如果有goroutine尝试在互斥锁已经锁定的情况下，再调用lock方法，那么它就需要等待解锁之后再次上锁。为了正确使用互斥锁，就要确保锁访问共享值的代码必须先锁定互斥锁，然后才能执行所需的操作。并且在操作完成之后必须解除互斥锁，任何不遵循这一模式的代码都可能引发竞争条件。基于此原因，互斥锁在绝大多数情况下，只会在包内进行使用；这个包会通过互斥锁保护自定义的内容，并将相应的lock和unlock调用，巧妙的隐藏在函数和方法的背后。和channel不一样，互斥锁并未内置在go语言中。而是通过sync包来引入的；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="comment">// the lock is held until we return from the function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁定义在被保护的变量之上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line">1. 当两个goroutine同时修改一个值的时候，会发生什么</span><br><span class="line">2. 尝试对一个已经被锁定的互斥锁进行锁定操作，会发生什么</span><br><span class="line">3. 尝试多一个未被锁定的互斥锁进行解锁操作，会发生什么</span><br><span class="line">4. 同时在多个不同的goroutine里面调用相同类型的方法是安全的吗</span><br></pre></td></tr></table></figure><h3 id="22-3-互斥锁的隐患"><a href="#22-3-互斥锁的隐患" class="headerlink" title="22.3 互斥锁的隐患"></a>22.3 互斥锁的隐患</h3><h4 id="22-3-1-死锁"><a href="#22-3-1-死锁" class="headerlink" title="22.3.1  死锁"></a>22.3.1  死锁</h4><p> 如果一个程序锁定之后，它执行的操作很多。就需要越来越加的小心。</p><p>如果一个goroutine在锁定互斥锁之后，因为某些事情而被阻塞。那么将要取得互斥锁的其它goroutine就可能会被耽搁很长时间。更严重的是，如果持有互斥锁的goroutine因为某些原因尝试锁定同一个互斥锁就会引发死锁（正在尝试加锁操作的goroutine将永远无法解除已经被锁定的互斥锁，最终导致这个lock调用被永久的阻塞）。</p><p>所以为了保证这个互斥锁的使用安全，遵守以下两个原则</p><ol><li>尽可能的简化互斥锁保护的代码</li><li>对每一份共享状态只使用一个互斥锁</li></ol><h3 id="22-4-长时间运行的工作进程"><a href="#22-4-长时间运行的工作进程" class="headerlink" title="22.4 长时间运行的工作进程"></a>22.4 长时间运行的工作进程</h3><p>工作进程（worker）</p><p>把一直存在并且独立运行的goroutine称作为 工作进程</p><p>而工作进程通常被写成包含select语句的for循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// wait for channels here.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-5-事件循环和goroutine"><a href="#22-5-事件循环和goroutine" class="headerlink" title="22.5 事件循环和goroutine"></a>22.5 事件循环和goroutine</h3><p>事件循环（event loop）</p><p>中心循环（central loop）</p><p>Go通过提供groutine作为核心概念，消除了对中心循环的需求；</p><p>某些编程语言会用事件循环的中心循环来等待时间，并在这个事件发生时调用相应的已注册函数。而go语言则是通过提供goroutine作为核心概念，消除对中心循环的需求。</p><p>我们可以把任何工作进程goroutine都看做是独立运行的事件循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"image"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos := image.Point&#123;X: <span class="number">10</span>, Y: <span class="number">10</span>&#125;</span><br><span class="line">direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">next := time.After(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-next:</span><br><span class="line">pos = pos.Add(direction)</span><br><span class="line">fmt.Println(<span class="string">"current position is"</span>, pos)</span><br><span class="line">next = time.After(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">right = command(<span class="number">0</span>)</span><br><span class="line">left  = command(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoverDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">commandc <span class="keyword">chan</span> command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoverDriver</span><span class="params">()</span> *<span class="title">RoverDriver</span></span> &#123;</span><br><span class="line">r := &amp;RoverDriver&#123;</span><br><span class="line">commandc: <span class="built_in">make</span>(<span class="keyword">chan</span> command),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> r.drive()</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos := image.Point&#123;X: <span class="number">0</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">direction := image.Point&#123;X: <span class="number">1</span>, Y: <span class="number">0</span>&#125;</span><br><span class="line">updateInterval := <span class="number">250</span> * time.Millisecond</span><br><span class="line">nextMove := time.After(updateInterval)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c := &lt;-r.commandc:</span><br><span class="line"><span class="keyword">switch</span> c &#123;</span><br><span class="line"><span class="keyword">case</span> right:</span><br><span class="line">direction = image.Point&#123;X: -direction.Y, Y: direction.X&#125;</span><br><span class="line"><span class="keyword">case</span> left:</span><br><span class="line">direction = image.Point&#123;X: direction.Y, Y: -direction.X&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"new direction %v"</span>, direction)</span><br><span class="line"><span class="keyword">case</span> &lt;-nextMove:</span><br><span class="line">pos = pos.Add(direction)</span><br><span class="line">log.Printf(<span class="string">"moved to %v"</span>, pos)</span><br><span class="line">nextMove = time.After(updateInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Left</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.commandc &lt;- left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Right</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.commandc &lt;- right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := NewRoverDriver()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">r.Left()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">r.Right()</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改代码使得每次移动之间的间隔增加半秒</p><p>以RoverDriver类型为基础，定义start方法·stop方法和对应的命令，然后修改代码使得探测器可以接受这两个新命令</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack5_1</title>
      <link href="2021/02/23/webpack5-1/"/>
      <url>2021/02/23/webpack5-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Webpack5-boilerplate"><a href="#Webpack5-boilerplate" class="headerlink" title="Webpack5 boilerplate"></a>Webpack5 boilerplate</h2><h3 id="1-Common"><a href="#1-Common" class="headerlink" title="1. Common"></a>1. Common</h3><h4 id="2-1-init"><a href="#2-1-init" class="headerlink" title="2.1 init"></a>2.1 init</h4><p><strong>install webpack5</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev --save-exact</span><br></pre></td></tr></table></figure><h4 id="2-2-添加changelog"><a href="#2-2-添加changelog" class="headerlink" title="2.2 添加changelog"></a>2.2 添加changelog</h4><h4 id="2-3-添加CI-CD"><a href="#2-3-添加CI-CD" class="headerlink" title="2.3 添加CI/CD"></a>2.3 添加CI/CD</h4><h4 id="2-4-项目结构设计"><a href="#2-4-项目结构设计" class="headerlink" title="2.4 项目结构设计"></a>2.4 项目结构设计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|- &#x2F;config     一些配置文件，比如webpack config等</span><br><span class="line">|- &#x2F;internals  一些内部脚本，生成模版文件， 执行cleanAndSetup操作等；</span><br><span class="line">|- &#x2F;scripts    必要的npm scripts</span><br><span class="line">|- package.json</span><br><span class="line">|- index.html</span><br><span class="line">|- &#x2F;src</span><br><span class="line">  |- index.ts</span><br></pre></td></tr></table></figure><h4 id="2-5-添加-prettier"><a href="#2-5-添加-prettier" class="headerlink" title="2.5 添加 prettier"></a>2.5 添加 prettier</h4><blockquote><p>格式化代码利器，配合vscode全局使用；</p></blockquote><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact prettier</span><br></pre></td></tr></table></figure><p><strong>init</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#123;&#125;&gt; .prettierrc.json</span><br><span class="line">touch .prettierignore</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .prettierignore </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore artifacts:</span></span><br><span class="line">build</span><br><span class="line">coverage</span><br></pre></td></tr></table></figure><h4 id="2-6-babel"><a href="#2-6-babel" class="headerlink" title="2.6 babel"></a>2.6 babel</h4><p><strong>babel简述</strong></p><p>babel是一个js编译器，主要是将es6+转换为向后兼容的js语法；这样就能运行在旧版本浏览器或者其他低版本的环境中；</p><ul><li><p>利用<code>@Babel/polyfill</code>可以通过Polyfill方式在目标环境中添加缺失的特性；</p></li><li><p>babel能够转换jsx语法；主要用到<code>@babel/preset-react</code>;</p></li><li><p>babel还可以删除类型注释，主要用到<code>@babel/preset-typescript</code>，但是无法做类型检查，类型检查需要Flow/Typescript这类的工具;</p></li><li><p>babel是构建在插件之上的，使用现有的插件可以组成一个转换管道；通过使用或创建一个<code>preset</code> 即可轻松使用一组插件；使用<code>generator-babel-plugin</code>生成一个插件模版；</p></li></ul><h5 id="2-6-1-概念"><a href="#2-6-1-概念" class="headerlink" title="2.6.1 概念"></a>2.6.1 概念</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact @babel/core @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure><h6 id="2-6-1-1-babel-core"><a href="#2-6-1-1-babel-core" class="headerlink" title="2.6.1.1 @babel/core"></a>2.6.1.1 @babel/core</h6><p>babel 核心功能包含在该模块中；</p><h6 id="2-6-1-2-babel-cli"><a href="#2-6-1-2-babel-cli" class="headerlink" title="2.6.1.2 @babel/cli"></a>2.6.1.2 @babel/cli</h6><p>@babel/cli 是一个能够从终端（命令行）使用的工具；</p><p><strong>babelrc</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"presets"</span>: [],</span><br><span class="line"><span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-6-1-3-plugins"><a href="#2-6-1-3-plugins" class="headerlink" title="2.6.1.3 plugins"></a>2.6.1.3 plugins</h6><blockquote><p>插件是小型的js程序，用于指导babel如何代码进行转换</p></blockquote><p>现在，babel虽然开箱即用，但是什么动作都不做。类似于<code>const babel = code =&gt; code</code>，将代码解析之后再输出同样的代码，如果想要babel做一些实际的工作，就需要为其添加插件；</p><p>例如<code>@babel/plugin-transform-arrow-functions</code>之类的插件能将es6的箭头函数转换成es5的function；但是代码中依然有其他es6属性，比如class。 我们希望对它们也进行转换，不需要一个接一个添加所需要的插件。可以使用一个<code>preset</code>（即一组预先设定的插件）</p><p>就像插件一样，可以根据自己所需要的插件组合创建一个 自己的<code>preset</code>并将其分享出去；</p><p><strong>插件参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加参数的时候,下面这几种是一致的；</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"pluginA"</span>, [<span class="string">"pluginA"</span>], [<span class="string">"pluginA"</span>,&#123;&#125;]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加参数，请传递一个以参数名作为（key）的对象</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"transform-async-to-module-method"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"module"</span>: <span class="string">"bluebird"</span>,</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"coroutine"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-6-1-4-preset-（-babel-env）"><a href="#2-6-1-4-preset-（-babel-env）" class="headerlink" title="2.6.1.4 preset （@babel/env）"></a>2.6.1.4 preset （@babel/env）</h6><blockquote><p>除了一个一个添加插件，还可以以 preset 的形式启用一组插件，对比plugin来说，preset就是为了让不想自动手动组合插件的开发者提供的，preset可以作为Babel插件的组合；</p></blockquote><p>可以简单把Babel Preset视为Babel Plugin的集合，比如babel-preset-es2015 就包含了所有跟es6转换有关的插件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/babel src --out-dir lib --presets=@babel/env</span><br></pre></td></tr></table></figure><p><strong>preset参数</strong></p><p>格式与plugin一致；</p><p><strong>官方Preset</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@babel/preset-env</span><br><span class="line">@babel/preset-flow</span><br><span class="line">@babel/preset-react</span><br><span class="line">@babel/preset-typescript</span><br></pre></td></tr></table></figure><h6 id="2-6-1-5-Plugin与Preset执行顺序"><a href="#2-6-1-5-Plugin与Preset执行顺序" class="headerlink" title="2.6.1.5 Plugin与Preset执行顺序"></a>2.6.1.5 Plugin与Preset执行顺序</h6><p>可以同时使用多个Plugin 和Preset，此时，它们执行顺序非常重要</p><ol><li>先执行完所有Plugin，再执行Preset</li><li>多个Plugin，按声明次序顺序执行</li><li>多个Preset，按照声明次序逆序执行</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [ </span><br><span class="line">    <span class="string">"transform-react-jsx"</span>,</span><br><span class="line">    <span class="string">"transform-async-to-generator"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"presets"</span>: [ </span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"es2016"</span>    </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行顺序</strong></p><p><code>transform-react-jsx，transform-async-to-generator，es2016，es2015</code></p><h6 id="2-6-1-6-babel-polyfill"><a href="#2-6-1-6-babel-polyfill" class="headerlink" title="2.6.1.6 babel-polyfill"></a>2.6.1.6 babel-polyfill</h6><p>babel默认只转换新的js句法（syntax），不转新的API，类似Proxy，Promise这些。举例来说，ES6在Array对象上新增了Array.from方法，babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill；</p><p>从babel7.4.0版本开始，这个软件包已经不推荐使用了，建议使用<code>core-js/stable</code> 和<code>regenerator-runtime/runtime</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/stable'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'regenerator-runtime/runtime'</span></span><br></pre></td></tr></table></figure><p><strong>useBuiltIns</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"edge"</span>: <span class="string">"17"</span>,</span><br><span class="line">          <span class="attr">"firefox"</span>: <span class="string">"60"</span>,</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span>,</span><br><span class="line">          <span class="attr">"safari"</span>: <span class="string">"11.1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span> <span class="comment">// 当此参数设置为 "usage" 时，就会加载上面所提到的最后一个优化措施，也就是只包含你所需要的 polyfill. </span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br><span class="line"><span class="comment">// 加了 "useBuiltIns": "usage" 之类转化为</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.promise.finally'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().finaly();</span><br></pre></td></tr></table></figure><p>Babel将检查你的所有代码，以便查找目标环境中缺失的功能，然后只把必须的polyfill包含进来；如果没加<code>useage</code>，那必须在所有代码之前通过require加载一次完成的polyfill</p><h6 id="2-6-1-7-小结"><a href="#2-6-1-7-小结" class="headerlink" title="2.6.1.7 小结"></a>2.6.1.7 小结</h6><p>使用<code>@babel-cli</code>从终端运行Babel；</p><p>利用 <code>@babel/polyfill</code>模拟所有新的js功能，比如Array.from, Promise等；</p><p>而<code>@babel-env</code>preset 只对目标环境（如浏览器）中缺失的功能进行代码转换和加载polyfill；</p><h5 id="2-6-2-配置"><a href="#2-6-2-配置" class="headerlink" title="2.6.2 配置"></a>2.6.2 配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;&#125;&gt;babel.config.json</span><br></pre></td></tr></table></figure><h6 id="2-6-2-1-typescript"><a href="#2-6-2-1-typescript" class="headerlink" title="2.6.2.1 typescript"></a>2.6.2.1 typescript</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact @babel/preset-typescript</span><br></pre></td></tr></table></figure><h6 id="2-6-2-2-react"><a href="#2-6-2-2-react" class="headerlink" title="2.6.2.2 react"></a>2.6.2.2 react</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact @babel/preset-react</span><br></pre></td></tr></table></figure><h4 id="2-7-引入typescript"><a href="#2-7-引入typescript" class="headerlink" title="2.7 引入typescript"></a>2.7 引入typescript</h4><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact typescript ts-loader</span><br></pre></td></tr></table></figure><p><strong>tsconfig.json</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;&#125; &gt;tsconfig.json</span><br></pre></td></tr></table></figure><h4 id="2-8-引入react"><a href="#2-8-引入react" class="headerlink" title="2.8 引入react"></a>2.8 引入react</h4><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react react-dom react-router react-router-dom redux react-saga reselect react-redux immer connected-react-router <span class="built_in">history</span> --save --save-exact</span><br></pre></td></tr></table></figure><p>记得加入@types</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/react @types/react-dom --save-dev --save-exact</span><br></pre></td></tr></table></figure><h4 id="2-9-载入css相关资源"><a href="#2-9-载入css相关资源" class="headerlink" title="2.9 载入css相关资源"></a>2.9 载入css相关资源</h4><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader css-loader less less-loader --save-dev --save-exact</span><br></pre></td></tr></table></figure><p><strong>安装PostCSS Preset Env</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact postcss-preset-env postcss postcss-loader</span><br></pre></td></tr></table></figure><p><strong>MiniCssExtractPlugin</strong></p><p>生产模式下运行时使用来提取CSS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact mini-css-extract-plugin</span><br></pre></td></tr></table></figure><h4 id="2-10-解析图片，字体之类的"><a href="#2-10-解析图片，字体之类的" class="headerlink" title="2.10 解析图片，字体之类的"></a>2.10 解析图片，字体之类的</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader --save-dev --save-exact</span><br></pre></td></tr></table></figure><h4 id="2-11-HtmlWebpackPlugin"><a href="#2-11-HtmlWebpackPlugin" class="headerlink" title="2.11 HtmlWebpackPlugin"></a>2.11 HtmlWebpackPlugin</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact html-webpack-plugin</span><br></pre></td></tr></table></figure><h3 id="2-Dev"><a href="#2-Dev" class="headerlink" title="2. Dev"></a>2. Dev</h3><p><strong>install</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev --save-exact webpack-hot-middleware express webpack-dev-middleware</span><br></pre></td></tr></table></figure><h3 id="3-Pro"><a href="#3-Pro" class="headerlink" title="3. Pro"></a>3. Pro</h3>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graphics1</title>
      <link href="2021/02/09/graphics1/"/>
      <url>2021/02/09/graphics1/</url>
      
        <content type="html"><![CDATA[<p>前置</p><h2 id="1-Course-Topis（mainly-4-parts）"><a href="#1-Course-Topis（mainly-4-parts）" class="headerlink" title="1. Course Topis（mainly 4 parts）"></a>1. Course Topis（mainly 4 parts）</h2><ul><li>Rasterization （光栅化）</li><li>Curves and Meshes</li><li>Ray Tracing （光线追踪）</li><li>Animation/Simulation （动画/模拟）</li></ul><h3 id="1-1-Rasterization"><a href="#1-1-Rasterization" class="headerlink" title="1.1 Rasterization"></a>1.1 Rasterization</h3><p>光栅化， 把三维空间的几何形体显示在屏幕上。这就是光栅化。</p><p>实时的计算机图形学的主要应用，在计算机图形学的范畴内，实时的定义我们认为是每秒钟生成30幅画面或者叫30帧，能达到这个级别就叫实时，否则叫离线；</p><h3 id="1-2-Curves-and-Meshes"><a href="#1-2-Curves-and-Meshes" class="headerlink" title="1.2 Curves and Meshes"></a>1.2 Curves and Meshes</h3><p>在图形学中，如何表示一条光滑的曲线。如何表示曲面。</p><h3 id="1-3-Ray-Tracing-（光线追踪）"><a href="#1-3-Ray-Tracing-（光线追踪）" class="headerlink" title="1.3 Ray Tracing （光线追踪）"></a>1.3 Ray Tracing （光线追踪）</h3><p>生成真实美观的画面；</p><p>trade off 取舍 </p>]]></content>
      
      
      <categories>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liner_Algebra</title>
      <link href="2021/02/08/liner-Algebra/"/>
      <url>2021/02/08/liner-Algebra/</url>
      
        <content type="html"><![CDATA[<p>一系列简短可刷的视频，将线性代数中的几何直觉动画化；</p><p>即使你能跟上视频的速度，你也需要留点时间给自己思考，学习往往发生在此刻；</p><h2 id="1-向量"><a href="#1-向量" class="headerlink" title="1. 向量"></a>1. 向量</h2><h3 id="1-1-含义"><a href="#1-1-含义" class="headerlink" title="1.1 含义"></a>1.1 含义</h3><p>线性代数中最基础、最根源的组成部分就是向量；</p><p>一般来说，有三种看待向量的观点，看似不同却有所关联；</p><h4 id="1-1-1-物理专业视角"><a href="#1-1-1-物理专业视角" class="headerlink" title="1.1.1 物理专业视角"></a>1.1.1 物理专业视角</h4><p>向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向；但是只要以上两个特征相同，你可以自由移动一个向量而保持它不变；</p><p><strong>二维向量</strong></p><p>处在平面中的巷里那个是二维的；</p><p><strong>三维向量</strong></p><p>而处在我们所生活的空间中的向量是三维的；</p><h4 id="1-1-2-计算机专业视角"><a href="#1-1-2-计算机专业视角" class="headerlink" title="1.1.2 计算机专业视角"></a>1.1.2 计算机专业视角</h4><p>从计算机专业学生的视角看，向量是有序的数字列表；比如你正在做一些有关房价的分析；而你只关心两个特征： ``房屋面积<code>和</code>价格`。</p><p>你可能会用一对数字对每个房屋进行建模；第一个数代表房屋面积，第二个数代表价格；</p><p>注意，这里的数字顺序不可颠倒；用行话来讲，你会用二维向量对房屋进行建模；在这里，“向量”只不过是“列表”的一个花哨的说法；之所以这个向量是二维的，是因为这个列表的长度是2；</p><h4 id="1-1-3-数学专业视角"><a href="#1-1-3-数学专业视角" class="headerlink" title="1.1.3 数学专业视角"></a>1.1.3 数学专业视角</h4><p>另一方面，数学家试图去概括这两种观点，大致地说，向量可以是任何东西。只要保证两个向量相加以及数字与向量相乘是有意义的即可；</p><p><strong>向量加法和向量数乘贯穿线性代数始终，二者起着很重要的作用</strong></p><p>一种思考“向量”的特定方式</p><p>现在关注的是它的几何方面，首先需要考虑一个箭头，考虑这个箭头在某个坐标系中，比如x-y平面。并且箭头起点位于原点；这与物理专业学生的看法略有不同。因为在他们眼中，向量可以在空间中自由落脚；但是在线性代数中，向量经常以原点作为起点；</p><p>一旦你理解了“向量是空间中的箭头”这种观点，就来看看“向量是有序的数字列表”这种观点；</p><p>在直角坐标系中，一个向量的坐标由一对数构成；（-2，3），这对数指导你如何从原点（向量起点）出发到达它的尖端（向量终点）</p><p>第一个数告诉你沿着X轴走多远，正数代表向右移动，负数代表向左移动；</p><p>第二个数告诉你沿着Y轴走多远；正数代表向上移动，负数代表向下移动；</p><p>为了把向量和点区别开，惯用方法是把这对数竖着写，然后用方括号括起来；每一对数给出唯一一个向量；</p><h3 id="1-2-向量的和"><a href="#1-2-向量的和" class="headerlink" title="1.2 向量的和"></a>1.2 向量的和</h3><p><img src="vector1.png" alt="image-20210208234410862"></p><p>平移第二个向量，使它的起点与第一个向量的终点重合。然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是它们的和；</p><p>顺便一提，这个向量加法的定义差不多是线性代数中唯一允许向量离开原点的情形；</p><h4 id="1-2-1-数学角度看向量加法"><a href="#1-2-1-数学角度看向量加法" class="headerlink" title="1.2.1 数学角度看向量加法"></a>1.2.1 数学角度看向量加法</h4><p><img src="vector2.png" alt="image-20210208235656431"></p><p><img src="vector3.png" alt="image-20210208235911892"></p><p>我们重新编排它们的吮吸，使得我们先完成所有水平运送，再完成所有竖直运动；</p><p><img src="vector4.png" alt="image-20210209000135241"></p><p>所以新向量的坐标就是 (1+3, 2+(-1)); 即<code>(x1+x2,y1+y2)</code>,总体来说，在“向量是有序的数字列表”观点里，向量加法就是把对应项相加；</p><h3 id="1-3-向量数乘"><a href="#1-3-向量数乘" class="headerlink" title="1.3 向量数乘"></a>1.3 向量数乘</h3><p>另一个向量基础运算就是向量数乘</p><h4 id="1-3-1-缩放"><a href="#1-3-1-缩放" class="headerlink" title="1.3.1 缩放"></a>1.3.1 缩放</h4><p>比如说你选择数字2，把它与一个给定向量相乘。意味着你把这个向量拉长为原向量的2倍。 如果将向量乘以1/3，就意味着这个向量长度缩短为原来的1/3.如果乘以-1.8，相当于往反方向拉长1.8倍；<code>2,1/3,-1.8,它们用于缩放向量，被称为“标量”</code>实际上自始至终，数字在线性代数中起到的主要作用就是缩放向量；所以，“标量”和“数字”两个词通常在这里可以相互替换；</p><p>这种拉伸或压缩，有时又使向量反向的过程被称为“缩放”；</p><h4 id="1-3-2-数学角度看向量数乘"><a href="#1-3-2-数学角度看向量数乘" class="headerlink" title="1.3.2 数学角度看向量数乘"></a>1.3.2 数学角度看向量数乘</h4><p>从数字的角度来看，将一个向量伸长为原来的2倍；对应于将每一个分量分别乘以2；</p><p><img src="vector5.png" alt="image-20210209002032279"></p><p>所以将向量看作一个数字列表时，向量与标量相乘就是将向量中的每个分量与标量相乘；</p><h3 id="1-4-向量点乘与叉乘"><a href="#1-4-向量点乘与叉乘" class="headerlink" title="1.4 向量点乘与叉乘"></a>1.4 向量点乘与叉乘</h3><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>线性代数围绕两种基本运算： 向量加法与向量乘法“究竟是什么意思了”；</p><p>为什么数学家只考虑这两种运算，并且又是如何将它们抽象独立出来，不管你选什么代表向量都与之无关；</p><p>实际上无论你怎么看待向量都无所谓，或把向量看作空间中的箭头；或者把向量看作数字列表；这种观点又恰好有漂亮的几何意义与之对应。线性代数的效用很少提现在这些观点的其中一个上，而是更多地体现在它能够在这些观点中相互转化；</p><p>线性代数为数据分析提供了一条将大量数据列表概念化、可视化的渠道；它让数据样式变得非常明晰，并让你大致了解特定运算的意义；</p><p>另一方面，线性代数给物理学家和计算机图形程序员提供了一种语言；让他们通过计算机能处理数字来描述并操纵空间；</p><h2 id="2-线性组合、张成的空间与基"><a href="#2-线性组合、张成的空间与基" class="headerlink" title="2. 线性组合、张成的空间与基"></a>2. 线性组合、张成的空间与基</h2><h3 id="2-1-基向量"><a href="#2-1-基向量" class="headerlink" title="2.1 基向量"></a>2.1 基向量</h3><p>关于向量坐标，还有一种有趣的方式来看待这些坐标，它对线性代数很重要。当你看到一对描述向量的数时，比如（3，-2），可以把它的每个坐标看作一个标量；</p><p><img src="vector6.png" alt="image-20210209101806130"></p><p><img src="vector7.png" alt="image-20210209102013500"></p><p>在xy坐标系中，有两个非常特别的向量。一个指向正右方，长度为1，通常被称为<code>i 帽</code>或者x方向的单位向量；另一个指向正上方，长度为1。通常被称为<code>j帽</code> 或者y方向的单位向量；</p><p><img src="vector8.png" alt="image-20210209102531618"></p><p>现在想象向量(3,-2)的x坐标是一个标量，它将<code>i帽</code>拉伸为原来的3倍；它将<code>j帽</code>拉伸为原来的2倍；从这个角度去看，这个向量实际上是两个经过缩放的向量的和；</p><p><img src="vector9.png" alt="image-20210209102757457"></p><p>“缩放向量并且相加” 这一概念至关重要，<code>i 与 j 是xy坐标系的“基向量”；它们合起来被称为坐标系的基；</code></p><p>这是在说，当你把坐标看作标量时；基向量实际上就是这些标量缩放的对象；</p><p><img src="vector10.png" alt="image-20210209103551566"></p><p><img src="vector11.png" alt="image-20210209103743636"></p><p>我们根据这两个特殊的基向量构建坐标系时，也浮现了一些有趣而微妙的问题，<code>如果我们选择不同的基向量会怎么样？</code>我们完全可以选择不同的基向量，获得一个合理的新坐标系；</p><p><img src="vector12.png" alt="image-20210209104537826"></p><p>比如说，随便选一个指向右上方的向量（红色），再随便选一个指向右下方的向量（蓝色）。想象一下，通过选择两个标量，分别用于缩放二者的其中一个；然后把它们相加，你能得到不同的结果；</p><p><img src="vector13.png" alt="image-20210209104634338"></p><p>通过改变所选择的标量，你可以得到哪些二维向量？</p><p>答案是，你可以得到所有的二维向量。为什么呢？</p><p>这样一对新的基向量，同样允许我们在一对数和二维向量之间自由转化；</p><p>但是这种变换关系与之前用i帽 和 j帽的变换关系完全不同；</p><p><img src="vector14.png" alt="image-20210209114258225"></p><p><img src="vector15.png" alt="image-20210209114403505"></p><p><code>每当我们用数字描述向量时，它都依赖于我们正在使用的基</code>两个数乘向量和被称为这两个向量的线性组合。</p><p><img src="vector16.png" alt="image-20210209115355067"></p><h3 id="2-2-向量张成的空间（span）"><a href="#2-2-向量张成的空间（span）" class="headerlink" title="2.2 向量张成的空间（span）"></a>2.2 向量张成的空间（span）</h3><p>“线性”这个词从哪儿来？这根直线又又什么关系？</p><p>如果固定其中一个标量，让另一个标量自由变化。所产生的向量的终点会描出一条直线；(下面两张图分别为固定向量W缩放V 和 固定V缩放W)</p><p><img src="vector17.png" alt="image-20210209115702292"></p><p><img src="vector18.png" alt="image-20210209115821892"></p><p>如果你让两个标量同时自由变化，考虑所有可能得到的向量；可能有两种情况；</p><p>大部分情况下，对于一对初始向量，你能到达平面中的每一个点；所有二维向量都尽在掌握；</p><p>但是也有糟糕的情况，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上；</p><p><img src="vector19.png" alt="image-20210209120416875"></p><p>实际上还有第三种情况： 两个向量都是零向量。那就只能乖乖呆在原点了；</p><p><img src="vector20.png" alt="image-20210209125225821"></p><p>所有可以表示为给定向量线性组合的向量的集合；被称为给定向量张成的空间（span）; 现在用行话重新叙述刚才的内容；对大部分二维向量对来说，它们张成的空间是所有二维向量的集合。</p><p>但当共线的时，它们张成的空间就是终点落在一条直线上的向量的集合；</p><p><strong>线性代数紧紧围绕向量加法与数乘</strong></p><p>两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么？</p><p>现在是时候讨论一下通常我们是如何将向量看作点的；</p><p>想象落在一条直接上的一些向量时，你会觉得拥挤。而同时想象所有二维向量填满平面时，你会觉得非常拥挤；</p><p><img src="vector21.png" alt="image-20210209142438907"></p><p>所以为了对抗这种情况，通常我们就用向量的终点代表改向量。而像以往一样，它的起点仍旧位于原点；用这种方法来看，如果你要考虑落在一条直线上的所有向量时，你需要考虑直线本身就行了；类似地，同时考虑所有二维向量时，将每个向量抽象为它的终点；实际上，你就不必考虑所有的箭头了，只需要考虑无限大的二维平面本身即可；</p><p>当你只考虑一个向量时，就把它看作箭头。当你考虑多个向量时，就把它们都看作点；前面有提到对大部分二维向量来说，它们张成的空间是整个无限大的二维平面；如果共线，它们张成的空间就是一条直线；</p><h4 id="2-2-1-两个三维向量张成的空间是什么样的？"><a href="#2-2-1-两个三维向量张成的空间是什么样的？" class="headerlink" title="2.2.1  两个三维向量张成的空间是什么样的？"></a>2.2.1  两个三维向量张成的空间是什么样的？</h4><p>如果我们再去考虑三维空间，张成空间这个概念就开始变得有趣了。这两个向量张成的空间就是它们所有可能的线性组合。</p><p><img src="vector22.png" alt="image-20210209144441848"></p><p>这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量张成的空间；或者说，所有终点落在这个平面上的向量的集合是这两个向量张成的空间；</p><p>如果再加上第三个向量，那么它们张成的空间又是什么样的呢？</p><p>会有两种情况，如果第三个向量恰好落在前两个向量所张成的平面上。那么它们张成的空间并不会改变，还是被困在这个平面上；</p><p>另外一种情况，如果你随机选一个向量，它几乎不可能落在前面两个向量所张成的平面中。这种情况下，由于第三个向量指向不同的方向。当你缩放第三个向量时，它将前两个向量张成的平面沿它的方向来回移动，从而扫过整个空间；</p><h3 id="2-3-线性无关与线性相关"><a href="#2-3-线性无关与线性相关" class="headerlink" title="2.3 线性无关与线性相关"></a>2.3 线性无关与线性相关</h3><p>当有多个向量，并且可以移除其中一个而不减少张成的空间。当这种情况发生时，我们称它们是“线性相关”的；另一种表述方法是其中一个向量，可以表示为其它向量的线性组合，因为这个向量已经落在其它向量张成的空间之中；</p><p>另一方面，如果所有向量都给张成的空间增添了新的维度；它们就被称为是“线性无关”的。</p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p><strong>“向量空间的一组基是张成该空间的一个线性无关的向量集；”</strong></p><p>空间的一组基的严格定义是这样的： 张成该空间的一个线性无关向量的集合，基于目前对“张成” 和 “线性无关” 这两个词的理解。思考一下为什么这个定义合乎情理；</p><h2 id="3-矩阵与线性变换"><a href="#3-矩阵与线性变换" class="headerlink" title="3. 矩阵与线性变换"></a>3. 矩阵与线性变换</h2><h3 id="3-1-线性变换"><a href="#3-1-线性变换" class="headerlink" title="3.1 线性变换"></a>3.1 线性变换</h3><blockquote><p>很遗憾， Matrix（矩阵）是什么是说不清的，你必须得自己亲眼看看；</p></blockquote><p>“如果要我选出一个主题，它不仅让线性代数的其它内容一目了然，又经常被初次学习线性代数的人忽视，我会选择这个——线性变换的概念以及它和矩阵的关系”</p><p>在这期视频中，只会集中讨论这些变换在二维空间中长什么样。以及它们如何与矩阵向量乘法关联。尤其展示一种不用死记硬背的考虑矩阵向量乘法的方法；</p><p><img src="matrix1.png" alt="image-20210209154527578"></p><p>首先，先来解析“线性变换”这个术语。“变换”本质上是“函数”的一种花哨的说法，它接收输入内容，并输出对应结果；</p><p><img src="matrix2.png" alt="image-20210209154800497"></p><p><img src="matrix3.png" alt="image-20210209154826105"></p><p>特别地，在线性代数的情况下。我么考虑的是接收一个向量并且输出一个向量的变换；</p><p>特别的，在线性代数的情况下。我们考虑的是接收一个向量并且输出一个向量的变换；</p><p><img src="matrix4.png" alt="image-20210209155750711"></p><p><img src="matrix5.png" alt="image-20210209155826060"></p><p>既然“变换”和“函数”意义相同，为什么还要使用前者而不是后者？因为使用“变换”是在暗示以特定方式来可视化这一输入-输出关系； 一种理解“向量的函数”的方法是使用运动。</p><p><img src="matrix6.png" alt="image-20210209160637527"></p><p>如果一个变换接收一个向量并输出一个向量；我们想象这个输入向量移动到输出向量的位置；</p><p>接下来，要理解整个变换。我们可以想象每一个输入向量都移动到对应输出向量的位置；同样多个箭头显得很拥挤，只用终点表示该向量，用这种方法考虑所有输入向量都移动到对应输出向量的位置时。我们只用看空间中的所有点移动到其它点的位置；</p><p><img src="matrix7.png" alt="image-20210209160814616"></p><p>各种个样对空间的变换所产生的效果是美妙的，任意一个变换可以非常复杂。幸运的是，<code>线性代数限制在一种特殊类型的变换上；这种变换更容易理解，称为线性变换</code></p><p><img src="transform1.png" alt="image-20210209161355416"></p><p>直观地说，如果一个变换具有以下两条性质，我们就称它是线性的；</p><p>一是直线在变换后仍然保持为直线，不能有所弯曲；</p><p>二是原点必须保持固定；</p><p>举例： 上图变换保持原点不动，乍一看它好像保持直线平直；但实际并非如此，因为只展示了水平和竖直的网格线；</p><p>当你看看它对一条对角线的作用时，很明显它不是一个线性变换；</p><p><img src="transform2.png" alt="image-20210209162235888"></p><p>总体来说，你应该把线性变换看作是“保持网格线平行且等距分布”的变换；</p><h4 id="3-1-1-如何用数值描述线性变换"><a href="#3-1-1-如何用数值描述线性变换" class="headerlink" title="3.1.1 如何用数值描述线性变换"></a>3.1.1 如何用数值描述线性变换</h4><p><img src="transform3.png" alt="image-20210209162450690"></p><p>当你在通过编程制作动画和视频来教授这一主题，你应该给计算机什么样的计算公式；使得你给它一个向量的坐标，它能给你变换后向量的坐标呢？</p><p>实际结果是，你只需要记录两个基向量i帽和j帽变换后的位置；</p><p><img src="transform5.png" alt="image-20210209163505605"></p><p>比如说，考虑坐标为（-1，2）的向量V。 这个向量就是 -1 与 i帽之积与2与j帽之积的和；</p><p>如果运用一些变换，并且跟随这三个向量的运动。网格线保持平行且等距分布的性质有一个重要的推论；</p><p><img src="transform6.png" alt="image-20210209165040650"></p><p>变换后的向量V的位置，是-1与变换后的i帽之积，加上2与变换后的j帽之积；</p><p>换句话说，向量V是i帽和j帽的一个特定线性组合，那么变换后的向量V也是变换后i帽和j帽的同样的线性组合；这意味着，你可以只根据变换后的i帽和j帽，就推断出变换后的V；</p><p>如上图所示的变换，可以看出i帽落在坐标（1，-2）上。j帽落在x轴上，坐标为（3，0）；也就是说，-1乘以i帽加上2乘以j帽所代表的向量；会落在-1 乘以向量（1，-2）加上2乘以向量（3，0）的位置上；简单运算之后，你就能推断出向量V一定落在向量（5，2）上；</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformed V = <span class="number">-1</span>(Transformed i) + <span class="number">2</span>(Transformed j)</span><br></pre></td></tr></table></figure><p><img src="transform7.png" alt="image-20210209165909608"></p><p>实际上，因为展示出整个变换的样子。完全可以直接读出向量V在变换后落在坐标（5，2）上；但是更炫酷的是，只要记录了变换后的i帽和j帽。我们就可以推断出任意向量在变换之后的位置；完全必须观察变换本身是什么样。</p><p>一般情况下，一个向量的坐标是（x，y），变换后这个向量就是x乘以变换后的i帽（1，-2）；加上y乘以变换后的j帽（3，0）。简单运算之后你就知道它落在坐标（1x+3y, -2x+0y）上。运用这个公式，我给你任意一个向量，你都能告诉它在变换后的位置；</p><p><img src="transform8.png" alt="image-20210209173033678"></p><p>以上这些内容是在说，一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标。通常我们将这些坐标包装在一个<code>2*2</code>的格子中，称它为<code>2*2</code>矩阵；</p><p><img src="transform9.png" alt="image-20210209175112110"></p><p>你可以把它的列理解为两个特殊的向量，即变换后的i帽和j帽。如果你有一个描述线性变换的2*2矩阵，以及一个给定向量；你想了解线性变换对这个向量的作用；你只需要取出向量的坐标；将它们分别与矩阵的特定列相乘，然后将结果相加即可；这与“缩放基向量再相加”的思想一致</p><p><img src="transfrom10.png" alt="image-20210209175818004"></p><h2 id="4-矩阵乘法与线性变换复合"><a href="#4-矩阵乘法与线性变换复合" class="headerlink" title="4. 矩阵乘法与线性变换复合"></a>4. 矩阵乘法与线性变换复合</h2><h2 id="5-三维空间中的线性变换"><a href="#5-三维空间中的线性变换" class="headerlink" title="5. 三维空间中的线性变换"></a>5. 三维空间中的线性变换</h2><h2 id="6-行列式"><a href="#6-行列式" class="headerlink" title="6. 行列式"></a>6. 行列式</h2><h2 id="7-逆矩阵、列空间与零空间"><a href="#7-逆矩阵、列空间与零空间" class="headerlink" title="7. 逆矩阵、列空间与零空间"></a>7. 逆矩阵、列空间与零空间</h2><h2 id="8-非方阵"><a href="#8-非方阵" class="headerlink" title="8. 非方阵"></a>8. 非方阵</h2><h2 id="9-点积与对偶性"><a href="#9-点积与对偶性" class="headerlink" title="9. 点积与对偶性"></a>9. 点积与对偶性</h2><h2 id="10-叉积的标准介绍"><a href="#10-叉积的标准介绍" class="headerlink" title="10. 叉积的标准介绍"></a>10. 叉积的标准介绍</h2><h2 id="11-以线性变换的眼光看叉积"><a href="#11-以线性变换的眼光看叉积" class="headerlink" title="11. 以线性变换的眼光看叉积"></a>11. 以线性变换的眼光看叉积</h2><h2 id="12-基变换"><a href="#12-基变换" class="headerlink" title="12. 基变换"></a>12. 基变换</h2><h2 id="13-特征向量与特征值"><a href="#13-特征向量与特征值" class="headerlink" title="13. 特征向量与特征值"></a>13. 特征向量与特征值</h2><h2 id="14-抽象向量空间"><a href="#14-抽象向量空间" class="headerlink" title="14. 抽象向量空间"></a>14. 抽象向量空间</h2><h2 id="15-克莱姆法则，几何解释"><a href="#15-克莱姆法则，几何解释" class="headerlink" title="15. 克莱姆法则，几何解释"></a>15. 克莱姆法则，几何解释</h2>]]></content>
      
      
      <categories>
          
          <category> algebra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cli</title>
      <link href="2021/02/07/cli/"/>
      <url>2021/02/07/cli/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Quick-start"><a href="#1-Quick-start" class="headerlink" title="1. Quick start"></a>1. Quick start</h2><h3 id="1-1-创建文件夹"><a href="#1-1-创建文件夹" class="headerlink" title="1.1  创建文件夹"></a>1.1  创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mkdir sunmao &amp;&amp; <span class="built_in">cd</span> sunmao &amp;&amp; npm init -y</span><br><span class="line">$&gt; touch sm.js</span><br></pre></td></tr></table></figure><h3 id="1-2-设置package-json"><a href="#1-2-设置package-json" class="headerlink" title="1.2 设置package.json"></a>1.2 设置package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"sunmao"</span>,</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"sunmao"</span>: <span class="string">"sm.js"</span> <span class="comment">// 添加 bin 配置，sumao 命令即 指向 sm.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"A Iterating scaffolding for react, redux-saga and Typescript"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"main.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"git+https://github.com/TenonMortise/sunmao"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"ruanhan"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"bugs"</span>: &#123;</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/TenonMortise/sunmao/issues"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://github.com/TenonMortise/sunmao#readme"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-npm-link"><a href="#1-3-npm-link" class="headerlink" title="1.3 npm link"></a>1.3 npm link</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sm.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello, sunmao'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&gt; chmod 755 sm.js</span><br><span class="line">$&gt; sudo npm link</span><br><span class="line"></span><br><span class="line">up to date <span class="keyword">in</span> 10.078s</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/sunmao -&gt; /usr/<span class="built_in">local</span>/lib/node_modules/sunmao/sm.js</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/node_modules/sunmao -&gt; /Users/ruanhan/sunmao</span><br><span class="line"></span><br><span class="line">$&gt; sunmao</span><br><span class="line">$&gt; hello, sunmao</span><br></pre></td></tr></table></figure><p>参考文档：</p><p><a href="https://javascript.ruanyifeng.com/nodejs/npm.html#toc0" target="_blank" rel="noopener">npm link</a></p><h3 id="1-4-npm-unlink"><a href="#1-4-npm-unlink" class="headerlink" title="1.4 npm unlink"></a>1.4 npm unlink</h3><p>如果你的项目不再需要该模块，可以在项目目录内使用<code>npm unlink</code>命令，删除符号链接。</p><h2 id="2-第三方工具介绍"><a href="#2-第三方工具介绍" class="headerlink" title="2. 第三方工具介绍"></a>2. 第三方工具介绍</h2><h3 id="2-1-commander-js"><a href="#2-1-commander-js" class="headerlink" title="2.1 commander.js"></a>2.1 commander.js</h3><p>可以自动的解析命令和参数，用于处理用户输入的命令。</p><h3 id="2-2-download-git-repo"><a href="#2-2-download-git-repo" class="headerlink" title="2.2 download-git-repo,"></a>2.2 download-git-repo,</h3><p>下载并提取 git 仓库，用于下载项目模板。</p><h3 id="2-3-inrequire-js"><a href="#2-3-inrequire-js" class="headerlink" title="2.3 inrequire.js"></a>2.3 inrequire.js</h3><p>通用的命令行用户界面集合，用于和用户进行交互。</p><h3 id="2-4-ora"><a href="#2-4-ora" class="headerlink" title="2.4 ora"></a>2.4 ora</h3><p>下载过程久的话，可以用于显示下载中的动画效果。</p><h3 id="2-5-chalk"><a href="#2-5-chalk" class="headerlink" title="2.5 chalk"></a>2.5 chalk</h3><p>可以给终端的字体加上颜色。</p><h3 id="2-6-log-symbols"><a href="#2-6-log-symbols" class="headerlink" title="2.6 log-symbols"></a>2.6 log-symbols</h3><p>可以在终端上显示出 √ 或 × 等的图标。</p><h3 id="2-7-install"><a href="#2-7-install" class="headerlink" title="2.7 install"></a>2.7 install</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commander download-git-repo inquirer ora chalk log-symbols</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp</title>
      <link href="2021/02/02/dp/"/>
      <url>2021/02/02/dp/</url>
      
        <content type="html"><![CDATA[<h2 id="1-动态规划题目特点"><a href="#1-动态规划题目特点" class="headerlink" title="1 动态规划题目特点"></a>1 动态规划题目特点</h2><ol><li>计数类</li></ol><ul><li>有多少种方式走到右下角</li><li>有多少种方法选出K个数使得和是sum</li></ul><ol start="2"><li>求最大最小值（DP最大的一类）</li></ol><ul><li>从左上角走到右下角路径的最大数字和</li><li>最长上升子序列长度</li></ul><ol start="3"><li>求存在性</li></ol><ul><li>取石子游戏，先手是否必胜</li><li>能不能选出K个数使得和是sum</li></ul><h2 id="2-dp解题步骤"><a href="#2-dp解题步骤" class="headerlink" title="2 dp解题步骤"></a>2 dp解题步骤</h2><p>以 Coin Change 为例；</p><p><strong>三种硬币，分别面值2元，5元和7元， 没种硬不都有足够多，去书店买本书需要27元。如何用最少的硬币组合正好付清，不需要对方找钱</strong></p><p><code>分析： 这题出现求最少，显然可以使用DP方法来解决</code></p><h3 id="2-1-动态规划组成部分一：-确定状态"><a href="#2-1-动态规划组成部分一：-确定状态" class="headerlink" title="2.1 动态规划组成部分一： 确定状态"></a>2.1 动态规划组成部分一： 确定状态</h3><h4 id="2-1-1-状态在动态规划中的作用属于定海神针"><a href="#2-1-1-状态在动态规划中的作用属于定海神针" class="headerlink" title="2.1.1  状态在动态规划中的作用属于定海神针"></a>2.1.1  状态在动态规划中的作用属于定海神针</h4><h4 id="2-1-2-简单来说，解动态规划的时候需要开一个数组，数组的每个元素f-i-或者-f-i-j-代表什么；-类似于解数学题中，X，-Y，Z代表什么；"><a href="#2-1-2-简单来说，解动态规划的时候需要开一个数组，数组的每个元素f-i-或者-f-i-j-代表什么；-类似于解数学题中，X，-Y，Z代表什么；" class="headerlink" title="2.1.2  简单来说，解动态规划的时候需要开一个数组，数组的每个元素f[i] 或者 f[i][j]代表什么； 类似于解数学题中，X， Y，Z代表什么；"></a>2.1.2  简单来说，解动态规划的时候需要开一个数组，数组的每个元素<code>f[i]</code> 或者 <code>f[i][j]</code>代表什么； 类似于解数学题中，X， Y，Z代表什么；</h4><h4 id="2-1-3-确定状态需要两个意识："><a href="#2-1-3-确定状态需要两个意识：" class="headerlink" title="2.1.3  确定状态需要两个意识："></a>2.1.3  确定状态需要两个意识：</h4><h5 id="2-1-3-1-最后一步"><a href="#2-1-3-1-最后一步" class="headerlink" title="2.1.3.1 最后一步"></a>2.1.3.1 最后一步</h5><p>  虽然我们不知道最优策略是什么，但是最优策略肯定是K梅硬币a1,a2,…,ak 面值加起来是27；</p><p>最后一步指的就是最优策略中的最后一个决策，对应到这一题就是一定会有一枚最后的硬币决策： ak， 那么除了这枚硬币，前面硬币的面值加起来是27-ak；</p><p><img src="01.png" alt="image-20210202160842790"></p><p><strong>关键点1：</strong></p><p>我们不关心前面的 <code>k-1</code> 枚硬币是怎么拼出<code>27-ak</code>的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道<code>ak</code> 和<code>k</code>， 但是我们确定前面的硬币拼出了 <code>27-ak</code>；</p><p><strong>关键点2:</strong></p><p>因为是最优策略，所以拼出<code>27-ak</code>的硬币数一定要最少，否则这就不是最优策略了；</p><p>解析关键点2： 比如最优策略要用5枚硬币，假设最后一枚是5元面额，那么4枚硬币组成了22元。你不可能用3枚，2枚甚至1枚拼成22元； 浅显的道理，如果用3枚可以拼出来22元的话，那么最优策略要用5枚的假设就不成立；</p><h5 id="2-1-3-2-子问题"><a href="#2-1-3-2-子问题" class="headerlink" title="2.1.3.2 子问题"></a>2.1.3.2 子问题</h5><p>我现在当然想求K，但是想求K的话，需要知道前面k-1等于几。（即最少需要多少枚硬币可以拼出27-ak）</p><p>所以，我们的要求就变成了：最少要用多少枚硬币可以拼出27-ak枚硬币；</p><p>原问题是最少用多少枚硬币拼出27；</p><p>我们将原问题转化成了一个子问题，而且规模更小： <code>27-ak</code></p><p>那该如何定义状态呢，一旦子问题出来了，状态就直接把相同的汉字copy下来。即<code>最少用多少枚硬币拼出X</code></p><p>为了简化定义，我们设状态 <code>f(x)=最少用多少枚硬币拼出x</code>结合这一题就是<code>f(x)=最少用多少枚硬币拼出27</code>.整个问题就变成，以前求<code>f(27)</code>,现在求<code>f(27-ak)</code>;</p><p><img src="01.png" alt="ziwenti"></p><p>等等，我们还不知道最后那枚硬币ak是多少， 当然最后那枚硬币ak只可能是2，5或者7</p><p>如果ak是2的话，f(27)应该是f(27-2)+1（加上最后这一枚硬币2）</p><p>如果ak是5的话，f(27)应该是f(27-5)+1（加上最后这一枚硬币5）</p><p>如果ak是7的话，f(27)应该是f(27-7)+1（加上最后这一枚硬币7）</p><p>除此之外，没有其他的可能了；</p><p>因为我们需求最少的硬币数，所以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">27</span>) = min&#123;f(<span class="number">27</span><span class="number">-2</span>)+<span class="number">1</span>, f(<span class="number">27</span><span class="number">-5</span>)+<span class="number">1</span>, f(<span class="number">27</span><span class="number">-7</span>)+<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="02.png" alt="image-20210202225916604"></p><h4 id="2-1-4-递归解法的问题"><a href="#2-1-4-递归解法的问题" class="headerlink" title="2.1.4 递归解法的问题"></a>2.1.4 递归解法的问题</h4><p>递归做了很多重复计算，效率低下</p><p>如何避免？</p><p>DP是将计算结果保存下来，并改变计算顺序；</p><h3 id="2-2-动态规划组成部分二：-转移方程"><a href="#2-2-动态规划组成部分二：-转移方程" class="headerlink" title="2.2 动态规划组成部分二： 转移方程"></a>2.2 动态规划组成部分二： 转移方程</h3><p>设状态f[x] = 最少用多少枚硬币拼出X；</p><p>对于任意X</p><p><img src="03.png" alt="image-20210202231607434"></p><h4 id="2-2-1-f-x-与-f-x-的区别"><a href="#2-2-1-f-x-与-f-x-的区别" class="headerlink" title="2.2.1 f[x] 与 f(x)的区别"></a>2.2.1 f[x] 与 f(x)的区别</h4><p>f[x] ，[] 代表数组下标</p><p>f(x)  ，（）代表函数调用</p><h3 id="2-3-动态规划组成部分三：-初始条件和边界条件"><a href="#2-3-动态规划组成部分三：-初始条件和边界条件" class="headerlink" title="2.3 动态规划组成部分三： 初始条件和边界条件"></a>2.3 动态规划组成部分三： 初始条件和边界条件</h3><p><code>f[x]=min{f[x-2]+1, f[x-5]+1, f[x-7]+1}</code></p><p><strong>两个问题</strong></p><p>x-2, x-5或者x-7 小于0怎么办？什么时候停下来？</p><p>如果不能拼出Y，就定义f[Y] = 正无穷，例如 f[-1] = f[-2] = … = 正无穷</p><p>所以f[1] = min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1；</p><p>初始条件： f[0] = 0; 因为初始条件用转移方程是算不出来的。但我又需要它的定义。</p><p>根据 f[0] = min{f[-2]+1, f[-5]+1, f[-7]+1} 算，f[0]是正无穷的。而我们明明知道，f[0] 不等于正无穷，而是等于0，所以需要手动制定。有的时候初始条件不需要给很多个，比如f[0], f[1], f[2] 等等是不需要额外多个去定义，定不定义该值取决于能否根据其他预设的值;比如f[1] 是正无穷，f[2] = {f[0]+1, f[-3]+1, f[-5]+1} 是 1， 然后后面的值都能基于此算出来了；</p><p>初始条件的实质就是把那些最小的值定义下来，边界情况的实质就是不要数组越界；不管数组往下越界到负数，还是数组往上越界超过了都不行；</p><h3 id="2-4-动态规划组成部分四：计算顺序"><a href="#2-4-动态规划组成部分四：计算顺序" class="headerlink" title="2.4 动态规划组成部分四：计算顺序"></a>2.4 动态规划组成部分四：计算顺序</h3><p>拼出X所需要的最少硬币数： f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}</p><p>初始条件： f[0] = 0</p><p>然后计算 f[1], f[2],… , f[27] （对于此题来说，是从小到大来计算，DP大多数情况下都是从小到大，二维的话就是从上到下，从左到右）</p><p>计算顺序只有一个原则，那就是当我们计算到f[X]时，f[X-2], f[X-5], f[X-7] 都已经出结果了；</p><h3 id="2-5-动态规划计算步骤"><a href="#2-5-动态规划计算步骤" class="headerlink" title="2.5 动态规划计算步骤"></a>2.5 动态规划计算步骤</h3><p>f[X] = 最少用多少枚硬币拼出X</p><p>f[X] = 正无穷 表示无法用硬币拼出X</p><p><img src="04.png" alt="image-20210203112234974"></p><p>每一步尝试三种硬币，一共27步；</p><p>与递归算法相比，没有任何重复计算；</p><p>算法时间复杂度（即需要进行的步数）： <code>27*3  (总面额*多少种硬币)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>A  [2, 5, 7]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>M  27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coinChange</span>(<span class="params">A, M</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 0 ... n: [n+1]</span></span><br><span class="line">  <span class="comment">// 0 ... n-1: [n]</span></span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Array</span>(M + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// number of kind of coins</span></span><br><span class="line">  <span class="keyword">let</span> n = A.length;</span><br><span class="line">  <span class="comment">// initialization</span></span><br><span class="line"></span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i, j;</span><br><span class="line">  <span class="comment">//最少用多少枚硬币 依次拼出  f[1], f[2], ... f[27]，从小到大的顺序</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">    <span class="comment">// 初始设置为无穷大</span></span><br><span class="line">    f[i] = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">    <span class="comment">// last coin A[j] 要拼出i块钱，最后一枚硬币应该是谁（这枚硬币不应该跳出A的范围）</span></span><br><span class="line">    <span class="comment">// f[i] = min&#123;f[i-A[0]] + 1,..., f[i-A[n-1]]+1&#125;;</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= A[j] &amp;&amp; f[i - A[j]] != <span class="built_in">Number</span>.MAX_VALUE) &#123;</span><br><span class="line">        <span class="comment">// i - A[j] 可能是负数，所以需要添加判断</span></span><br><span class="line">        <span class="comment">// 无穷大不能+1，会越界。所以需要添加校验；</span></span><br><span class="line">        f[i] = <span class="built_in">Math</span>.min(f[i - A[j]] + <span class="number">1</span>, f[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[M] == <span class="built_in">Number</span>.MAX_VALUE) &#123;</span><br><span class="line">    <span class="comment">// 如果拼不出来，要求返回-1；</span></span><br><span class="line">    f[M] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[M];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(coinChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">27</span>));</span><br></pre></td></tr></table></figure><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p>求最值型动态规划</p><p>动态规划组成部分：</p><ol><li>确定状态<ul><li>最后一步 (最优策略中使用的最后一枚硬币ak)</li><li>化成子问题 （最少的硬币拼出更小的面值27-ak）</li></ul></li><li>转移方程<ul><li>f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}</li></ul></li><li>初始条件和边界条件<ul><li>f[0] = 0, 如果不能拼出Y，f[Y]= 正无穷</li></ul></li><li>计算顺序<ul><li>f[0], f[1], f[2], …</li></ul></li></ol><p>消除冗余，加速计算；</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webgl01</title>
      <link href="2021/01/28/webgl01/"/>
      <url>2021/01/28/webgl01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图形系统绘图原理"><a href="#1-图形系统绘图原理" class="headerlink" title="1. 图形系统绘图原理"></a>1. 图形系统绘图原理</h2><p>webgl绘图，要深入细节里，根内存、cpu交互，真正控制图形输出的每一个细节；</p><p>webgl基础概念，GPU， 渲染管线，着色器；</p><h3 id="1-1-计算机图形系统"><a href="#1-1-计算机图形系统" class="headerlink" title="1.1 计算机图形系统"></a>1.1 计算机图形系统</h3><p>一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。</p><ul><li><p>光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</p></li><li><p>像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</p></li><li><p>帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</p></li><li><p>CPU（Central Processing Unit）：中央处理单元，负责逻辑计算。</p></li><li><p>GPU（Graphics Processing Unit）：图形处理单元，负责图形计算。</p></li></ul><h4 id="1-1-1-绘图通用过程"><a href="#1-1-1-绘图通用过程" class="headerlink" title="1.1.1 绘图通用过程"></a>1.1.1 绘图通用过程</h4><p>首先，经过CPU处理，成为具有特定结构的几何信息，然后，这些信息会被送到GPU中进行处理。在GPU中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上；</p><p>这个过程主要分为两个步骤，</p><p>一是对 给定的数据结合绘图的场景进行计算（例如相机，光源，遮挡物体等等）进行计算，最终将图形变为屏幕空间的2D坐标。</p><p>二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上，这整个过程是一步一步进行的，前一步的输出就是最后一步的输入，这个过程叫做渲染管线（RenderPipelines）</p><h4 id="1-1-2-GPU"><a href="#1-1-2-GPU" class="headerlink" title="1.1.2 GPU"></a>1.1.2 GPU</h4><p>CPU 和 GPU 都属于处理单元，但是结构不同。</p><p>CPU像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物，一条CPU流水线串行处理这些任务的速度，取决于CPU（管道）的处理能力；一个计算机系统会有很多条CPU流水线，任何一个任务 都可以随机通过任意一个流水线，这样计算机就能够并行处理多个任务了，这样一条流水线对应的就是 thread；</p><p>CPU处理大型任务是足够的，但是处理图像应用就不合适了。处理图像，实际上是处理计算图片上每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成一个简单的任务，而每一个图片应用又是由无数个个像素点组成的，所以，需要在同一时间处理无数个小任务。要处理这么多的小任务，使用更小，更多的处理单元，是一种更好的处理方式，GPU就是这样的处理单元；</p><p>GPU由大量的小型处理单元构成，它没有CPU那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张800*600大小的图片，GPU也可以保证这48万个像素点分别对应一个小单元，这样就可以同时对每个像素点进行计算了；</p><h2 id="2-helloWorld"><a href="#2-helloWorld" class="headerlink" title="2 .helloWorld"></a>2 .helloWorld</h2><p>浏览器提供的webgl API是 OpenGL ES的js绑定版本，它赋予了开发者操作GPU的能力。这一特点也让webGL的绘图方式略微复杂，无法直接调用API控制画笔。大致需要以下几个步骤</p><h3 id="2-1-webGL绘图步骤"><a href="#2-1-webGL绘图步骤" class="headerlink" title="2.1 webGL绘图步骤"></a>2.1 webGL绘图步骤</h3><ol><li>创建webgl上下文</li><li>创建webgl程序</li><li>将数据存入缓冲区</li><li>将缓冲区数据读取到GPU</li><li>GPU执行webgl程序，输出结果</li></ol><h3 id="2-1-1-创建webgl上下文"><a href="#2-1-1-创建webgl上下文" class="headerlink" title="2.1.1 创建webgl上下文"></a>2.1.1 创建webgl上下文</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gl = canvas.getContext(<span class="string">'webgl'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-2-创建webgl程序"><a href="#2-2-2-创建webgl程序" class="headerlink" title="2.2.2 创建webgl程序"></a>2.2.2 创建webgl程序</h3><p>webgl程序是一个webGL Program对象，它是给GPU 最终运行着色器的程序；</p><p>首先编写两个着色器；两个着色器分别对应的是 顶点 和图元， webgl是以顶点和图元来描述图形几何信息的；所以顶点和图元是绘图过程中必不可少的。webgl绘制一个图形的过程，一般需要两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，一段叫片元着色器（Fragment Shader）负责处理图形的像素信息；</p><h4 id="2-2-2-1-顶点"><a href="#2-2-2-1-顶点" class="headerlink" title="2.2.2.1 顶点"></a>2.2.2.1 顶点</h4><p>顶点就是几何图形的顶点，三角形有三个顶点，四边形有四个顶点。</p><h4 id="2-2-2-2-图元"><a href="#2-2-2-2-图元" class="headerlink" title="2.2.2.2 图元"></a>2.2.2.2 图元</h4><p>图元是webgl可直接处理的图形单元，由webgl绘图模式决定，有点、线、三角形等；webgl中最小的图元是三角形；</p><p>webgl支持的图元类型有七种；</p><ul><li>gl.POINTS(点), </li><li>gl.LINES(线段), </li><li>gl.LINE_STRIP(线条), </li><li>gl.LINE_LOOP(回路), </li><li>gl.TRIANGLES(三角形), </li><li>gl.TRIANGLE_STRIP(三角带), </li><li>gl.TRIANGLE_FAN(三角扇)。</li></ul><p>要绘制空心三角形，gl.LINE_STRIP(线条)、gl.LINES(线段)、 gl.LINE_LOOP(回路)都可以实现。 </p><p>但是gl.LINES(线段)需要写入六个顶点([-1, -1, 0, 1, 0, 1, 1, -1, 1, -1,-1, -1]), </p><p>gl.LINE_STRIP(线条)也需要写入四个顶点([-1, -1, 0, 1, 1, -1,-1, -1]),</p><p>而gl.LINE_LOOP(回路)，只需要是三个顶点([-1, -1, 0, 1, 1, -1])；</p><h4 id="2-2-2-3-顶点着色器和片元着色器"><a href="#2-2-2-3-顶点着色器和片元着色器" class="headerlink" title="2.2.2.3 顶点着色器和片元着色器"></a>2.2.2.3 顶点着色器和片元着色器</h4><p>顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息（如顶点的坐标、法线方向、材质等等，从而改变我们绘制出来的图形的形状或者大小等等；</p><p>顶点处理完成之后，webgl就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单讲，就是对指定图元中的像素点着色；</p><p>webgl从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是生成光栅信息的过程，也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化后的像素信息；</p><p><strong>举例</strong></p><p>将图元设为<code>线段</code>，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是<code>空心</code>的。</p><p>将图元设为<code>三角形</code>，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是<code>实心</code>的；</p><p>因为图元是webGL可以直接处理的图形单元，所以其他非图元的圆形最终必须要转换为图元才可以被webGL处理。比如绘制实心四边形，就需要将四边形拆分成两个三角形，再交给webGL分别绘制出来；</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="comment">// attribute 相当于var const，声明变量的关键字</span></span><br><span class="line"><span class="comment">// vec2 变量类型，vec2表示二维向量</span></span><br><span class="line"><span class="comment">// position 变量名</span></span><br><span class="line"><span class="keyword">const</span> vertex = `</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> position;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_PointSize</span> = <span class="number">1.0</span>;</span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">`;</span><br><span class="line"><span class="comment">// 通过gl_Position 设置顶点；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">const</span> fragment = `</span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">`;</span><br><span class="line"><span class="comment">// gl_FragColor 是webGL片元着色器内置变量，表示当前像素点颜色。 它是一个用RGBA色值表示的四维向量数据；</span></span><br><span class="line"><span class="comment">// 变量类型 vec4 表示四维向量</span></span><br><span class="line"><span class="comment">// webGL可以并行地对整个三角形的所有像素点同时运行片元着色器，并行处理是WebGL程序非常重要的概念；不论这个三角形是大是小，有几十个像素点还是上百万个像素点，GPU都是同时处理每个像素点的；也就是说，图形中有多少个像素点，着色器程序在GPU中就会被同时执行多少次；</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建顶点着色器对象</span></span><br><span class="line"><span class="keyword">const</span> vertexShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class="line">gl.shaderSource(vertexShader, vertex);</span><br><span class="line">gl.compileShader(vertexShader);</span><br><span class="line"><span class="comment">// 创建片元着色器对象</span></span><br><span class="line"><span class="keyword">const</span> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class="line">gl.shaderSource(fragmentShader, fragment);</span><br><span class="line">gl.compileShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建webGLProgram 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> program = gl.createProgram();</span><br><span class="line">gl.attachShader(program, vertexShader);</span><br><span class="line">gl.attachShader(program, fragmentShader);</span><br><span class="line">gl.linkProgram(program);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用webGLProgram对象</span></span><br><span class="line">gl.useProgram(program);</span><br></pre></td></tr></table></figure><h4 id="2-2-2-4-向片元着色器传递数据（与绘图步骤无关）"><a href="#2-2-2-4-向片元着色器传递数据（与绘图步骤无关）" class="headerlink" title="2.2.2.4 向片元着色器传递数据（与绘图步骤无关）"></a>2.2.2.4 向片元着色器传递数据（与绘图步骤无关）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> postion;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color; <span class="comment">// 顶点着色器可通过 varying变量传给片元着色器；</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_PointSize</span> = <span class="number">1.0</span>;</span><br><span class="line">  color = <span class="type">vec3</span>(<span class="number">0.5</span> + position * <span class="number">0.5</span>, <span class="number">0.0</span>); <span class="comment">// 将顶点值映射为一个RGB颜色值；</span></span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position*<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将gl_FragColor 的rgb值设为变量color的值；</span></span><br><span class="line"><span class="comment">// 这个三角形是一个颜色均匀渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。webgl</span></span><br><span class="line"><span class="comment">// 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值</span></span><br><span class="line"><span class="comment">// 利用线性插值可以让像素点的颜色均匀渐变这一特点，可以绘制更多颜色丰富的图形；</span></span><br></pre></td></tr></table></figure><h3 id="2-2-3-将数据存入缓冲区"><a href="#2-2-3-将数据存入缓冲区" class="headerlink" title="2.2.3 将数据存入缓冲区"></a>2.2.3 将数据存入缓冲区</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三角形的顶点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>, <span class="number">-1</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将points写入webGL缓冲区</span></span><br><span class="line"><span class="keyword">const</span> bufferId = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="2-2-4-将缓冲区数据读取到GPU"><a href="#2-2-4-将缓冲区数据读取到GPU" class="headerlink" title="2.2.4 将缓冲区数据读取到GPU"></a>2.2.4 将缓冲区数据读取到GPU</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取顶点着色器中的position变量的地址</span></span><br><span class="line"><span class="keyword">const</span> vPosition = gl.getAttribLocation(program, <span class="string">'position'</span>);</span><br><span class="line"><span class="comment">// 给变量设置长度和类型</span></span><br><span class="line">gl.vertexAttribPointer(vPosition, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 激活这个变量</span></span><br><span class="line">gl.enableVertexAttribArray(vPosition);</span><br></pre></td></tr></table></figure><p>经过这样处理，在顶点着色器中，定义的points类型数组中对应的值，就能通过变量position读取到了；</p><h3 id="2-2-5-GPU执行webgl程序，输出结果"><a href="#2-2-5-GPU执行webgl程序，输出结果" class="headerlink" title="2.2.5 GPU执行webgl程序，输出结果"></a>2.2.5 GPU执行webgl程序，输出结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">gl.drawArrays(gl.TRIANGLES,<span class="number">0</span>, points.length/<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="3-Math"><a href="#3-Math" class="headerlink" title="3. Math"></a>3. Math</h2><p>我们要建立一套与各个图形系统无关联的，简单基于<code>向量和矩阵运算</code>的数学体系，用它来描述所有的几何图形信息。</p><p>如何建立一套描述几何图形信息的数学体系，以及如何用这个体系来解决可视化图形呈现的问题；</p><h3 id="3-1-坐标系"><a href="#3-1-坐标系" class="headerlink" title="3.1 坐标系"></a>3.1 坐标系</h3><p>坐标系与向量来描述基本图形的方法，从如何定义和变换图形的直角坐标系，以及如何运用向量表示点和线段；</p><h4 id="3-1-1-HTML"><a href="#3-1-1-HTML" class="headerlink" title="3.1.1 HTML"></a>3.1.1 HTML</h4><p>窗口坐标体系，以参考对象的元素盒子左上角为坐标原点，x轴向右，y轴向下，坐标值对应像素值；</p><h4 id="3-1-2-SVG"><a href="#3-1-2-SVG" class="headerlink" title="3.1.2 SVG"></a>3.1.2 SVG</h4><p>视区盒子（viewBox）坐标系，默认情况下，是以svg根元素左上角为坐标原点，x轴向右，y轴向下，svg根元素右下角坐标为它的像素宽高值。</p><p>如果设置了viewBox属性，那么svg根元素左上角为viewBox的前两个值，右下角为viewBox的后两个值；</p><h4 id="3-1-3-Canvas"><a href="#3-1-3-Canvas" class="headerlink" title="3.1.3 Canvas"></a>3.1.3 Canvas</h4><p>画布左上角为坐标原点，右下角坐标值为canvas画布宽高值；</p><h4 id="3-1-4-webGL"><a href="#3-1-4-webGL" class="headerlink" title="3.1.4 webGL"></a>3.1.4 webGL</h4><p>三维坐标系，它默认以画布正中间为坐标原点，x轴朝右，y轴朝上，z轴朝外，x轴，y轴在画布中范围是 -1 到1；</p><h4 id="3-1-5-坐标系转换-以canvas为例"><a href="#3-1-5-坐标系转换-以canvas为例" class="headerlink" title="3.1.5  坐标系转换(以canvas为例)"></a>3.1.5  坐标系转换(以canvas为例)</h4><p>因为html svg canvas webgl都是直角坐标系，所以它们可以方便地相互转化。html，svg，canvas提供了transform的api很方便进行坐标系转换；</p><p>webgl本身不提供tranform的api，可以在shader里做矩阵运算来实现坐标转换。</p><p>在很多可视化场景下，要处理成千上万的图形，如果这个时候，在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。采用坐标变换的方式就是一个很好的优化思路，它能够简化计算量，这不仅让代码更容易理解，也可以节省CPU运算时间；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rc2 = rough.canvas(canvas2);</span><br><span class="line"><span class="keyword">const</span> ctx = rc2.ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过translate变换 ，将canvas坐标画布原点从左上角（0，0）移动至（256， 256）的位置，即画布的底边上的中心位置；</span></span><br><span class="line">ctx.translate(<span class="number">256</span>, <span class="number">256</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以移动了原点后的新的坐标为参照，通过scale(1,-1) 将Y轴向下的部分，即y&gt;0的部分沿x轴翻转180度；这样就变成画布底边中点为原点，x轴向右，y轴向上的坐标系了；</span></span><br><span class="line">ctx.scale(<span class="number">1</span>, <span class="number">-1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hillOpts2 = &#123; <span class="attr">roughness</span>: <span class="number">2.8</span>, <span class="attr">strokeWidth</span>: <span class="number">2</span>, <span class="attr">fill</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line">rc2.path(<span class="string">"M-180 0L-80 100L20 0"</span>, hillOpts2);</span><br><span class="line">rc2.path(<span class="string">"M-20 0L80 100L180 0"</span>, hillOpts2);</span><br><span class="line"></span><br><span class="line">rc2.circle(<span class="number">0</span>, <span class="number">150</span>, <span class="number">105</span>, &#123;</span><br><span class="line">  stroke: <span class="string">"red"</span>,</span><br><span class="line">  strokeWidth: <span class="number">4</span>,</span><br><span class="line">  fill: <span class="string">"rgba(255,255, 0, 0.4)"</span>,</span><br><span class="line">  fillStyle: <span class="string">"solid"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-向量"><a href="#3-2-向量" class="headerlink" title="3.2 向量"></a>3.2 向量</h3><p>在直角坐标系里绘制图形，一般的几何图形都是由点，线段喝面构成，其中，点和线段是基础的图元信息，因此，如何描述它们是绘图的关键；</p><p>如何用向量来描述点和线段？一般用向量来表示一个点或者一个线段；</p><p>用二维向量来表示这个平面上的点和线段，二维向量其实就是一个包含了两个数值的数组，一个是x坐标值，一个是y坐标值；</p><p><img src="xiangliang1.png" alt="image-20210129145004214"></p><p><code>向量V(x,y)有两个含义，一是表示该坐标系下位于（x，y）处的一个点，二是可以表示从原点（0，0）到坐标（x，y）的一根线段。</code></p><h4 id="3-2-1-向量基本运算"><a href="#3-2-1-向量基本运算" class="headerlink" title="3.2.1 向量基本运算"></a>3.2.1 向量基本运算</h4><p><img src="xiangliang2.png" alt="image-20210129150448210"></p><p>现在有两个向量，v1和v2；</p><p>v1+v2 相当于将V1的终点沿着v2向量的方向移动一段距离。这段距离等于v2向量的长度。</p><p>这样在平面上得到三个元素</p><ol><li>一个新的点 (x1+x2, y1+y2)；</li><li>一条新的线段 [(0, 0), (x1+x2, y1+y2)];</li><li>一段折线 [(0,0),(x1,y1),(x1+x2, y1+y2)];</li></ol><h4 id="3-2-2-向量长度和方向"><a href="#3-2-2-向量长度和方向" class="headerlink" title="3.2.2 向量长度和方向"></a>3.2.2 向量长度和方向</h4><p>一个向量包含长度和方向信息</p><p>它的长度可以用向量的 x、y 的平方和的平方根 （勾三股四弦五）来表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.length = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">Math</span>.hypot(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y)&#125;;</span><br></pre></td></tr></table></figure><p>它的方向可以用与 x 轴的夹角来表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.dir = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="keyword">this</span>.y, <span class="keyword">this</span>.x);&#125;</span><br><span class="line"><span class="comment">// Math.atan2 的取值范围是 -π到π，负数表示在 x 轴下方，正数表示在 x 轴上方。</span></span><br></pre></td></tr></table></figure><p><img src="atan2.png" alt="image-20210129161732242"></p><p>根据长度和方向的定义，还能推导出一组关系方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.x = v.length * <span class="built_in">Math</span>.cos(v.dir);</span><br><span class="line">v.y = v.length * <span class="built_in">Math</span>.sin(v.dir);</span><br></pre></td></tr></table></figure><p><strong>推导过程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#角A  对边=y 邻边 = x, 斜边 = z</span></span><br><span class="line">x*x + y*y = z*z</span><br><span class="line">sinA = 对边/斜边 = y/z</span><br><span class="line">cosA = 邻边/斜边 = x/z</span><br><span class="line">tanA = 对边/邻边 = sinA/cosA = (y/z) / (x/z) = y/x;</span><br><span class="line"></span><br><span class="line">v.length * cosA = z * (x/z) = x</span><br><span class="line">v.length * sinA = z * (y/z) = y</span><br></pre></td></tr></table></figure><p>结论： 可以很简单构造出一个绘图向量。如果以点 V（x0, y0）为起点，沿着某个方向画一段长度为length的线段，只需构造如下一个向量即可；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = length * v(cos(A), sin(A))</span><br></pre></td></tr></table></figure><p><strong>推导过程</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 = length * v(cos(A), sin(A))</span><br><span class="line">#  这里写成 v1 = length (cosA, sinA) 更容易理解一些</span><br><span class="line">cosA = x/z;</span><br><span class="line">sinA = y/z;</span><br><span class="line">length = z;</span><br></pre></td></tr></table></figure><p>可视化呈现依赖于计算机图形学，而向量运算是整个计算机图形学的数学基础；</p><p><img src="xiangliang6.png" alt="image-20210201115049568"></p><h3 id="3-3-向量乘法"><a href="#3-3-向量乘法" class="headerlink" title="3.3 向量乘法"></a>3.3 向量乘法</h3><p>向量的点乘Dot.product, 向量的点乘也叫向量的内积、数量积；</p><p>向量的叉乘Corss.product，也叫向量积，外积、叉积；</p><h4 id="3-3-1-一个例子引出向量乘法的"><a href="#3-3-1-一个例子引出向量乘法的" class="headerlink" title="3.3.1 一个例子引出向量乘法的"></a>3.3.1 一个例子引出向量乘法的</h4><p>*<em>判断：一个点是否在扫描器内 *</em></p><p><img src="xiangliang3.png" alt="image-20210201100216269"></p><p><strong>解答</strong></p><p>如图所示，扫描器是60度，垂直向上，所以它的范围应该是60度到120度； 也就是 <code>Math.PI/3</code> 到 <code>2*Math.PI/3</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  先求出目标向量与X轴的夹脚</span></span><br><span class="line">v.dir = <span class="built_in">Math</span>.atan2(v.y, v.x); <span class="comment">// 此方法是求解夹角的，比如 Math.atan2(1,1) === Math.PI/4 // true</span></span><br><span class="line"><span class="comment">// 求解该 dir是否在扫描器之内</span></span><br><span class="line">isIn = v.dir &gt; <span class="built_in">Math</span>.PI/<span class="number">3</span> &amp;&amp; v.dir &lt; <span class="number">2</span>*<span class="built_in">Math</span>.PI/ <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-向量点乘"><a href="#3-3-2-向量点乘" class="headerlink" title="3.3.2 向量点乘"></a>3.3.2 向量点乘</h4><p>两个N维向量，a和b， a = [a1,a2,a3,…an], b = [b1b2b3….bn];  那向量的点积代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a*b = a1*b1 + a2*b2 + .... an*bn</span><br></pre></td></tr></table></figure><p>a, b 向量点积的几何意义，是a向量乘以b向量在a向量上的投影分量。</p><p>它的物理含义相当于a力作用于物体，产生b位移所做的功。</p><p><img src="xiangliang4.png" alt="image-20210201101853232"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当a、b向量平行时，那么它们的夹角为0</span></span><br><span class="line">a.x * b.x + a.y * b.y = a.length * b.length;</span><br><span class="line"><span class="comment">// 当a、b两个向量垂直时，它们的夹角就是90度，那么a.b = 0；</span></span><br><span class="line">a.x * b.x + a.y * b.y === a*b*cos(<span class="number">90</span>度) = a*b*<span class="number">0</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>向量的点乘， 对两个向量执行点乘运算，结果是一个【Scaler标量】（一个数字）</p><p>（标量： scalar， 只有大小没有方向的量，例如物体移动中的平均速率·路程）</p><h4 id="3-3-3-向量的叉乘"><a href="#3-3-3-向量的叉乘" class="headerlink" title="3.3.3 向量的叉乘"></a>3.3.3 向量的叉乘</h4><p>向量的叉乘，则是针对两条向量的另一种运算方式。</p><p>向量叉乘运算的结果不是标量，而是一个新的向量；新的向量会 垂直于 原来的这两条向量；</p><p><img src="xiangliang7.png" alt="image-20210201130057607"></p><p>向量A和向量B的叉积是向量C， 【向量C】同时垂直于【向量A和向量B】</p><p><img src="xiangliang8.png" alt="image-20210201130451600"></p><p>【向量的叉乘】一个用途就是找到我们应该在哪一轴上施加【扭力Torque】（还有，跟踪导弹，比如合金弹头的C弹，也是可以通过叉乘的方法去实现的）；</p><p>如下示例：</p><p>【向量A】表示的是炮口【当前朝向】</p><p>【向量B】表示的是炮口将要【调整后的朝向】</p><p>【向量C】将两个向量进行叉乘后，找到炮口需要在哪一轴上进行旋转并且施加相应的扭力；</p><p><img src="xiangliang9.png" alt="image-20210201131037523"></p><p><img src="xiangliang5.png" alt="image-20210201104506469"></p><p><strong>叉积几何意义</strong></p><p>向量a和b的叉积，就相当于向量a（蓝色带箭头线段）与向量b沿垂直方向的投影（红色带箭头线段）的乘积。（如上图所示），二维向量叉积的几何意义就是向量a、b组成的平行四边形的面积；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|a| 表示向量a的length；</span><br></pre></td></tr></table></figure><p><strong>思考题：求点到线段的距离</strong></p><p>在了解向量叉积的几何意义之后， 我们通过向量叉积得到平行四边形的面积，再除以底边长；就能得到点到向量所在直线的距离</p><p><strong>叉乘在数学上的计算方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中，i，j，k 分别是 x，y，z 轴的单位向量，我们把行列式展开，就能得到如下公式：</span></span><br><span class="line">a X b = [y1 * z2 - y2 * z1, - (x1 * z2 - x2 * z1), x1 * y2 - x2 * y1]</span><br></pre></td></tr></table></figure><p>更多点积差积相关知识参考<a href="https://geek-docs.com/linear-algebra/vector/vector-chaji.html" target="_blank" rel="noopener">https://geek-docs.com/linear-algebra/vector/vector-chaji.html</a></p><p><strong>回到思考题3:  给任意一个点，判断这个点在不在扫描器内</strong></p><p><img src="xiangliang3.png" alt="image-20210201100216269"></p><p><strong>归一化</strong></p><p>归一化，用 v0的 x、y 分别除以它的绝对值。归一化后的向量方向不变，长度为 1。 在向量乘法里，如果 a、b 都是长度为 1 的归一化向量，那么|a X b| 的结果就是 a、b 夹角的正弦值，而|a • b|的结果就是 a、b 夹角的余弦值。</p><p>好了，再说回来，我们把归一化的向量 a 叉乘扫描器中线上的 v(0,1)，由于扫描器关于 y 轴对称，所以扫描器边缘与 y 轴的夹角是正负 30 度。那么在与单位向量求叉积的时候，就会出现 2 种情况：</p><ol><li>点在扫描范围内，如向量 a，就一定满足： |a X v| &lt;= ||a||v|sin(30°)| = |sin(30°)| = 0.5；</li><li>点不在扫描范围内，如向量 b，就一定满足：|b X v| &gt; ||b||v|sin(30°)| = |sin(30°)| = 0.5。</li></ol><p><img src="xiangliang10.png" alt="image-20210201170711074"></p><p>因此，只要任意一点所在的向量与单位向量的叉积结果的绝对值不大于0.5（即sin30度），就说明这个点在扫描范围内，所以如下判断方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> isInRange = <span class="built_in">Math</span>.abs(<span class="keyword">new</span> Vec2(<span class="number">0</span>, <span class="number">1</span>).cross(v0.normalize())) &lt;= <span class="number">0.5</span>; </span><br><span class="line"><span class="comment">// v0.normalize()即将v0归一化</span></span><br></pre></td></tr></table></figure><h4 id="3-3-4-点乘与叉乘加述"><a href="#3-3-4-点乘与叉乘加述" class="headerlink" title="3.3.4 点乘与叉乘加述"></a>3.3.4 点乘与叉乘加述</h4><ul><li>Dot product </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a向量 * b向量 = a长度 * b长度 * cos@</span><br><span class="line">  <span class="comment">// @ 为a向量和b向量的夹角</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 点乘使用场景1， 快速得到两个向量的夹角</span></span><br><span class="line">  cos@ = （a向量 * b向量） / （a长度 * b长度）</span><br></pre></td></tr></table></figure><p>点乘能快速得到两个向量的夹角， 特别是在两个向量都是单位向量的时候。它们的长度自然都是1；所以它们的点乘自然就是夹角的cos值；</p><p><strong>点乘满足的计算规律</strong></p><p>交换律，分配律，结合率；</p><ul><li>Cross product</li></ul><h3 id="3-4-向量和参数方程描述曲线"><a href="#3-4-向量和参数方程描述曲线" class="headerlink" title="3.4 向量和参数方程描述曲线"></a>3.4 向量和参数方程描述曲线</h3><p>用参数方程描述曲线的方法，通过此方法可以描述常见的圆，椭圆，抛物线，正余弦等曲线，还能描述更具一般性的曲线；比如贝塞尔曲线，或者Catmull-Rom曲线等等；</p><h4 id="3-4-1-画圆"><a href="#3-4-1-画圆" class="headerlink" title="3.4.1 画圆"></a>3.4.1 画圆</h4><p><img src="xiangliang11.png" alt="image-20210201210910536"></p><p>如下图所示的参数方程，圆心为（x0, y0），半径为r；</p><h4 id="3-4-2-画圆椎曲线"><a href="#3-4-2-画圆椎曲线" class="headerlink" title="3.4.2 画圆椎曲线"></a>3.4.2 画圆椎曲线</h4><p>除了画圆，参数方程还可以描述很多其他圆椎曲线，比如椭圆的参数方程。它其实和圆的参数方程很接近。其中，a，b 分别是椭圆的长轴和短轴，当a=b=r时，这个方程就是椭圆的方程式。圆是椭圆的特例；</p><p><img src="xiangliang12.png" alt="image-20210201212553422"></p><h4 id="3-4-3-抛物线的参数方程，"><a href="#3-4-3-抛物线的参数方程，" class="headerlink" title="3.4.3 抛物线的参数方程，"></a>3.4.3 抛物线的参数方程，</h4><p>其中p是常数，为焦点到准线的距离</p><p><img src="xiangliang13.png" alt="image-20210201212737588"></p><h4 id="3-4-4-贝塞尔曲线"><a href="#3-4-4-贝塞尔曲线" class="headerlink" title="3.4.4 贝塞尔曲线"></a>3.4.4 贝塞尔曲线</h4><h3 id="3-5-三角剖分和向量操作描述并处理多边形"><a href="#3-5-三角剖分和向量操作描述并处理多边形" class="headerlink" title="3.5 三角剖分和向量操作描述并处理多边形"></a>3.5 三角剖分和向量操作描述并处理多边形</h3><h3 id="3-6-仿射变换对几何图形进行坐标变换"><a href="#3-6-仿射变换对几何图形进行坐标变换" class="headerlink" title="3.6 仿射变换对几何图形进行坐标变换"></a>3.6 仿射变换对几何图形进行坐标变换</h3>]]></content>
      
      
      <categories>
          
          <category> webgl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas</title>
      <link href="2021/01/26/canvas/"/>
      <url>2021/01/26/canvas/</url>
      
        <content type="html"><![CDATA[<h2 id="1-canvas-基础API"><a href="#1-canvas-基础API" class="headerlink" title="1. canvas 基础API"></a>1. canvas 基础API</h2><h3 id="1-1-context"><a href="#1-1-context" class="headerlink" title="1.1 context"></a>1.1 context</h3><p>context对象 <strong>proto</strong> 指向CanvasRenderingContext2D，一些绘图API集中在这些地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure><p> context对象API大体分两类</p><ol><li><p>设置状态的 （颜色，线宽， 坐标变换）</p></li><li><p>绘制指令API，绘制不同形状的几何图形</p></li></ol><h3 id="1-2-绘图API"><a href="#1-2-绘图API" class="headerlink" title="1.2 绘图API"></a>1.2 绘图API</h3><h4 id="1-2-1-rect"><a href="#1-2-1-rect" class="headerlink" title="1.2.1 rect"></a>1.2.1 rect</h4><p>绘制矩形指令</p><p><strong>参数</strong></p><p>四个参数，分别为<code>要绘制矩形的x坐标</code>，<code>要绘制矩形y坐标</code>, <code>矩形宽</code>和<code>矩形高</code>；</p><h4 id="1-2-2-缓存当前状态和恢复"><a href="#1-2-2-缓存当前状态和恢复" class="headerlink" title="1.2.2 缓存当前状态和恢复"></a>1.2.2 缓存当前状态和恢复</h4><p>类似一个压栈和弹栈功能；</p><p><strong>save</strong></p><p>保留当前的路径和颜色等状态</p><p><strong>restore</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">"green"</span>;</span><br><span class="line">ctx.save(); <span class="comment">// 保存画笔初始坐标(0,0), 填充色为绿色</span></span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the default state</span></span><br><span class="line">ctx.restore();</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">150</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 该图形的画笔坐标回到 初始状态，即 (0,0) ,填充色为绿色，而不是默认色；</span></span><br></pre></td></tr></table></figure><h3 id="1-3-绘制状态API"><a href="#1-3-绘制状态API" class="headerlink" title="1.3 绘制状态API"></a>1.3 绘制状态API</h3><p><strong>fillStyle</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.fillStyle = color;</span><br></pre></td></tr></table></figure><h3 id="1-4-坐标系统"><a href="#1-4-坐标系统" class="headerlink" title="1.4 坐标系统"></a>1.4 坐标系统</h3><p>  左上角为 (0, 0)</p><p> 右下角为 (canvas.width, canvas.height)</p><h3 id="1-5-绘图过程"><a href="#1-5-绘图过程" class="headerlink" title="1.5 绘图过程"></a>1.5 绘图过程</h3><ol><li>获取canvas对象，getContext(‘2d’)</li><li>绘制状态， fillStyle， translate等；</li><li>beginPath开始绘制</li><li>调绘图指令，rect等</li><li>调fill指令，将绘制内容输出到画布中；</li></ol><h3 id="1-6-图形信息"><a href="#1-6-图形信息" class="headerlink" title="1.6 图形信息"></a>1.6 图形信息</h3><p>有的时候，类似一份层级数据（城市 &gt; 省份 &gt; 中国）这样层级数据，要将它与绘图指令建立联系，建立联系指的是 要把数据的层级、位置、和要绘制的圆的半径、位置一一对应起来；</p><p>换句话说就是要把数据转换成图形信息，这个步骤需要数学计算；</p><p>假设，我们要将数据展现在一个画布宽高为 1600 * 1600 的 Canvas 中，那我们可以通过 d3.pack() 将数据映射为一组 1600 宽高范围内的圆形。</p><p>具体绘制的过程比较简单，<code>只需要遍历数据并且根据数据内容绘制圆弧</code></p>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="2021/01/25/C/"/>
      <url>2021/01/25/C/</url>
      
        <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="1-程序"><a href="#1-程序" class="headerlink" title="1.程序"></a>1.程序</h2><blockquote><p>写程序前，先构想好程序的结构，而不是先从定义变量开始。</p></blockquote><ol><li>没有想好解决方案，不要急于动手写程序？</li><li>有了解决方案以后，可以按照“先粗后细，先抽象后具体”的办法，先有程序的轮廓，如有必要可以解决“建模工具”画一些图，而后再动手写程序；</li><li>写程序时，可以先写出程序轮廓，而后再补充变量定义等细节；</li></ol><p>程序并不纠结于是否更优。<br>而在于程序结构是不是清楚，是不是容易被人看懂</p><h3 id="1-1-写程序的过程"><a href="#1-1-写程序的过程" class="headerlink" title="1.1 写程序的过程"></a>1.1 写程序的过程</h3><blockquote><p>按照由大到小，由粗到细，由抽象到具体的方法分析、编写程序</p></blockquote><ul><li>程序的结构 （基本思想）<ul><li>程序由若干个“模块”组成</li><li>模块之内“高内聚”（高内聚， 就是这个模块只做这个事情，不干别的。功能单一）</li><li>模块之间“低耦合” （当一个模块被改动的时候，只会印象它自己，而不会影响别的）</li></ul></li></ul><h3 id="1-2-编程语言共性-（语法）"><a href="#1-2-编程语言共性-（语法）" class="headerlink" title="1.2 编程语言共性 （语法）"></a>1.2 编程语言共性 （语法）</h3><p>程序设计语言的构成,语言种类千差万别，但是，一般来说，基本成分不外四种：</p><ol><li>数据， 用以描述程序中所涉及的数据 （数据类型）</li><li>运算，用以描述程序中所包含的运算；（运算符）</li><li>控制，用以表达程序中的控制构造；（三种类型的控制语句是如何写的，顺序，分支，循环）</li><li>IO，用以表达程序中数据的传输； （如何输入和输出数据）</li></ol><h3 id="1-3-大纲"><a href="#1-3-大纲" class="headerlink" title="1.3 大纲"></a>1.3 大纲</h3><ol><li>基本概念</li><li>数据类型，运算符，表达式</li><li>IO</li><li>流程控制（顺序，分支，循转）</li><li>数组</li><li>指针</li><li>函数</li><li>构造类型</li><li>动态内存管理</li><li>调试工具，（gdb，make）</li><li>常用库函数</li></ol><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><blockquote><p>把内存想象成一个长长的带子,带子上面有很多小方格，每个格子都是一个字节（存储单元）。每个小方格都有它对应的地址，每个字节（单元）有八位，1B（byte） = 8b（bit）每一个位存储一个二进制的数。</p></blockquote><h3 id="2-1-变量与常量"><a href="#2-1-变量与常量" class="headerlink" title="2.1 变量与常量"></a>2.1 变量与常量</h3><h4 id="2-1-1-常量"><a href="#2-1-1-常量" class="headerlink" title="2.1.1 常量"></a>2.1.1 常量</h4><blockquote><p>在程序执行过程中值不会发生变化的量，数组名是一个典型的常量，一旦数组定义了，gcc为当前的数组分配了一段空间了。然后数组的位置就定死了。数组名就是一个数组的起始位置。是一个常量，如果你在=左边写上一个常量，就表示企图更改一个常量的值；比如<code>1=f</code> ，显然不成立；</p></blockquote><p><strong>常量的分类</strong></p><ul><li><p>整型常量</p></li><li><p>实型常量</p><p>3.14,  5.26;</p></li><li><p>字符常量</p><p>由单引号印起来的单个字符或者转义字符，如’a’</p><p>转义字符： ‘\n’, ‘\r’, ‘\t’ ，’\015’(八进制数)， ‘\x7f’(十六进制数)</p></li><li><p>字符串常量</p><p>由双引号印起来的一个或多个字符组成的序列，如: “”(空串)</p><p>一个字符串在存储的时候，最末尾会有一个结束标记，通常称作尾0<code>\0</code>.所以<code>&quot;&quot;</code>是占空间的，空字符占一个字节的空间；</p><ul><li>合法的字符串 （””, “a”, “abXYZ”）</li><li>暂时不确定是否合法的字符 （”abc\n\021\018”) 因为<code>\018</code>不是八进制，因为出现了8，而我们知道<code>\0</code>是字符串数组的末尾。所以<code>\0</code>到底能否插入进字符串中间，这个需要后续字符数组专题揭秘；</li><li>字符串常量需要借助构造类型——数组来保存</li><li><code>&#39;a&#39;和&quot;a&quot;的区别</code>：前者是字符常量，后者是字符串常量。</li></ul></li><li><p>标识常量</p><ul><li><p>#define， 程序中一改全改 <code>#define PI 3.14</code>，在程序预处理之后，宏名被宏体完整的替换；<code>define ADD 2+3 ADD*ADD</code> = <code>2+3*2+3而不是(2+3)*(2+3)</code>。 #define，处理在程序的预处理阶段，占编译时间。不占运行时间。一改全改；缺点： 不检查语法，只是单纯的宏体与宏名之间的替换；</p><ol><li>带参数的#define</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX(a, b)  a&gt;b?a:b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  i = <span class="number">5</span>;</span><br><span class="line">  j=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"/d\n"</span>, MAX(i, j));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -E define.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  i = <span class="number">5</span>;</span><br><span class="line">  j=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"/d\n"</span>, (i&gt;j?i:j));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>一个特殊问题的解决方式</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max = %d\n"</span>, MAX(i++, j++));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i=%d\tj=%d\n"</span>, i, j);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((i++) &gt; (j++) ? (i++) : (j++))</span><br><span class="line"></span><br><span class="line"><span class="comment">// max = 6</span></span><br><span class="line"><span class="comment">// i=7     j=4</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>首先，max和MAX的区别，MAX只占用预编译时间，等运行的时候，实际上已经将所有宏体替换到程序中去了。不会再需要额外的时间了。而max则不同，在函数的调用位置，对当前的一个执行现场做一个压栈保存。然后去到指定的函数去执行。（跳往另外一个入口地址）然后再回来，弹栈恢复当前现场的过程。这个过程 占用了运行的时间；</p></li><li><p>什么时候用宏，什么时候用函数？在需要极致性能的场景用宏，前提是宏能满足；比如内核。在应用层面，系统层面，多用函数。因为应用层要求更高的是稳定性，而非实时性。</p></li><li><p>解决方案，需要找一个变量来接受；而不是让其继续做加运算；</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (&#123;typeof(a) A = a, B = b;((A) &gt; (B) ? (A) : (B)); &#125;)</span></span><br><span class="line"><span class="comment">// typeof(a) 用a的类型定义A，就很灵性了。有点泛型的意思了；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max = %d\n"</span>, MAX(i++, j++));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i=%d\tj=%d\n"</span>, i, j);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// max = 5</span></span><br><span class="line"><span class="comment">// i=6     j=4</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-变量"><a href="#2-1-2-变量" class="headerlink" title="2.1.2 变量"></a>2.1.2 变量</h4><blockquote><p>用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量；</p></blockquote><p>当计算机执行到 <code>int max=0</code> 这句程序时，计算机会在内存里面找到一片存储空间（几个连续的存储单元），然后给该片存储空间取个名字叫 <code>Max</code>， 再把 <code>0</code> 这个初始值放在这个存储空间中来。<code>并记下这个名字（Max）和这片连续的存储空间的起始的地址之间的对应关系</code></p><p>定义： [存储类型]  数据类型  标识符 =  值 </p><p><code>TYPE NAME = VALUE;</code></p><p>存储类型 可选</p><h5 id="2-1-2-1-标识符"><a href="#2-1-2-1-标识符" class="headerlink" title="2.1.2.1 标识符"></a>2.1.2.1 标识符</h5><p>当定义一个某种类型的标识符的时候，编译器会为当前的值分配一块内存空间；如何称呼这块空间，就是<code>房间号</code>。房间号就是标识符。编译器会给标识符（房间号）和内存地址标识做关联。当搜索变量名的时候，编译器知道要去到哪块内存地址去搜索；简单说，标识符就是这块空间的临时别名；</p><h4 id="2-1-3-存储类型"><a href="#2-1-3-存储类型" class="headerlink" title="2.1.3 存储类型"></a>2.1.3 存储类型</h4><blockquote><p>auto, static register extern(说明型)</p></blockquote><h5 id="2-1-3-1-auto"><a href="#2-1-3-1-auto" class="headerlink" title="2.1.3.1 auto"></a>2.1.3.1 auto</h5><blockquote><p>默认，自动分配空间，自动回收空间</p></blockquote><p>auto类型分配在栈上，堆主要是来进行动态内存分配的空间；堆栈不挨着</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">int</span> i; <span class="comment">// 原则上不会 对 i所在这块空间进行初始化</span></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i); <span class="comment">// 随机的结果，当然有的编译器会置为0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"j= %d\n"</span>, j); <span class="comment">// 0  编译器会初始化为0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x =<span class="number">0</span>;</span><br><span class="line">  x = x+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffee6b3c928-&gt;1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明： 这三个地址未必一致，但一致的原因是 auto类型的变量都存放在栈上，栈上的空间按正常理论来讲，它实际上是连续分配的。而当前x在  func函数被调用的时候，它才会被产生。然后在当前函数执行结束的时候，这块空间被释放掉了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="2-1-3-2-register"><a href="#2-1-3-2-register" class="headerlink" title="2.1.3.2 register"></a>2.1.3.2 register</h5><blockquote><p>建议型关键字；</p></blockquote><p>寄存器类型，资源少，速度快，寄存器存放在CPU当中，寄存器的数据比较吃紧，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i =<span class="number">1</span>; <span class="comment">// 除非i在程序中，超高频率被使用，才建议编译器将i分配到寄存器中；至于有没有被放到寄存器中，由gcc来决定；</span></span><br></pre></td></tr></table></figure><p><strong>register的苛刻条件；</strong></p><ol><li>只能定义局部变量，不能定义全局变量；</li><li>大小有限制，只能定义 32 位大小的数据类型，如double 就不可以</li><li>寄存器中没有地址，所以一个寄存器类型变量无法打印出地址查看或者使用；</li></ol><h5 id="2-1-3-3-static"><a href="#2-1-3-3-static" class="headerlink" title="2.1.3.3 static"></a>2.1.3.3 static</h5><blockquote><p>静态型，自动初始化为0值或空值，并值其变量的值有继承性（继承性指的的static在内存中只此一份，所以下次使用的时候还是基于上一次的值，而不会被初始化）。另外，常用于修饰变量或函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x =<span class="number">0</span>;</span><br><span class="line">  x = x+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;1</span></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;2</span></span><br><span class="line"><span class="comment">// 0x10c4b1018-&gt;3</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明： static类型的变量，只用一块空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>static 修饰函数：</strong></p><p>防止该函数对外扩展，（简单说就是该函数只能在当前文件下使用，在别的文件下没法使用；）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello func"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_func</span><span class="params">()</span>  <span class="comment">// 外界可以通过 call_func 这个桥梁函数来引用 func</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说全局变量都要修饰成static，防止跟别的.c文件中同名变量冲突。然后用static来修饰函数，为的是强调当前函数不可外扩，（该函数只能在当前文件使用，别的文件下没法使用）</p><h5 id="2-1-3-4-extern"><a href="#2-1-3-4-extern" class="headerlink" title="2.1.3.4 extern"></a>2.1.3.4 extern</h5><blockquote><p>说明型， 意味着不能改变被说明的变量的值或类型；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proj.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">  func();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proj.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proj.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">// 我的i不是自己定义的，是引用其他文件里面的i，编译器自己去找，extern不能改变声明的类型和值；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-变量的生命周期和作用范围（即作用域）"><a href="#2-1-4-变量的生命周期和作用范围（即作用域）" class="headerlink" title="2.1.4 变量的生命周期和作用范围（即作用域）"></a>2.1.4 变量的生命周期和作用范围（即作用域）</h4><ol><li>全局变量和局部变量</li><li>局部变量和局部变量</li><li>参考图片</li></ol><h2 id="3-C程序"><a href="#3-C程序" class="headerlink" title="3. C程序"></a>3. C程序</h2><h3 id="3-1-程序规范"><a href="#3-1-程序规范" class="headerlink" title="3.1 程序规范"></a>3.1 程序规范</h3><blockquote><p>以helleworld为例对写程序的思路提出如下要求:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void main(void);</span></span><br><span class="line"><span class="comment">//void main(int argc, char **argv); // char * argv[]</span></span><br><span class="line"><span class="comment">//int main(int argc, char **argv);</span></span><br><span class="line"><span class="comment">//int main(void);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello c!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>头文件正确包含的重要性；</li><li>知道程序中的所有警告<code>gcc file.c -Wall</code></li><li>如何调试段错误，先把程序中的所有警告调好；</li><li>以函数为单位来进行程序编写；</li><li>声明部分 和  实现部分（变量先定义，后使用）</li><li>return 0 （exit(0) 在单进程单线程的程序中 和 return 0意义一样的，exit(0)是给它父进程看的，当前main函数的父进程是shell）</li><li>多用空格空行</li><li>添加注释</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $? <span class="comment"># 上一条语句执行的状态</span></span><br></pre></td></tr></table></figure><h3 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h3><blockquote><p>#if #endif 注释</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(0)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3-编译"><a href="#3-3-编译" class="headerlink" title="3.3 编译"></a>3.3 编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gcc hello.c</span></span><br><span class="line">.c -&gt; .out</span><br></pre></td></tr></table></figure><p><strong>gcc过程(c源文件到可执行文件需要经过的顺序)</strong></p><p>c源文件 - 预处理 - 编译 - 汇编  - 链接 - 可执行文件</p><ul><li>预处理 <code>gcc -E hello.c &gt; hello.i</code> (预处理hello.c，保存至 hello.i 文件)<pre><code>以#开头的语句部分都是在预处理阶段解决掉的；`include`或者 `if define`</code></pre></li><li>编译阶段<code>gcc -S hello.i</code> (编译hello.i)<pre><code>默认会生成一个 .s文件，编译成汇编文件；</code></pre></li><li>汇编阶段<code>gcc -c hello.s</code><pre><code>生成一个 .o文件；</code></pre></li><li>链接阶段<code>gcc hello.o -o hello</code> (链接.o文件 生成可执行文件 hello)<pre><code>生成可执行文件hello;</code></pre></li></ul><h4 id="3-3-1-C编译"><a href="#3-3-1-C编译" class="headerlink" title="3.3.1 C编译"></a>3.3.1 C编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c  <span class="comment"># 把test.c 编译成一个可执行文件 test</span></span><br><span class="line">gcc hello.c -Wall   <span class="comment"># 显示编译警告，原则上编码过程当中把程序调到没有警告为止；</span></span><br><span class="line">./<span class="built_in">test</span>              <span class="comment"># 执行 test</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-多个-c文件"><a href="#3-3-2-多个-c文件" class="headerlink" title="3.3.2 多个.c文件"></a>3.3.2 多个.c文件</h4><ul><li>main() 里的代码太长了 适合分成几个函数</li><li>一个源文件太长适合分成几个文件</li><li>两个独立的源文件不能编译形成可执行的程序</li></ul><h4 id="3-3-3-头文件"><a href="#3-3-3-头文件" class="headerlink" title="3.3.3 头文件"></a>3.3.3 头文件</h4><blockquote><p>把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件(.c文件)中  #include 这个头文件，就能让编译器在编译的时候知道函数的原型</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.c  max.c  max.h</span></span><br><span class="line">gcc  main.c  max.c</span><br></pre></td></tr></table></figure><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h2><ul><li>不同数据类型所占字节数</li><li>存储区别</li><li>不同类型的数据间转换</li><li>特殊性：</li></ul><h3 id="4-1-基本类型"><a href="#4-1-基本类型" class="headerlink" title="4.1 基本类型"></a>4.1 基本类型</h3><ul><li>数值类型 <ul><li>整型<ul><li>短整型 short   （2个字节，16位）</li><li>整型 int      （4个字节，32位）</li><li>长整型 long    （4个字节，32位）</li></ul></li><li>浮点型<ul><li>单精度型 float   （4个字节，32位）</li><li>双精度型 double    （8个字节，64位）</li></ul></li></ul></li><li>字符类型 char           （1个字节，8位）</li></ul><h4 id="4-1-1-整形存储"><a href="#4-1-1-整形存储" class="headerlink" title="4.1.1 整形存储"></a>4.1.1 整形存储</h4><p><strong>整型的存储都是以补码的形势来存储的</strong></p><p>补码：正数的补码是它二进制本身，负数的补码是它绝对值的那个数的二进制形式取反再加1的结果；</p><p>254 -&gt; unsigned int(无符号 int) -&gt; 32位</p><p>-254 -&gt; 254-&gt; 1111 1110 取反 +1  </p><ul><li>有无符号的区别，最高位到底代表是符号还是正常有效值；有符号的话，为0表示正数，为1表示负数；</li></ul><p>(254)10 =&gt; (11111110)2</p><p>方法： 除2取余倒序排列；（转2进制）11111110</p><pre><code>除8取余倒序排列；（转8进制）376除16取余倒序排列；（转16进制） FE</code></pre><p><strong>进制表示</strong></p><ul><li>254                 十进制</li><li>B11111110    二进制</li><li>0376               八进制</li><li>0xFE               十六进制</li></ul><h4 id="4-1-2-浮点型存储"><a href="#4-1-2-浮点型存储" class="headerlink" title="4.1.2  浮点型存储"></a>4.1.2  浮点型存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span> * <span class="number">10</span>^<span class="number">0</span></span><br><span class="line"><span class="number">0.314</span> * <span class="number">10</span>^<span class="number">1</span></span><br><span class="line"><span class="number">0.0314</span> * <span class="number">10</span>^<span class="number">2</span></span><br><span class="line"><span class="number">314</span> * <span class="number">10</span>^<span class="number">-2</span></span><br></pre></td></tr></table></figure><p><strong>浮点数是以0.314 * 10^1的方式来存储3.14的</strong></p><p><code>整数部分为0，只是在意精度部分是多少。然后在意指数部分是多少。</code></p><ul><li>浮点数在32 个bit上是如何存放的<br>0～22位（共23个bit）用来记录精度部分。 22位～30位（共8个bit） 用来存储的是指数部分。最高位（第31位） 表示的是符号位置，表示是正数还是负数；</li></ul><p><strong>举例</strong></p><p>0.000789 -&gt; 0.789 -&gt; 10^3</p><p><code>精度部分存储 789的二进制形式，8个位存储3</code></p><ul><li>float 32位</li><li>double 64位 ，比float多出来的32位完全放在精度的控制上</li></ul><h4 id="4-1-3-char存储"><a href="#4-1-3-char存储" class="headerlink" title="4.1.3 char存储"></a>4.1.3 char存储</h4><ul><li>char 8位。                    -128～127</li><li>unsigned char 8位。   0～255</li></ul><h4 id="4-1-4-不同类型的数据间转换"><a href="#4-1-4-不同类型的数据间转换" class="headerlink" title="4.1.4 不同类型的数据间转换"></a>4.1.4 不同类型的数据间转换</h4><h5 id="4-1-4-1-精度丢失"><a href="#4-1-4-1-精度丢失" class="headerlink" title="4.1.4.1 精度丢失"></a>4.1.4.1 精度丢失</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.9</span>;</span><br><span class="line"><span class="keyword">int</span> i = f; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h5 id="4-1-4-2-隐式转换"><a href="#4-1-4-2-隐式转换" class="headerlink" title="4.1.4.2 隐式转换"></a>4.1.4.2 隐式转换</h5><p><strong>编译器默认做的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">ch + i   --&gt; i  <span class="comment">// 默认往精度高，或者所占字节长比较高的那一种数据类型去靠拢的</span></span><br><span class="line">f -d     --&gt; d  <span class="comment">// 精度高的 double</span></span><br><span class="line">(ch + i) - (<span class="keyword">float</span> - <span class="keyword">double</span>) --&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><h5 id="4-1-4-3-显式转换"><a href="#4-1-4-3-显式转换" class="headerlink" title="4.1.4.3 显式转换"></a>4.1.4.3 显式转换</h5><p><strong>强制类型转换</strong></p><h5 id="4-1-4-4-特殊性："><a href="#4-1-4-4-特殊性：" class="headerlink" title="4.1.4.4 特殊性："></a>4.1.4.4 特殊性：</h5><ol><li>布尔型bool</li><li>float类型； <code>1.0/3*3 ！= 1</code></li><li>char型是否有符号，不知道，一个未定义的行为</li><li>不同形式的0值；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="string">'0'</span>;</span><br><span class="line"><span class="string">"0"</span>;</span><br><span class="line"><span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾）</li></ol><h3 id="4-2-构造类型"><a href="#4-2-构造类型" class="headerlink" title="4.2 构造类型"></a>4.2 构造类型</h3><ul><li>数组</li><li>结构体 struct</li><li>共用体  union</li><li>枚举类型 enum</li></ul><h4 id="4-2-1-enum"><a href="#4-2-1-enum" class="headerlink" title="4.2.1  enum"></a>4.2.1  enum</h4><p>*<em>语法: *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum 标识符</span><br><span class="line">&#123;</span><br><span class="line">  成员1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> day</span><br><span class="line">&#123;</span><br><span class="line">  MON,  <span class="comment">//默认从0 开始往下排</span></span><br><span class="line">  TUS,</span><br><span class="line">  THR,</span><br><span class="line">  WES,</span><br><span class="line">  FRI = <span class="number">1</span>,  <span class="comment">// 如果给FRI赋值为1的话，那么接下来会从1继续排</span></span><br><span class="line">  SAT,</span><br><span class="line">  SUN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main () &#123;</span><br><span class="line">  <span class="keyword">enum</span> day a = FRI;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>把enum当宏使用: *</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    STATE_RUNNING = <span class="number">1</span>,</span><br><span class="line">    STATE_CANCELED,</span><br><span class="line">    STATE_OVER</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">char</span> start;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_st</span> <span class="title">job1</span>;</span></span><br><span class="line">   <span class="comment">// job1.state = STATE_CANCELED;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (job1.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_CANCELED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_OVER:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_RUNNING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 信号，操作系统后续会讲</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>这种场景可以用 enum代替宏的使用: *</em></p><p>因为宏经过预编译之后被替换掉了，宏的部分会被替换。影响调试。<br>当然enum不是万能，并不能替代宏；宏还可以传递参数</p><h4 id="4-2-2-结构体类型"><a href="#4-2-2-结构体类型" class="headerlink" title="4.2.2 结构体类型"></a>4.2.2 结构体类型</h4><ul><li>类型描述</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">  数据类型 成员<span class="number">1</span>;</span><br><span class="line">  数据类型 成员<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型嵌套</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">birthdata_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> year;</span><br><span class="line">  <span class="keyword">int</span> month;</span><br><span class="line">  <span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">birthday_st</span> <span class="title">birth</span>;</span> <span class="comment">// 嵌套定义</span></span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> chinese;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">birthdata_st</span>  // 嵌套定义</span></span><br><span class="line"><span class="class">  &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">  &#125;birth;</span><br><span class="line">  <span class="keyword">int</span> math;</span><br><span class="line">  <span class="keyword">int</span> chinese;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义变量（变量，数组，指针），初始化及成员引用；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span>  <span class="comment">// student 不是变量名而是类型</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>]</span><br><span class="line">  .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员引用：</p><p> <code>变量名.成员名</code></p><p><code>指针名-&gt;成员名</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="keyword">int</span> bigint;</span><br><span class="line">  <span class="keyword">float</span> mfloat;</span><br><span class="line">  <span class="keyword">char</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> <span class="title">a</span> = &#123;</span></span><br><span class="line">      <span class="number">123</span>,</span><br><span class="line">      <span class="number">456.789</span>,</span><br><span class="line">      <span class="string">'a'</span>&#125;;</span><br><span class="line"></span><br><span class="line">  a.bigint = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d, %f, %c\n"</span>, a.bigint, a.mfloat, a.name);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>定义结构体变量的方式: *</em></p><p><code>student tudent1,student2;</code><br>(结构体类型名) (结构体变量名)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>]</span><br><span class="line">  .....</span><br><span class="line">&#125; lige_1, lige_2;</span><br></pre></td></tr></table></figure><p>*<em>结构体赋值: *</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike2</span> = <span class="title">mike</span>;</span>  <span class="comment">// 结构体赋值相当于copy一份给对方</span></span><br><span class="line">    mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike2.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">        mike2.name[i] = <span class="built_in">toupper</span>(mike2.name[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike2.id_num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike2.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>结构体内存 *</em> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 看上去是10个字节，结果打印出来的是16个字节；</span></span><br><span class="line"><span class="comment">// 地址对齐， 结构体对齐的概念；</span></span><br></pre></td></tr></table></figure><ul><li>一个公式</li></ul><p>address（当前准备存储的变量的地址）%（你当前要存放变量的sizeOf）<br>如果能整除的话，那么这个变量就存放在这里，如果这个表达式不成立，那么address就得 + 1；</p><p>举例子说明,首先下面是一段内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">0</span><br><span class="line">----------</span><br><span class="line">1</span><br><span class="line">----------</span><br><span class="line">2</span><br><span class="line">----------</span><br><span class="line">3</span><br><span class="line">----------</span><br><span class="line">4</span><br><span class="line">----------</span><br><span class="line">5</span><br><span class="line">----------</span><br><span class="line">6</span><br><span class="line">----------</span><br><span class="line">7</span><br><span class="line">----------</span><br><span class="line">8</span><br><span class="line">----------</span><br><span class="line">9</span><br><span class="line">----------</span><br><span class="line">10</span><br><span class="line">----------</span><br><span class="line">11</span><br><span class="line">----------</span><br><span class="line">12</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>解释 *</em></p><p>首先内存第一个地址的值是0，结构体的第一个属性是int，我们知道int占4个字节。0/4 能整除，因此第一个int占据从0-3 这个几个内存中，然后 char占1个字节，4/1能整除，因此第二个char占据了4这个内存中。接着结构体第三个属性为float，占据4个字节。内存地址5/4没法整除，当前内存++，分别到6，7，都无法整除4.到了8，8/4能整除，所以，从8打11这一段内存就存放着float这个属性，接下来又是char12/1能整除，所以char属性占据了char12这个内存地址； </p><p><code>值得注意的是，不同的操作系统内存对齐的方式是不同的；因此在socket编程中，我们传过去的结构体数据在末端一定不能做对齐；因为不知道不同平台到底是什么字节对齐的</code></p><p>*<em>结构体对齐 *</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure><p>这个操作在网络编程当中很常用；</p><p>总结</p><p>如果没有内存对齐，就是指定<strong>attribute</strong>((packed))的话，那么结构体内存的大小就是各个属性的sizeof累加的结果。如果没加就需要考虑内存对齐的问题，不同的机器内存对齐的方式是不同的。因为在跨机器编程比如socket编程当中，是需要指定<strong>attribute</strong>((packed))来确保数据的完整性和 安全性；</p><h5 id="4-2-2-1-结构体作为函数参数传递给函数（值传递，地址传递）"><a href="#4-2-2-1-结构体作为函数参数传递给函数（值传递，地址传递）" class="headerlink" title="4.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）"></a>4.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span> <span class="params">(struct student mike)</span> </span>&#123;</span><br><span class="line">    mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">           mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    renew(mike);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="number">20130123</span></span><br><span class="line">#MIKE</span><br><span class="line">#<span class="number">123</span></span><br><span class="line"><span class="meta">#mike</span></span><br></pre></td></tr></table></figure><ul><li>结论</li></ul><p>结构体的传入是 值拷贝，函数内部执行的是副本</p><h5 id="4-2-2-2-当把结构体当成形参传递的时候，意味着什么"><a href="#4-2-2-2-当把结构体当成形参传递的时候，意味着什么" class="headerlink" title="4.2.2.2 当把结构体当成形参传递的时候，意味着什么"></a>4.2.2.2 当把结构体当成形参传递的时候，意味着什么</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(struct simp_st b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 内存总是要分配一个完整的 结构体 体积所占的空间用来接受这个形参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(b)); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">simp_st</span> *<span class="title">p</span> = &amp;<span class="title">a</span>;</span></span><br><span class="line">    func(a);</span><br><span class="line">    <span class="comment">// func(a.i, a.ch, a.f)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>小结： 所以我们一般不会这么去用。会有非常严重的性能浪费；一般我们会传递结构体指针；</li></ul><h5 id="4-2-2-3-结构体作为函数返回值时"><a href="#4-2-2-3-结构体作为函数返回值时" class="headerlink" title="4.2.2.3 结构体作为函数返回值时"></a>4.2.2.3 结构体作为函数返回值时</h5><p> 总结： 结构体作为函数返回值时，相当于copy一份给调用者</p><h5 id="4-2-2-4-指向结构体变量的指针"><a href="#4-2-2-4-指向结构体变量的指针" class="headerlink" title="4.2.2.4  指向结构体变量的指针"></a>4.2.2.4  指向结构体变量的指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> = &amp;<span class="title">mike</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*p).id_num);  <span class="comment">// 123</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 123   另外一种写法  -&gt; 指向运算符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// mike  另外一种写法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (*p).name);  <span class="comment">// mike</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-5-指向结构体变量的指针作为参数传入函数"><a href="#4-2-2-5-指向结构体变量的指针作为参数传入函数" class="headerlink" title="4.2.2.5 指向结构体变量的指针作为参数传入函数"></a>4.2.2.5 指向结构体变量的指针作为参数传入函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span> <span class="params">(struct student mike)</span> </span>&#123;</span><br><span class="line">   mike.id_num = <span class="number">20130000</span> + mike.id_num;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">          mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">mike</span> = &#123;</span><span class="number">123</span>, &#123;<span class="string">'m'</span>, <span class="string">'i'</span>, <span class="string">'k'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;&#125;;</span><br><span class="line">   renew(&amp;mike);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mike.id_num); <span class="comment">// 20130123    值被篡改</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, mike.name);  <span class="comment">// MIKE         值被篡改</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-6-结构体数组"><a href="#4-2-2-6-结构体数组" class="headerlink" title="4.2.2.6 结构体数组"></a>4.2.2.6 结构体数组</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">myclass</span>[3] =</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="number">123</span>, &#123;<span class="string">'m'</span>,<span class="string">'k'</span>,<span class="string">'k'</span>,<span class="string">'e'</span>&#125;,</span><br><span class="line">        <span class="number">133</span>, &#123;<span class="string">'j'</span>,<span class="string">'o'</span>,<span class="string">'y'</span>&#125;,</span><br><span class="line">        <span class="number">143</span>, &#123;<span class="string">'t'</span>,<span class="string">'o'</span>,<span class="string">'m'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> * <span class="title">p</span> = &amp;<span class="title">myclass</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 123 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// mkke</span></span><br><span class="line">    p++; <span class="comment">// 跳一个结构体 体积的内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;id_num);   <span class="comment">// 133</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p-&gt;name);     <span class="comment">// joy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-7-链表"><a href="#4-2-2-7-链表" class="headerlink" title="4.2.2.7 链表"></a>4.2.2.7 链表</h5><ul><li>动态地 申请内存空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pint = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);   <span class="comment">// 开辟一片内存存储空间并返回起始地址； </span></span><br><span class="line"><span class="keyword">delete</span> pint;  <span class="comment">// 释放掉指针所指向的内存空间；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">// 申请一个 4个整型小数组的空间；并返回起始地址；</span></span><br><span class="line"><span class="keyword">delete</span> [] pia; <span class="comment">// 开个方括号，指的是释放掉的是一个数组区域</span></span><br></pre></td></tr></table></figure><ul><li>动态地 建立链表节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    student *next;</span><br><span class="line">&#125;</span><br><span class="line">student *head;</span><br><span class="line">head = <span class="keyword">new</span> student;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-共用体"><a href="#4-2-3-共用体" class="headerlink" title="4.2.3 共用体"></a>4.2.3 共用体</h4><blockquote><p>共用体和结构体语法很像，但截然不同的是，结构体各个成员会占用不同的内存，结构体整体内存 &gt;= sizeof（所有属性）， 因为有内存缝隙的 概念，所以有时候会大一些；</p><p>而公用体的内存体积取决于最大属性的体积；共用体所有成员占据同一段内存；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来的值覆盖掉。</p><p>共用体是硬件稀缺时代的产物；结合实际场景，比如 checkbox 男女只能同时存在一个；</p></blockquote><p><strong>语法</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 共用体名 &#123;</span><br><span class="line">  成员列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型嵌套</li></ul><p>硬件存储分大小端的；</p><p>大端格式： 数据的低位保存在高地址中；</p><p>小端格式： 数据的低位保存在低地址中；</p><ul><li>定义变量（变量，数组，指针），初始化及成员引用 (变量名.成员 指针名-&gt;成员)</li><li>占用内存大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> test_un</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> test_un a;</span><br><span class="line">  a.f = <span class="number">345.678</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">// 8  验证多个成员共用一块空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, a.f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> unioz</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">  &#125; c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> unioz x;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>)); <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(x));      <span class="comment">// 48</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数传参（值，地址）</li><li>位域</li></ul><h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5. 类型转换"></a>5. 类型转换</h2><p>存储涉及到2进制，8进制，10进制，16进制。这几种进制之间的转换首先要区别开，如何去获得一个二进制</p><h3 id="5-1-十进制转二进制"><a href="#5-1-十进制转二进制" class="headerlink" title="5.1  十进制转二进制"></a>5.1  十进制转二进制</h3><blockquote><p>除2取余，余数倒序排列</p></blockquote><p>254 -&gt; unsigned int -&gt; 32位 （4个字节）</p><p>254（10进制）-&gt; 11111110 (2进制) -&gt; 376 (8进制) -&gt; FE(16进制)</p><p>c语言程序当中是不识别二进制的</p><p>254         默认10进制<br>B11111110   二进制<br>0376        八进制<br>0xFE        十六进制</p><h3 id="5-2-补码"><a href="#5-2-补码" class="headerlink" title="5.2 补码"></a>5.2 补码</h3><blockquote><p>一个正数的补码形式就是 它二进制本身,负数的补码是它绝对值的二进制形式取反 + 1</p></blockquote><p>254 -&gt; unsigned int -&gt; 32位<br>-254 -&gt; 254 -&gt; 1111 1110 取反 + 1</p><h2 id="6-运算符和表达式"><a href="#6-运算符和表达式" class="headerlink" title="6. 运算符和表达式"></a>6. 运算符和表达式</h2><p>表达式与语句的区别</p><ul><li>运算符部分：</li></ul><ol><li>每个运算符所需要的参与运算的操作个数</li><li>结合性</li><li>优先级</li><li>运算符的特殊性</li></ol><ul><li>% 要求 除数，被除数都是整型</li></ul><ol start="5"><li>位运算的重要性</li></ol><h3 id="8-1-自增和自减"><a href="#8-1-自增和自减" class="headerlink" title="8.1 自增和自减"></a>8.1 自增和自减</h3><blockquote><p>运算符在前，先进行计算，再取变量值使用变量在前， 先取变量值使用，再进行计算</p></blockquote><h2 id="7-位运算"><a href="#7-位运算" class="headerlink" title="7. 位运算"></a>7. 位运算</h2><h3 id="3-1-gt-gt-lt-lt"><a href="#3-1-gt-gt-lt-lt" class="headerlink" title="3.1  &gt;&gt; &lt;&lt;"></a>3.1  &gt;&gt; &lt;&lt;</h3><blockquote><p>位运算（左移右移）基本等同于乘2除2运算,像汇编当中乘以多少，除以多少，几乎按这种方式来实现的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100 = <span class="number">12</span></span><br><span class="line">~i -&gt; B0011  <span class="comment">// 取反</span></span><br><span class="line"><span class="comment">// 把i往右移一位，1100  变成 110， 转化为10进制就是12</span></span><br><span class="line">i &gt;&gt; <span class="number">1</span>  --&gt; <span class="number">110</span> = <span class="number">6</span>  </span><br><span class="line"><span class="comment">// 把i往左移一位， 1100变成11000， 转化为10进制就是24</span></span><br><span class="line">i &lt;&lt; <span class="number">1</span> --&gt; <span class="number">11000</span> = <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="3-2-（取反）"><a href="#3-2-（取反）" class="headerlink" title="3.2  ~ （取反）"></a>3.2  ~ （取反）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100 = <span class="number">12</span></span><br><span class="line">~i -&gt; B0011  <span class="comment">// 取反</span></span><br></pre></td></tr></table></figure><h3 id="3-3-按位或"><a href="#3-3-按位或" class="headerlink" title="3.3  按位或"></a>3.3  按位或</h3><blockquote><p>按位或的计算原则是，同一个位上，两者有一者为1就为真，两者都为假才为假</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i|j</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">｜ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">   <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1101</span> -&gt; <span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="3-4-按位与"><a href="#3-4-按位与" class="headerlink" title="3.4  按位与"></a>3.4  按位与</h3><blockquote><p>按位与的计算原则是，同一个位上，两者有都为1就为真，否则为假</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i&amp;j</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">&amp; <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="3-5-相同为0，-不同为1"><a href="#3-5-相同为0，-不同为1" class="headerlink" title="3.5  ^ (相同为0， 不同为1)"></a>3.5  ^ (相同为0， 不同为1)</h3><blockquote><p>亦或计算原则， 同一个位上，相同为0， 不同为1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = B1100;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i^j</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">^ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="3-6-位运算的重要意义"><a href="#3-6-位运算的重要意义" class="headerlink" title="3.6  位运算的重要意义"></a>3.6  位运算的重要意义</h3><ul><li>将操作数中第N位 置1， 其他位不变；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num = num | 1 &lt;&lt; n // 把某一位 置1的话，把1左移 N个位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如将i 的第二位 置1</span></span><br><span class="line"><span class="keyword">int</span> i = B1011;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i = i | i &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">| <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>   <span class="comment">// 注意是把 1 左移动 N个位。 1  -&gt;  0100  空位补0</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>将操作数中第N位 清0， 其他位不变；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num = num &amp; ~(1 &lt;&lt; n) // 把某一位 置1的话，把1左移 N个位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如将i 的第1位 置0</span></span><br><span class="line"><span class="keyword">int</span> i = B1011;</span><br><span class="line"><span class="keyword">int</span> j = B1001;</span><br><span class="line"></span><br><span class="line">i = i | i &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">| <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   <span class="comment">// -&gt; 把1左移N位取反</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li><p>测试第n位： if (num &amp; i 1 &lt;&lt; n)</p></li><li><p>从一个指定宽度的数中取出其中的某几位 （练习题）</p></li></ul><h2 id="8-内核代码位置"><a href="#8-内核代码位置" class="headerlink" title="8.  内核代码位置"></a>8.  内核代码位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /linux/include/linux</span><br><span class="line">vim list.h</span><br></pre></td></tr></table></figure><h2 id="9-宏"><a href="#9-宏" class="headerlink" title="9.  宏"></a>9.  宏</h2><ul><li>#开头的是编译预处理指令</li><li>它们不是C语言的成分，但是C语言程序离不开它们</li><li>#define 用来定义一个宏；</li><li>define (定义一个宏)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(<span class="string">"%d\n"</span>, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言程序在编译之前，会做一次编译预处理；</span></span><br><span class="line"><span class="comment">// 会把程序中所有的PI都替换成 3.14159</span></span><br></pre></td></tr></table></figure><h3 id="4-1-save-temps"><a href="#4-1-save-temps" class="headerlink" title="4.1 save-temps"></a>4.1 save-temps</h3><p>对一个 .c 文件执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 02.c --save-temps</span><br></pre></td></tr></table></figure><p>生成 四个文件</p><p><code>02.i</code><br><code>02.s</code><br><code>02.o</code><br><code>a.out</code></p><p>过程依次是</p><p><code>.c -&gt; .i -&gt; .s -&gt; .o -&gt; a.out</code></p><p>.c是源代码，经过编译预处理之后变成 .i 这种中间结果文件，<br>当中所有编译预处理指令都执行完，比如 define 宏需要替换掉;<br>然后由于编译器对 .i文件进行编译 生成汇编代码 .s文件；<br>然后汇编代码文件，进行汇编变成目标文件， 目标文件再经过链接<br>之后形成一个可执行的东西；</p><ul><li>查看 .i 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail  03.i</span><br><span class="line">tail -n 50 03.i <span class="comment"># 看03.i文件 最后 50行</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"># <span class="number">943</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">3</span> <span class="string">"03.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">2</span>*<span class="number">3.1415927</span>*<span class="number">3.0</span>); <span class="comment">// 这里明显把宏替换成了值；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 同样的可以把 “%f\n” 也替换成宏**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(FORMATTER, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-宏的缺点"><a href="#4-2-宏的缺点" class="headerlink" title="4.2 宏的缺点"></a>4.2 宏的缺点</h3><blockquote><p>不检查语法，在预处理或者编译阶段是不报错的；</p></blockquote><h3 id="4-3-define"><a href="#4-3-define" class="headerlink" title="4.3 define"></a>4.3 define</h3><ul><li>#define &lt;名字&gt; &lt;值&gt;</li><li>结尾没有 分号，因为不是C的语句</li><li>名字必须是一个单词，值可以是各种东西</li><li>在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值；</li><li>完全的文本替换</li><li>gcc –save-temps</li><li>如果一个宏的值中有其他的宏的名字，也是会被替换的</li><li>如果一个宏的值超过一行，最后一行之前的行末需要加\</li><li>宏的值后面出现的注释不会被当作宏的一部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159        <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI          <span class="comment">// PI * 2</span></span></span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prinft(FORMATTER, <span class="number">2</span>*PI*<span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159        <span class="comment">//  指定义了一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMATTER <span class="meta-string">"%f\n"</span>  <span class="comment">// 指定一个FORMATTER 宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI2 2*PI          <span class="comment">// PI * 2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRT printf(<span class="meta-string">"%f"</span>, PI)\</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI2)</span><br><span class="line"><span class="comment">// PI 是这个宏的名字， 3.14159是这个宏的值；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PRT;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-没有值的宏"><a href="#4-4-没有值的宏" class="headerlink" title="4.4 没有值的宏"></a>4.4 没有值的宏</h3><ul><li>#define_DEBUG</li><li>这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了；</li></ul><h3 id="4-5-预定义的宏"><a href="#4-5-预定义的宏" class="headerlink" title="4.5 预定义的宏"></a>4.5 预定义的宏</h3><blockquote><p>用来表示一些特殊的东西，可以让编译器替我们插入一些特殊的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_LINE_     <span class="comment">//这个源代码所在当前的行号；</span></span><br><span class="line">_FILE_     <span class="comment">// 源代码的文件名</span></span><br><span class="line">_DATE_     <span class="comment">// 编译时候的日期</span></span><br><span class="line">_TIME_     <span class="comment">// 编译时候的时间</span></span><br><span class="line">_STDC_</span><br></pre></td></tr></table></figure><h3 id="4-6-像函数的宏"><a href="#4-6-像函数的宏" class="headerlink" title="4.6 像函数的宏"></a>4.6 像函数的宏</h3><p><code>#define cube(x) ((x)*(x)*(x))</code></p><p>宏可以带参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cube(x) ((x)*(x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cube(<span class="number">5</span>));  <span class="comment">// 125</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 .i 文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((<span class="number">5</span>)*(<span class="number">5</span>)*(<span class="number">5</span>)));  <span class="comment">// 被预处理成这样了；</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">2</span>*<span class="number">3.1415927</span>*<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-错误定义的宏"><a href="#4-7-错误定义的宏" class="headerlink" title="4.7 错误定义的宏"></a>4.7 错误定义的宏</h3><p><code>#define RADTODEG(x) (x*57.29578)</code><br><code>#define RADTODEG(x) (x)*57.29578</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADTODEG(x) (x*57.29578)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADTODEG(x) (x)*57.29578</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, RADTODEG(<span class="number">5</span>+<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">180</span>/RADTODEG2(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被预处理的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, (<span class="number">5</span>+<span class="number">2</span> * <span class="number">57.29578</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">180</span>/<span class="number">1</span>*<span class="number">57.29678</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 被预处理的结果是不符合我们的要求的；</p><h3 id="4-8带参数的宏的原则"><a href="#4-8带参数的宏的原则" class="headerlink" title="4.8带参数的宏的原则"></a>4.8带参数的宏的原则</h3><ul><li><p>一切都要有括号</p><ul><li>整个值要有括号，指的是整个宏的值有括号</li><li>参数出现的每个地方都要括号 </li></ul></li><li><p>#define RADTODEG(x) ((x)*57.29578)</p></li><li><p>可以带多个参数</p><ul><li>#define MIN((a,b) ((a)&gt;(b)?(b):(a))</li></ul></li><li><p>也可以组合（嵌套）使用其他宏</p></li><li><p>在大型程序的代码中使用非常普遍</p></li><li><p>可以非常复杂，如“产生”函数</p><ul><li>在# 和 ## 这两个运算符的帮助下</li></ul></li><li><p>存在中西方文化差异</p></li><li><p>部分宏会被inline函数替代 </p></li></ul><h3 id="4-9-什么时候用宏-什么时候用函数"><a href="#4-9-什么时候用宏-什么时候用函数" class="headerlink" title="4.9 什么时候用宏 什么时候用函数"></a>4.9 什么时候用宏 什么时候用函数</h3><p>应用求稳定，用函数<br>追求极致性能，用宏</p><h3 id="4-10-include-“”-还是-lt-gt"><a href="#4-10-include-“”-还是-lt-gt" class="headerlink" title="4.10 include  “” 还是 &lt;&gt;"></a>4.10 include  “” 还是 &lt;&gt;</h3><p>include 做了什么？</p><blockquote><p>include就是把头文件里头所有的文本插入到include所在.c文件的那一行.</p></blockquote><ul><li>#include有两种形式来指出要插入的文件<ul><li>“”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找</li><li>&lt;&gt; 让编译器只在指定的目录去找</li></ul></li><li>编译器自己知道自己的标准库的头文件在哪里</li><li>环境变量和编译器命令行参数也可以指定寻找头文件的目录</li></ul><h3 id="4-11-头文件-（-h文件）"><a href="#4-11-头文件-（-h文件）" class="headerlink" title="4.11 头文件 （.h文件）"></a>4.11 头文件 （.h文件）</h3><ul><li>在使用和定义这个函数的地方都应该 #include 这个头文件</li><li>一般的做法就是任何.c都有对应的同名的.h,把所有对外公开的函数的原型和全局变量的声明都放进去</li><li>在函数前面加上static 就使得它成为只能在所在的编译单元中被使用的函数</li><li>在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量</li></ul><h3 id="4-12-变量的声明"><a href="#4-12-变量的声明" class="headerlink" title="4.12 变量的声明"></a>4.12 变量的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> gAll;   <span class="comment">// 全局声明一个 变量</span></span><br></pre></td></tr></table></figure><ul><li>int i； 是变量的定义</li><li>extern int i； 是变量的声明</li></ul><h3 id="4-13声明和定义"><a href="#4-13声明和定义" class="headerlink" title="4.13声明和定义"></a>4.13声明和定义</h3><ul><li>声明是不产生的代码的东西<ul><li>函数原型</li><li>变量声明</li><li>结构声明</li><li>宏声明</li><li>枚举声明</li><li>类型声明</li><li>inline函数</li></ul></li><li>定义是产生代码的东西</li></ul><h2 id="10-typedef"><a href="#10-typedef" class="headerlink" title="10. typedef"></a>10. typedef</h2><blockquote><p>为已有的数据类型改名</p></blockquote><p><code>typedef  已有的数据类型 新名字;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  INT i;</span><br><span class="line">  <span class="built_in">printf</span>(D, i); </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-typedef-和-define的区别"><a href="#5-1-typedef-和-define的区别" class="headerlink" title="5.1  typedef 和 define的区别"></a>5.1  typedef 和 define的区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *IP;</span><br><span class="line"></span><br><span class="line">IP p,q  --&gt; <span class="keyword">int</span> *p, q;</span><br><span class="line">IP p,q  --&gt; <span class="keyword">int</span> *p, *q;</span><br></pre></td></tr></table></figure><p>** 更多示例** </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ARR[<span class="number">6</span>];    ---&gt; <span class="keyword">int</span> [<span class="number">6</span>] -&gt; ARR;</span><br><span class="line">ARR a; --&gt; <span class="keyword">int</span> a[<span class="number">6</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> <span class="title">NODE</span>;</span></span><br><span class="line">NODE a; --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> <span class="title">a</span>;</span></span><br><span class="line">NODE *p; --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">NODEP</span>;</span></span><br><span class="line">NODEP p --&gt; <span class="class"><span class="keyword">struct</span> <span class="title">node_st</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;NODE, *NODEP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">FUNC</span><span class="params">(<span class="keyword">int</span>)</span></span>; --&gt; <span class="keyword">int</span>(<span class="keyword">int</span>)  FUNC;</span><br><span class="line">FUNC f; --&gt; <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> *<span class="title">FUNCP</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">FUNCP p; ---&gt;  <span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *(*FUNCP)(<span class="keyword">int</span>);</span><br><span class="line">FUNCP p; ---&gt; <span class="keyword">int</span> *(*p)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>类型      数组名[常量表达式]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>    sheep[<span class="number">10</span>]</span><br><span class="line"><span class="keyword">int</span>      a2001[<span class="number">1000</span>]</span><br></pre></td></tr></table></figure><h2 id="11-一唯数组"><a href="#11-一唯数组" class="headerlink" title="11.  一唯数组"></a>11.  一唯数组</h2><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h3><p>  【存储类型】 数据类型 标识符 【下标】</p><h3 id="1-1-2-初始化"><a href="#1-1-2-初始化" class="headerlink" title="1.1.2 初始化"></a>1.1.2 初始化</h3><p>不初始化<br>全部初始化<br>部分初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">// 不给长度也行</span></span><br><span class="line">  <span class="keyword">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;   <span class="comment">// [1,2,0,0]   部分元素初始化</span></span><br><span class="line">  <span class="keyword">int</span> c[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;   <span class="comment">// [0,0,0,0]     部分元素初始化</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;  <span class="comment">// compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-3-元素引用"><a href="#1-1-3-元素引用" class="headerlink" title="1.1.3 元素引用"></a>1.1.3 元素引用</h3><p>  数组名【下标】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arr[M];</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">      <span class="keyword">for</span>(; i&lt;M; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;arr[i], arr[i]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x7ffee4394940-&gt;-466007712</span></span><br><span class="line"><span class="comment">// 0x7ffee4394944-&gt;32766</span></span><br><span class="line"><span class="comment">// 0x7ffee4394948-&gt;201064485</span></span><br></pre></td></tr></table></figure><ul><li><p>下标</p><p>查找块</p></li></ul><h3 id="1-1-4-数组名"><a href="#1-1-4-数组名" class="headerlink" title="1.1.4 数组名"></a>1.1.4 数组名</h3><blockquote><p>当前数组的起始位置，数组名本身就是表示地址的一个常量。</p></blockquote><p>常量： 程序执行过程当中不会发生变化的量；正因为数组名是常量，所以它不能无条件出现在数组的左边；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arr[M] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      arr[M] = &#123;<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 语法错误，数组名是常量，无法被直接赋值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">      <span class="keyword">for</span>(; i&lt;M; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%p-&gt;%d\n"</span>, &amp;arr[i], arr[i]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-5-数组越界"><a href="#1-1-5-数组越界" class="headerlink" title="1.1.5 数组越界"></a>1.1.5 数组越界</h3><blockquote><p>溢出数组所在内存区域</p></blockquote><h4 id="1-1-6-fb"><a href="#1-1-6-fb" class="headerlink" title="1.1.6 fb"></a>1.1.6 fb</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fib[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">2</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">         fib[i] = fib[i<span class="number">-1</span>] + fib[i<span class="number">-2</span>];</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fb加个排序</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fib[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> j;</span><br><span class="line">     <span class="keyword">int</span> tmp;</span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">2</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">         fib[i] = fib[i<span class="number">-1</span>] + fib[i<span class="number">-2</span>];</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">     i=<span class="number">0</span>;</span><br><span class="line">     j=<span class="keyword">sizeof</span>(fib)/<span class="keyword">sizeof</span>(fib[<span class="number">0</span>]) <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">     &#123;</span><br><span class="line">         tmp = fib[i];</span><br><span class="line">         fib[i] = fib[j];</span><br><span class="line">         fib[j] = tmp;</span><br><span class="line">         i++;</span><br><span class="line">         j--;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fib[i]);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="12-二维数组"><a href="#12-二维数组" class="headerlink" title="12.  二维数组"></a>12.  二维数组</h2><h3 id="1-2-1-定义，初始化"><a href="#1-2-1-定义，初始化" class="headerlink" title="1.2.1 定义，初始化"></a>1.2.1 定义，初始化</h3><p>   【存储类型】  数据类型   标识符  【行下标】 【列下标】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> b[][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[M][N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-二维数组元素引用"><a href="#1-2-2-二维数组元素引用" class="headerlink" title="1.2.2 二维数组元素引用"></a>1.2.2 二维数组元素引用</h3><p>数组名[行标][列标]<br>int a[3][4]   // 定一个三行四列的二维数组</p><h3 id="1-2-3-存储形式"><a href="#1-2-3-存储形式" class="headerlink" title="1.2.3 存储形式"></a>1.2.3 存储形式</h3><blockquote><p>顺序存储，按行存储,二维数组在内存中的存储， 是拉平的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">a[0][0]</span><br><span class="line">----------</span><br><span class="line">a[0][1]</span><br><span class="line">----------</span><br><span class="line">a[0][2]</span><br><span class="line">----------</span><br><span class="line">a[0][3]</span><br><span class="line">----------</span><br><span class="line">a[1][0]</span><br><span class="line">----------</span><br><span class="line">a[1][1]</span><br><span class="line">----------</span><br><span class="line">a[1][2]</span><br><span class="line">----------</span><br><span class="line">a[1][3]</span><br><span class="line">----------</span><br><span class="line">a[2][0]</span><br><span class="line">----------</span><br><span class="line">a[2][1]</span><br><span class="line">----------</span><br><span class="line">a[2][2]</span><br><span class="line">----------</span><br><span class="line">a[2][3]</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><ol><li>深入理解二维数组</li></ol><table><thead><tr><th>1 a[0][0]</th><th>2 a[0][1]</th><th>3 a[0][2]</th><th>4 a[0][3]</th></tr></thead><tbody><tr><td>5 a[1][0]</td><td>6 a[1][1]</td><td>7 a[1][2]</td><td>8 a[1][3]</td></tr><tr><td>9 a[2][0]</td><td>10 a[2][1]</td><td>11 a[2][2]</td><td>12 a[2][3]</td></tr></tbody></table><h3 id="1-2-4-二维数组练习题"><a href="#1-2-4-二维数组练习题" class="headerlink" title="1.2.4 二维数组练习题"></a>1.2.4 二维数组练习题</h3><h4 id="1-2-4-1-行列互换"><a href="#1-2-4-1-行列互换" class="headerlink" title="1.2.4.1 行列互换"></a>1.2.4.1 行列互换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N][M];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[j][i] = arr[i][j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-2-求最大值及其所在位置"><a href="#1-2-4-2-求最大值及其所在位置" class="headerlink" title="1.2.4.2 求最大值及其所在位置"></a>1.2.4.2 求最大值及其所在位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">max</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[M][N] = &#123;<span class="number">43</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">89</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>][<span class="number">0</span>], row =<span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]&gt;<span class="built_in">max</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">max</span>= a[i][j];</span><br><span class="line">               row = i;</span><br><span class="line">               col = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">max</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d --- %d\n"</span>, row, col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N][M];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">max</span>();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-3-求各行与各列的和"><a href="#1-2-4-3-求各行与各列的和" class="headerlink" title="1.2.4.3 求各行与各列的和"></a>1.2.4.3 求各行与各列的和</h4><p><img src="./2_arr.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sum</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[<span class="number">4</span>][<span class="number">3</span>] += a[i][j];</span><br><span class="line">            a[<span class="number">4</span>][j] += a[i][j];</span><br><span class="line">            a[i][<span class="number">3</span>] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-4-矩阵乘积"><a href="#1-2-4-4-矩阵乘积" class="headerlink" title="1.2.4.4 矩阵乘积"></a>1.2.4.4 矩阵乘积</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 2</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; ;</span><br><span class="line">     <span class="keyword">int</span> b[N][K]= &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> c[M][K];</span><br><span class="line">     <span class="keyword">int</span> i,j,k;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;N; k++)</span><br><span class="line">             &#123;</span><br><span class="line">                 c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%4d"</span>,c[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     mul();</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-5-深入理解二维数组"><a href="#1-2-5-深入理解二维数组" class="headerlink" title="1.2.5 深入理解二维数组"></a>1.2.5 深入理解二维数组</h3><p><img src="./arr_2.png" alt=""></p><h4 id="1-2-5-1-三维数组"><a href="#1-2-5-1-三维数组" class="headerlink" title="1.2.5.1 三维数组"></a>1.2.5.1 三维数组</h4><p>a[5][3][4]    数据立方体  </p><p>5 -&gt; 片<br>3 -&gt; 行<br>4 -&gt; 列</p><p>在内存中依然是打平存放；</p><h2 id="13-字符数组"><a href="#13-字符数组" class="headerlink" title="13. 字符数组"></a>13. 字符数组</h2><h3 id="1-3-1-定义，初始化，存储特点"><a href="#1-3-1-定义，初始化，存储特点" class="headerlink" title="1.3.1 定义，初始化，存储特点"></a>1.3.1 定义，初始化，存储特点</h3><p> 【存储类型】 数据类型  标识符 【下标】。。。</p><h4 id="1-3-1-1-单个字符初始化"><a href="#1-3-1-1-单个字符初始化" class="headerlink" title="1.3.1.1 单个字符初始化"></a>1.3.1.1 单个字符初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br></pre></td></tr></table></figure><p>char c[] = {‘C’, ‘h’, ‘i’, ‘n’, ‘a’};<br>// c[0] = C   c[1] = h  c[2]= i  c[3]=n  c[4]=a</p><h4 id="1-3-1-2-用字符串常量初始化"><a href="#1-3-1-2-用字符串常量初始化" class="headerlink" title="1.3.1.2 用字符串常量初始化"></a>1.3.1.2 用字符串常量初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">6</span>] = <span class="string">"hello"</span>;  <span class="comment">// 最后一位 以 '\0' 结尾</span></span><br></pre></td></tr></table></figure><p>char c[] = “China”<br>// c[0] = C   c[1] = h  c[2]= i  c[3]=n  c[4]=a  c[5]=\0</p><h3 id="1-3-2-输入输出"><a href="#1-3-2-输入输出" class="headerlink" title="1.3.2 输入输出"></a>1.3.2 输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[N], str1[N], str2[N];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>, str, str1,str2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n%s\n%s\n"</span>, str, str1,str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// how are you</span></span><br><span class="line"><span class="comment">// how</span></span><br><span class="line"><span class="comment">// are</span></span><br><span class="line"><span class="comment">// you</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-1-单词计数"><a href="#1-3-2-1-单词计数" class="headerlink" title="1.3.2.1 单词计数"></a>1.3.2.1 单词计数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">     <span class="keyword">int</span> count =<span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     gets(str);</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">             flag = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 count++;</span><br><span class="line">                 flag=<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"count = %d\n"</span>, count);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-字符数组注意事项"><a href="#1-3-3-字符数组注意事项" class="headerlink" title="1.3.3 字符数组注意事项"></a>1.3.3 字符数组注意事项</h3><blockquote><p>所有字符串都是以  \0 来结尾的；所有以 \0结尾 的字符数组都可以被看为字符串</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>] = <span class="string">"China"</span>; <span class="comment">//只可以在数组定义并初始化的时候</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用赋值语句将一个字符串常量或字符数组直接赋给另一个字符数组</span></span><br><span class="line">str1[] = <span class="string">"China"</span>   <span class="comment">// 赋值，不合法</span></span><br><span class="line">str1 = <span class="string">"China"</span>     <span class="comment">// 赋值，不合法</span></span><br><span class="line">str2 = str1        <span class="comment">// 赋值，不合法</span></span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol><li>变量与地址</li><li>指针与指针变量</li><li>直接访问与间接访问</li><li>空指针与野指针</li><li>空类型指针</li><li>定义，初始化，书写规则</li><li>指针运算</li><li>指针与数组<ol><li>指针与一维数组</li><li>指针与二维数组</li><li>指针与字符数组</li></ol></li><li>const与指针</li><li>指针数组和数组指针</li><li>多级指针</li></ol><h2 id="14-变量与地址"><a href="#14-变量与地址" class="headerlink" title="14. 变量与地址"></a>14. 变量与地址</h2><p>变量名： 变量名就是用户对某一块内存空间的抽象表示；想把这块儿内存置成100，就写<code>int i = 100;</code>变量名就是某个内存空间的别名；</p><p>地址： 指针就是地址，指针就是指向某个内存空间地址的地址值；</p><h3 id="1-1-变量的三要素"><a href="#1-1-变量的三要素" class="headerlink" title="1.1  变量的三要素"></a>1.1  变量的三要素</h3><p><code>int a = 3</code> 在内存中， 即产生 0x0012FF78，3，a 三个要素。</p><ol><li>0x0012FF78即变量的地址， 把这个变量的地址称为“指向该变量的指针”；</li><li>3即变量值；</li><li>a即变量的签名；</li></ol><h3 id="1-2-输出变量的地址"><a href="#1-2-输出变量的地址" class="headerlink" title="1.2  输出变量的地址"></a>1.2  输出变量的地址</h3><p>地址运算符 “&amp;” </p><p><code>int a = 3; printf(&quot;%x&quot;, &amp;a)</code></p><h2 id="15-指针与指针变量"><a href="#15-指针与指针变量" class="headerlink" title="15. 指针与指针变量"></a>15. 指针与指针变量</h2><p><strong>语法</strong></p><p><code>TYPE NAME = VALUE；</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;    <span class="comment">// type 为 int</span></span><br><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// type 为 int *, 而不是 int</span></span><br></pre></td></tr></table></figure><h3 id="2-1-非法操作（野指针）"><a href="#2-1-非法操作（野指针）" class="headerlink" title="2.1 非法操作（野指针）"></a>2.1 非法操作（野指针）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// 合法操作，指针一旦定义出来，就要给一个明确指向；没有的话，下回分解</span></span><br><span class="line"><span class="keyword">int</span> * p = <span class="number">0x7fffa37eac60</span>; <span class="comment">// 可能这个地址已经被占用了，一般情况下，是个非法操作；</span></span><br></pre></td></tr></table></figure><h3 id="2-2-指针变量"><a href="#2-2-指针变量" class="headerlink" title="2.2 指针变量"></a>2.2 指针变量</h3><blockquote><p>专门用于存放指针（某个变量的地址）的变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> * pointer;  <span class="comment">//定义名字为pointer的指针变量；只能存放地址！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int *pointer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) int 是指针变量的基类型  所谓基类型：指针变量指向的变量的类型</span></span><br><span class="line"><span class="comment">// 2) *   是指针运算符，表示pointer这个变量的类型</span></span><br><span class="line"><span class="comment">// 3) pointer   是指指针变量的名字</span></span><br><span class="line"></span><br><span class="line">pointer = &amp;c;</span><br><span class="line"><span class="comment">// 将变量c 的地址赋值给指针变量pointer；</span></span><br><span class="line"><span class="comment">// 赋值后，称指针变量pointer指向了变量c；</span></span><br></pre></td></tr></table></figure><p>则<code>*pointer</code>： 为pointer所指向的存储单元的内容；是变量c。<br>因此<code>*pointer</code>可以当作 变量c 来使用</p><h3 id="2-3-指针变量的地址"><a href="#2-3-指针变量的地址" class="headerlink" title="2.3 指针变量的地址"></a>2.3 指针变量的地址</h3><blockquote><p>指针变量也是变量，是变量就有地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(P, p);</span><br><span class="line">    <span class="built_in">printf</span>(P, &amp;p);   <span class="comment">// 指针变量也有地址；</span></span><br><span class="line"><span class="comment">// 0x7ffee6a26ac8</span></span><br><span class="line"><span class="comment">// 0x7ffee6a26ac0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-指针变量示例"><a href="#2-4-指针变量示例" class="headerlink" title="2.4 指针变量示例"></a>2.4 指针变量示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b=<span class="number">3</span>, temp;</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>, *p2 = <span class="literal">NULL</span>;</span><br><span class="line">    p1 = &amp;a;</span><br><span class="line">    p2 = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">if</span>(*p1 &lt; *p2) &#123;</span><br><span class="line">        temp = *p1; *p1 = *p2; *p2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p1);  <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p2);  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-指针作运算-取地址-和-取-和关系运算"><a href="#2-5-指针作运算-取地址-和-取-和关系运算" class="headerlink" title="2.5 指针作运算 (取地址 和 取 * 和关系运算)"></a>2.5 指针作运算 (取地址 和 取 * 和关系运算)</h3><p><img src="./point_01.png" alt=""></p><h4 id="2-5-1-取地址"><a href="#2-5-1-取地址" class="headerlink" title="2.5.1 取地址"></a>2.5.1 取地址</h4><blockquote><p>要获取某个变量在内存中的房间号</p></blockquote><h4 id="2-5-2-取"><a href="#2-5-2-取" class="headerlink" title="2.5.2 取*"></a>2.5.2 取*</h4><blockquote><p>找到现在给定房间号里面存放的内容</p></blockquote><h2 id="16-直接访问和间接访问"><a href="#16-直接访问和间接访问" class="headerlink" title="16. 直接访问和间接访问"></a>16. 直接访问和间接访问</h2><h3 id="3-1一级间接访问和-二级间接访问"><a href="#3-1一级间接访问和-二级间接访问" class="headerlink" title="3.1一级间接访问和 二级间接访问"></a>3.1一级间接访问和 二级间接访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">     <span class="keyword">int</span> **q = &amp;p;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(P, p); <span class="comment">// 0x7ffee92579b8</span></span><br><span class="line">     <span class="built_in">printf</span>(P, q); <span class="comment">// 0x7ffee92579b0</span></span><br><span class="line">     <span class="built_in">printf</span>(P, *q); <span class="comment">// 0x7ffee92579b8</span></span><br><span class="line"> printt(D, i); <span class="comment">// 1 直接访问</span></span><br><span class="line">     <span class="built_in">printf</span>(D, *p); <span class="comment">// 1  一级间接访问</span></span><br><span class="line">     <span class="built_in">printf</span>(D, **q);<span class="comment">// 1 二级间接访问</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-指针关系运算"><a href="#3-2-指针关系运算" class="headerlink" title="3.2 指针关系运算"></a>3.2 指针关系运算</h3><blockquote><p>当两个指针指向的是一块连续内存空间的时候， 比如两个指针指向同一个数组。在这种情况下，两个指针可以做一个关系上的比较；</p></blockquote><p><code>++ --</code></p><blockquote><p>++ – 运算实际上改变指针位置；</p></blockquote><h3 id="3-3-指针变量类型与指针变量大小"><a href="#3-3-指针变量类型与指针变量大小" class="headerlink" title="3.3  指针变量类型与指针变量大小"></a>3.3  指针变量类型与指针变量大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">float</span> *q;</span><br><span class="line"><span class="keyword">double</span> *d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(i)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(p)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(q)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">printf</span>(D, <span class="keyword">sizeof</span>(d)); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 结构体指针的大小也是8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">不管指针是多少级的指针，不管指针是什么样的类型。指针在某个平台下所占的地址空间是确定的。那既然如此为何 要给指针变量加类型呢，比如 int *p, float *q.</span></span><br><span class="line"><span class="comment">那是因为有 *p 取* 的操作，比如*q的时候，怎么就能知道去对应地址读取 4个字节呢？ 这个时候就要靠 指针变量的 变量类型加持了。所以这个变量类型之间的意义 就不尽相同了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * s;</span><br><span class="line">s = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(D, *s); <span class="comment">// 这个时候，不知道要去读取 4个字节，所以结果不是1；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-空指针与野指针"><a href="#17-空指针与野指针" class="headerlink" title="17. 空指针与野指针"></a>17. 空指针与野指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> * p = <span class="literal">NULL</span>;<span class="comment">// 指针被定义出来，还未决定指向哪里的时候，可以先指向NULL，系统上 0 号不分配给任何进程；把指针置为空是为了预防野指针；</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-野指针"><a href="#4-1-野指针" class="headerlink" title="4.1 野指针"></a>4.1 野指针</h3><blockquote><p>当前这个指针的指向是不确定的，或者压根就没有指向；但是直接使用这个指针了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p --&gt; %d\n"</span>, p ,*p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffee67879d8---&gt;0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p --&gt; %d\n"</span>, p ,*p);</span><br><span class="line"></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 段错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-1-如何杜绝野指针"><a href="#4-1-1-如何杜绝野指针" class="headerlink" title="4.1.1 如何杜绝野指针"></a>4.1.1 如何杜绝野指针</h4><blockquote><p>指针一经定义，就必须有一个明确的指向，没有暂时没有指向的话，就先指向NULL；</p></blockquote><h2 id="18-空类型"><a href="#18-空类型" class="headerlink" title="18. 空类型"></a>18. 空类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * p = <span class="literal">NULL</span>; <span class="comment">// 即 空类型 void * 是一个百搭的类型，任何类型的指针值都可以赋值给它。void * 也可以把自己的值赋值给任何类型的指针；</span></span><br></pre></td></tr></table></figure><h3 id="5-1-空类型的使用场景"><a href="#5-1-空类型的使用场景" class="headerlink" title="5.1 空类型的使用场景"></a>5.1 空类型的使用场景</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="19-运算符优先级"><a href="#19-运算符优先级" class="headerlink" title="19. 运算符优先级"></a>19. 运算符优先级</h2><blockquote><p>上面优先级比下面高</p></blockquote><ul><li>后置++ –<ul><li>前置++ – 逻辑非 (!) * &amp;   // 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高<ul><li>算术运算符<ul><li>关系运算符<ul><li>&amp;&amp;和｜｜<ul><li>赋值运算符</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li>同级别，优先级由右往左结合顺序， 离目标越近，优先级越高</li></ul><p>如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;*pointer = &amp;(*pointer)</span><br><span class="line">*&amp;a = *(&amp;a)</span><br></pre></td></tr></table></figure><p><code>(*pointer)++ 不等于 *pointer++</code></p><p>(<em>pointer)++ 是先 做取</em>运算，得到的int类型自增， <em>pointer++ 则是 指针变量移位，然后再取</em>运算</p><p><code>*pointer++ 的含义</code></p><p>假设： pointer当前所存的地址是0x00000100</p><ul><li>若pointer 的指针变量基类型是 指向一个 int或实型（占4个字节），则pointer++ 等于 iptr + 1*4 = 0x00000104</li><li>若pointer 指向一个 字符型（占1个字节），则pointer++ 等于 iptr + 1*1 = 0x00000101</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">33</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(P, a); <span class="comment">// 0x7ffee0eeda20</span></span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(P, p); <span class="comment">// 0x7ffee0eeda20</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p); <span class="comment">//  5</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p++); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p++); <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">printf</span>(D, *p);   <span class="comment">// 19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*p++ 是地址移动</span><br></pre></td></tr></table></figure><p>** 小结** </p><p>  指针和指针变量是不同的。指针是地址，指针变量就是一个普通的变量。<br><em>pointer指的是这个指针变量 所指向的那片内存空间里面的内容。<br>(</em>pointer)++ 不等于 *pointer++</p><h2 id="20-指针与数组"><a href="#20-指针与数组" class="headerlink" title="20. 指针与数组"></a>20. 指针与数组</h2><blockquote><p>数组名代表数组首元素的地址 （<em>数组名相当于指向数组第一个元素的指针</em>）；<br>数组名不是变量，不能给a赋值；<br><code>int *p = &amp;a[0];</code> <code>a++</code>是没有意义的（a只是个常量），但<code>p++</code>会引起p变化。<br>p可以指向数组最后一个元素以后的元素。<br>指针做加减运算时一定注意有效的范围；（指针理论上能够在内存中自由的漂移，很可能移除某一个数组的范围，有的时候就比较危险了）</p></blockquote><p><img src="./arr_1.png" alt=""></p><h3 id="7-1-数组名代表数组首元素的地址"><a href="#7-1-数组名代表数组首元素的地址" class="headerlink" title="7.1 数组名代表数组首元素的地址"></a>7.1 数组名代表数组首元素的地址</h3><blockquote><p>数组名是指向数组第一个元素的指针；</p></blockquote><ul><li>对于数组a[10], 数组名 a代表数组 a[10]中第一个元素a[0]的地址； 即  a 与 a[0]等价</li><li>注意： a是地址常量，不是变量，不能给a赋值；</li></ul><h3 id="7-2-创建一个匿名数组"><a href="#7-2-创建一个匿名数组" class="headerlink" title="7.2  创建一个匿名数组"></a>7.2  创建一个匿名数组</h3><blockquote><p>指针和数组的关系，其实就是一种引用方式而已。你的一维数组名和一级指针之间的关系其实除了一个是变量，一个是常量之外。完全可以等价代换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> [<span class="number">3</span>])&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(D, p[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-利用指针变量引用数组元素"><a href="#7-3-利用指针变量引用数组元素" class="headerlink" title="7.3 利用指针变量引用数组元素"></a>7.3 利用指针变量引用数组元素</h3><ul><li>若定义<ul><li>数组 int a[10]; 指针 int * pointer;</li></ul></li><li>则:<ul><li>pointer =a; 等价于pointer = &amp;a[0];</li></ul></li><li>数组访问<br>  pointer+ i; 等价于 a+i; 等价于 &amp;a[i];<br>  *(pointer+i);  等价于 *(a+i); 等价于a[i];</li><li>表示形式<br>  pointer[i] 等价于 *(pointer+i);</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = a; <span class="comment">// a 是 数组的地址，</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);   <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p++);  <span class="comment">// 4    ++的含义是先使用p，然后再++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);     <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *++p);   <span class="comment">// 6   前+ 和 后+ 跟js一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">0</span>]); <span class="comment">// 因为p=a了，所以p[0] 即a[0]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-抽象公式"><a href="#7-4-抽象公式" class="headerlink" title="7.4 抽象公式"></a>7.4 抽象公式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a[i]: a[i] = *(a+i) = *(p+i) = p[i];</span></span><br><span class="line"><span class="comment">// &amp;a[i]: &amp;a[i] = a+i = p+i = &amp;p[i];</span></span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><h3 id="7-5-重置指针变量"><a href="#7-5-重置指针变量" class="headerlink" title="7.5 重置指针变量"></a>7.5 重置指针变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d/n"</span>, p++);</span><br><span class="line"></span><br><span class="line">p = a; <span class="comment">// 这里需要 重置一下 p的指针；不然会数组越界；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *p++);</span><br></pre></td></tr></table></figure><h3 id="7-6-需要注意的问题"><a href="#7-6-需要注意的问题" class="headerlink" title="7.6 需要注意的问题"></a>7.6 需要注意的问题</h3><blockquote><p><code>int * p = &amp;a[0];</code> , <code>* a++</code>是没有意义的（因为a是个常量），但<code>p++</code>会引起<code>p</code>变化；<code>* p</code>可以指向数组最后一个元素以后的元素；（因为p是内存中的一个指针），所以指针做加减运算时一定注意有效的范围。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>],</span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;a[<span class="number">1</span>];</span><br><span class="line">iPtr--;     <span class="comment">// 指向&amp;a[0]</span></span><br><span class="line">*iPtr = <span class="number">3</span>;  <span class="comment">// a[0] = 3</span></span><br><span class="line">iPtr--;     <span class="comment">// 指向&amp;a[-1], dangerous</span></span><br><span class="line">*iPtr = <span class="number">6</span>;  <span class="comment">// (damage)  对内存造成损坏，影响内存中其他的变量</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a[<span class="number">3</span>];</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p++); <span class="comment">// 100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p--); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *--p); <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7-指向二维数组的指针"><a href="#7-7-指向二维数组的指针" class="headerlink" title="7.7 指向二维数组的指针"></a>7.7 指向二维数组的指针</h3><h4 id="7-7-1-遍历数组元素"><a href="#7-7-1-遍历数组元素" class="headerlink" title="7.7.1 遍历数组元素"></a>7.7.1 遍历数组元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">for</span> (p= &amp;a[<span class="number">0</span>][<span class="number">0</span>]   ;p &lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">12</span>; p++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0x7ffeefbff4f0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4f4</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4f8</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff4fc</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff500</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff504</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff508</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff50c</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff510</span></span><br><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff514</span></span><br><span class="line"><span class="comment">// 19</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff518</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 0x7ffeefbff51c</span></span><br><span class="line"><span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>如上所示， 会将这个数组的内容都打印出来了，因为二维数组会被拉平存储到一段连续的内存空间当中</p><h4 id="7-7-2-二维数组行列指针"><a href="#7-7-2-二维数组行列指针" class="headerlink" title="7.7.2 二维数组行列指针"></a>7.7.2 二维数组行列指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> D <span class="meta-string">"%d\n"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> P <span class="meta-string">"%p\n"</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"&amp;a = %p, &amp;a+1 = %p\n"</span>, &amp;a, &amp;a+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%&amp;a[0][0] = %p, &amp;a[1][0] = %p\n"</span>, &amp;a[<span class="number">0</span>][<span class="number">0</span>], &amp;a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%p---&gt;%d\n"</span>, &amp;a[i][j], a[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;a = 0x7ffefe385370,            &amp;a+1 = 0x7ffefe3853a0</span></span><br><span class="line"><span class="comment">// %&amp;a[0][0] = 0x7ffefe385370, &amp;a[1][0] = 0x7ffefe385380</span></span><br><span class="line"><span class="comment">// 0x7ffefe385370---&gt;1</span></span><br><span class="line"><span class="comment">// 0x7ffefe385374---&gt;2</span></span><br><span class="line"><span class="comment">// 0x7ffefe385378---&gt;3</span></span><br><span class="line"><span class="comment">// 0x7ffefe38537c---&gt;4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffefe385380---&gt;5</span></span><br><span class="line"><span class="comment">// 0x7ffefe385384---&gt;6</span></span><br><span class="line"><span class="comment">// 0x7ffefe385388---&gt;7</span></span><br><span class="line"><span class="comment">// 0x7ffefe38538c---&gt;8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffefe385390---&gt;9</span></span><br><span class="line"><span class="comment">// 0x7ffefe385394---&gt;10</span></span><br><span class="line"><span class="comment">// 0x7ffefe385398---&gt;11</span></span><br><span class="line"><span class="comment">// 0x7ffefe38539c---&gt;12</span></span><br></pre></td></tr></table></figure><p>小结：</p><blockquote><p>所以a除了是二维数组的数组名（地址常量）之外，在使用上比较偏向一个指向行指针。</p></blockquote><h4 id="7-7-3-能够接收二维数组指针的指针变量"><a href="#7-7-3-能够接收二维数组指针的指针变量" class="headerlink" title="7.7.3 能够接收二维数组指针的指针变量"></a>7.7.3 能够接收二维数组指针的指针变量</h4><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">     p  =&amp;a[i][j]; <span class="comment">// *(a+0) , *a</span></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++,p++) <span class="comment">// for (i=0; i&lt;12; i++)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);  <span class="comment">//     printf("%d ", p[i]);</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 1 2 3 4 5 6 7 8 9 10 11 12</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="7-7-4-另一段程序"><a href="#7-7-4-另一段程序" class="headerlink" title="7.7.4 另一段程序"></a>7.7.4 另一段程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>], i,j;</span><br><span class="line">p = a;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;    <span class="comment">// i&lt;3 代表行号， j&lt;4 代表列号；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; *(*(p+i)+j); <span class="comment">// 正误判断： 访问元素 a[i][j]</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>程序分析</em></p><p>从 p = a 开始</p><ul><li><p>a相当于指向a[3][4]的“第一个元素”的指针；</p></li><li><p>所谓“第一个元素”是指一个“包含4个int型元素的一维数组”；</p></li><li><p>所以，a相当于一个“包含4个int型元素的一维数组”的地址；</p></li><li><p>因此，p的基类型应该是： “包含4个int型元素的一维数组”</p></li><li><p>变量定义语句的语法为： int (*p)[4];</p></li></ul><p>*p(数组)</p><p>p -&gt; |    (<em>p)[0] | (</em>p)[1] | (<em>p)[2] | (</em>p)[3] |</p><h4 id="7-7-5-利用指针变量引用多维数组中的数组"><a href="#7-7-5-利用指针变量引用多维数组中的数组" class="headerlink" title="7.7.5 利用指针变量引用多维数组中的数组"></a>7.7.5 利用指针变量引用多维数组中的数组</h4><p><em>(</em>(p+i)+j)是什么？</p><ul><li><p>p 是指向一个“包含4个int型元素的一维数组”；</p></li><li><p>p+i 是第i+1个“包含4个int型元素的一维数组”的地址;</p></li><li><p>p+i 等价于&amp;a[i]；</p></li><li><p>*(p+i)等价于a[i]；</p></li><li><p>*(p+i)+j 等价于 a[i]+j; // 这里把a[i] 当作一个指针来看 因此， a[i]+j 等价于 &amp;a[i][j];</p></li><li><p><em>(</em>(p+i)+j) 等价于 a[i][j];</p></li></ul><h3 id="7-8-指针与字符数组"><a href="#7-8-指针与字符数组" class="headerlink" title="7.8  指针与字符数组"></a>7.8  指针与字符数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> s[] = <span class="string">"i love coding!"</span>; <span class="comment">// codeing</span></span><br><span class="line"> <span class="keyword">char</span> *p = s+<span class="number">7</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s+<span class="number">7</span>);</span><br><span class="line"> <span class="built_in">puts</span>(s);</span><br><span class="line"> <span class="built_in">puts</span>(p); <span class="comment">// puts(p) 相当于把p的起始位置拿进来， 依次输出，直到碰到\0 为止；</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// coding!</span></span><br><span class="line"><span class="comment">// i love coding!</span></span><br><span class="line"><span class="comment">// coding!</span></span><br></pre></td></tr></table></figure><h4 id="7-8-1-字符数组拼接"><a href="#7-8-1-字符数组拼接" class="headerlink" title="7.8.1  字符数组拼接"></a>7.8.1  字符数组拼接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// str = "world"  false</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"world123"</span>); <span class="comment">// 覆盖原来数组空的每一项</span></span><br><span class="line"><span class="built_in">puts</span>(str); <span class="comment">// world123</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// world123</span></span><br></pre></td></tr></table></figure><h4 id="7-8-2-字符串长度和字符串字节数"><a href="#7-8-2-字符串长度和字符串字节数" class="headerlink" title="7.8.2 字符串长度和字符串字节数"></a>7.8.2 字符串长度和字符串字节数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d ,%d"</span>, <span class="keyword">sizeof</span>(str), <span class="built_in">strlen</span>(str));  <span class="comment">// 6, 5</span></span><br></pre></td></tr></table></figure><h4 id="7-8-3-字符指针跟字符数组的区别"><a href="#7-8-3-字符指针跟字符数组的区别" class="headerlink" title="7.8.3 字符指针跟字符数组的区别"></a>7.8.3 字符指针跟字符数组的区别</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(str); <span class="comment">// 8   指针变量不分类型 ， 64位系统下长度都是8个字节， 32位系统为4个字节；</span></span><br><span class="line"><span class="built_in">strlen</span>(str); <span class="comment">// 5   字符串长度</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"world"</span>); <span class="comment">// 段错误， 字符指针跟字符数组的区别就在于此。因为str 指向的是一个 字符串常量的地址， strcpy是一个覆盖写操作，显然，企图去更改一个常量是无效的。之所以是常量，是串常量，这个串在当前存储位置是特殊的。在使用上不允许被改变和覆盖。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line">str = <span class="string">"world123"</span>; <span class="comment">//更改指针指向；</span></span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h2 id="21-字符串与指针"><a href="#21-字符串与指针" class="headerlink" title="21. 字符串与指针"></a>21. 字符串与指针</h2><blockquote><p>指向字符串的指针</p></blockquote><ul><li>指向字符串的指针变量： char a[10]; char *p; p=a;</li></ul><p>数组和字符串太接近了。那怎么去定义指向字符串的指针呢？也很简单， 我首先定义一个字符数组，它就是用来存放字符串的。 我们以前讲过字符串和字符数组其实区别就在于有没有最后的反斜杠零， 本质上都是字符数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *s = c;</span><br><span class="line"><span class="built_in">printf</span>(P, s); <span class="comment">// 0x7ffee2066aba</span></span><br><span class="line"><span class="built_in">printf</span>(P, c); <span class="comment">// 0x7ffee2066aba</span></span><br><span class="line"><span class="built_in">printf</span>(S, s); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">printf</span>(S, c); <span class="comment">// hello </span></span><br><span class="line">s++;</span><br><span class="line"><span class="built_in">printf</span>(S, s); <span class="comment">// ello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-字符串指针举例"><a href="#8-1-字符串指针举例" class="headerlink" title="8.1  字符串指针举例"></a>8.1  字符串指针举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>] = <span class="string">"ABC"</span>;</span><br><span class="line"><span class="keyword">char</span> *pc;</span><br><span class="line">pc = <span class="string">"hello"</span>; <span class="comment">// 虽然 hello赋值给了pc，但是却不能通过pc去改变hello， 因为hello是常量，常量在内存中被放在特殊的地方了；这片区域不允许修改；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// hello</span></span><br><span class="line">pc++;                  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ello</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// e</span></span><br><span class="line">pc = <span class="built_in">buffer</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pc;           <span class="comment">// ABC</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-const与指针"><a href="#22-const与指针" class="headerlink" title="22. const与指针"></a>22. const与指针</h2><blockquote><p>const是把某些内容常量化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>; <span class="comment">// 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针常量</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><h3 id="9-1-变量值常量化"><a href="#9-1-变量值常量化" class="headerlink" title="9.1  变量值常量化"></a>9.1  变量值常量化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>; <span class="comment">// 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure><h3 id="9-2-常量指针"><a href="#9-2-常量指针" class="headerlink" title="9.2  常量指针"></a>9.2  常量指针</h3><blockquote><p>指针的指向可以发生变化，但是指针所指向当前的那块内存的值是不可以发生变化的；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">  <span class="comment">//   float *p = &amp;pi;  // 警告： initialization discards ‘const’ qualifier from pointer target type</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">float</span> *p = &amp;pi;</span><br><span class="line">    *p = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, *p);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> chart * pathname, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 常量指针，保护pathname值不被篡改</span></span><br></pre></td></tr></table></figure><h3 id="9-3-指针常量"><a href="#9-3-指针常量" class="headerlink" title="9.3  指针常量"></a>9.3  指针常量</h3><p><code>int *const p;</code></p><blockquote><p>指针常量指 指针的指向永远不能发生变化；但是指针指向的值可以有变化；</p></blockquote><h3 id="9-4-如何区分到底是-常量指针，还是指针常量"><a href="#9-4-如何区分到底是-常量指针，还是指针常量" class="headerlink" title="9.4  如何区分到底是 常量指针，还是指针常量"></a>9.4  如何区分到底是 常量指针，还是指针常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p; <span class="comment">// 如果先碰到const关键字，就把常量先念出来</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p; <span class="comment">// 如果先看到 *，就把指针先念出来</span></span><br></pre></td></tr></table></figure><h3 id="9-5-两个const修饰"><a href="#9-5-两个const修饰" class="headerlink" title="9.5  两个const修饰"></a>9.5  两个const修饰</h3><p><code>const int *const p;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;i;</span><br><span class="line"></span><br><span class="line">p = &amp;j; <span class="comment">// warning 因为p是只读的，不能更改指向；</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// warning 因为*p 也是只读的；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-6-指向符号常量的指针"><a href="#9-6-指向符号常量的指针" class="headerlink" title="9.6  指向符号常量的指针"></a>9.6  指向符号常量的指针</h3><p><code>const int * p;</code></p><p>当把p定义成一个指向符号常量的指针的时侯， 然后再让这个p指向什么东西， 它所指向的那个东西就不能被修改了。我们就不能通过p再去修改 它所指向的那个东西了。</p><ul><li>深坑啊,要留意</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">78</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a;</span><br><span class="line">*p1 = <span class="number">58</span>;   <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line">p1 = &amp;b;    <span class="comment">// （可以给 p1 重新赋值）</span></span><br><span class="line">*p1 = <span class="number">68</span>;    <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line"><span class="built_in">printf</span>(D, *p1);  <span class="comment">// 28</span></span><br><span class="line">p1 = &amp;c;      <span class="comment">// （可以给 p1 重新赋值）</span></span><br><span class="line">*p1 = <span class="number">88</span>;     <span class="comment">// (error, *p不能被赋值)</span></span><br><span class="line"><span class="built_in">printf</span>(D, *p1)  <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-7-再谈一维数组的地址"><a href="#9-7-再谈一维数组的地址" class="headerlink" title="9.7 再谈一维数组的地址"></a>9.7 再谈一维数组的地址</h3><p><em>数组名相当于指向数组第一个元素的指针</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// a[1]的地址，管辖范围只有a[1]</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// a[1]的地址，管辖范围是整个a的内存空间</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// a[2]的地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 跳出了a的内存范围，理论上是 a[5]的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(P, a);           <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, a+<span class="number">1</span>);         <span class="comment">// 0x7ffee42adab4   跨越4个字节</span></span><br><span class="line"><span class="built_in">printf</span>(P, &amp;a);          <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, &amp;a+<span class="number">1</span>);        <span class="comment">// 0x7ffee42adac0  // 跨越16个字节</span></span><br><span class="line"><span class="built_in">printf</span>(P, *(&amp;a));       <span class="comment">// 0x7ffee42adab0</span></span><br><span class="line"><span class="built_in">printf</span>(P, *(&amp;a) + <span class="number">1</span>);   <span class="comment">// 0x7ffee42adab4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据C语言的规范 *(&amp;a)  等同于 a; 即a数组第一个元素的内存地址<br>*(&amp;a) + 1 等同于 a+1; 即a数组第二个元素的内存地址</p><p>&amp;a的管辖范围是整个数组a。c语言规范中，当它前面出现*时，管辖范围降级，即堕落成了 a[0]的地址；</p><h3 id="9-8-总结"><a href="#9-8-总结" class="headerlink" title="9.8  总结"></a>9.8  总结</h3><blockquote><p>数组名相当于指向数组第一个元素的指针</p></blockquote><ul><li>&amp;运算符 - 升级</li></ul><p>若 a 是指向数组第一个元素的指针，即a相当于 &amp;a[0];</p><ul><li>&amp;a是“指向数组”的指针；&amp;a+1将跨越16个字节；</li><li>&amp;a相当于管辖范围 “上升” 了一级;</li></ul><ul><li>*运算符 - 降级<br>*a是数组的第一个元素a[0]；即 *a等价于a[0]；</li></ul><ul><li>*a 相当于管辖范围“下降”了一级；      </li></ul><h3 id="9-9-指向二维数组的指针"><a href="#9-9-指向二维数组的指针" class="headerlink" title="9.9  指向二维数组的指针"></a>9.9  指向二维数组的指针</h3><ul><li><p>二维数组的定义</p><ul><li>二维数组a[3][4]包含三个元素： a[0] a[1] a[2]</li><li>每个元素都是一个“包含四个整型元素”的数组</li></ul></li></ul><p>| 1 a[0][0]  | 2 a[0][1] | 3 a[0][2] | 4 a[0][3] |<br>| 5 a[1][0]  | 6 a[1][1] | 7 a[1][2] | 8 a[1][3] |<br>| 9 a[2][0]  | 10 a[2][1]| 11 a[2][2]| 12 a[2][3]| </p><pre><code>- 二维数组的第一个元素是a[0];- a[0]是一个“包含四个整形元素”的一维数组；</code></pre><p><img src="./pointer_1.png" alt=""></p><p>推论</p><p>a 与 &amp;a[0] 等价<br>a[0] 与  &amp;a[0][0] 等价<br>a[0] 与 <em>a 等价<br>a[0][0] 与 *</em>a 等价</p><h3 id="9-10-总结"><a href="#9-10-总结" class="headerlink" title="9.10  总结"></a>9.10  总结</h3><p>三条规律<br>1） 数组名相当于指向数组第一个元素的指针；<br>2） &amp;E相当于把E的管辖范围上升了一个级别；<br>3） *E相当于把E的管辖范围下降了一个级别；</p><h2 id="23-指针与函数"><a href="#23-指针与函数" class="headerlink" title="23. 指针与函数"></a>23. 指针与函数</h2><h3 id="10-1-指针用作函数参数"><a href="#10-1-指针用作函数参数" class="headerlink" title="10.1 指针用作函数参数"></a>10.1 指针用作函数参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> *q1, <span class="keyword">int</span> *q2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (*q1 &lt; *q2)&#123;</span><br><span class="line">        temp = *q1;</span><br><span class="line">        *q1 = *q2;</span><br><span class="line">        *q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, *p1, *p2;</span><br><span class="line">    <span class="built_in">scanf</span>(a);</span><br><span class="line">    <span class="built_in">scanf</span>(b);</span><br><span class="line">    p1 = &amp;a; p2 = &amp;b;</span><br><span class="line">    Rank(p1, p2); <span class="comment">// 指针传递，即地址传递</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-将数组名作为实参"><a href="#10-2-将数组名作为实参" class="headerlink" title="10.2 将数组名作为实参"></a>10.2 将数组名作为实参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">total += *p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, total); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">sum(a, <span class="number">3</span>); <span class="comment">// 将数组名作为实参赋给指针型形参</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-“数组名”-做形参"><a href="#10-3-“数组名”-做形参" class="headerlink" title="10.3  “数组名” 做形参"></a>10.3  “数组名” 做形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 编译器将形参数组名 作为 指针变量来处理！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span><span class="number">-1</span>; i++) &#123;</span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>) = *<span class="built_in">array</span> + *(<span class="built_in">array</span>+<span class="number">1</span>); <span class="comment">// 数组从第二项开始，每一项都等于自己加上前一项的和；</span></span><br><span class="line"><span class="built_in">array</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(a, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序里，把一个指针变量或者是数组的名字，传递给一个函数的时候，是挺危险的，因为这个函数拿到的，是这个变量或者是数组的地址， 它拿到了地址，它就可以直接对地址里面存放的这些值，进行肆意的修改，那有没有一种办法，可以呢 使我既能够把这个地址传递给某个函数，又能够确保不让这个函数随意的修改这片地址里面的值呢？ </p><ul><li>如何 “限制” 指针的功能<ul><li>如何“限制”指针实参的功能</li></ul></li></ul><h3 id="10-4-即指向符号常量的指针"><a href="#10-4-即指向符号常量的指针" class="headerlink" title="10.4  即指向符号常量的指针"></a>10.4  即指向符号常量的指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 补充为const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span><span class="number">-1</span>; i++) &#123;</span><br><span class="line">*(<span class="built_in">array</span>+<span class="number">1</span>) = *<span class="built_in">array</span> + *(<span class="built_in">array</span>+<span class="number">1</span>); <span class="comment">//  array变成常量之后，无法修改</span></span><br><span class="line"><span class="built_in">array</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(a, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符号常量声明语句</p><ol><li>const 数组类型 常量名 = 常量值；</li><li>数据类型 const 常量名 = 常量值；</li></ol><h3 id="10-5-指针用作函数返回值"><a href="#10-5-指针用作函数返回值" class="headerlink" title="10.5  指针用作函数返回值"></a>10.5  指针用作函数返回值</h3><p>函数的返回值可以是多种类型</p><ol><li>返回整形数据的函数<br> <code>int max(int x, int y);</code></li><li>返回指针类型数据的函数<br> <code>int *min(int x, int y)</code><ul><li>函数名字前面表示函数的类型 *</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int arr[][4] 除了这么定义，还可以 int *(arr)[4]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *pt;</span><br><span class="line">pt = *(arr+n<span class="number">-1</span>) + m<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> (pt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="built_in">get</span>(a, <span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析一下返回结果， 又一个需要注意的深坑</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = getInt1();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">// 这里会打印未知数，也可能会打印20；为什么呢，因为随着getInt1的运行时完毕，导致它函数内部的所有引用被释放了。所以返回的地址&amp;value1 指向的内存空间被释放掉了；所以谁也不会知道这个地址现在存放的是个啥，如果该块内存没有被新写入值，那么还是20；新写入的话，那就是新的未知量了；</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value2 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p, *q;</span><br><span class="line">p = getInt1();</span><br><span class="line">q = getInt2();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);  <span class="comment">// 这里大概率会是30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那既然如此，有什么办法解决这个问题</p><ul><li>静态局部变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getInt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value2 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p, *q;</span><br><span class="line">p = getInt1();</span><br><span class="line">q = getInt2();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *q);  <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>什么是静态局部变量</li></ul><p>** 静态局部变量 ** </p><blockquote><p>函数中局部变量的值在函数调用结束后不消失而保留原值</p></blockquote><p>即其占用的存储单元不释放，在下一次该函数调用时，仍可以继续使用该变量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;  <span class="comment">// 有点像 hooks，只初始化一次，后续不再重新将其赋值为0；</span></span><br><span class="line">    a = a+<span class="number">1</span>;</span><br><span class="line">    b = b+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i&lt;<span class="number">3</span>;i--)&#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>小结</li></ul><p>指针与函数</p><pre><code>指针用做函数参数    函数拿到地址可对其所指内容进行修改；    可以使用const来“限制”指针的功能；指针用做函数返回值    必须确保函数返回的地址是有意义的；    返回全局变量或静态局部变量；</code></pre><h2 id="24-指针数组和数组指针"><a href="#24-指针数组和数组指针" class="headerlink" title="24. 指针数组和数组指针"></a>24. 指针数组和数组指针</h2><h3 id="11-1-数组指针"><a href="#11-1-数组指针" class="headerlink" title="11.1 数组指针"></a>11.1 数组指针</h3><blockquote><p>归根结底是一个指针，是指向数组的指针。</p></blockquote><p>【存储类型】 数据类型 （*指针名）【下标】 = 值；</p><p>如： <code>int (*p)[3]; ---&gt; type name  ----&gt;  int[3] *p</code></p><p>解析：</p><blockquote><p>定义一个指针变量 p, 用来指向 <code>int[3]</code> 类型的元素的起始位置。原来 <code>int * p</code> 的时候，<code>p+1</code> 的操作是移动一个 <code>int</code> 的大小。如果p的类型 变成了 <code>int [3]</code>的话，<code>p+1</code>的操作是一下移动三个 int 元素的大小。所以数组指针是在某种 大小的数组中进行移动。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> *p = *a;</span><br><span class="line">     <span class="keyword">int</span> (*q)[N]= a;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p %p\n"</span>, a, a+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p %p\n\n"</span>, q, q+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt;M; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%p -&gt; %d\n"</span>, *(a+i)+j, *(*(a+i)+j));</span><br><span class="line">            <span class="comment">//  printf("%p -&gt; %d\n", *(q+i)+j, *(*(q+i)+j)); // a 和 q现在是等价的，区别只是一个是常量，一个是变量；</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 0x7ffd6f5ad200</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 0x7ffd6f5ad200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f0 -&gt; 1</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f4 -&gt; 2</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1f8 -&gt; 3</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad1fc -&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad200 -&gt; 5</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad204 -&gt; 6</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad208 -&gt; 7</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad20c -&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad210 -&gt; 9</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad214 -&gt; 10</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad218 -&gt; 11</span></span><br><span class="line"><span class="comment">// 0x7ffd6f5ad21c -&gt; 12</span></span><br></pre></td></tr></table></figure><h3 id="11-2-指针数组"><a href="#11-2-指针数组" class="headerlink" title="11.2 指针数组"></a>11.2 指针数组</h3><blockquote><p>归根结底是一个数组</p></blockquote><p>【存储类型】 数据类型 * 数组名 【长度】</p><p>如： <code>int * arr[3]; ---&gt; TYPE NAME ---&gt; int *[3] arr;</code></p><h3 id="11-3-指针数组与数组指针的区别"><a href="#11-3-指针数组与数组指针的区别" class="headerlink" title="11.3 指针数组与数组指针的区别"></a>11.3 指针数组与数组指针的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, k, j;</span><br><span class="line">  <span class="comment">//  指针数组</span></span><br><span class="line">  <span class="keyword">char</span> *name[<span class="number">5</span>] = &#123;<span class="string">"Follow me"</span>, <span class="string">"Basic"</span>, <span class="string">"Great"</span>, <span class="string">"Fortran"</span>, <span class="string">"Computer"</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> *tmp;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span> - <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    k = i;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name[k], name[j]) &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != i)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp = name[i];</span><br><span class="line">      name[i] = name[k];</span><br><span class="line">      name[k] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(name[i]);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-多级指针"><a href="#25-多级指针" class="headerlink" title="25 .多级指针"></a>25 .多级指针</h2><p><img src="./point_01.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line1 <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Line2 <span class="keyword">int</span> *p = &amp;num</span><br><span class="line">Line3 <span class="keyword">int</span> *p1 = p;</span><br><span class="line">Line4 <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">Line5 <span class="keyword">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure><p>多级指针的本质，只是C语言的一个书写规范<br>，事实上任何指针都可以保存任何地址；</p><ul><li>多级指针的存储的值的推理过程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line1 <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Line2 <span class="keyword">int</span> *p = &amp;num</span><br><span class="line">Line3 <span class="keyword">int</span> *p1 = p;</span><br><span class="line">Line4 <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">Line5 <span class="keyword">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li>函数的定义</li><li>函数的传参</li><li>函数的调用 （嵌套和递归）</li><li>函数与数组</li><li>函数与指针 （指针函数， 函数指针， 函数指针数组）</li></ol><h2 id="26-函数的定义"><a href="#26-函数的定义" class="headerlink" title="26. 函数的定义"></a>26. 函数的定义</h2><p>  数据类型  函数名 （【数据类型 形参名 。。。】）</p><blockquote><p>函数的类型是指 函数的返回值的数据类型</p></blockquote><h3 id="1-1-1-main函数"><a href="#1-1-1-main函数" class="headerlink" title="1.1.1 main函数"></a>1.1.1 main函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  argc： 参数计数器，统计终端上多少个参数传进来</span></span><br><span class="line"><span class="comment">  *argv[]： 列表，用来传递刚才命令行传递进来的参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *argv[]是一个数组；</span></span><br><span class="line"><span class="comment">  argv 是数组名；</span></span><br><span class="line"><span class="comment">  char* 指数组中每个元素的类型为 char*；即字符指针</span></span><br><span class="line"><span class="comment">  argv 即字符数组指针的首地址；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"argc=%d\n"</span>, argc);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main /etc/a*.conf</span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>因为shell 会自动解析通配符，把结果都解析出来。</p><p><img src="./function_01.png" alt=""><br>图示：char * argv 数组模型</p><p>** 输出argv** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">// for (i=0; i&lt;argc; i++)</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; argv[i] !=<span class="literal">NULL</span>; i++)</span><br><span class="line">    <span class="built_in">puts</span>(argv[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-C语言使用函数之前也需要先声明"><a href="#1-1-2-C语言使用函数之前也需要先声明" class="headerlink" title="1.1.2 C语言使用函数之前也需要先声明"></a>1.1.2 C语言使用函数之前也需要先声明</h3><blockquote><p>函数在使用前都要声明，除非被调用函数的定义部分已经出现在主调函数之前, 在C语言中，函数声明就是函数原型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 需要先声明，因为main函数在 printf_hello函数上面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  printf_hello();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-函数的传参"><a href="#27-函数的传参" class="headerlink" title="27. 函数的传参"></a>27. 函数的传参</h2><h3 id="1-2-1-值传递"><a href="#1-2-1-值传递" class="headerlink" title="1.2.1 值传递"></a>1.2.1 值传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_value</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="comment">// 参数i j 随着 print_value 调用栈执行结束就释放掉了。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d%d\n"</span>, i,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i =<span class="number">3</span>; l = <span class="number">5</span>;</span><br><span class="line">  printf_value(i,l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-地址传递"><a href="#1-2-2-地址传递" class="headerlink" title="1.2.2 地址传递"></a>1.2.2 地址传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> * i, <span class="keyword">int</span> * j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  tmp = *i;</span><br><span class="line">  *i = *j;</span><br><span class="line">  *j = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i =<span class="number">3</span>; l = <span class="number">5</span>;</span><br><span class="line">  swap(&amp;i,&amp;l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-函数的调用（嵌套调用-和-递归调用）"><a href="#28-函数的调用（嵌套调用-和-递归调用）" class="headerlink" title="28. 函数的调用（嵌套调用 和 递归调用）"></a>28. 函数的调用（嵌套调用 和 递归调用）</h2><h3 id="1-3-1-函数的调用方式"><a href="#1-3-1-函数的调用方式" class="headerlink" title="1.3.1 函数的调用方式"></a>1.3.1 函数的调用方式</h3><ol><li>函数调用作为独立语句，<code>stringPrint();</code></li><li>函数作为表达式的一部分,<code>number = max(numA,numB)/2;</code></li><li>以实参形式出现在其他函数的调用中,<code>number = min(sum(-5, 100), numC);</code></li></ol><h3 id="1-3-2-嵌套调用"><a href="#1-3-2-嵌套调用" class="headerlink" title="1.3.2 嵌套调用"></a>1.3.2 嵌套调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">max</span>(a,b,c) - <span class="built_in">min</span>(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = a &lt; b? a :b;</span><br><span class="line">  <span class="keyword">return</span> tmp &lt; c ? tmp : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = a &gt; b? a :b;</span><br><span class="line">  <span class="keyword">return</span> tmp &gt; c ? tmp : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>, c = <span class="number">10</span>;</span><br><span class="line">  result = minus(a,b,c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-函数与数组"><a href="#39-函数与数组" class="headerlink" title="39. 函数与数组"></a>39. 函数与数组</h2><h3 id="1-4-1-函数与一唯数组"><a href="#1-4-1-函数与一唯数组" class="headerlink" title="1.4.1 函数与一唯数组"></a>1.4.1 函数与一唯数组</h3><p>问题：封装一个printf_arr方法来遍历数组；应该如何定义 printf_arr 的行参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_arr</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"printf_arr ---&gt; %p\n"</span>, a); <span class="comment">// 传入的是 数组 a的 起始地址；</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++) <span class="comment">// 是因为 a的 sizeof为 8， 所以只能访问数组前2位</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);   <span class="comment">// 1， 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main ---&gt; %p\n"</span>,a ); <span class="comment">// a 即 &amp;a, 即 &amp;a[0];</span></span><br><span class="line">  printf_arr(a);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main       ---&gt; 0x7ffd84a62eb0</span></span><br><span class="line"><span class="comment">// printf_arr ---&gt; 0x7ffd84a62eb0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(p));<span class="comment">// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(a)); <span class="comment">// 20，整个数组所占内存的大小，因为每个int是 4个字节；</span></span><br><span class="line">  print_arr(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 解决方法**</p><p>将数组的长度，当做第二个参数传入给 子函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(p));<span class="comment">// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]); <span class="comment">// p[i] 与 *(p+i) 等价</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, __FUNCTION__, <span class="keyword">sizeof</span>(a)); <span class="comment">// 20，整个数组所占内存的大小，因为每个int是 4个字节；</span></span><br><span class="line">  print_arr(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_arr</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 当 p[] 作为行参时， [] 等同于 * 因此 int p[] 即为 int *p</span></span><br></pre></td></tr></table></figure><p>** 示例** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>  a[N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">   a            -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  *a即*(a+<span class="number">0</span>)    -&gt;  <span class="keyword">int</span></span><br><span class="line">  a[<span class="number">0</span>]          -&gt;  <span class="keyword">int</span></span><br><span class="line">  &amp;a[<span class="number">3</span>]         -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  p[i]          -&gt;  <span class="keyword">int</span></span><br><span class="line">  p             -&gt;  <span class="keyword">int</span> *</span><br><span class="line">  *p            -&gt;  <span class="keyword">int</span></span><br><span class="line">  p+<span class="number">1</span>           -&gt;  <span class="keyword">int</span> *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 逆序** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j, m, tmp;</span><br><span class="line">  m = (n <span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;=m;i++) &#123;</span><br><span class="line">    j = n <span class="number">-1</span> -i;</span><br><span class="line">    tmp = p[i];</span><br><span class="line">    p[i] = p[j];</span><br><span class="line">    p[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">0</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  func(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a));</span><br><span class="line">   <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-函数与二维数组"><a href="#1-4-2-函数与二维数组" class="headerlink" title="1.4.2 函数与二维数组"></a>1.4.2 函数与二维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; M; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure><p>问题： 同样的把输出放到一个独立的函数中去，也就是考察一下 二维数组应该如何给函数传参</p><blockquote><p>这个问题实际考察点在于 二维数组如何 过实参给函数，以及函数的二维数组行参应该如何定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种, 用一个二维数组的指针去接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> (*p) [N], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(*p+i)); <span class="comment">// 关键点在这里， 首先 p 指向的是 int [3] 这个类型。所以需要降级 为列指针</span></span><br><span class="line">      &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M*N); <span class="comment">// *a  === a[0] === *(a+0)</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种，用一个普通一维数组指针去接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n);</span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(p+i));</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(&amp;a[<span class="number">0</span>][<span class="number">0</span>], M*N); <span class="comment">// 传递的是列指针</span></span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span>  <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> (*p)[N],<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>,*(*(p+i)+j));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M,N);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四种</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">arr_traverse</span><span class="params">(<span class="keyword">int</span> p[][N],<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//    printf("%p\n", p);</span></span><br><span class="line">   <span class="comment">//  printf("%d\n", n); </span></span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d  "</span>, p[i][j]);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a ---&gt; %d\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">     arr_traverse(a, M,N);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>** 小结 ** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[M][N] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">int</span> * p = *a;</span><br><span class="line"><span class="keyword">int</span> (*q)[N] = a;</span><br></pre></td></tr></table></figure><p>二维数组 参与传参的一些基本内容</p><table><thead><tr><th align="left">a[i][j]</th><th align="center">*(a+i)+j</th><th align="right">a[i]+j</th><th align="center">p[i]</th><th align="right">*p</th></tr></thead><tbody><tr><td align="left">q[i][j]</td><td align="center">*q === *(q+0)</td><td align="right">q</td><td align="center">p+3</td><td align="right">q+2</td></tr><tr><td align="left">int</td><td align="center">int *</td><td align="right">int *</td><td align="center">int</td><td align="right">int</td></tr><tr><td align="left">int</td><td align="center">int *</td><td align="right">int (*)[N]</td><td align="center">int *</td><td align="right">int (*)[N]</td></tr></tbody></table><h4 id="1-4-2-1-示例：-求平均数"><a href="#1-4-2-1-示例：-求平均数" class="headerlink" title="1.4.2.1 示例： 求平均数"></a>1.4.2.1 示例： 求平均数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">average_score</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum/n;</span><br><span class="line">&#125;</span><br><span class="line">find_num(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+num)+i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">  average_score(*a, M*N);</span><br><span class="line">  find_num(a, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-2-二维数组什么时候传行指针，什么时候传列指针"><a href="#1-4-2-2-二维数组什么时候传行指针，什么时候传列指针" class="headerlink" title="1.4.2.2  二维数组什么时候传行指针，什么时候传列指针"></a>1.4.2.2  二维数组什么时候传行指针，什么时候传列指针</h4><blockquote><p>当不区分行列的时候，可以把它当作一个大的一维数组。那就传递指针。 如果要区分行列来做某件事情的时候，那就需要把行指针传递过去。</p></blockquote><h3 id="1-4-3-函数与字符数组"><a href="#1-4-3-函数与字符数组" class="headerlink" title="1.4.3 函数与字符数组"></a>1.4.3 函数与字符数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(str2, str1);  <span class="comment">//实现了拷贝</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">mystrcpy</span><span class="params">(<span class="keyword">char</span> * dest, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ret = dest;</span><br><span class="line">  <span class="keyword">if</span> (dest != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">while</span>((*dest++ = *src++) != <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  mystrcpy(str2, str1);  <span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line">  <span class="built_in">puts</span>(str2); <span class="comment">// 测试一下</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个 mystrncpy 用于拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">mystrncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i&lt;n &amp;&amp; (dest[i] = src[i]); i++)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">for</span> (; i&lt;n; i++)</span><br><span class="line">    dest[i] = <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  mystrncpy(str2, str1, <span class="number">5</span>);  <span class="comment">//实现一个 mystrcpy 用于拷贝</span></span><br><span class="line">  <span class="built_in">puts</span>(str2); <span class="comment">// 测试一下</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-函数与指针"><a href="#30-函数与指针" class="headerlink" title="30.  函数与指针"></a>30.  函数与指针</h2><blockquote><p>指针函数, 函数指针, 函数指针数组</p></blockquote><h3 id="1-5-1-指针函数"><a href="#1-5-1-指针函数" class="headerlink" title="1.5.1 指针函数"></a>1.5.1 指针函数</h3><blockquote><p>一个函数的返回值为指针，即为指针函数</p></blockquote><p><code>返回值 * 函数名(形参);</code><br><code>如： int * fun(int);</code></p><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从find_num 这个函数说起，这个函数并不纯，而且没有实现它的功能；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, *(*(p+num)+i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">  <span class="keyword">float</span> ave;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  find_num(a, num); <span class="comment">// find_num 的设计不应该没有返回值；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> (*p)[N], <span class="keyword">int</span> num)</span> <span class="comment">// 将find_num 设计成为一个指针函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; M <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> *(p+num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> * res;</span><br><span class="line">    <span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> ave;</span><br><span class="line">    <span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line">    res = find_num(a, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d"</span>,res[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-函数指针"><a href="#1-5-2-函数指针" class="headerlink" title="1.5.2 函数指针"></a>1.5.2 函数指针</h3><blockquote><p>一个指针指向的是函数， 在C语言里面。你并不能用一个普通变量去接收 函数啊，或者结构体等等数据类型，必须要使用相同的类型变量去接收相同的类型。比如函数要用函数指针变量去接收；</p></blockquote><p>  类型  (<em>指针名) （形参）<br>  如： int (</em>p)(int);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个函数指针</span></span><br><span class="line"></span><br><span class="line">  p = add; <span class="comment">// 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址， 也可以写成 p = &amp;add;这里之所以省略，是因为函数名(add)本身就是一个地址。所以在指针和函数的指向关系当中，地址符可以省略。同样的 `ret = *p(a, b)`； p前面的 *也可以省略。 `ret = p(a, b)`。指向函数的指针，让这个指针指向某一个函数的入口地址。下面通过指针来传参数就如同通过函数名来传参数是一样的；</span></span><br><span class="line">  ret = p(a, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-函数指针数组"><a href="#1-5-3-函数指针数组" class="headerlink" title="1.5.3 函数指针数组"></a>1.5.3 函数指针数组</h3><p>引子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret1, ret2;</span><br><span class="line">  <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个函数指针</span></span><br><span class="line">  <span class="keyword">int</span> (*q)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 这里面定义两个相同的 函数指针有点浪费</span></span><br><span class="line"></span><br><span class="line">  p = add; <span class="comment">// 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址</span></span><br><span class="line">  ret1 = p(a, b);</span><br><span class="line">  ret2 = q(a, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret2;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-引出函数指针数组"><a href="#1-5-4-引出函数指针数组" class="headerlink" title="1.5.4 引出函数指针数组"></a>1.5.4 引出函数指针数组</h3><p>语法：</p><p>类型 （<em>数组名[下标]）（形参）；<br>如: int (</em>arr[N])(int);<br>arr是一个数组，这个数组有N个元素。这N个元素都是指向函数的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">3</span>, b=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ret1, ret2;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">// int (int, int) *funcp[2];  funcp这个数组有两个指针，两个指针都是指向 int (int, int) 类型的函数； 转换一种写法就是</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> (*funcp[<span class="number">2</span>])(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// p = add;</span></span><br><span class="line">  <span class="comment">// q = sub;</span></span><br><span class="line">  <span class="comment">// ret1 = p(a, b);</span></span><br><span class="line">  <span class="comment">// ret2 = q(a, b);</span></span><br><span class="line"></span><br><span class="line">  funcp[<span class="number">0</span>] = add;</span><br><span class="line">  funcp[<span class="number">1</span>] = sub;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret1 = funcp[i](a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf("%d\n",ret1);</span></span><br><span class="line">  <span class="comment">// printf("%d\n",ret2;</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-指向指针函数的函数指针数组"><a href="#1-5-5-指向指针函数的函数指针数组" class="headerlink" title="1.5.5 指向指针函数的函数指针数组"></a>1.5.5 指向指针函数的函数指针数组</h3><p>  <code>int *(*func[N])(int)</code></p><h2 id="31-函数的执行过程"><a href="#31-函数的执行过程" class="headerlink" title="31. 函数的执行过程"></a>31. 函数的执行过程</h2><h3 id="1-6-1-main函数-——-函数执行的入口"><a href="#1-6-1-main函数-——-函数执行的入口" class="headerlink" title="1.6.1 main函数 —— 函数执行的入口"></a>1.6.1 main函数 —— 函数执行的入口</h3><ul><li>遇到函数，开辟内存空间；</li><li>在内存空间再碰到函数时候，<ul><li>初始化内嵌函数；</li><li>传递参数</li><li>保存外层函数执行空间</li><li>执行完毕后。。。。释放函数执行栈</li><li>接收函数的返回值</li><li>恢复现场，从断点处继续执行</li></ul></li></ul><h3 id="1-6-2-参数的传递"><a href="#1-6-2-参数的传递" class="headerlink" title="1.6.2 参数的传递"></a>1.6.2 参数的传递</h3><ul><li><p>实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”。即拷贝</p></li><li><p>函数调用时，系统给行参分配存储单元，并将实参对应的值传递给形参；</p><p>P.S. 实参与形参的类型必须相同或可以兼容；</p></li></ul><h3 id="1-6-3-变量的作用范围"><a href="#1-6-3-变量的作用范围" class="headerlink" title="1.6.3 变量的作用范围"></a>1.6.3 变量的作用范围</h3><p>局部变量与全局变量</p><blockquote><p>根据变量在程序中作用范围的不同，可以将变量分为局部变量和全局变量</p></blockquote><ul><li><p>局部变量<br>在函数内或块内定义，只在这个函数或块内其作用的变量；</p></li><li><p>全局变量<br>在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。</p></li><li><p>当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量</p></li></ul><h2 id="32-数组与函数"><a href="#32-数组与函数" class="headerlink" title="32. 数组与函数"></a>32. 数组与函数</h2><ul><li>数组名 做函数参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">30</span>;</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  change(a);  <span class="comment">// 地址传递， 数组的名字代表着数组所在的地址；</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d, %d,"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>]); <span class="comment">// 30 50</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-缓冲区"><a href="#33-缓冲区" class="headerlink" title="33.  缓冲区"></a>33.  缓冲区</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// __FUNCTION__ 当前所在的函数，</span></span><br><span class="line">    <span class="comment">// __LINE__ 当前所在的行数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s:%d]before"</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s:%d]after"</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">./<span class="built_in">printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发现两个printf都没打印出来东西</span></span><br></pre></td></tr></table></figure><p>** 缓冲机制 **</p><blockquote><p>由于使用了终端设备，所以原本默认是全缓冲模式变成了行缓冲模式。所以printf是遇到了 \n 才去刷新缓冲区的。或者是当前等缓冲区满了去自动刷新。\n 是去强制刷新缓冲区。 没有加\n  那个“before”这句话就放到了输出缓冲区当中，什么时候刷新呢？ 要么等程序结束自动刷新IO，要么就是遇到一些强制刷新的函数iflush 这种，要么就等到缓冲区攒满了一次性去刷新。</p></blockquote><h2 id="34-动态内存管理"><a href="#34-动态内存管理" class="headerlink" title="34. 动态内存管理"></a>34. 动态内存管理</h2><blockquote><p>在编写程序时，通常并不知道需要处理的数据量，或者难以评估所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，就需要动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存管理原理；</p></blockquote><p>以下几个函数都存在标准 stdlib.h 中</p><h3 id="1-9-1-malloc-calloc-（分配新的内存区域）"><a href="#1-9-1-malloc-calloc-（分配新的内存区域）" class="headerlink" title="1.9.1 malloc  calloc （分配新的内存区域）"></a>1.9.1 malloc  calloc （分配新的内存区域）</h3><p><code>void *malloc(size_t, size);</code></p><p>它会在堆上分配这块连续的内存空间，并返回起始地址；</p><p><code>void *calloc(size_t nmemb, size_t size)</code></p><p>一个成员 size个大小，nmemb这么多成员的空间；连续申请多块 size大的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// 用完记得释放掉内存， 在同一个函数中做到 malloc 和 free一一对应</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span> ;i&lt;num; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>*<em>一道面试题 (提示： 这个程序当中已经产生了内存泄漏) *</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// p在这个函数当中是一个局部变量，随着func执行完毕之后，这块内存空间会丢失。导致内存泄漏，只有随着操作系统中这个进程结束掉，才会释放这100个单位的内存</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  func(p, num);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> **p, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 用一个二级指针来接受</span></span><br><span class="line">  *p = <span class="built_in">malloc</span>(n);           <span class="comment">// 此时*p 就是main函数中的p</span></span><br><span class="line">  <span class="keyword">if</span> (*p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  func(&amp;p, num);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改法二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  p = func(p, num);  <span class="comment">// 用p 来接触返回值</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-2-realloc-（调整已分配的内存区域）"><a href="#1-9-2-realloc-（调整已分配的内存区域）" class="headerlink" title="1.9.2   realloc  （调整已分配的内存区域）"></a>1.9.2   realloc  （调整已分配的内存区域）</h3><p><code>void *realloc(void *ptr, size_t size);</code></p><p>重新分配一块动态的内存空间 ,比如之前用malloc calloc分配的内存空间太大或者太小，现在把 起始地址传进去(第一个参数); 然后要size 大小的这么一段(第二个参数)；所以 realloc会在当前地址往下继续扩展，凑足size返回回来；当然，如果*ptr 开始的这个区段，没有一整块size大小的空间，那么就会去别的内存上面去寻找。直到找到之后，再返回那块空间的起始地址回来；</p><h3 id="1-9-3-free-（释放已分配的内存区域）"><a href="#1-9-3-free-（释放已分配的内存区域）" class="headerlink" title="1.9.3  free  （释放已分配的内存区域）"></a>1.9.3  free  （释放已分配的内存区域）</h3><blockquote><p>原则， 谁申请谁释放， （防止内存泄露）；如果不能做到在同一函数中做到谁申请谁释放 就在同一模块中做到这些；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 测试地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p--&gt;%d\n"</span>, *p); <span class="comment">// 0xa--&gt;0</span></span><br><span class="line"><span class="built_in">free</span>(p);                 <span class="comment">// 正确的做法是</span></span><br><span class="line">p = <span class="literal">NULL</span>;                <span class="comment">// 正确的做法是，一个指针free了之后，立即赋值 NULL</span></span><br><span class="line"><span class="comment">// free 代表着 变量p对于那片 内存空间 没有了 控制权限；所以free之后要 p = NULL</span></span><br><span class="line">*p = <span class="number">123</span>;                <span class="comment">// 实际上这是个野指针，该块内存释放掉了，有可能被其他人用来声明变量了。这里重新赋值，相当于可能把别人的变量给覆盖了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);      <span class="comment">// 123</span></span><br><span class="line">                         <span class="comment">// 测试地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p--&gt;%d\n"</span>, *p); <span class="comment">// 0x7b--&gt;145574408</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts declaration files</title>
      <link href="2021/01/21/ts-declaration-files/"/>
      <url>2021/01/21/ts-declaration-files/</url>
      
        <content type="html"><![CDATA[<h2 id="10-Declaration-Files"><a href="#10-Declaration-Files" class="headerlink" title="10. Declaration Files"></a>10. Declaration Files</h2><h3 id="10-1-Declaration-Reference"><a href="#10-1-Declaration-Reference" class="headerlink" title="10. 1 Declaration Reference"></a>10. 1 Declaration Reference</h3><p>本节显示一些API的文档以及该API的示例用法，并说明如何编写相应的声明。</p><h4 id="10-1-1-具有属性的对象"><a href="#10-1-1-具有属性的对象" class="headerlink" title="10.1.1 具有属性的对象"></a>10.1.1 具有属性的对象</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">let</span> result = myLib.makeGreeting(<span class="string">"hello, world"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"The computed greeting is:"</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = myLib.numberOfGreetings;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeGreeting</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">let</span> <span class="title">numberOfGreetings</span>: <span class="title">number</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-2-Overloaded-Functions"><a href="#10-1-2-Overloaded-Functions" class="headerlink" title="10.1.2  Overloaded Functions"></a>10.1.2  Overloaded Functions</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="keyword">let</span> x : Widget = getWidget(<span class="number">43</span>);</span><br><span class="line"><span class="keyword">let</span> arr: Widget[] = getWidget(<span class="string">"all of them"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getWidget</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">Widget</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getWidget</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">Widget</span>[]</span>;</span><br></pre></td></tr></table></figure><h4 id="10-1-3-Reusable-Types-Interfaces"><a href="#10-1-3-Reusable-Types-Interfaces" class="headerlink" title="10.1.3 Reusable Types (Interfaces)"></a>10.1.3 Reusable Types (Interfaces)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line">greet(&#123;</span><br><span class="line">  greeting: <span class="string">"hello world"</span>,</span><br><span class="line">  duration: <span class="number">4000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">interface</span> GreetingSettings &#123;</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  duration?: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">setting: GreetingSettings</span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h4 id="10-1-4-Reusable-Types-Type-Aliases"><a href="#10-1-4-Reusable-Types-Type-Aliases" class="headerlink" title="10.1.4 Reusable Types (Type Aliases)"></a>10.1.4 Reusable Types (Type Aliases)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"howdy"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MyGreeter <span class="keyword">extends</span> Greeter &#123;&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">"hello"</span>);</span><br><span class="line">greet(getGreeting);</span><br><span class="line">greet(<span class="keyword">new</span> MyGreeter());</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用类型别名来简化类型：</span></span><br><span class="line"><span class="keyword">type</span> GreetingLike = <span class="built_in">string</span> | <span class="function">(<span class="params">(<span class="params"></span>)=&gt; <span class="built_in">string</span></span>) | <span class="params">MyGreeter</span>;</span></span><br><span class="line"><span class="function"><span class="params">declare</span> <span class="params">function</span> <span class="params">greet</span>(<span class="params">g: GreetingLike</span>): <span class="params">void</span>;</span></span><br></pre></td></tr></table></figure><h4 id="10-1-5-组织类型"><a href="#10-1-5-组织类型" class="headerlink" title="10.1.5 组织类型"></a>10.1.5 组织类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Greeter(<span class="string">"Hello"</span>);</span><br><span class="line">g.log(&#123; verbose: <span class="literal">true</span> &#125;);</span><br><span class="line">g.alert(&#123; modal: <span class="literal">false</span>, title: <span class="string">"Current Greeting"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用命名空间去组织类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> GreetingLib &#123;</span><br><span class="line">  <span class="keyword">interface</span> LogOptions &#123;</span><br><span class="line">    verbose?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> AlertOptions &#123;</span><br><span class="line">    modal: <span class="built_in">boolean</span>;</span><br><span class="line">    title?: <span class="built_in">string</span>;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用嵌套的命名空间来声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> GreetingLib.Options &#123;</span><br><span class="line">  <span class="comment">// Refer to via GreetingLib.Options.Log</span></span><br><span class="line">  <span class="keyword">interface</span> Log &#123;</span><br><span class="line">    verbose?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> Alert &#123;</span><br><span class="line">    modal: <span class="built_in">boolean</span>;</span><br><span class="line">    title?: <span class="built_in">string</span>;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-6-Classes"><a href="#10-1-6-Classes" class="headerlink" title="10.1.6 Classes"></a>10.1.6 Classes</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="keyword">const</span> myGreeter = <span class="keyword">new</span> Greeter(<span class="string">"hello, world"</span>);</span><br><span class="line">myGreeter.greeting = <span class="string">"howdy"</span>;</span><br><span class="line">myGreeter.showGreeting();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SpecialGreeter <span class="keyword">extends</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"Very special greetings"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 使用 declare class 来描述类或类对象。类可以具有属性和方法以及构造函数。</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">greeting: <span class="built_in">string</span></span>);</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  showGreeting(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-1-7-Global-Variables"><a href="#10-1-7-Global-Variables" class="headerlink" title="10.1.7 Global Variables"></a>10.1.7 Global Variables</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="built_in">console</span>.log(f00/<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> foo: <span class="built_in">number</span></span><br></pre></td></tr></table></figure><h4 id="10-1-8-Global-Functions"><a href="#10-1-8-Global-Functions" class="headerlink" title="10.1.8 Global Functions"></a>10.1.8 Global Functions</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line">greet(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">str: <span class="built_in">string</span></span>):<span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h3 id="10-2-Library-Structures"><a href="#10-2-Library-Structures" class="headerlink" title="10.2 Library Structures"></a>10.2 Library Structures</h3><p>针对不同类型的库，编写对应类型的声明文件。你是通过cdn获取这些库还是通过npm获取；你是require引入还是import引入；</p><h4 id="10-2-1-模块化的库"><a href="#10-2-1-模块化的库" class="headerlink" title="10.2.1 模块化的库"></a>10.2.1 模块化的库</h4><p>几乎每个现代的Node.js库都属于模块家族。这些类型的库仅在带有模块加载器的JS环境中工作。例如，express仅在Node.js中有效，并且必须使用CommonJS require函数加载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someLib = <span class="built_in">require</span>(<span class="string">"someLib"</span>);</span><br><span class="line">define(..., [<span class="string">'someLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">someLib</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>从代码中识别模块库</strong></p><ul><li>Unconditional calls to <code>require</code> or <code>define</code></li><li>Declarations like <code>import * as a from &#39;b&#39;;</code> or <code>export c;</code></li><li>Assignments to <code>exports</code> or <code>module.exports</code></li></ul><p>They will rarely have:</p><ul><li>Assignments to properties of <code>window</code> or <code>global</code></li></ul><h5 id="10-2-1-1-Modules-d-ts"><a href="#10-2-1-1-Modules-d-ts" class="headerlink" title="10.2.1.1 Modules.d.ts"></a>10.2.1.1 Modules.d.ts</h5><ul><li>常见的Commonjs 模式</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getArrayLength,</span><br><span class="line">  maxInterval,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This can be described by the following .d.ts:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br></pre></td></tr></table></figure><ul><li>Es  module</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This would have the following .d.ts equivalent:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Default Exports</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="regexp">/hello( world)?/</span>;</span><br><span class="line"><span class="comment">// .d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> helloWorld: <span class="built_in">RegExp</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> helloWorld;</span><br></pre></td></tr></table></figure><p>CommonJS中的一种导出样式是导出函数。由于函数也是对象，因此可以在导出中添加额外的字段。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.slice;</span><br><span class="line">&#125;</span><br><span class="line">getArrayLength.maxInterval = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = getArrayLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Which can be described with:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 需要在 tsconfig.json 中设置 esModuleInterop: true</span></span><br></pre></td></tr></table></figure><p>如果没有在 tsconfig.json 中设置 esModuleInterop: true</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> getArrayLength &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">const</span> maxInterval: <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 export= 语法</span></span><br><span class="line"><span class="keyword">export</span> = getArrayLength;</span><br></pre></td></tr></table></figure><ul><li>模块中的类型</li></ul><p>可能需要提供一种不存在的JavaScript代码类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    length: getArrayLength(arr),</span><br><span class="line">    firstObject: arr[<span class="number">0</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getArrayMetadata,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// described</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayMetadata = &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  firstObject: <span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>):<span class="title">ArrayMetadata</span></span>;</span><br><span class="line"><span class="comment">// 泛型优化版</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayMetadata&lt;ArrType&gt; = &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  firstObject: ArrType | <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArrayMetadata</span>&lt;<span class="title">ArrType</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  arr: ArrType[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ArrayMetadata</span>&lt;<span class="title">ArrType</span>&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li>Namespaces in Module Code</li></ul><p>试图描述JavaScript运行时的关联可能很棘手。如果类似ES模块的语法没有提供足够的工具来描述导出，则可以使用名称空间。</p><p>您可能有足够复杂的类型来描述，因此您选择在.d.ts中对它们进行命名空间：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时可用的JavaScript类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> API &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">baseURL: <span class="built_in">string</span></span>);</span><br><span class="line">  getInfo(opts: API.InfoRequest): API.InfoResponse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This namespace is merged with the API class and allows for consumers, and this file</span></span><br><span class="line"><span class="comment">// to have types which are nested away in their own sections.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> API &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> InfoRequest &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> InfoResponse &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用<code>export as namespace</code>声明模块将在UMD上下文中的全局范围内可用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> namespaces moduleName;</span><br></pre></td></tr></table></figure><ul><li>Template</li></ul><p>为了让您了解所有这些部分如何组合在一起，这里是制作新模块时的参考.d.ts。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果此模块是在模块加载程序环境之外加载时公开全局变量“ myLib”的UMD模块，请在此处声明该全局变量。</span></span><br><span class="line"><span class="comment">否则，删除此声明。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module exports functions, declare them like so.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myOtherFunction</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ You can declare types that are available via importing the module */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ You can declare properties of the module using const, let, or var */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myField: <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><ul><li>库文件布局</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myLib</span><br><span class="line">  +---- index.js</span><br><span class="line">  +---- foo.js</span><br><span class="line">  +---- bar</span><br><span class="line">         +---- index.js</span><br><span class="line">         +---- baz.js</span><br></pre></td></tr></table></figure><ul><li>声明文件布局应为</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@types&#x2F;myLib</span><br><span class="line">  +---- index.d.ts</span><br><span class="line">  +---- foo.d.ts</span><br><span class="line">  +---- bar</span><br><span class="line">         +---- index.d.ts</span><br><span class="line">         +---- baz.d.ts</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thest could be imported as</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"myLib"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"myLib/foo"</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">require</span>(<span class="string">"myLib/bar"</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">require</span>(<span class="string">"myLib/bar/baz"</span>);</span><br></pre></td></tr></table></figure><ul><li>Testing your types</li></ul><p>If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:</p><blockquote><ol><li>Create a new folder in <code>node_modules/@types/[libname]</code></li><li>Create an <code>index.d.ts</code> in that folder, and copy the example in</li><li>See where your usage of the module breaks, and start to fill out the index.d.ts</li><li>When you’re happy, clone <a href="https://github.com/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped/DefinitelyTyped</a> and follow the instructions in the README.</li></ol></blockquote><p>Otherwise</p><blockquote><ol><li>Create a new file in the root of your source tree: <code>[libname].d.ts</code></li><li>Add <code>declare module &quot;[libname]&quot; { }</code></li><li>Add the template inside the braces of the declare module, and see where your usage breaks</li></ol></blockquote><h5 id="10-2-1-2-module-function"><a href="#10-2-1-2-module-function" class="headerlink" title="10.2.1.2  module:function"></a>10.2.1.2  module:function</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greeter <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line">greeter(<span class="number">2</span>);</span><br><span class="line">greeter(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></table></figure><p>如果模块可以像一个函数一样被调用，需使用module-function 模版</p><p>要同时通过UMD和模块引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file for function modules.</span></span><br><span class="line"><span class="comment"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that ES6 modules cannot directly export class objects.</span></span><br><span class="line"><span class="comment">// This file should be imported using the CommonJS-style:</span></span><br><span class="line"><span class="comment">//   import x = require('[~THE MODULE~]');</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Alternatively, if --allowSyntheticDefaultImports or</span></span><br><span class="line"><span class="comment">// --esModuleInterop is turned on, this file can also be</span></span><br><span class="line"><span class="comment">// imported as a default import:</span></span><br><span class="line"><span class="comment">//   import x from '[~THE MODULE~]';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Refer to the TypeScript documentation at</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require</span></span><br><span class="line"><span class="comment">// to understand common workarounds for this limitation of ES6 modules.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when</span></span><br><span class="line"><span class="comment"> *~ loaded outside a module loader environment, declare that global here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this declaration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myFuncLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This declaration specifies that the function</span></span><br><span class="line"><span class="comment"> *~ is the exported object from the file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> = Greeter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This example shows how to have multiple overloads for your function */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">Greeter</span>.<span class="title">NamedReturnType</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">length: <span class="built_in">number</span></span>): <span class="title">Greeter</span>.<span class="title">LengthReturnType</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want to expose types from your module as well, you can</span></span><br><span class="line"><span class="comment"> *~ place them in this block. Often you will want to describe the</span></span><br><span class="line"><span class="comment"> *~ shape of the return type of the function; that type should</span></span><br><span class="line"><span class="comment"> *~ be declared in here, as this example shows.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ Note that if you decide to include this namespace, the module can be</span></span><br><span class="line"><span class="comment"> *~ incorrectly imported as a namespace object, unless</span></span><br><span class="line"><span class="comment"> *~ --esModuleInterop is turned on:</span></span><br><span class="line"><span class="comment"> *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Greeter &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> LengthReturnType &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> NamedReturnType &#123;</span><br><span class="line">    firstName: <span class="built_in">string</span>;</span><br><span class="line">    lastName: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*~ If the module also has properties, declare them here. For example,</span></span><br><span class="line"><span class="comment">   *~ this declaration says that this code is legal:</span></span><br><span class="line"><span class="comment">   *~   import f = require('super-greeter');</span></span><br><span class="line"><span class="comment">   *~   console.log(f.defaultName);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> defaultName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> defaultLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-1-2-module-class"><a href="#10-2-1-2-module-class" class="headerlink" title="10.2.1.2  module:class"></a>10.2.1.2  module:class</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeter = <span class="built_in">require</span>(<span class="string">"super-greeter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">new</span> Greeter();</span><br><span class="line">greeter.greet();</span><br></pre></td></tr></table></figure><p>如果导出的对象是一个类的话；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module template file for class modules.</span></span><br><span class="line"><span class="comment"> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that ES6 modules cannot directly export class objects.</span></span><br><span class="line"><span class="comment">// This file should be imported using the CommonJS-style:</span></span><br><span class="line"><span class="comment">//   import x = require('[~THE MODULE~]');</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Alternatively, if --allowSyntheticDefaultImports or</span></span><br><span class="line"><span class="comment">// --esModuleInterop is turned on, this file can also be</span></span><br><span class="line"><span class="comment">// imported as a default import:</span></span><br><span class="line"><span class="comment">//   import x from '[~THE MODULE~]';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Refer to the TypeScript documentation at</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require</span></span><br><span class="line"><span class="comment">// to understand common workarounds for this limitation of ES6 modules.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when</span></span><br><span class="line"><span class="comment"> *~ loaded outside a module loader environment, declare that global here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this declaration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> myClassLib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This declaration specifies that the class constructor function</span></span><br><span class="line"><span class="comment"> *~ is the exported object from the file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> = MyClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Write your module's methods and properties in this class */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> MyClass &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">customGreeting?: <span class="built_in">string</span></span>);</span><br><span class="line"></span><br><span class="line">  greet: <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  myMethod(opts: MyClass.MyClassMethodOptions): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want to expose types from your module as well, you can</span></span><br><span class="line"><span class="comment"> *~ place them in this block.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ Note that if you decide to include this namespace, the module can be</span></span><br><span class="line"><span class="comment"> *~ incorrectly imported as a namespace object, unless</span></span><br><span class="line"><span class="comment"> *~ --esModuleInterop is turned on:</span></span><br><span class="line"><span class="comment"> *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> MyClass &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> MyClassMethodOptions &#123;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    height?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-1-3-Module-plugin"><a href="#10-2-1-3-Module-plugin" class="headerlink" title="10.2.1.3  Module: plugin"></a>10.2.1.3  Module: plugin</h5><p>If you have a module which when imported, makes changes to other modules use template</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jest = <span class="built_in">require</span>(<span class="string">'jest'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jest-matchers-files"</span>);</span><br></pre></td></tr></table></figure><p>when you want to work with JavaScript code which extends another library.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normal Greeter API</span></span><br><span class="line">greeter(<span class="number">2</span>);</span><br><span class="line">greeter(<span class="string">"Hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we extend the object with a new function at runtime</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"hyper-super-greeter"</span>;</span><br><span class="line">greeter.hyperGreet();</span><br></pre></td></tr></table></figure><p>The definition for “super-greeter”</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*~ This example shows how to have 多个重载 for your function */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> GreeterFunction &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">  (time: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This example shows how to export 一个接口指定的function  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> greeter: GreeterFunction;</span><br></pre></td></tr></table></figure><p>We can extend the existing module like the following:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the module plugin template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ On this line, import the module which this module adds to */</span></span><br><span class="line"><span class="keyword">import</span> &#123; greeter &#125; <span class="keyword">from</span> <span class="string">"super-greeter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Here, declare the same module as the one you imported above</span></span><br><span class="line"><span class="comment"> *~ then we expand the existing declaration of the greeter function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> "super-greeter" &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> GreeterFunction &#123;</span><br><span class="line">    <span class="comment">/** Greets even better! */</span></span><br><span class="line">    hyperGreet(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2-Global-Libraries"><a href="#10-2-2-Global-Libraries" class="headerlink" title="10.2.2 Global Libraries"></a>10.2.2 Global Libraries</h4><p>全局库是可以从全局范围访问的库（即，无需使用任何形式的导入）。许多库只是公开一个或多个全局变量供使用。例如jquery;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(() =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--一般情况，全局库的使用方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://a.great.cdn.for/someLib.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，最流行的可全局库 实际上是作为 UMD标准 编写的（请参见下文）。 UMD库文档很难与全局库文档区分开。在编写全局声明文件之前，请确保该库不是UMD。</p><p><strong>从代码中识别Global Library</strong></p><p>查看全局库的代码时，通常会看到：</p><ul><li>Top-level <code>var</code> statements or <code>function</code> declarations</li><li>One or more assignments to <code>window.someName</code></li><li>Assumptions that DOM primitives like <code>document</code> or <code>window</code> exist</li></ul><p>You <em>won’t</em> see:</p><ul><li>Checks for, or usage of, module loaders like <code>require</code> or <code>define</code></li><li>CommonJS/Node.js-style imports of the form <code>var fs = require(&quot;fs&quot;);</code></li><li>Calls to <code>define(...)</code></li><li>Documentation describing how to <code>require</code> or import the library</li></ul><h5 id="10-2-2-1-Global-d-ts"><a href="#10-2-2-1-Global-d-ts" class="headerlink" title="10.2.2.1  Global.d.ts"></a>10.2.2.1  Global.d.ts</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If this library is callable (e.g. can be invoked as myLib(3)),</span></span><br><span class="line"><span class="comment"> *~ include those call signatures here.</span></span><br><span class="line"><span class="comment"> *~ Otherwise, delete this section.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">myLib</span>(<span class="params">a: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">myLib</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If you want the name of this library to be a valid type name,</span></span><br><span class="line"><span class="comment"> *~ you can do so here.</span></span><br><span class="line"><span class="comment"> *~</span></span><br><span class="line"><span class="comment"> *~ For example, this allows us to write 'var x: myLib';</span></span><br><span class="line"><span class="comment"> *~ Be sure this actually makes sense! If it doesn't, just</span></span><br><span class="line"><span class="comment"> *~ delete this declaration and add types inside the namespace below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> myLib &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  extras?: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your library has properties exposed on a global variable,</span></span><br><span class="line"><span class="comment"> *~ place them here.</span></span><br><span class="line"><span class="comment"> *~ You should also place types (interfaces and type alias) here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="comment">//~ We can write 'myLib.timeout = 50;'</span></span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can access 'myLib.version', but not change it</span></span><br><span class="line">  <span class="keyword">const</span> version: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ There's some class we can create via 'let c = new myLib.Cat(42)'</span></span><br><span class="line">  <span class="comment">//~ Or reference e.g. 'function f(c: myLib.Cat) &#123; ... &#125;</span></span><br><span class="line">  <span class="keyword">class</span> Cat &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">number</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~ We can read 'c.age' from a 'Cat' instance</span></span><br><span class="line">    readonly age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~ We can invoke 'c.purr()' from a 'Cat' instance</span></span><br><span class="line">    purr(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can declare a variable as</span></span><br><span class="line">  <span class="comment">//~   'var s: myLib.CatSettings = &#123; weight: 5, name: "Maru" &#125;;'</span></span><br><span class="line">  <span class="keyword">interface</span> CatSettings &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    tailLength?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can write 'const v: myLib.VetID = 42;'</span></span><br><span class="line">  <span class="comment">//~  or 'const v: myLib.VetID = "bob";'</span></span><br><span class="line">  <span class="keyword">type</span> VetID = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkCat</span>(<span class="params">c: Cat, s?: VetID</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-2-2-Global-Modifying-Module"><a href="#10-2-2-2-Global-Modifying-Module" class="headerlink" title="10.2.2.2 Global: Modifying Module"></a>10.2.2.2 Global: Modifying Module</h5><p>导入全局变量的模块会在全局范围内更改现有值。例如，可能存在一个库，该库在导入时将新成员添加到String.prototype。由于存在运行时冲突的可能性，该模式有些危险，但是我们仍然可以为其编写声明文件。</p><p><strong>识别全局修改模块</strong></p><p>全局修改模块通常易于从其文档中识别，它们类似全局插件，但是需要require方法的调用 才能激活它们的副作用；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'require' call that doesn't use its return value</span></span><br><span class="line"><span class="keyword">var</span> unused = <span class="built_in">require</span>(<span class="string">"magic-string-time"</span>);</span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"magic-string-time"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"hello, world"</span>;</span><br><span class="line"><span class="comment">// Creates new methods on built-in types</span></span><br><span class="line"><span class="built_in">console</span>.log(x.startsWithHello());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// Creates new methods on built-in types</span></span><br><span class="line"><span class="built_in">console</span>.log(y.reverseAndSort());</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span></span><br><span class="line"><span class="comment">// Project: [~THE PROJECT NAME~]</span></span><br><span class="line"><span class="comment">// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ This is the global-modifying module template file. You should rename it to index.d.ts</span></span><br><span class="line"><span class="comment"> *~ and place it in a folder with the same name as the module.</span></span><br><span class="line"><span class="comment"> *~ For example, if you were writing a file for "super-greeter", this</span></span><br><span class="line"><span class="comment"> *~ file should be 'super-greeter/index.d.ts'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ Note: If your global-modifying module is callable or constructable, you'll</span></span><br><span class="line"><span class="comment"> *~ need to combine the patterns here with those in the module-class or module-function</span></span><br><span class="line"><span class="comment"> *~ template files</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="comment">/*~ Here, declare things that go in the global namespace, or augment</span></span><br><span class="line"><span class="comment">   *~ existing declarations in the global namespace</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> String &#123;</span><br><span class="line">    fancyFormat(opts: StringFormatOptions): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your module exports types or values, write them as usual */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringFormatOptions &#123;</span><br><span class="line">  fancinessLevel: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ For example, declaring a method on the module (in addition to its global side effects) */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-UMD"><a href="#10-2-3-UMD" class="headerlink" title="10.2.3 UMD"></a>10.2.3 UMD</h4><p>UMD模块既可以用作模块（通过import），也可以用作全局模块（在没有模块加载器的环境中运行时）。这样编写了许多流行的库，例如Moment.js。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs 环境下</span></span><br><span class="line"><span class="keyword">import</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="comment">// 浏览器环境下</span></span><br><span class="line"><span class="built_in">console</span>.log(mement.format());</span><br></pre></td></tr></table></figure><p><strong>umd模版</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([<span class="string">"libName"</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"libName"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.returnExports = factory(root.libName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span> ? self : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Use b in some fashion.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Just return a value to define the module export.</span></span><br><span class="line">    <span class="comment">// This example returns an object, but the module</span></span><br><span class="line">    <span class="comment">// can return a function as the exported value.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>UMD库的文档通常还会演示一个显示require的“在Node.js中使用”示例，以及一个使用<code>script</code>标记加载该脚本的“在浏览器中使用”示例。</p><h4 id="10-2-4-Consuming-Dependencies"><a href="#10-2-4-Consuming-Dependencies" class="headerlink" title="10.2.4 Consuming Dependencies"></a>10.2.4 Consuming Dependencies</h4><p>你的库可能具有集中依赖关系，下面会说明如何将它们导入声明文件；</p><ul><li>Dependencies on Global Libraries</li></ul><p>If your library depends on a global library, use a <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> directive:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="someLib" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">someLib</span>.<span class="title">thing</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Dependencies on Modules</li></ul><p>If your library depends on a module, use an <code>import</code> statement:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">"moment"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">moment</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Dependencies on UMD libraries</li></ul><p>From a Global Library</p><p>If your global library depends on a UMD module, use a <code>/// &lt;reference types</code> directive:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="moment" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>): <span class="title">moment</span></span>;</span><br></pre></td></tr></table></figure><p>From a Module or UMD Library</p><p>If your module or UMD library depends on a UMD library, use an <code>import</code> statement:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> someLib <span class="keyword">from</span> <span class="string">"someLib"</span>;</span><br></pre></td></tr></table></figure><p>Do <em>not</em> use a <code>/// &lt;reference</code> directive 来声明对UMD库的依赖！</p><h4 id="10-2-5-Preventing-Name-Conflicts"><a href="#10-2-5-Preventing-Name-Conflicts" class="headerlink" title="10.2.5 Preventing Name Conflicts"></a>10.2.5 Preventing Name Conflicts</h4><p>编写全局声明文件时，可以在全局范围内定义许多类型。强烈不建议这样做，因为当项目中有许多声明文件时，它可能导致无法解决的名称冲突。</p><p>库定义的任何全局变量只声明 namespaces</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> cats &#123;</span><br><span class="line"><span class="keyword">interface</span> KittySettings &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// But not</span></span><br><span class="line"> <span class="comment">// at top-level</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span> CatsKittySettings&#123;&#125;</span><br></pre></td></tr></table></figure><p>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</p><h3 id="10-3-Do’s-and-Don’ts"><a href="#10-3-Do’s-and-Don’ts" class="headerlink" title="10.3 Do’s and Don’ts"></a>10.3 Do’s and Don’ts</h3><h4 id="10-3-1-基本类型"><a href="#10-3-1-基本类型" class="headerlink" title="10.3.1 基本类型"></a>10.3.1 基本类型</h4><p>不要使用<code>Number,String,Boolean, Symbol, or Object</code> 等类型；</p><h4 id="10-3-2-any"><a href="#10-3-2-any" class="headerlink" title="10.3.2 any"></a>10.3.2 any</h4><p>any类型你懂得，尽量别用。anyScript毫无意义；</p><h4 id="10-3-3-Callback-Types"><a href="#10-3-3-Callback-Types" class="headerlink" title="10.3.3 Callback Types"></a>10.3.3 Callback Types</h4><p>对于返回值被忽略的回调，别使用any, 使用void更好；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: () =&gt; <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: () =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-4-重载和回调函数"><a href="#10-3-4-重载和回调函数" class="headerlink" title="10.3.4 重载和回调函数"></a>10.3.4 重载和回调函数</h4><p>不要编写仅在回调函数上有所不同的单独重载：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params">action: () =&gt; <span class="built_in">void</span>, timeout?: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (done: DoneFn) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Do write a single overload using the maximum arity:</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAll</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  action: (done: DoneFn) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><p>原因：回调忽略参数始终是合法的，因此不需要较短的重载。首先提供一个较短的回调允许输入错误类型的函数，因为它们与第一个重载匹配。</p><h4 id="10-3-5-function-重载"><a href="#10-3-5-function-重载" class="headerlink" title="10.3.5 function 重载"></a>10.3.5 function 重载</h4><p>不要在更具体的重载之前放置更一般的重载；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLElement</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLDivElement</span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem: HTMLDivElement;</span><br><span class="line"><span class="keyword">var</span> x = fn(myElem); <span class="comment">// x: any, wat?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过将更一般的签名放在更具体的签名之后来对重载进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLDivElement</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLElement</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem: HTMLDivElement;</span><br><span class="line"><span class="keyword">var</span> x = fn(myElem); <span class="comment">// x: string, :)</span></span><br></pre></td></tr></table></figure><p>原因：TypeScript在解决函数调用时选择第一个匹配的重载。当较早的过载比较晚的过载“更普遍”时，较晚的过载实际上是隐藏的，无法调用。</p><h4 id="10-3-6-Use-Optional-Parameters"><a href="#10-3-6-Use-Optional-Parameters" class="headerlink" title="10.3.6 Use Optional Parameters"></a>10.3.6 Use Optional Parameters</h4><p>不要写一些仅在尾随参数上有所不同的重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">interface</span> Example &#123;</span><br><span class="line">  diff(one: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two: <span class="built_in">string</span>, three: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">interface</span> Example &#123;</span><br><span class="line">  diff(one: <span class="built_in">string</span>, two?: <span class="built_in">string</span>, three?: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-7-Union-Types"><a href="#10-3-7-Union-Types" class="headerlink" title="10.3.7 Union Types"></a>10.3.7 Union Types</h4><p>不要只在一个参数位置编写因类型而异的重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line"><span class="keyword">interface</span> Moment &#123;</span><br><span class="line">  utcOffset(): <span class="built_in">number</span>;</span><br><span class="line">  utcOffset(b: <span class="built_in">number</span>): Moment;</span><br><span class="line">  utcOffset(b: <span class="built_in">string</span>): Moment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">interface</span> Moment &#123;</span><br><span class="line">  utcOffset(): <span class="built_in">number</span>;</span><br><span class="line">  utcOffset(b: <span class="built_in">number</span> | <span class="built_in">string</span>): Moment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// When written with separate overloads, incorrectly an error</span></span><br><span class="line">  <span class="comment">// When written with union types, correctly OK</span></span><br><span class="line">  <span class="keyword">return</span> moment().utcOffset(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-Deep-Dive"><a href="#10-4-Deep-Dive" class="headerlink" title="10.4 Deep Dive"></a>10.4 Deep Dive</h3><h4 id="10-4-1-Namespaces"><a href="#10-4-1-Namespaces" class="headerlink" title="10.4.1 Namespaces"></a>10.4.1 Namespaces</h4><p>类型可以存在于名称空间中。例如，如果我们有声明let x：A.B.C，则说类型C来自A.B命名空间。A， B 不一定必须是类型或者值</p><h4 id="10-4-2-简单组合，一个名字多种含义"><a href="#10-4-2-简单组合，一个名字多种含义" class="headerlink" title="10.4.2 简单组合，一个名字多种含义"></a>10.4.2 简单组合，一个名字多种含义</h4><p>给定名称A，我们最多可以找到A的三种不同含义：类型，值或名称空间。名称的解释方式取决于所使用的上下文。例如，在一个声明文件中 中 <code>let m：A.A = A ;</code>，首先将A用作namespaces，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！</p><h5 id="10-4-2-1-User-Combinations"><a href="#10-4-2-1-User-Combinations" class="headerlink" title="10.4.2.1 User Combinations"></a>10.4.2.1 User Combinations</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> SomeVar: &#123; a: SomeType &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumed</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">"./foo"</span>;</span><br><span class="line"><span class="keyword">let</span> x: foo.SomeType = foo.SomeVar.a;</span><br><span class="line"><span class="built_in">console</span>.log(x.count);</span><br></pre></td></tr></table></figure><p>这种方法不错，但我们可能会认为 SomeType 和 SomeVar 紧密相关，因此您希望它们具有相同的名称。我们可以使用合并相同的名称Bar呈现这两个不同的对象；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> Bar: &#123;a : Bar&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Bar &#123;</span><br><span class="line">count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumed</span></span><br><span class="line"><span class="keyword">import</span> &#123; Bar &#125; <span class="keyword">from</span> <span class="string">"./foo"</span>;</span><br><span class="line"><span class="keyword">let</span> x: Bar = Bar.a;</span><br><span class="line"><span class="built_in">console</span>.log(x.count);</span><br></pre></td></tr></table></figure><p>我们在这里使用Bar作为类型和值。请注意，我们不必将Bar值声明为Bar类型，它们是独立的。</p><h5 id="10-4-2-2-Advanced-Combinations"><a href="#10-4-2-2-Advanced-Combinations" class="headerlink" title="10.4.2.2 Advanced Combinations"></a>10.4.2.2 Advanced Combinations</h5><p>某些声明可以跨多个声明进行组合，比如 class C {}  和 interface C{} 可以共存，并且都给类型C贡献了属性。 只要不造成冲突，就是合法的，一般的经验法则是， 值始终会与同名的其他值发生冲突，除非将它们声明为namespaces,；</p><p>s, types will conflict if they are declared with a type alias declaration (<code>type s = string</code>), and namespaces never conflict.</p><ul><li>Adding using an `interface</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: Foo = ...;</span><br><span class="line"><span class="built_in">console</span>.log(a.x + a.y); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this also works with classes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: Foo = ...;</span><br><span class="line"><span class="built_in">console</span>.log(a.x + a.y); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that we cannot add to type aliases (type s = string;) using an interface.</span></span><br></pre></td></tr></table></figure><ul><li>Adding using a namespace</li></ul><p>可以使用namespace声明以任何不会造成冲突的方式添加新的类型，值和namespace。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给class添加一个静态成员</span></span><br><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">let</span> y = C.x; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>在此示例中，我们向C的静态侧（其构造函数）添加了一个值。这是因为我们添加了一个值，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。</p><p>We could also add a namespaced type to a class:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> D &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y: C.D; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>在我们为其编写 namespace 声明之前，没有 <code>namespace C</code>。作为命名空间的C的含义与该类创建的C的值或类型的含义不冲突。</p><p>我们可以使用名称空间声明执行许多不同的合并;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Y &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Z &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... elsewhere ...</span></span><br><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> Y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Z &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> C &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> X = <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>In this example, the first block creates the following name meanings:</p><ul><li>A value <code>X</code> (because the <code>namespace</code> declaration contains a value, <code>Z</code>)</li><li>A namespace <code>X</code> (because the <code>namespace</code> declaration contains a type, <code>Y</code>)</li><li>A type <code>Y</code> in the <code>X</code> namespace</li><li>A type <code>Z</code> in the <code>X</code> namespace (the instance shape of the class)</li><li>A value <code>Z</code> that is a property of the <code>X</code> value (该class的构造函数)</li></ul><p>The second block creates the following name meanings:</p><ul><li>A value <code>Y</code> (of type <code>number</code>) that is a property of the <code>X</code> value</li><li>A namespace <code>Z</code></li><li>A value <code>Z</code> that is a property of the <code>X</code> value</li><li>A type <code>C</code> in the <code>X.Z</code> namespace</li><li>A value <code>C</code> that is a property of the <code>X.Z</code> value</li><li>A type <code>X</code></li></ul><h3 id="10-5-Publish-to-npm"><a href="#10-5-Publish-to-npm" class="headerlink" title="10.5 Publish to npm"></a>10.5 Publish to npm</h3><h4 id="10-5-1-两种发布方法"><a href="#10-5-1-两种发布方法" class="headerlink" title="10.5.1 两种发布方法"></a>10.5.1 两种发布方法</h4><ol><li>bundling with your npm package</li><li>publishing to the <a href="https://www.npmjs.com/~types" target="_blank" rel="noopener">@types organization</a> on npm.</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="..." /&gt;</span></span><br><span class="line"><span class="comment">// Don’t use /// &lt;reference path="..." /&gt; in your declaration files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference path="../typescript/lib/typescriptServices.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do use /// &lt;reference types="..." /&gt; instead.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types="typescript" /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="10-5-2-Packaging-dependent-declarations"><a href="#10-5-2-Packaging-dependent-declarations" class="headerlink" title="10.5.2 Packaging dependent declarations"></a>10.5.2 Packaging dependent declarations</h4><p>If your type definitions depend on another package:</p><ul><li><em>Don’t</em> combine it with yours, keep each in their own file.</li><li><em>Don’t</em> copy the declarations in your package either.</li><li><em>Do</em> depend on the npm type declaration package if it doesn’t package its declaration files.</li></ul><h4 id="10-5-3-Publish-to-types"><a href="#10-5-3-Publish-to-types" class="headerlink" title="10.5.3 Publish to @types"></a>10.5.3 Publish to @types</h4><p>Packages under the <a href="https://www.npmjs.com/~types" target="_blank" rel="noopener">@types</a> organization are published automatically from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a> using the <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher" target="_blank" rel="noopener">types-publisher tool</a>. To get your declarations published as an @types package, please submit a pull request to <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a>. You can find more details in the <a href="http://definitelytyped.org/guides/contributing.html" target="_blank" rel="noopener">contribution guidelines page</a>.</p><h3 id="10-6-Find-and-Install-Declaration-Files"><a href="#10-6-Find-and-Install-Declaration-Files" class="headerlink" title="10.6 Find and Install Declaration Files"></a>10.6 Find and Install Declaration Files</h3><ul><li>loadsh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/lodash</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 npm install 了 类型声明</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line">_.padStart(<span class="string">"hi"</span>, <span class="number">20</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or if you’re not using modules, you can just use the global variable _.</span></span><br><span class="line">_.padStart(<span class="string">"Hello TypeScript!"</span>, <span class="number">20</span>, <span class="string">" "</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts modules</title>
      <link href="2021/01/20/ts-modules/"/>
      <url>2021/01/20/ts-modules/</url>
      
        <content type="html"><![CDATA[<h2 id="6-Modules"><a href="#6-Modules" class="headerlink" title="6. Modules"></a>6. Modules</h2><h3 id="6-1-import-export"><a href="#6-1-import-export" class="headerlink" title="6.1 import/export"></a>6.1 import/export</h3><p>模块是在自己的范围内执行的，而不是在全局范围内执行的；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用导出形式之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种导入形式将其导入。</p><p>模块是声明性的，模块之间的关系是根据文件级别的导入和导出指定的；</p><p>模块使用模块加载器相互导入， 在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。</p><h4 id="6-1-1-export"><a href="#6-1-1-export" class="headerlink" title="6.1.1 export"></a>6.1.1 export</h4><p>可以通过添加export关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重命名导出</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure><p><strong>重新导出不会将其导入本地，也不会引入局部变量。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParseIntBasedZipCodeValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(s).toString() === s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export original validator but rename it</span></span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> RegExpBasedZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br></pre></td></tr></table></figure><p><strong>导出所有</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./StringValidator"</span>; <span class="comment">// exports 'StringValidator' interface</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>; <span class="comment">// exports 'ZipCodeValidator' class and 'numberRegexp' constant value</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./ParseIntBasedZipCodeValidator"</span>; <span class="comment">//  exports the 'ParseIntBasedZipCodeValidator' class</span></span><br><span class="line"><span class="comment">// and re-exports 'RegExpBasedZipCodeValidator' as alias</span></span><br><span class="line"><span class="comment">// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'</span></span><br><span class="line"><span class="comment">// module.</span></span><br></pre></td></tr></table></figure><h4 id="6-1-2-import"><a href="#6-1-2-import" class="headerlink" title="6.1.2 import"></a>6.1.2 import</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single export</span></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="comment">// renamed</span></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> ZCV &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZCV();</span><br><span class="line"><span class="comment">// 将整个模块导入单个变量，并使用它来访问模块导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.ZipCodeValidator();</span><br><span class="line"><span class="comment">// 某些模块会设置一些可由其他模块使用的全局状态。这些模块可能没有任何出口</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./my-module.js"</span></span><br></pre></td></tr></table></figure><h4 id="6-1-3-default-exports"><a href="#6-1-3-default-exports" class="headerlink" title="6.1.3 default exports"></a>6.1.3 default exports</h4><blockquote><p>默认导出</p></blockquote><p>​        每个模块可以选择导出默认导出。默认导出用关键字<code>default</code>标记；每个模块只能有一个默认导出。默认导出使用其他导入形式导入。</p><p>​        默认出口真的很方便。例如，像jQuery之类的库可能具有jQuery或$的默认导出，我们也可能以$或jQuery的名称导入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> $:JQuery</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.ts</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">"jquery"</span>;</span><br><span class="line">$(<span class="string">"button"</span>).html(<span class="string">"xxx"</span>)</span><br></pre></td></tr></table></figure><h4 id="6-1-4-Export-all-as-x"><a href="#6-1-4-Export-all-as-x" class="headerlink" title="6.1.4 Export all as x"></a>6.1.4 Export all as x</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> utilities <span class="keyword">from</span> <span class="string">"./utilities"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;utilities&#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br></pre></td></tr></table></figure><h4 id="6-1-4-export-import-require"><a href="#6-1-4-export-import-require" class="headerlink" title="6.1.4 export =      import = require()"></a>6.1.4 export =      import = require()</h4><p>TypeScript supports <code>export =</code> to model the traditional CommonJS and AMD workflow.</p><p><code>export =</code>语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。</p><p>当使用<code>export =</code>导出模块时, 必须用 <code>import module = require(&quot;module&quot;)</code> 导入模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// z.ts</span></span><br><span class="line"><span class="keyword">let</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> = ZipCodeValidator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t.ts</span></span><br><span class="line"><span class="keyword">import</span> zip = <span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> zip();</span><br></pre></td></tr></table></figure><h3 id="6-2-code-generation-for-Modules"><a href="#6-2-code-generation-for-Modules" class="headerlink" title="6.2 code generation for Modules"></a>6.2 code generation for Modules</h3><p>typescript 会依据不同的模块规则，生成不同的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleModule.ts</span></span><br><span class="line"><span class="keyword">import</span> m = <span class="built_in">require</span>(<span class="string">"mod"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = m.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>AMD / RequireJS SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"./mod"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, mod_1</span>) </span>&#123;</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>CommonJS / Node SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>UMD SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> v = factory(<span class="built_in">require</span>, exports);</span><br><span class="line">  <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">module</span>.exports = v;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">  define([<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"./mod"</span>], factory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> mod_1 = <span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">exports.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>System SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.register([<span class="string">"./mod"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">exports_1</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> mod_1;</span><br><span class="line"><span class="keyword">var</span> t;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  setters: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">mod_1_1</span>) </span>&#123;</span><br><span class="line">      mod_1 = mod_1_1;</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    exports_1(<span class="string">"t"</span>, (t = mod_1.something + <span class="number">1</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Native ECMAScript 2015 modules SimpleModule.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">"./mod"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> t = something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="6-3-可选模块加载和其他高级加载方案"><a href="#6-3-可选模块加载和其他高级加载方案" class="headerlink" title="6.3 可选模块加载和其他高级加载方案"></a>6.3 可选模块加载和其他高级加载方案</h3><p>为了保持类型安全，我们可以使用typeof关键字。当在类型位置中使用typeof关键字时，将产生值的类型，在这种情况下为模块的类型。</p><h4 id="6-3-1-Dynamic-Module-Loading-in-Node-js"><a href="#6-3-1-Dynamic-Module-Loading-in-Node-js" class="headerlink" title="6.3.1 Dynamic Module Loading in Node.js"></a>6.3.1 Dynamic Module Loading in Node.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line"><span class="keyword">let</span> ZipCodeValidator: <span class="keyword">typeof</span> Zip = <span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line"><span class="keyword">if</span> (validator.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-2-Sample-Dynamic-Module-Loading-in-require-js"><a href="#6-3-2-Sample-Dynamic-Module-Loading-in-require-js" class="headerlink" title="6.3.2 Sample: Dynamic Module Loading in require.js"></a>6.3.2 Sample: Dynamic Module Loading in require.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">moduleNames: <span class="built_in">string</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">onLoad: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Zip <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"./ZipCodeValidator"</span>], <span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (validator.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-3-Sample-Dynamic-Module-Loading-in-System-js"><a href="#6-3-3-Sample-Dynamic-Module-Loading-in-System-js" class="headerlink" title="6.3.3 Sample: Dynamic Module Loading in System.js"></a>6.3.3 Sample: Dynamic Module Loading in System.js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> System: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">"./ZipCodeValidator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">System.import(<span class="string">"./ZipCodeValidator"</span>).then(<span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (x.isAcceptable(<span class="string">"..."</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-使用其他js库"><a href="#6-4-使用其他js库" class="headerlink" title="6.4 使用其他js库"></a>6.4 使用其他js库</h3><p>为了描述非ts编写的库，我们需要声明该库公开的API；通常将这些声明定义在<code>.d.ts</code>文件中，就类似c/c++程序中的 <code>.h</code>文件；</p><p>Ts程序在开发过程中，会不可避免的引用到第三方js库，但是无法使用Typescript诸如类型检查等特性功能，为了解决这个问题，需要将这些库的函数和方法去掉后只保留导出类型声明，而产生一个描述js库和模块信息的声明文件，通过引用这个声明文件，就可以借用TS的各种特性来使用库文件；</p><h4 id="6-4-1-声明文件的存放方式"><a href="#6-4-1-声明文件的存放方式" class="headerlink" title="6.4.1 声明文件的存放方式"></a>6.4.1 声明文件的存放方式</h4><ol><li>在tsconfig include 字段包含 的范围内编写.d.ts，都能被自动识别</li><li>在x.js 相同目录创建同名声明文件x.d.ts，这样也会被自动识别；</li><li>node_modules/@types/ 下存放的各个第三方模块声明文件，自己编写的声明文件不要放这里；</li><li>作为npm模块发布时，声明文件可捆绑发布，需在package.json中指明“types”：”./types/index.d.ts”</li></ol><h4 id="6-4-1-无配置使用js"><a href="#6-4-1-无配置使用js" class="headerlink" title="6.4.1 无配置使用js"></a>6.4.1 无配置使用js</h4><p>在tsconfig.json中关闭”noImplicitAny”: false时，可直接在Ts中引用js的库，所有的引入都会被默认为any类型。此方法不推荐使用；</p><h4 id="6-4-2-Ts中引入js"><a href="#6-4-2-Ts中引入js" class="headerlink" title="6.4.2 Ts中引入js"></a>6.4.2 Ts中引入js</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hello = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;hello&#125; <span class="keyword">from</span> <span class="string">'./hello'</span></span><br><span class="line"><span class="comment">// 无法找到模块'./hello'的声明文件</span></span><br><span class="line"><span class="comment">// 这就告诉用户，需要为hello.js编写声明文件了；</span></span><br><span class="line"><span class="comment">// hello.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">const</span> hello: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>  上面的例子稍微简单一些，下面写一个相对复杂点的demo</p><p><strong>tsconfig.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist/"</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>],</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"./src/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-src</span><br><span class="line">-swap</span><br><span class="line">-index.js</span><br><span class="line">-index.d.ts</span><br><span class="line">-index.ts</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap/index.js</span></span><br><span class="line"><span class="keyword">const</span> NAME = <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line">  temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;NAME&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  swap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> swap &#123; <span class="comment">// ts 编译运行时的 swap命名空间, 增加命名空间放置被全局污染。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T, b: T</span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> swap; <span class="comment">// 注意这里要导出，有export/import 语句的文件 才是模块</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> swap <span class="keyword">from</span> <span class="string">"./swap"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"3"</span>,</span><br><span class="line">  b = <span class="string">"4"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(swap.swap&lt;<span class="built_in">string</span>&gt;(a, b));</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure><h4 id="6-4-3-declare"><a href="#6-4-3-declare" class="headerlink" title="6.4.3 declare"></a>6.4.3 declare</h4><p><strong>var和declare的区别</strong></p><p>​        var表示创建一个新变量，declare用来告诉ts编译器这个变量已经在别处被创建过了， 如果你用declare，什么都不会添加到生成的js中， 它只是对编译器一个简单的提示；</p><p>​        举例说明，如果你引入的第三方js文件中有 <code>var externalModule</code>，你需要定义<code>declare var externalModule</code> 去提示ts编译器，externalModule这个变量已经被创建了；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">class</span> Action &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个class  Action的具体实现应该在其他什么地方，可以在个 .js文件里面</p><p>​        </p><h4 id="6-4-4-Ts中导入-png-json等"><a href="#6-4-4-Ts中导入-png-json等" class="headerlink" title="6.4.4 Ts中导入.png .json等"></a>6.4.4 Ts中导入.png .json等</h4><p>导入.png .json 等文件时，同样也需要去编写声明文件；</p><p>提供一种方式，可以创建一个声明文件 <code>src/@types/definition.d.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.png' &#123;</span><br><span class="line"><span class="keyword">const</span> value: <span class="built_in">string</span></span><br><span class="line"><span class="keyword">export</span> = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="comment">// 之后在TS中导入也不会有问题</span></span><br><span class="line"><span class="keyword">import</span> avatar <span class="keyword">from</span> <span class="string">'./img/avatar.png'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> avatar = <span class="built_in">require</span>(<span class="string">'./img/avatar.png'</span>)</span><br><span class="line">  <span class="comment">// 可能会提示 require 未定义，有两种方式：</span></span><br><span class="line">  <span class="comment">//  1. 自行声明：declare const require: any</span></span><br><span class="line">  <span class="comment">//  2. yarn add -D @types/node</span></span><br></pre></td></tr></table></figure><h4 id="6-4-5-第三方模块没有可用的声明文件"><a href="#6-4-5-第三方模块没有可用的声明文件" class="headerlink" title="6.4.5  第三方模块没有可用的声明文件"></a>6.4.5  第三方模块没有可用的声明文件</h4><p>有些模块没有对应的声明文件时，需要我们自己编写声明文件，以rc-form为例子，需要在<code>src/@types/defintion.d.ts</code>中添加声明代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defintion.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "rc-form" &#123;</span><br><span class="line"><span class="comment">// 再次简单进行类型声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createForm: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createFormField: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> formShape: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-6-webpack-别名-aliases"><a href="#6-4-6-webpack-别名-aliases" class="headerlink" title="6.4.6  webpack  别名  aliases"></a>6.4.6  webpack  别名  aliases</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">aliases: &#123;</span><br><span class="line">  <span class="comment">// 公共的工具类、容器和组件</span></span><br><span class="line">  utils: path.resolve(<span class="string">'../utils'</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;ua&#125; <span class="keyword">from</span> <span class="string">'utils/broswer'</span></span><br><span class="line"><span class="comment">// cannot find module 'utils/browser'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要在tsconfig.json 添加baseUrl 和 paths</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 添加配置</span></span><br><span class="line">  <span class="string">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">  <span class="string">"paths"</span>: &#123;</span><br><span class="line">    <span class="string">"utils/*"</span>: [<span class="string">"../utils/*"</span>],</span><br><span class="line">    <span class="string">"components/*"</span>: [<span class="string">"../components/*"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"include"</span>: [<span class="string">"./src/*"</span>, <span class="string">"./src/**/*"</span>],</span><br><span class="line"><span class="string">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-7-类型Window上不存在属性“X”"><a href="#6-4-7-类型Window上不存在属性“X”" class="headerlink" title="6.4.7 类型Window上不存在属性“X”"></a>6.4.7 类型Window上不存在属性“X”</h4><p>需要对window进行扩展，直接在<code>src/@types/definition.d.ts</code>中扩展</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">x: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(Window.x) <span class="comment">// success</span></span><br></pre></td></tr></table></figure><ul><li>注意全局声明和局部声明</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;IPerson&#125; <span class="keyword">from</span> <span class="string">'./intefaces/index.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">X: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.X); <span class="comment">// fail: 类型“Window"上不存在属性“X”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决思路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// definition.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;IPerson&#125; <span class="keyword">from</span> <span class="string">'./intefaces/index.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">  <span class="keyword">interface</span> Window &#123;</span><br><span class="line">    X: <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.X) <span class="comment">// success </span></span><br><span class="line"><span class="comment">// 原因在于当一个 .ts文件加入import/export 语句的时候，该文件会变为一个模块；因为这个模块中的声明也会变为局部声明； 因此需要加到global的域上</span></span><br></pre></td></tr></table></figure><h3 id="6-5-Ambient-Modules"><a href="#6-5-Ambient-Modules" class="headerlink" title="6.5 Ambient Modules"></a>6.5 Ambient Modules</h3><p>在nodejs中，很多任务的完成都需要引入一个或多个模块，我们可以给每个模块在他们的根目录建立一个.d.ts文件用来声明类型，但合并这些声明到一个大的.d.ts文件往往更方便一些。使用module关键字和 引号名 。这些引号名的名称将在以后的导入中使用；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "url" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Url &#123;</span><br><span class="line">  protocol?: <span class="built_in">string</span>;</span><br><span class="line">  hostname?: <span class="built_in">string</span>;</span><br><span class="line">  pathname?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  urlStr: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  parseQueryString?,</span></span></span><br><span class="line"><span class="function"><span class="params">  slashesDenoteHost?</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Url</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "path" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> sep: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we can <code>/// &lt;reference&gt;</code> <code>node.d.ts</code> and then load the modules using <code>import url = require(&quot;url&quot;);</code> or <code>import * as URL from &quot;url&quot;</code>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="node.d.ts"/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> URL <span class="keyword">from</span> <span class="string">"url"</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = URL.parse(<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure><h4 id="6-5-1-不想为第三方js写声明"><a href="#6-5-1-不想为第三方js写声明" class="headerlink" title="6.5.1 不想为第三方js写声明"></a>6.5.1 不想为第三方js写声明</h4><p>If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declarations.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "hot-new-<span class="keyword">module</span>";</span><br><span class="line"></span><br><span class="line">// All imports from shorthand <span class="keyword">module</span> will have the any type;</span><br><span class="line">import x, &#123;y&#125; <span class="keyword">from</span> <span class="string">"hot-new-module"</span>;</span><br><span class="line">x(y);</span><br></pre></td></tr></table></figure><h4 id="6-5-2-通配符"><a href="#6-5-2-通配符" class="headerlink" title="6.5.2 通配符"></a>6.5.2 通配符</h4><p>一些模块加载器（例如SystemJS和AMD）允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declareations.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*!text" &#123;</span><br><span class="line"><span class="keyword">const</span> content: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Some do it the other way around.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "json!*" &#123;</span><br><span class="line"><span class="keyword">const</span> value: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now you can import things that match "*!text" or "json!*".</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">"./xyz.txt!text"</span>;</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">"json!http://example.com/data.json"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data, fileContent);</span><br></pre></td></tr></table></figure><h4 id="6-5-3-UMD-modules"><a href="#6-5-3-UMD-modules" class="headerlink" title="6.5.3 UMD modules"></a>6.5.3 UMD modules</h4><p>一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为UMD模块。可以通过导入或全局变量访问这些库。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math-lib.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPreme</span>(<span class="params">x: <span class="built_in">number</span></span>):<span class="title">boolean</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> mathLib;</span><br></pre></td></tr></table></figure><p>The library can then be used as an import within modules:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">"math-lib"</span>;</span><br><span class="line">isPrime(<span class="number">2</span>);</span><br><span class="line">mathLib.isPrime(<span class="number">2</span>); <span class="comment">// ERROR: can't use the global definition from inside a module</span></span><br></pre></td></tr></table></figure><p>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathLib.isPrime(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="6-7-Guidance-for-structuring-modules"><a href="#6-7-Guidance-for-structuring-modules" class="headerlink" title="6.7 Guidance for structuring modules"></a>6.7 Guidance for structuring modules</h3><h4 id="6-7-1-Export-as-close-to-top-level-as-possible"><a href="#6-7-1-Export-as-close-to-top-level-as-possible" class="headerlink" title="6.7.1 Export as close to top-level as possible"></a>6.7.1 Export as close to top-level as possible</h4><p>如果要导入大量内容，请使用名称空间导入模式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLargeModule.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Dog &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Cat &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Tree &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Flower &#123; ... &#125;</span><br><span class="line"><span class="comment">// Consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myLargeModule <span class="keyword">from</span> <span class="string">"./MyLargeModule.ts"</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure><h4 id="6-7-2-Re-export-to-extend"><a href="#6-7-2-Re-export-to-extend" class="headerlink" title="6.7.2 Re-export to extend"></a>6.7.2 Re-export to extend</h4><p>通常，您将需要扩展模块上的功能。常见的JS模式是使用扩展来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样合并。推荐的解决方案是不要变更原始对象，而是导出提供新功能的新对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Calculator &#123;</span><br><span class="line"><span class="keyword">private</span> current = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> operator: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 只能做10以内的计算；</span></span><br><span class="line">  <span class="keyword">if</span> (digit &gt;= <span class="string">"0"</span> &amp;&amp; digit &lt;= <span class="string">"9"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue * <span class="number">10</span> + (digit.charCodeAt(<span class="number">0</span>) - <span class="string">"0"</span>.charCodeAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processOperator(operator: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>].indexOf(operator) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> operator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> evaluateOperator(</span><br><span class="line">  operator: <span class="built_in">string</span>,</span><br><span class="line">  left: <span class="built_in">number</span>,</span><br><span class="line">  right: <span class="built_in">number</span></span><br><span class="line">): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>.operator) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">      <span class="keyword">return</span> left - right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">      <span class="keyword">return</span> left * right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">      <span class="keyword">return</span> left / right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> evaluate() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.operator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">this</span>.evaluateOperator(</span><br><span class="line">      <span class="keyword">this</span>.operator,</span><br><span class="line">      <span class="keyword">this</span>.memory,</span><br><span class="line">      <span class="keyword">this</span>.current</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">this</span>.current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.current = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> handleChar(char: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (char === <span class="string">"="</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.evaluate();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.processDigit(char, <span class="keyword">this</span>.current);</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">this</span>.processOperator(char);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.evaluate();</span><br><span class="line">        <span class="keyword">this</span>.operator = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Unsupported input: '<span class="subst">$&#123;char&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> getResult() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.memory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c: Calculator, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">  c.handleChar(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`result of '<span class="subst">$&#123;input&#125;</span>' is '<span class="subst">$&#123;c.getResult()&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">import</span> &#123;Calculator,  test&#125; <span class="keyword">from</span> <span class="string">'./ProgrammerCalculator'</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">"1+2*33/11="</span>);</span><br></pre></td></tr></table></figure><p><strong>新需求： 要求计算超过9的值</strong></p><p>这个时候不在原类上更改，而是在继承类上做新功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Calculator &#125; <span class="keyword">from</span> <span class="string">"./Calculator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ProgrammerCalculator <span class="keyword">extends</span> Calculator &#123;</span><br><span class="line"><span class="keyword">static</span> digits = [</span><br><span class="line">  <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"2"</span>,</span><br><span class="line">  <span class="string">"3"</span>,</span><br><span class="line">  <span class="string">"4"</span>,</span><br><span class="line">  <span class="string">"5"</span>,</span><br><span class="line">  <span class="string">"6"</span>,</span><br><span class="line">  <span class="string">"7"</span>,</span><br><span class="line">  <span class="string">"8"</span>,</span><br><span class="line">  <span class="string">"9"</span>,</span><br><span class="line">  <span class="string">"A"</span>,</span><br><span class="line">  <span class="string">"B"</span>,</span><br><span class="line">  <span class="string">"C"</span>,</span><br><span class="line">  <span class="string">"D"</span>,</span><br><span class="line">  <span class="string">"E"</span>,</span><br><span class="line">  <span class="string">"F"</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> base: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">const</span> maxBase = ProgrammerCalculator.digits.length;</span><br><span class="line">  <span class="keyword">if</span> (base &lt;= <span class="number">0</span> || base &gt; maxBase) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`base has to be within 0 to <span class="subst">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      currentValue * <span class="keyword">this</span>.base + ProgrammerCalculator.digits.indexOf(digit)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export the new extended calculator as Calculator</span></span><br><span class="line"><span class="keyword">export</span> &#123; ProgrammerCalculator <span class="keyword">as</span> Calculator &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also, export the helper function</span></span><br><span class="line"><span class="keyword">export</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">"./Calculator"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Calculator, test &#125; <span class="keyword">from</span> <span class="string">"./ProgrammerCalculator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">"001+010="</span>); <span class="comment">// prints 3</span></span><br></pre></td></tr></table></figure><h4 id="6-7-3-Do-not-use-namespaces-in-modules"><a href="#6-7-3-Do-not-use-namespaces-in-modules" class="headerlink" title="6.7.3  Do not use namespaces in modules"></a>6.7.3  Do not use namespaces in modules</h4><p>当首次转向基于模块的组织时，一种普遍的趋势是将导出包装在命名空间的附加层中。模块具有自己的作用域，并且从模块外部仅可见导出的声明。考虑到这一点，名称空间在使用模块时几乎没有价值。</p><h2 id="7-Namespaces"><a href="#7-Namespaces" class="headerlink" title="7. Namespaces"></a>7. Namespaces</h2><p>在TypeScript 1.5中，模块命名法则已更改。 “Internal modules”现在是“namespaces”。为了与ECMAScript 2015的术语保持一致，“External modules”现在简称为“modules”（module X {}  等同于 namespaceX {}）</p><p>在声明内部模块时，在使用module关键字的任何地方，可以并且应该改用namespace关键字。</p><h3 id="7-1-多个相似对象添加namespaces"><a href="#7-1-多个相似对象添加namespaces" class="headerlink" title="7.1 多个相似对象添加namespaces"></a>7.1 多个相似对象添加namespaces</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      validators[name].isAcceptable(s) ? <span class="string">"matches"</span> : <span class="string">"does not match"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Splitting-Across-Files"><a href="#7-2-Splitting-Across-Files" class="headerlink" title="7.2  Splitting Across Files"></a>7.2  Splitting Across Files</h3><p>​    随着应用程序的扩展，我们希望将代码拆分为多个文件，以使其易于维护;</p><h5 id="7-2-1-Multi-file-namespaces"><a href="#7-2-1-Multi-file-namespaces" class="headerlink" title="7.2.1 Multi-file namespaces"></a>7.2.1 Multi-file namespaces</h5><p>  我们将Validation名称空间拆分为多个文件。即使文件是分开的，它们每个都可以贡献相同的名称空间，并且可以像将它们全部定义在一个位置一样使用。由于文件之间存在依赖性，因此我们将添加参考标记，以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。</p><ul><li>Validation.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LettersOnlyValidator.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ZipCodeValidator.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Test.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="LettersOnlyValidator.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="ZipCodeValidator.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      validators[name].isAcceptable(s) ? <span class="string">"matches"</span> : <span class="string">"does not match"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦涉及到多个文件，需要确保所有已编译的代码都已加载，有两种方法可以做到这点</p><h6 id="7-2-1-1-级联输出"><a href="#7-2-1-1-级联输出" class="headerlink" title="7.2.1.1 级联输出"></a>7.2.1.1 级联输出</h6><p>使用 –outFile，将所有输入文件编译为单个js输出文件</p><p><code>tsc --outFile sample.js Test.ts</code></p><h6 id="7-2-1-2-自动排序输出"><a href="#7-2-1-2-自动排序输出" class="headerlink" title="7.2.1.2 自动排序输出"></a>7.2.1.2 自动排序输出</h6><p>编译器将根据文件中存在的参考标记自动排序输出文件。您还可以分别指定每个文件：</p><p><code>tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</code></p><h6 id="7-2-1-3-单个编译"><a href="#7-2-1-3-单个编译" class="headerlink" title="7.2.1.3 单个编译"></a>7.2.1.3 单个编译</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc test.ts</span><br><span class="line">tes Validation.ts</span><br></pre></td></tr></table></figure><h3 id="7-3-Aliases"><a href="#7-3-Aliases" class="headerlink" title="7.3 Aliases"></a>7.3 Aliases</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Square &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = Shapes.Polygons;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.Square(); </span><br><span class="line"><span class="comment">// Same as 'new Shapes.Polygons.Square()'</span></span><br></pre></td></tr></table></figure><h4 id="7-3-1-使用第三方JavaScript库"><a href="#7-3-1-使用第三方JavaScript库" class="headerlink" title="7.3.1 使用第三方JavaScript库"></a>7.3.1 使用第三方JavaScript库</h4><p>为了描述不是用TypeScript编写的库的形状，我们需要声明该库公开的API。因为大多数JavaScript库仅公开一些顶级对象，所以namespaces是表示它们的好方法。</p><p>D3在名为d3的全局对象中定义其功能。由于此库是通过script标签加载的，因此可以使用命名空间来声明它的shape。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> namspace D3 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Selectors &#123;</span><br><span class="line">  select: &#123;</span><br><span class="line">    (selector: <span class="built_in">string</span>): Selection;</span><br><span class="line">    (element: EventTarget): Selection;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Event &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Base <span class="keyword">extends</span> Selectors &#123;</span><br><span class="line">  event: Event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> d3: D3.Base;</span><br></pre></td></tr></table></figure><h2 id="8-三斜杠指令"><a href="#8-三斜杠指令" class="headerlink" title="8. 三斜杠指令"></a>8. 三斜杠指令</h2><p>三斜杠指令是包含单个XML标签的单行注释。注释的内容用作编译器指令。</p><p>三斜杠指令仅在其包含文件的顶部有效。三斜杠指令只能在单行或多行注释之前，包括其他三斜杠指令。如果在声明或声明之后遇到它们，则将它们视为常规的单行注释，并且没有特殊含义。</p><ul><li><code>/// &lt;reference path=&quot;./lib/index.d.ts&quot; /&gt;</code>：表示对一个文件的依赖。</li><li><code>/// &lt;reference types=&quot;jye&quot; /&gt;</code>：表示对一个库的依赖。</li></ul><p>三斜线的<code>path</code> &amp; <code>types</code>，和<code>es6</code>的<code>import</code>语义相似，同时<strong>三斜线指令必须放在文件的最顶端</strong>。例如，当我们的声明文件过于庞大，一般都会采用三斜线指令，将我们的声明文件拆分成若干个，然后由一个入口文件引入。</p><h3 id="8-1-文件之间的依赖声明"><a href="#8-1-文件之间的依赖声明" class="headerlink" title="8.1  文件之间的依赖声明"></a>8.1  文件之间的依赖声明</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path="..."/&gt;</span></span><br><span class="line"><span class="comment">///&lt;reference path="..."/&gt;   是这个group中最常见的，它用作文件之间依赖关系的声明；</span></span><br></pre></td></tr></table></figure><p>三斜杠指令指示编译器在编译过程中包括其他文件；</p><p>当使用 –out 或 –outFile时，它们还可以用作对输出进行排序的方法。预处理通过后，文件以与输入相同的顺序输出到目标文件位置。</p><h3 id="8-2-input-files-预处理"><a href="#8-2-input-files-预处理" class="headerlink" title="8.2  input files 预处理"></a>8.2  input files 预处理</h3><p>编译器对输入文件进行预处理，以解析所有三斜杠引用指令。在此过程中，其他文件将添加到编译过程中。</p><p>该过程从一组根文件开始；这些是在命令行或tsconfig.json文件的“files”列表中指定的文件名。这些根文件将按照指定的顺序进行预处理。在将文件添加到列表之前，必须先处理其中的所有三斜杠引用及其目标。按照在文件中出现的顺序，深度优先地解析三斜杠引用</p><p>A triple-slash reference path is resolved relative to the containing file, if unrooted.</p><h3 id="8-3-types"><a href="#8-3-types" class="headerlink" title="8.3 types"></a>8.3 types</h3><p><code>types=&quot;...&quot; 与 path=&quot;...&quot;</code> 类似，前者声明对包的依赖，后者声明对一个文件的依赖</p><p>这些程序包名称的解析过程与import语句中的模块名称解析过程相似。考虑三重斜杠引用类型指令的一种简单方法是将其作为声明包的导入。</p><p>在一个声明文件中包括 <code>types=&quot;node&quot;</code> 则该声明文件使用<code>@types/node/index.d.ts</code>中声明的名称，因此，此包需要与声明文件一起包含在编译中; </p><p>仅当您书写d.ts文件时，才使用这些指令；</p><p>对于编译期间生成的声明文件，编译器会自动添加<code>types=&quot;...&quot;</code>。当且仅当reslulting file使用 referenced package中 任何声明的时候，才会在生成的声明文件中添加 <code>types=&quot;...&quot;</code> ；</p><p>在 .ts 文件声明对 一个@types 包的依赖， 使用命令行 –types 或者 tsconfig.json中设置；</p><h3 id="8-4-lib"><a href="#8-4-lib" class="headerlink" title="8.4 lib"></a>8.4 lib</h3><p><code>lib=&quot;...&quot;</code> </p><p>此指令允许文件显式包括现有的内置lib文件。</p><p>例如，在编译中的一个文件中添加/// &lt;reference lib =“ es2017.string” /&gt;等效于使用–lib es2017.string进行编译。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference lib="es2017.string" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">"foo"</span>.padStart(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="9-Namespaces-and-Modules"><a href="#9-Namespaces-and-Modules" class="headerlink" title="9. Namespaces and Modules"></a>9. Namespaces and Modules</h2><h3 id="9-1-使用modules"><a href="#9-1-使用modules" class="headerlink" title="9.1 使用modules"></a>9.1 使用modules</h3><p>模块可以包含代码和声明</p><p>从es6开始，模块是语言的原生机制，新的项目，模块将是推荐的代码组织机制；</p><h3 id="9-2-使用namespaces"><a href="#9-2-使用namespaces" class="headerlink" title="9.2 使用namespaces"></a>9.2 使用namespaces</h3><p>命名空间是TypeScript特定的组织代码的方式。</p><p>命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。与模块不同，它们可以跨越多个文件，并且可以使用–outFile进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都作为script标记包含在HTML页面中。</p><p>就像所有全局命名空间污染一样，很难识别组件依赖性，尤其是在大型应用程序中。</p><h3 id="9-3-使用namespaces-和-modules-遇到的一些坑"><a href="#9-3-使用namespaces-和-modules-遇到的一些坑" class="headerlink" title="9.3 使用namespaces 和 modules 遇到的一些坑"></a>9.3 使用namespaces 和 modules 遇到的一些坑</h3><h4 id="9-3-1-不需要namespaces的时候"><a href="#9-3-1-不需要namespaces的时候" class="headerlink" title="9.3.1 不需要namespaces的时候"></a>9.3.1 不需要namespaces的时候</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `shapes.ts`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Square &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `shapeConsumer.ts`</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">"./shapes"</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.Shapes.Triangle(); <span class="comment">// shapes.Shapes?</span></span><br></pre></td></tr></table></figure><p>推荐的做法，当一个文件中定义了import/export 的时候，那么它就变成了一个模块。模块中，命名空间显然多此一举了</p><p><strong>推荐做法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Square &#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shapeConsumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">"./shapes"</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.Triangle();</span><br></pre></td></tr></table></figure><h4 id="9-3-2-reference-和import-的使用时机"><a href="#9-3-2-reference-和import-的使用时机" class="headerlink" title="9.3.2 reference 和import 的使用时机"></a>9.3.2 reference 和import 的使用时机</h4><p>一个常见的错误是尝试使用<code>/// reference ...</code>语法来引用模块文件，而不是使用<code>import</code>语句；</p><p>编译器如何 基于 <code>path of an import path(import X from &#39;xxx&#39;; import x = require(&#39;...&#39;))</code> 找到模块的类型信息；</p><p>编译器将尝试查找.ts，.tsx，然后找到具有适当路径的.d.ts。如果找不到特定的文件，然编译器会去找<code>ambient module declaration</code> 记得这些需要在 .d.ts 文件中声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myModules.d.ts</span></span><br><span class="line"><span class="comment">// In a .d.ts file or .ts file that is not a module:</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "SomeModule" &#123;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// myOtherModule.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference path="myModules.d.ts" /&gt;  记得添加依赖</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">"SomeModule"</span>; <span class="comment">// 这里并不是导入 文件名，而是模块名，因为 myModules.d.ts 不是一个模块；</span></span><br></pre></td></tr></table></figure><p><code>/// reference path=&quot;myModules.d.ts&quot;</code> 使我们能够找到包含环境模块声明的声明文件，This is how the <code>node.d.ts</code> file that several of the TypeScript samples use is consumed.</p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts generics</title>
      <link href="2021/01/20/ts-generics/"/>
      <url>2021/01/20/ts-generics/</url>
      
        <content type="html"><![CDATA[<h2 id="5-Generics"><a href="#5-Generics" class="headerlink" title="5. Generics"></a>5. Generics</h2><p>泛型，创建可重用组件的工具。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// Property 'length' does not exist on type 'T'.</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-泛型定义"><a href="#5-1-泛型定义" class="headerlink" title="5.1 泛型定义"></a>5.1 泛型定义</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">  &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity1: &#123; &lt;T&gt;(arg: T): T &#125; = identity;</span><br><span class="line"><span class="keyword">let</span> myIdentity2: GenericIdentityFn = identity;</span><br></pre></td></tr></table></figure><h3 id="5-2-泛型类"><a href="#5-2-泛型类" class="headerlink" title="5.2 泛型类"></a>5.2 泛型类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-泛型约束"><a href="#5-3-泛型约束" class="headerlink" title="5.3 泛型约束"></a>5.3 泛型约束</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-Using-Type-Parameters-in-Generic-Constraints"><a href="#5-3-1-Using-Type-Parameters-in-Generic-Constraints" class="headerlink" title="5.3.1 Using Type Parameters in Generic Constraints"></a>5.3.1 Using Type Parameters in Generic Constraints</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">"a"</span>);</span><br><span class="line">getProperty(x, <span class="string">"m"</span>);</span><br><span class="line"><span class="comment">// Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.</span></span><br></pre></td></tr></table></figure><h4 id="5-3-2-泛型类"><a href="#5-3-2-泛型类" class="headerlink" title="5.3.2 泛型类"></a>5.3.2 泛型类</h4><p>使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c: &#123; <span class="keyword">new</span> (): T &#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">  hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">  nametag: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  numLegs: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c: <span class="keyword">new</span> () =&gt; A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;</span><br><span class="line">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts doc</title>
      <link href="2021/01/19/ts-doc/"/>
      <url>2021/01/19/ts-doc/</url>
      
        <content type="html"><![CDATA[<h1 id="handbook"><a href="#handbook" class="headerlink" title="handbook"></a>handbook</h1><p><strong>A reader who completes the walkthrough should be able to:</strong></p><ul><li>Read and understand commonly-used TypeScript syntax and patterns</li><li>Explain the effects of important compiler options</li><li>Correctly predict type system behavior in most cases</li><li>Write a .d.ts declaration for a simple function, object, or class</li></ul><h2 id="1-basic-Types"><a href="#1-basic-Types" class="headerlink" title="1. basic Types"></a>1. basic Types</h2><p> 在TypeScript中，我们支持与JavaScript中期望的类型相同的类型，并添加了一个额外的枚举类型以帮助处理问题。</p><p>Boolean, Number, String, Array,Tuple,Enum,Unkown,Any,Void, Null and Undefined, Never, Object,</p><ul><li>Tuple</li></ul><p>元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对字符串和一个数字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">"hello"</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">"hello"</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><ul><li>Enum</li></ul><p>枚举是JavaScript标准数据类型集的一个有用补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays 'Green'</span></span><br><span class="line"><span class="built_in">console</span>.log(colorName);</span><br></pre></td></tr></table></figure><ul><li>Unknown</li></ul><p>我们可能需要描述编写应用程序时不知道的变量类型。这些值可能来自动态内容，例如来自用户-或者我们可能要有意接受我们API中的所有值。在这些情况下，我们希望提供一种类型，该类型告诉编译器和将来的读者此变量可以是任何变量，因此我们将其赋予未知类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: unknown = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, definitely a boolean</span></span><br><span class="line">notSure = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果您有一个类型未知的变量，则可以通过进行typeof检查，比较检查或更高级的类型防护来将其范围缩小到更具体的范围;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> maybe: unknown;</span><br><span class="line"><span class="comment">// 'maybe' could be a string, object, boolean, undefined, or other types</span></span><br><span class="line"><span class="keyword">const</span> aNumber: <span class="built_in">number</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'unknown' is not assignable to type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (maybe === <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TypeScript knows that maybe is a boolean now</span></span><br><span class="line">  <span class="keyword">const</span> aBoolean: <span class="built_in">boolean</span> = maybe;</span><br><span class="line">  <span class="comment">// So, it cannot be a string</span></span><br><span class="line">  <span class="keyword">const</span> aString: <span class="built_in">string</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'boolean' is not assignable to type 'string'.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> maybe === <span class="string">"string"</span>) &#123;</span><br><span class="line">  <span class="comment">// TypeScript knows that maybe is a string</span></span><br><span class="line">  <span class="keyword">const</span> aString: <span class="built_in">string</span> = maybe;</span><br><span class="line">  <span class="comment">// So, it cannot be a boolean</span></span><br><span class="line">  <span class="keyword">const</span> aBoolean: <span class="built_in">boolean</span> = maybe;</span><br><span class="line"><span class="comment">//Type 'string' is not assignable to type 'boolean'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Any</li></ul><p>在某些情况下，并非所有类型信息都可用。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况，可能要选择退出类型检查。将这些值标记为any类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="comment">// OK, return value of 'getValue' is not checked</span></span><br><span class="line"><span class="keyword">const</span> str: <span class="built_in">string</span> = getValue(<span class="string">"myString"</span>);</span><br></pre></td></tr></table></figure><p>与 unknown 不同，any类型的变量使您可以访问任意属性，甚至是不存在的属性。这些属性包括函数，并且TypeScript不会检查它们的存在或类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> looselyTyped: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// OK, ifItExists might exist at runtime</span></span><br><span class="line">looselyTyped.ifItExists();</span><br><span class="line"><span class="comment">// OK, toFixed exists (but the compiler doesn't check)</span></span><br><span class="line">looselyTyped.toFixed();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strictlyTyped: unknown = <span class="number">4</span>;</span><br><span class="line">strictlyTyped.toFixed();</span><br><span class="line"><span class="comment">// Object is of type 'unknown'.</span></span><br></pre></td></tr></table></figure><ul><li>Void</li></ul><p>void有点像任何其他的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Null and Undefined</li></ul><p>在TypeScript中，undefined和null实际上实际上分别将其类型命名为undefined和null。就像void一样，它们本身并不是非常有用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>Never</li></ul><p>The <code>never</code> type is a subtype of, and assignable to, every type; however, <em>no</em> type is a subtype of, or assignable to, <code>never</code> (except <code>never</code> itself). Even <code>any</code> isn’t assignable to <code>never</code>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function returning never must not have a reachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred return type is never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function returning never must not have a reachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object</li></ul><p>object是代表非基本类型的类型，即不是数字，字符串，布尔值，bigint，symbol，null或undefined的任何类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With object type, APIs like Object.create can be better represented.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">create(&#123; prop: <span class="number">0</span> &#125;);</span><br><span class="line">create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//Argument of type '42' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="string">"string"</span>);</span><br><span class="line"><span class="comment">//Argument of type '"string"' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//Argument of type 'false' is not assignable to parameter of type 'object | null'.</span></span><br><span class="line">create(<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">//Argument of type 'undefined' is not assignable to parameter of type 'object | null'.</span></span><br></pre></td></tr></table></figure><ul><li>Type assertions</li></ul><p>类型断言是一种告诉编译器“相信我，我知道我在做什么”的方法。类型断言就像其他语言中的类型转换一样，但是它不执行数据的特殊检查或重构。它对运行时没有影响，仅由编译器使用。 TypeScript假定您（程序员）已经执行了所需的任何特殊检查。</p><p>类型断言的两种形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型1: as 语句</span></span><br><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"><span class="comment">// 类型2: 尖括号</span></span><br><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><p>jsx中无法使用 类型2；</p><ul><li>About Number, String, Boolean, Symbol and Object</li></ul><p>可能会认为数字，字符串，布尔值，符号或对象类型与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎永远不应将其用作类型。</p><h2 id="2-interface"><a href="#2-interface" class="headerlink" title="2. interface"></a>2. interface</h2><h3 id="2-1-readonly"><a href="#2-1-readonly" class="headerlink" title="2.1 readonly"></a>2.1 readonly</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript具有与Array <T>相同的ReadonlyArray <T>类型，并且删除了所有变异方法，因此可以确保创建后不更改数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Index signature in type 'readonly number[]' only permits reading.</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Property 'push' does not exist on type 'readonly number[]'.</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Cannot assign to 'length' because it is a read-only property.</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.</span></span><br></pre></td></tr></table></figure><p>在代码片段的最后一行，您可以看到，即使将整个ReadonlyArray分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line"></span><br><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><ul><li>ReadOnly or const</li></ul><p>记住是使用只读还是const的最简单方法是询问是否在变量或属性上使用它。变量使用const，而属性使用只读。</p><h3 id="2-2-Optional"><a href="#2-2-Optional" class="headerlink" title="2.2 Optional"></a>2.2 Optional</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Excess-Property-Checks"><a href="#2-3-Excess-Property-Checks" class="headerlink" title="2.3 Excess Property Checks"></a>2.3 Excess Property Checks</h3><p>但是，TypeScript认为此代码中可能存在错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行过多的属性检查。如果对象文字具有“目标类型”所没有的任何属性，则会出现错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    color: config.color || <span class="string">"red"</span>,</span><br><span class="line">    area: config.width ? config.width * config.width : <span class="number">20</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="comment">//Argument of type '&#123; colour: string; width: number; &#125;' is not assignable to parameter of type 'SquareConfig'.</span></span><br><span class="line"> <span class="comment">// Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?</span></span><br></pre></td></tr></table></figure><ul><li>解决方案</li></ul><ol><li>解决这些检查实际上非常简单。最简单的方法是只使用类型断言：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySquare = createSquare(&#123;width: <span class="number">100</span>, opacity: <span class="number">0.5</span>&#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure><ol start="2"><li>如果对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mySquare = createSquare(&#123;width: <span class="number">100</span>, opacity: <span class="number">0.5</span>&#125;);</span><br><span class="line"><span class="comment">// 只要您在squareOptions和SquareConfig之间具有一个公共属性，上述变通办法就会起作用。但是，如果变量没有任何公共对象属性，它将失败。</span></span><br><span class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">"red"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br><span class="line"><span class="comment">// Type '&#123; colour: string; &#125;' has no properties in common with type 'SquareConfig'.</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Function-Types"><a href="#2-4-Function-Types" class="headerlink" title="2.4 Function Types"></a>2.4 Function Types</h3><p>为了描述带有接口的函数类型，我们给接口一个调用签名。这就像只声明参数列表和返回类型的函数声明。参数列表中的每个参数都需要名称和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch2: SearchFunc;</span><br><span class="line"><span class="comment">// 参数不定义string，ts会自动推断</span></span><br><span class="line">mySearch2 = <span class="function"><span class="keyword">function</span> (<span class="params">src, sub</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">src, sub</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回值需要遵守interface</span></span><br><span class="line"><span class="comment">//Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.</span></span><br><span class="line"><span class="comment">//  Type 'string' is not assignable to type 'boolean'.</span></span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"string"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-5-Indexable-Types"><a href="#2-5-Indexable-Types" class="headerlink" title="2.5 Indexable Types"></a>2.5 Indexable Types</h3><p>可索引类型具有索引签名，该签名描述了可用于索引对象的类型以及建立索引时对应的返回类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为在用数字索引时，JavaScript实际上会在将其索引到对象之前将其转换为字符串。这意味着使用100（一个数字）进行索引与使用“ 100”（一个字符串）进行索引是同一回事，因此两者必须保持一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: indexing with a numeric string might get you a completely separate type of Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">  [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">Numeric index <span class="keyword">type</span> <span class="string">'Animal'</span> is not assignable to <span class="built_in">string</span> index <span class="keyword">type</span> <span class="string">'Dog'</span>.</span><br><span class="line">  [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管字符串索引签名是描述“字典”模式的强大方法，但它们还强制所有属性与其返回类型匹配。这是因为字符串索引声明obj.property也可以作为obj [“ property”]使用。在以下示例中，名称的类型与字符串索引的类型不匹配，并且类型检查器给出错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>; <span class="comment">// ok, length is a number</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// error, the type of 'name' is not a subtype of the indexer</span></span><br><span class="line"><span class="comment">// Property 'name' of type 'string' is not assignable to string index type 'number'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果索引签名是属性类型的并集，则可以接受不同类型的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberOrStringDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span> | <span class="built_in">string</span>; <span class="comment">// 属性类型</span></span><br><span class="line">  length: <span class="built_in">number</span>; <span class="comment">// ok, length is a number</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// ok, name is a string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，您可以将索引签名设为只读，以防止分配给它们的索引：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">  readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">"Mallory"</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="comment">// Index signature in type 'ReadonlyStringArray' only permits reading.</span></span><br></pre></td></tr></table></figure><h3 id="2-6-Class-Types"><a href="#2-6-Class-Types" class="headerlink" title="2.6 Class Types"></a>2.6 Class Types</h3><h4 id="2-6-1-Implement"><a href="#2-6-1-Implement" class="headerlink" title="2.6.1 Implement"></a>2.6.1 Implement</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为当类实现接口时，仅检查该类的实例侧。由于构造函数位于静态端，因此它不包含在此检查中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">  <span class="comment">// Class 'Clock' incorrectly implements interface 'ClockConstructor'.</span></span><br><span class="line"> <span class="comment">//  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.</span></span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> Clock(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>需要直接使用类的静态方面。在此示例中，我们定义了两个接口，用于构造函数的ClockConstructor和用于实例方法的ClockInterface。然后，为方便起见，我们定义了一个构造函数createClock，该函数创建传递给它的类型的实例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: ClockConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">  hour: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  minute: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure><p>另一种简单的方法是使用类表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Clock: ClockConstructor = <span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clock = <span class="keyword">new</span> Clock(<span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line">clock.tick();</span><br></pre></td></tr></table></figure><h3 id="2-7-Extending-Interfaces"><a href="#2-7-Extending-Interfaces" class="headerlink" title="2.7 Extending Interfaces"></a>2.7 Extending Interfaces</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h3 id="2-8-Hybrid-Types"><a href="#2-8-Hybrid-Types" class="headerlink" title="2.8 Hybrid Types"></a>2.8 Hybrid Types</h3><p>an object that acts as both a function and an object, with additional properties:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125; <span class="keyword">as</span> Counter;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><p>与第三方JavaScript交互时，您可能需要使用上述模式来完全描述类型的形状</p><h3 id="2-9-Interfaces-Extending-Classes"><a href="#2-9-Interfaces-Extending-Classes" class="headerlink" title="2.9 Interfaces Extending Classes"></a>2.9 Interfaces Extending Classes</h3><p>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</p><p>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ImageControl <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line"><span class="comment">//Class 'ImageControl' incorrectly implements interface 'SelectableControl'.</span></span><br><span class="line"> <span class="comment">// Types have separate declarations of a private property 'state'.</span></span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        In the above example, <code>SelectableControl</code> contains all of the members of <code>Control</code>, including the private <code>state</code> property. Since <code>state</code> is a private member it is only possible for descendants of <code>Control</code> to implement <code>SelectableControl</code>. This is because only descendants of <code>Control</code> will have a <code>state</code> private member that originates in the same declaration, which is a requirement for private members to be compatible.</p><p>​        Within the <code>Control</code> class it is possible to access the <code>state</code> private member through an instance of <code>SelectableControl</code>. Effectively, a <code>SelectableControl</code> acts like a <code>Control</code> that is known to have a <code>select</code> method. The <code>Button</code> and <code>TextBox</code> classes are subtypes of <code>SelectableControl</code> (because they both inherit from <code>Control</code> and have a <code>select</code> method). The <code>ImageControl</code> class has it’s own <code>state</code> private member rather than extending <code>Control</code>, so it cannot implement <code>SelectableControl</code>.</p><h2 id="3-Functions"><a href="#3-Functions" class="headerlink" title="3. Functions"></a>3. Functions</h2><p>在TypeScript中，尽管有类，名称空间和模块，但是函数仍然在描述操作方式中起着关键作用。 TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。</p><h3 id="3-1-this"><a href="#3-1-this" class="headerlink" title="3.1 this"></a>3.1 this</h3><p>Learning how to use <code>this</code> in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use <code>this</code> and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of <code>this</code> with a couple of techniques. If you need to learn how <code>this</code> works in JavaScript, though, first read Yehuda Katz’s <a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">Understanding JavaScript Function Invocation and “this”</a>. Yehuda’s article explains the inner workings of <code>this</code> very well, so we’ll just cover the basics here.</p><p><strong><code>this</code> and arrow functions</strong></p><p>In JavaScript, <code>this</code> is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</p><p>Let’s look at an example:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Notice that <code>createCardPicker</code> is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the <code>this</code> being used in the function created by <code>createCardPicker</code> will be set to <code>window</code> instead of our <code>deck</code> object. That’s because we call <code>cardPicker()</code> on its own. A top-level non-method syntax call like this will use <code>window</code> for <code>this</code>. (Note: under strict mode, <code>this</code> will be <code>undefined</code> rather than <code>window</code>).</p><p>We can fix this by making sure the function is bound to the correct <code>this</code> before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original <code>deck</code> object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the <code>this</code> where the function is created rather than where it is invoked:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture 'this' right here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Even better, TypeScript will warn you when you make this mistake if you pass the <code>--noImplicitThis</code> flag to the compiler. It will point out that <code>this</code> in <code>this.suits[pickedSuit]</code> is of type <code>any</code>.</p><p><strong><code>this</code> parameters</strong></p><p>Unfortunately, the type of <code>this.suits[pickedSuit]</code> is still <code>any</code>. That’s because <code>this</code> comes from the function expression inside the object literal. To fix this, you can provide an explicit <code>this</code> parameter. <code>this</code> parameters are fake parameters that come first in the parameter list of a function:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// make sure `this` is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s add a couple of interfaces to our example above, <code>Card</code> and <code>Deck</code>, to make the types clearer and easier to reuse:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">  suit: <span class="built_in">string</span>;</span><br><span class="line">  card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">  suits: <span class="built_in">string</span>[];</span><br><span class="line">  cards: <span class="built_in">number</span>[];</span><br><span class="line">  createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">  suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">  cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">  createCardPicker: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>Now TypeScript knows that <code>createCardPicker</code> expects to be called on a <code>Deck</code> object. That means that <code>this</code> is of type <code>Deck</code> now, not <code>any</code>, so <code>--noImplicitThis</code> will not cause any errors.</p><p><strong><code>this</code> parameters in callbacks</strong></p><p>You can also run into errors with <code>this</code> in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, <code>this</code> will be <code>undefined</code>. With some work you can use <code>this</code> parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">  addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type. Second, annotate your calling code with <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickBad(<span class="keyword">this</span>: Handler, e: Event) &#123;</span><br><span class="line">    <span class="comment">// oops, used `this` here. using this callback would crash at runtime</span></span><br><span class="line">    <span class="keyword">this</span>.info = e.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// error!</span></span><br><span class="line"><span class="comment">//Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'.</span></span><br><span class="line">  <span class="comment">//The 'this' types of each signature are incompatible.</span></span><br><span class="line">   <span class="comment">// Type 'void' is not assignable to type 'Handler'.Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'.</span></span><br><span class="line"> <span class="comment">// The 'this' types of each signature are incompatible.</span></span><br><span class="line"> <span class="comment">//   Type 'void' is not assignable to type 'Handler'.</span></span><br></pre></td></tr></table></figure><p>With <code>this</code> annotated, you make it explicit that <code>onClickBad</code> must be called on an instance of <code>Handler</code>. Then TypeScript will detect that <code>addClickListener</code> requires a function that has <code>this: void</code>. To fix the error, change the type of <code>this</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickGood(<span class="keyword">this</span>: <span class="built_in">void</span>, e: Event) &#123;</span><br><span class="line">    <span class="comment">// can't use `this` here because it's of type void!</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"clicked!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickGood);</span><br></pre></td></tr></table></figure><p>Because <code>onClickGood</code> specifies its <code>this</code> type as <code>void</code>, it is legal to pass to <code>addClickListener</code>. Of course, this also means that it can’t use <code>this.info</code>. If you want both then you’ll have to use an arrow function:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.info = e.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This works because arrow functions use the outer <code>this</code>, so you can always pass them to something that expects <code>this: void</code>. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler.</p><h3 id="3-2-Overloads"><a href="#3-2-Overloads" class="headerlink" title="3.2 Overloads"></a>3.2 Overloads</h3><p>JavaScript本质上是一种非常动态的语言。一个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">  <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">    <span class="keyword">return</span> pickedCard;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure><h2 id="4-Classes"><a href="#4-Classes" class="headerlink" title="4. Classes"></a>4. Classes</h2><h3 id="4-1-abstract"><a href="#4-1-abstract" class="headerlink" title="4.1 abstract"></a>4.1 abstract</h3><p> abstract关键字用于定义抽象类以及抽象类中的抽象方法。</p><p>抽象类， 是可以从中派成出其他类的基类；简单说就是只能被继承，不能new出实例；与interface不同的是，抽象类中可以有成员实现的详细信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> App &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> setTargetProps&lt;T&gt; (target: T, source: Partial&lt;T&gt;): T &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(target).forEach(<span class="function">(<span class="params">property: keyof T</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setTargetPropsByProperty(target, property, source[property])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> App();</span><br><span class="line"><span class="comment">// Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="keyword">class</span> B <span class="keyword">extends</span> App&#123;&#125;;</span><br><span class="line"><span class="comment">// 非抽象类“ B”未实现从类“ App”继承的抽象成员“ make”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C <span class="keyword">extends</span> App&#123;</span><br><span class="line">  make()&#123;&#125; <span class="comment">// 需要实现抽象类中定义的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含abstract关键字，并且可以选择包括访问修饰符。</p><h3 id="4-2-public-private-and-protected"><a href="#4-2-public-private-and-protected" class="headerlink" title="4.2 public,private, and protected"></a>4.2 public,private, and protected</h3><h4 id="4-2-1-类型兼容"><a href="#4-2-1-类型兼容" class="headerlink" title="4.2.1 类型兼容"></a>4.2.1 类型兼容</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"Rhino"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Goat"</span>);</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; </span><br><span class="line"><span class="comment">// Type 'Employee' is not assignable to type 'Animal'. 没有继承关系的类型无法做赋值操作；</span></span><br><span class="line"><span class="comment">//  Types have separate declarations of a private property 'name'</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-protected"><a href="#4-2-2-protected" class="headerlink" title="4.2.2 protected"></a>4.2.2 protected</h4><p>protected修饰符的行为与private修饰符非常相似，除了声明为protected的成员也可以在派生类中访问之外；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">    <span class="comment">// 派生类中可以访问到 基类中的 protected 属性；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch());</span><br><span class="line"><span class="comment">// 虽然我们不能从Person外部使用name，但仍可以在Employee的实例方法中使用它，因为Employee源自Person。</span></span><br><span class="line"><span class="built_in">console</span>.log(howard.name);</span><br><span class="line"><span class="comment">// Property 'name' is protected and only accessible within class 'Person' and its subclasses.</span></span><br></pre></td></tr></table></figure><p>构造函数也可能被标记为受保护的。这意味着该类不能在其包含的类之外实例化，但是可以扩展。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee can extend Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>);</span><br><span class="line"><span class="comment">// Constructor of class 'Person' is protected and only accessible within the class declaration. 因为 new Person的时候是需要调 Person的构造函数，由于其构造函数添加了 protected关键字。实例是无法调类的构造函数的，所以就无法被实例化了；</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-Readonly"><a href="#4-2-3-Readonly" class="headerlink" title="4.2.3 Readonly"></a>4.2.3 Readonly</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">readonly theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dad = <span class="keyword">new</span> Octopus(<span class="string">"Man with the 8 strong legs"</span>);</span><br><span class="line">dad.name = <span class="string">"Man with the 3-piece suit"</span>;</span><br><span class="line"><span class="comment">// Cannot assign to 'name' because it is a read-only property.</span></span><br><span class="line"><span class="built_in">console</span>.log(dad.name)</span><br></pre></td></tr></table></figure><h4 id="4-2-4-accessors"><a href="#4-2-4-accessors" class="headerlink" title="4.2.4 accessors"></a>4.2.4 accessors</h4><p>TypeScript支持getters / setter方法，以拦截对对象成员的访问。这使您可以更好地控制如何访问每个对象上的成员的方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  fullName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此版本中，我们添加了一个setter来检查newName的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是这样，我们会抛出错误通知客户端代码出了点问题。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullNameMaxLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span> = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"fullName has a max length of "</span> + fullNameMaxLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><p>首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。</p><p>其次，带有get和no set的访问器会自动推断为只读。当代码生成.d.ts文件时很有用，因为用户通过ide可以看到这些无法进行更改。</p><h4 id="4-2-5-Static"><a href="#4-2-5-Static" class="headerlink" title="4.2.5 Static"></a>4.2.5 Static</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Grid &#123;</span><br><span class="line">  <span class="keyword">static</span> origin = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  calculateDistanceFromOrigin(point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDist = point.x - Grid.origin.x;</span><br><span class="line">    <span class="keyword">let</span> yDist = point.y - Grid.origin.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>); <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>); <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;));</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;));</span><br></pre></td></tr></table></figure><h4 id="4-2-6-Using-a-class-as-an-interface"><a href="#4-2-6-Using-a-class-as-an-interface" class="headerlink" title="4.2.6 Using a class as an interface"></a>4.2.6 Using a class as an interface</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="5-Decorators"><a href="#5-Decorators" class="headerlink" title="5. Decorators"></a>5. Decorators</h2><p>随着TypeScript和ES6中类的引入，现在存在某些情况，这些情况需要附加功能来支持  annotating or modifying classes and class members。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的第2阶段提议，可作为TypeScript的实验功能使用。</p><p>JavaScript引入class之后，我们需要在不同的类之间共享或者扩展一些方法或行为的时候，代码会变得很复杂，不够优雅，这也是装饰器被提出的一个很重要原因之一；</p><p>要为装饰器启用实验性支持，必须在命令行或tsconfig.json中启用experimentalDecorators编译器选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰器是一种特殊的声明，可以附加到类声明，方法，访问器，属性或参数上。装饰器使用<code>@expression</code>形式，其中expression求值之后必须也是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入；</p><h3 id="5-1-class-decorators"><a href="#5-1-class-decorators" class="headerlink" title="5.1 class decorators"></a>5.1 class decorators</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.age = 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addName</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.name = "leo";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span></span><br><span class="line"><span class="meta">@addName</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age, person.name); <span class="comment">// 18 ,'age'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line"><span class="keyword">var</span> __decorate = <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length,</span><br><span class="line">    r =</span><br><span class="line">      c &lt; <span class="number">3</span></span><br><span class="line">        ? target</span><br><span class="line">        : desc === <span class="literal">null</span></span><br><span class="line">        ? (desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key))</span><br><span class="line">        : desc;</span><br><span class="line">  <span class="keyword">var</span> d;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">"function"</span>) &#123;</span><br><span class="line">    r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> ((d = decorators[i]))</span><br><span class="line">        <span class="comment">// 核心代码就是 d(r) r为构造函数Person</span></span><br><span class="line">        r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.age = 18;</span><br><span class="line">&#125;</span><br><span class="line">function addName(<span class="keyword">constructor</span>) &#123;</span><br><span class="line">  <span class="keyword">constructor</span>.prototype.name = "leo";</span><br><span class="line">&#125;</span><br><span class="line">var Person = /** @class */ (function () &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Person = __decorate([addAge, addName], Person);</span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.age, person.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-reflect-metadata"><a href="#5-2-reflect-metadata" class="headerlink" title="5.2 reflect-metadata"></a>5.2 reflect-metadata</h3><p><strong>install</strong></p><p><code>npm install reflect-metadata</code></p><p><strong>demo</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span>;</span><br><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>, <span class="string">"alex"</span>, target);</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>, <span class="string">"world"</span>, target, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getOwnMetadata(<span class="string">"name"</span>, target)); <span class="comment">// alex</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getOwnMetadata(<span class="string">"name"</span>, target, <span class="string">"hello"</span>)); <span class="comment">// world</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classMetadata</span>(<span class="params">key: <span class="built_in">any</span>, value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    Reflect.defineMetadata(key, value, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodMetadata</span>(<span class="params">key: <span class="built_in">any</span>, value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyName: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Person.prototype.hello.name=world</span></span><br><span class="line">    Reflect.defineMetadata(key, value, target, propertyName);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给类本身增加元数据</span></span><br><span class="line"><span class="comment">//@Reflect.metadata('name','Person')</span></span><br><span class="line"><span class="meta">@classMetadata</span>(<span class="string">"name"</span>, <span class="string">"Person"</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">//给类的原型增加元数据</span></span><br><span class="line">  <span class="comment">//@Reflect.metadata('name', 'world')</span></span><br><span class="line">  <span class="meta">@methodMetadata</span>(<span class="string">"name"</span>, <span class="string">"world"</span>)</span><br><span class="line">  hello(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>, Person)); <span class="comment">// Person</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>, <span class="keyword">new</span> Person(), <span class="string">"hello"</span>)); <span class="comment">// world</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html5vedio</title>
      <link href="2021/01/04/html5vedio/"/>
      <url>2021/01/04/html5vedio/</url>
      
        <content type="html"><![CDATA[<h4 id="html5-播放器加速"><a href="#html5-播放器加速" class="headerlink" title="html5 播放器加速"></a>html5 播放器加速</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"></span><br><span class="line">video.playbackRate = <span class="number">2</span> <span class="comment">// 播放器播放速度</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browser-sync</title>
      <link href="2020/12/21/browser-sync/"/>
      <url>2020/12/21/browser-sync/</url>
      
        <content type="html"><![CDATA[<h2 id="全局安装1231312312312123"><a href="#全局安装1231312312312123" class="headerlink" title="全局安装1231312312312123"></a>全局安装1231312312312123</h2><p><code>sudo npm install -g browser-sync</code></p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器 监听所有的html文件</span></span><br><span class="line">$ browser-sync start --server --files <span class="string">"*.html"</span></span><br><span class="line"><span class="comment"># 启动服务器 监听所有的文件</span></span><br><span class="line">$ browser-sync start --server --files <span class="string">"**"</span></span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>browser-sync start --server --port 3333 --files &quot;*.css,*.html,*.js&quot;</code></p><h2 id="start-options"><a href="#start-options" class="headerlink" title="start options"></a>start options</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">help</span>                 <span class="comment">#输出使用信息</span></span><br><span class="line">--version               <span class="comment">#输出的版本号</span></span><br><span class="line">--browser               <span class="comment">#选择哪个浏览器应该是自动打开</span></span><br><span class="line">--files                 <span class="comment">#文件路径看</span></span><br><span class="line">--exclude               <span class="comment">#文件模式忽视</span></span><br><span class="line">--server               <span class="comment">#运行本地服务器（使用您的CWD作为Web根）</span></span><br><span class="line">--index                 <span class="comment">#指定哪些文件应该被用作索引页</span></span><br><span class="line">--extensions           <span class="comment">#指定文件扩展名回退</span></span><br><span class="line">--startPath             <span class="comment">#指定起始路径，打开浏览器</span></span><br><span class="line">--https                 <span class="comment">#启用S​​SL地方发展</span></span><br><span class="line">--directory             <span class="comment">#显示服务器的目录列表</span></span><br><span class="line">--proxy                 <span class="comment">#代理现有的服务器</span></span><br><span class="line">--xip                   <span class="comment">#使用xip.io域路由</span></span><br><span class="line">--tunnel               <span class="comment">#使用公共网址</span></span><br><span class="line">--open                 <span class="comment">#选择哪个URL是自动打开（本地，外部或隧道）</span></span><br><span class="line">--config               <span class="comment">#指定为BS-config.js文件的路径</span></span><br><span class="line">--host                 <span class="comment">#指定主机名使用</span></span><br><span class="line">--logLevel             <span class="comment">#设置记录器输出电平（沉默，信息或调试）</span></span><br><span class="line">--port                <span class="comment">#指定要使用的端口</span></span><br><span class="line">--reload-delay        <span class="comment">#以毫秒为单位的时间延迟重装事件以下文件的变化</span></span><br><span class="line">--reload-debounce      <span class="comment">#限制在浏览器中的频率：刷新事件可以被发射到连接的客户机</span></span><br><span class="line">--ui-port              <span class="comment">#指定端口的UI使用</span></span><br><span class="line">--no-notify            <span class="comment">#禁用浏览器的通知元素</span></span><br><span class="line">--no-open              <span class="comment">#不要打开一个新的浏览器窗口</span></span><br><span class="line">--no-online            <span class="comment">#强制离线使用</span></span><br><span class="line">--no-ui                <span class="comment">#不要启动用户界面</span></span><br><span class="line">--no-ghost-mode        <span class="comment">#禁用幽灵模式</span></span><br><span class="line">--no-inject-changes    <span class="comment">#刷新上的每个文件更改</span></span><br><span class="line">--no-reload-on-restart<span class="comment">#不要自动重新加载在重新启动所有浏览器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab3</title>
      <link href="2020/12/17/gitlab3/"/>
      <url>2020/12/17/gitlab3/</url>
      
        <content type="html"><![CDATA[<h2 id="gitlab-分支策略"><a href="#gitlab-分支策略" class="headerlink" title="gitlab 分支策略"></a>gitlab 分支策略</h2><blockquote><p>考虑到gitlab一般在企业内部使用，一般不存在社区开发者，所以在管理上不会采用github的upstream/origin双仓库模式。gitlab下，开发者们面向一个仓库进行提交即可；</p></blockquote><h3 id="设置对分支的保护权限"><a href="#设置对分支的保护权限" class="headerlink" title="设置对分支的保护权限"></a>设置对分支的保护权限</h3><blockquote><p>顾名思义，分支的权限必不可少，它可以约束开发者们的提交行为和提交策略。避免失误操作将未测试过的代码强制提交到生产分支；developer可以不关心；</p></blockquote><p><img src="branch.png" alt="Protected Branches"></p><h3 id="issue与Milestones"><a href="#issue与Milestones" class="headerlink" title="issue与Milestones"></a>issue与Milestones</h3><blockquote><p>issue可以理解为一个最小原子的任务，多个任务组成一个 milestones；Milestones 可以理解为某个时间区间内的任务集；一个Milestones可包含多个issue； 当该Milestones中所有issue完成，则标志着此Milestones的结束；</p></blockquote><h4 id="创建issue和mr"><a href="#创建issue和mr" class="headerlink" title="创建issue和mr"></a>创建issue和mr</h4><ol><li>创建一个issue</li></ol><p><img src="issue.png" alt="issue"></p><ol start="2"><li>关联一个mr</li></ol><p><img src="mr.png" alt="mr"></p><ol start="3"><li>branch name</li></ol><blockquote><p>branch name 会以issue的序号开始，然后抓取title中的英文和数字做连接。</p></blockquote><p>可采用<code>index-categroy-content-[username]-[time]</code>的自定义方式，括号部分可选</p><ul><li><p>category</p><ul><li>feature</li><li>bugfix</li><li>chore</li><li>enhance</li></ul></li><li><p>content，一到三个词简述任务</p></li><li><p>username，任务认领人</p></li><li><p>time，创建分支的时间，一般 <code>201217</code>或者<code>1225</code></p></li></ul><ol start="4"><li>source</li></ol><p>基于什么分支创建当前分支，<code>feature/chore/enhance</code>选择<code>dev-0.3</code>, <code>bugfix</code>选择<code>env-dev</code></p><h3 id="提交代码流程"><a href="#提交代码流程" class="headerlink" title="提交代码流程"></a>提交代码流程</h3><p><img src="flow.jpg" alt="flow"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch <span class="comment"># 获取issue关联的分支名</span></span><br><span class="line">git checkout -b 6-feature-pivotDrill origin/6-feature-pivotDrill <span class="comment"># 基于远端新建一个本地开发分支</span></span><br><span class="line"></span><br><span class="line">git rebase dev-0.3 <span class="comment"># 在开发过程中，不定时rebase 宿主分支，防止版本隔断</span></span><br><span class="line">git push origin 6-feature-pivotDrill <span class="comment"># 提交至远程映射</span></span><br><span class="line"><span class="comment"># 通知maintainer完成代码合并，并关闭issue</span></span><br></pre></td></tr></table></figure><h3 id="commits规范"><a href="#commits规范" class="headerlink" title="commits规范"></a>commits规范</h3><p><code>&#39;type(module) some desc&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type = [</span><br><span class="line">  <span class="string">"build"</span>, <span class="comment">// 构建执行</span></span><br><span class="line">  <span class="string">"chore"</span>, <span class="comment">// 构建工具相关</span></span><br><span class="line">  <span class="string">"ci"</span>, <span class="comment">// CI 相关</span></span><br><span class="line">  <span class="string">"docs"</span>, <span class="comment">// 文档更新</span></span><br><span class="line">  <span class="string">"feat"</span>, <span class="comment">// 新功能</span></span><br><span class="line">  <span class="string">"fix"</span>, <span class="comment">// bug 修复</span></span><br><span class="line">  <span class="string">"perf"</span>, <span class="comment">// 性能优化</span></span><br><span class="line">  <span class="string">"refactor"</span>, <span class="comment">// 功能重构</span></span><br><span class="line">  <span class="string">"release"</span>,</span><br><span class="line">  <span class="string">"revert"</span>, <span class="comment">// 回滚操作</span></span><br><span class="line">  <span class="string">"style"</span>, <span class="comment">// 样式变动</span></span><br><span class="line">  <span class="string">"test"</span>, <span class="comment">// 单元测试</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">moduele = [</span><br><span class="line">  <span class="comment">// 以davinci为例,只列出前端模块</span></span><br><span class="line">  <span class="string">"project"</span>,</span><br><span class="line">  <span class="string">"dashboard"</span>,</span><br><span class="line">  <span class="string">"display"</span>,</span><br><span class="line">  <span class="string">"widget"</span>,</span><br><span class="line">  <span class="string">"schdule"</span>,</span><br><span class="line">  <span class="string">"view"</span>,</span><br><span class="line">  <span class="string">"source"</span>,</span><br><span class="line">  <span class="string">"user"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="review代码的参考标准"><a href="#review代码的参考标准" class="headerlink" title="review代码的参考标准"></a>review代码的参考标准</h3><ol><li>格式化后的代码，在vscode中安装<code>prettier</code>工具，设置<code>ctrl+s</code>默认对当前页进行<code>prettier</code>格式化；</li><li>所有commits必须要关联issue，如果没有issue要新建issue然后关联mr（merge request），基于当前mr提交代码；</li><li>原则上，不能有肉眼可见的bug，一般review代码时会进行简单的测试；</li><li>其他规则（代码规范）</li></ol><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><blockquote><p>原则上，所有新提交的代码参考项目代码风格即可。简述为下面几个方面</p></blockquote><ol><li>原则上，变量名含义精准，（ps：严禁全局作用域中出现单字符命名空间；）</li><li>不要求一定要加注释或者不加注释，我们的愿景是能够书写无注释就能看懂的代码。根据业务逻辑难易程度，自行决定。 尽量英文注释；</li><li>不建议提交大量重复代码，须做好代码的抽象复用；</li><li>尽量使用被主流浏览器支持的的es规范书写代码，原则上新es规范下已有的工具类和函数，不重复造轮子；</li><li>其他涉及<code>html/css/javascript</code>相关的推荐规范会渐进式纳入规范集；</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab2</title>
      <link href="2020/12/16/gitlab2/"/>
      <url>2020/12/16/gitlab2/</url>
      
        <content type="html"><![CDATA[<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p><img src="label.png" alt="label"></p><h3 id="标签组"><a href="#标签组" class="headerlink" title="标签组"></a>标签组</h3><blockquote><p>标签组的意义就是定义一次，多个项目统一使用</p></blockquote><h4 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h4><blockquote><p>前端还是后端，ios 还是 android</p></blockquote><ul><li>angular</li><li>node</li></ul><h4 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h4><blockquote><p>目前产品中存在的问题，以及该问题的优先级程度</p></blockquote><ul><li>bug： 常规bug</li><li>security： 安全漏洞</li><li>production： 涉及到生产环境</li></ul><h4 id="Mindless"><a href="#Mindless" class="headerlink" title="Mindless"></a>Mindless</h4><blockquote><p>影响较小的任务，比如更改文件夹目录，适配规范</p></blockquote><ul><li>chore</li><li>legal</li></ul><h4 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h4><blockquote><p>影响用户体验，或者用户对产品的理解. These can be both opportunities and “UX bugs”.</p></blockquote><ul><li>copy</li><li>design</li><li>ux: User Experience</li></ul><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><blockquote><p>服务器环境，开发环境，生产环境或者测试环境</p></blockquote><ul><li>staging</li><li>test</li></ul><h4 id="Feedback"><a href="#Feedback" class="headerlink" title="Feedback"></a>Feedback</h4><blockquote><p>待确认的问题，比如一些拍脑袋的需求；或者某个需求我们还没决定怎么实现</p></blockquote><ul><li>discussion</li><li>question： 还没到需要讨论的情况</li><li>rfc</li></ul><h4 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h4><blockquote><p>现有功能或基础架构上的迭代。</p></blockquote><ul><li>enhancement: 现有模块有更高的完成度</li><li>optimization: 现有功能代码层面的重构，或者交互流程上的梳理</li></ul><h4 id="Additions"><a href="#Additions" class="headerlink" title="Additions"></a>Additions</h4><blockquote><p>新功能，新页面</p></blockquote><ul><li>feature</li></ul><h4 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h4><blockquote><p>现在不好说，未来肯定有结果，可能做成功， 可能做不成；</p></blockquote><ul><li>in progress： 进行中的需求</li><li>watchlist： 先拖着的需求，有可能就拖掉了</li></ul><h4 id="Inactive"><a href="#Inactive" class="headerlink" title="Inactive"></a>Inactive</h4><blockquote><p>无需采取任何行动或可能采取任何行动。该问题已解决，可以通过其他问题更好地解决；</p></blockquote><ul><li>invalid： 无效的</li><li>wontfix： 不会修复</li><li>duplicate： 重复</li><li>on hold： 等待候听</li></ul>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab 使用</title>
      <link href="2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="软件开发阶段"><a href="#软件开发阶段" class="headerlink" title="软件开发阶段"></a>软件开发阶段</h2><blockquote><p>软件开发十个阶段在gitlab中对应的管理方式方法</p></blockquote><ol><li>IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了<code>Mattermost</code> 它类似一个聊天工具。</li><li>ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在工单追踪器<code>issue tracker</code>中帮助你去提升这个点子。</li><li>PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用工单看板<code>Issue Board</code>。</li><li>CODE： 现在，当一切准备就绪，我们可以开始写代码了。</li><li>COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。</li><li>TEST： 通过<code>GitLab CI</code>，我们可以运行脚本来构建和测试我们的应用。</li><li>REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行代码复审<code>code review</code>以及批准。</li><li>STAGING：： 预发布环境。</li><li>PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了。</li><li>FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 <code>Cycle Analytics</code>来对当前项目中关键的部分进行的反馈</li></ol><h2 id="issue-和-milestone"><a href="#issue-和-milestone" class="headerlink" title="issue 和 milestone"></a>issue 和 milestone</h2><blockquote><p>milestone里程碑，用来标识阶段性目标， 对目标进行细化，化整为零一个个的issues，然后根据每个issues的紧急程度选择性的完成。等所有issues解决完之后 就标志着阶段性目标已完成；</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>把实际问题转化为issue，这些问题可以标记为<code>正在解决</code>和<code>计划解决</code>；</li><li>milestone对应着阶段性项目计划，然后细分为多个issues，而且可以指定完成时间，gitlab会自动生成完成进度情况概略图。</li><li>issues也可以是一个建议，共给大家一起讨论；</li><li>milestone 和issue建立时我们通常可以对问题进行简单描述，并且记录问题的解决过程，包括他人提出的疑问也可以在这里记录，后期可以随时查看；</li></ol><h3 id="创建milestone"><a href="#创建milestone" class="headerlink" title="创建milestone"></a>创建milestone</h3><blockquote><p>可以在项目开始前创建milestone，后面建issues时关联它，也可以先建issues，后期由项目负责人建milestone，然后把所有issues关联过来；</p></blockquote><ol><li>创建一个名字</li><li>简单描述，简述创建的原因，这个里程碑最终的目的，编辑的时候可以直接贴图，也可以添加附件（支持markdown格式，可以预览）</li><li>指定计划的完成时间；</li></ol><h3 id="新建issues"><a href="#新建issues" class="headerlink" title="新建issues"></a>新建issues</h3><blockquote><p>一个issues表示一个功能、一个bug、一个建议; 新建议题很简单，标题+描述+计划时间+指定人+里程碑，里程碑一定要指定一下，还可以加标签。</p></blockquote><ol><li>功能：里程碑的细分，尽量小，方便merger时的代码审核；</li><li>bug：解决程序中存在的某些问题；</li><li>建议：可以作为一个讨论交流区，也可以实现它;</li><li>一个issues 对应一个指定人，一个git 分支；</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="2020/12/09/test/"/>
      <url>2020/12/09/test/</url>
      
        <content type="html"><![CDATA[<h2 id="配置hexo到阿里云"><a href="#配置hexo到阿里云" class="headerlink" title="配置hexo到阿里云"></a>配置hexo到阿里云</h2><blockquote><p>网上大多数教程问题不大，额外需要注意修改一些文件的写入权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将post-receive 设置为可执行文件</span></span><br><span class="line">chmod +x ~/hexo.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置博客源地址文件夹权限，不然git hooks写入不了，Unable to unlink 就是这种原因</span></span><br><span class="line">sudo chmod -R 777 /home/www/hexo</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> doc </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo</title>
      <link href="2020/06/04/hello-world/"/>
      <url>2020/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloworld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(helloworld);</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> doc </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
