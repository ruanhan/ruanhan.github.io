{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-08-20T05:55:31.000Z","updated":"2020-08-20T07:19:22.806Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-20T05:58:38.000Z","updated":"2020-08-20T07:18:21.424Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack5_1","slug":"webpack5-1","date":"2021-02-23T06:50:45.000Z","updated":"2021-02-23T06:55:11.632Z","comments":true,"path":"2021/02/23/webpack5-1/","link":"","permalink":"http://yoursite.com/2021/02/23/webpack5-1/","excerpt":"","text":"1. Webpack5 迁移1.1 坑1.1.1 第一坑","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"graphics1","slug":"graphics1","date":"2021-02-09T10:24:13.000Z","updated":"2021-02-11T00:00:59.294Z","comments":true,"path":"2021/02/09/graphics1/","link":"","permalink":"http://yoursite.com/2021/02/09/graphics1/","excerpt":"","text":"前置 1. Course Topis（mainly 4 parts） Rasterization （光栅化） Curves and Meshes Ray Tracing （光线追踪） Animation/Simulation （动画/模拟） 1.1 Rasterization光栅化， 把三维空间的几何形体显示在屏幕上。这就是光栅化。 实时的计算机图形学的主要应用，在计算机图形学的范畴内，实时的定义我们认为是每秒钟生成30幅画面或者叫30帧，能达到这个级别就叫实时，否则叫离线； 1.2 Curves and Meshes在图形学中，如何表示一条光滑的曲线。如何表示曲面。 1.3 Ray Tracing （光线追踪）生成真实美观的画面； trade off 取舍","categories":[{"name":"graphics","slug":"graphics","permalink":"http://yoursite.com/categories/graphics/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"liner_Algebra","slug":"liner-Algebra","date":"2021-02-08T13:59:25.000Z","updated":"2021-02-21T10:25:54.752Z","comments":true,"path":"2021/02/08/liner-Algebra/","link":"","permalink":"http://yoursite.com/2021/02/08/liner-Algebra/","excerpt":"","text":"一系列简短可刷的视频，将线性代数中的几何直觉动画化； 即使你能跟上视频的速度，你也需要留点时间给自己思考，学习往往发生在此刻； 1. 向量1.1 含义线性代数中最基础、最根源的组成部分就是向量； 一般来说，有三种看待向量的观点，看似不同却有所关联； 1.1.1 物理专业视角向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向；但是只要以上两个特征相同，你可以自由移动一个向量而保持它不变； 二维向量 处在平面中的巷里那个是二维的； 三维向量 而处在我们所生活的空间中的向量是三维的； 1.1.2 计算机专业视角从计算机专业学生的视角看，向量是有序的数字列表；比如你正在做一些有关房价的分析；而你只关心两个特征： ``房屋面积和价格`。 你可能会用一对数字对每个房屋进行建模；第一个数代表房屋面积，第二个数代表价格； 注意，这里的数字顺序不可颠倒；用行话来讲，你会用二维向量对房屋进行建模；在这里，“向量”只不过是“列表”的一个花哨的说法；之所以这个向量是二维的，是因为这个列表的长度是2； 1.1.3 数学专业视角另一方面，数学家试图去概括这两种观点，大致地说，向量可以是任何东西。只要保证两个向量相加以及数字与向量相乘是有意义的即可； 向量加法和向量数乘贯穿线性代数始终，二者起着很重要的作用 一种思考“向量”的特定方式 现在关注的是它的几何方面，首先需要考虑一个箭头，考虑这个箭头在某个坐标系中，比如x-y平面。并且箭头起点位于原点；这与物理专业学生的看法略有不同。因为在他们眼中，向量可以在空间中自由落脚；但是在线性代数中，向量经常以原点作为起点； 一旦你理解了“向量是空间中的箭头”这种观点，就来看看“向量是有序的数字列表”这种观点； 在直角坐标系中，一个向量的坐标由一对数构成；（-2，3），这对数指导你如何从原点（向量起点）出发到达它的尖端（向量终点） 第一个数告诉你沿着X轴走多远，正数代表向右移动，负数代表向左移动； 第二个数告诉你沿着Y轴走多远；正数代表向上移动，负数代表向下移动； 为了把向量和点区别开，惯用方法是把这对数竖着写，然后用方括号括起来；每一对数给出唯一一个向量； 1.2 向量的和 平移第二个向量，使它的起点与第一个向量的终点重合。然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是它们的和； 顺便一提，这个向量加法的定义差不多是线性代数中唯一允许向量离开原点的情形； 1.2.1 数学角度看向量加法 我们重新编排它们的吮吸，使得我们先完成所有水平运送，再完成所有竖直运动； 所以新向量的坐标就是 (1+3, 2+(-1)); 即(x1+x2,y1+y2),总体来说，在“向量是有序的数字列表”观点里，向量加法就是把对应项相加； 1.3 向量数乘另一个向量基础运算就是向量数乘 1.3.1 缩放比如说你选择数字2，把它与一个给定向量相乘。意味着你把这个向量拉长为原向量的2倍。 如果将向量乘以1/3，就意味着这个向量长度缩短为原来的1/3.如果乘以-1.8，相当于往反方向拉长1.8倍；2,1/3,-1.8,它们用于缩放向量，被称为“标量”实际上自始至终，数字在线性代数中起到的主要作用就是缩放向量；所以，“标量”和“数字”两个词通常在这里可以相互替换； 这种拉伸或压缩，有时又使向量反向的过程被称为“缩放”； 1.3.2 数学角度看向量数乘从数字的角度来看，将一个向量伸长为原来的2倍；对应于将每一个分量分别乘以2； 所以将向量看作一个数字列表时，向量与标量相乘就是将向量中的每个分量与标量相乘； 1.4 向量点乘与叉乘1.5 总结线性代数围绕两种基本运算： 向量加法与向量乘法“究竟是什么意思了”； 为什么数学家只考虑这两种运算，并且又是如何将它们抽象独立出来，不管你选什么代表向量都与之无关； 实际上无论你怎么看待向量都无所谓，或把向量看作空间中的箭头；或者把向量看作数字列表；这种观点又恰好有漂亮的几何意义与之对应。线性代数的效用很少提现在这些观点的其中一个上，而是更多地体现在它能够在这些观点中相互转化； 线性代数为数据分析提供了一条将大量数据列表概念化、可视化的渠道；它让数据样式变得非常明晰，并让你大致了解特定运算的意义； 另一方面，线性代数给物理学家和计算机图形程序员提供了一种语言；让他们通过计算机能处理数字来描述并操纵空间； 2. 线性组合、张成的空间与基2.1 基向量关于向量坐标，还有一种有趣的方式来看待这些坐标，它对线性代数很重要。当你看到一对描述向量的数时，比如（3，-2），可以把它的每个坐标看作一个标量； 在xy坐标系中，有两个非常特别的向量。一个指向正右方，长度为1，通常被称为i 帽或者x方向的单位向量；另一个指向正上方，长度为1。通常被称为j帽 或者y方向的单位向量； 现在想象向量(3,-2)的x坐标是一个标量，它将i帽拉伸为原来的3倍；它将j帽拉伸为原来的2倍；从这个角度去看，这个向量实际上是两个经过缩放的向量的和； “缩放向量并且相加” 这一概念至关重要，i 与 j 是xy坐标系的“基向量”；它们合起来被称为坐标系的基； 这是在说，当你把坐标看作标量时；基向量实际上就是这些标量缩放的对象； 我们根据这两个特殊的基向量构建坐标系时，也浮现了一些有趣而微妙的问题，如果我们选择不同的基向量会怎么样？我们完全可以选择不同的基向量，获得一个合理的新坐标系； 比如说，随便选一个指向右上方的向量（红色），再随便选一个指向右下方的向量（蓝色）。想象一下，通过选择两个标量，分别用于缩放二者的其中一个；然后把它们相加，你能得到不同的结果； 通过改变所选择的标量，你可以得到哪些二维向量？ 答案是，你可以得到所有的二维向量。为什么呢？ 这样一对新的基向量，同样允许我们在一对数和二维向量之间自由转化； 但是这种变换关系与之前用i帽 和 j帽的变换关系完全不同； 每当我们用数字描述向量时，它都依赖于我们正在使用的基两个数乘向量和被称为这两个向量的线性组合。 2.2 向量张成的空间（span）“线性”这个词从哪儿来？这根直线又又什么关系？ 如果固定其中一个标量，让另一个标量自由变化。所产生的向量的终点会描出一条直线；(下面两张图分别为固定向量W缩放V 和 固定V缩放W) 如果你让两个标量同时自由变化，考虑所有可能得到的向量；可能有两种情况； 大部分情况下，对于一对初始向量，你能到达平面中的每一个点；所有二维向量都尽在掌握； 但是也有糟糕的情况，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上； 实际上还有第三种情况： 两个向量都是零向量。那就只能乖乖呆在原点了； 所有可以表示为给定向量线性组合的向量的集合；被称为给定向量张成的空间（span）; 现在用行话重新叙述刚才的内容；对大部分二维向量对来说，它们张成的空间是所有二维向量的集合。 但当共线的时，它们张成的空间就是终点落在一条直线上的向量的集合； 线性代数紧紧围绕向量加法与数乘 两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么？ 现在是时候讨论一下通常我们是如何将向量看作点的； 想象落在一条直接上的一些向量时，你会觉得拥挤。而同时想象所有二维向量填满平面时，你会觉得非常拥挤； 所以为了对抗这种情况，通常我们就用向量的终点代表改向量。而像以往一样，它的起点仍旧位于原点；用这种方法来看，如果你要考虑落在一条直线上的所有向量时，你需要考虑直线本身就行了；类似地，同时考虑所有二维向量时，将每个向量抽象为它的终点；实际上，你就不必考虑所有的箭头了，只需要考虑无限大的二维平面本身即可； 当你只考虑一个向量时，就把它看作箭头。当你考虑多个向量时，就把它们都看作点；前面有提到对大部分二维向量来说，它们张成的空间是整个无限大的二维平面；如果共线，它们张成的空间就是一条直线； 2.2.1 两个三维向量张成的空间是什么样的？如果我们再去考虑三维空间，张成空间这个概念就开始变得有趣了。这两个向量张成的空间就是它们所有可能的线性组合。 这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量张成的空间；或者说，所有终点落在这个平面上的向量的集合是这两个向量张成的空间； 如果再加上第三个向量，那么它们张成的空间又是什么样的呢？ 会有两种情况，如果第三个向量恰好落在前两个向量所张成的平面上。那么它们张成的空间并不会改变，还是被困在这个平面上； 另外一种情况，如果你随机选一个向量，它几乎不可能落在前面两个向量所张成的平面中。这种情况下，由于第三个向量指向不同的方向。当你缩放第三个向量时，它将前两个向量张成的平面沿它的方向来回移动，从而扫过整个空间； 2.3 线性无关与线性相关当有多个向量，并且可以移除其中一个而不减少张成的空间。当这种情况发生时，我们称它们是“线性相关”的；另一种表述方法是其中一个向量，可以表示为其它向量的线性组合，因为这个向量已经落在其它向量张成的空间之中； 另一方面，如果所有向量都给张成的空间增添了新的维度；它们就被称为是“线性无关”的。 2.4 小结“向量空间的一组基是张成该空间的一个线性无关的向量集；” 空间的一组基的严格定义是这样的： 张成该空间的一个线性无关向量的集合，基于目前对“张成” 和 “线性无关” 这两个词的理解。思考一下为什么这个定义合乎情理； 3. 矩阵与线性变换3.1 线性变换 很遗憾， Matrix（矩阵）是什么是说不清的，你必须得自己亲眼看看； “如果要我选出一个主题，它不仅让线性代数的其它内容一目了然，又经常被初次学习线性代数的人忽视，我会选择这个——线性变换的概念以及它和矩阵的关系” 在这期视频中，只会集中讨论这些变换在二维空间中长什么样。以及它们如何与矩阵向量乘法关联。尤其展示一种不用死记硬背的考虑矩阵向量乘法的方法； 首先，先来解析“线性变换”这个术语。“变换”本质上是“函数”的一种花哨的说法，它接收输入内容，并输出对应结果； 特别地，在线性代数的情况下。我么考虑的是接收一个向量并且输出一个向量的变换； 特别的，在线性代数的情况下。我们考虑的是接收一个向量并且输出一个向量的变换； 既然“变换”和“函数”意义相同，为什么还要使用前者而不是后者？因为使用“变换”是在暗示以特定方式来可视化这一输入-输出关系； 一种理解“向量的函数”的方法是使用运动。 如果一个变换接收一个向量并输出一个向量；我们想象这个输入向量移动到输出向量的位置； 接下来，要理解整个变换。我们可以想象每一个输入向量都移动到对应输出向量的位置；同样多个箭头显得很拥挤，只用终点表示该向量，用这种方法考虑所有输入向量都移动到对应输出向量的位置时。我们只用看空间中的所有点移动到其它点的位置； 各种个样对空间的变换所产生的效果是美妙的，任意一个变换可以非常复杂。幸运的是，线性代数限制在一种特殊类型的变换上；这种变换更容易理解，称为线性变换 直观地说，如果一个变换具有以下两条性质，我们就称它是线性的； 一是直线在变换后仍然保持为直线，不能有所弯曲； 二是原点必须保持固定； 举例： 上图变换保持原点不动，乍一看它好像保持直线平直；但实际并非如此，因为只展示了水平和竖直的网格线； 当你看看它对一条对角线的作用时，很明显它不是一个线性变换； 总体来说，你应该把线性变换看作是“保持网格线平行且等距分布”的变换； 3.1.1 如何用数值描述线性变换 当你在通过编程制作动画和视频来教授这一主题，你应该给计算机什么样的计算公式；使得你给它一个向量的坐标，它能给你变换后向量的坐标呢？ 实际结果是，你只需要记录两个基向量i帽和j帽变换后的位置； 比如说，考虑坐标为（-1，2）的向量V。 这个向量就是 -1 与 i帽之积与2与j帽之积的和； 如果运用一些变换，并且跟随这三个向量的运动。网格线保持平行且等距分布的性质有一个重要的推论； 变换后的向量V的位置，是-1与变换后的i帽之积，加上2与变换后的j帽之积； 换句话说，向量V是i帽和j帽的一个特定线性组合，那么变换后的向量V也是变换后i帽和j帽的同样的线性组合；这意味着，你可以只根据变换后的i帽和j帽，就推断出变换后的V； 如上图所示的变换，可以看出i帽落在坐标（1，-2）上。j帽落在x轴上，坐标为（3，0）；也就是说，-1乘以i帽加上2乘以j帽所代表的向量；会落在-1 乘以向量（1，-2）加上2乘以向量（3，0）的位置上；简单运算之后，你就能推断出向量V一定落在向量（5，2）上； 1Transformed V = -1(Transformed i) + 2(Transformed j) 实际上，因为展示出整个变换的样子。完全可以直接读出向量V在变换后落在坐标（5，2）上；但是更炫酷的是，只要记录了变换后的i帽和j帽。我们就可以推断出任意向量在变换之后的位置；完全必须观察变换本身是什么样。 一般情况下，一个向量的坐标是（x，y），变换后这个向量就是x乘以变换后的i帽（1，-2）；加上y乘以变换后的j帽（3，0）。简单运算之后你就知道它落在坐标（1x+3y, -2x+0y）上。运用这个公式，我给你任意一个向量，你都能告诉它在变换后的位置； 以上这些内容是在说，一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标。通常我们将这些坐标包装在一个2*2的格子中，称它为2*2矩阵； 你可以把它的列理解为两个特殊的向量，即变换后的i帽和j帽。如果你有一个描述线性变换的2*2矩阵，以及一个给定向量；你想了解线性变换对这个向量的作用；你只需要取出向量的坐标；将它们分别与矩阵的特定列相乘，然后将结果相加即可；这与“缩放基向量再相加”的思想一致 4. 矩阵乘法与线性变换复合5. 三维空间中的线性变换6. 行列式7. 逆矩阵、列空间与零空间8. 非方阵9. 点积与对偶性10. 叉积的标准介绍11. 以线性变换的眼光看叉积12. 基变换13. 特征向量与特征值14. 抽象向量空间15. 克莱姆法则，几何解释","categories":[{"name":"algebra","slug":"algebra","permalink":"http://yoursite.com/categories/algebra/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"}]},{"title":"cli","slug":"cli","date":"2021-02-07T07:50:09.000Z","updated":"2021-02-20T07:31:56.962Z","comments":true,"path":"2021/02/07/cli/","link":"","permalink":"http://yoursite.com/2021/02/07/cli/","excerpt":"","text":"1. Quick start1.1 创建文件夹12$&gt; mkdir sunmao &amp;&amp; cd sunmao &amp;&amp; npm init -y$&gt; touch sm.js 1.2 设置package.json12345678910111213141516171819202122&#123; \"name\": \"sunmao\", \"bin\": &#123; \"sunmao\": \"sm.js\" // 添加 bin 配置，sumao 命令即 指向 sm.js &#125;, \"version\": \"0.0.1\", \"description\": \"A Iterating scaffolding for react, redux-saga and Typescript\", \"main\": \"main.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/TenonMortise/sunmao\" &#125;, \"author\": \"ruanhan\", \"license\": \"MIT\", \"bugs\": &#123; \"url\": \"https://github.com/TenonMortise/sunmao/issues\" &#125;, \"homepage\": \"https://github.com/TenonMortise/sunmao#readme\"&#125; 1.3 npm link1234// sm.js#!/usr/bin/env nodeconsole.log('hello, sunmao') 123456789$&gt; chmod 755 sm.js$&gt; sudo npm linkup to date in 10.078s/usr/local/bin/sunmao -&gt; /usr/local/lib/node_modules/sunmao/sm.js/usr/local/lib/node_modules/sunmao -&gt; /Users/ruanhan/sunmao$&gt; sunmao$&gt; hello, sunmao 参考文档： npm link 1.4 npm unlink如果你的项目不再需要该模块，可以在项目目录内使用npm unlink命令，删除符号链接。 2. 第三方工具介绍2.1 commander.js可以自动的解析命令和参数，用于处理用户输入的命令。 2.2 download-git-repo,下载并提取 git 仓库，用于下载项目模板。 2.3 inrequire.js通用的命令行用户界面集合，用于和用户进行交互。 2.4 ora下载过程久的话，可以用于显示下载中的动画效果。 2.5 chalk可以给终端的字体加上颜色。 2.6 log-symbols可以在终端上显示出 √ 或 × 等的图标。 2.7 install1npm install commander download-git-repo inquirer ora chalk log-symbols","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"dp","slug":"dp","date":"2021-02-02T02:16:56.000Z","updated":"2021-02-09T10:27:09.525Z","comments":true,"path":"2021/02/02/dp/","link":"","permalink":"http://yoursite.com/2021/02/02/dp/","excerpt":"","text":"1 动态规划题目特点 计数类 有多少种方式走到右下角 有多少种方法选出K个数使得和是sum 求最大最小值（DP最大的一类） 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出K个数使得和是sum 2 dp解题步骤以 Coin Change 为例； 三种硬币，分别面值2元，5元和7元， 没种硬不都有足够多，去书店买本书需要27元。如何用最少的硬币组合正好付清，不需要对方找钱 分析： 这题出现求最少，显然可以使用DP方法来解决 2.1 动态规划组成部分一： 确定状态2.1.1 状态在动态规划中的作用属于定海神针2.1.2 简单来说，解动态规划的时候需要开一个数组，数组的每个元素f[i] 或者 f[i][j]代表什么； 类似于解数学题中，X， Y，Z代表什么；2.1.3 确定状态需要两个意识：2.1.3.1 最后一步 虽然我们不知道最优策略是什么，但是最优策略肯定是K梅硬币a1,a2,…,ak 面值加起来是27； 最后一步指的就是最优策略中的最后一个决策，对应到这一题就是一定会有一枚最后的硬币决策： ak， 那么除了这枚硬币，前面硬币的面值加起来是27-ak； 关键点1： 我们不关心前面的 k-1 枚硬币是怎么拼出27-ak的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道ak 和k， 但是我们确定前面的硬币拼出了 27-ak； 关键点2: 因为是最优策略，所以拼出27-ak的硬币数一定要最少，否则这就不是最优策略了； 解析关键点2： 比如最优策略要用5枚硬币，假设最后一枚是5元面额，那么4枚硬币组成了22元。你不可能用3枚，2枚甚至1枚拼成22元； 浅显的道理，如果用3枚可以拼出来22元的话，那么最优策略要用5枚的假设就不成立； 2.1.3.2 子问题我现在当然想求K，但是想求K的话，需要知道前面k-1等于几。（即最少需要多少枚硬币可以拼出27-ak） 所以，我们的要求就变成了：最少要用多少枚硬币可以拼出27-ak枚硬币； 原问题是最少用多少枚硬币拼出27； 我们将原问题转化成了一个子问题，而且规模更小： 27-ak 那该如何定义状态呢，一旦子问题出来了，状态就直接把相同的汉字copy下来。即最少用多少枚硬币拼出X 为了简化定义，我们设状态 f(x)=最少用多少枚硬币拼出x结合这一题就是f(x)=最少用多少枚硬币拼出27.整个问题就变成，以前求f(27),现在求f(27-ak); 等等，我们还不知道最后那枚硬币ak是多少， 当然最后那枚硬币ak只可能是2，5或者7 如果ak是2的话，f(27)应该是f(27-2)+1（加上最后这一枚硬币2） 如果ak是5的话，f(27)应该是f(27-5)+1（加上最后这一枚硬币5） 如果ak是7的话，f(27)应该是f(27-7)+1（加上最后这一枚硬币7） 除此之外，没有其他的可能了； 因为我们需求最少的硬币数，所以： 1f(27) = min&#123;f(27-2)+1, f(27-5)+1, f(27-7)+1&#125; 2.1.4 递归解法的问题递归做了很多重复计算，效率低下 如何避免？ DP是将计算结果保存下来，并改变计算顺序； 2.2 动态规划组成部分二： 转移方程设状态f[x] = 最少用多少枚硬币拼出X； 对于任意X 2.2.1 f[x] 与 f(x)的区别f[x] ，[] 代表数组下标 f(x) ，（）代表函数调用 2.3 动态规划组成部分三： 初始条件和边界条件f[x]=min{f[x-2]+1, f[x-5]+1, f[x-7]+1} 两个问题 x-2, x-5或者x-7 小于0怎么办？什么时候停下来？ 如果不能拼出Y，就定义f[Y] = 正无穷，例如 f[-1] = f[-2] = … = 正无穷 所以f[1] = min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1； 初始条件： f[0] = 0; 因为初始条件用转移方程是算不出来的。但我又需要它的定义。 根据 f[0] = min{f[-2]+1, f[-5]+1, f[-7]+1} 算，f[0]是正无穷的。而我们明明知道，f[0] 不等于正无穷，而是等于0，所以需要手动制定。有的时候初始条件不需要给很多个，比如f[0], f[1], f[2] 等等是不需要额外多个去定义，定不定义该值取决于能否根据其他预设的值;比如f[1] 是正无穷，f[2] = {f[0]+1, f[-3]+1, f[-5]+1} 是 1， 然后后面的值都能基于此算出来了； 初始条件的实质就是把那些最小的值定义下来，边界情况的实质就是不要数组越界；不管数组往下越界到负数，还是数组往上越界超过了都不行； 2.4 动态规划组成部分四：计算顺序拼出X所需要的最少硬币数： f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1} 初始条件： f[0] = 0 然后计算 f[1], f[2],… , f[27] （对于此题来说，是从小到大来计算，DP大多数情况下都是从小到大，二维的话就是从上到下，从左到右） 计算顺序只有一个原则，那就是当我们计算到f[X]时，f[X-2], f[X-5], f[X-7] 都已经出结果了； 2.5 动态规划计算步骤f[X] = 最少用多少枚硬币拼出X f[X] = 正无穷 表示无法用硬币拼出X 每一步尝试三种硬币，一共27步； 与递归算法相比，没有任何重复计算； 算法时间复杂度（即需要进行的步数）： 27*3 (总面额*多少种硬币) 1234567891011121314151617181920212223242526272829303132333435363738/** * * @param &#123;*&#125; A [2, 5, 7] * @param &#123;*&#125; M 27 */function coinChange(A, M) &#123; // 0 ... n: [n+1] // 0 ... n-1: [n] const f = new Array(M + 1); // number of kind of coins let n = A.length; // initialization f[0] = 0; let i, j; //最少用多少枚硬币 依次拼出 f[1], f[2], ... f[27]，从小到大的顺序 for (i = 1; i &lt;= M; ++i) &#123; // 初始设置为无穷大 f[i] = Number.MAX_VALUE; // last coin A[j] 要拼出i块钱，最后一枚硬币应该是谁（这枚硬币不应该跳出A的范围） // f[i] = min&#123;f[i-A[0]] + 1,..., f[i-A[n-1]]+1&#125;; for (j = 0; j &lt; n; ++j) &#123; if (i &gt;= A[j] &amp;&amp; f[i - A[j]] != Number.MAX_VALUE) &#123; // i - A[j] 可能是负数，所以需要添加判断 // 无穷大不能+1，会越界。所以需要添加校验； f[i] = Math.min(f[i - A[j]] + 1, f[i]); &#125; &#125; &#125; if (f[M] == Number.MAX_VALUE) &#123; // 如果拼不出来，要求返回-1； f[M] = -1; &#125; return f[M];&#125;console.log(coinChange([1, 5, 6], 27)); 2.6 小结求最值型动态规划 动态规划组成部分： 确定状态 最后一步 (最优策略中使用的最后一枚硬币ak) 化成子问题 （最少的硬币拼出更小的面值27-ak） 转移方程 f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1} 初始条件和边界条件 f[0] = 0, 如果不能拼出Y，f[Y]= 正无穷 计算顺序 f[0], f[1], f[2], … 消除冗余，加速计算；","categories":[{"name":"algo","slug":"algo","permalink":"http://yoursite.com/categories/algo/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"webgl01","slug":"webgl01","date":"2021-01-28T02:30:44.000Z","updated":"2021-02-17T08:29:26.395Z","comments":true,"path":"2021/01/28/webgl01/","link":"","permalink":"http://yoursite.com/2021/01/28/webgl01/","excerpt":"","text":"1. 图形系统绘图原理webgl绘图，要深入细节里，根内存、cpu交互，真正控制图形输出的每一个细节； webgl基础概念，GPU， 渲染管线，着色器； 1.1 计算机图形系统一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。 光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。 像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。 帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。 CPU（Central Processing Unit）：中央处理单元，负责逻辑计算。 GPU（Graphics Processing Unit）：图形处理单元，负责图形计算。 1.1.1 绘图通用过程首先，经过CPU处理，成为具有特定结构的几何信息，然后，这些信息会被送到GPU中进行处理。在GPU中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上； 这个过程主要分为两个步骤， 一是对 给定的数据结合绘图的场景进行计算（例如相机，光源，遮挡物体等等）进行计算，最终将图形变为屏幕空间的2D坐标。 二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上，这整个过程是一步一步进行的，前一步的输出就是最后一步的输入，这个过程叫做渲染管线（RenderPipelines） 1.1.2 GPUCPU 和 GPU 都属于处理单元，但是结构不同。 CPU像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物，一条CPU流水线串行处理这些任务的速度，取决于CPU（管道）的处理能力；一个计算机系统会有很多条CPU流水线，任何一个任务 都可以随机通过任意一个流水线，这样计算机就能够并行处理多个任务了，这样一条流水线对应的就是 thread； CPU处理大型任务是足够的，但是处理图像应用就不合适了。处理图像，实际上是处理计算图片上每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成一个简单的任务，而每一个图片应用又是由无数个个像素点组成的，所以，需要在同一时间处理无数个小任务。要处理这么多的小任务，使用更小，更多的处理单元，是一种更好的处理方式，GPU就是这样的处理单元； GPU由大量的小型处理单元构成，它没有CPU那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张800*600大小的图片，GPU也可以保证这48万个像素点分别对应一个小单元，这样就可以同时对每个像素点进行计算了； 2 .helloWorld浏览器提供的webgl API是 OpenGL ES的js绑定版本，它赋予了开发者操作GPU的能力。这一特点也让webGL的绘图方式略微复杂，无法直接调用API控制画笔。大致需要以下几个步骤 2.1 webGL绘图步骤 创建webgl上下文 创建webgl程序 将数据存入缓冲区 将缓冲区数据读取到GPU GPU执行webgl程序，输出结果 2.1.1 创建webgl上下文1const gl = canvas.getContext('webgl'); 2.2.2 创建webgl程序webgl程序是一个webGL Program对象，它是给GPU 最终运行着色器的程序； 首先编写两个着色器；两个着色器分别对应的是 顶点 和图元， webgl是以顶点和图元来描述图形几何信息的；所以顶点和图元是绘图过程中必不可少的。webgl绘制一个图形的过程，一般需要两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，一段叫片元着色器（Fragment Shader）负责处理图形的像素信息； 2.2.2.1 顶点顶点就是几何图形的顶点，三角形有三个顶点，四边形有四个顶点。 2.2.2.2 图元图元是webgl可直接处理的图形单元，由webgl绘图模式决定，有点、线、三角形等；webgl中最小的图元是三角形； webgl支持的图元类型有七种； gl.POINTS(点), gl.LINES(线段), gl.LINE_STRIP(线条), gl.LINE_LOOP(回路), gl.TRIANGLES(三角形), gl.TRIANGLE_STRIP(三角带), gl.TRIANGLE_FAN(三角扇)。 要绘制空心三角形，gl.LINE_STRIP(线条)、gl.LINES(线段)、 gl.LINE_LOOP(回路)都可以实现。 但是gl.LINES(线段)需要写入六个顶点([-1, -1, 0, 1, 0, 1, 1, -1, 1, -1,-1, -1]), gl.LINE_STRIP(线条)也需要写入四个顶点([-1, -1, 0, 1, 1, -1,-1, -1]), 而gl.LINE_LOOP(回路)，只需要是三个顶点([-1, -1, 0, 1, 1, -1])； 2.2.2.3 顶点着色器和片元着色器顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息（如顶点的坐标、法线方向、材质等等，从而改变我们绘制出来的图形的形状或者大小等等； 顶点处理完成之后，webgl就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单讲，就是对指定图元中的像素点着色； webgl从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是生成光栅信息的过程，也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化后的像素信息； 举例 将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。 将图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的； 因为图元是webGL可以直接处理的图形单元，所以其他非图元的圆形最终必须要转换为图元才可以被webGL处理。比如绘制实心四边形，就需要将四边形拆分成两个三角形，再交给webGL分别绘制出来； 1234567891011121314151617181920212223// 顶点着色器// attribute 相当于var const，声明变量的关键字// vec2 变量类型，vec2表示二维向量// position 变量名const vertex = `attribute vec2 position;void main()&#123; gl_PointSize = 1.0; gl_Position = vec4(position, 1.0, 1.0);&#125;`;// 通过gl_Position 设置顶点；// 片元着色器const fragment = `precision mediump float;void main()&#123; gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);&#125;`;// gl_FragColor 是webGL片元着色器内置变量，表示当前像素点颜色。 它是一个用RGBA色值表示的四维向量数据；// 变量类型 vec4 表示四维向量// webGL可以并行地对整个三角形的所有像素点同时运行片元着色器，并行处理是WebGL程序非常重要的概念；不论这个三角形是大是小，有几十个像素点还是上百万个像素点，GPU都是同时处理每个像素点的；也就是说，图形中有多少个像素点，着色器程序在GPU中就会被同时执行多少次； 123456789101112131415161718// 创建顶点着色器对象const vertexShader = gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vertexShader, vertex);gl.compileShader(vertexShader);// 创建片元着色器对象const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fragmentShader, fragment);gl.compileShader(fragmentShader);// 创建webGLProgram 对象const program = gl.createProgram();gl.attachShader(program, vertexShader);gl.attachShader(program, fragmentShader);gl.linkProgram(program);// 启用webGLProgram对象gl.useProgram(program); 2.2.2.4 向片元着色器传递数据（与绘图步骤无关）1234567891011121314151617181920// 顶点着色器attribute vec2 postion;varying vec3 color; // 顶点着色器可通过 varying变量传给片元着色器；void main()&#123; gl_PointSize = 1.0; color = vec3(0.5 + position * 0.5, 0.0); // 将顶点值映射为一个RGB颜色值； gl_Position = vec4(position*0.5, 1.0, 1.0);&#125;// 片元着色器precision mediump float;varying vec3 color;void main()&#123; gl_FragColor = vec4(color, 1.0);&#125;// 将gl_FragColor 的rgb值设为变量color的值；// 这个三角形是一个颜色均匀渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。webgl// 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值// 利用线性插值可以让像素点的颜色均匀渐变这一特点，可以绘制更多颜色丰富的图形； 2.2.3 将数据存入缓冲区123456789101112// 定义三角形的顶点const points = new Float32Array([ -1, -1, 0, 1, 1, -1,]);// 将points写入webGL缓冲区const bufferId = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW); 2.2.4 将缓冲区数据读取到GPU123456// 获取顶点着色器中的position变量的地址const vPosition = gl.getAttribLocation(program, 'position');// 给变量设置长度和类型gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);// 激活这个变量gl.enableVertexAttribArray(vPosition); 经过这样处理，在顶点着色器中，定义的points类型数组中对应的值，就能通过变量position读取到了； 2.2.5 GPU执行webgl程序，输出结果12gl.clear(gl.COLOR_BUFFER_BIT);gl.drawArrays(gl.TRIANGLES,0, points.length/2); 3. Math我们要建立一套与各个图形系统无关联的，简单基于向量和矩阵运算的数学体系，用它来描述所有的几何图形信息。 如何建立一套描述几何图形信息的数学体系，以及如何用这个体系来解决可视化图形呈现的问题； 3.1 坐标系坐标系与向量来描述基本图形的方法，从如何定义和变换图形的直角坐标系，以及如何运用向量表示点和线段； 3.1.1 HTML窗口坐标体系，以参考对象的元素盒子左上角为坐标原点，x轴向右，y轴向下，坐标值对应像素值； 3.1.2 SVG视区盒子（viewBox）坐标系，默认情况下，是以svg根元素左上角为坐标原点，x轴向右，y轴向下，svg根元素右下角坐标为它的像素宽高值。 如果设置了viewBox属性，那么svg根元素左上角为viewBox的前两个值，右下角为viewBox的后两个值； 3.1.3 Canvas画布左上角为坐标原点，右下角坐标值为canvas画布宽高值； 3.1.4 webGL三维坐标系，它默认以画布正中间为坐标原点，x轴朝右，y轴朝上，z轴朝外，x轴，y轴在画布中范围是 -1 到1； 3.1.5 坐标系转换(以canvas为例)因为html svg canvas webgl都是直角坐标系，所以它们可以方便地相互转化。html，svg，canvas提供了transform的api很方便进行坐标系转换； webgl本身不提供tranform的api，可以在shader里做矩阵运算来实现坐标转换。 在很多可视化场景下，要处理成千上万的图形，如果这个时候，在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。采用坐标变换的方式就是一个很好的优化思路，它能够简化计算量，这不仅让代码更容易理解，也可以节省CPU运算时间； 1234567891011121314151617181920const rc2 = rough.canvas(canvas2);const ctx = rc2.ctx;// 通过translate变换 ，将canvas坐标画布原点从左上角（0，0）移动至（256， 256）的位置，即画布的底边上的中心位置；ctx.translate(256, 256); // 以移动了原点后的新的坐标为参照，通过scale(1,-1) 将Y轴向下的部分，即y&gt;0的部分沿x轴翻转180度；这样就变成画布底边中点为原点，x轴向右，y轴向上的坐标系了；ctx.scale(1, -1); const hillOpts2 = &#123; roughness: 2.8, strokeWidth: 2, fill: \"blue\" &#125;;rc2.path(\"M-180 0L-80 100L20 0\", hillOpts2);rc2.path(\"M-20 0L80 100L180 0\", hillOpts2);rc2.circle(0, 150, 105, &#123; stroke: \"red\", strokeWidth: 4, fill: \"rgba(255,255, 0, 0.4)\", fillStyle: \"solid\",&#125;); 3.2 向量在直角坐标系里绘制图形，一般的几何图形都是由点，线段喝面构成，其中，点和线段是基础的图元信息，因此，如何描述它们是绘图的关键； 如何用向量来描述点和线段？一般用向量来表示一个点或者一个线段； 用二维向量来表示这个平面上的点和线段，二维向量其实就是一个包含了两个数值的数组，一个是x坐标值，一个是y坐标值； 向量V(x,y)有两个含义，一是表示该坐标系下位于（x，y）处的一个点，二是可以表示从原点（0，0）到坐标（x，y）的一根线段。 3.2.1 向量基本运算 现在有两个向量，v1和v2； v1+v2 相当于将V1的终点沿着v2向量的方向移动一段距离。这段距离等于v2向量的长度。 这样在平面上得到三个元素 一个新的点 (x1+x2, y1+y2)； 一条新的线段 [(0, 0), (x1+x2, y1+y2)]; 一段折线 [(0,0),(x1,y1),(x1+x2, y1+y2)]; 3.2.2 向量长度和方向一个向量包含长度和方向信息 它的长度可以用向量的 x、y 的平方和的平方根 （勾三股四弦五）来表示 1v.length = function()&#123;return Math.hypot(this.x, this.y)&#125;; 它的方向可以用与 x 轴的夹角来表示 12v.dir = function() &#123; return Math.atan2(this.y, this.x);&#125;// Math.atan2 的取值范围是 -π到π，负数表示在 x 轴下方，正数表示在 x 轴上方。 根据长度和方向的定义，还能推导出一组关系方式： 12v.x = v.length * Math.cos(v.dir);v.y = v.length * Math.sin(v.dir); 推导过程 12345678#角A 对边=y 邻边 = x, 斜边 = zx*x + y*y = z*zsinA = 对边/斜边 = y/zcosA = 邻边/斜边 = x/ztanA = 对边/邻边 = sinA/cosA = (y/z) / (x/z) = y/x;v.length * cosA = z * (x/z) = xv.length * sinA = z * (y/z) = y 结论： 可以很简单构造出一个绘图向量。如果以点 V（x0, y0）为起点，沿着某个方向画一段长度为length的线段，只需构造如下一个向量即可； 1v1 = length * v(cos(A), sin(A)) 推导过程 12345v1 = length * v(cos(A), sin(A))# 这里写成 v1 = length (cosA, sinA) 更容易理解一些cosA = x/z;sinA = y/z;length = z; 可视化呈现依赖于计算机图形学，而向量运算是整个计算机图形学的数学基础； 3.3 向量乘法向量的点乘Dot.product, 向量的点乘也叫向量的内积、数量积； 向量的叉乘Corss.product，也叫向量积，外积、叉积； 3.3.1 一个例子引出向量乘法的*判断：一个点是否在扫描器内 * 解答 如图所示，扫描器是60度，垂直向上，所以它的范围应该是60度到120度； 也就是 Math.PI/3 到 2*Math.PI/3 1234// 先求出目标向量与X轴的夹脚v.dir = Math.atan2(v.y, v.x); // 此方法是求解夹角的，比如 Math.atan2(1,1) === Math.PI/4 // true// 求解该 dir是否在扫描器之内isIn = v.dir &gt; Math.PI/3 &amp;&amp; v.dir &lt; 2*Math.PI/ 3 3.3.2 向量点乘两个N维向量，a和b， a = [a1,a2,a3,…an], b = [b1b2b3….bn]; 那向量的点积代码： 1a*b = a1*b1 + a2*b2 + .... an*bn a, b 向量点积的几何意义，是a向量乘以b向量在a向量上的投影分量。 它的物理含义相当于a力作用于物体，产生b位移所做的功。 1234// 当a、b向量平行时，那么它们的夹角为0a.x * b.x + a.y * b.y = a.length * b.length;// 当a、b两个向量垂直时，它们的夹角就是90度，那么a.b = 0；a.x * b.x + a.y * b.y === a*b*cos(90度) = a*b*0 = 0; 总结 向量的点乘， 对两个向量执行点乘运算，结果是一个【Scaler标量】（一个数字） （标量： scalar， 只有大小没有方向的量，例如物体移动中的平均速率·路程） 3.3.3 向量的叉乘向量的叉乘，则是针对两条向量的另一种运算方式。 向量叉乘运算的结果不是标量，而是一个新的向量；新的向量会 垂直于 原来的这两条向量； 向量A和向量B的叉积是向量C， 【向量C】同时垂直于【向量A和向量B】 【向量的叉乘】一个用途就是找到我们应该在哪一轴上施加【扭力Torque】（还有，跟踪导弹，比如合金弹头的C弹，也是可以通过叉乘的方法去实现的）； 如下示例： 【向量A】表示的是炮口【当前朝向】 【向量B】表示的是炮口将要【调整后的朝向】 【向量C】将两个向量进行叉乘后，找到炮口需要在哪一轴上进行旋转并且施加相应的扭力； 叉积几何意义 向量a和b的叉积，就相当于向量a（蓝色带箭头线段）与向量b沿垂直方向的投影（红色带箭头线段）的乘积。（如上图所示），二维向量叉积的几何意义就是向量a、b组成的平行四边形的面积； 1|a| 表示向量a的length； 思考题：求点到线段的距离 在了解向量叉积的几何意义之后， 我们通过向量叉积得到平行四边形的面积，再除以底边长；就能得到点到向量所在直线的距离 叉乘在数学上的计算方法 12// 其中，i，j，k 分别是 x，y，z 轴的单位向量，我们把行列式展开，就能得到如下公式：a X b = [y1 * z2 - y2 * z1, - (x1 * z2 - x2 * z1), x1 * y2 - x2 * y1] 更多点积差积相关知识参考https://geek-docs.com/linear-algebra/vector/vector-chaji.html 回到思考题3: 给任意一个点，判断这个点在不在扫描器内 归一化 归一化，用 v0的 x、y 分别除以它的绝对值。归一化后的向量方向不变，长度为 1。 在向量乘法里，如果 a、b 都是长度为 1 的归一化向量，那么|a X b| 的结果就是 a、b 夹角的正弦值，而|a • b|的结果就是 a、b 夹角的余弦值。 好了，再说回来，我们把归一化的向量 a 叉乘扫描器中线上的 v(0,1)，由于扫描器关于 y 轴对称，所以扫描器边缘与 y 轴的夹角是正负 30 度。那么在与单位向量求叉积的时候，就会出现 2 种情况： 点在扫描范围内，如向量 a，就一定满足： |a X v| &lt;= ||a||v|sin(30°)| = |sin(30°)| = 0.5； 点不在扫描范围内，如向量 b，就一定满足：|b X v| &gt; ||b||v|sin(30°)| = |sin(30°)| = 0.5。 因此，只要任意一点所在的向量与单位向量的叉积结果的绝对值不大于0.5（即sin30度），就说明这个点在扫描范围内，所以如下判断方法 123const isInRange = Math.abs(new Vec2(0, 1).cross(v0.normalize())) &lt;= 0.5; // v0.normalize()即将v0归一化 3.3.4 点乘与叉乘加述 Dot product 12345a向量 * b向量 = a长度 * b长度 * cos@ // @ 为a向量和b向量的夹角 // 点乘使用场景1， 快速得到两个向量的夹角 cos@ = （a向量 * b向量） / （a长度 * b长度） 点乘能快速得到两个向量的夹角， 特别是在两个向量都是单位向量的时候。它们的长度自然都是1；所以它们的点乘自然就是夹角的cos值； 点乘满足的计算规律 交换律，分配律，结合率； Cross product 3.4 向量和参数方程描述曲线用参数方程描述曲线的方法，通过此方法可以描述常见的圆，椭圆，抛物线，正余弦等曲线，还能描述更具一般性的曲线；比如贝塞尔曲线，或者Catmull-Rom曲线等等； 3.4.1 画圆 如下图所示的参数方程，圆心为（x0, y0），半径为r； 3.4.2 画圆椎曲线除了画圆，参数方程还可以描述很多其他圆椎曲线，比如椭圆的参数方程。它其实和圆的参数方程很接近。其中，a，b 分别是椭圆的长轴和短轴，当a=b=r时，这个方程就是椭圆的方程式。圆是椭圆的特例； 3.4.3 抛物线的参数方程，其中p是常数，为焦点到准线的距离 3.4.4 贝塞尔曲线3.5 三角剖分和向量操作描述并处理多边形3.6 仿射变换对几何图形进行坐标变换","categories":[{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/categories/webgl/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"canvas","slug":"canvas","date":"2021-01-26T10:08:55.000Z","updated":"2021-02-09T10:26:35.151Z","comments":true,"path":"2021/01/26/canvas/","link":"","permalink":"http://yoursite.com/2021/01/26/canvas/","excerpt":"","text":"1. canvas 基础API1.1 contextcontext对象 proto 指向CanvasRenderingContext2D，一些绘图API集中在这些地方 12const canvas = document.querySelector('canvas')const context = canvas.getContext('2d'); context对象API大体分两类 设置状态的 （颜色，线宽， 坐标变换） 绘制指令API，绘制不同形状的几何图形 1.2 绘图API1.2.1 rect绘制矩形指令 参数 四个参数，分别为要绘制矩形的x坐标，要绘制矩形y坐标, 矩形宽和矩形高； 1.2.2 缓存当前状态和恢复类似一个压栈和弹栈功能； save 保留当前的路径和颜色等状态 restore 123456789ctx.fillStyle = \"green\";ctx.save(); // 保存画笔初始坐标(0,0), 填充色为绿色ctx.fillRect(10, 10, 100, 100);// Restore the default statectx.restore();ctx.fillRect(150, 40, 100, 100); // 该图形的画笔坐标回到 初始状态，即 (0,0) ,填充色为绿色，而不是默认色； 1.3 绘制状态APIfillStyle 1context.fillStyle = color; 1.4 坐标系统 左上角为 (0, 0) 右下角为 (canvas.width, canvas.height) 1.5 绘图过程 获取canvas对象，getContext(‘2d’) 绘制状态， fillStyle， translate等； beginPath开始绘制 调绘图指令，rect等 调fill指令，将绘制内容输出到画布中； 1.6 图形信息有的时候，类似一份层级数据（城市 &gt; 省份 &gt; 中国）这样层级数据，要将它与绘图指令建立联系，建立联系指的是 要把数据的层级、位置、和要绘制的圆的半径、位置一一对应起来； 换句话说就是要把数据转换成图形信息，这个步骤需要数学计算； 假设，我们要将数据展现在一个画布宽高为 1600 * 1600 的 Canvas 中，那我们可以通过 d3.pack() 将数据映射为一组 1600 宽高范围内的圆形。 具体绘制的过程比较简单，只需要遍历数据并且根据数据内容绘制圆弧","categories":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/categories/canvas/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"C","slug":"C","date":"2021-01-25T02:12:49.000Z","updated":"2021-02-09T10:26:22.189Z","comments":true,"path":"2021/01/25/C/","link":"","permalink":"http://yoursite.com/2021/01/25/C/","excerpt":"","text":"前置1.程序 写程序前，先构想好程序的结构，而不是先从定义变量开始。 没有想好解决方案，不要急于动手写程序？ 有了解决方案以后，可以按照“先粗后细，先抽象后具体”的办法，先有程序的轮廓，如有必要可以解决“建模工具”画一些图，而后再动手写程序； 写程序时，可以先写出程序轮廓，而后再补充变量定义等细节； 程序并不纠结于是否更优。而在于程序结构是不是清楚，是不是容易被人看懂 1.1 写程序的过程 按照由大到小，由粗到细，由抽象到具体的方法分析、编写程序 程序的结构 （基本思想） 程序由若干个“模块”组成 模块之内“高内聚”（高内聚， 就是这个模块只做这个事情，不干别的。功能单一） 模块之间“低耦合” （当一个模块被改动的时候，只会印象它自己，而不会影响别的） 1.2 编程语言共性 （语法）程序设计语言的构成,语言种类千差万别，但是，一般来说，基本成分不外四种： 数据， 用以描述程序中所涉及的数据 （数据类型） 运算，用以描述程序中所包含的运算；（运算符） 控制，用以表达程序中的控制构造；（三种类型的控制语句是如何写的，顺序，分支，循环） IO，用以表达程序中数据的传输； （如何输入和输出数据） 1.3 大纲 基本概念 数据类型，运算符，表达式 IO 流程控制（顺序，分支，循转） 数组 指针 函数 构造类型 动态内存管理 调试工具，（gdb，make） 常用库函数 2. 基本概念 把内存想象成一个长长的带子,带子上面有很多小方格，每个格子都是一个字节（存储单元）。每个小方格都有它对应的地址，每个字节（单元）有八位，1B（byte） = 8b（bit）每一个位存储一个二进制的数。 2.1 变量与常量2.1.1 常量 在程序执行过程中值不会发生变化的量，数组名是一个典型的常量，一旦数组定义了，gcc为当前的数组分配了一段空间了。然后数组的位置就定死了。数组名就是一个数组的起始位置。是一个常量，如果你在=左边写上一个常量，就表示企图更改一个常量的值；比如1=f ，显然不成立； 常量的分类 整型常量 实型常量 3.14, 5.26; 字符常量 由单引号印起来的单个字符或者转义字符，如’a’ 转义字符： ‘\\n’, ‘\\r’, ‘\\t’ ，’\\015’(八进制数)， ‘\\x7f’(十六进制数) 字符串常量 由双引号印起来的一个或多个字符组成的序列，如: “”(空串) 一个字符串在存储的时候，最末尾会有一个结束标记，通常称作尾0\\0.所以&quot;&quot;是占空间的，空字符占一个字节的空间； 合法的字符串 （””, “a”, “abXYZ”） 暂时不确定是否合法的字符 （”abc\\n\\021\\018”) 因为\\018不是八进制，因为出现了8，而我们知道\\0是字符串数组的末尾。所以\\0到底能否插入进字符串中间，这个需要后续字符数组专题揭秘； 字符串常量需要借助构造类型——数组来保存 &#39;a&#39;和&quot;a&quot;的区别：前者是字符常量，后者是字符串常量。 标识常量 #define， 程序中一改全改 #define PI 3.14，在程序预处理之后，宏名被宏体完整的替换；define ADD 2+3 ADD*ADD = 2+3*2+3而不是(2+3)*(2+3)。 #define，处理在程序的预处理阶段，占编译时间。不占运行时间。一改全改；缺点： 不检查语法，只是单纯的宏体与宏名之间的替换； 带参数的#define 1234567891011121314151617#define MAX(a, b) a&gt;b?a:bint main() &#123; int i, j; i = 5; j=3; printf(\"/d\\n\", MAX(i, j)); exit(0);&#125;// gcc -E define.c int main() &#123; int i, j; i = 5; j=3; printf(\"/d\\n\", (i&gt;j?i:j)); exit(0);&#125; 一个特殊问题的解决方式 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))int max(int a, int b)&#123;return a&gt;b?a:b;&#125;int main()&#123; int i = 5; int j = 3; printf(\"max = %d\\n\", MAX(i++, j++)); printf(\"i=%d\\tj=%d\\n\", i, j); exit(0);&#125;((i++) &gt; (j++) ? (i++) : (j++))// max = 6// i=7 j=4 首先，max和MAX的区别，MAX只占用预编译时间，等运行的时候，实际上已经将所有宏体替换到程序中去了。不会再需要额外的时间了。而max则不同，在函数的调用位置，对当前的一个执行现场做一个压栈保存。然后去到指定的函数去执行。（跳往另外一个入口地址）然后再回来，弹栈恢复当前现场的过程。这个过程 占用了运行的时间； 什么时候用宏，什么时候用函数？在需要极致性能的场景用宏，前提是宏能满足；比如内核。在应用层面，系统层面，多用函数。因为应用层要求更高的是稳定性，而非实时性。 解决方案，需要找一个变量来接受；而不是让其继续做加运算； 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) (&#123;typeof(a) A = a, B = b;((A) &gt; (B) ? (A) : (B)); &#125;)// typeof(a) 用a的类型定义A，就很灵性了。有点泛型的意思了；int main()&#123; int i = 5; int j = 3; printf(\"max = %d\\n\", MAX(i++, j++)); printf(\"i=%d\\tj=%d\\n\", i, j); exit(0);&#125;// max = 5// i=6 j=4 2.1.2 变量 用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量； 当计算机执行到 int max=0 这句程序时，计算机会在内存里面找到一片存储空间（几个连续的存储单元），然后给该片存储空间取个名字叫 Max， 再把 0 这个初始值放在这个存储空间中来。并记下这个名字（Max）和这片连续的存储空间的起始的地址之间的对应关系 定义： [存储类型] 数据类型 标识符 = 值 TYPE NAME = VALUE; 存储类型 可选 2.1.2.1 标识符当定义一个某种类型的标识符的时候，编译器会为当前的值分配一块内存空间；如何称呼这块空间，就是房间号。房间号就是标识符。编译器会给标识符（房间号）和内存地址标识做关联。当搜索变量名的时候，编译器知道要去到哪块内存地址去搜索；简单说，标识符就是这块空间的临时别名； 2.1.3 存储类型 auto, static register extern(说明型) 2.1.3.1 auto 默认，自动分配空间，自动回收空间 auto类型分配在栈上，堆主要是来进行动态内存分配的空间；堆栈不挨着 12345678910int main ()&#123; auto int i; // 原则上不会 对 i所在这块空间进行初始化 int j; printf(\"i = %d\\n\", i); // 随机的结果，当然有的编译器会置为0 printf(\"j= %d\\n\", j); // 0 编译器会初始化为0 exit(0);&#125; 123456789101112131415161718192021void func(void)&#123; int x =0; x = x+1; printf(\"%p-&gt;%d\\n\", &amp;x, x);&#125;int main()&#123; func(); func(); func();&#125;// 0x7ffee6b3c928-&gt;1// 0x7ffee6b3c928-&gt;1// 0x7ffee6b3c928-&gt;1/**说明： 这三个地址未必一致，但一致的原因是 auto类型的变量都存放在栈上，栈上的空间按正常理论来讲，它实际上是连续分配的。而当前x在 func函数被调用的时候，它才会被产生。然后在当前函数执行结束的时候，这块空间被释放掉了。*/ 2.1.3.2 register 建议型关键字； 寄存器类型，资源少，速度快，寄存器存放在CPU当中，寄存器的数据比较吃紧， 1register int i =1; // 除非i在程序中，超高频率被使用，才建议编译器将i分配到寄存器中；至于有没有被放到寄存器中，由gcc来决定； register的苛刻条件； 只能定义局部变量，不能定义全局变量； 大小有限制，只能定义 32 位大小的数据类型，如double 就不可以 寄存器中没有地址，所以一个寄存器类型变量无法打印出地址查看或者使用； 2.1.3.3 static 静态型，自动初始化为0值或空值，并值其变量的值有继承性（继承性指的的static在内存中只此一份，所以下次使用的时候还是基于上一次的值，而不会被初始化）。另外，常用于修饰变量或函数 1234567891011121314151617181920void func(void)&#123; static int x =0; x = x+1; printf(\"%p-&gt;%d\\n\", &amp;x, x);&#125;int main()&#123; func(); func(); func();&#125;// 0x10c4b1018-&gt;1// 0x10c4b1018-&gt;2// 0x10c4b1018-&gt;3/**说明： static类型的变量，只用一块空间。*/ static 修饰函数： 防止该函数对外扩展，（简单说就是该函数只能在当前文件下使用，在别的文件下没法使用；） 123456789static void func(void)&#123; printf(\"hello func\");&#125;void call_func() // 外界可以通过 call_func 这个桥梁函数来引用 func&#123; func()&#125; 一般来说全局变量都要修饰成static，防止跟别的.c文件中同名变量冲突。然后用static来修饰函数，为的是强调当前函数不可外扩，（该函数只能在当前文件使用，别的文件下没法使用） 2.1.3.4 extern 说明型， 意味着不能改变被说明的变量的值或类型； 12345678910111213141516171819202122// proj.hvoid func(void);// main.cint i =10;int main()&#123; printf(\"%d\\n\", i); func(); exit(0);&#125;// proj.c#include \"proj.h\"extern int i; // 我的i不是自己定义的，是引用其他文件里面的i，编译器自己去找，extern不能改变声明的类型和值；void func(void)&#123; printf(\"%d\\n\", i); exit(0);&#125; 2.1.4 变量的生命周期和作用范围（即作用域） 全局变量和局部变量 局部变量和局部变量 参考图片 3. C程序3.1 程序规范 以helleworld为例对写程序的思路提出如下要求: 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//void main(void);//void main(int argc, char **argv); // char * argv[]//int main(int argc, char **argv);//int main(void);void main()&#123; printf(\"hello c!\\n\"); exit(0);&#125; 头文件正确包含的重要性； 知道程序中的所有警告gcc file.c -Wall 如何调试段错误，先把程序中的所有警告调好； 以函数为单位来进行程序编写； 声明部分 和 实现部分（变量先定义，后使用） return 0 （exit(0) 在单进程单线程的程序中 和 return 0意义一样的，exit(0)是给它父进程看的，当前main函数的父进程是shell） 多用空格空行 添加注释 1echo $? # 上一条语句执行的状态 3.2 注释 #if #endif 注释 12345#if(0)int main()&#123; return 0;&#125;#endif 3.3 编译12#gcc hello.c.c -&gt; .out gcc过程(c源文件到可执行文件需要经过的顺序) c源文件 - 预处理 - 编译 - 汇编 - 链接 - 可执行文件 预处理 gcc -E hello.c &gt; hello.i (预处理hello.c，保存至 hello.i 文件)以#开头的语句部分都是在预处理阶段解决掉的；`include`或者 `if define` 编译阶段gcc -S hello.i (编译hello.i)默认会生成一个 .s文件，编译成汇编文件； 汇编阶段gcc -c hello.s生成一个 .o文件； 链接阶段gcc hello.o -o hello (链接.o文件 生成可执行文件 hello)生成可执行文件hello; 3.3.1 C编译123gcc -o test test.c # 把test.c 编译成一个可执行文件 testgcc hello.c -Wall # 显示编译警告，原则上编码过程当中把程序调到没有警告为止；./test # 执行 test 3.3.2 多个.c文件 main() 里的代码太长了 适合分成几个函数 一个源文件太长适合分成几个文件 两个独立的源文件不能编译形成可执行的程序 3.3.3 头文件 把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件(.c文件)中 #include 这个头文件，就能让编译器在编译的时候知道函数的原型 12# main.c max.c max.hgcc main.c max.c 4. 数据类型 不同数据类型所占字节数 存储区别 不同类型的数据间转换 特殊性： 4.1 基本类型 数值类型 整型 短整型 short （2个字节，16位） 整型 int （4个字节，32位） 长整型 long （4个字节，32位） 浮点型 单精度型 float （4个字节，32位） 双精度型 double （8个字节，64位） 字符类型 char （1个字节，8位） 4.1.1 整形存储整型的存储都是以补码的形势来存储的 补码：正数的补码是它二进制本身，负数的补码是它绝对值的那个数的二进制形式取反再加1的结果； 254 -&gt; unsigned int(无符号 int) -&gt; 32位 -254 -&gt; 254-&gt; 1111 1110 取反 +1 有无符号的区别，最高位到底代表是符号还是正常有效值；有符号的话，为0表示正数，为1表示负数； (254)10 =&gt; (11111110)2 方法： 除2取余倒序排列；（转2进制）11111110 除8取余倒序排列；（转8进制）376 除16取余倒序排列；（转16进制） FE进制表示 254 十进制 B11111110 二进制 0376 八进制 0xFE 十六进制 4.1.2 浮点型存储12343.14 * 10^00.314 * 10^10.0314 * 10^2314 * 10^-2 浮点数是以0.314 * 10^1的方式来存储3.14的 整数部分为0，只是在意精度部分是多少。然后在意指数部分是多少。 浮点数在32 个bit上是如何存放的0～22位（共23个bit）用来记录精度部分。 22位～30位（共8个bit） 用来存储的是指数部分。最高位（第31位） 表示的是符号位置，表示是正数还是负数； 举例 0.000789 -&gt; 0.789 -&gt; 10^3 精度部分存储 789的二进制形式，8个位存储3 float 32位 double 64位 ，比float多出来的32位完全放在精度的控制上 4.1.3 char存储 char 8位。 -128～127 unsigned char 8位。 0～255 4.1.4 不同类型的数据间转换4.1.4.1 精度丢失12float f = 3.9;int i = f; // 4 4.1.4.2 隐式转换编译器默认做的 12345678int i;char ch;float f;double d;ch + i --&gt; i // 默认往精度高，或者所占字节长比较高的那一种数据类型去靠拢的f -d --&gt; d // 精度高的 double(ch + i) - (float - double) --&gt; double 4.1.4.3 显式转换强制类型转换 4.1.4.4 特殊性： 布尔型bool float类型； 1.0/3*3 ！= 1 char型是否有符号，不知道，一个未定义的行为 不同形式的0值； 12340;'0';\"0\";'\\0'; 数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾） 4.2 构造类型 数组 结构体 struct 共用体 union 枚举类型 enum 4.2.1 enum*语法: * 1234enum 标识符&#123; 成员1,&#125; 123456789101112131415enum day&#123; MON, //默认从0 开始往下排 TUS, THR, WES, FRI = 1, // 如果给FRI赋值为1的话，那么接下来会从1继续排 SAT, SUN&#125;int main () &#123; enum day a = FRI; printf(\"%d\\n\", a); // 5&#125; *把enum当宏使用: * 12345678910111213141516171819202122232425262728293031323334enum &#123; STATE_RUNNING = 1, STATE_CANCELED, STATE_OVER&#125;;struct time_t &#123;&#125;;struct job_st&#123; int id; int state; char start; char end;&#125;;int main() &#123; struct job_st job1; // job1.state = STATE_CANCELED; switch (job1.state) &#123; case STATE_CANCELED: break; case STATE_OVER: break; case STATE_RUNNING: break; default: abort(); // 信号，操作系统后续会讲 &#125; return 0;&#125; *这种场景可以用 enum代替宏的使用: * 因为宏经过预编译之后被替换掉了，宏的部分会被替换。影响调试。当然enum不是万能，并不能替代宏；宏还可以传递参数 4.2.2 结构体类型 类型描述 1234struct 结构体名 &#123; 数据类型 成员1; 数据类型 成员2;&#125; 类型嵌套 1234567891011121314151617181920212223242526272829struct birthdata_st &#123; int year; int month; int day;&#125;struct student_st&#123; int id; char name[NAMESIZE]; struct birthday_st birth; // 嵌套定义 int math; int chinese;&#125;// 或者struct student_st&#123; int id; char name[NAMESIZE]; struct birthdata_st // 嵌套定义 &#123; int year; int month; int day; &#125;birth; int math; int chinese;&#125; 定义变量（变量，数组，指针），初始化及成员引用； 12345struct student &#123; // student 不是变量名而是类型 int id; char name[20] .....&#125;; 成员引用： 变量名.成员名 指针名-&gt;成员名 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct simp_st&#123; /* data */ int bigint; float mfloat; char name;&#125;;int main()&#123; struct simp_st a = &#123; 123, 456.789, 'a'&#125;; a.bigint = 333; printf(\"%d, %f, %c\\n\", a.bigint, a.mfloat, a.name); exit(0);&#125; *定义结构体变量的方式: * student tudent1,student2;(结构体类型名) (结构体变量名) 12345struct student &#123; int id; char name[20] .....&#125; lige_1, lige_2; *结构体赋值: * 123456789101112int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; struct student mike2 = mike; // 结构体赋值相当于copy一份给对方 mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike2.name[i]!='\\0'; i++) &#123; mike2.name[i] = toupper(mike2.name[i]); printf(\"%d\\n\", mike2.id_num); printf(\"%s\\n\", mike2.name); &#125; return 0;&#125; *结构体内存 * 12345678struct simp_st &#123; int i; char ch; float f; char ch1;&#125;// 看上去是10个字节，结果打印出来的是16个字节；// 地址对齐， 结构体对齐的概念； 一个公式 address（当前准备存储的变量的地址）%（你当前要存放变量的sizeOf）如果能整除的话，那么这个变量就存放在这里，如果这个表达式不成立，那么address就得 + 1； 举例子说明,首先下面是一段内存 123456789101112131415161718192021222324252627----------0----------1----------2----------3----------4----------5----------6----------7----------8----------9----------10----------11----------12---------- 1234567// 目标结构体struct simp_st &#123; int i; char ch; float f; char ch1;&#125; *解释 * 首先内存第一个地址的值是0，结构体的第一个属性是int，我们知道int占4个字节。0/4 能整除，因此第一个int占据从0-3 这个几个内存中，然后 char占1个字节，4/1能整除，因此第二个char占据了4这个内存中。接着结构体第三个属性为float，占据4个字节。内存地址5/4没法整除，当前内存++，分别到6，7，都无法整除4.到了8，8/4能整除，所以，从8打11这一段内存就存放着float这个属性，接下来又是char12/1能整除，所以char属性占据了char12这个内存地址； 值得注意的是，不同的操作系统内存对齐的方式是不同的；因此在socket编程中，我们传过去的结构体数据在末端一定不能做对齐；因为不知道不同平台到底是什么字节对齐的 *结构体对齐 * 1234struct point &#123; int x; int y;&#125;__attribute__((packed)); 这个操作在网络编程当中很常用； 总结 如果没有内存对齐，就是指定attribute((packed))的话，那么结构体内存的大小就是各个属性的sizeof累加的结果。如果没加就需要考虑内存对齐的问题，不同的机器内存对齐的方式是不同的。因为在跨机器编程比如socket编程当中，是需要指定attribute((packed))来确保数据的完整性和 安全性； 4.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）123456789101112131415161718192021void renew (struct student mike) &#123; mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike.name[i]!='\\0'; i++) &#123; mike.name[i] = toupper(mike.name[i]); &#125; printf(\"%d\\n\", mike.id_num); printf(\"%s\\n\", mike.name);&#125;int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; renew(mike); printf(\"%d\\n\", mike.id_num); printf(\"%s\\n\", mike.name); return 0;&#125;#20130123#MIKE#123#mike 结论 结构体的传入是 值拷贝，函数内部执行的是副本 4.2.2.2 当把结构体当成形参传递的时候，意味着什么1234567891011void func (struct simp_st b)&#123; // 内存总是要分配一个完整的 结构体 体积所占的空间用来接受这个形参 printf(\"%d\\n\", sizeof(b)); // 12&#125;int main() &#123; struct simp_st a; struct simp_st *p = &amp;a; func(a); // func(a.i, a.ch, a.f)&#125; 小结： 所以我们一般不会这么去用。会有非常严重的性能浪费；一般我们会传递结构体指针； 4.2.2.3 结构体作为函数返回值时 总结： 结构体作为函数返回值时，相当于copy一份给调用者 4.2.2.4 指向结构体变量的指针12345678910int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; struct student *p = &amp;mike; printf(\"%d\\n\", (*p).id_num); // 123 printf(\"%d\\n\", p-&gt;id_num); // 123 另外一种写法 -&gt; 指向运算符 printf(\"%s\\n\", p-&gt;name); // mike 另外一种写法 printf(\"%s\\n\", (*p).name); // mike return 0;&#125; 4.2.2.5 指向结构体变量的指针作为参数传入函数1234567891011121314void renew (struct student mike) &#123; mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike.name[i]!='\\0'; i++) &#123; mike.name[i] = toupper(mike.name[i]); &#125;&#125;int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; renew(&amp;mike); printf(\"%d\\n\", mike.id_num); // 20130123 值被篡改 printf(\"%s\\n\", mike.name); // MIKE 值被篡改 return 0;&#125; 4.2.2.6 结构体数组12345678910111213141516int main()&#123; struct student myclass[3] = &#123; 123, &#123;'m','k','k','e'&#125;, 133, &#123;'j','o','y'&#125;, 143, &#123;'t','o','m'&#125; &#125;; struct student * p = &amp;myclass; printf(\"%d\\n\", p-&gt;id_num); // 123 printf(\"%s\\n\", p-&gt;name); // mkke p++; // 跳一个结构体 体积的内存 printf(\"%d\\n\", p-&gt;id_num); // 133 printf(\"%s\\n\", p-&gt;name); // joy return 0;&#125; 4.2.2.7 链表 动态地 申请内存空间 123456int *pint = new int(1024); // 开辟一片内存存储空间并返回起始地址； delete pint; // 释放掉指针所指向的内存空间；int *pia = new int[4]; // 申请一个 4个整型小数组的空间；并返回起始地址；delete [] pia; // 开个方括号，指的是释放掉的是一个数组区域 动态地 建立链表节点 123456struct student &#123; int id; student *next;&#125;student *head;head = new student; 4.2.3 共用体 共用体和结构体语法很像，但截然不同的是，结构体各个成员会占用不同的内存，结构体整体内存 &gt;= sizeof（所有属性）， 因为有内存缝隙的 概念，所以有时候会大一些； 而公用体的内存体积取决于最大属性的体积；共用体所有成员占据同一段内存；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来的值覆盖掉。 共用体是硬件稀缺时代的产物；结合实际场景，比如 checkbox 男女只能同时存在一个； 语法 123union 共用体名 &#123; 成员列表&#125; 类型嵌套 硬件存储分大小端的； 大端格式： 数据的低位保存在高地址中； 小端格式： 数据的低位保存在低地址中； 定义变量（变量，数组，指针），初始化及成员引用 (变量名.成员 指针名-&gt;成员) 占用内存大小 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;union test_un&#123; /* data */ int i; float f; double d; char ch;&#125;;int main()&#123; union test_un a; a.f = 345.678; printf(\"%d\\n\", sizeof(a)); // 8 验证多个成员共用一块空间 printf(\"%f\\n\", a.f); exit(0);&#125; 123456789101112131415161718union unioz&#123; int a; double d; struct &#123; int arr[10]; float f; &#125; c;&#125;;int main()&#123; union unioz x; printf(\"%d\\n\", sizeof(double)); // 8 printf(\"%d\\n\", sizeof(x)); // 48 exit(0);&#125; 函数传参（值，地址） 位域 5. 类型转换存储涉及到2进制，8进制，10进制，16进制。这几种进制之间的转换首先要区别开，如何去获得一个二进制 5.1 十进制转二进制 除2取余，余数倒序排列 254 -&gt; unsigned int -&gt; 32位 （4个字节） 254（10进制）-&gt; 11111110 (2进制) -&gt; 376 (8进制) -&gt; FE(16进制) c语言程序当中是不识别二进制的 254 默认10进制B11111110 二进制0376 八进制0xFE 十六进制 5.2 补码 一个正数的补码形式就是 它二进制本身,负数的补码是它绝对值的二进制形式取反 + 1 254 -&gt; unsigned int -&gt; 32位-254 -&gt; 254 -&gt; 1111 1110 取反 + 1 6. 运算符和表达式表达式与语句的区别 运算符部分： 每个运算符所需要的参与运算的操作个数 结合性 优先级 运算符的特殊性 % 要求 除数，被除数都是整型 位运算的重要性 8.1 自增和自减 运算符在前，先进行计算，再取变量值使用变量在前， 先取变量值使用，再进行计算 7. 位运算3.1 &gt;&gt; &lt;&lt; 位运算（左移右移）基本等同于乘2除2运算,像汇编当中乘以多少，除以多少，几乎按这种方式来实现的 123456int i = B1100 = 12~i -&gt; B0011 // 取反// 把i往右移一位，1100 变成 110， 转化为10进制就是12i &gt;&gt; 1 --&gt; 110 = 6 // 把i往左移一位， 1100变成11000， 转化为10进制就是24i &lt;&lt; 1 --&gt; 11000 = 24 3.2 ~ （取反）12int i = B1100 = 12~i -&gt; B0011 // 取反 3.3 按位或 按位或的计算原则是，同一个位上，两者有一者为1就为真，两者都为假才为假 1234567891011int i = B1100;int j = B1001;i|j 1 1 0 0｜ 1 0 0 1---------- 1 1 0 11101 -&gt; 13 3.4 按位与 按位与的计算原则是，同一个位上，两者有都为1就为真，否则为假 1234567891011int i = B1100;int j = B1001;i&amp;j 1 1 0 0&amp; 1 0 0 1---------- 1 0 0 01000 -&gt; 8 3.5 ^ (相同为0， 不同为1) 亦或计算原则， 同一个位上，相同为0， 不同为1 1234567891011int i = B1100;int j = B1001;i^j 1 1 0 0^ 1 0 0 1---------- 0 1 0 11000 -&gt; 5 3.6 位运算的重要意义 将操作数中第N位 置1， 其他位不变； 1234567891011121314//num = num | 1 &lt;&lt; n // 把某一位 置1的话，把1左移 N个位// 比如将i 的第二位 置1int i = B1011;int j = B1001;i = i | i &lt;&lt; 2; 1 0 1 1| 0 1 0 0 // 注意是把 1 左移动 N个位。 1 -&gt; 0100 空位补0---------- 1 1 1 11000 -&gt; 5 将操作数中第N位 清0， 其他位不变； 1234567891011121314//num = num &amp; ~(1 &lt;&lt; n) // 把某一位 置1的话，把1左移 N个位// 比如将i 的第1位 置0int i = B1011;int j = B1001;i = i | i &lt;&lt; 2; 1 0 1 1| 1 1 0 1 // -&gt; 把1左移N位取反---------- 1 0 0 11000 -&gt; 5 测试第n位： if (num &amp; i 1 &lt;&lt; n) 从一个指定宽度的数中取出其中的某几位 （练习题） 8. 内核代码位置12cd /linux/include/linuxvim list.h 9. 宏 #开头的是编译预处理指令 它们不是C语言的成分，但是C语言程序离不开它们 #define 用来定义一个宏； define (定义一个宏) 12345678910#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(\"%d\\n\", 2*PI*3.0); return 0;&#125;// C语言程序在编译之前，会做一次编译预处理；// 会把程序中所有的PI都替换成 3.14159 4.1 save-temps对一个 .c 文件执行 1gcc 02.c --save-temps 生成 四个文件 02.i02.s02.oa.out 过程依次是 .c -&gt; .i -&gt; .s -&gt; .o -&gt; a.out .c是源代码，经过编译预处理之后变成 .i 这种中间结果文件，当中所有编译预处理指令都执行完，比如 define 宏需要替换掉;然后由于编译器对 .i文件进行编译 生成汇编代码 .s文件；然后汇编代码文件，进行汇编变成目标文件， 目标文件再经过链接之后形成一个可执行的东西； 查看 .i 文件 12tail 03.itail -n 50 03.i # 看03.i文件 最后 50行 123456789extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));# 943 \"/usr/include/stdio.h\" 3 4# 3 \"03.c\" 2int main()&#123; printf(\"%f\\n\", 2*3.1415927*3.0); // 这里明显把宏替换成了值； return 0;&#125; ** 同样的可以把 “%f\\n” 也替换成宏** 12345678#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(FORMATTER, 2*PI*3.0); return 0;&#125; 4.2 宏的缺点 不检查语法，在预处理或者编译阶段是不报错的； 4.3 define #define &lt;名字&gt; &lt;值&gt; 结尾没有 分号，因为不是C的语句 名字必须是一个单词，值可以是各种东西 在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值； 完全的文本替换 gcc –save-temps 如果一个宏的值中有其他的宏的名字，也是会被替换的 如果一个宏的值超过一行，最后一行之前的行末需要加\\ 宏的值后面出现的注释不会被当作宏的一部分 123456789#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏#define PI2 2*PI // PI * 2// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(FORMATTER, 2*PI*3.0); return 0;&#125; 1234567891011#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏#define PI2 2*PI // PI * 2#define PRT printf(\"%f\", PI)\\ printf(\"%f\\n\", PI2)// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; PRT; return 0;&#125; 4.4 没有值的宏 #define_DEBUG 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了； 4.5 预定义的宏 用来表示一些特殊的东西，可以让编译器替我们插入一些特殊的值。 12345_LINE_ //这个源代码所在当前的行号；_FILE_ // 源代码的文件名_DATE_ // 编译时候的日期_TIME_ // 编译时候的时间_STDC_ 4.6 像函数的宏#define cube(x) ((x)*(x)*(x)) 宏可以带参数 123456#define cube(x) ((x)*(x)*(x))int main(int argc, char const *argv[])&#123; printf(\"%d\\n\", cube(5)); // 125 return 0;&#125; 打开 .i 文件 12345int main()&#123;printf(\"%d\\n\", ((5)*(5)*(5))); // 被预处理成这样了； printf(\"%f\\n\", 2*3.1415927*3.0);return 0;&#125; 4.7 错误定义的宏#define RADTODEG(x) (x*57.29578)#define RADTODEG(x) (x)*57.29578 1234567#define RADTODEG(x) (x*57.29578)#define RADTODEG(x) (x)*57.29578int main() &#123; printf(\"%f\\n\", RADTODEG(5+2)); printf(\"%f\\n\", 180/RADTODEG2(1));&#125; 被预处理的结果 1234int main() &#123; printf(\"%f\\n\", (5+2 * 57.29578)); printf(\"%f\\n\", 180/1*57.29678);&#125; 我们发现 被预处理的结果是不符合我们的要求的； 4.8带参数的宏的原则 一切都要有括号 整个值要有括号，指的是整个宏的值有括号 参数出现的每个地方都要括号 #define RADTODEG(x) ((x)*57.29578) 可以带多个参数 #define MIN((a,b) ((a)&gt;(b)?(b):(a)) 也可以组合（嵌套）使用其他宏 在大型程序的代码中使用非常普遍 可以非常复杂，如“产生”函数 在# 和 ## 这两个运算符的帮助下 存在中西方文化差异 部分宏会被inline函数替代 4.9 什么时候用宏 什么时候用函数应用求稳定，用函数追求极致性能，用宏 4.10 include “” 还是 &lt;&gt;include 做了什么？ include就是把头文件里头所有的文本插入到include所在.c文件的那一行. #include有两种形式来指出要插入的文件 “”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找 &lt;&gt; 让编译器只在指定的目录去找 编译器自己知道自己的标准库的头文件在哪里 环境变量和编译器命令行参数也可以指定寻找头文件的目录 4.11 头文件 （.h文件） 在使用和定义这个函数的地方都应该 #include 这个头文件 一般的做法就是任何.c都有对应的同名的.h,把所有对外公开的函数的原型和全局变量的声明都放进去 在函数前面加上static 就使得它成为只能在所在的编译单元中被使用的函数 在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量 4.12 变量的声明123// add.hint add(int a, int b);extern int gAll; // 全局声明一个 变量 int i； 是变量的定义 extern int i； 是变量的声明 4.13声明和定义 声明是不产生的代码的东西 函数原型 变量声明 结构声明 宏声明 枚举声明 类型声明 inline函数 定义是产生代码的东西 10. typedef 为已有的数据类型改名 typedef 已有的数据类型 新名字; 1234567typedef int INT;int main () &#123; INT i; printf(D, i); exit(0);&#125; 5.1 typedef 和 define的区别12345#define IP int *typedef int *IP;IP p,q --&gt; int *p, q;IP p,q --&gt; int *p, *q; ** 更多示例** 12typedef int ARR[6]; ---&gt; int [6] -&gt; ARR;ARR a; --&gt; int a[6]; 123456789101112131415161718192021222324252627struct node_st&#123; int i; float f;&#125;;typedef struct node_st NODE;NODE a; --&gt; struct node_st a;NODE *p; --&gt; struct node_st *p;typedef struct node_st *NODEP;NODEP p --&gt; struct node_st *p;struct&#123; int i; float f;&#125;NODE, *NODEP;typedef int FUNC(int); --&gt; int(int) FUNC;FUNC f; --&gt; int f(int);typedef int *FUNCP(int);FUNCP p; ---&gt; int *p(int);typedef int *(*FUNCP)(int);FUNCP p; ---&gt; int *(*p)(int); 数组类型 数组名[常量表达式] 12float sheep[10]int a2001[1000] 11. 一唯数组1.1.1 定义 【存储类型】 数据类型 标识符 【下标】 1.1.2 初始化不初始化全部初始化部分初始化 123456int main () &#123; int a[] = &#123;1,2,3,4&#125; // 不给长度也行 int b[4] = &#123;1,2&#125; // [1,2,0,0] 部分元素初始化 int c[4] = &#123;0&#125; // [0,0,0,0] 部分元素初始化 int d[4] = &#123;1,2,3,4,5,6&#125; // compile error&#125; 1.1.3 元素引用 数组名【下标】 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3int main()&#123; int arr[M]; int i; printf(\"%d\\n\", sizeof(arr)); for(; i&lt;M; i++) printf(\"%p-&gt;%d\\n\", &amp;arr[i], arr[i]); exit(0);&#125;// 0x7ffee4394940-&gt;-466007712// 0x7ffee4394944-&gt;32766// 0x7ffee4394948-&gt;201064485 下标 查找块 1.1.4 数组名 当前数组的起始位置，数组名本身就是表示地址的一个常量。 常量： 程序执行过程当中不会发生变化的量；正因为数组名是常量，所以它不能无条件出现在数组的左边； 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3int main()&#123; int arr[M] = &#123;1,2,3&#125;; int i; arr[M] = &#123;4,5, 6&#125;; // 语法错误，数组名是常量，无法被直接赋值 printf(\"%d\\n\", sizeof(arr)); for(; i&lt;M; i++) printf(\"%p-&gt;%d\\n\", &amp;arr[i], arr[i]); exit(0);&#125; 1.1.5 数组越界 溢出数组所在内存区域 1.1.6 fb12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main() &#123; int fib[10] = &#123;1,1&#125;; int i; for (i =2; i&lt;10; i++) fib[i] = fib[i-1] + fib[i-2]; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); printf(\"\\n\"); return; &#125; 12345678910111213141516171819202122232425262728293031// fb加个排序 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int fib[10] = &#123;1,1&#125;; int i; int j; int tmp; for (i =2; i&lt;10; i++) fib[i] = fib[i-1] + fib[i-2]; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); printf(\"\\n\"); i=0; j=sizeof(fib)/sizeof(fib[0]) -1; while(i&lt;j) &#123; tmp = fib[i]; fib[i] = fib[j]; fib[j] = tmp; i++; j--; &#125; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); return; &#125; 12. 二维数组1.2.1 定义，初始化 【存储类型】 数据类型 标识符 【行下标】 【列下标】 123int a[3][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;int b[][4] = &#123;1,2,3,4,5,6,7,8,9&#125;;int c[3][4] = &#123;0&#125;; 1234int main()&#123; int a[M][N]&#125; 1.2.2 二维数组元素引用数组名[行标][列标]int a[3][4] // 定一个三行四列的二维数组 1.2.3 存储形式 顺序存储，按行存储,二维数组在内存中的存储， 是拉平的 12345678910111213141516171819202122232425----------a[0][0]----------a[0][1]----------a[0][2]----------a[0][3]----------a[1][0]----------a[1][1]----------a[1][2]----------a[1][3]----------a[2][0]----------a[2][1]----------a[2][2]----------a[2][3]---------- 深入理解二维数组 1 a[0][0] 2 a[0][1] 3 a[0][2] 4 a[0][3] 5 a[1][0] 6 a[1][1] 7 a[1][2] 8 a[1][3] 9 a[2][0] 10 a[2][1] 11 a[2][2] 12 a[2][3] 1.2.4 二维数组练习题1.2.4.1 行列互换123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 3int main()&#123; int arr[M][N] = &#123;1,2,3,4,5,6&#125;; int b[N][M]; int i,j; for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; b[j][i] = arr[i][j]; printf(\"%d\",arr[i][j]); &#125; printf(\"\\n\"); &#125;; for (i=0;i&lt;N;i++) &#123; for (j=0;j&lt;M;j++) printf(\"%d\", b[i][j]); printf(\"\\n\"); &#125; exit(0);&#125; 1.2.4.2 求最大值及其所在位置12345678910111213141516171819202122232425262728293031#define M 2#define N 3static void max(void)&#123; int a[M][N] = &#123;43,4,23,89,9,7&#125;; int i,j; int max = a[0][0], row =0, col = 0; for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; if(a[i][j]&gt;max) &#123; max= a[i][j]; row = i; col = j; &#125; &#125; &#125; printf(\"%d\\n\",max); printf(\"%d --- %d\\n\", row, col);&#125;int main()&#123; int arr[M][N] = &#123;1,2,3,4,5,6&#125;; int b[N][M]; int i,j; max(); exit(0);&#125; 1.2.4.3 求各行与各列的和 123456789101112131415161718192021222324252627282930static void sum(void)&#123; int a[5][4] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;,&#123;10,11,12&#125;&#125;; int i, j; for (i=0; i&lt;4; i++) &#123; for (j=0;j&lt;3;j++) &#123; a[4][3] += a[i][j]; a[4][j] += a[i][j]; a[i][3] += a[i][j]; &#125; &#125; for(i=0;i&lt;5;i++) &#123; for(j=0;j&lt;4;j++) &#123; printf(\"%4d\",a[i][j]); &#125; printf(\"\\n\"); &#125;&#125;int main()&#123; sum(); exit(0);&#125; 1.2.4.4 矩阵乘积123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 3#define K 2 static void mul(void) &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125; ; int b[N][K]= &#123;1,0,0,1,1,0&#125;; int c[M][K]; int i,j,k; for(i=0;i&lt;M;i++) &#123; for(j=0;j&lt;K;j++) &#123; for(k=0; k&lt;N; k++) &#123; c[i][j] += a[i][k] * b[k][j]; &#125; &#125; &#125; for(i=0;i&lt;M;i++) &#123; for(j=0;j&lt;K;j++) &#123; printf(\"%4d\",c[i][j]); &#125; printf(\"\\n\"); &#125; &#125; int main() &#123; mul(); exit(0); &#125; 1.2.5 深入理解二维数组 1.2.5.1 三维数组a[5][3][4] 数据立方体 5 -&gt; 片3 -&gt; 行4 -&gt; 列 在内存中依然是打平存放； 13. 字符数组1.3.1 定义，初始化，存储特点 【存储类型】 数据类型 标识符 【下标】。。。 1.3.1.1 单个字符初始化1char str[3] = &#123;'a','b','c'&#125; char c[] = {‘C’, ‘h’, ‘i’, ‘n’, ‘a’};// c[0] = C c[1] = h c[2]= i c[3]=n c[4]=a 1.3.1.2 用字符串常量初始化1char str1[6] = \"hello\"; // 最后一位 以 '\\0' 结尾 char c[] = “China”// c[0] = C c[1] = h c[2]= i c[3]=n c[4]=a c[5]=\\0 1.3.2 输入输出1234567891011int main()&#123; char str[N], str1[N], str2[N]; int i; scanf(\"%s%s%s\", str, str1,str2); printf(\"%s\\n%s\\n%s\\n\", str, str1,str2);&#125;// how are you// how// are// you 1.3.2.1 单词计数12345678910111213141516171819202122#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; char str[128]; int count =0, flag = 0; int i; gets(str); for(i=0;str[i]!='\\0';i++) &#123; if(str[i]==' ') flag = 0; else if(flag == 0) &#123; count++; flag=1; &#125; &#125; printf(\"count = %d\\n\", count); &#125; 1.3.3 字符数组注意事项 所有字符串都是以 \\0 来结尾的；所有以 \\0结尾 的字符数组都可以被看为字符串 123456char c[6] = \"China\"; //只可以在数组定义并初始化的时候// 不能用赋值语句将一个字符串常量或字符数组直接赋给另一个字符数组str1[] = \"China\" // 赋值，不合法str1 = \"China\" // 赋值，不合法str2 = str1 // 赋值，不合法 指针 变量与地址 指针与指针变量 直接访问与间接访问 空指针与野指针 空类型指针 定义，初始化，书写规则 指针运算 指针与数组 指针与一维数组 指针与二维数组 指针与字符数组 const与指针 指针数组和数组指针 多级指针 14. 变量与地址变量名： 变量名就是用户对某一块内存空间的抽象表示；想把这块儿内存置成100，就写int i = 100;变量名就是某个内存空间的别名； 地址： 指针就是地址，指针就是指向某个内存空间地址的地址值； 1.1 变量的三要素int a = 3 在内存中， 即产生 0x0012FF78，3，a 三个要素。 0x0012FF78即变量的地址， 把这个变量的地址称为“指向该变量的指针”； 3即变量值； a即变量的签名； 1.2 输出变量的地址地址运算符 “&amp;” int a = 3; printf(&quot;%x&quot;, &amp;a) 15. 指针与指针变量语法 TYPE NAME = VALUE； 12int i = 1; // type 为 intint * p = &amp;i; // type 为 int *, 而不是 int 2.1 非法操作（野指针）12int * p = &amp;i; // 合法操作，指针一旦定义出来，就要给一个明确指向；没有的话，下回分解int * p = 0x7fffa37eac60; // 可能这个地址已经被占用了，一般情况下，是个非法操作； 2.2 指针变量 专门用于存放指针（某个变量的地址）的变量 123456789101112int c = 76;int * pointer; //定义名字为pointer的指针变量；只能存放地址！// int *pointer;// 1) int 是指针变量的基类型 所谓基类型：指针变量指向的变量的类型// 2) * 是指针运算符，表示pointer这个变量的类型// 3) pointer 是指指针变量的名字pointer = &amp;c;// 将变量c 的地址赋值给指针变量pointer；// 赋值后，称指针变量pointer指向了变量c； 则*pointer： 为pointer所指向的存储单元的内容；是变量c。因此*pointer可以当作 变量c 来使用 2.3 指针变量的地址 指针变量也是变量，是变量就有地址 12345678910int main() &#123; int a = 13; int * p = &amp;a; *p = 100; printf(P, p); printf(P, &amp;p); // 指针变量也有地址； // 0x7ffee6a26ac8 // 0x7ffee6a26ac0 return 0;&#125; 2.4 指针变量示例12345678910111213int main()&#123; int a = 0, b=3, temp; int *p1 = NULL, *p2 = NULL; p1 = &amp;a; p2 = &amp;b; printf(\"%p\\n\", &amp;a); printf(\"%p\\n\", &amp;b); if(*p1 &lt; *p2) &#123; temp = *p1; *p1 = *p2; *p2 = temp; &#125; printf(\"%d\\n\", *p1); // 3 printf(\"%d\\n\", *p2); // 0&#125; 2.5 指针作运算 (取地址 和 取 * 和关系运算) 2.5.1 取地址 要获取某个变量在内存中的房间号 2.5.2 取* 找到现在给定房间号里面存放的内容 16. 直接访问和间接访问3.1一级间接访问和 二级间接访问1234567891011121314int main ()&#123; int i = 1; int *p = &amp;i; int **q = &amp;p; printf(P, p); // 0x7ffee92579b8 printf(P, q); // 0x7ffee92579b0 printf(P, *q); // 0x7ffee92579b8 printt(D, i); // 1 直接访问 printf(D, *p); // 1 一级间接访问 printf(D, **q);// 1 二级间接访问 exit(0);&#125; 3.2 指针关系运算 当两个指针指向的是一块连续内存空间的时候， 比如两个指针指向同一个数组。在这种情况下，两个指针可以做一个关系上的比较； ++ -- ++ – 运算实际上改变指针位置； 3.3 指针变量类型与指针变量大小12345678910111213141516171819202122int main ()&#123;int i = 1;int * p;float *q;double *d;printf(D, sizeof(i)); // 8printf(D, sizeof(p)); // 8printf(D, sizeof(q)); // 8printf(D, sizeof(d)); // 8// 结构体指针的大小也是8/** 不管指针是多少级的指针，不管指针是什么样的类型。指针在某个平台下所占的地址空间是确定的。那既然如此为何 要给指针变量加类型呢，比如 int *p, float *q. 那是因为有 *p 取* 的操作，比如*q的时候，怎么就能知道去对应地址读取 4个字节呢？ 这个时候就要靠 指针变量的 变量类型加持了。所以这个变量类型之间的意义 就不尽相同了。*/char * s;s = &amp;i;printf(D, *s); // 这个时候，不知道要去读取 4个字节，所以结果不是1；&#125; 17. 空指针与野指针12345int main ()&#123; int * p = NULL;// 指针被定义出来，还未决定指向哪里的时候，可以先指向NULL，系统上 0 号不分配给任何进程；把指针置为空是为了预防野指针； exit(0);&#125; 4.1 野指针 当前这个指针的指向是不确定的，或者压根就没有指向；但是直接使用这个指针了。 1234567int main()&#123; int *p; printf(\"%p --&gt; %d\\n\", p ,*p); // 0x7ffee67879d8---&gt;0&#125; 1234567int main()&#123; int *p; printf(\"%p --&gt; %d\\n\", p ,*p); *p = 1; // 段错误&#125; 4.1.1 如何杜绝野指针 指针一经定义，就必须有一个明确的指向，没有暂时没有指向的话，就先指向NULL； 18. 空类型1void * p = NULL; // 即 空类型 void * 是一个百搭的类型，任何类型的指针值都可以赋值给它。void * 也可以把自己的值赋值给任何类型的指针； 5.1 空类型的使用场景1void *memcpy(void *dest, const void *src, size_t n); 19. 运算符优先级 上面优先级比下面高 后置++ – 前置++ – 逻辑非 (!) * &amp; // 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高 算术运算符 关系运算符 &amp;&amp;和｜｜ 赋值运算符 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高 如 12&amp;*pointer = &amp;(*pointer)*&amp;a = *(&amp;a) (*pointer)++ 不等于 *pointer++ (pointer)++ 是先 做取运算，得到的int类型自增， pointer++ 则是 指针变量移位，然后再取运算 *pointer++ 的含义 假设： pointer当前所存的地址是0x00000100 若pointer 的指针变量基类型是 指向一个 int或实型（占4个字节），则pointer++ 等于 iptr + 1*4 = 0x00000104 若pointer 指向一个 字符型（占1个字节），则pointer++ 等于 iptr + 1*1 = 0x00000101 12345678910111213int main() &#123; int a[5] = &#123;5,11,19,21,33&#125;; int *p = NULL; printf(P, a); // 0x7ffee0eeda20 p = a; printf(P, p); // 0x7ffee0eeda20 printf(D, *p); // 5 printf(D, *p++); // 5 printf(D, *p++); // 11 printf(D, *p); // 19 return 0;&#125;*p++ 是地址移动 ** 小结** 指针和指针变量是不同的。指针是地址，指针变量就是一个普通的变量。pointer指的是这个指针变量 所指向的那片内存空间里面的内容。(pointer)++ 不等于 *pointer++ 20. 指针与数组 数组名代表数组首元素的地址 （数组名相当于指向数组第一个元素的指针）；数组名不是变量，不能给a赋值；int *p = &amp;a[0]; a++是没有意义的（a只是个常量），但p++会引起p变化。p可以指向数组最后一个元素以后的元素。指针做加减运算时一定注意有效的范围；（指针理论上能够在内存中自由的漂移，很可能移除某一个数组的范围，有的时候就比较危险了） 7.1 数组名代表数组首元素的地址 数组名是指向数组第一个元素的指针； 对于数组a[10], 数组名 a代表数组 a[10]中第一个元素a[0]的地址； 即 a 与 a[0]等价 注意： a是地址常量，不是变量，不能给a赋值； 7.2 创建一个匿名数组 指针和数组的关系，其实就是一种引用方式而已。你的一维数组名和一级指针之间的关系其实除了一个是变量，一个是常量之外。完全可以等价代换。 1234567int main()&#123; int *p = (int [3])&#123;1,2,3&#125;; int i; for (i=0;i&lt;3;i++) printf(D, p[i])&#125; 7.3 利用指针变量引用数组元素 若定义 数组 int a[10]; 指针 int * pointer; 则: pointer =a; 等价于pointer = &amp;a[0]; 数组访问 pointer+ i; 等价于 a+i; 等价于 &amp;a[i]; *(pointer+i); 等价于 *(a+i); 等价于a[i]; 表示形式 pointer[i] 等价于 *(pointer+i); 1234567891011121314151617int main () &#123; int a[9] = &#123;4,5,6,7,8,9,1,2,3&#125;; int *p = NULL; p = a; // a 是 数组的地址， printf(\"%d\\n\", *p); // 4 printf(\"%d\\n\", *p++); // 4 ++的含义是先使用p，然后再++ printf(\"%d\\n\", *p); // 5 printf(\"%d\\n\", *++p); // 6 前+ 和 后+ 跟js一样 printf(\"%d\\n\", p[0]); // 因为p=a了，所以p[0] 即a[0] printf(\"%d\\n\", p[1]); printf(\"%d\\n\", p[2]); printf(\"%d\\n\", p[3]); printf(\"%d\\n\", p[4]); return 0;&#125; 7.4 抽象公式12345int * p = a;// a[i]: a[i] = *(a+i) = *(p+i) = p[i];// &amp;a[i]: &amp;a[i] = a+i = p+i = &amp;p[i];p = a; 7.5 重置指针变量1234567891011int a[3];int *p = a;int i;for (i=0; i&lt;sizeof(a)/sizeof(*a); i++) scanf(\"%d/n\", p++);p = a; // 这里需要 重置一下 p的指针；不然会数组越界；for (i=0; i&lt;sizeof(a)/sizeof(*a); i++) printf(\"%d\", *p++); 7.6 需要注意的问题 int * p = &amp;a[0]; , * a++是没有意义的（因为a是个常量），但p++会引起p变化；* p可以指向数组最后一个元素以后的元素；（因为p是内存中的一个指针），所以指针做加减运算时一定注意有效的范围。 123456int a[5],int *iPtr = &amp;a[1];iPtr--; // 指向&amp;a[0]*iPtr = 3; // a[0] = 3iPtr--; // 指向&amp;a[-1], dangerous*iPtr = 6; // (damage) 对内存造成损坏，影响内存中其他的变量 示例 123456789int main()&#123; int a[5] = &#123;6,7,8,9,0&#125;; int *p = &amp;a[3]; *p = 100; printf(\"%d\\n\", *p++); // 100 printf(\"%d\\n\", *p--); // 0 printf(\"%d\\n\", *--p); // 8 return 0;&#125; 7.7 指向二维数组的指针7.7.1 遍历数组元素1234567891011121314151617181920212223242526272829303132int main()&#123; int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int *p; for (p= &amp;a[0][0] ;p &lt; &amp;a[0][0]+12; p++) &#123; printf(\"%d\\n\", *p); &#125; return 0;&#125;// 0x7ffeefbff4f0// 1// 0x7ffeefbff4f4// 3// 0x7ffeefbff4f8// 5// 0x7ffeefbff4fc// 7// 0x7ffeefbff500// 9// 0x7ffeefbff504// 11// 0x7ffeefbff508// 13// 0x7ffeefbff50c// 15// 0x7ffeefbff510// 17// 0x7ffeefbff514// 19// 0x7ffeefbff518// 21// 0x7ffeefbff51c// 23 如上所示， 会将这个数组的内容都打印出来了，因为二维数组会被拉平存储到一段连续的内存空间当中 7.7.2 二维数组行列指针12345678910111213141516171819202122232425262728293031323334353637383940414243 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define M 3 #define N 4 #define D \"%d\\n\" #define P \"%p\\n\" int main () &#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i, j; printf(\"&amp;a = %p, &amp;a+1 = %p\\n\", &amp;a, &amp;a+1); printf(\"%&amp;a[0][0] = %p, &amp;a[1][0] = %p\\n\", &amp;a[0][0], &amp;a[1][0]); for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%p---&gt;%d\\n\", &amp;a[i][j], a[i][j]); &#125; printf(\"\\n\"); &#125; exit(0); &#125;// &amp;a = 0x7ffefe385370, &amp;a+1 = 0x7ffefe3853a0// %&amp;a[0][0] = 0x7ffefe385370, &amp;a[1][0] = 0x7ffefe385380// 0x7ffefe385370---&gt;1// 0x7ffefe385374---&gt;2// 0x7ffefe385378---&gt;3// 0x7ffefe38537c---&gt;4// 0x7ffefe385380---&gt;5// 0x7ffefe385384---&gt;6// 0x7ffefe385388---&gt;7// 0x7ffefe38538c---&gt;8// 0x7ffefe385390---&gt;9// 0x7ffefe385394---&gt;10// 0x7ffefe385398---&gt;11// 0x7ffefe38539c---&gt;12 小结： 所以a除了是二维数组的数组名（地址常量）之外，在使用上比较偏向一个指向行指针。 7.7.3 能够接收二维数组指针的指针变量引子 1234567891011&#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i=0, j=0; int *p = NULL; p =&amp;a[i][j]; // *(a+0) , *a for (i=0; i&lt;12; i++,p++) // for (i=0; i&lt;12; i++) printf(\"%d \", *p); // printf(\"%d \", p[i]); printf(\"\\n\"); exit(0); // 1 2 3 4 5 6 7 8 9 10 11 12 &#125; 7.7.4 另一段程序123456789int main()&#123; int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int (*p)[4], i,j; p = a; cin&gt;&gt;i&gt;&gt;j; // i&lt;3 代表行号， j&lt;4 代表列号； cout &lt;&lt; setw(4) &lt;&lt; *(*(p+i)+j); // 正误判断： 访问元素 a[i][j] return 0;&#125; 程序分析 从 p = a 开始 a相当于指向a[3][4]的“第一个元素”的指针； 所谓“第一个元素”是指一个“包含4个int型元素的一维数组”； 所以，a相当于一个“包含4个int型元素的一维数组”的地址； 因此，p的基类型应该是： “包含4个int型元素的一维数组” 变量定义语句的语法为： int (*p)[4]; *p(数组) p -&gt; | (p)[0] | (p)[1] | (p)[2] | (p)[3] | 7.7.5 利用指针变量引用多维数组中的数组((p+i)+j)是什么？ p 是指向一个“包含4个int型元素的一维数组”； p+i 是第i+1个“包含4个int型元素的一维数组”的地址; p+i 等价于&amp;a[i]； *(p+i)等价于a[i]； *(p+i)+j 等价于 a[i]+j; // 这里把a[i] 当作一个指针来看 因此， a[i]+j 等价于 &amp;a[i][j]; ((p+i)+j) 等价于 a[i][j]; 7.8 指针与字符数组12345678910111213 int main () &#123; char s[] = \"i love coding!\"; // codeing char *p = s+7; printf(\"%s\\n\", s+7); puts(s); puts(p); // puts(p) 相当于把p的起始位置拿进来， 依次输出，直到碰到\\0 为止； exit(0); &#125;// coding!// i love coding!// coding! 7.8.1 字符数组拼接12345678910#include &lt;string.h&gt;int main()&#123; char str[] = \"hello\"; // str = \"world\" false strcpy(str, \"world123\"); // 覆盖原来数组空的每一项 puts(str); // world123 exit(0);&#125;// world123 7.8.2 字符串长度和字符串字节数12char str[] = \"hello\";printf(\"%d ,%d\", sizeof(str), strlen(str)); // 6, 5 7.8.3 字符指针跟字符数组的区别12345678char *str = \"hello\";sizeof(str); // 8 指针变量不分类型 ， 64位系统下长度都是8个字节， 32位系统为4个字节；strlen(str); // 5 字符串长度strcpy(str, \"world\"); // 段错误， 字符指针跟字符数组的区别就在于此。因为str 指向的是一个 字符串常量的地址， strcpy是一个覆盖写操作，显然，企图去更改一个常量是无效的。之所以是常量，是串常量，这个串在当前存储位置是特殊的。在使用上不允许被改变和覆盖。// 正确的做法str = \"world123\"; //更改指针指向；puts(str); 21. 字符串与指针 指向字符串的指针 指向字符串的指针变量： char a[10]; char *p; p=a; 数组和字符串太接近了。那怎么去定义指向字符串的指针呢？也很简单， 我首先定义一个字符数组，它就是用来存放字符串的。 我们以前讲过字符串和字符数组其实区别就在于有没有最后的反斜杠零， 本质上都是字符数组。 123456789101112int main()&#123; int a = 5; int *p = &amp;a; char c[6] = &#123;'h', 'e', 'l', 'l', 'o','\\0'&#125;; char *s = c; printf(P, s); // 0x7ffee2066aba printf(P, c); // 0x7ffee2066aba printf(S, s); // hello printf(S, c); // hello s++; printf(S, s); // ello&#125; 8.1 字符串指针举例123456789101112int main() &#123; char buffer[10] = \"ABC\"; char *pc; pc = \"hello\"; // 虽然 hello赋值给了pc，但是却不能通过pc去改变hello， 因为hello是常量，常量在内存中被放在特殊的地方了；这片区域不允许修改； cout &lt;&lt; pc &lt;&lt; endl; // hello pc++; cout &lt;&lt; pc &lt;&lt; endl; // ello cout &lt;&lt; *pc &lt;&lt; endl; // e pc = buffer; cout &lt;&lt; pc; // ABC return 0;&#125; 22. const与指针 const是把某些内容常量化 1234567891011121314const int a;const float pi = 3.14; // 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。int const a;// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思 const int *p;int const *p;// 指针常量int *const p;const int *const p; 9.1 变量值常量化123const int a;const float pi = 3.14; // 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。int const a; 9.2 常量指针 指针的指向可以发生变化，但是指针所指向当前的那块内存的值是不可以发生变化的； 123// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思const int *p;int const *p; 12345678910int main ()&#123; const float pi = 3.14; // float *p = &amp;pi; // 警告： initialization discards ‘const’ qualifier from pointer target type const float *p = &amp;pi; *p = 3.14159; printf(\"%f\\n\", pi); printf(\"%f\\n\", *p); exit(0);&#125; 举例： 1int open(const chart * pathname, int flags); // 常量指针，保护pathname值不被篡改 9.3 指针常量int *const p; 指针常量指 指针的指向永远不能发生变化；但是指针指向的值可以有变化； 9.4 如何区分到底是 常量指针，还是指针常量1234const int *p; // 如果先碰到const关键字，就把常量先念出来int const *p; int *const p; // 如果先看到 *，就把指针先念出来 9.5 两个const修饰const int *const p; 12345678910int main ()&#123; int i = 1; int j = 100; const int * const p = &amp;i; p = &amp;j; // warning 因为p是只读的，不能更改指向； *p = 10; // warning 因为*p 也是只读的；&#125; 9.6 指向符号常量的指针const int * p; 当把p定义成一个指向符号常量的指针的时侯， 然后再让这个p指向什么东西， 它所指向的那个东西就不能被修改了。我们就不能通过p再去修改 它所指向的那个东西了。 深坑啊,要留意 1234567891011121314int main() &#123; const int a = 78; const int b = 28; int c = 18; const int * p1 = &amp;a; *p1 = 58; // (error, *p不能被赋值) p1 = &amp;b; // （可以给 p1 重新赋值） *p1 = 68; // (error, *p不能被赋值) printf(D, *p1); // 28 p1 = &amp;c; // （可以给 p1 重新赋值） *p1 = 88; // (error, *p不能被赋值) printf(D, *p1) // 18&#125; 9.7 再谈一维数组的地址数组名相当于指向数组第一个元素的指针 123456789101112131415int main() &#123; int a[4] = &#123;1,3,5,7&#125;; cout&lt;&lt;a&lt;&lt;endl; // a[1]的地址，管辖范围只有a[1] cout&lt;&lt;&amp;a&lt;&lt;endl; // a[1]的地址，管辖范围是整个a的内存空间 cout&lt;&lt;a+1&lt;&lt;endl; // a[2]的地址 cout&lt;&lt;&amp;a+1&lt;&lt;endl; // 跳出了a的内存范围，理论上是 a[5]的地址 printf(P, a); // 0x7ffee42adab0 printf(P, a+1); // 0x7ffee42adab4 跨越4个字节 printf(P, &amp;a); // 0x7ffee42adab0 printf(P, &amp;a+1); // 0x7ffee42adac0 // 跨越16个字节 printf(P, *(&amp;a)); // 0x7ffee42adab0 printf(P, *(&amp;a) + 1); // 0x7ffee42adab4&#125; 根据C语言的规范 *(&amp;a) 等同于 a; 即a数组第一个元素的内存地址*(&amp;a) + 1 等同于 a+1; 即a数组第二个元素的内存地址 &amp;a的管辖范围是整个数组a。c语言规范中，当它前面出现*时，管辖范围降级，即堕落成了 a[0]的地址； 9.8 总结 数组名相当于指向数组第一个元素的指针 &amp;运算符 - 升级 若 a 是指向数组第一个元素的指针，即a相当于 &amp;a[0]; &amp;a是“指向数组”的指针；&amp;a+1将跨越16个字节； &amp;a相当于管辖范围 “上升” 了一级; *运算符 - 降级*a是数组的第一个元素a[0]；即 *a等价于a[0]； *a 相当于管辖范围“下降”了一级； 9.9 指向二维数组的指针 二维数组的定义 二维数组a[3][4]包含三个元素： a[0] a[1] a[2] 每个元素都是一个“包含四个整型元素”的数组 | 1 a[0][0] | 2 a[0][1] | 3 a[0][2] | 4 a[0][3] || 5 a[1][0] | 6 a[1][1] | 7 a[1][2] | 8 a[1][3] || 9 a[2][0] | 10 a[2][1]| 11 a[2][2]| 12 a[2][3]| - 二维数组的第一个元素是a[0]; - a[0]是一个“包含四个整形元素”的一维数组； 推论 a 与 &amp;a[0] 等价a[0] 与 &amp;a[0][0] 等价a[0] 与 a 等价a[0][0] 与 *a 等价 9.10 总结三条规律1） 数组名相当于指向数组第一个元素的指针；2） &amp;E相当于把E的管辖范围上升了一个级别；3） *E相当于把E的管辖范围下降了一个级别； 23. 指针与函数10.1 指针用作函数参数123456789101112131415161718void Rank(int *q1, int *q2) &#123; int temp; if (*q1 &lt; *q2)&#123; temp = *q1; *q1 = *q2; *q2 = temp; &#125;&#125;int main() &#123; int a, b, *p1, *p2; scanf(a); scanf(b); p1 = &amp;a; p2 = &amp;b; Rank(p1, p2); // 指针传递，即地址传递 printf(\"%d\\n\", a); printf(\"%d\\n\", b); return 0;&#125; 10.2 将数组名作为实参123456789101112void sum(int *p, int n) &#123; int total = 0; for (int i=0; i&lt;n; i++)&#123; total += *p++; &#125; printf(\"%d\\n\", total); // 6&#125;int main() &#123; int a[3] = &#123;1,2,3&#125;; sum(a, 3); // 将数组名作为实参赋给指针型形参 return 0;&#125; 10.3 “数组名” 做形参12345678910111213// c++ 编译器将形参数组名 作为 指针变量来处理！int sum(int array[], int n)&#123; for (int i=0; i&lt;10-1; i++) &#123; *(array+1) = *array + *(array+1); // 数组从第二项开始，每一项都等于自己加上前一项的和； array++; &#125; return *array;&#125;int main() &#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; printf(\"%d\\n\", sum(a, 10)); return 0;&#125; 当程序里，把一个指针变量或者是数组的名字，传递给一个函数的时候，是挺危险的，因为这个函数拿到的，是这个变量或者是数组的地址， 它拿到了地址，它就可以直接对地址里面存放的这些值，进行肆意的修改，那有没有一种办法，可以呢 使我既能够把这个地址传递给某个函数，又能够确保不让这个函数随意的修改这片地址里面的值呢？ 如何 “限制” 指针的功能 如何“限制”指针实参的功能 10.4 即指向符号常量的指针123456789101112int sum(const int array[], int n)&#123; // 补充为const for (int i=0; i&lt;10-1; i++) &#123; *(array+1) = *array + *(array+1); // array变成常量之后，无法修改 array++; &#125; return *array;&#125;int main() &#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; printf(\"%d\\n\", sum(a, 10)); return 0;&#125; 符号常量声明语句 const 数组类型 常量名 = 常量值； 数据类型 const 常量名 = 常量值； 10.5 指针用作函数返回值函数的返回值可以是多种类型 返回整形数据的函数 int max(int x, int y); 返回指针类型数据的函数 int *min(int x, int y) 函数名字前面表示函数的类型 * 123456789101112// int arr[][4] 除了这么定义，还可以 int *(arr)[4]int *get(int arr[][4], int n, int m) &#123; int *pt; pt = *(arr+n-1) + m-1; return (pt);&#125;int main() &#123; int a[4][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16&#125;; int *p; p = get(a, 2,3); printf(\"%d\\n\", *p);&#125; 分析一下返回结果， 又一个需要注意的深坑 1234567891011int *getInt1() &#123; int value1 = 20; return &amp;value1;&#125;int main() &#123; int *p; p = getInt1(); printf(\"%d\\n\", *p); // 这里会打印未知数，也可能会打印20；为什么呢，因为随着getInt1的运行时完毕，导致它函数内部的所有引用被释放了。所以返回的地址&amp;value1 指向的内存空间被释放掉了；所以谁也不会知道这个地址现在存放的是个啥，如果该块内存没有被新写入值，那么还是20；新写入的话，那就是新的未知量了； return 0;&#125; 验证 1234567891011121314151617int *getInt1() &#123; int value1 = 20; return &amp;value1;&#125;int *getInt2() &#123; int value2 = 30; return &amp;value2;&#125;int main() &#123; int *p, *q; p = getInt1(); q = getInt2(); printf(\"%d\\n\", *p); // 这里大概率会是30 return 0;&#125; 那既然如此，有什么办法解决这个问题 静态局部变量 123456789101112131415161718int *getInt1() &#123; static int value1 = 20; return &amp;value1;&#125;int *getInt2() &#123; static int value2 = 30; return &amp;value2;&#125;int main() &#123; int *p, *q; p = getInt1(); q = getInt2(); printf(\"%d\\n\", *p); // 20 printf(\"%d\\n\", *q); // 30 return 0;&#125; 什么是静态局部变量 ** 静态局部变量 ** 函数中局部变量的值在函数调用结束后不消失而保留原值 即其占用的存储单元不释放，在下一次该函数调用时，仍可以继续使用该变量； 12345678910111213141516171819202122void function() &#123; int a = 0; static int b = 0; // 有点像 hooks，只初始化一次，后续不再重新将其赋值为0； a = a+1; b = b+1; printf(\"%d\\n\", a); printf(\"%d\\n\", b);&#125;int main() &#123; for (int i =3; i&lt;3;i--)&#123; function(); &#125; return 0;&#125;// 1// 1// 1// 2// 1// 3 小结 指针与函数 指针用做函数参数 函数拿到地址可对其所指内容进行修改； 可以使用const来“限制”指针的功能； 指针用做函数返回值 必须确保函数返回的地址是有意义的； 返回全局变量或静态局部变量；24. 指针数组和数组指针11.1 数组指针 归根结底是一个指针，是指向数组的指针。 【存储类型】 数据类型 （*指针名）【下标】 = 值； 如： int (*p)[3]; ---&gt; type name ----&gt; int[3] *p 解析： 定义一个指针变量 p, 用来指向 int[3] 类型的元素的起始位置。原来 int * p 的时候，p+1 的操作是移动一个 int 的大小。如果p的类型 变成了 int [3]的话，p+1的操作是一下移动三个 int 元素的大小。所以数组指针是在某种 大小的数组中进行移动。 12345678910111213141516171819202122232425262728293031323334353637383940int main () &#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i=0, j=0; int *p = *a; int (*q)[N]= a; printf(\"%p %p\\n\", a, a+1); printf(\"%p %p\\n\\n\", q, q+1); for (i =0; i&lt;M; i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%p -&gt; %d\\n\", *(a+i)+j, *(*(a+i)+j)); // printf(\"%p -&gt; %d\\n\", *(q+i)+j, *(*(q+i)+j)); // a 和 q现在是等价的，区别只是一个是常量，一个是变量； &#125; printf(\"\\n\"); &#125; exit(0); &#125;// 0x7ffd6f5ad1f0 0x7ffd6f5ad200// 0x7ffd6f5ad1f0 0x7ffd6f5ad200// 0x7ffd6f5ad1f0 -&gt; 1// 0x7ffd6f5ad1f4 -&gt; 2// 0x7ffd6f5ad1f8 -&gt; 3// 0x7ffd6f5ad1fc -&gt; 4// 0x7ffd6f5ad200 -&gt; 5// 0x7ffd6f5ad204 -&gt; 6// 0x7ffd6f5ad208 -&gt; 7// 0x7ffd6f5ad20c -&gt; 8// 0x7ffd6f5ad210 -&gt; 9// 0x7ffd6f5ad214 -&gt; 10// 0x7ffd6f5ad218 -&gt; 11// 0x7ffd6f5ad21c -&gt; 12 11.2 指针数组 归根结底是一个数组 【存储类型】 数据类型 * 数组名 【长度】 如： int * arr[3]; ---&gt; TYPE NAME ---&gt; int *[3] arr; 11.3 指针数组与数组指针的区别1234567891011121314151617181920212223242526272829int main()&#123; int i, k, j; // 指针数组 char *name[5] = &#123;\"Follow me\", \"Basic\", \"Great\", \"Fortran\", \"Computer\"&#125;; char *tmp; for (i = 0; i &lt; 5 - 1; i++) &#123; k = i; for (j = i + 1; j &lt; 5; j++) &#123; if (strcmp(name[k], name[j]) &gt; 0) &#123; k = j; &#125; &#125; if (k != i) &#123; tmp = name[i]; name[i] = name[k]; name[k] = tmp; &#125; &#125;; for (i = 0; i &lt; 5; i++) &#123; puts(name[i]); &#125;; return 0;&#125; 25 .多级指针 12345Line1 int num = 1;Line2 int *p = &amp;numLine3 int *p1 = p;Line4 int **p2 = &amp;p1;Line5 int ***p3 = &amp;p2; 多级指针的本质，只是C语言的一个书写规范，事实上任何指针都可以保存任何地址； 多级指针的存储的值的推理过程 12345Line1 int num = 1;Line2 int *p = &amp;numLine3 int *p1 = p;Line4 int **p2 = &amp;p1;Line5 int ***p3 = &amp;p2; 函数 函数的定义 函数的传参 函数的调用 （嵌套和递归） 函数与数组 函数与指针 （指针函数， 函数指针， 函数指针数组） 26. 函数的定义 数据类型 函数名 （【数据类型 形参名 。。。】） 函数的类型是指 函数的返回值的数据类型 1.1.1 main函数1234567891011121314/** argc： 参数计数器，统计终端上多少个参数传进来 *argv[]： 列表，用来传递刚才命令行传递进来的参数 *argv[]是一个数组； argv 是数组名； char* 指数组中每个元素的类型为 char*；即字符指针 argv 即字符数组指针的首地址；*/int main(int argc, char *argv[]);&#123; printf(\"argc=%d\\n\", argc); exit(0);&#125; 12./main /etc/a*.conf# 4 因为shell 会自动解析通配符，把结果都解析出来。 图示：char * argv 数组模型 ** 输出argv** 12345678int main (int argc, char * argv[]) &#123; int i; // for (i=0; i&lt;argc; i++) for (i=0; argv[i] !=NULL; i++) puts(argv[i]); exit(0);&#125; 1.1.2 C语言使用函数之前也需要先声明 函数在使用前都要声明，除非被调用函数的定义部分已经出现在主调函数之前, 在C语言中，函数声明就是函数原型。 123456789101112#include &lt;stdio.h&gt;void printf_hello(void);// 需要先声明，因为main函数在 printf_hello函数上面int main ()&#123; printf_hello(); return 0;&#125;void printf_hello(void)&#123; printf(\"hello world!\\n\"); return;&#125; 27. 函数的传参1.2.1 值传递12345678910int printf_value(int i, int j) &#123; // 参数i j 随着 print_value 调用栈执行结束就释放掉了。 printf(\"%d%d\\n\", i,l); return 0;&#125;int main() &#123; int i =3; l = 5; printf_value(i,l); return 0;&#125; 1.2.2 地址传递123456789101112int swap (int * i, int * j) &#123; int tmp; tmp = *i; *i = *j; *j = tmp;&#125;int main() &#123; int i =3; l = 5; swap(&amp;i,&amp;l); return 0;&#125; 28. 函数的调用（嵌套调用 和 递归调用）1.3.1 函数的调用方式 函数调用作为独立语句，stringPrint(); 函数作为表达式的一部分,number = max(numA,numB)/2; 以实参形式出现在其他函数的调用中,number = min(sum(-5, 100), numC); 1.3.2 嵌套调用123456789101112131415161718int minus(int a, int b, int c) &#123; return max(a,b,c) - min(a, b, c);&#125;int min(int a, int b, int c) &#123; int tmp = a &lt; b? a :b; return tmp &lt; c ? tmp : c;&#125;int max(int a, int b, int c) &#123; int tmp = a &gt; b? a :b; return tmp &gt; c ? tmp : c;&#125;int main () &#123; int result; int a = 3, b = 5, c = 10; result = minus(a,b,c); printf(\"%d\\n\", result); return 0;&#125; 39. 函数与数组1.4.1 函数与一唯数组问题：封装一个printf_arr方法来遍历数组；应该如何定义 printf_arr 的行参 12345678910111213141516171819202122int printf_arr(int a[])&#123; int i = 0; printf(\"printf_arr ---&gt; %p\\n\", a); // 传入的是 数组 a的 起始地址； for (i=0; i&lt;sizeof(a)/sizeof(a[0]); i++) // 是因为 a的 sizeof为 8， 所以只能访问数组前2位 &#123; printf(\"%d \",a[i]); // 1， 2 &#125; printf(\"\\n\");&#125;int main()&#123; int a[6] = &#123;1,2,3,4,5,6&#125;; printf(\"main ---&gt; %p\\n\",a ); // a 即 &amp;a, 即 &amp;a[0]; printf_arr(a); exit(0);&#125;// main ---&gt; 0x7ffd84a62eb0// printf_arr ---&gt; 0x7ffd84a62eb0 1234567891011void print_arr(int *p)&#123; int i; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(p));// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置&#125;int main()&#123; int a[] = &#123;1,3,5,7,9&#125;; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(a)); // 20，整个数组所占内存的大小，因为每个int是 4个字节； print_arr(a);&#125; ** 解决方法** 将数组的长度，当做第二个参数传入给 子函数。 1234567891011121314void print_arr(int *p, int n)&#123; int i; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(p));// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置 for (i=0; i&lt;n; i++) printf(\"%d\\n\", p[i]); // p[i] 与 *(p+i) 等价 printf(\"\\n\");&#125;int main()&#123; int a[] = &#123;1,3,5,7,9&#125;; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(a)); // 20，整个数组所占内存的大小，因为每个int是 4个字节； print_arr(a, sizeof(a)/sizeof(*a));&#125; 12void printf_arr(int p[], int n);// 当 p[] 作为行参时， [] 等同于 * 因此 int p[] 即为 int *p ** 示例** 12345678910111213int main() &#123; int a[N] = &#123;1,2,3,4,5,6&#125;; int *p = a; a -&gt; int * *a即*(a+0) -&gt; int a[0] -&gt; int &amp;a[3] -&gt; int * p[i] -&gt; int p -&gt; int * *p -&gt; int p+1 -&gt; int *&#125; ** 逆序** 12345678910111213141516171819202122void func(int *p, int n) &#123; int i=0, j, m, tmp; m = (n -1)/2; for (;i&lt;=m;i++) &#123; j = n -1 -i; tmp = p[i]; p[i] = p[j]; p[j] = tmp; &#125;&#125;;int main() &#123; int a[0] = &#123;1,3,5,7,9&#125;; for (i =0; i&lt; sizeof(a)/sizeof(*a); i++) printf(\"%d\\n\", a[i]); printf(\"\\n\"); func(a, sizeof(a)/sizeof(*a)); for (i =0; i&lt; sizeof(a)/sizeof(*a); i++) printf(\"%d\\n\", a[i]); printf(\"\\n\"); return 0;&#125; 1.4.2 函数与二维数组12345678910111213141516171819 int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; int i = 0; int j = 0; for (i = 0; i&lt; M; i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%d \", a[i][j]); &#125; printf(\"\\n\"); &#125; exit(0); &#125;// 1 2 3// 4 5 6 问题： 同样的把输出放到一个独立的函数中去，也就是考察一下 二维数组应该如何给函数传参 这个问题实际考察点在于 二维数组如何 过实参给函数，以及函数的二维数组行参应该如何定义 1234567891011121314151617181920212223// 第一种, 用一个二维数组的指针去接收int arr_traverse(int (*p) [N], int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;n;i++) &#123; printf(\"%d \",*(*p+i)); // 关键点在这里， 首先 p 指向的是 int [3] 这个类型。所以需要降级 为列指针 &#125;; printf(\"\\n\"); &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M*N); // *a === a[0] === *(a+0) exit(0); &#125; 1234567891011121314151617181920212223// 第二种，用一个普通一维数组指针去接收int arr_traverse(int *p, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;n;i++) &#123; printf(\"%d \",*(p+i)); &#125;; printf(\"\\n\"); &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(&amp;a[0][0], M*N); // 传递的是列指针 exit(0); &#125; 12345678910111213141516171819202122232425262728// 第三种 void arr_traverse(int (*p)[N],int m, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;m;i++) &#123; for (j=0; j&lt;n;j++) &#123; printf(\"%d \",*(*(p+i)+j)); &#125; &#125;; printf(\"\\n\"); return; &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M,N); exit(0); &#125; 1234567891011121314151617181920212223242526// 第四种void arr_traverse(int p[][N],int m, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;m;i++) &#123; for (j=0; j&lt;n;j++) &#123; printf(\"%d \", p[i][j]); &#125; &#125;; printf(\"\\n\"); return; &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M,N); exit(0); &#125; ** 小结 ** 123int a[M][N] = &#123;...&#125;;int * p = *a;int (*q)[N] = a; 二维数组 参与传参的一些基本内容 a[i][j] *(a+i)+j a[i]+j p[i] *p q[i][j] *q === *(q+0) q p+3 q+2 int int * int * int int int int * int (*)[N] int * int (*)[N] 1.4.2.1 示例： 求平均数1234567891011121314151617181920212223242526float average_score(int *p, int n)&#123; int i; float sum = 0; for (i=0; i&lt;n; i++) &#123; sum += p[i]; &#125; return sum/n;&#125;find_num(int (*p)[N], int num)&#123; int i = 0; for (i =0; i&lt;N; i++) &#123; printf(\"%d\\n\", *(*(p+num)+i)); &#125;&#125;int main ()&#123; int num = 1; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; average_score(*a, M*N); find_num(a, num);&#125; 1.4.2.2 二维数组什么时候传行指针，什么时候传列指针 当不区分行列的时候，可以把它当作一个大的一维数组。那就传递指针。 如果要区分行列来做某件事情的时候，那就需要把行指针传递过去。 1.4.3 函数与字符数组1234567int main () &#123; char str1[] = \"helloworld\"; char str2[128]; strcpy(str2, str1); //实现了拷贝 exit(0);&#125; 123456789101112131415//实现一个 mystrcpy 用于拷贝char * mystrcpy(char * dest, const char * src) &#123; char *ret = dest; if (dest != NULL &amp;&amp; src != NULL) while((*dest++ = *src++) != '\\n'); return ret;&#125;int main () &#123; char str1[] = \"helloworld\"; char str2[128]; mystrcpy(str2, str1); //实现一个 mystrcpy 用于拷贝 puts(str2); // 测试一下 exit(0);&#125; 123456789101112131415161718//实现一个 mystrncpy 用于拷贝char * mystrncpy(char *dest, const char * src, size_t n) &#123; int i=0; for (; i&lt;n &amp;&amp; (dest[i] = src[i]); i++) ; for (; i&lt;n; i++) dest[i] = '\\0'; return dest;&#125;int main () &#123; char str1[] = \"helloworld\"; char str2[128]; mystrncpy(str2, str1, 5); //实现一个 mystrcpy 用于拷贝 puts(str2); // 测试一下 exit(0);&#125; 30. 函数与指针 指针函数, 函数指针, 函数指针数组 1.5.1 指针函数 一个函数的返回值为指针，即为指针函数 返回值 * 函数名(形参);如： int * fun(int); 引子 123456789101112131415161718// 从find_num 这个函数说起，这个函数并不纯，而且没有实现它的功能；void find_num(int (*p)[N], int num)&#123; int i; for(i=0;i&lt;N;i++) &#123; printf(\"%d\", *(*(p+num)+i)); &#125; printf(\"\\n\");&#125;int main()&#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; float ave; int num = 0; find_num(a, num); // find_num 的设计不应该没有返回值；&#125; 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3#define N 4int * find_num(int (*p)[N], int num) // 将find_num 设计成为一个指针函数&#123; if (num &gt; M -1) return NULL; return *(p+num);&#125;int main()&#123; int i, j; int * res; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; float ave; int num =0; res = find_num(a, num); if (res != NULL) &#123; for (i=0;i&lt;N;i++) printf(\"%d\",res[i]); printf(\"\\n\"); &#125; else &#123; printf(\"can not find\\n\"); &#125;&#125;; 1.5.2 函数指针 一个指针指向的是函数， 在C语言里面。你并不能用一个普通变量去接收 函数啊，或者结构体等等数据类型，必须要使用相同的类型变量去接收相同的类型。比如函数要用函数指针变量去接收； 类型 (指针名) （形参） 如： int (p)(int); 123456789101112131415int add (int a, int b)&#123; return a+b;&#125;int main()&#123; int a=3, b=5; int ret; int (*p)(int, int); // 定义一个函数指针 p = add; // 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址， 也可以写成 p = &amp;add;这里之所以省略，是因为函数名(add)本身就是一个地址。所以在指针和函数的指向关系当中，地址符可以省略。同样的 `ret = *p(a, b)`； p前面的 *也可以省略。 `ret = p(a, b)`。指向函数的指针，让这个指针指向某一个函数的入口地址。下面通过指针来传参数就如同通过函数名来传参数是一样的； ret = p(a, b); printf(\"%d\\n\",ret); exit(0);&#125; 1.5.3 函数指针数组引子 12345678910111213141516171819202122int add (int a, int b)&#123; return a+b;&#125;int sub (int a, int b)&#123; return a*b;&#125;int main()&#123; int a=3, b=5; int ret1, ret2; int (*p)(int, int); // 定义一个函数指针 int (*q)(int, int); // 这里面定义两个相同的 函数指针有点浪费 p = add; // 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址 ret1 = p(a, b); ret2 = q(a, b); printf(\"%d\\n\",ret1); printf(\"%d\\n\",ret2; exit(0);&#125; 1.5.4 引出函数指针数组语法： 类型 （数组名[下标]）（形参）；如: int (arr[N])(int);arr是一个数组，这个数组有N个元素。这N个元素都是指向函数的指针。 1234567891011121314151617181920212223242526int main()&#123; int a=3, b=5; int ret1, ret2; int i; // int (int, int) *funcp[2]; funcp这个数组有两个指针，两个指针都是指向 int (int, int) 类型的函数； 转换一种写法就是 int (*funcp[2])(int, int); // p = add; // q = sub; // ret1 = p(a, b); // ret2 = q(a, b); funcp[0] = add; funcp[1] = sub; for (i=0; i&lt;2; i++) &#123; ret1 = funcp[i](a, b); printf(\"%d\\n\",ret1); &#125; // printf(\"%d\\n\",ret1); // printf(\"%d\\n\",ret2; exit(0);&#125; 1.5.5 指向指针函数的函数指针数组 int *(*func[N])(int) 31. 函数的执行过程1.6.1 main函数 —— 函数执行的入口 遇到函数，开辟内存空间； 在内存空间再碰到函数时候， 初始化内嵌函数； 传递参数 保存外层函数执行空间 执行完毕后。。。。释放函数执行栈 接收函数的返回值 恢复现场，从断点处继续执行 1.6.2 参数的传递 实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”。即拷贝 函数调用时，系统给行参分配存储单元，并将实参对应的值传递给形参； P.S. 实参与形参的类型必须相同或可以兼容； 1.6.3 变量的作用范围局部变量与全局变量 根据变量在程序中作用范围的不同，可以将变量分为局部变量和全局变量 局部变量在函数内或块内定义，只在这个函数或块内其作用的变量； 全局变量在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。 当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量 32. 数组与函数 数组名 做函数参数 1234567891011void change(int a[]) &#123; a[0] = 30; a[1] = 50;&#125;int main() &#123; int a[2] = &#123;3, 5&#125;; change(a); // 地址传递， 数组的名字代表着数组所在的地址； printf(\"%d, %d,\", a[0], a[1]); // 30 50 return 0&#125; 33. 缓冲区1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; // __FUNCTION__ 当前所在的函数， // __LINE__ 当前所在的行数 printf(\"[%s:%d]before\", __FUNCTION__, __LINE__); while(1); printf(\"[%s:%d]after\", __FUNCTION__, __LINE__); exit(0);&#125;./printf// 发现两个printf都没打印出来东西 ** 缓冲机制 ** 由于使用了终端设备，所以原本默认是全缓冲模式变成了行缓冲模式。所以printf是遇到了 \\n 才去刷新缓冲区的。或者是当前等缓冲区满了去自动刷新。\\n 是去强制刷新缓冲区。 没有加\\n 那个“before”这句话就放到了输出缓冲区当中，什么时候刷新呢？ 要么等程序结束自动刷新IO，要么就是遇到一些强制刷新的函数iflush 这种，要么就等到缓冲区攒满了一次性去刷新。 34. 动态内存管理 在编写程序时，通常并不知道需要处理的数据量，或者难以评估所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，就需要动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存管理原理； 以下几个函数都存在标准 stdlib.h 中 1.9.1 malloc calloc （分配新的内存区域）void *malloc(size_t, size); 它会在堆上分配这块连续的内存空间，并返回起始地址； void *calloc(size_t nmemb, size_t size) 一个成员 size个大小，nmemb这么多成员的空间；连续申请多块 size大的内存 1234567891011121314int *p;p = malloc(sizeof(int));if (p == NULL)&#123; printf(\"error\");&#125;else&#123; *p = 10; printf(\"%d\\n\", *p);&#125;;free(p); // 用完记得释放掉内存， 在同一个函数中做到 malloc 和 free一一对应printf(\"%d\\n\", *p);exit(0); 12345678910111213int *p;int num = 5;p = malloc(sizeof(int) * num);for (int i= 0 ;i&lt;num; i++) &#123; scanf(\"%d\", &amp;p[i]);&#125;for (int j=0; j&lt;num; j++) &#123; printf(\"%d \", p[j]);&#125;printf(\"\\n\");free(p);exit(0); *一道面试题 (提示： 这个程序当中已经产生了内存泄漏) * 12345678910111213141516void func(int *p, int n) &#123; p = malloc(n); if (p == NULL) exit(1); // p在这个函数当中是一个局部变量，随着func执行完毕之后，这块内存空间会丢失。导致内存泄漏，只有随着操作系统中这个进程结束掉，才会释放这100个单位的内存 return;&#125;int main()&#123; int num = 100; int *p = NULL; func(p, num); free(p); exit(0);&#125; 改法一： 12345678910111213141516void func(int **p, int n) &#123; // 用一个二级指针来接受 *p = malloc(n); // 此时*p 就是main函数中的p if (*p == NULL) exit(1); return;&#125;int main()&#123; int num = 100; int *p = NULL; func(&amp;p, num); free(p); exit(0);&#125; 改法二： 123456789101112131415161718void func(int *p, int n)&#123; p = malloc(n); if (p == NULL) exit(1); return p;&#125;int main()&#123; int num = 100; int *p = NULL; p = func(p, num); // 用p 来接触返回值 free(p); exit(0);&#125; 1.9.2 realloc （调整已分配的内存区域）void *realloc(void *ptr, size_t size); 重新分配一块动态的内存空间 ,比如之前用malloc calloc分配的内存空间太大或者太小，现在把 起始地址传进去(第一个参数); 然后要size 大小的这么一段(第二个参数)；所以 realloc会在当前地址往下继续扩展，凑足size返回回来；当然，如果*ptr 开始的这个区段，没有一整块size大小的空间，那么就会去别的内存上面去寻找。直到找到之后，再返回那块空间的起始地址回来； 1.9.3 free （释放已分配的内存区域） 原则， 谁申请谁释放， （防止内存泄露）；如果不能做到在同一函数中做到谁申请谁释放 就在同一模块中做到这些； 123456789101112131415161718int *p;int num = 10;p = malloc(sizeof(int));if (p == NULL)&#123; exit(1);&#125;;*p = 10;printf(\"%d\\n\", *p); // 10// 测试地址printf(\"%p--&gt;%d\\n\", *p); // 0xa--&gt;0free(p); // 正确的做法是p = NULL; // 正确的做法是，一个指针free了之后，立即赋值 NULL// free 代表着 变量p对于那片 内存空间 没有了 控制权限；所以free之后要 p = NULL*p = 123; // 实际上这是个野指针，该块内存释放掉了，有可能被其他人用来声明变量了。这里重新赋值，相当于可能把别人的变量给覆盖了printf(\"%d\\n\", *p); // 123 // 测试地址printf(\"%p--&gt;%d\\n\", *p); // 0x7b--&gt;145574408","categories":[{"name":"language","slug":"language","permalink":"http://yoursite.com/categories/language/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"ts declaration files","slug":"ts-declaration-files","date":"2021-01-21T03:16:49.000Z","updated":"2021-02-09T10:28:11.416Z","comments":true,"path":"2021/01/21/ts-declaration-files/","link":"","permalink":"http://yoursite.com/2021/01/21/ts-declaration-files/","excerpt":"","text":"10. Declaration Files10. 1 Declaration Reference本节显示一些API的文档以及该API的示例用法，并说明如何编写相应的声明。 10.1.1 具有属性的对象12345// codelet result = myLib.makeGreeting(\"hello, world\");console.log(\"The computed greeting is:\" + result);let count = myLib.numberOfGreetings; 12345// 声明declare namespace myLib &#123; function makeGreeting(s: string): string, let numberOfGreetings: number;&#125; 10.1.2 Overloaded Functions1234567// code let x : Widget = getWidget(43);let arr: Widget[] = getWidget(\"all of them\");// 声明declare function getWidget(n: number): Widget;declare function getWidget(s: string): Widget[]; 10.1.3 Reusable Types (Interfaces)1234567891011121314// codegreet(&#123; greeting: \"hello world\", duration: 4000&#125;);// 声明interface GreetingSettings &#123; greeting: string; duration?: number; color?: string;&#125;declare function greet(setting: GreetingSettings): void; 10.1.4 Reusable Types (Type Aliases)12345678910111213// code function getGreeting() &#123; return \"howdy\";&#125;class MyGreeter extends Greeter &#123;&#125;greet(\"hello\");greet(getGreeting);greet(new MyGreeter());// 声明// 使用类型别名来简化类型：type GreetingLike = string | (()=&gt; string) | MyGreeter;declare function greet(g: GreetingLike): void; 10.1.5 组织类型1234567891011121314151617181920212223242526272829// codeconst g = new Greeter(\"Hello\");g.log(&#123; verbose: true &#125;);g.alert(&#123; modal: false, title: \"Current Greeting\" &#125;);// 声明// 使用命名空间去组织类型declare namespace GreetingLib &#123; interface LogOptions &#123; verbose?: boolean; &#125; interface AlertOptions &#123; modal: boolean; title?: string; color?: string; &#125;&#125; // 使用嵌套的命名空间来声明declare namespace GreetingLib.Options &#123; // Refer to via GreetingLib.Options.Log interface Log &#123; verbose?: boolean; &#125; interface Alert &#123; modal: boolean; title?: string; color?: string; &#125;&#125; 10.1.6 Classes1234567891011121314151617// codeconst myGreeter = new Greeter(\"hello, world\");myGreeter.greeting = \"howdy\";myGreeter.showGreeting();class SpecialGreeter extends Greeter &#123; constructor() &#123; super(\"Very special greetings\"); &#125;&#125;// 声明// 使用 declare class 来描述类或类对象。类可以具有属性和方法以及构造函数。declare class Greeter &#123; constructor(greeting: string); greeting: string; showGreeting(): void;&#125; 10.1.7 Global Variables1234// codeconsole.log(f00/2);// 声明declare var foo: number 10.1.8 Global Functions1234// codegreet(\"hello\");// 声明declare function greet(str: string):void; 10.2 Library Structures针对不同类型的库，编写对应类型的声明文件。你是通过cdn获取这些库还是通过npm获取；你是require引入还是import引入； 10.2.1 模块化的库几乎每个现代的Node.js库都属于模块家族。这些类型的库仅在带有模块加载器的JS环境中工作。例如，express仅在Node.js中有效，并且必须使用CommonJS require函数加载。 12345var fs = require(\"fs\");import * as fs from \"fs\";var someLib = require(\"someLib\");define(..., ['someLib'], function(someLib) &#123;&#125;); 从代码中识别模块库 Unconditional calls to require or define Declarations like import * as a from &#39;b&#39;; or export c; Assignments to exports or module.exports They will rarely have: Assignments to properties of window or global 10.2.1.1 Modules.d.ts 常见的Commonjs 模式 123456789101112131415const maxInterval = 12;function getArrayLength(arr) &#123; return arr.length;&#125;module.exports = &#123; getArrayLength, maxInterval,&#125;;// This can be described by the following .d.ts:export function getArrayLength(arr: any[]): number;export const maxInterval: 12; Es module 1234567export function getArrayLength(arr) &#123; return arr.length;&#125;// This would have the following .d.ts equivalent:export function getArrayLength(arr: any[]): number; Default Exports 12345// codemodule.exports = /hello( world)?/;// .d.tsdeclare const helloWorld: RegExp;export default helloWorld; CommonJS中的一种导出样式是导出函数。由于函数也是对象，因此可以在导出中添加额外的字段。 1234567891011function getArrayLength(arr) &#123; return arr.slice;&#125;getArrayLength.maxInterval = 12;module.exports = getArrayLength;// Which can be described with:export default function getArrayLength(arr: any[]): number;export const maxInterval: 12;// 需要在 tsconfig.json 中设置 esModuleInterop: true 如果没有在 tsconfig.json 中设置 esModuleInterop: true 123456declare function getArrayLength(arr: any[]): number;declare namespace getArrayLength &#123; declare const maxInterval: 12;&#125;// 使用 export= 语法export = getArrayLength; 模块中的类型 可能需要提供一种不存在的JavaScript代码类型 123456789101112131415161718192021222324252627// code function getArrayMetadata(arr) &#123; return &#123; length: getArrayLength(arr), firstObject: arr[0], &#125;;&#125;module.exports = &#123; getArrayMetadata,&#125;;// describedexport type ArrayMetadata = &#123; length: number; firstObject: any | undefined;&#125;export function getArrayMetadata(arr: any[]):ArrayMetadata;// 泛型优化版export type ArrayMetadata&lt;ArrType&gt; = &#123; length: number; firstObject: ArrType | undefined;&#125;;export function getArrayMetadata&lt;ArrType&gt;( arr: ArrType[]): ArrayMetadata&lt;ArrType&gt;; Namespaces in Module Code 试图描述JavaScript运行时的关联可能很棘手。如果类似ES模块的语法没有提供足够的工具来描述导出，则可以使用名称空间。 您可能有足够复杂的类型来描述，因此您选择在.d.ts中对它们进行命名空间： 123456789101112131415161718// 运行时可用的JavaScript类export class API &#123; constructor(baseURL: string); getInfo(opts: API.InfoRequest): API.InfoResponse;&#125;// This namespace is merged with the API class and allows for consumers, and this file// to have types which are nested away in their own sections.declare namespace API &#123; export interface InfoRequest &#123; id: string; &#125; export interface InfoResponse &#123; width: number; height: number; &#125;&#125; 您可以使用export as namespace声明模块将在UMD上下文中的全局范围内可用 1export as namespaces moduleName; Template 为了让您了解所有这些部分如何组合在一起，这里是制作新模块时的参考.d.ts。 1234567891011121314151617181920212223242526272829// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*如果此模块是在模块加载程序环境之外加载时公开全局变量“ myLib”的UMD模块，请在此处声明该全局变量。否则，删除此声明。 */export as namespace myLib;/*~ If this module exports functions, declare them like so. */export function myFunction(a: string): string;export function myOtherFunction(a: number): number;/*~ You can declare types that are available via importing the module */export interface SomeType &#123; name: string; length: number; extras?: string[];&#125;/*~ You can declare properties of the module using const, let, or var */export const myField: number; 库文件布局 123456myLib +---- index.js +---- foo.js +---- bar +---- index.js +---- baz.js 声明文件布局应为 123456@types&#x2F;myLib +---- index.d.ts +---- foo.d.ts +---- bar +---- index.d.ts +---- baz.d.ts 12345// thest could be imported asvar a = require(\"myLib\");var b = require(\"myLib/foo\");var c = require(\"myLib/bar\");var d = require(\"myLib/bar/baz\"); Testing your types If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you: Create a new folder in node_modules/@types/[libname] Create an index.d.ts in that folder, and copy the example in See where your usage of the module breaks, and start to fill out the index.d.ts When you’re happy, clone DefinitelyTyped/DefinitelyTyped and follow the instructions in the README. Otherwise Create a new file in the root of your source tree: [libname].d.ts Add declare module &quot;[libname]&quot; { } Add the template inside the braces of the declare module, and see where your usage breaks 10.2.1.2 module:function1234import greeter from \"super-greeter\";greeter(2);greeter(\"Hello world\"); 如果模块可以像一个函数一样被调用，需使用module-function 模版 要同时通过UMD和模块引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for function modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' */// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style:// import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import:// import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myFuncLib;/*~ This declaration specifies that the function *~ is the exported object from the file */export = Greeter;/*~ This example shows how to have multiple overloads for your function */declare function Greeter(name: string): Greeter.NamedReturnType;declare function Greeter(length: number): Greeter.LengthReturnType;/*~ If you want to expose types from your module as well, you can *~ place them in this block. Often you will want to describe the *~ shape of the return type of the function; that type should *~ be declared in here, as this example shows. *~ *~ Note that if you decide to include this namespace, the module can be *~ incorrectly imported as a namespace object, unless *~ --esModuleInterop is turned on: *~ import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS! */declare namespace Greeter &#123; export interface LengthReturnType &#123; width: number; height: number; &#125; export interface NamedReturnType &#123; firstName: string; lastName: string; &#125; /*~ If the module also has properties, declare them here. For example, *~ this declaration says that this code is legal: *~ import f = require('super-greeter'); *~ console.log(f.defaultName); */ export const defaultName: string; export let defaultLength: number;&#125; 10.2.1.2 module:class1234const Greeter = require(\"super-greeter\");const greeter = new Greeter();greeter.greet(); 如果导出的对象是一个类的话； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for class modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' */// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style:// import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import:// import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myClassLib' when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myClassLib;/*~ This declaration specifies that the class constructor function *~ is the exported object from the file */export = MyClass;/*~ Write your module's methods and properties in this class */declare class MyClass &#123; constructor(customGreeting?: string); greet: void; myMethod(opts: MyClass.MyClassMethodOptions): number;&#125;/*~ If you want to expose types from your module as well, you can *~ place them in this block. *~ *~ Note that if you decide to include this namespace, the module can be *~ incorrectly imported as a namespace object, unless *~ --esModuleInterop is turned on: *~ import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS! */declare namespace MyClass &#123; export interface MyClassMethodOptions &#123; width?: number; height?: number; &#125;&#125; 10.2.1.3 Module: pluginIf you have a module which when imported, makes changes to other modules use template 12const jest = require('jest');require(\"jest-matchers-files\"); when you want to work with JavaScript code which extends another library. 123456789import &#123; greeter &#125; from \"super-greeter\";// Normal Greeter APIgreeter(2);greeter(\"Hello world\");// Now we extend the object with a new function at runtimeimport \"hyper-super-greeter\";greeter.hyperGreet(); The definition for “super-greeter” 12345678/*~ This example shows how to have 多个重载 for your function */export interface GreeterFunction &#123; (name: string): void (time: number): void&#125;/*~ This example shows how to export 一个接口指定的function */export const greeter: GreeterFunction; We can extend the existing module like the following: 12345678910111213141516171819202122// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module plugin template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*~ On this line, import the module which this module adds to */import &#123; greeter &#125; from \"super-greeter\";/*~ Here, declare the same module as the one you imported above *~ then we expand the existing declaration of the greeter function */export module \"super-greeter\" &#123; export interface GreeterFunction &#123; /** Greets even better! */ hyperGreet(): void; &#125;&#125; 10.2.2 Global Libraries全局库是可以从全局范围访问的库（即，无需使用任何形式的导入）。许多库只是公开一个或多个全局变量供使用。例如jquery; 123$(() =&gt; &#123; console.log(\"hello\");&#125;) 12&lt;!--一般情况，全局库的使用方式 --&gt;&lt;script src=\"http://a.great.cdn.for/someLib.js\"&gt;&lt;/script&gt; 现在，最流行的可全局库 实际上是作为 UMD标准 编写的（请参见下文）。 UMD库文档很难与全局库文档区分开。在编写全局声明文件之前，请确保该库不是UMD。 从代码中识别Global Library 查看全局库的代码时，通常会看到： Top-level var statements or function declarations One or more assignments to window.someName Assumptions that DOM primitives like document or window exist You won’t see: Checks for, or usage of, module loaders like require or define CommonJS/Node.js-style imports of the form var fs = require(&quot;fs&quot;); Calls to define(...) Documentation describing how to require or import the library 10.2.2.1 Global.d.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ If this library is callable (e.g. can be invoked as myLib(3)), *~ include those call signatures here. *~ Otherwise, delete this section. */declare function myLib(a: string): string;declare function myLib(a: number): number;/*~ If you want the name of this library to be a valid type name, *~ you can do so here. *~ *~ For example, this allows us to write 'var x: myLib'; *~ Be sure this actually makes sense! If it doesn't, just *~ delete this declaration and add types inside the namespace below. */interface myLib &#123; name: string; length: number; extras?: string[];&#125;/*~ If your library has properties exposed on a global variable, *~ place them here. *~ You should also place types (interfaces and type alias) here. */declare namespace myLib &#123; //~ We can write 'myLib.timeout = 50;' let timeout: number; //~ We can access 'myLib.version', but not change it const version: string; //~ There's some class we can create via 'let c = new myLib.Cat(42)' //~ Or reference e.g. 'function f(c: myLib.Cat) &#123; ... &#125; class Cat &#123; constructor(n: number); //~ We can read 'c.age' from a 'Cat' instance readonly age: number; //~ We can invoke 'c.purr()' from a 'Cat' instance purr(): void; &#125; //~ We can declare a variable as //~ 'var s: myLib.CatSettings = &#123; weight: 5, name: \"Maru\" &#125;;' interface CatSettings &#123; weight: number; name: string; tailLength?: number; &#125; //~ We can write 'const v: myLib.VetID = 42;' //~ or 'const v: myLib.VetID = \"bob\";' type VetID = string | number; //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);' function checkCat(c: Cat, s?: VetID);&#125; 10.2.2.2 Global: Modifying Module导入全局变量的模块会在全局范围内更改现有值。例如，可能存在一个库，该库在导入时将新成员添加到String.prototype。由于存在运行时冲突的可能性，该模式有些危险，但是我们仍然可以为其编写声明文件。 识别全局修改模块 全局修改模块通常易于从其文档中识别，它们类似全局插件，但是需要require方法的调用 才能激活它们的副作用； 123456789101112// 'require' call that doesn't use its return valuevar unused = require(\"magic-string-time\");/* or */require(\"magic-string-time\");var x = \"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());var y = [1, 2, 3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort()); 123456789101112131415161718192021222324252627282930313233// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the global-modifying module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*~ Note: If your global-modifying module is callable or constructable, you'll *~ need to combine the patterns here with those in the module-class or module-function *~ template files */declare global &#123; /*~ Here, declare things that go in the global namespace, or augment *~ existing declarations in the global namespace */ interface String &#123; fancyFormat(opts: StringFormatOptions): string; &#125;&#125;/*~ If your module exports types or values, write them as usual */export interface StringFormatOptions &#123; fancinessLevel: number;&#125;/*~ For example, declaring a method on the module (in addition to its global side effects) */export function doSomething(): void;/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */export &#123;&#125;; 10.2.3 UMDUMD模块既可以用作模块（通过import），也可以用作全局模块（在没有模块加载器的环境中运行时）。这样编写了许多流行的库，例如Moment.js。 1234// nodejs 环境下import moment = require('moment');// 浏览器环境下console.log(mement.format()); umd模版 12345678910111213141516(function (root, factory) &#123; if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define([\"libName\"], factory); &#125; else if (typeof module === \"object\" &amp;&amp; module.exports) &#123; module.exports = factory(require(\"libName\")); &#125; else &#123; root.returnExports = factory(root.libName); &#125;&#125;(typeof self !== 'undefined' ? self : this, function (b) &#123; // Use b in some fashion. // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;)); UMD库的文档通常还会演示一个显示require的“在Node.js中使用”示例，以及一个使用script标记加载该脚本的“在浏览器中使用”示例。 10.2.4 Consuming Dependencies你的库可能具有集中依赖关系，下面会说明如何将它们导入声明文件； Dependencies on Global Libraries If your library depends on a global library, use a /// &lt;reference types=&quot;...&quot; /&gt; directive: 123/// &lt;reference types=\"someLib\" /&gt;function getThing(): someLib.thing; Dependencies on Modules If your library depends on a module, use an import statement: 123import * as moment from \"moment\";function getThing(): moment; Dependencies on UMD libraries From a Global Library If your global library depends on a UMD module, use a /// &lt;reference types directive: 123/// &lt;reference types=\"moment\" /&gt;function getThing(): moment; From a Module or UMD Library If your module or UMD library depends on a UMD library, use an import statement: 1import * as someLib from \"someLib\"; Do not use a /// &lt;reference directive 来声明对UMD库的依赖！ 10.2.5 Preventing Name Conflicts编写全局声明文件时，可以在全局范围内定义许多类型。强烈不建议这样做，因为当项目中有许多声明文件时，它可能导致无法解决的名称冲突。 库定义的任何全局变量只声明 namespaces 12345678declare namespace cats &#123; interface KittySettings &#123;&#125;&#125; // But not // at top-level interface CatsKittySettings&#123;&#125; This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users. 10.3 Do’s and Don’ts10.3.1 基本类型不要使用Number,String,Boolean, Symbol, or Object 等类型； 10.3.2 anyany类型你懂得，尽量别用。anyScript毫无意义； 10.3.3 Callback Types对于返回值被忽略的回调，别使用any, 使用void更好； 12345678/* WRONG */function fn(x: () =&gt; any) &#123; x();&#125;/* OK */function fn(x: () =&gt; void) &#123; x();&#125; 10.3.4 重载和回调函数不要编写仅在回调函数上有所不同的单独重载： 12345678910111213/* WRONG */declare function beforeAll(action: () =&gt; void, timeout?: number): void;declare function beforeAll( action: (done: DoneFn) =&gt; void, timeout?: number): void;// ok// Do write a single overload using the maximum arity:declare function beforeAll( action: (done: DoneFn) =&gt; void, timeout?: number): void; 原因：回调忽略参数始终是合法的，因此不需要较短的重载。首先提供一个较短的回调允许输入错误类型的函数，因为它们与第一个重载匹配。 10.3.5 function 重载不要在更具体的重载之前放置更一般的重载； 1234567891011121314151617/* WRONG */declare function fn(x: any): any;declare function fn(x: HTMLElement): number;declare function fn(x: HTMLDivElement): string;var myElem: HTMLDivElement;var x = fn(myElem); // x: any, wat?// 通过将更一般的签名放在更具体的签名之后来对重载进行排序/* OK */declare function fn(x: HTMLDivElement): string;declare function fn(x: HTMLElement): number;declare function fn(x: any): any;var myElem: HTMLDivElement;var x = fn(myElem); // x: string, :) 原因：TypeScript在解决函数调用时选择第一个匹配的重载。当较早的过载比较晚的过载“更普遍”时，较晚的过载实际上是隐藏的，无法调用。 10.3.6 Use Optional Parameters不要写一些仅在尾随参数上有所不同的重载 1234567891011/* WRONG */interface Example &#123; diff(one: string): number; diff(one: string, two: string): number; diff(one: string, two: string, three: boolean): number;&#125;/* OK */interface Example &#123; diff(one: string, two?: string, three?: boolean): number;&#125; 10.3.7 Union Types不要只在一个参数位置编写因类型而异的重载 1234567891011121314151617181920/* WRONG */interface Moment &#123; utcOffset(): number; utcOffset(b: number): Moment; utcOffset(b: string): Moment;&#125;/* OK */interface Moment &#123; utcOffset(): number; utcOffset(b: number | string): Moment;&#125;function fn(x: string): void;function fn(x: number): void;function fn(x: number | string) &#123; // When written with separate overloads, incorrectly an error // When written with union types, correctly OK return moment().utcOffset(x);&#125; 10.4 Deep Dive10.4.1 Namespaces类型可以存在于名称空间中。例如，如果我们有声明let x：A.B.C，则说类型C来自A.B命名空间。A， B 不一定必须是类型或者值 10.4.2 简单组合，一个名字多种含义给定名称A，我们最多可以找到A的三种不同含义：类型，值或名称空间。名称的解释方式取决于所使用的上下文。例如，在一个声明文件中 中 let m：A.A = A ;，首先将A用作namespaces，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！ 10.4.2.1 User Combinations123456789// foo.d.tsexport var SomeVar: &#123; a: SomeType &#125;;export interface SomeType &#123; count: number;&#125;// consumedimport * as foo from \"./foo\";let x: foo.SomeType = foo.SomeVar.a;console.log(x.count); 这种方法不错，但我们可能会认为 SomeType 和 SomeVar 紧密相关，因此您希望它们具有相同的名称。我们可以使用合并相同的名称Bar呈现这两个不同的对象； 123456789// foo.d.tsexport var Bar: &#123;a : Bar&#125;;export interface Bar &#123; count: number&#125;// consumedimport &#123; Bar &#125; from \"./foo\";let x: Bar = Bar.a;console.log(x.count); 我们在这里使用Bar作为类型和值。请注意，我们不必将Bar值声明为Bar类型，它们是独立的。 10.4.2.2 Advanced Combinations某些声明可以跨多个声明进行组合，比如 class C {} 和 interface C{} 可以共存，并且都给类型C贡献了属性。 只要不造成冲突，就是合法的，一般的经验法则是， 值始终会与同名的其他值发生冲突，除非将它们声明为namespaces,； s, types will conflict if they are declared with a type alias declaration (type s = string), and namespaces never conflict. Adding using an `interface 1234567891011121314151617181920212223interface Foo &#123; x: number;&#125;// ... elsewhere ...interface Foo &#123; y: number;&#125;let a: Foo = ...;console.log(a.x + a.y); // OK// this also works with classesclass Foo &#123; x: number;&#125;// ... elsewhere ...interface Foo &#123; y: number;&#125;let a: Foo = ...;console.log(a.x + a.y); // OK// Note that we cannot add to type aliases (type s = string;) using an interface. Adding using a namespace 可以使用namespace声明以任何不会造成冲突的方式添加新的类型，值和namespace。 123456// 给class添加一个静态成员class C &#123;&#125;namespace C &#123; export let x: number;&#125; let y = C.x; // OK 在此示例中，我们向C的静态侧（其构造函数）添加了一个值。这是因为我们添加了一个值，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。 We could also add a namespaced type to a class: 123456class C &#123;&#125;// ... elsewhere ...namespace C &#123; export interface D &#123;&#125;&#125;let y: C.D; // OK 在我们为其编写 namespace 声明之前，没有 namespace C。作为命名空间的C的含义与该类创建的C的值或类型的含义不冲突。 我们可以使用名称空间声明执行许多不同的合并; 12345678910111213namespace X &#123; export interface Y &#123;&#125; export class Z &#123;&#125;&#125;// ... elsewhere ...namespace X &#123; export var Y: number; export namespace Z &#123; export class C &#123;&#125; &#125;&#125;type X = string; In this example, the first block creates the following name meanings: A value X (because the namespace declaration contains a value, Z) A namespace X (because the namespace declaration contains a type, Y) A type Y in the X namespace A type Z in the X namespace (the instance shape of the class) A value Z that is a property of the X value (该class的构造函数) The second block creates the following name meanings: A value Y (of type number) that is a property of the X value A namespace Z A value Z that is a property of the X value A type C in the X.Z namespace A value C that is a property of the X.Z value A type X 10.5 Publish to npm10.5.1 两种发布方法 bundling with your npm package publishing to the @types organization on npm. 12345678/// &lt;reference path=\"...\" /&gt;// Don’t use /// &lt;reference path=\"...\" /&gt; in your declaration files./// &lt;reference path=\"../typescript/lib/typescriptServices.d.ts\" /&gt;// Do use /// &lt;reference types=\"...\" /&gt; instead./// &lt;reference types=\"typescript\" /&gt; 10.5.2 Packaging dependent declarationsIf your type definitions depend on another package: Don’t combine it with yours, keep each in their own file. Don’t copy the declarations in your package either. Do depend on the npm type declaration package if it doesn’t package its declaration files. 10.5.3 Publish to @typesPackages under the @types organization are published automatically from DefinitelyTyped using the types-publisher tool. To get your declarations published as an @types package, please submit a pull request to DefinitelyTyped. You can find more details in the contribution guidelines page. 10.6 Find and Install Declaration Files loadsh 1npm install @types/lodash 123456// 如果 npm install 了 类型声明import * as _ from \"lodash\";_.padStart(\"hi\", 20, \"\");// or if you’re not using modules, you can just use the global variable _._.padStart(\"Hello TypeScript!\", 20, \" \");","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts modules","slug":"ts-modules","date":"2021-01-20T11:42:30.000Z","updated":"2021-02-09T10:28:43.410Z","comments":true,"path":"2021/01/20/ts-modules/","link":"","permalink":"http://yoursite.com/2021/01/20/ts-modules/","excerpt":"","text":"6. Modules6.1 import/export模块是在自己的范围内执行的，而不是在全局范围内执行的；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用导出形式之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种导入形式将其导入。 模块是声明性的，模块之间的关系是根据文件级别的导入和导出指定的； 模块使用模块加载器相互导入， 在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。 6.1.1 export可以通过添加export关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。 123export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125; 重命名导出 1234567class ZipCodeValidator implements StringValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s);&#125;&#125;export &#123; ZipCodeValidator &#125;;export &#123; ZipCodeValidator as mainValidator &#125;; 重新导出不会将其导入本地，也不会引入局部变量。 12345678export class ParseIntBasedZipCodeValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; parseInt(s).toString() === s;&#125;&#125;// Export original validator but rename itexport &#123; ZipCodeValidator as RegExpBasedZipCodeValidator &#125; from \"./ZipCodeValidator\"; 导出所有 123456export * from \"./StringValidator\"; // exports 'StringValidator' interfaceexport * from \"./ZipCodeValidator\"; // exports 'ZipCodeValidator' class and 'numberRegexp' constant valueexport * from \"./ParseIntBasedZipCodeValidator\"; // exports the 'ParseIntBasedZipCodeValidator' class// and re-exports 'RegExpBasedZipCodeValidator' as alias// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'// module. 6.1.2 import12345678910// single exportimport &#123; ZipCodeValidator &#125; from \"./ZipCodeValidator\";// renamedimport &#123; ZipCodeValidator as ZCV &#125; from \"./ZipCodeValidator\";let myValidator = new ZCV();// 将整个模块导入单个变量，并使用它来访问模块导出import * as validator from \"./ZipCodeValidator\";let myValidator = new validator.ZipCodeValidator();// 某些模块会设置一些可由其他模块使用的全局状态。这些模块可能没有任何出口import \"./my-module.js\" 6.1.3 default exports 默认导出 ​ 每个模块可以选择导出默认导出。默认导出用关键字default标记；每个模块只能有一个默认导出。默认导出使用其他导入形式导入。 ​ 默认出口真的很方便。例如，像jQuery之类的库可能具有jQuery或$的默认导出，我们也可能以$或jQuery的名称导入 1234567// JQuery.d.tsdeclare let $:JQueryexport default $;// App.tsimport $ from \"jquery\";$(\"button\").html(\"xxx\") 6.1.4 Export all as x12export * as utilities from \"./utilities\";import &#123;utilities&#125; from './index'; 6.1.4 export = import = require()TypeScript supports export = to model the traditional CommonJS and AMD workflow. export =语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。 当使用export =导出模块时, 必须用 import module = require(&quot;module&quot;) 导入模块 1234567891011121314151617// z.tslet numberRegexp = /^[0-9]+$/;class ZipCodeValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s);&#125;&#125;export = ZipCodeValidator;// t.tsimport zip = require(\"./ZipCodeValidator\");// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validator = new zip(); 6.2 code generation for Modulestypescript 会依据不同的模块规则，生成不同的代码 123// SimpleModule.tsimport m = require(\"mod\");export let t = m.something + 1; AMD / RequireJS SimpleModule.js 123define([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) &#123;exports.t = mod_1.something + 1;&#125;); CommonJS / Node SimpleModule.js 12var mod_1 = require(\"./mod\");exports.t = mod_1.something + 1; UMD SimpleModule.js 1234567891011(function (factory) &#123;if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") &#123; var v = factory(require, exports); if (v !== undefined) module.exports = v;&#125; else if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define([\"require\", \"exports\", \"./mod\"], factory);&#125;&#125;)(function (require, exports) &#123;var mod_1 = require(\"./mod\");exports.t = mod_1.something + 1;&#125;); System SimpleModule.js 1234567891011121314System.register([\"./mod\"], function (exports_1) &#123;var mod_1;var t;return &#123; setters: [ function (mod_1_1) &#123; mod_1 = mod_1_1; &#125;, ], execute: function () &#123; exports_1(\"t\", (t = mod_1.something + 1)); &#125;,&#125;;&#125;); Native ECMAScript 2015 modules SimpleModule.js 12import &#123; something &#125; from \"./mod\";export var t = something + 1; 6.3 可选模块加载和其他高级加载方案为了保持类型安全，我们可以使用typeof关键字。当在类型位置中使用typeof关键字时，将产生值的类型，在这种情况下为模块的类型。 6.3.1 Dynamic Module Loading in Node.js1234567891011declare function require(moduleName: string): any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123;let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");let validator = new ZipCodeValidator();if (validator.isAcceptable(\"...\")) &#123; /* ... */&#125;&#125; 6.3.2 Sample: Dynamic Module Loading in require.js123456789101112131415declare function require(moduleNames: string[],onLoad: (...args: any[]) =&gt; void): void;import * as Zip from \"./ZipCodeValidator\";if (needZipValidation) &#123;require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) =&gt; &#123; let validator = new ZipCodeValidator.ZipCodeValidator(); if (validator.isAcceptable(\"...\")) &#123; /* ... */ &#125;&#125;);&#125; 6.3.3 Sample: Dynamic Module Loading in System.js123456789101112declare const System: any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123;System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) =&gt; &#123; var x = new ZipCodeValidator(); if (x.isAcceptable(\"...\")) &#123; /* ... */ &#125;&#125;);&#125; 6.4 使用其他js库为了描述非ts编写的库，我们需要声明该库公开的API；通常将这些声明定义在.d.ts文件中，就类似c/c++程序中的 .h文件； Ts程序在开发过程中，会不可避免的引用到第三方js库，但是无法使用Typescript诸如类型检查等特性功能，为了解决这个问题，需要将这些库的函数和方法去掉后只保留导出类型声明，而产生一个描述js库和模块信息的声明文件，通过引用这个声明文件，就可以借用TS的各种特性来使用库文件； 6.4.1 声明文件的存放方式 在tsconfig include 字段包含 的范围内编写.d.ts，都能被自动识别 在x.js 相同目录创建同名声明文件x.d.ts，这样也会被自动识别； node_modules/@types/ 下存放的各个第三方模块声明文件，自己编写的声明文件不要放这里； 作为npm模块发布时，声明文件可捆绑发布，需在package.json中指明“types”：”./types/index.d.ts” 6.4.1 无配置使用js在tsconfig.json中关闭”noImplicitAny”: false时，可直接在Ts中引用js的库，所有的引入都会被默认为any类型。此方法不推荐使用； 6.4.2 Ts中引入js123456789// hello.jsexport const hello = () =&gt; console.log('hello');// index.tsimport &#123;hello&#125; from './hello'// 无法找到模块'./hello'的声明文件// 这就告诉用户，需要为hello.js编写声明文件了；// hello.d.tsexport declare const hello: () =&gt; void 上面的例子稍微简单一些，下面写一个相对复杂点的demo tsconfig.json 123456789101112&#123; \"compilerOptions\": &#123; \"outDir\": \"./dist/\", \"noImplicitAny\": true, \"allowJs\": true, \"module\": \"commonjs\", \"target\": \"es5\", \"experimentalDecorators\": true &#125;, \"exclude\": [\"node_modules\"], \"include\": [\"./src/**/*\"]&#125; dir 12345-src -swap -index.js -index.d.ts -index.ts 1234567891011121314// swap/index.jsconst NAME = \"A\";const swap = (a, b) =&gt; &#123; let temp; temp = a; a = b; b = temp; return `I am $&#123;NAME&#125;`;&#125;;export default &#123; swap,&#125;; 123456// swap/index.d.tsdeclare namespace swap &#123; // ts 编译运行时的 swap命名空间, 增加命名空间放置被全局污染。 function swap&lt;T&gt;(a: T, b: T): void;&#125;export default swap; // 注意这里要导出，有export/import 语句的文件 才是模块 12345678// index.tsimport swap from \"./swap\";let a = \"3\", b = \"4\";console.log(swap.swap&lt;string&gt;(a, b));console.log(a, b); 6.4.3 declarevar和declare的区别 ​ var表示创建一个新变量，declare用来告诉ts编译器这个变量已经在别处被创建过了， 如果你用declare，什么都不会添加到生成的js中， 它只是对编译器一个简单的提示； ​ 举例说明，如果你引入的第三方js文件中有 var externalModule，你需要定义declare var externalModule 去提示ts编译器，externalModule这个变量已经被创建了； 1export declare class Action &#123;&#125; 这个class Action的具体实现应该在其他什么地方，可以在个 .js文件里面 ​ 6.4.4 Ts中导入.png .json等导入.png .json 等文件时，同样也需要去编写声明文件； 提供一种方式，可以创建一个声明文件 src/@types/definition.d.ts 1234567891011121314// definition.d.tsdeclare module '*.png' &#123;const value: stringexport = value&#125;// index.ts// 之后在TS中导入也不会有问题import avatar from './img/avatar.png'const avatar = require('./img/avatar.png') // 可能会提示 require 未定义，有两种方式： // 1. 自行声明：declare const require: any // 2. yarn add -D @types/node 6.4.5 第三方模块没有可用的声明文件有些模块没有对应的声明文件时，需要我们自己编写声明文件，以rc-form为例子，需要在src/@types/defintion.d.ts中添加声明代码 1234567// defintion.d.tsdeclare module \"rc-form\" &#123;// 再次简单进行类型声明export const createForm: any;export const createFormField: any;export const formShape: any;&#125; 6.4.6 webpack 别名 aliases1234567891011121314151617181920212223242526// webpack.config.jsconst config = &#123;aliases: &#123; // 公共的工具类、容器和组件 utils: path.resolve('../utils'),&#125;// &#125;// index.tsimport &#123;ua&#125; from 'utils/broswer'// cannot find module 'utils/browser'// 只需要在tsconfig.json 添加baseUrl 和 paths&#123;\"compilerOptions\": &#123; // ... // 添加配置 \"baseUrl\": \".\", \"paths\": &#123; \"utils/*\": [\"../utils/*\"], \"components/*\": [\"../components/*\"] &#125;&#125;,\"include\": [\"./src/*\", \"./src/**/*\"],\"exclude\": [\"node_modules\"]&#125; 6.4.7 类型Window上不存在属性“X”需要对window进行扩展，直接在src/@types/definition.d.ts中扩展 1234567// definition.d.tsinterface Window &#123; x: any&#125;// index.tsconsole.log(Window.x) // success 注意全局声明和局部声明 1234567891011121314151617181920212223// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'interface Window &#123; X: any&#125;// index.tsconsole.log(window.X); // fail: 类型“Window\"上不存在属性“X”// 解决思路// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'declare global &#123; interface Window &#123; X: any &#125;&#125;// index.tsconsole.log(window.X) // success // 原因在于当一个 .ts文件加入import/export 语句的时候，该文件会变为一个模块；因为这个模块中的声明也会变为局部声明； 因此需要加到global的域上 6.5 Ambient Modules在nodejs中，很多任务的完成都需要引入一个或多个模块，我们可以给每个模块在他们的根目录建立一个.d.ts文件用来声明类型，但合并这些声明到一个大的.d.ts文件往往更方便一些。使用module关键字和 引号名 。这些引号名的名称将在以后的导入中使用； 1234567891011121314151617181920// node.d.tsdeclare module \"url\" &#123;export interface Url &#123; protocol?: string; hostname?: string; pathname?: string;&#125;export function parse( urlStr: string, parseQueryString?, slashesDenoteHost?): Url;&#125;declare module \"path\" &#123;export function normalize(p: string): string;export function join(...paths: any[]): string;export var sep: string;&#125; Now we can /// &lt;reference&gt; node.d.ts and then load the modules using import url = require(&quot;url&quot;); or import * as URL from &quot;url&quot;. 123/// &lt;reference path=\"node.d.ts\"/&gt;import * as URL from \"url\";let myUrl = URL.parse('...') 6.5.1 不想为第三方js写声明If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly. 123456// declarations.d.tsdeclare module \"hot-new-module\";// All imports from shorthand module will have the any type;import x, &#123;y&#125; from \"hot-new-module\";x(y); 6.5.2 通配符一些模块加载器（例如SystemJS和AMD）允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。 12345678910111213141516// declareations.d.tsdeclare module \"*!text\" &#123;const content: string;export default content;&#125;// Some do it the other way around.declare module \"json!*\" &#123;const value: any;export default value;&#125;// Now you can import things that match \"*!text\" or \"json!*\".import fileContent from \"./xyz.txt!text\";import data from \"json!http://example.com/data.json\";console.log(data, fileContent); 6.5.3 UMD modules一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为UMD模块。可以通过导入或全局变量访问这些库。 123// math-lib.d.tsexport function isPreme(x: number):boolean;export as namespace mathLib; The library can then be used as an import within modules: 123import &#123; isPrime &#125; from \"math-lib\";isPrime(2);mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports) 1mathLib.isPrime(2); 6.7 Guidance for structuring modules6.7.1 Export as close to top-level as possible如果要导入大量内容，请使用名称空间导入模式 12345678// MyLargeModule.tsexport class Dog &#123; ... &#125;export class Cat &#123; ... &#125;export class Tree &#123; ... &#125;export class Flower &#123; ... &#125;// Consumer.tsimport * as myLargeModule from \"./MyLargeModule.ts\";let x = new myLargeModule.Dog(); 6.7.2 Re-export to extend通常，您将需要扩展模块上的功能。常见的JS模式是使用扩展来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样合并。推荐的解决方案是不要变更原始对象，而是导出提供新功能的新对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081export class Calculator &#123;private current = 0;private memory = 0;private operator: string;protected processDigit(digit: string, currentValue: number) &#123; // 只能做10以内的计算； if (digit &gt;= \"0\" &amp;&amp; digit &lt;= \"9\") &#123; return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0)); &#125;&#125;protected processOperator(operator: string) &#123; if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) &gt;= 0) &#123; return operator; &#125;&#125;protected evaluateOperator( operator: string, left: number, right: number): number &#123; switch (this.operator) &#123; case \"+\": return left + right; case \"-\": return left - right; case \"*\": return left * right; case \"/\": return left / right; &#125;&#125;private evaluate() &#123; if (this.operator) &#123; this.memory = this.evaluateOperator( this.operator, this.memory, this.current ); &#125; else &#123; this.memory = this.current; &#125; this.current = 0;&#125;public handleChar(char: string) &#123; if (char === \"=\") &#123; this.evaluate(); return; &#125; else &#123; let value = this.processDigit(char, this.current); if (value !== undefined) &#123; this.current = value; return; &#125; else &#123; let value = this.processOperator(char); if (value !== undefined) &#123; this.evaluate(); this.operator = value; return; &#125; &#125; &#125; throw new Error(`Unsupported input: '$&#123;char&#125;'`);&#125;public getResult() &#123; return this.memory;&#125;&#125;export function test(c: Calculator, input: string) &#123;for (let i = 0; i &lt; input.length; i++) &#123; c.handleChar(input[i]);&#125;console.log(`result of '$&#123;input&#125;' is '$&#123;c.getResult()&#125;'`);&#125; 1234// 使用import &#123;Calculator, test&#125; from './ProgrammerCalculator';let c = new Calculator(2);test(c, \"1+2*33/11=\"); 新需求： 要求计算超过9的值 这个时候不在原类上更改，而是在继承类上做新功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ProgrammerCalculator.tsimport &#123; Calculator &#125; from \"./Calculator\";class ProgrammerCalculator extends Calculator &#123;static digits = [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\",];constructor(public base: number) &#123; super(); const maxBase = ProgrammerCalculator.digits.length; if (base &lt;= 0 || base &gt; maxBase) &#123; throw new Error(`base has to be within 0 to $&#123;maxBase&#125; inclusive.`); &#125;&#125;protected processDigit(digit: string, currentValue: number) &#123; if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) &#123; return ( currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit) ); &#125;&#125;&#125;// Export the new extended calculator as Calculatorexport &#123; ProgrammerCalculator as Calculator &#125;;// Also, export the helper functionexport &#123; test &#125; from \"./Calculator\"; 12345// TestProgrammerCalculator.tsimport &#123; Calculator, test &#125; from \"./ProgrammerCalculator\";let c = new Calculator(2);test(c, \"001+010=\"); // prints 3 6.7.3 Do not use namespaces in modules当首次转向基于模块的组织时，一种普遍的趋势是将导出包装在命名空间的附加层中。模块具有自己的作用域，并且从模块外部仅可见导出的声明。考虑到这一点，名称空间在使用模块时几乎没有价值。 7. Namespaces在TypeScript 1.5中，模块命名法则已更改。 “Internal modules”现在是“namespaces”。为了与ECMAScript 2015的术语保持一致，“External modules”现在简称为“modules”（module X {} 等同于 namespaceX {}） 在声明内部模块时，在使用module关键字的任何地方，可以并且应该改用namespace关键字。 7.1 多个相似对象添加namespaces123456789101112131415161718192021222324252627282930313233343536373839namespace Validation &#123;export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125;const lettersRegexp = /^[A-Za-z]+$/;const numberRegexp = /^[0-9]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125;&#125;export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;&#125;// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123;for (let name in validators) &#123; console.log( `\"$&#123;s&#125;\" - $&#123; validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" &#125; $&#123;name&#125;` );&#125;&#125; 7.2 Splitting Across Files​ 随着应用程序的扩展，我们希望将代码拆分为多个文件，以使其易于维护; 7.2.1 Multi-file namespaces 我们将Validation名称空间拆分为多个文件。即使文件是分开的，它们每个都可以贡献相同的名称空间，并且可以像将它们全部定义在一个位置一样使用。由于文件之间存在依赖性，因此我们将添加参考标记，以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。 Validation.ts 12345namespace Validation &#123;export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125;&#125; LettersOnlyValidator.ts 123456789/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123;const lettersRegexp = /^[A-Za-z]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125;&#125;&#125; ZipCodeValidator.ts 123456789/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123;const numberRegexp = /^[0-9]+$/;export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;&#125; Test.ts 12345678910111213141516171819202122/// &lt;reference path=\"Validation.ts\" /&gt;/// &lt;reference path=\"LettersOnlyValidator.ts\" /&gt;/// &lt;reference path=\"ZipCodeValidator.ts\" /&gt;// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123;for (let name in validators) &#123; console.log( `\"$&#123;s&#125;\" - $&#123; validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" &#125; $&#123;name&#125;` );&#125;&#125; 一旦涉及到多个文件，需要确保所有已编译的代码都已加载，有两种方法可以做到这点 7.2.1.1 级联输出使用 –outFile，将所有输入文件编译为单个js输出文件 tsc --outFile sample.js Test.ts 7.2.1.2 自动排序输出编译器将根据文件中存在的参考标记自动排序输出文件。您还可以分别指定每个文件： tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts 7.2.1.3 单个编译12tsc test.tstes Validation.ts 7.3 Aliases12345678910namespace Shapes &#123;export namespace Polygons &#123; export class Triangle &#123;&#125; export class Square &#123;&#125;&#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 7.3.1 使用第三方JavaScript库为了描述不是用TypeScript编写的库的形状，我们需要声明该库公开的API。因为大多数JavaScript库仅公开一些顶级对象，所以namespaces是表示它们的好方法。 D3在名为d3的全局对象中定义其功能。由于此库是通过script标签加载的，因此可以使用命名空间来声明它的shape。 1234567891011121314151617181920declare namspace D3 &#123;export interface Selectors &#123; select: &#123; (selector: string): Selection; (element: EventTarget): Selection; &#125;;&#125;export interface Event &#123; x: number; y: number;&#125;export interface Base extends Selectors &#123; event: Event;&#125;&#125;declare var d3: D3.Base; 8. 三斜杠指令三斜杠指令是包含单个XML标签的单行注释。注释的内容用作编译器指令。 三斜杠指令仅在其包含文件的顶部有效。三斜杠指令只能在单行或多行注释之前，包括其他三斜杠指令。如果在声明或声明之后遇到它们，则将它们视为常规的单行注释，并且没有特殊含义。 /// &lt;reference path=&quot;./lib/index.d.ts&quot; /&gt;：表示对一个文件的依赖。 /// &lt;reference types=&quot;jye&quot; /&gt;：表示对一个库的依赖。 三斜线的path &amp; types，和es6的import语义相似，同时三斜线指令必须放在文件的最顶端。例如，当我们的声明文件过于庞大，一般都会采用三斜线指令，将我们的声明文件拆分成若干个，然后由一个入口文件引入。 8.1 文件之间的依赖声明12///&lt;reference path=\"...\"/&gt;///&lt;reference path=\"...\"/&gt; 是这个group中最常见的，它用作文件之间依赖关系的声明； 三斜杠指令指示编译器在编译过程中包括其他文件； 当使用 –out 或 –outFile时，它们还可以用作对输出进行排序的方法。预处理通过后，文件以与输入相同的顺序输出到目标文件位置。 8.2 input files 预处理编译器对输入文件进行预处理，以解析所有三斜杠引用指令。在此过程中，其他文件将添加到编译过程中。 该过程从一组根文件开始；这些是在命令行或tsconfig.json文件的“files”列表中指定的文件名。这些根文件将按照指定的顺序进行预处理。在将文件添加到列表之前，必须先处理其中的所有三斜杠引用及其目标。按照在文件中出现的顺序，深度优先地解析三斜杠引用 A triple-slash reference path is resolved relative to the containing file, if unrooted. 8.3 typestypes=&quot;...&quot; 与 path=&quot;...&quot; 类似，前者声明对包的依赖，后者声明对一个文件的依赖 这些程序包名称的解析过程与import语句中的模块名称解析过程相似。考虑三重斜杠引用类型指令的一种简单方法是将其作为声明包的导入。 在一个声明文件中包括 types=&quot;node&quot; 则该声明文件使用@types/node/index.d.ts中声明的名称，因此，此包需要与声明文件一起包含在编译中; 仅当您书写d.ts文件时，才使用这些指令； 对于编译期间生成的声明文件，编译器会自动添加types=&quot;...&quot;。当且仅当reslulting file使用 referenced package中 任何声明的时候，才会在生成的声明文件中添加 types=&quot;...&quot; ； 在 .ts 文件声明对 一个@types 包的依赖， 使用命令行 –types 或者 tsconfig.json中设置； 8.4 liblib=&quot;...&quot; 此指令允许文件显式包括现有的内置lib文件。 例如，在编译中的一个文件中添加/// &lt;reference lib =“ es2017.string” /&gt;等效于使用–lib es2017.string进行编译。 123/// &lt;reference lib=\"es2017.string\" /&gt;\"foo\".padStart(4); 9. Namespaces and Modules9.1 使用modules模块可以包含代码和声明 从es6开始，模块是语言的原生机制，新的项目，模块将是推荐的代码组织机制； 9.2 使用namespaces命名空间是TypeScript特定的组织代码的方式。 命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。与模块不同，它们可以跨越多个文件，并且可以使用–outFile进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都作为script标记包含在HTML页面中。 就像所有全局命名空间污染一样，很难识别组件依赖性，尤其是在大型应用程序中。 9.3 使用namespaces 和 modules 遇到的一些坑9.3.1 不需要namespaces的时候123456789101112// `shapes.ts`export namespace Shapes &#123;export class Triangle &#123; /* ... */&#125;export class Square &#123; /* ... */&#125;&#125;// `shapeConsumer.ts`import * as shapes from \"./shapes\";let t = new shapes.Shapes.Triangle(); // shapes.Shapes? 推荐的做法，当一个文件中定义了import/export 的时候，那么它就变成了一个模块。模块中，命名空间显然多此一举了 推荐做法 12345678910// shapes.tsexport class Triangle &#123;/* ... */&#125;export class Square &#123;/* ... */&#125;// shapeConsumer.tsimport * as shapes from \"./shapes\";let t = new shapes.Triangle(); 9.3.2 reference 和import 的使用时机一个常见的错误是尝试使用/// reference ...语法来引用模块文件，而不是使用import语句； 编译器如何 基于 path of an import path(import X from &#39;xxx&#39;; import x = require(&#39;...&#39;)) 找到模块的类型信息； 编译器将尝试查找.ts，.tsx，然后找到具有适当路径的.d.ts。如果找不到特定的文件，然编译器会去找ambient module declaration 记得这些需要在 .d.ts 文件中声明 12345678// myModules.d.ts// In a .d.ts file or .ts file that is not a module:declare module \"SomeModule\" &#123; export function fn(): string;&#125;// myOtherModule.ts/// &lt;reference path=\"myModules.d.ts\" /&gt; 记得添加依赖import * as m from \"SomeModule\"; // 这里并不是导入 文件名，而是模块名，因为 myModules.d.ts 不是一个模块； /// reference path=&quot;myModules.d.ts&quot; 使我们能够找到包含环境模块声明的声明文件，This is how the node.d.ts file that several of the TypeScript samples use is consumed.","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts generics","slug":"ts-generics","date":"2021-01-20T11:42:15.000Z","updated":"2021-02-09T10:28:30.509Z","comments":true,"path":"2021/01/20/ts-generics/","link":"","permalink":"http://yoursite.com/2021/01/20/ts-generics/","excerpt":"","text":"5. Generics泛型，创建可重用组件的工具。 1234function loggingIdentity&lt;T&gt;(arg: T) &#123; console.log(arg.length); // Property 'length' does not exist on type 'T'. return arg;&#125; 5.1 泛型定义1234567891011function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;let myIdentity1: &#123; &lt;T&gt;(arg: T): T &#125; = identity;let myIdentity2: GenericIdentityFn = identity; 5.2 泛型类12345678910class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y;&#125;; 5.3 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 5.3.1 Using Type Parameters in Generic Constraints123456789function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\");getProperty(x, \"m\");// Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'. 5.3.2 泛型类使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型； 123function create&lt;T&gt;(c: &#123; new (): T &#125;): T &#123; return new c();&#125; 使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系 1234567891011121314151617181920212223242526class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts doc","slug":"ts-doc","date":"2021-01-19T08:12:21.000Z","updated":"2021-02-09T10:28:20.873Z","comments":true,"path":"2021/01/19/ts-doc/","link":"","permalink":"http://yoursite.com/2021/01/19/ts-doc/","excerpt":"","text":"handbookA reader who completes the walkthrough should be able to: Read and understand commonly-used TypeScript syntax and patterns Explain the effects of important compiler options Correctly predict type system behavior in most cases Write a .d.ts declaration for a simple function, object, or class 1. basic Types 在TypeScript中，我们支持与JavaScript中期望的类型相同的类型，并添加了一个额外的枚举类型以帮助处理问题。 Boolean, Number, String, Array,Tuple,Enum,Unkown,Any,Void, Null and Undefined, Never, Object, Tuple 元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对字符串和一个数字： 123456// Declare a tuple typelet x: [string, number];// Initialize itx = [\"hello\", 10]; // OK// Initialize it incorrectlyx = [10, \"hello\"]; // Error Enum 枚举是JavaScript标准数据类型集的一个有用补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。 123456789enum Color &#123; Red = 1, Green, Blue,&#125;let colorName: string = Color[2];// Displays 'Green'console.log(colorName); Unknown 我们可能需要描述编写应用程序时不知道的变量类型。这些值可能来自动态内容，例如来自用户-或者我们可能要有意接受我们API中的所有值。在这些情况下，我们希望提供一种类型，该类型告诉编译器和将来的读者此变量可以是任何变量，因此我们将其赋予未知类型。 12345let notSure: unknown = 4;notSure = \"maybe a string instead\";// OK, definitely a booleannotSure = false; 如果您有一个类型未知的变量，则可以通过进行typeof检查，比较检查或更高级的类型防护来将其范围缩小到更具体的范围; 1234567891011121314151617181920declare const maybe: unknown;// 'maybe' could be a string, object, boolean, undefined, or other typesconst aNumber: number = maybe;//Type 'unknown' is not assignable to type 'number'.if (maybe === true) &#123; // TypeScript knows that maybe is a boolean now const aBoolean: boolean = maybe; // So, it cannot be a string const aString: string = maybe;//Type 'boolean' is not assignable to type 'string'.&#125;if (typeof maybe === \"string\") &#123; // TypeScript knows that maybe is a string const aString: string = maybe; // So, it cannot be a boolean const aBoolean: boolean = maybe;//Type 'string' is not assignable to type 'boolean'.&#125; Any 在某些情况下，并非所有类型信息都可用。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况，可能要选择退出类型检查。将这些值标记为any类型： 123declare function getValue(key: string): any;// OK, return value of 'getValue' is not checkedconst str: string = getValue(\"myString\"); 与 unknown 不同，any类型的变量使您可以访问任意属性，甚至是不存在的属性。这些属性包括函数，并且TypeScript不会检查它们的存在或类型 123456789let looselyTyped: any = 4;// OK, ifItExists might exist at runtimelooselyTyped.ifItExists();// OK, toFixed exists (but the compiler doesn't check)looselyTyped.toFixed();let strictlyTyped: unknown = 4;strictlyTyped.toFixed();// Object is of type 'unknown'. Void void有点像任何其他的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型： 123function warnUser(): void &#123; console.log(\"This is my warning message\");&#125; Null and Undefined 在TypeScript中，undefined和null实际上实际上分别将其类型命名为undefined和null。就像void一样，它们本身并不是非常有用： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Never The never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never. 1234567891011121314// Function returning never must not have a reachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must not have a reachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; Object object是代表非基本类型的类型，即不是数字，字符串，布尔值，bigint，symbol，null或undefined的任何类型。 123456789101112131415// With object type, APIs like Object.create can be better represented.declare function create(o: object | null): void;// OKcreate(&#123; prop: 0 &#125;);create(null);create(42);//Argument of type '42' is not assignable to parameter of type 'object | null'.create(\"string\");//Argument of type '\"string\"' is not assignable to parameter of type 'object | null'.create(false);//Argument of type 'false' is not assignable to parameter of type 'object | null'.create(undefined);//Argument of type 'undefined' is not assignable to parameter of type 'object | null'. Type assertions 类型断言是一种告诉编译器“相信我，我知道我在做什么”的方法。类型断言就像其他语言中的类型转换一样，但是它不执行数据的特殊检查或重构。它对运行时没有影响，仅由编译器使用。 TypeScript假定您（程序员）已经执行了所需的任何特殊检查。 类型断言的两种形式 123456// 类型1: as 语句let someValue: unknown = \"this is a string\";let strLength: number = (someValue as string).length;// 类型2: 尖括号let someValue: unknown = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; jsx中无法使用 类型2； About Number, String, Boolean, Symbol and Object 可能会认为数字，字符串，布尔值，符号或对象类型与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎永远不应将其用作类型。 2. interface2.1 readonly1234interface Point &#123; readonly x: number; readonly y: number;&#125; TypeScript具有与Array 相同的ReadonlyArray 类型，并且删除了所有变异方法，因此可以确保创建后不更改数组： 1234567891011let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!//Index signature in type 'readonly number[]' only permits reading.ro.push(5); // error!//Property 'push' does not exist on type 'readonly number[]'.ro.length = 100; // error!//Cannot assign to 'length' because it is a read-only property.a = ro; // error!//The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'. 在代码片段的最后一行，您可以看到，即使将整个ReadonlyArray分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它： 1234let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;a = ro as number[]; ReadOnly or const 记住是使用只读还是const的最简单方法是询问是否在变量或属性上使用它。变量使用const，而属性使用只读。 2.2 Optional1234interface SquareConfig &#123; color?: string; width?: number;&#125; 2.3 Excess Property Checks但是，TypeScript认为此代码中可能存在错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行过多的属性检查。如果对象文字具有“目标类型”所没有的任何属性，则会出现错误： 123456789101112131415interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; return &#123; color: config.color || \"red\", area: config.width ? config.width * config.width : 20, &#125;;&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;);//Argument of type '&#123; colour: string; width: number; &#125;' is not assignable to parameter of type 'SquareConfig'. // Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 解决方案 解决这些检查实际上非常简单。最简单的方法是只使用类型断言： 1const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125; as SquareConfig); 如果对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。 12345678910interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125;);// 只要您在squareOptions和SquareConfig之间具有一个公共属性，上述变通办法就会起作用。但是，如果变量没有任何公共对象属性，它将失败。let squareOptions = &#123; colour: \"red\" &#125;;let mySquare = createSquare(squareOptions);// Type '&#123; colour: string; &#125;' has no properties in common with type 'SquareConfig'. 2.4 Function Types为了描述带有接口的函数类型，我们给接口一个调用签名。这就像只声明参数列表和返回类型的函数声明。参数列表中的每个参数都需要名称和类型。 1234567891011121314151617181920212223242526interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function (source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125;;let mySearch2: SearchFunc;// 参数不定义string，ts会自动推断mySearch2 = function (src, sub): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125;;let mySearch: SearchFunc;mySearch = function (src, sub) &#123; // 返回值需要遵守interface//Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.// Type 'string' is not assignable to type 'boolean'. let result = src.search(sub); return \"string\";&#125;; 2.5 Indexable Types可索引类型具有索引签名，该签名描述了可用于索引对象的类型以及建立索引时对应的返回类型 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为在用数字索引时，JavaScript实际上会在将其索引到对象之前将其转换为字符串。这意味着使用100（一个数字）进行索引与使用“ 100”（一个字符串）进行索引是同一回事，因此两者必须保持一致。 1234567891011121314interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;// Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay &#123; [x: number]: Animal;Numeric index type 'Animal' is not assignable to string index type 'Dog'. [x: string]: Dog;&#125; 尽管字符串索引签名是描述“字典”模式的强大方法，但它们还强制所有属性与其返回类型匹配。这是因为字符串索引声明obj.property也可以作为obj [“ property”]使用。在以下示例中，名称的类型与字符串索引的类型不匹配，并且类型检查器给出错误： 123456interface NumberDictionary &#123; [index: string]: number; length: number; // ok, length is a number name: string; // error, the type of 'name' is not a subtype of the indexer// Property 'name' of type 'string' is not assignable to string index type 'number'.&#125; 但是，如果索引签名是属性类型的并集，则可以接受不同类型的属性： 12345interface NumberOrStringDictionary &#123; [index: string]: number | string; // 属性类型 length: number; // ok, length is a number name: string; // ok, name is a string&#125; 最后，您可以将索引签名设为只读，以防止分配给它们的索引： 1234567interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];myArray[2] = \"Mallory\"; // error!// Index signature in type 'ReadonlyStringArray' only permits reading. 2.6 Class Types2.6.1 Implement123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 这是因为当类实现接口时，仅检查该类的实例侧。由于构造函数位于静态端，因此它不包含在此检查中。 123456789101112interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; // Class 'Clock' incorrectly implements interface 'ClockConstructor'. // Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'. currentTime: Date; constructor(h: number, m: number) &#123;&#125;&#125;const clock = new Clock(1, 3); 需要直接使用类的静态方面。在此示例中，我们定义了两个接口，用于构造函数的ClockConstructor和用于实例方法的ClockInterface。然后，为方便起见，我们定义了一个构造函数createClock，该函数创建传递给它的类型的实例 1234567891011121314151617181920212223242526272829303132interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;function createClock( ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"tick tock\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 另一种简单的方法是使用类表达式： 1234567891011121314151617interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;;let clock = new Clock(12, 17);clock.tick(); 2.7 Extending Interfaces12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &#123;&#125; as Square;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 2.8 Hybrid Typesan object that acts as both a function and an object, with additional properties: 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = function (start: number) &#123;&#125; as Counter; counter.interval = 123; counter.reset = function () &#123;&#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 与第三方JavaScript交互时，您可能需要使用上述模式来完全描述类型的形状 2.9 Interfaces Extending ClassesWhen an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it. This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example: 12345678910111213141516171819202122class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;class ImageControl implements SelectableControl &#123;//Class 'ImageControl' incorrectly implements interface 'SelectableControl'. // Types have separate declarations of a private property 'state'. private state: any; select() &#123;&#125;&#125; ​ In the above example, SelectableControl contains all of the members of Control, including the private state property. Since state is a private member it is only possible for descendants of Control to implement SelectableControl. This is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible. ​ Within the Control class it is possible to access the state private member through an instance of SelectableControl. Effectively, a SelectableControl acts like a Control that is known to have a select method. The Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method). The ImageControl class has it’s own state private member rather than extending Control, so it cannot implement SelectableControl. 3. Functions在TypeScript中，尽管有类，名称空间和模块，但是函数仍然在描述操作方式中起着关键作用。 TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。 3.1 thisLearning how to use this in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use this and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of this with a couple of techniques. If you need to learn how this works in JavaScript, though, first read Yehuda Katz’s Understanding JavaScript Function Invocation and “this”. Yehuda’s article explains the inner workings of this very well, so we’ll just cover the basics here. this and arrow functions In JavaScript, this is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument. Let’s look at an example: 1234567891011121314151617let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; return function () &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Notice that createCardPicker is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the this being used in the function created by createCardPicker will be set to window instead of our deck object. That’s because we call cardPicker() on its own. A top-level non-method syntax call like this will use window for this. (Note: under strict mode, this will be undefined rather than window). We can fix this by making sure the function is bound to the correct this before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original deck object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the this where the function is created rather than where it is invoked: 123456789101112131415161718let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Even better, TypeScript will warn you when you make this mistake if you pass the --noImplicitThis flag to the compiler. It will point out that this in this.suits[pickedSuit] is of type any. this parameters Unfortunately, the type of this.suits[pickedSuit] is still any. That’s because this comes from the function expression inside the object literal. To fix this, you can provide an explicit this parameter. this parameters are fake parameters that come first in the parameter list of a function: 123function f(this: void) &#123; // make sure `this` is unusable in this standalone function&#125; Let’s add a couple of interfaces to our example above, Card and Deck, to make the types clearer and easier to reuse: 1234567891011121314151617181920212223242526272829interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function (this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Now TypeScript knows that createCardPicker expects to be called on a Deck object. That means that this is of type Deck now, not any, so --noImplicitThis will not cause any errors. this parameters in callbacks You can also run into errors with this in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, this will be undefined. With some work you can use this parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with this: 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this: 123456789101112131415class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used `this` here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error!//Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. //The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'.Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. // The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'. With this annotated, you make it explicit that onClickBad must be called on an instance of Handler. Then TypeScript will detect that addClickListener requires a function that has this: void. To fix the error, change the type of this: 12345678910class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use `this` here because it's of type void! console.log(\"clicked!\"); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); Because onClickGood specifies its this type as void, it is legal to pass to addClickListener. Of course, this also means that it can’t use this.info. If you want both then you’ll have to use an arrow function: 123456class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message; &#125;;&#125; This works because arrow functions use the outer this, so you can always pass them to something that expects this: void. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler. 3.2 OverloadsJavaScript本质上是一种非常动态的语言。一个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。 1234567891011121314151617181920212223242526272829let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123; suit: string; card: number &#125;[]): number;function pickCard(x: number): &#123; suit: string; card: number &#125;;function pickCard(x) &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [ &#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;,];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 4. Classes4.1 abstract abstract关键字用于定义抽象类以及抽象类中的抽象方法。 抽象类， 是可以从中派成出其他类的基类；简单说就是只能被继承，不能new出实例；与interface不同的是，抽象类中可以有成员实现的详细信息。 12345678910111213141516171819202122232425export abstract class App &#123; public setTargetProps&lt;T&gt; (target: T, source: Partial&lt;T&gt;): T &#123; try &#123; Object.keys(target).forEach((property: keyof T) =&gt; &#123; this.setTargetPropsByProperty(target, property, source[property]) &#125;) &#125; catch (error) &#123; throw new Error(error) &#125; return target &#125;&#125;const app = new App();// Cannot create an instance of an abstract class.class B extends App&#123;&#125;;// 非抽象类“ B”未实现从类“ App”继承的抽象成员“ make”class C extends App&#123; make()&#123;&#125; // 需要实现抽象类中定义的抽象方法&#125; 抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含abstract关键字，并且可以选择包括访问修饰符。 4.2 public,private, and protected4.2.1 类型兼容12345678910111213141516171819202122232425262728class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super(\"Rhino\"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal(\"Goat\");let rhino = new Rhino();let employee = new Employee(\"Bob\");animal = rhino;animal = employee; // Type 'Employee' is not assignable to type 'Animal'. 没有继承关系的类型无法做赋值操作；// Types have separate declarations of a private property 'name' 4.2.2 protectedprotected修饰符的行为与private修饰符非常相似，除了声明为protected的成员也可以在派生类中访问之外； 123456789101112131415161718192021222324252627class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; // 派生类中可以访问到 基类中的 protected 属性； return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());// 虽然我们不能从Person外部使用name，但仍可以在Employee的实例方法中使用它，因为Employee源自Person。console.log(howard.name);// Property 'name' is protected and only accessible within class 'Person' and its subclasses. 构造函数也可能被标记为受保护的。这意味着该类不能在其包含的类之外实例化，但是可以扩展。 123456789101112131415161718192021222324class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee can extend Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\");// Constructor of class 'Person' is protected and only accessible within the class declaration. 因为 new Person的时候是需要调 Person的构造函数，由于其构造函数添加了 protected关键字。实例是无法调类的构造函数的，所以就无法被实例化了； 4.2.3 Readonly12345678910111213class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(readonly theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\";// Cannot assign to 'name' because it is a read-only property.console.log(dad.name) 4.2.4 accessorsTypeScript支持getters / setter方法，以拦截对对象成员的访问。这使您可以更好地控制如何访问每个对象上的成员的方式。 12345678910class Employee &#123; fullName: string;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 在此版本中，我们添加了一个setter来检查newName的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是这样，我们会抛出错误通知客户端代码出了点问题。 123456789101112131415161718192021222324const fullNameMaxLength = 10;class Employee &#123; private _fullName: string = \"\"; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123; throw new Error(\"fullName has a max length of \" + fullNameMaxLength); &#125; this._fullName = newName; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 注意事项 首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。 其次，带有get和no set的访问器会自动推断为只读。当代码生成.d.ts文件时很有用，因为用户通过ide可以看到这些无法进行更改。 4.2.5 Static1234567891011121314151617class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123; let xDist = point.x - Grid.origin.x; let yDist = point.y - Grid.origin.y; return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123;&#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 4.2.6 Using a class as an interface12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;; 5. Decorators随着TypeScript和ES6中类的引入，现在存在某些情况，这些情况需要附加功能来支持 annotating or modifying classes and class members。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的第2阶段提议，可作为TypeScript的实验功能使用。 JavaScript引入class之后，我们需要在不同的类之间共享或者扩展一些方法或行为的时候，代码会变得很复杂，不够优雅，这也是装饰器被提出的一个很重要原因之一； 要为装饰器启用实验性支持，必须在命令行或tsconfig.json中启用experimentalDecorators编译器选项 1tsc --target ES5 --experimentalDecorators 1234567// tsconfig.json&#123; \"compilerOptions\": &#123; \"target\": \"ES5\", \"experimentalDecorators\": true &#125;&#125; 装饰器是一种特殊的声明，可以附加到类声明，方法，访问器，属性或参数上。装饰器使用@expression形式，其中expression求值之后必须也是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入； 5.1 class decorators12345678910111213141516171819function addAge(constructor: Function) &#123; constructor.prototype.age = 18;&#125;function addName(constructor: Function) &#123; constructor.prototype.name = \"leo\";&#125;@addAge@addNameclass Person &#123; name: string; age!: number;&#125;let person = new Person();console.log(person.age, person.name); // 18 ,'age' 12345678910111213141516171819202122232425262728293031323334353637// bundle.jsvar __decorate = function (decorators, target, key, desc) &#123; var c = arguments.length, r = c &lt; 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc; var d; if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.decorate === \"function\") &#123; r = Reflect.decorate(decorators, target, key, desc); &#125; else &#123; for (var i = decorators.length - 1; i &gt;= 0; i--) if ((d = decorators[i])) // 核心代码就是 d(r) r为构造函数Person r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; &#125; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;&#125;;function addAge(constructor) &#123; constructor.prototype.age = 18;&#125;function addName(constructor) &#123; constructor.prototype.name = \"leo\";&#125;var Person = /** @class */ (function () &#123; function Person() &#123;&#125; Person = __decorate([addAge, addName], Person); return Person;&#125;)();var person = new Person();console.log(person.age, person.name);export &#123;&#125;; 5.2 reflect-metadatainstall npm install reflect-metadata demo 1234567891011121314151617181920212223242526272829303132import \"reflect-metadata\";let target = &#123;&#125;;Reflect.defineMetadata(\"name\", \"alex\", target);Reflect.defineMetadata(\"name\", \"world\", target, \"hello\");console.log(Reflect.getOwnMetadata(\"name\", target)); // alexconsole.log(Reflect.getOwnMetadata(\"name\", target, \"hello\")); // worldfunction classMetadata(key: any, value: any) &#123; return function (target: any) &#123; Reflect.defineMetadata(key, value, target); &#125;;&#125;function methodMetadata(key: any, value: any) &#123; return function (target: any, propertyName: any) &#123; //Person.prototype.hello.name=world Reflect.defineMetadata(key, value, target, propertyName); &#125;;&#125;//给类本身增加元数据//@Reflect.metadata('name','Person')@classMetadata(\"name\", \"Person\")class Person &#123; //给类的原型增加元数据 //@Reflect.metadata('name', 'world') @methodMetadata(\"name\", \"world\") hello(): string &#123; return \"world\"; &#125;&#125;console.log(Reflect.getMetadata(\"name\", Person)); // Personconsole.log(Reflect.getMetadata(\"name\", new Person(), \"hello\")); // world","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"html5vedio","slug":"html5vedio","date":"2021-01-04T07:02:23.000Z","updated":"2021-02-09T10:27:48.301Z","comments":true,"path":"2021/01/04/html5vedio/","link":"","permalink":"http://yoursite.com/2021/01/04/html5vedio/","excerpt":"","text":"html5 播放器加速123const video = document.querySelector('video');video.playbackRate = 2 // 播放器播放速度","categories":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"}]},{"title":"browser-sync","slug":"browser-sync","date":"2020-12-21T06:07:39.000Z","updated":"2021-02-09T10:26:03.847Z","comments":true,"path":"2020/12/21/browser-sync/","link":"","permalink":"http://yoursite.com/2020/12/21/browser-sync/","excerpt":"","text":"全局安装1231312312312123sudo npm install -g browser-sync 快速使用1234# 启动服务器 监听所有的html文件$ browser-sync start --server --files \"*.html\"# 启动服务器 监听所有的文件$ browser-sync start --server --files \"**\" 启动browser-sync start --server --port 3333 --files &quot;*.css,*.html,*.js&quot; start options1234567891011121314151617181920212223242526272829--help #输出使用信息--version #输出的版本号--browser #选择哪个浏览器应该是自动打开--files #文件路径看--exclude #文件模式忽视--server #运行本地服务器（使用您的CWD作为Web根）--index #指定哪些文件应该被用作索引页--extensions #指定文件扩展名回退--startPath #指定起始路径，打开浏览器--https #启用S​​SL地方发展--directory #显示服务器的目录列表--proxy #代理现有的服务器--xip #使用xip.io域路由--tunnel #使用公共网址--open #选择哪个URL是自动打开（本地，外部或隧道）--config #指定为BS-config.js文件的路径--host #指定主机名使用--logLevel #设置记录器输出电平（沉默，信息或调试）--port #指定要使用的端口--reload-delay #以毫秒为单位的时间延迟重装事件以下文件的变化--reload-debounce #限制在浏览器中的频率：刷新事件可以被发射到连接的客户机--ui-port #指定端口的UI使用--no-notify #禁用浏览器的通知元素--no-open #不要打开一个新的浏览器窗口--no-online #强制离线使用--no-ui #不要启动用户界面--no-ghost-mode #禁用幽灵模式--no-inject-changes #刷新上的每个文件更改--no-reload-on-restart #不要自动重新加载在重新启动所有浏览器","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"gitlab3","slug":"gitlab3","date":"2020-12-17T07:30:43.000Z","updated":"2021-02-09T10:27:24.991Z","comments":true,"path":"2020/12/17/gitlab3/","link":"","permalink":"http://yoursite.com/2020/12/17/gitlab3/","excerpt":"","text":"gitlab 分支策略 考虑到gitlab一般在企业内部使用，一般不存在社区开发者，所以在管理上不会采用github的upstream/origin双仓库模式。gitlab下，开发者们面向一个仓库进行提交即可； 设置对分支的保护权限 顾名思义，分支的权限必不可少，它可以约束开发者们的提交行为和提交策略。避免失误操作将未测试过的代码强制提交到生产分支；developer可以不关心； issue与Milestones issue可以理解为一个最小原子的任务，多个任务组成一个 milestones；Milestones 可以理解为某个时间区间内的任务集；一个Milestones可包含多个issue； 当该Milestones中所有issue完成，则标志着此Milestones的结束； 创建issue和mr 创建一个issue 关联一个mr branch name branch name 会以issue的序号开始，然后抓取title中的英文和数字做连接。 可采用index-categroy-content-[username]-[time]的自定义方式，括号部分可选 category feature bugfix chore enhance content，一到三个词简述任务 username，任务认领人 time，创建分支的时间，一般 201217或者1225 source 基于什么分支创建当前分支，feature/chore/enhance选择dev-0.3, bugfix选择env-dev 提交代码流程 123456git fetch # 获取issue关联的分支名git checkout -b 6-feature-pivotDrill origin/6-feature-pivotDrill # 基于远端新建一个本地开发分支git rebase dev-0.3 # 在开发过程中，不定时rebase 宿主分支，防止版本隔断git push origin 6-feature-pivotDrill # 提交至远程映射# 通知maintainer完成代码合并，并关闭issue commits规范&#39;type(module) some desc&#39; 1234567891011121314151617181920212223242526type = [ \"build\", // 构建执行 \"chore\", // 构建工具相关 \"ci\", // CI 相关 \"docs\", // 文档更新 \"feat\", // 新功能 \"fix\", // bug 修复 \"perf\", // 性能优化 \"refactor\", // 功能重构 \"release\", \"revert\", // 回滚操作 \"style\", // 样式变动 \"test\", // 单元测试]moduele = [ // 以davinci为例,只列出前端模块 \"project\", \"dashboard\", \"display\", \"widget\", \"schdule\", \"view\", \"source\", \"user\"] review代码的参考标准 格式化后的代码，在vscode中安装prettier工具，设置ctrl+s默认对当前页进行prettier格式化； 所有commits必须要关联issue，如果没有issue要新建issue然后关联mr（merge request），基于当前mr提交代码； 原则上，不能有肉眼可见的bug，一般review代码时会进行简单的测试； 其他规则（代码规范） 代码规范 原则上，所有新提交的代码参考项目代码风格即可。简述为下面几个方面 原则上，变量名含义精准，（ps：严禁全局作用域中出现单字符命名空间；） 不要求一定要加注释或者不加注释，我们的愿景是能够书写无注释就能看懂的代码。根据业务逻辑难易程度，自行决定。 尽量英文注释； 不建议提交大量重复代码，须做好代码的抽象复用； 尽量使用被主流浏览器支持的的es规范书写代码，原则上新es规范下已有的工具类和函数，不重复造轮子； 其他涉及html/css/javascript相关的推荐规范会渐进式纳入规范集；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab2","slug":"gitlab2","date":"2020-12-16T10:41:24.000Z","updated":"2020-12-18T05:41:03.023Z","comments":true,"path":"2020/12/16/gitlab2/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab2/","excerpt":"","text":"label 标签组 标签组的意义就是定义一次，多个项目统一使用 Platform 前端还是后端，ios 还是 android angular node Problems 目前产品中存在的问题，以及该问题的优先级程度 bug： 常规bug security： 安全漏洞 production： 涉及到生产环境 Mindless 影响较小的任务，比如更改文件夹目录，适配规范 chore legal Experience 影响用户体验，或者用户对产品的理解. These can be both opportunities and “UX bugs”. copy design ux: User Experience Environment 服务器环境，开发环境，生产环境或者测试环境 staging test Feedback 待确认的问题，比如一些拍脑袋的需求；或者某个需求我们还没决定怎么实现 discussion question： 还没到需要讨论的情况 rfc Improvements 现有功能或基础架构上的迭代。 enhancement: 现有模块有更高的完成度 optimization: 现有功能代码层面的重构，或者交互流程上的梳理 Additions 新功能，新页面 feature Pending 现在不好说，未来肯定有结果，可能做成功， 可能做不成； in progress： 进行中的需求 watchlist： 先拖着的需求，有可能就拖掉了 Inactive 无需采取任何行动或可能采取任何行动。该问题已解决，可以通过其他问题更好地解决； invalid： 无效的 wontfix： 不会修复 duplicate： 重复 on hold： 等待候听","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab 使用","slug":"gitlab-使用","date":"2020-12-16T06:52:39.000Z","updated":"2020-12-18T05:43:13.922Z","comments":true,"path":"2020/12/16/gitlab-使用/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"软件开发阶段 软件开发十个阶段在gitlab中对应的管理方式方法 IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了Mattermost 它类似一个聊天工具。 ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在工单追踪器issue tracker中帮助你去提升这个点子。 PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用工单看板Issue Board。 CODE： 现在，当一切准备就绪，我们可以开始写代码了。 COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。 TEST： 通过GitLab CI，我们可以运行脚本来构建和测试我们的应用。 REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行代码复审code review以及批准。 STAGING：： 预发布环境。 PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了。 FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 Cycle Analytics来对当前项目中关键的部分进行的反馈 issue 和 milestone milestone里程碑，用来标识\b阶段性目标， 对目标进行细化，化整为零一个个的issues，然后根据每个issues的紧急程度选择性的完成。等所有issues解决完之后 就标志着阶段性目标已完成； 使用方法 把实际问题转化为issue，这些问题可以标记为正在解决和计划解决； milestone对应着阶段性项目计划，然后细分为多个issues，而且可以指定完成时间，gitlab会自动生成完成进度情况概略图。 issues也可以是一个建议，共给大家一起讨论； milestone 和issue建立时我们通常可以对问题进行简单描述，并且记录问题的解决过程，包括他人提出的疑问也可以在这里记录，后期可以随时查看； 创建milestone 可以在项目开始前创建milestone，后面建issues时关联它，也可以先建issues，后期由项目负责人建milestone，然后把所有issues关联过来； 创建一个名字 简单描述，简述创建的原因，这个里程碑最终的目的，编辑的时候可以直接贴图，也可以添加附件（支持markdown格式，可以预览） 指定计划的完成时间； 新建issues 一个issues表示一个功能、一个bug、一个建议; 新建议题很简单，标题+描述+计划时间+指定人+里程碑，里程碑一定要指定一下，还可以加标签。 功能：里程碑的细分，尽量小，方便merger时的代码审核； bug：解决程序中存在的某些问题； 建议：可以作为一个讨论交流区，也可以实现它; 一个issues 对应一个指定人，一个git 分支；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"nginx","slug":"test","date":"2020-12-09T14:19:03.750Z","updated":"2020-12-18T05:42:10.435Z","comments":true,"path":"2020/12/09/test/","link":"","permalink":"http://yoursite.com/2020/12/09/test/","excerpt":"","text":"配置hexo到阿里云 网上大多数教程问题不大，额外需要注意修改一些文件的写入权限 1234567# 将post-receive 设置为可执行文件chmod +x ~/hexo.git/hooks/post-receivecd ~# 设置博客源地址文件夹权限，不然git hooks写入不了，Unable to unlink 就是这种原因sudo chmod -R 777 /home/www/hexo","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo","slug":"hello-world","date":"2020-06-04T03:45:32.772Z","updated":"2020-12-18T05:41:36.853Z","comments":true,"path":"2020/06/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy test12345function helloworld() &#123; return 'hello world'&#125;console.log(helloworld); More info: Deployment","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"},{"name":"graphics","slug":"graphics","permalink":"http://yoursite.com/categories/graphics/"},{"name":"algebra","slug":"algebra","permalink":"http://yoursite.com/categories/algebra/"},{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"},{"name":"algo","slug":"algo","permalink":"http://yoursite.com/categories/algo/"},{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/categories/webgl/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/categories/canvas/"},{"name":"language","slug":"language","permalink":"http://yoursite.com/categories/language/"},{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"},{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"},{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}