{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-08-20T05:55:31.000Z","updated":"2020-08-20T07:19:22.806Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-20T05:58:38.000Z","updated":"2020-08-20T07:18:21.424Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"linux command","slug":"linux-command","date":"2021-03-30T13:11:41.000Z","updated":"2021-03-30T15:17:01.236Z","comments":true,"path":"2021/03/30/linux-command/","link":"","permalink":"http://yoursite.com/2021/03/30/linux-command/","excerpt":"","text":"1. 目录绝对路径： 从根目录开始，指定一个位置、文件 相对路径： 从当前进程工作目录位置开始，指定一个位置、文件 shell： 命令解析器，默认运行在终端当中的进程 bash： born again shell， Linux版的shell 1.1 Linux目录结构/ 跟目录，一般根目录下只存放目录； /home: 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下， 表示当前用户的家目录，edu表示用户edu的家目录 /bin: /usr/bin: 可执行的二进制文件的目录，如ls，tar，cat等 /boot： 放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器： /boot/grub /dev/： 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom/mnt /etc： 系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab, /etc/fstab, /etc/init.d, /etc/X11, /etc/sysconfig, /etc/xinetd.d /root 系统管理员root的家目录（宿主目录） /lib： /usr/lib: /usr/local/lib: 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /home/username 普通用户的家 /etc 配置文件目录 /sbin 管理命令目录 /usr 应用程序存放目录，/usr/bin： 存放应用程序， /usr/share： 存放共享函数库文件。/usr/local：存放软件升级包。/usr/share/doc：系统说明文件存放目录，/usr/share/man：程序说明文件存放目录。/usr/include： 存放头文件 /tmp: 一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下； 1.2 用户Linux是一款多用户多任务的分时复用操作系统 家目录：宿主目录。 ​ 每个用户不同，cd回车所到的目录。 普通用户切换至root用户 1su - root 2. 终端的使用 图形终端 命令行终端 远程终端 （SSH、VNC） // 工作中实际使用最多的， 通过互联网连接远程 切换至字符终端 1init 3 万能的帮助命令 为什么要学习帮助命令 man帮助 man是manual的缩写， 用法 man ls man 也是一条命令,分为9章，可以使用man命令获得man的帮助 man 7 man man [number] man 第几章 help帮助 shell（命令解释器） 自带的命令称为内部命令，其他的是外部命令 内部命令使用help帮助 help cd 外部命令使用help帮助 ls –help info帮助 info帮助比help更详细，作为help的补充 info ls 使用网络资源（搜索引擎和官方文档） Linux 的基本操作方式是命令行 海量的命令不适合“死记硬背” 分屏读取：more， less， cat， tac 3. 文件管理linux - 一切皆文件 文件查看 目录文件的创建与删除 通配符 文件操作 文本内容查看 pwd 显示当前的目录名称 cd 更改当前的操作目录 cd /path/to/… 绝对路径 cd ./path/to/… 相对路径 cd ../path/to/… 相对路径 ls 查看当前目录下的文件 1ls [选项，选项... ] 参数... 常用参数： -l 长格式显示文件 -a 显示隐藏文件 -r 逆序显示 -t 按照时间顺序显示 -R 递归显示 3.0 chmod修改用户访问权限chmod 修改文件权限有两种使用格式： 字母法和数字法 常用的是数字法 3.1 文件的增删创建 mkdir 创建文件 touch mkdir -p app/a/b/c 创建递归目录 ls -R 查看目录层级 *删除 * 1rm -r [文件名1] [文件名2] rm 删除文件无法恢复； *复制 * cp -r /root/a /tmp tmp在系统中是临时目录的意思 cp -v cp -p cp -a 移动 mv /file/a /file/b 改名 1mv &#x2F;file&#x2F;a &#x2F;tmp 通配符 * ： 表示该文件夹下所有文件 复制文本/粘贴文本 12ctrl+shift+cctrl+shift+v 复制文件夹 1cp -r dir1 dir2 看函数源码 123451. 光标停在函数名上，2. esc退出编辑模式；3. shift+k 可以直接跳转到 man 手册 3.2 文本查看cat 文本内容显示到终端 head 查看文件开头 tail 查看文件结尾 常用参数 -f 文件内容更新后，显示信息同步更新 wc 统计文件内容信息 3.3 重定向12&gt; 重定向到指定文件，文件不存在自动创建&gt;&gt; 将内容追加到指定文件，文件不存在自动创建，存在不覆盖 3.4 建立链接文件ln linux链接文件类似于Windows下的快捷方式 链接文件分为软链接和硬链接 软链接： ln 源文件 连接文件软链接不占用磁盘空间，源文件删除则软链接链接失效 (等同于windows下的快捷方式，建议使用 绝对路径创建软链接) 123$&gt; ls -s /home/xxx/file1 file.soft$&gt; lsfile.soft -&gt; /home/xxx/file1 硬链接： ln -s 源文件 链接文件硬链接只能链接普通文件，不能链接目录 如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的磁盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。 注意：如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径 3.5 管道left|right 管道的作用： 将管道符｜左边命令的输出传给后边的命令做为输入 123ps -aux | grep init# ps 列出所有进程# grep 过滤init进程 linux 备份压缩 最早的linux介质是磁带，使用的命令是 tar 可以打包后的磁带文件进行压缩缓存，压缩的命令是gzip 和 bzip2 经常使用的拓展名 .tar.gz .tar.bz2 .tgz 1tar cf &#x2F;tmp&#x2F;etc-backup.tar &#x2F;etc 4. 进程管理 运行中的程序程序正在运行的过程，管理程序什么时候启动，整个生命周期需要多少资源。内存资源， 运行时需要多少cpu资源，程序运行完之后把程序结束掉。还有进程之间的通讯。 进程终止的方式并不唯一，分为正常终止和异常终止 正常终止也分为main返回、调用exit等方式 异常终止分为调用abort、接受信号等 进程的概念与进程查看 查看命令 ps ps PID TTY TIME CMD 11931 pts/1 00:11.02 su PID: 进程ID，唯一标识符 CMD： 进程名称 TTY： 当前执行程序的终端 （pts/1 虚拟终端） TIME： 不具备参考价值的进程时间 pstree top 结论： ​ - 进程也是树形结构 ​ - 进程和权限有着密不可分的关系 进程的控制命令 进程的通信方式 - 信号 守护进程和系统日志 服务管理工具 systemctl SELinux简介 12345ps axj *# 查看精确到进程信息*ps axm *# 能查看精确到线程信息*ps ax -L *# 以linux的方式来查看进程和线程的关系* 查看机器 TCP， udp链接 1netstat -anu 1netstat -ant 使用本机的 提供的客户端 1nc ip port 打开一张图片 eog xy.png # 打开一张图片","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"net","slug":"net","date":"2021-03-28T15:27:34.000Z","updated":"2021-03-30T13:24:44.298Z","comments":true,"path":"2021/03/28/net/","link":"","permalink":"http://yoursite.com/2021/03/28/net/","excerpt":"","text":"网关 对于局域网来说，上网需要路由器，路由器可以被称为网关。 网关还能承载DNS服务器的作用。 1. OSI七层模型 **Open System Interconnection****适用于所有的网络 分工带来效能 将复杂的流程分解为几个功能相对单一的子进程 整个流程更加清晰，复杂问题简单化 更容易发现问题并针对性的解决问题 应用层(Application) 提供业务处理的，比如网络与用户应用软件之间的接口服务(HTTP) 表示层(Presentation) 内容是什么格式（英文还是中文，还是二进制等等）表示的，这一层提供格式化的表示和转换数据服务，如加密和压缩() 会话层(Session)保持会话， 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制() 传输层(Transimission) 提供建立、维护和取消传输连接功能，负责可靠地传输数据(TCP) 网络层(Network) 处理网络间路由，确保数据及时传送(路由器) 数据链路层(DataLink) 负责无错传输数据，确认帧、发错重传等(交换机) 物理层(Physics) 提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器) 解析： 拿张稿纸写封信 （应用层，表示层，会话层先合并为一层， 写信整体对应的是应用层，里面放的业务数据） 把信装到信封里面，写上收件人，收件人地址（地址分为两部分，第一部分，省市区地址和楼盘门牌号。第二部分是房间号） 然后给邮局，一般邮局不会只打包一封信，而是把一些相同目的地的信封打包成包裹，然后写上目标地址（这个打包的过程对应的是传输层） 邮局送信，先找到具体楼盘以及门牌号。邮局（寻址，这里对应的是网络层）知道目的地了，开始选择道路（铁路或者公路或者飞行）。 确定位置和运输方式之后，开始传输，到达目的地之后。把数据包给到收件人，收件人拆开数据包。拿到信（数据）（这个层是数据链路层和物理层负责，物理层负责实际的物理传输，就010101的传信号），万一途中把包裹丢失了怎么办，以及其他意外的处理，比如包裹的包装是否被拆过。都需要校验。（这个是数据链路层负责的事情 ） 1下层是为上层提供服务的 物理层 建立，维护，断开物理连接 数据最终还是需要物理层的硬件传输，这些硬件只能传输010101.这些01010 在网络中怎么去表示呢。不同的介质表现方式是不一样的。 高电频和低电频表示，5V 和 0V分别表示 1 和 0； 1.1 数据链路层 建立逻辑连接，进行硬件地址寻址·差错校验等功能。 比如两个网卡，这两张网卡如何建立连接，如何通信。通信过程中出问题了如何解决。发送过程中丢包要重新传。链路层依赖物理层，（下层是为上层提供服务的，上层会把数据传给下层，让下层帮忙提供服务） 1.2 网络层 进行逻辑地址寻址，实现不同网络之间的路径选择 从一个端到另一个端，肯定不止一条路。而是有无数条路。那要如何找到最快的路呢。这个是网络层负责的 1.3 传输层 定义传输数据的协议端口号，以及流控和差错校验（在不可靠的路线上做可靠的事情） 从一个端向另外一个端发送数据包的时候，如何做到中间丢包了，发送端能够感知到。一般操作方式是，当发送端发送包之后，开一个定时器。一般发送一个数据包，会有一个经验的时间。比如A到B之间传数据包要2秒，那么这个定时器2秒之后还没回来，我就默认这个包丢了。那就重新传一份。直到接受端返回正确的回馈。 1.4 应用层表示层会话层 应用层，表示层，会话层一般会打包到一层，就是实际的数据，比如发送的是文本，图片还是网页等这些东西。下层帮上层提供服务，上层给下层下发命令。下层帮忙处理。 1.5 分层模型 1.6 封装过程 数据在不同层的称谓 数据帧（Frame） 是一种信息单位，它的起点和目的点都是数据链路层 数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层 段（Segment）： 通常是指起始点和目的地都是传输层的信息单元 消息（message）： 是指起始点和目的地都在网络层以上（经常在应用层）的信息单元 不同的层解自己的封装的数据（段，数据包，数据帧等等） 2. TCP/IP参考模型TCP/IP是传输控制协议/网络互联协议的简称 早期的TCP/IP模型是一个四层结构，从下往上依次是网络接口层、互联网层、传输层和应用层 后来在使用过程中，借鉴OSI七层参考模型，将网络接口层划分为了物理层和数据链路层，形成五层结构 5层对应7层 应用层对应 （应用层，表示层和会话层） 传输层对应传输层 网络层对应网络层 数据链路层对应数据链路层 物理层对应物理层 2.1 协议的概念和作用 协议的目的为了让计算机能够通信，计算机需要定义通信规则，这些规则就是协议，信息双方都要理解，而且信息能够传输。 规则是多种，协议也有多种 协议就是数据封装格式+传输 的结合 2.2 常用协议TCP/IP协议被称为传输控制协议/互联网协议，又称网络通讯协议 是由网络层的IP协议和传输层的TCP协议组成，是一个很大的协议集合 物理层和数据链路层没有定义任何特定协议，支持所有的标准和专用的协议 层级 名称 含义 应用层 HTTP 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议 应用层 FTP 文件传输协议（英文：File Transfer Protocol，缩写：FTP）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式 应用层 TFTP (Trivial File Transfer Protocol,简单文件传输协议)是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议 应用层 SMTP 简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP) 是在Internet传输Email的事实标准 应用层 SNMP 简单网络管理协议（SNMP，Simple Network Management Protocol），由一组网络管理的标准组成，包含一个应用层协议（application layer protocol）、数据库模型（database schema）和一组资源对象,该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。 应用层 DNS 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。 TCP TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议 传输层 UDP UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 传输层 ICMP ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息 网络层 IGMP Internet 组管理协议称为IGMP协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间 网络层 IP 互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为IP地址（英语：IP Address），是分配给用户上网使用的网际协议（英语：Internet Protocol, IP）的设备的数字标签 网络层 ARP 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议 网络层 RARP 反向地址转换协议（RARP：Reverse Address Resolution Protocol） 反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址 以下具体讲5层协议3. 网络接口层网络接口层是TCP/IP模型的最底层，负责接收从上一层交来的数据报并将数据报通过底层的物理网络发送出去，比较常见的就是设备的驱动程序，此层没有特定的协议 网络接口层又分为物理层和数据链路层 3.1 物理层计算机在传递数据的时候传递的都是0和1的数字，而物理层关心的是用什么信号来表示0和1，是否可以双向通信，最初的连接如何建立以及完成连接如何终止,物理层是为数据传输提供可靠的环境 尽可能的屏蔽掉物理设备和传输媒介，使数据链路层不考虑这些差异，只考虑本层的协议和服务 为用户提供在一条物理传输媒体上提供传送和接收比特流的能力 需要解决物理连接、维护和释放的问题 3.1.1 数字信号的编码数字信号的编码：用何种物理信号来表示0和1 3.1.1.1 非归零编码 缺点就是连音没法处理，是多个1 还是一个1的问题；所以需要告诉多长时间是个间隔呢。不然没法判断是几个1 优点： 编/译码简单。 缺点： 内部不含时钟信号， 收/发端同步困难。 用途： 计算机内部， 或低速数据通信。 3.1.1.2 曼彻斯特编码 附加一个从低到高或者从高到低的频率 优点： 内部自含时钟， 收/发端同步容易。 抗干扰能力强。 缺点： 编/译码较复杂。 占用更多的信道带宽， 在同样的波特率的情况下， 要比非归零编码多占用一倍信道带宽。 用途： 802.3局域网（以太网）使用场景更多 3.2 数据链路层数据链路层是OSI参考模型中的第二层，介乎于物理层和网络层之间 数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层 如何将数据组合成数据块，在数据链路层中称这种数据块为帧frame，帧是数据链路层的传送单位 如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配 以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理 3.2.1 以太网以太网（Ethernet）是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容 以太网的标准拓扑结构为总线型拓扑 以太网仍然使用总线型拓扑和CSMA/CD（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术 以太网实现了网络上无线电系统多个节点发送信息的想法，每个节点必须获取电缆或者信道的才能传送信息 每一个节点有全球唯一的48位地址也就是制造商分配给网卡的MAC地址，以保证以太网上所有节点能互相鉴别 3.2.2 总线型拓扑（只用到了物理层和数据链路层） 网络总线，每个电脑都可以接受消息，发送消息。 总线型拓扑是采用单根传输作为共用的传输介质,将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上 使用总线型拓扑结构需解决的是确保端用户使用媒体发送数据时不能出现冲突。 总线型网络采用载波监听多路访问/冲突检测协议（CSMA/CD)作为控制策略 （CSMA/CD指的是，每个电脑得监听其他电脑的状态，大家不能同时往网络总线上发消息） 3.2.2.1 载波监听多路访问全称Carrier Sense Multiple Access (CSMA)，是一种允许多个设备在同一信道发送信号的协议，其中的设备监听其它设备是否忙碌，只有在线路空闲时才发送 在此种访问方式下，网络中的所有用户共享传输介质，信息通过广播传送到所有端口，网络中的工作站对接收到的信息进行确认，若是发给自己的便接收否则不理 从发送端情况看，当一个工作站有数据要发送时，他首先监听信道并检测网络上是否有其他的工作站正在发送DATA，如果检测到信道忙，工作站将继续WAIT若发现信道空闲，则开始发送数据，信息发送出去后，发送端还要继续对发送出去的信息进行确认，以了解接收端是否已经正确接收到数据，如果收到则发送结束，否则再次发送 核心思想 先听后讲 信道空闲则发送，信道忙则等待。 边听边讲 发送信号时不断检测信道是否碰撞。（发信号时即时检测） 碰撞即停 （因为网线是单向的，传输过程中发现别人也在往反方向发，那么赶紧停止发送） 退避重传 二进制指数退避重传 多次碰撞，放弃发送,最多16次 （下面这个计算退避等待时间的算法，1，2，4，8.。。64） 如果64秒还没发出去，那么就不发了。 3.2.2.2 冲突检测冲突检测即发送站点在发送数据时要边发送边监听信道，若监听到信道有干扰信号，则表示产生了冲突，于是就要停止发送数据，计算出退避等待时间，然后使用CSMA方法继续尝试发送 计算退避等待时间采用的是二进制指数退避算法 （发消息的时候，检测别的电脑是否也在发，如果有就等1秒，1秒后继续校验，如果阻塞继续等2秒，后面依次类推 等 2的次方倍） 3.2.2.3 总线拓扑的缺点 不安全，发送出去的包连接总线的所有电脑都能劫持到。本来不该他收的信息他也可以收。 3.2.2.4 交换机 后来出现了交换机，交换机是一个二层的设备，在物理链路层上工作。比如A电脑发送消息给B电脑，直接连接交换机即可。就不同通知同样连接交换机的C电脑 交换机和路由器的区别 首先交换机是一个数据链路层的设备，只是传输数据包。数据包里面肯定有原地址和目标地址（比如A电脑 -&gt; B电脑）这个地址就是 MAC地址。 路由处理ip地址，主要作用是网络层的寻址 3.2.3 MAC地址 在通信过程中是用内置在网卡内的地址来标识计算机身份的 每个网卡都有一个全球唯一的地址来标识自己，不会重复(保证局域网之内不重复就行了)。MAC地址48位的二进制组成，通常分为6段，用16进制表示 3.2.4 以太网帧格式 在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。 后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址 帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议) 以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏 字段 说明 前导符(Preamble) 由1和0交互构成(10101010…..)，共占7个字节，用于使PLS子层电路与收到的帧达成时钟同步 帧起始(Start-of-Frame Delimiter, SFD) 为10101011，共占1个字节，表示一个帧的开始。它和前导符共同使接收方能根据1、0交替来迅速实现比特同步，当检测到连续的两位1时，将后续信息交给MAC子层。通常来说，Pre和SFD这两个字段只用于提醒接收端新帧到达，并不计入MAC帧大小，也不算作是MAC帧头的组成部分 目的MAC(Destination Address, DA)/源MAC(Source Address, SA) 分别用于标识目的MAC地址和源MAC地址，两个字段各占6个字节。它们可以是单播地址也可以是广播地址。当地址的最高位为0时表示单播，最高位为1时为组播，全为1时为广播 长度(Length)/类型(Type) 这是一个二选一的字段，共占2个字节，对于不同的网络协议，它有不同的含义。但是，作为类型使用时，如上表所示，最小值也总是大于1536（十六进制0x600）；所以不会产生冲突。另外，在IEEE 802.3中，数据字段的长度为38~1500个字节 数据(Data) 该字段对于不同的以太网帧包含的内容不一，对于较老的以太网标准，它是网络层来的数据报；而较新的标准，则是一个LLC帧的全部内容 帧校验序列(FCS) 它是一个包含32位CRC校验值的字段，一共占4个字节。由发送端对MAC帧的DA字段到Data字段间（不包含前导符和帧起始）的二进制序列进行计算 3.2.5 ARP协议 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址(MAC地址)的一个TCP/IP协议 主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源 地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存 由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗 3.2.5.1 ARP协议报文 字段 说明 硬件类型 表示硬件地址的类型，值为1表示以太网地址 协议类型 表示要映射的协议地址类型。它的值为0x0800表示IP地址类型 硬件地址长度和协议长度 以字节为单位，对于以太网上的IP地址的ARP请求或应答来说，他们的值分别为6和4 操作类型 用来表示这个报文的类型，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4 发送端MAC地址 发送方设备的硬件地址 发送端IP地址 发送方设备的IP地址 目标MAC地址 接收方设备的硬件地址 目标IP地址 接收方设备的IP地址 3.2.5.2 ARP地址解析过程 主机A和B在同一个网段，主机A要向主机B发送信息 主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。 4. 互联网层(网络层)位于传输层和网络接口层之间,用于把数据从源主机经过若干个中间节点传送到目标主机,并向传输层提供最基础的数据传输服务,它要提供路由和选址的工作 4.1 选址交换机是靠MAC来寻址的，而因为MAC地址是无层次的,所以要靠IP地址来确认计算机的位置,这就是选址 4.2 路由 寻址 在能够选择的多条道路之间选择一条最短的路径就是路由的工作 4.3 IP在网络中，每台计算机都有一个唯一的地址，方便别人找到它，这个地址称为IP地址。 4.3.1 IP头部 字段 说明 版本 Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100 首部长部 报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节 优先级与服务类型 占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0 总长度 占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节 标识符 占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1 标志 分为3个字段，依次为保留位、不分片位和更多片位 标志 保留位：一般被置为0 标志 不分片位：表示该数据报是否被分片，如果被置为1，则不能对数据报进行分片，如果要对其进行分片处理，就应将其置为0 标志 更多片位：除了最后一个分片，其他每个组成数据报的片都要将该位置设置为1. 段偏移量 占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置 TTL(Time to Live生存时间) 该字段用于表示IP数据包的生命周期，可以防止一个数据包在网络中无限循环地发下去。TTL的意思是一个数据包在被丢弃之前在网络中的最大周转时间。该数据包经过的每一个路由器都会检查该字段中的值，当TTL的值为0时此数据包会被丢弃。TTL对应于一个数据包通过路由器的数目，一个数据包每经过一个路由器，TTL将减去1 协议号 占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等 首部校验和 检验和是16位的错误检测字段。目的主机和网络中的每个网关都要重新计算报头的校验和，一样表示没有改动过,计算方法是：对头部中每个16比特进行二进制反码求和 源IP地址 该字段用于表示数据包的源地址，指的是发送该数据包的设备的网络地址 目标IP地址 该字段用于表示数据包的目标的地址，指的是接收节点的网络地址 4.3.2 IP地址格式IP地址是一个网络编码，用来确定网络中的一个节点。 IP地址是由32位二进制(32bit)组成 4.3.3 IP地址组成网络部分(NETWORK), 网络部分表示不同的网络 主机部分(HOST) ，主机部分标示在一个网络中特定的主机 4.3.4 IP地址表示 4.3.5 IP地址的分类 IP地址的网络部分是由Internet地址分配机构来统一分配的，这样可以保证IP的唯一性。 ip地址中全为1的ip即255.255.255.255，它称为限制广播地址，如果将其作为数据包的目标地址可以理解为发送到所有网络的所有主机 ip地址中全为0的ip即0.0.0.0，它表示启动时的ip地址，其含义就是尚未未分配时的ip地址 127是用来进行本机测试的，除了127.255.255.255外，其它的127开头的地址都代表本机 ip地址有5种 A类：1.0.0.0~126.255.255.255 B类：128.0.0.0~191.255.255.255 C类：192.0.0.0~223.255.255.255 D类：224.0.0.0~239.255.255.255 （用于组播） E类：240.0.0.0~254.255.255.255 （用于科研） 其中127.0.0.0~127.255.255.255用于环回测试 A类网络，第一个字节是网络，另外三个字节是host地址， B类网络，网络有两个字节，另外两个字节是host地址 C类网络，网络有三个字节，另外1个字节是host地址 问题 如上图所示，保留地址中第二行 172.12.0.0/12描述为16个连续的B段， 192.168.0.0/16描述为256个连续的C段，如何理解 172.16.0.0~172.31.255.255, 因为B类网络的host只占最后两个字节，172.16～172.31 就代表了16个连续的B类网络可用 192.168.0.0~192.168.255.255，因为C类网络的host只占最后一个字节，所以从192.168.0 到 192.168.255， 就有256个连续的C类网络可用 服务器可以监听的端口从0到65535，理论上这台服务器的这个端口只要没被占用，你都可以给服务器绑定。如果是一些默认的服务，服务器绑的也是默认的端口，那么客户端是可以知道的。比如：80是给http服务，443是给htts服务，21是给ftp服务等，否则的话，就需要服务器开发者告诉客户端应该连接哪个端口。 192.168.0.1/27表示什么 （理解子网，网段 和子网掩码）首先 192.168.0.1 是个IP地址，更细一点的话，属于C类型的，后面的/27 则表示网络号的长度，也叫VLSM（Variable Length Subnet Mask，可变长子网掩码），192.168.0.1/27 属于CIDR（无类别域间路由，Classless Inter-Domain Routing）表述形式 1IP&#96; 地址是以点分割为四部分，每部分 &#96;8bit&#96; （位）也就是一个 &#96;byte&#96;（字节）。在C类地址中，网络号占 &#96;24bit&#96;，主机号占 &#96;8bit 网络号 主机号 11111111 11111111 11111111 00000000 1192.168.0.1&#x2F;27 说明网络号占了27bit， 27个1表示网络号， 后面5个0表示主机号 网络号 主机号 11111111 11111111 11111111 11100000 网络号向主机借了3bit,说明有2^3=8个子网，每个子网可用主机数为 2^5-2=30, 这里 -2 是因为头尾的网络地址（全0的部分）和广播地址（全1的部分）是不可用的。 11111111 11111111 11111111 11100000 11100000 转为十进制即 2**7+2**6+2**5 即224。所以子网掩码为255.255.255.224。 IP 地址 11000000 10101000 00000000 00000001 子网掩码 11111111 11111111 11111111 11100000 网络地址 11000000 10101000 00000000 00000000 广播地址 11000000 10101000 00000000 00011111 网络地址是IP地址192.168.0.1 和 子网掩码 255.255.255.224的二进制 做 与运算，结果为 192.168.0.0, 广播地址则是在 网络地址的基础上把主机号从右往左数5位置为1而得到 192.168.0.31。 有效的主机IP地址为 192.168.0.1 到 192.168.0.30。 结合上面计算出有8个子网，那么192.168.0.1则落在第一个可用子网内 192.168.0.1~192.168.0.30，子网分布如下 子网 IP 网段 可用主机 一 192.168.0.0 ~ 192.168.0.31 192.168.0.1 ~ 192.168.0.30 二 192.168.0.32 ~ 192.168.0.63 192.168.0.33 ~ 192.168.0.62 三 192.168.0.64 ~ 192.168.0.95 192.168.0.65 ~ 192.168.0.94 四 192.168.0.96 ~ 192.168.0.127 192.168.0.97 ~ 192.168.0.126 五 192.168.0.128 ~ 192.168.0.159 192.168.0.129 ~ 192.168.0.158 六 192.168.0.160 ~ 192.168.0.191 192.168.0.161 ~ 192.168.0.190 七 192.168.0.192 ~ 192.168.0.223 192.168.0.193 ~ 192.168.0.222 八 192.168.0.224 ~ 192.168.0.255 192.168.0.225 ~ 192.168.0.254 每个子网中全0网络地址和全1广播地址不能作为主机ip来使用（这里的全0和全1，指的是二进制的全0 全1） 4.3.6 公有地址和私有地址 从上面所示，ip地址共有2的32次方减2个，总共不到43亿个ip地址。，上面提到过全球的网卡300多亿张，所以必然没办法每张网卡都能对应一个ip地址。然后有一些ip出于某种原因，还被保留下来了。所以可以提供使用的ip很少很少。那为啥这么多年过去了，IP还没用完呢。原因就是 **子网** 的存在； 保留网段（私有IP） 一个常见的现象，我们所在的单位或者组织，普遍会使用诸如10.0.x.x 或者192.168.x.x这样的ip地址，这样的ip到底代表了什么？ 不同的组织使用同样的ip会不会导致冲突呢？ 背后的原因是，国际标准组织在IPV4 地址空间里面，专门划分出了一些网段，这些网段不会用做公网上的IP，而是仅仅保留作内部使用。这些地址称作保留网段； | 分类 | IP地址范围 | 私有IP地址范围 | 最大主机个数 || —– | ————————- | —————————– || A类IP | 1.0.0.0126.255.255.255 | 10.0.0.0 ~ 10.255.255.255 | 2**24-2 || B类IP | 128.0.0.0191.255.255.255 | 172.16.0.0 ~ 172.31.255.255 | 216-2 || C类IP | 192.0.0.0~223.255.255.255 | 192.168.0.0 ~ 192.168.255.255 | 28-2 | 1其他范围的IP均为公有IP地址 网段与子网掩码在网络IP划分的时候，需要区分两个概念 第一是网络（network）的概念，直观点说，它表示的是这组IP共用的部分，比如在192.168.1.1～192.168.1.255这个区间里，它们共同的部分是192.168.1.0 第二是主机（host）的概念，它表示的是这组IP不同的部分，上面的例子中1～255就是不同的那些部分，表示有255个可用的不同IP 例如IPv4 地址，192.0.2.12，我们可以说前面三个字节是子网， 即（192.0.2.12），最后一个字节是host，或者换个方式，我们能说host为8位，子网掩码为192.0.2.0/24 （即24个1，8个0 255.255.255.0） 网络地址位数由子网掩码决定，你可以将IP地址与子网掩码进行“位与”操作，就能得到网络的值。子网掩码一般看起来像是255.255.255.0（二进制为 11111111.11111111.11111111.00000000），这里需要强调的是，A，B，C三类地址都有自己默认的子网掩码，A类为255.0.0.0, B类为255.255.0.0, C类为255.255.255.0 比如你的ip地址是192.0.2.12， 使用这个子网掩码时，你的网络地址就会是192.0.2.12与255.255.255.0 所得到的值： 192.0.2.0, 192.0.2.0就是这个网络的值； 子网掩码能接受任意个位，而不单纯是上面讨论的8，16或24个比特而已，所以你可以有一个子网掩码255.255.255.252(二进制位 11111111.11111111.11111100),这个子网掩码能切出一个30个位的网络以及2个位的主机，这个网络最多有四台host，因为最后一个位有两个0，（11111111，11111110，11111101，11111100）四种情况。 子网掩码只有一个作用，就是将某个IP地址划分为网络地址和主机地址两个部分。 子网掩码的格式永远都是二进制格式：前面一连串1，后面一连串的0 不过一大串的数字会有点不好用，比如像255.192.0.0这样的子网掩码，无法直观看到多少个，多个0，后来发明了新的办法，只需要将一个斜线放在ip地址后面，接着用一个十进制的数组用以表示网络的位数，类似这样：192.0.2.12/30,这样就很容易知道有30个1，2个0， 所以主机个数为4； 4.3.7 子网掩码 为什么一个职场1000多人只靠着一个ip就能满足，靠的就是子网掩码 子网掩码(subnet mask)又叫子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位的掩码。 子网掩码不能单独存在，它必须结合IP地址一起使用。 子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 子网掩码也是32个二进制位 对应IP的网络部分用1表示 对应IP地址的主机部分用0表示 IP地址和子网掩码做逻辑与运算得到网络地址 0和任何数相与都是0 1和任何数相与都等于任何数本身 A B C 三类地址都有自己默认的子网掩码 A类 255.0.0.0 B类 255.255.0.0 C类 255.255.255.0 子网掩码可以自己设置也可以自动获取 子网的第一个ip 是 192.168.5.129 最后一台主机ip是 192.168.5.158 定向广播 192.168.5.159 下一个子网 192.168.5.160 判断两个ip地址在不在一个子网之内 IP地址和子网掩码的二进制 做与运算之后得到子网的二进制网络地址，判断两个网络地址在不在一个子网之内，把它们根子网掩码做与运算。如果与的结果是一致的，那说明在一个子网之内。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354*// 判断两个ip地址在不在一个子网之内*let ip1 = \"192.168.0.1\";let ip2 = \"192.168.0.4\";let mask = \"255.255.255.0\";function same(ip1, ip2, mask) &#123; let ip1s = ip1​ .split(\".\")​ .map((item) =&gt; (+item).toString(2).padStart(8, \"0\"))​ .join(\"\"); let ip2s = ip2​ .split(\".\")​ .map((item) =&gt; (+item).toString(2).padStart(8, \"0\"))​ .join(\"\"); let masks = mask​ .split(\".\")​ .map((item) =&gt; (+item).toString(2).padStart(8, \"0\"))​ .join(\"\"); return (​ (parseInt(ip1s, 2) &amp; parseInt(masks, 2)) ===​ (parseInt(ip2s, 2) &amp; parseInt(masks, 2)) );&#125;let result = same(ip1, ip2, mask);console.log(result); 子网掩码解决什么问题子网掩码所做的是将网络划分出子网，解决网段的问题。私有ip才是解决ip不够用的问题 子网掩码划分子网 一个实际的场景， 比如一个公司有两个部门，财务部和hr部，每个部分都有四台电脑，网络要部署到两个部门，但是两个部门需要独立的局域网。我们知道一个C类ip地址可以有254个主机地址。所以，需要通过子网掩码的方式来把一个ip地址拆分给连个部门使用。 比如ip为 10011111 11111111 11111111 11000000 子网掩码1 为 10011111 11111111 11111111 11100000 子网掩码2 为 10011111 11111111 11111111 11110000 子网掩码可以是多个 子网掩码将不在一个子网之内的网络调整到一个子网内，即往左边移位 比如 255.255.255.0 =&gt; 255.255.0.0 =&gt; 255.0.0.0 划分局域网需要物理划分的同时还要通过子网掩码划分吗？ 是的，首先把一些电脑划分到一个子网之内。它们需要在一个物理网络内。它们必须连上路由器，交换机等等。另外还得看子网掩码，看看ip地址在不在一个局域网之内。 5. 传输层 位于应用层和网络接口层之间 是面向连接的、可靠的的进程到进程通信的协议 TCP提供全双工服务，即数据可在同一时间双向传播 TCP将若干个字节构成一个分组，此分组称为报文段(Segment) 对可靠性要求高的上层协议，实现可靠性的保证,如果数据丢失、损坏的情况下如何保证可靠性,网络层只管传递数据，成功与否并不关心 5.1 传输层的功能提供了一种端到端的连接 5.2 协议分类TCP(Transimision Control Protocal) 传输控制协议 可靠的、面向连接的协议 传输效率低 UDP(User Datagram Protocal) 用户数据报协议 不可靠的、无连接的服务 传输效率高 5.3 TCP协议 将数据进行分段打包传输 对每个数据包编号控制顺序 运输中丢失、重发和丢弃处理 流量控制避免拥塞 5.3.1 TCP数据包封装5.3.1.1 格式 源端口号和目标端口号，计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 5.3.1.2 32位序列号 32位序列号 TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值 5.3.1.3 确认应答号 确认应答号 它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。 1,2,3,4 包到达目的地的时机不一样；当3先到。接收端并不会立即通知发送端已经收到3. 而是会等待一段时间之后，如果依然没有响应。则告知发送端，已经收到了3. 请把1，2重新发一下。因为已经收到了3.所以必然有1，2.等到最终1和2都到了。那再告知发送端，已经收到1，2，3 5.3.1.4 首部长度 首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。 5.3.1.5 控制位 控制位 TCP的连接、传输和断开都受这六个控制位的指挥 URG(urgent紧急位) 紧急信号 ACK（响应位） PSH(push急迫位) 缓存区将满，立刻传输速度 RST(reset重置位) 连接断了重新连接 SYN（sync同步）TCP基于链接的，想根对方建立链接，勇敢伸出一只手。发送SYN标识位 FIN（finish完成）发送端完成位，提出断开链接的一方把FIN置为1表示要断开连接 紧急指针：仅在 URG(urgent紧急) 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。 5.3.1.5.1 SYNSYN(synchronous建立联机) 同步序号位 TCP建立连接时要将这个值设为1 5.3.1.5.2 ACKACK(acknowledgement 确认)为1表示确认号 5.3.1.5.3 FINFIN发送端完成位，提出断开连接的一方把FIN置为1表示要断开连接 5.3.1.6 窗口值 窗口值 说明接收端可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。它是来在TCP传输中进行流量控制的 窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测（每隔一段时间，发送端主动发送一个问询，窗口大小有没有改变） 5.3.1.7 差错控制校验和用来做差错控制，TCP校验和的计算包括TCP首部、数据和其它填充字节。在发送TCP数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验 和一致说明数据是正确的，否则 将认为数据被破坏，接收端将丢弃该数据 5.3.2 握手和断开（三次握手，四次挥手） TCP是面向连接的协议，它在源点和终点之间建立虚拟连接，而不是物理连接 在数据通信之前，发送端与接收端要先建立连接，等数据发送结束后，双方再断开连接 TCP连接的每一方都是由一个IP地址和一个端口组成 5.3.2.1 tcp服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051*// tcp_server.js*var net = require(\"net\");var server = new net.Server();server.on(\"connection\", function (socket) &#123; console.log(\"connected\"); socket.on('data',function(data)&#123; console.log(data.toString()); socket.write(\"server:\"+data); &#125;) socket.on('end',function(data)&#123; console.log('end'); &#125;) socket.on('error',function(error)&#123; console.log(error); &#125;)&#125;);server.listen(8000);server.on(\"listening\", function () &#123; console.log(\"Created server on http://127.0.0.1:8000/\");&#125;)server.on(\"close\", function () &#123; console.log(\"server closed!\");&#125;)server.on(\"error\", function (err) &#123; console.log(err);&#125;) 12345678910111213141516171819202122232425262728293031323334*//tcp_client.js*var net = require(\"net\");var socket = net.Socket();socket.connect(8000, '127.0.0.1', function () &#123; console.log(\"connect the server\"); socket.write(\"hello\");&#125;)socket.on(\"data\", function (data) &#123; console.log(data.toString()); socket.destroy();&#125;)socket.on(\"error\", function (err) &#123; console.log(err);&#125;)socket.on(\"end\", function () &#123; console.log(\"data end\");&#125;) 5.3.2.1 三次握手 第一次握手主机A通过一个标识为SYN标识位的数据段发送给主机B请求连接，通过该数据段告诉主机B希望建立连接，需要B应答，并告诉主机B传输的起始序列号 第二次握手是主机B用一个确认应答ACK和同步序列号SYNC标志位的数据段来响应主机A，一是发送ACK告诉主机A收到了数据段，二是通知主机A从哪个序列号做标记。 第三次握手是主机A确认收到了主机B的数据段并可以开始传输实际数据。 SYN_SENT(connect()) 握手请求 SYN seq=x (x为一个32位的随机数) LISTEN(listen()) SYN_RCVD 发送 SYN seq=y, ACK = x+1 (此时客户端宣布 established) 客户端发送 ACK=y+1 (此时服务端感知 established) sep的作用是给数据包标住序号，用于后面确认，重传等。seq是一个2**32的数字seq如果越界，会重置为0. 5.3.2.2 收发数据 5.3.2.3 四次断开 主机A发送FIN控制位发出断开连接的请求 主机B进行响应，确认收到断开连接请求 主机B提出反方向的关闭要求 主机A确认收到的主机B的关闭连接请求 为什么挥手会有四次，在客户端发送断开链接指令的时候， 服务端发送了一次 ACK 和一次ACK/FIN指令。为何这两次指令不能合并在一起呢？ 因为收到关闭请求和真正关闭只有一段时间差的，这段时间差当中可能还有传输的数据包。所以服务端没办法第一时间返回finsh。只有等数据包情况处理好之后，才能返回finsh请求； 5.3.3 滑动窗口 滑动窗口（Sliding window）是一种流量控制技术 早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题 TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据 当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小 发送方和接收方各维护一个窗口长度，接收方会把窗口大小发给发送方。发送方设置一个小于或者等于接收窗口大小的值。 窗口大小 = 缓存区大小 - 缓存字节数 5.3.3.1 窗口机制 滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口 发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同 不同的滑动窗口协议窗口大小一般不同 发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧 5.3.3.2 拥塞控制 TCP拥塞控制是传输控制协议（英语：Transmission Control Protocol，缩写TCP）避免网络拥塞的算法，是互联网上主要的一个拥塞控制措施 TCP使用多种拥塞控制策略来避免雪崩式拥塞。TCP会为每条连接维护一个“拥塞窗口”来限制可能在端对端间传输的未确认分组总数量 这类似TCP流量控制机制中使用的滑动窗口，是由发送方控制的 TCP在一个连接初始化或超时后使用一种“慢启动”机制来增加拥塞窗口的大小。它的起始值一般为最大分段大小（Maximum segment size，MSS）的两倍，虽然名为“慢启动”，初始值也相当低，但其增长极快：当每个分段得到确认时，拥塞窗口会增加一个MSS，使得在每次往返时间（round-trip time，RTT）内拥塞窗口能高效地双倍增长 在流量控制中，接收方通过TCP的“窗口”值（Window Size）来告知发送方，由发送方通过对拥塞窗口和接收窗口的大小比较，来确定任何时刻内需要传输的数据量 和式增加，积式减少（additive-increase/multiplicative-decrease，AIMD，这里简称“线增积减”）是一种反馈控制算法，其包含了对拥塞窗口线性增加，和当发生拥塞时对窗口积式减少。多个使用AIMD控制的TCP流最终会收敛到对线路的等量竞争使用。 未确认的数据包刚好等于带宽等于延迟 当发现丢包的时候立刻减半 5.4 UDP UDP是一个无连接、不保证可靠性的传输层协议，也就是说发送端不关心发送的数据是否到达目标主机、数据是否出错等，收到数据的主机也不会告诉 发送方是否收到了数据，它的可靠性由上层协议来保障 首部结构简单，在数据传输时能实现最小的开销，如果进程想发送很短的报文而对可靠性要求不高可以使用 没有握手，也没有挥手 5.4.1 UDP的封装格式5.4.1.1 数据包 5.4.1.2 数据长度 5.4.1.3 差错控制 5.4.2 UDP的应用 QQ 视频软件 TFTP 简单文件传输协议(短信) 5.4.3 UDP服务器5.4.3.1 点对点123456789101112131415161718*// udp_server.js*var dgram = require('dgram');var socket = dgram.createSocket('udp4');socket.on('message',function(msg,rinfo)&#123; console.log(msg.toString()); console.log(rinfo); socket.send(msg,0,msg.length,rinfo.port,rinfo.address);&#125;);socket.bind(41234,'localhost'); 1234567891011121314151617181920212223242526*// udp_client.js*var dgram = require('dgram');var socket = dgram.createSocket('udp4');socket.on('message',function(msg,rinfo)&#123; console.log(msg.toString()); console.log(rinfo);&#125;);socket.send(new Buffer('helloworld'),0,5,41234,'localhost',function(err,bytes)&#123; console.log('发送了个%d字节',bytes);&#125;);socket.on('error',function(err)&#123; console.error(err);&#125;); 5.4.3.2 广播 创建一个UDP服务器并通过该服务器进行数据的广播 123456789101112131415161718*// udp_server.js*let dgram = require('dgram');let server = dgram.createSocket('udp4);server.on('message',function(msg)&#123;let buf = new Bufffer('已经接收客户端发送的数据'+msg);server.setBroadcast(true);server.send(buf,0,buf.length,41235,\"192.168.1.255\");&#125;);server.bind(41234,'192.168.1.100'); 123456789101112131415161718*//udp_client.js*let dgram = require('dgram');let client = dgram.createSocket('udp4);client.bind(41235,'192.168.1.102);let buf = new Buffer('hello');client.send(buf,0,buf.length,41234,'192.168.1.100');client.on('message',function(msg,rinfo)&#123;console.log('received : ',msg);&#125;); 5.4.3.3 组播 所谓的组播，就是将网络中同一业务类型进行逻辑上的分组，从某个socket端口上发送的数据只能被该组中的其他主机所接收，不被组外的任何主机接收。 实现组播时，并不直接把数据发送给目标地址，而是将数据发送到组播主机，操作系统将把该数据组播给组内的其他所有成员。 在网络中，使用D类地址作为组播地址。范围是指 224.0.0.0 ~ 239.255.255.255,分为三类 局部组播地址: 224.0.0.0 ~ 224.0.0.255 为路由协议和其他用途保留 预留组播地址: 224.0.1.0 ~ 238.255.255.255 可用于全球范围或网络协议 管理权限组播地址 ： 239.0.0.0 ～ 239.255.255.255 组织内部使用，不可用于Internet 1234567891011121314151617181920212223242526*//udp_server.js*let dgram = require('dgram');let server = dgram.createSocket('udp4');server.on('listening',function()&#123;server.MulticastTTL(128);server.setMulticastLoopback(true);server.addMembership('230.185.192.108');&#125;);setInterval(broadcast,1000);function broadcast()&#123;let buffer = Buffer.from(new Date().toLocaleString());server.send(buffer,0,buffer.length,8080,\"230.185.192.108\");&#125; 1234567891011121314151617181920*//udp_client.js*let dgram = require('dgram');let client = dgram.createSocket('udp4');client.on('listening',function()&#123;client.addMembership('230.185.192.108');&#125;);client.on('message',function(message,remote)&#123;console.log(message.toString());&#125;);client.bind(8080,'192.168.1.103'); 5.4.3 DNS服务器3.4.3.1 域名 域名空间结构 根域 顶级域 组织域 国家/地区域名 二级域名 3.4.3.2 DNS服务器 DNS是Domain Name Service的缩写，DNS服务器进行域名和与之对应的IP地址转换的服务器 IP地址不易记忆 早期使用Hosts文件解析域名 主要名称重复 主机维护困难 DNS(Domain Name System 域名系统) 分布式 层次性 3.4.3.3 查找过程 客户端向本地域名服务器发出请求，我要访问www.163.com，请告诉我它的IP地址 本地DNS服务器向DNS根服务器发出请求，根DNS服务器会告诉本地服务器(.com)的服务器地址 本地DNS服务器会向(.com域)发请求，会得到(163.com)的服务器地址 本地DNS服务器会向(163.com)发请求,会得到(www.163.com)的IP地址1.1.1.1 本地DNS服务器向客户端回复域名(www.163.com)对应的IP地址是1.1.1.1 5.4.4 DHCP服务器（Dynamic Host Configuration Protocol） 保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。 DHCP应当可以给用户分配永久固定的IP地址。 DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机） DHCP服务器应当向现有的BOOTP客户端提供服务。 5.4.4.1 工作流程 主机发送DHCPDISCOVER广播包在网络上寻找DHCP服务器； DHCP服务器向主机发送DHCPOFFER单播数据包，包含IP地址、MAC地址、域名信息以及地址租期； 主机发送DHCPREQUEST广播包，正式向服务器请求分配已提供的IP地址； DHCP服务器向主机发送DHCPACK单播包，确认主机的请求 5.4.4.2 抓包 6. 应用层6.1 协议 6.2 应用层常见协议 HTTP 超文件传输协议 FTP 文件传输协议 SMTP(发送邮件)和POP3(接收邮件) 6.3 案例数据-&gt;传输层(包)-&gt;网络层(段Segment)-&gt;数据链路层(帧) 6.3.1 发送方是从高层到低层封装数据 在应用层要把各式各样的数据如字母、数字、汉字、图片等转换成二进制 在TCP传输层中，上层的数据被分割成小的数据段，并为每个分段后的数据封装TCP报文头部 在TCP头部有一个关键的字段信息端口号，它用于标识上层的协议或应用程序，确保上层数据的正常通信 计算机可以多进程并发运行，例如在发邮件的同时也可以通过浏览器浏览网页，这两种应用通过端口号进行区分 在网络层，上层数据被封装上亲的报文头部(IP头部)，上层的数据是包括TCP头部的。IP地址包括的最关键字段信息就是IP地址，用于标识网络的逻辑地址。 数据链路径层，上层数据成一个MAC头部，内部有最关键的是MAC地址。MAC地址就是固化在硬件设备内部的全球唯一的物理地址。 在物理层，无论在之前哪一层封装的报文头和还是上层数据都是由二进制组成的，物理将这些二进制数字比特流转换成电信号在网络中传输 6.3.2 接收方是从低层到高层解封装 数据封装完毕传输到接收方后，将数据要进行解封装 在物理层，先把电信号转成二进制数据，并将数据传送至数据链路层 在数据链路层，把MAC头部拆掉，并将剩余的数据传送至上一层 在网络层，数据的IP头部被拆掉，并将剩余的数据送至上一层 在传输层，把TCP头部拆掉，将真实的数据传送至应用层 6.3.3 真实网络环境 发送方和接收方中间可能会有多个硬件中转设备 中间可能会增加交换机和路由器 数据在传输过程中不断地进行封装和解封装的过程，每层设备只能处理哪一层的数据 交换机属于数据链路层 路由器属于网络层 A电脑 -&gt; A交换机 -&gt; A路由器 -&gt; B路由器 -&gt; B交换机 -&gt; B电脑 7. 附录7.1 不同层中的称谓 数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。 数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。 段（Segment）：通常是指起始点和目的地都是传输层的信息单元。 消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 7.2 IP头服务类型 IP首部中的服务类型（TOS） TOS包括共8位，包括3 bit的优先权字段（取值可以从000-111所有值），4 bit的TOS子字段和1 bit未用位但必须置0。 3bit的8个优先级的定义如下： 111–Network Control(网络控制）一般保留给网络控制数据使用，如路由。 110–Internetwork Control(网间控制) 101–Critic(关键)语音数据使用。 100–Flash Override(疾速)视频会议和视频流使用。 011–Flash(闪速)语音控制数据使用。 010–Immediate(快速)数据业务使用 001–Priority(优先)数据业务使用 000–Routine(普通)默认标记值。 4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是一般服务。 Telnet、Rlogin这两个交互应用要求最小的传输时延，FTP文件传输要求最大吞吐量，最高可靠性是指网络管理（SNMP）和路由选择协议。用户网络新闻要求最小费用","categories":[{"name":"net","slug":"net","permalink":"http://yoursite.com/categories/net/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"go2","slug":"go2","date":"2021-03-24T13:10:34.000Z","updated":"2021-04-01T02:21:02.328Z","comments":true,"path":"2021/03/24/go2/","link":"","permalink":"http://yoursite.com/2021/03/24/go2/","excerpt":"","text":"1. io1.1 写文件按字符串写 WriteString 12345678910func main()&#123; f, err:= os.OpenFile(\"./a.txt\", os.O_RDWR, 6) if err != nil &#123; fmt.Println(\"openFile err:\", err) return &#125; defer f.Close() n, err := fmt.Println(\"success\") // n 写入字符个数 f.WriteString(\"123\") // 按字符串写&#125; 按位置写 writeAt 1234// Seek() // 文件位置指针off, _ := f.Seek(-5, io.SeekEnd)fmt.Println(\"off\", off) // off 表示从文件起始位置往后偏的值n, err = f.WriteAt([]byte(\"1111\"), off) 1.2 读文件按行读 12345678910111213141516func main()&#123; f, err:= os.OpenFile(\"./a.txt\", os.O_RDWR, 6) if err != nil &#123; fmt.Println(\"openFile err:\", err) return &#125; defer f.Close() fmt.Println(\"success\") // 创建一个带有缓冲区的reader reader := bufio.NewReader(f) buf, err := reader.ReadBytes('\\n') // 读一行数据 if err != nil &#123; fmt.Println(\"ReadBytes err\", err) &#125; fmt.Println(string(buf)) // hellowo1111&#125; 12345678910// 全部读取reader := bufio.NewReader(f)for &#123; buf, err := reader.ReadBytes('\\n') // 读一行数据 if err != nil &amp;&amp; err == io.EOF &#123; fmt.Println(\"ReadBytes err\", err) return &#125; fmt.Println(string(buf)) // hellowo1111&#125; 1.3 缓冲区磁盘构成 振臂 磁头 磁道 扇区 一个扇区512B，数据在磁盘存储时至少要占据一个扇区。 磁盘读取是物理操作，物理操作取决于硬件的性能。考虑到物理操作性能开销明显，所以需要进行性能优化。便有了缓冲区。 一次性尽可能多的奖磁盘上的内容读取到当前内存中，比如需要一行文件。但是缓冲区真正从磁盘上读取的时候。它不止拿了一行。而是尽可能的奖当前扇区里面的数据都读取过来。因为读一行和把当前扇区读完，对于磁头来说，都是一次物理操作。 一个场景，当读取一行之后，还需要继续读。那么这个时候，就可以直接从缓冲区中读取了，而不需要再次让磁盘执行物理操作读取。而从内存中读取数据是电子操作（电子操作访问速度接近光速，比物理操作快得多） 缓冲区 “预读入，缓输出” 往磁盘上写数据的时候，大多情况下是先写到缓冲区中了。等待缓冲区满，由操作系统批量一次性刷到磁盘当中。 1.4 32位与64位内存地址32位 最大内存地址 2^32 4GB（进程空间） 64位 最大内存地址 2^64 比较大 2. 并行与并发2.1 并行（parallel） 并行，同一时刻，有多条指令在多个处理器上同时执行。并行需要借助多核cpu实现。 2.2 并发宏观：在用户体验上，程序在并行执行 微观：多个计划任务，顺序执行。在飞快的切换，轮换使用cpu时间轮片；（cpu时间调度算法） 进程状态： 初始态、 就绪态、 运行态、 挂起（阻塞）态、终止（停止）态 线程并发： 什么是线程 Lwp（light weight process）轻量级进程，本质上仍是进程（Linux下） 进程： 独立地址空间，拥有PCB 线程： 有独立的PCB，但没有独立的地址空间（共享） 区别： 在于是否共享地址空间，独居（进程）； 合租（线程） 线程： 最小的执行单位 进程： 最小分配资源单位，可看成是只有一个线程的进程； 2.3 线程同步同步即协同步调，按预定的先后次序运行。 线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回，同时其它线程为保证数据一致性，不能调用该功能； 举例：A，B两张银行卡取钱。当两个线程访问共享资源时，如果没有协调机制，会产生与时间有关的错误。—— 锁 因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。 2.3.1 线程同步机制：互斥锁（互斥量）：建议锁，拿到锁以后，才能访问数据，没有拿到锁的线程，阻塞等待。等到拿锁的线程释放锁。 读写锁： 一把锁（读属性、写属性），写独占，读共享，写锁优先级高 信号量： 条件变量： 2.4 协程并发协程： coroutine，也叫轻量级线程。 与传统系统级线程和进程相比，协程最大优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源崩溃。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。 一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行。多个协程分享该线程分配到的计算机资源。 在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。 2.5 小结在一次并发任务中，进程、线程、协程都可以实现，从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。 进程并发：优点是稳定性强，开销较线程大。 线程并发：优点是节省资源，尤其是调度时，线程与线程之间切换的时候。而进程间切换的开销就比较大一些。 协程并发： 效率高，系统利用率高 3. goroutineGo语言为并发编程而内置的上层API基于顺序通信进程模型CSP（communicating sequential processes）。这就意味着显式锁都是可以避免的。因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。 Go语言中的并发程序主要是用两种手段来实现。goroutine 和 channel 3.1 概论1234567func main() &#123; go sing() go dance() for &#123; &#125;&#125; Goroutine 的并发机制；main goroutine中的for{} 占据较长的时间。可以确保两个goroutine能执行完毕； Goroutine的特性： 主go程结束，子go程随之退出； 3.2 runtime包3.2.1 Goschedruntime.Gosched() 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次再获得cpu时间轮片的时候，从该让cpu的位置恢复执行。 当再次获得cpu时，从出让位置继续回复执行； —— 时间片轮转调度算法； 123456789101112func main()&#123; go func()&#123; for &#123; fmt.Println(\"this is goroutine\") &#125; &#125; for &#123; runtime.Gosched() // fmt.Println(\"this is main test\") &#125;&#125; 3.2.2 Goexit调用runtime.Goexit(), 将立即终止 当前goroutine执行，调度器确保所有已注册defer延迟调用被执行； return和Goexit之间的差异 return：返回当前函数调用给调用者；后续语句不糊执行了。return之前的defer生效，之后的defer不生效了； Goexit：结束调用该函数的当前goroutine，Goexit()之前注册的defer都生效； 123456789101112131415func test()&#123; defer fmt.Println(\"ccc\") runtime.Goexit(); fmt.Println(\"ddd\")&#125;func main()&#123; go func()&#123; fmt.Println(\"aaa\") test() fmt.Println(\"bbb\") &#125;() for&#123;&#125;&#125;// aaa// ccc 3.2.3 runtime.GOMAXPROCS()调用runtime.GOMAXPROCS() 设置可以并行计算的CPU核数最大值，并返回之前的值； 返回值：上一次设置的核心数 4. channelchannel是Go语言中的一个核心类型，可以把它看成管道（FIFO，first in ，first out）。并发核心单元通过它就可以发送或接收数据进行通讯，这在一定程度上又进一步降低了编程难度； channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享的问题 goroutine运行在相同的地址空间，因此访问共享内存必须做好同步，goroutine奉行通过通信来共享内存，而不是共享内存来通信； 引用类型channel可用于多个gouroutine通讯，其内部实现了同步，确保并发安全； 4.1 channel语法channel是一个对应make创建的底层数据结构的引用； 当复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和 其它的引用类型一样，channel的零值也是nil 定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的make函数来创建。 1234// Type 指定channel收发数据的类型；make(chan Type) // 等价于 make(chan Type, 0)// capacity 容量make(chan Type, capacity) 当参数 capacity=0 时，channel是无缓冲阻塞读写的，当capacity&gt;0 时，channel有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入； channel一边可以存东西，另一边可以取东西。channel通过 &lt;- 来接收和发送数据，发送和接收数据语法； 1234channel &lt;- value // 发送value到channel&lt;- channel // 接收并将其丢弃x := &lt;-channel // 从channel中接收数据，并赋值给xx, ok:= &lt;-channel // 功能同上，同时检查通道是否已经关闭或者是否为空 4.2 grouting 通信每当一个进程启动时，系统会自动打开三个文件，标准输入·标准输出·标准错误 —— 对应三个文件：stdin、 stdout、 stderr stdin对应的硬件 ——硬盘 stdout对应的硬件—— 屏幕 stderr对应的硬件——屏幕 当进程圆形结束，操作系统会自动关闭三个文件； 12345678910111213141516171819202122232425func printer(s string) &#123; for _, ch := range s &#123; fmt.Printf(\"%c\", ch) time.Sleep(300* time.Millisecond) &#125;&#125;// define tow people use printerfunc person1() &#123; printer(\"person1\")&#125;func person2()&#123; printer(\"person2\")&#125;func main()&#123; go person1() go person2() for &#123; ; &#125; // ppeerrssoonn21&#125; 12345678910111213141516171819func person1() &#123; channel&lt;-891 printer(\"person1\")&#125;func person2()&#123; printer(\"person2\")&#125;func main()&#123; go person1() go person2() for &#123; ; &#125; // person2 // 因为channel不设置容量是 无缓冲阻塞读写的；所以go程person1的printer方法没发输出数据了；只能是go程序2 执行&#125; channel有两个端： 一端： 写端（传入端） chan &lt;- 另一端： 读端（传出端）&lt;- chan 要求： 读端和写端必须同时满足条件，才能在chan上进行数据流动。否则，则阻塞； （读端去读了，chan没有，就是读端阻塞。写端写了，但是chan没有读，就是写端阻塞。总之就是谁操作了，阻塞谁。） 4.3 无缓冲的channel无缓冲的channel(unbuffered channel)是指在接收前没有能力保存任何值的通道； 这种类型的通道要求发送goroutine 和接收 goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的goroutinue阻塞。 这种对通道进行发送和接收的交互行为本身就是同步的，其中任意一个操作都无法离开另一个操作单独存在。 阻塞：由于某种原因数据没有到达，当前协程持续处于等待状态，直到条件满足，才解除阻塞。 同步： 在两个或多个协程（线程）间，保持数据内容一致性的机制； 123456ch: make(chan string)// 写端ch &lt;- \"he\" // 写端写数据，读端不在读，阻塞// 读端str:=&lt;-ch // 读端读数据，同时写端不在写，读端阻塞 4.3.1 channel同步，数据传递12345678910111213141516func main() &#123; channel := make(chan string) go func() &#123; for i := 0; i &lt; 2; i++ &#123; fmt.Println(\"i=\", i) &#125; channel &lt;- \"123\" &#125;() str := &lt;-channel // 阻塞写，上面的go程才有机会执行； fmt.Println(str) // i= 0// i= 1// 123&#125; 第1步，两个goroutine都到达通道，但哪个都没有开始执行发送或接收 第2步，左侧的goroutine将它的手伸进了通道，这模拟了向通道发送数据的行为，这时，这个goroutine会在通道中被锁住，直到交换完成； 第3步，右侧的goroutine将它的手放入通道，这模拟了从通道里接收数据，这个goroutine一样也会在通道中被锁住，直到交换完成 在第4步和第5步，进行交换，并最终，在第6步，两个goroutine都将它们的手从通道里面拿出来，这模拟了被锁住的goroutine得到释放，两个goroutine现在都可以去做其他事情了； 123456789101112131415161718192021222324252627func main() &#123; ch := make(chan int) go func() &#123; for i := 0; i &lt; 5; i++ &#123; fmt.Println(\"子go程 i=\", i) ch &lt;- i // // 1.当程序一个值往ch中写入时，由于channel中读的goroutine未就位，当前goroutine阻塞，下一个goroutine得以执行 &#125; &#125;() for i := 0; i &lt; 5; i++ &#123; num := &lt;-ch // // 2. 当执行到这里，读gorutine就位；上面的`ch&lt;-i` gorouine立即被唤醒并继续执行。执行之后，读gorouine也脱离channel，开始往下继续执行； fmt.Println(\"主go程读\", num) &#125;&#125;子go程 i= 0子go程 i= 1 // 这里为什么不是 主go程读 0主go程读 0主go程读 1子go程 i= 2子go程 i= 3主go程读 2主go程读 3子go程 i= 4主go程读 4 *为什么第二行不是 “子go程 i= 1” * 因为fmt.Println(&quot;主go程读&quot;, num)是IO操作，耗时（访问硬件）可能需要等待； channel应用与 两个goroutine中，一个读，一个写； 具备同步的能力，读、写同步 有缓冲channel 4.3.2 channel的len和cap123var channel = make(chan int)len(channel) // 0 channel中剩余未读取数据个数cap(channel) // 0 channel的容量 有缓冲channel 通道容量为非0， len(ch): channel中剩余未读取数据个数。cap(ch): 通道容量 channel应用于两个go程中，一个读，另一个写 缓冲区可以进行数据存储，存储至容量上限，阻塞，具备异步能力，不需要同时操作channel缓冲区（发短信） 1234567891011121314151617181920212223242526272829func main() &#123; ch := make(chan int, 2) // 存满3个元素之前不会阻塞 fmt.Println(\"len=\", len(ch), \"cap=\", cap(ch)) go func() &#123; for i := 0; i &lt; 6; i++ &#123; ch &lt;- i fmt.Println(\"子go程 i=\", i) &#125; &#125;() // time.Sleep(300 * time.Millisecond) for i := 0; i &lt; 6; i++ &#123; num := &lt;-ch fmt.Println(\"主go程读\", num) &#125;&#125;len= 0 cap= 2子go程 i= 0子go程 i= 1子go程 i= 2主go程读 0主go程读 1主go程读 2主go程读 3子go程 i= 3子go程 i= 4子go程 i= 5主go程读 4主go程读 5 4.4 关闭channel如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现； 确定不再向对端发送接收数据时，使用close关闭channel 对端可以判断channel是否关闭 1234if num, ok:= &lt;-ch; ok == true &#123; // 如果对端已经关闭， ok--&gt;false, num无数据 // 如果对端没有关闭，ok--&gt; true，num保存读到的数据&#125; 12345678910111213141516171819202122func main() &#123; ch := make(chan int) go func() &#123; for i := 0; i &lt; 5; i++ &#123; ch &lt;- i &#125; close(ch) &#125;() for &#123; // 不再需要指定循环次数 if num, ok := &lt;-ch; ok == true &#123; fmt.Println(\"读取数据\", num) &#125; else &#123; break &#125; &#125;&#125;读取数据 0读取数据 1读取数据 2读取数据 3读取数据 4 总结 1:数据没发送完，不应该关闭。 2 已经关闭的channel，不能再写入数据 3 写端已经关闭的channel，可以从中读取数据， ​ 读无缓冲channel 读到0， —— 说明写端关闭 ​ 读有缓冲channel，如果缓冲区有数据，先读数据。读完数据可以无限读，读到0 4.5 单向channel默认的channel是双向的， var ch chan int ch:=make(chan int) 单向写channel： var sendCh chan &lt;- int sendCh = make(chan &lt;- int) 单向读channel： var recvCh &lt;- chan int recvCh = make(&lt;- chan int) 转换： 双向channel 可以隐士转换为任意一种单向channel 1sendCh = ch 单向channel不能转换为双向channel 1ch = sendCH/recvCh // error!!! 传参：传【引用】 123456789ch := make(chan int)var sendCh chan&lt;- int = ch // 双向channel赋值给写channelsendCh &lt;- 789var recvCh &lt;-chan int = ch // 双向channel赋值给读channelnum := &lt;-recvChfmt.Println(\"num\", num)var ch2 chan int = sendCh //compiler error 单向channel无法赋值给双向channel 单向channel的好处，约束子函数行为。 12345678910111213141516171819package mainimport \"fmt\"func send(out chan&lt;- int) &#123; out &lt;- 123 // 只能往channel写，无法做读取操作 close(out)&#125;func recv(into &lt;-chan int) &#123; n := &lt;-into // 只能从channel读，无法做写入操作 fmt.Println(\"into=\", n) // 123&#125;func main() &#123; ch := make(chan int) go func() &#123; send(ch) &#125;() recv(ch)&#125; 4.6 生产者消费者模型单向channel最典型的应用是“生产者消费者模型” 所谓“生产者消费者模型”： 某个模块（函数等）负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、协程、线程、进程等）产生数据的模块，就形象地成为生产者，而处理数据的模块，就称为消费者。 单单抽象出生产者和消费者，还够不上是生产者/消费者模型。改模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。 1生产者——》缓冲区——》消费者 举例，假如需要寄出一封信，大致流程如下： 把信写好——相当于生产者制造数据 把信放入油桶——相当于生产者把数据放入缓冲区 邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区 生产者：发送数据端 消费者：接收数据端 缓冲区的好处 解耦（降低生产者和消费者之间耦合度） 生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据了；（生产者和消费者数量不对等时，能保持正常通信）基本不需要依赖消费者的处理速度； 缓存，生产者和消费者处理数据速度不一致时，暂存数据（如果生产者制造数据时快时慢，缓冲区的好处就提体现出来了。当数据制造快消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉） Channel 实现缓冲区 有缓冲channel和无缓冲channel都能实现缓冲区 有缓冲channel 异步通信 用于对实时不敏感的需求； 无缓冲channel 同步通信，用于实时需求； 4.7 channel作为参数传递，是引用传递4.8 模拟订单订单处理就是典型的生产消费模式 当很多用户单击下订单按钮后，订单生产的数据全部放到缓冲区，然后消费者将队列中的数据取出来发送到管理系统 通过生产者消费模式，将订单系统与仓库管理系统隔离开，且用户可以随时下单。如果订单系统直接调用仓库系统，那么用户单击下订单按钮后，要等到仓库系统的结果返回，这样速度会很慢； 4.9 定时器time.Timer Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间 1234type Timer struct &#123; C &lt;- chan Time r runtimeTimer&#125; 它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统自动向timer.C这个channel中写入当前时间，阻塞即被解除； 5. select5.1 select的作用Go里面提供了一个关键字select，通过select可以监听channel上的数据流动 select与switch相似，但select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作（读写操作，读channel写channel也是一种IO操作） 12345678select &#123; case &lt;- chan1: // 如果chan1成功读取到数据，则进行该case处理语句 case chan2 &lt;-1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程&#125; 在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句； 如果其中的任意一语句可以继续执行（即没有被阻塞）那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况 如果给出default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复 如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去 1234567891011for &#123; select &#123; case &lt;- chan1: // 如果chan1成功读取到数据，则进行该case处理语句 case chan2 &lt;-1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 &#125;&#125;// 如果需要轮训select监听channel数据流向的话，那么需要加上for语句。但是这样每次循环进来都需要default:这样就形成忙轮询死循环了。CPU一致被占用。所以一般在for的时候 不写default。这样的话select语句就会因为阻塞而挂起。挂起会出让cpu时间片。这样会提升计算机的效率 5.2 select基本使用123456789101112131415161718192021222324252627282930313233343536373839// select package mainimport ( \"fmt\" \"runtime\" \"time\")func main() &#123; ch := make(chan int) // 用来进行数据通信的channel quit := make(chan bool) // 用来判断是否退出的channel go func() &#123; // 写数据 for i := 0; i &lt; 5; i++ &#123; ch &lt;- i time.Sleep(time.Second) &#125; close(ch) quit &lt;- true // 通知主goroutine退出 runtime.Goexit() &#125;() for &#123; // 主goroutine 读数据 select &#123; case num := &lt;-ch: fmt.Println(num) case &lt;-quit: return // 终止进程 &#125; &#125;&#125;012340 select总结： 作用： 用来监听channel上的数据流动方向。读？写？ 用法： 参考switch case语句，但！ case后面必须是IO操作，不可以任意写判别表达式 注意事项： 监听的case中，没有满足监听条件，阻塞 监听的case中，有多个满足监听条件，任选一个执行 可以使用default来处理所有case都不满足监听条件的状况，通常不同（会产生忙轮训） select自身不带有循环机制，需要借助外层for来循环监听 break只能跳出select，类似swtich中的用法 5.3 select实现斐波那契数列5.4 超时有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时。 12345678910111213141516171819202122func main()&#123; c:= make(chan int) quit:=make(chan bool) go func()&#123; for &#123; select &#123; case v:= &lt;-c: case &lt;-time.After(3*time.Second): // 设置超时 quit&lt;-true break; &#125; &#125; &#125;() for i:=0; i&lt;2; i++ &#123; ch &lt;- i; time.Sleep(time.Second * 2) &#125; &lt;-quit // 主go程，阻塞等待子go程通知，退出 fmt.Println(\"finish!\")&#125; select超时处理： select监听time.After中channel的读事件，如果定时时间到，系统会向该channel中写入系统当前时间 1234select &#123; case &lt;- time.After(time.Second*5) // 定时到达后，要处理的内容&#125; 6. Lock什么是锁，就是某个协程（线程）在访问某个资源的时候先锁住，防止其他协程的访问，等访问完毕解锁后其他协程再来加锁访问。 6.1 死锁 不是锁的一种！！！ 是一种错误使用锁导致的现象 死锁是指两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁； 单go程死锁,（channel应该至少2个以上的go程中进行通信，否则死锁！） 12345func main()&#123; ch:=make(chan int) ch&lt;-789 // 阻塞 num:=&lt;-ch&#125; go程间channel访问顺序导致死锁 123456789func main() &#123; ch := make(chan int) num := &lt;-ch fmt.Println(num) go func() &#123; ch &lt;- 123 &#125;()&#125; 使用channel一端读（写），要保证另一端写（读）操作，同时有机会执行。否则死锁； 多go程，多channel交叉死锁 （日常编程当中，逻辑控制不严谨。出现频率比较高） 12345678910111213141516171819func main() &#123; ch1 := make(chan int) ch2 := make(chan int) go func() &#123; // 子 for &#123; select &#123; case num := &lt;-ch1: ch2 &lt;- num &#125; &#125; &#125;() for &#123; select &#123; case num := &lt;-ch2: ch1 &lt;- num &#125; &#125;&#125; 在go语言中，尽量不要将互斥锁，读写锁与channel混用，—— 隐形死锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"math/rand\" \"sync\" \"time\")var count intvar rwlock sync.RWMutex // 锁只有1把func readGo(in &lt;-chan int, idx int) &#123; for &#123; rwlock.RLock() // 以读模式枷锁 num := &lt;-in fmt.Printf(\"-----%dth 读go程，读出：%d\\n\", idx, num) rwlock.RUnlock() // 以读模式解锁 &#125;&#125;func writeGo(out chan&lt;- int, idx int) &#123; for &#123; // 生成随机数 num := rand.Intn(1000) rwlock.Lock() //以写模式枷锁 out &lt;- num fmt.Printf(\"%dth 写go程,写入：%d\\n\", idx, num) time.Sleep(time.Millisecond * 300) rwlock.Unlock() &#125;&#125;func main() &#123; // 播种随机种子 rand.Seed(time.Now().UnixNano()) ch := make(chan int) // 用于数据传递的channel for i := 0; i &lt; 3; i++ &#123; go readGo(ch, i+1) &#125; for i := 0; i &lt; 3; i++ &#123; go writeGo(ch, i+1) &#125; for &#123; &#125;&#125; 6.2 互斥锁每个资源都对应一个可称为“互斥锁”的标记，这个标记是用来保证在任意时刻，只能有一个协程（线程）访问该资源，其他的协程只能等待； 互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock，Lock锁定当前的共享资源，Unlock进行解锁； 在使用互斥锁时，一定要注意：对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。 123456789101112131415161718192021222324252627282930313233// 使用channel完成同步package mainimport ( \"fmt\" \"time\")var ch = make(chan int)func printer(str string) &#123; for _, ch := range str &#123; fmt.Printf(\"%c\", ch) time.Sleep(time.Millisecond * 300) &#125;&#125;func person1() &#123; ch &lt;- 98 printer(\"hello\")&#125;func person2() &#123; &lt;-ch printer(\"mutex\")&#125;func main() &#123; go person1() go person2() for &#123; &#125;&#125; 锁：强制锁建议锁 建议锁和强制锁并不是真正存在的锁，而是一种能对诸如记录锁、文件锁产生影响的两种机制； 这里的互斥锁是属于建议锁，操作系统不强制提供；（建议锁只是建议性存在的，并不强制执行，内核和系统总体上都坚持不使用建议性锁机制，它们依靠程序猿遵守这个规定，Linux默认是采用建议性锁） 建议锁只在合作进程（cooperating precess）之间才有效。破坏性的IO操作会成功 合作进程： 考虑数据库访问例程库，如果该库中所有函数都以一致性的方法处理记录锁，责成使用这些函数访问数据库的任何进程集为合作进程 上层应用使用的锁全部都是建议锁 强制锁机制是这样规定的：所有记录或文件锁功能内核执行的。破坏性的IO操作会被内核禁止。被锁的文件，内核会强制阻止任何对该文件的读或写违规访问。每次读或写访问都得检查锁是否存在。也就是强制性锁机制。 强制锁只在操作系统底层它自己会用到，编程用不上 阻塞在锁上 1234567891011121314151617181920212223242526// 使用互斥锁完成同步var mutex sync.Mutexfunc printer(str string) &#123; mutex.Lock() // 访问共享数据之前， for _, ch := range str &#123; fmt.Printf(\"%c\", ch) time.Sleep(time.Millisecond * 300) &#125; mutex.Unlock() // 访问共享数据之后&#125;func person1() &#123; printer(\"hello\")&#125;func person2() &#123; printer(\"mutex\")&#125;func main() &#123; go person1() go person2() for &#123; &#125;&#125; 6.3 读写锁互斥锁的本质是当一个goroutine访问的时候，其他goroutinue都不能 访问，这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。 其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在竞争的问题的。因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的； 所以问题不是出在读上，主要是修改，也就是“写”，修改的数据要同步，这样其他goroutinue才可以感知到。所以真正的互斥应该是读取和修改、修改和修改之间，读和读是没有互斥操作的必要的； 因此，衍生出另外一种锁，叫做读写锁。 读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutinue既不能进行读操作，也不能进行写操作。 Go中的读写锁由结构体类型sync.RWMutex表示，此类型的方法集合中包含两对方法： 一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”。 12func (*RWMutex) Lock()func (*RWMutex) Unlock() 另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁” 12func (*RWMutex)RLock()func (*RWMutex)RUlock() 数据同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( \"fmt\" \"math/rand\" \"sync\" \"time\")var count intvar rwlock sync.RWMutex // 锁只有1把func readGo(idx int) &#123; for &#123; rwlock.RLock() // 以读模式枷锁 num := count fmt.Printf(\"-----%dth 读go程，读出：%d\\n\", idx, num) rwlock.RUnlock() // 以读模式解锁 &#125;&#125;func writeGo(idx int) &#123; for &#123; // 生成随机数 num := rand.Intn(1000) rwlock.Lock() //以写模式枷锁 count = num fmt.Printf(\"%dth 写go程,写入：%d\\n\", idx, num) rwlock.Unlock() &#125;&#125;func main() &#123; // 播种随机种子 rand.Seed(time.Now().UnixNano()) for i := 0; i &lt; 3; i++ &#123; go readGo(i + 1) &#125; for i := 0; i &lt; 3; i++ &#123; go writeGo(i + 1) &#125; for &#123; &#125;&#125;//1th 写go程,写入：42//-----1th 读go程，读出：42//-----1th 读go程，读出：42//-----3th 读go程，读出：42//1th 写go程,写入：86//-----2th 读go程，读出：86//-----2th 读go程，读出：86//-----1th 读go程，读出：86 总结 读时共享，写时独占。写锁优先级比读锁高 6.4 条件变量12345678910111213141516171819202122232425262728293031323334353637383940// 引出问题func producer(out chan&lt;- int, idx int) &#123; for i := 0; i &lt; 50; i++ &#123; num := rand.Intn(800) fmt.Printf(\"%dth:product -&gt; %d,\\n \", idx, num) out &lt;- num &#125; close(out)&#125;func consumer(in &lt;-chan int, idx int) &#123; for num := range in &#123; fmt.Printf(\"-----%dth:consum -&gt; %d,\\n \", idx, num) &#125;&#125;func main() &#123; rand.Seed(time.Now().Unix()) product := make(chan int) for i := 0; i &lt; 5; i++ &#123; go consumer(product, i+1) &#125; for i := 0; i &lt; 5; i++ &#123; go producer(product, i+1) &#125; for &#123; &#125;&#125; 1th:product -&gt; 15, 3th:product -&gt; 481, 2th:product -&gt; 546, -----4th:consum -&gt; 15, -----4th:consum -&gt; 481, 1th:product -&gt; 790, 1th:product -&gt; 738, -----4th:consum -&gt; 790, // 546 空过去了 -----4th:consum -&gt; 738, 本身不是锁！！但条件变量总是与锁一起使用 条件变量的作用并不保证在同一时刻仅有一个协程访问某个共享的数据资源，而是在对应的共享数据的状态发生变化时，通知阻塞在某个条件上的协程（线程）。条件变量不是锁，在并发中不能达到同步的目的，因此条件变量总是与锁一块使用 例如，如果仓库队列满了，我们可以使用条件变量让生产者对应的go程暂停（阻塞），但是当消费者消费了某个产品后，仓库就不再满了，应该唤醒（发送通知给）阻塞的生产者go程继续生产产品 在抢锁之前，咨询条件变量。是否有必要抢锁（如果缓冲区满或空的时候） 以前的顺序 抢锁 访问公共区 解锁 条件变量版本的顺序 判断条件变量 抢锁 访问公共区 解锁 唤醒阻塞在条件变量上的对端 go标准库中的sync.Cond类型代表了条件变量，条件变量要与锁（互斥锁，或者读写锁）一起使用。成员变量L代表与条件变量搭配使用的锁 123456type Cond struct &#123; noCopy noCopy L Locker // 创建条件变量的时候，要指定其用的是什么锁 notify notifyList checker copyChecker&#125; 对应的有3个常用方法，Wait，Signal，Broadcase 123456789101112func (C *Cond)Wait()/**该函数的作用（一旦调用，会做下面三件事）1. 阻塞等待条件变量满足2. 释放已掌握的互斥锁相当于cond.L.Unlock() // 注意，1，2 两步为一个原子操作3. 当被唤醒，Wait()函数返回时，解除阻塞并重新获取互斥锁，相当于cond.L.Lock()*/// 下面两个函数为 唤醒操作func (c *Cond)Signal()// 单发通知，给一个正等待（阻塞）在该条件变量上的goroutinue 发送通知func (c *Cond)Broadcase()// 广播通知，给正在等待（阻塞）在该条件变量上的所有goroutinue发送通知 // 惊群效应 使用条件变量 123451. 定义条件变量cond2. cond.L--&gt;mutex ,指定一把锁3. cond.L.lock() 4 if xxxxwait() // 如果满足条件，做wait操作， wait包含3件事（一段时间的阻塞，解锁，加锁） 一段时间的阻塞，解锁，加锁 为什么在等待的时候，要解开锁，一会儿又加上呢？ 因为针对的对象是公共区（有缓冲channel），执行wait函数说明公共区达到了容器设定的条件。没办法继续往公共区读（写）数据。所以，当挂起等待的过程当中需要将锁让给对端。当对端写（读）数据之后，容器出现富余，它再唤醒对端，对端重新加上锁从而来访问公共区； 7. 定时器time.Timer Timer是一个定时器，代表未来的一个单一时间，你可以告诉timer你要等待多长时间 1234type Timer struct &#123; C &lt;- chan Time r runtimeTimer&#125; 它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统会自动向timer.C这个channel中写入当前时间，阻塞即被解除； 12345678910func main() &#123; fmt.Println(\"current time\", time.Now()) mytimer := time.NewTimer(time.Second * 2) // 定时时间到，系统会自动向timer.C这个channel写入了当前时间； currentTime := &lt;-mytimer.C fmt.Println(\"currentTime is:\", currentTime)&#125;//current time 2021-03-28 19:27:55.330078 +0800 CST m=+0.000082012//currentTime is: 2021-03-28 19:27:57.330273 +0800 CST m=+2.000328165 7.1 三种定时方法1234567891011func main()&#123; // 1. sleep time.Sleep(time.Second) // 2. Timer.C myTimer:= time.NewTimer(time.Second * 2) // 定时器慢，系统自动写入系统时间 currentTime := &lt;-mytimer.C fmt.Println(\"currentTime is:\", currentTime) // 3. time.After nowTimer2 := time.After(time.Second*2)&#125; time.After定时： 指定定时时长，定时到达后，系统会自定向定时器的成员写入 系统当前时间。 返回可读 chan，读取，可获得系统写入时间； 总结： Sleep NewTimer， After 都是 time包的 7.2 定时器的停止和重置12345678910func main()&#123; myTimer := time.NewTimer(time.Second * 3) // 创建定时器 myTimer.Reset(1 *time.Second) //重置定时器时长为1 go func()&#123; &lt;- myTimer.C fmt.Println(\"子go程，定时完毕\") &#125;() myTimer.Stop() //设置定时器停止 for &#123;&#125;&#125; 7.3 定时器周期定时周一到周五每天早上8点起床上班 123456789101112131415161718func main() &#123; fmt.Println(\"startTime:\", time.Now()) myTicker := time.NewTicker(time.Second) go func() &#123; for &#123; nowTime := &lt;-myTicker.C fmt.Println(\"nowTime:\", nowTime) &#125; &#125;() for &#123; &#125;&#125;//startTime: 2021-03-28 20:47:03.563903 +0800 CST m=+0.000099792//nowTime: 2021-03-28 20:47:04.575006 +0800 CST m=+1.011228039//nowTime: 2021-03-28 20:47:05.579668 +0800 CST m=+2.015915392//nowTime: 2021-03-28 20:47:06.577759 +0800 CST m=+3.014031618 可控的周期性定时器 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"time\")func main() &#123; quit := make(chan bool) myTimer := time.NewTicker(time.Second) fmt.Println(\"now Time:=\", time.Now()) i := 0 go func() &#123; for &#123; currentTime := &lt;-myTimer.C i++ fmt.Println(\"current Time:= \", currentTime) if i == 5 &#123; fmt.Println(\"done\") quit &lt;- true runtime.Goexit() &#125; &#125; &#125;() &lt;-quit&#125; 创建一个周期定时器 time.NewTicker，定时时长到达后，系统会自动向Ticker的C中写入系统当前时间，并且，每隔一个定时时长后，循环写入系统当前时间； 在子go程中循环读取C，获取系统写入的时间 8. 协议8.1 概述协议，就是双方约定好的一份的合同，在数据传输层面来说。如果要传输一个文件。我们必然需要来分析一下文件的特征。 对于发送端来说，我要怎么确保我发出去的东西，接收端能拿到并且拿到的东西是对的；一 文件不能串台，二，文件不能有丢失； 那最早的传输协议雏形，首先发过去文件名，其次发过去这个文件有多大，最后将文件内容拆包分发。 对应的在接收端，就知道这个文件的名称和容量的，当接收完毕之后。要校验一下文件名是否对的上的，文件大小是否对的上啊。这就是最早的FTP协议雏形 后续，随着需要越来越复杂，文件的类型也越来越多，文件体积越来越大。到这个时候，聪明的人类不断地升华这份合同，如果尽可能简单的去把问题高效解决了一直促进着计算机网络的发展； 8.2 典型协议传输层 TCP/UDP 应用层 HTTP/FTP 网络层 IP ICMP IGMP 网络接口层 ARP RARP TCP 传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议 UDP 用户数据报协议 是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送信息 HTTP超文本传输协议 FTP 文件传输协议 IP协议 ICMP internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制器之间 IGMP internet组管理协议，是internet协议族中的一个组播协议，该协议运行在主机和组播路由器之间 ARP 协议是正向地址解析协议，通知已知IP，寻找对应主机的MAC地址。 RARP 是反向地址转换协议，通过MAC地址确定IP地址 8.3 分层模型每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽 OSI/RM(理论上的标准) TCP/IP（事实上的标准） 应用层 应用层 表示层 应用层 会话层 应用层 传输层 传输层 网络层 网络层 数据链路层 链路层 物理层 链路层 8.4 层与协议 各层功能 网络层 -&gt; ip 传输层 -&gt; port 8.5 传输过程， 将一条字符串从一台主机发往另外一台主机 8.5.1 链路层两台主机传输数据，需要硬件支持，主机上得有网卡，软件得有网卡驱动。网卡对应的就是ARP协议 网卡身份证（全球唯一）：MAC地址；数据包的物理发送地址和物理接收地址 ARP协议：借助IP地址获得MAC地址； RARP协议： 借助MAC地址获得IP地址； 8.5.2 网络层网络层的作用是引进一套新地址，能够区分不同计算机是否属于同一个子网络。这套地址就叫做“网络地址”，就是平时说的IP地址； 网络地址帮助确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。 IP协议： 在网络环境中唯一标识一台主机； IP地址本质： 2进制数——点分十进制 IP地址 8.5.3 传输层TCP/UDP协议 封装port——在一台主机上唯一标识的进程； 8.5.4 应用层截止到应用层，通过链路层确定MAC地址，通过网络层确定IP地址，通过传输层由PORT定位到进程。至此目标主机确定下来了； 接下来开始传输实际的数据了，当然不会赤裸裸的将 字符串 丢网上，前面说了，发送端得确保接收端确实拿对并拿全了这个数据包才行；就便有了应用层的协议； 比如http协议，有文件名，文件MIME，请求体，请求状态等等等等； 8.5.5 数据包封装的过程自上向下 待发送的原理数据 应用层 传输层 ——TCP/UDP， 确定PORT 标识主机上一个进程 网络层——IP 网络地址—— 唯一标识网络的一台主机 链路层——ARP 获取MAC地址 用户层 应用层 kernel层 传输层 网络层 链路层 封装：应用层——传输层——网络层——链路层 解封装： 链路层——网络层——传输层——应用层 8.5.6 总结 mac地址 IP地址（需指定） port（需指定） 不能使用系统占用默认端口（80:万维网要用端口，8080：浏览器，5000+用户使用） 5000-65535（port范围） 9. socket编程网络通信过程中，socket一定是成对出现的； 双向半双工 -&gt; 对讲机 （从右往左，从左往后都可以。一旦其中一端指定了，另一端就也确定了） 双向全双工 -&gt; 电话 单工通信 -&gt; 遥控器 socket是一种典型的双向全双工通信，它的实现是通信的一端封装了两个channel，对外只提供一个访问接口。 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程，“IP地址+端口号”就对应一个socket，欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用socket来描述网络连接的一对一关系。 常用的socket类型有两种： 流式socket（SOCK_STREAM）和数据包式socket (SOCK_DGRAM)。 流式是一种面向连接的socket，针对于面向连接的TCP服务应用： 数据报式socket是一种无连接的socket，对应于无连接的UDP服务应用； 9.1 网络应用程序设计模式C/S模式 传统的网络应用设计模式，客户机（client）和服务器（server）模式，需要在通讯两端各自部署客户机和服务器来完成数据通信 B/S模式 浏览器（browser）/服务器（server）模式，只需要在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输 优缺点 对于C/S模式来说，其优点明显，客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活，可以在标准协议的基础上根据需求裁剪及定制。比如ftp协议的修改裁剪版； C/S模式的缺点突出，客户端和服务器都需要有一个开发团队来完成开发，工作量成倍提升，开发周期较长，从用户角度出发， 需要将客户端安插至用户主机上，对用户主机的安全性构成威胁，这也是很多用户不愿使用C/S模式应用程序的重要原因； B/S模式相比C/S模式而言，由于它没有独立客户端，使用标准浏览器作为客户端，只需要开发服务器端即可（服务端渲染页面可以理解为只开发服务器）。浏览器跨平台兼容，所以不受平台限制。 B/S的缺点就是网络应用支持受限，其他主要是浏览器本身的性能和os对比的性能差异； 9.2 TCP的C/S架构c/s架构的协议选择，TCP和UDP，TCP和UDP的差别就是在数据传输之前是否先建立好连接。TCP是先建立好连接，UDP是不建立好连接，直接传输数据。 socket 通信架构 起一个server服务器，Listen方法，该方法不是监听客户端链接。而是指定IP+port，Listen函数也创建了一个socket，但是此socket不用于通信，它只用于创建通信的socket，它保存IP和port。所以后续有客户端请求的socket进来，这个socket就copy一份出去接客； 使用Listen() 返回值创建一个 Accept，阻塞监听客户端链接 当有客户端链接进来，Accept会返回一个socket，这个socket用于通信。 此刻在client调用Dial函数，也返回一个socket，用于通信。socket在通信中成对出现 服务器判断关闭 Read读客户端，返回0， —— 对端关闭！ nc命令发送数据时，默认在结尾自带’\\n’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"fmt\" \"net\")func main() &#123; listener, err := net.Listen(\"tcp\", \"127.0.0.1:8000\") if err != nil &#123; fmt.Println(\"err=\", err) return &#125; defer listener.Close() fmt.Println(\"wait client\") for &#123; conn, err := listener.Accept() // 阻塞监听客户端连接请求 if err != nil &#123; fmt.Println(\"Accept() err:\", err) return &#125; go handlerFunc(conn) &#125;&#125;func handlerFunc(conn net.Conn) &#123; buf := make([]byte, 4096) fmt.Println(\"conn success\") for &#123; n, err := conn.Read(buf) if \"exit\\n\" == string(buf[:n]) &#123; fmt.Println(\"client exit:\") return &#125; if n == 0 &#123; fmt.Println(\"client exit:000\") return &#125; fmt.Println(n) if err != nil &#123; fmt.Println(\"conn.Read err:\", err) return &#125; defer conn.Close() fmt.Println(\"accept client:\", string(buf[:n])) &#125;&#125; 9.3 TCP通信过程三次握手（连接过程），四次挥手（断开过程） 1.为什么建立协议是三次握手,而关闭连接却是四次握手呢？ 因为是多个半关闭状态， 某一端完全写完之后可以停止发送，但没法停止接收。须等对端发完数据，发完断开请求之后，才能关闭并通知对端； 因为服务器端的LISTEN状态下的SOCKET当收到SYN报文建连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文时发送。但是关闭连接，当收到对应FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方表示同间现在可以关闭连接了，所以这里的ACK报文和FIN报文多数情况下都是分开发送的 2.为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 因为虽然对方同间关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISHED状态）但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文人一定被双方收到，因此处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来生发可能丢失的ACK报文 三次握手 主动发起请求短，发送SYN 被动建立连接请求端，应答ACK同时发送SYN 主动发送请求端，发送应答ACK 标志TCP三次握手建立完全 —— server： Accept（）返回， —— client Dial 返回 四次挥手 主动关闭连接请求，发送FIN 被动关闭连接请求端，应答ACK （标志，半关闭完成。 —— close() 被动关闭连接请求端，发送FIN 主动关闭连接请求端，应答ACK (标志，四次挥手建立完成 —— close) 9.4 TCP状态TCP状态转换图 主动发起连接请求端：CLOSED——完成三次握手——ESTABLISEHED（数据通信状态）——Dial函数返回 被动发起连接请求端：CLOSED2——调用Accept函数——LISTEN——完成三次握手——ESTABLISEHED（数据通信状态——Accept函数返回 ​ 数据传递期间——ESTABLISEHED（数据通信状态） 主动关闭连接请求端：ESTABLISEHED——FIN_WAIT_2（半关闭） ——TIME_WAIT ——2MSL——确认最后一个ACK被对端成功接收 （半关闭，TIME_WAIT，2MSL——只会出现在“主动关闭连接请求端” ） 被动关闭连接请求端： ESTABLISEHED——CLOSE 状态说明： CLOSED:表示初始状态 LISTEN:表示服务器端的某个SOCKET处于监听状态，可以接受连接了 SYN_RCVD:表示接受到了SYN报文，在正常情况下，这个状态是服务器SOCKET建立TCP连接的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这个状态，除非写一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不发送因此这个状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态 ESTABLISHED:表示连接已经建立了 FIN_WAIT_1:1和2真正的含义是表示等待对方的FIN报文，而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHE态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WATI_1状态，而当对方回应ACK报文后则进入到FIN_WAIT_2状态，当然在实际正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态比较难见，而FIN_WAIT_2状态还有时常可以用netstat看到 FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据要传送给你稍后再关闭连接 TIME_WAIT:表示收到了对方的FIN报文，并发送出ACK报文，就等2MSL后即可回到CLOSED可用状态了，如果FIN_WAID_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态 CLOSING:这种状态比较特殊，实际情况中很少见。正常情况下，发送FIN报文后，按理来说应该先收到（或同时收到）到方的ACK报文再收到对方的FIN报文，但是CLOSING状态表示你发送FIN报文后，并没有收到的收到对方的ACK报文，反而却也收到了对方的FIN报文。发生的原因：如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接 CLOSE_WAIT:表示等待关闭，当对方close一个SOCKET后发送FIN报文给自己，系统毫无疑问也会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态，接下来，实际上真正要考虑的是看你是否还有数据发送给对方，如果没有的各话，那么你也可以close这个SOCKET，发送FIN报文给对方，也即关闭连接，所以你有CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接 LAST_ACK:表示被动关闭一方在发送FIN报文后，最后等待对方的ACK报文，当收到ACK报文后，也即可以进入到CLOSED可用状态了 9.4.1 TCP状态 - 查看程序运行状态命令123456// linuxnetstat -apn|grep 8000// mac osnetstat -a lsof -i:8000 // MAC OS 查看端口情况 9.5 UDP由于UDP是“无连接”的，所以，服务器端不需要额外创建监听套接字，只需要指定好IP和port，然后监听该地址，等待客户端与之建立连接，即可通信； 12345678// 创建监听地址func ResolveUDPAddr(network, address string)(*UDPAddr, error)// 创建用户通信的socketfunc ListenUDP(network, laddr *UDPAddr)(*UDPConn, error)// 接收udp数据func (c *UDPConn)ReadFromUDP(b []byte)(int *UDPAddr, error)// 写出数据到udpfunc (c *UDPConn)WriteToUDP(b []byte, addr *UDPAddr)(int, error) UDP通信 无连接的，不可靠的报文传递，UDP因为无连接，所以线路取决于网络，网络状况会导致UDP丢包；只不过UDP的丢包问题系统层面不会执行重传；因此弥补这一缺陷需要在应用层对数据包进行校验；（需要封装针对UDP底层传输丢包问题的协议） TCP通信： 面向连接的，可靠的数据包传输，不是说TCP不丢包，而是说TCP丢包之后会重传，这个重传指令是系统层面在做； 9.5.1 udp通信流程 创建用于通信的socket 阻塞读socket 处理读到的数据 写数据给客户端 9.5.2 udp通信1234567891011121314151617181920212223242526272829303132// serverfunc main() &#123; udpsev, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:8001\") if err != nil &#123; fmt.Println(\"ResolveUDPAddr err:\", err) return &#125; conn, err := net.ListenUDP(\"udp\", udpsev) if err != nil &#123; fmt.Println(\"ListenUDP err:\", err) return &#125; defer conn.Close() buf := make([]byte, 4096) n, cltAddr, err := conn.ReadFromUDP(buf) if err != nil &#123; fmt.Println(\"ReadFromUDP\", err) return &#125; fmt.Println(\"buf...\", string(buf[:n])) _, err = conn.WriteToUDP([]byte(\"hi udp client\"), cltAddr) fmt.Println(\"not got\") if err != nil &#123; fmt.Println(\"writeToUdp\", err) return &#125;&#125; 12345678910111213141516171819// clientfunc main() &#123; conn, err := net.Dial(\"udp\", \"127.0.0.1:8001\") if err != nil &#123; fmt.Println(\"net.Dial err:\", err) return &#125; defer conn.Close() conn.Write([]byte(\"from client\")) buf := make([]byte, 4096) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"Read err:\", err) return &#125; fmt.Println(\"server send\", string(buf[:n]))&#125; 12//client nc默认是TCP的，加上-u参数表示udp$&gt; nc -u 127.0.0.1 \"port\" UDP服务器： 创建server端地址结构 net.ResolveUDPAddr() 创建用于通信的socket，绑定地址结构 udpConn = net.ListenUDP() Defer udpConn.Close() 读取客户端发送数据 ReadFromUDP() 返回： n, cltAddr(客户端的IP+port)，err 写数据给客户端 WriteToUDP(“待写数据”，cltAddr) UDP客户端： 参考TCP客户端 Net.Dial(“udp”, server的IP+PORT) 9.6 UDP与TCP的差异 TCP UDP 面向连接 面向无连接 要求系统资源较多（系统需要一套资源维护TCP协议） 要求系统资源较少 TCP程序结构比较复杂 UDP程序结构较简单 使用流式（建立通道后源源不断的写） 使用数据包式（单次发送就完事了） 保证数据准确性（回执机制） 不保证数据准确性（数据包的路径每次都可能不一样） 保证数据顺序 不保证数据顺序 通讯速度较慢 通讯速度较快 TCP： 对不稳定网络层，做完全弥补操作 UDP： 对不稳定的网络层，不作为 使用场景： TCP：对数据传输安全性 稳定性要求较高的场合，网络文件传输，下载，上传。 UDP：对数据实时传输要求较高的场合，视频直播 在线电话会议，游戏 9.7 文件传输流程简析 借助TCP完成文件的传输， 发送方向服务端发送文件名，服务端保存该文件名 接收方（服务端）向客户端返回一个消息ok，确认文件名保存成功 发送方（客户端）收到消息后，开始向服务端发送文件数据 接收方（服务端）读取文件内容，写入到之前保存好的文件中； 首先获取文件名，借助os包中stat函数来获取文件属性信息。在函数返回的文件属性中包含文件名和文件大小、Stat参数name传入的是文件访问的绝对路径。FileInfo中的Name函数可以将文件名单提取出来； 12345678910func Stat(name string) (FileInfo, error)// A FileInfo describes a file and is returned by Stat and Lstat.type FileInfo interface &#123; Name() string // base name of the file Size() int64 // length in bytes for regular files; system-dependent for others Mode() FileMode // file mode bits ModTime() time.Time // modification time IsDir() bool // abbreviation for Mode().IsDir() Sys() interface&#123;&#125; // underlying data source (can return nil)&#125; 9.7.1 文件属性12345678910111213141516func main() &#123; list := os.Args if len(list) != 2 &#123; fmt.Println(\"\") return &#125; path := list[1] fileInfo, err := os.Stat(path) if err != nil &#123; fmt.Println(\"os.Stat err:\", err) return &#125; fmt.Println(fileInfo.Name(), fileInfo.Size()) // cl.go 285&#125; 9.7.2 send 提示用户使用命令行参数输入文件名，接收文件名filepath（含访问路径） 使用os.Stat（）获取文件属性，得到纯文件名fileName（去除访问路径） 主动发送链接服务器请求，结束时关闭连接 发送文件名到接收端conn.Write() 读取接收端回发的确认数据conn.Read() 判断是否为“ok”，如果是，封装函数SendFile()发送文件内容，传参filePath 和conn 只读Open文件，结束时Close文件 循环读本地文件，读到EPF，读取完毕 将读到的内容原封不动conn.Write给接收端（服务器） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172func sendFile(conn net.Conn, filePath string) &#123; // open file by readOnly f, err := os.Open(filePath) if err != nil &#123; fmt.Println(\"open file err:\", err) return &#125; defer f.Close() // core, use buf loop the data until EOF buf := make([]byte, 4096) for &#123; n, err := f.Read(buf) if err != nil &#123; if err == io.EOF &#123; fmt.Println(\"file send complete:\", err) return &#125; else &#123; fmt.Println(\"Read file err:\", err) return &#125; &#125; // write to net _, err = conn.Write(buf[:n]) if err != nil &#123; fmt.Println(\"is.Stat err:\", err) return &#125; &#125;&#125;func main() &#123; list := os.Args if len(list) != 2 &#123; fmt.Println(\"\") return &#125; path := list[1] fileInfo, err := os.Stat(path) if err != nil &#123; fmt.Println(\"os.Stat err:\", err) return &#125; fileName := fileInfo.Name() fileSize := fileInfo.Size() fmt.Println(\"fileName=\", fileName, \"fileSize=\", fileSize) conn, err := net.Dial(\"tcp\", \"127.0.0.1:8009\") if err != nil &#123; fmt.Println(\"dial tcp err:\", err) return &#125; defer conn.Close() // send file name to recv _, err = conn.Write([]byte(fileName)) if err != nil &#123; fmt.Println(\"conn Write err:\", err) return &#125; // read \"OK\" buf := make([]byte, 4096) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"conn read err:\", err) return &#125; if string(buf[:n]) == \"OK\" &#123; sendFile(conn, path) &#125;&#125; 9.7.3 recv 创建监听socket，程序结束时关闭 阻塞等待发送端连接Accept，程序结束时关闭conn 接收（读取）文件名，保存 回发ok 封装函数RecvFile接收客户端发送的文件内容，传参fileName和conn 按文件名creat文件，结束时close 循环read发送端网络文件内容，当读到0说明文件读取完毕 将读到的内容原封不动的Write到创建的文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func recvFile(conn net.Conn, filename string) &#123; // create file deps filename f, err := os.Create(filename) if err != nil &#123; fmt.Println(\"os.Create err:\", err) return &#125; defer f.Close() // get data from socket and write in file buf := make([]byte, 4096) for &#123; n, _ := conn.Read(buf) if n == 0 &#123; fmt.Println(\"receive file complete\") return &#125; // write into local file f.Write(buf[:n]) &#125;&#125;func main() &#123; listener, err := net.Listen(\"tcp\", \"127.0.0.1:8009\") if err != nil &#123; fmt.Println(\"listen tcp err:\", err) return &#125; defer listener.Close() conn, err := listener.Accept() if err != nil &#123; fmt.Println(\"conn err:\", err) return &#125; defer conn.Close() // require filename and save buf := make([]byte, 4096) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"conn Read:\", err) return &#125; filename := string(buf[:n]) fmt.Println(\"filename=\", filename) // send \"ok\" _, err = conn.Write([]byte(\"OK\")) if err != nil &#123; fmt.Println(\"write Ok err:\", err) &#125; // require file content recvFile(conn, filename)&#125; 10. HTTPweb工作方式： 客户端——&gt; 访问www.xxx.域名-&gt; DNS服务，返回对应IP 客户端——》 IP+port -〉 访问网页数据（TCP连接，HTTP协议） http和URL：http 规定了浏览器访问服务器进行数据通信的规则。http —— TLS、ssl——https URL： http请求包： 请求行： 请求方法（空格）请求文件URL（空格）协议版本（\\r\\n） 请求头：key:value 空行：\\r\\n —— 代表http请求头结束 10.1 HTTP服务创建流程1234// 注册处理函数，设置回调函数handlerhttp.HandleFunc()// 绑定服务器监听地址 http.ListenAndServe() Do: 静态文件服务器： 选定一个目录，存放jpg，png，txt，gif,m4a等类型文件，编写一饿服务器程序，可以给浏览器提供该目录下文件的访问服务； 1234func main()&#123; resp, err := http.Get(\"http://xxx\") defer resp.Body.Close() // 关闭resp.Body 而不是 resp&#125; 123456789101112for &#123; n,err:=resp.Body.Read(buf) if n==0 &#123; // 网络环境，通常用0去判断是否结尾。因为channel的缘故 fmt.Println(\"Read finish!\") break &#125; if err!= nil &amp;&amp; err != io.EOF &#123; // 本地文件读取，通常用EOF fmt.Println(\"\") return &#125; result += string(buf[:n])&#125;","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"go_web","slug":"go-web","date":"2021-03-16T10:12:02.000Z","updated":"2021-03-24T12:09:32.776Z","comments":true,"path":"2021/03/16/go-web/","link":"","permalink":"http://yoursite.com/2021/03/16/go-web/","excerpt":"","text":"1. 概要处理请求 模版 中间件 存储数据 HTTPS，HTTP2 测试 部署 2. 处理请求2.1 Create pro创建模块 GO111MODULE=on go mod init pro name helloworld 1234567891011package mainimport \"net/http\"func main() &#123; http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"hi go web\")) &#125;) http.ListenAndServe(\"localhost:8999\", nil)&#125; 2.2 如何处理web请求http.Handle 函数 http.HandleFunc 函数 2.2.1 创建web Server两种方式 方式一 http.ListenAndServer() http.ListenAndServeTLS() https 服务 第一个参数是网络地址， 第二个参数为handler 如果为nil，那么就是DefaultServeMux DefaultServeMux 是一个multiplexer（可以看作是一个路由器） 1http.ListenAndServe(\"localhost:8989\", nil) 方式二 http.Server可配置 server.ListenAndServe() server.ListenAndServeTLS() 12345server:= http.Server &#123; Addr: \"localhost:8989\", Handler: nil&#125;server.ListenAndServe() 2.2.2 DefaultServeMux它是一个multiplexer 多路复用器 它也是一个handler 1234567891011121314151617package mainimport \"net/http\"type myHandler struct&#123;&#125;func (m *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"myHandler\"))&#125;func main() &#123; mu := myHandler&#123;&#125; server := http.Server&#123; Addr: \"localhost:8989\", Handler: &amp;mu, &#125; server.ListenAndServe()&#125; 多个handler 不指定Server struct里面的Handler字段值 可以使用http.Handle将某个Handler附加到DefaultServeMux http包有一个Handle函数 ServerMux struct也有一个Handle方法 如果你调用http.Handle，实际上调用的是DefaultServeMux上的Handle方法 1234func Handle(patten string, handler Handler) // 注册函数type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; 1234567891011121314151617181920212223242526package mainimport \"net/http\"type myHandler struct&#123;&#125;func (m *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"myHandler\"))&#125;type hiHandler struct&#123;&#125;func (m *hiHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"hello handler\"))&#125;func main() &#123; mu := myHandler&#123;&#125; hi:= hiHandler&#123;&#125; server := http.Server&#123; Addr: \"localhost:8989\", Handler: nil, &#125; http.Handle(\"/mu\", &amp;mu) http.Handle(\"/hi\", &amp;hi) server.ListenAndServe()&#125; 2.2.3 Handler 函数 - http.HandleFunchandler是一个接口（interface） 123type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; Handler函数就是那些行为与handler类似的函数： Handler函数的签名与ServeHTTP方法的签名一样，接收： 一个http.ResponseWriter 一个指向http.Request的指针 Go有一个函数类型： HandlerFunc，可以将某个具有适当签名的函数f， 适配成为一个Handler，而这个Handler具有方法 f 12345678910111213141516171819202122232425262728293031package mainimport \"net/http\"type myHandler struct&#123;&#125;func (m *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"myHandler\"))&#125;type hiHandler struct&#123;&#125;func (m *hiHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"hello handler\"))&#125;func welcome (w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"weclome\"))&#125;func main() &#123; mu := myHandler&#123;&#125; hi:= hiHandler&#123;&#125; server := http.Server&#123; Addr: \"localhost:8989\", Handler: nil, &#125; http.Handle(\"/mu\", &amp;mu) http.Handle(\"/hi\", &amp;hi) //http.HandleFunc(\"/weclome\", welcome) http.Handle(\"/wel\", http.HandlerFunc(welcome)) // handleFunc 函数内部有适配器 handlerFunc server.ListenAndServe()&#125; 适配器HandlerFunc 123456type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP calls f(w, r).func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123; f(w, r)&#125; 2.2.4 五个内置handlerNotFoundHandler 404 RedirectHandler 返回一个handler，把每个请求使用给定的状态吗跳转到指定的URl url，要跳转到的URL code，跳转的状态吗（3XX），常见的 StatusMovedPermanently， StatusFound 或 StatusSeeOther StripPrefix 返回一个handler，它从请求URL中去掉指定的前缀，然后再调用另一个handler TimeoutHandler FileServer 1func FileServer(root FileSystem) Handler 返回一个handler，使用基于root的文件系统来相应请求 123type FileSystem interface &#123; Open(name string)(File, error)&#125; 使用时需要用到操作系统的文件系统，所以还需要委托给操作系统的文件系统来获取文件； 12type Dir stringfunc (d Dir) Open(name string)(File,error) 123456789101112package mainimport \"net/http\"func main() &#123; //http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) &#123; // fmt.Printf(request.URL.Path) // http.ServeFile(writer, request, \"/webroot\"+request.URL.Path) //&#125;) //http.ListenAndServe(\":8000\", nil) http.ListenAndServe(\":8000\", http.FileServer(http.Dir(\"webroot\")))&#125; 2.2.5 RequestHTTP请求 Request URL Header Body 2.2.5.1 HTTP消息HTTP Request 和 HTTP Response 它们具有相同的结构 请求（响应）行 0个或多个Header 空行 可选的消息体（Body） net/http 包提供了用于表示HTTP消息的结构 Request（是个struct），代表了客户端发送的HTTP请求消息 Request（是个struct），代表了客户端发送的HTTP请求消息 重要字段： URL Header Body Form，PostForm，MultipartForm 也可以通过Request的方法访问请求中的Cookie、URL、User Agent等消息 Request即可代表发送到服务器的请求，又可代表客户端发出的请求； 2.2.5.2 请求URLRequest的URL字段就代表了请求行（请求信息第一行）里面的部分内容 URL字段是指向url.URL类型的一个指针，url.URL是一个struct： 123456789type URL struct &#123; Scheme string Opaque string User *Userinfo Host string Path string RawQuery string Fragment string&#125; URL通用形式 scheme://[userinfo@]host/path[?query][#fragment] 不可以斜杠开头的URL被解释为： scheme:opaque[?query][#fragment] 2.2.5.3 URL QueryRawQuery 会提供实际查询的字符串 http://www.example/com/post?id=123&amp;thread_id=456 它的RawQuery的值就是id=123&amp;thread_id=456 还有一个简便的方法可以得到Key-Value对： 通过Request的Form字段 2.2.5.4 URL Fragment如果从浏览器发出的请求， 那么你无法提取出Fragment字段的值； 浏览器在发送请求时会把fragment部分去掉 但不是所有的请求都是从浏览器发出的（例如从HTTP客户端包） 2.2.5.5 Request Header请求和响应（Request、Response）的headers是通过Header类型来描述的，它是一个map，用来表述HTTP Header里的 Key-Value对； Header map的key是string类型，value是[]string 设置key的时候会创建一个空的[]string 作为value，value里面第一个元素就是新header的值； 为指定的key添加一个新的header值，执行append操作即可 res.Header 返回map r.Header[“Accept-Encoding”] 返回：[gzip,deflate]([]string类型) r.Header.Get(“Accept-Encoding”) 返回： gzip，deflate(string类型) 2.2.5.6 Request Body请求和响应的bodies都是使用Body字段来表示的 Body是一个io.ReadCloser接口 一个是Reader接口 一个是Closer接口 Reader接口定义了一个Open方法： 参数： []byte 返回：byte的数量、可选的错误 Closer接口定义了一个Close方法： 没有参数，返回可选的错误； 想要读取请求body的内容，可以调用Body的Read方法 12345678910111213141516 server := http.Server&#123; Addr: \":8989\", &#125; http.HandleFunc(\"/header\", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, r.Header) fmt.Fprintln(w, r.Header[\"Accept-Encoding\"]) fmt.Fprintln(w, r.Header.Get(\"Accept-Encoding\")) &#125;) http.HandleFunc(\"/post\", func(w http.ResponseWriter, r *http.Request) &#123; length := r.ContentLength body := make([]byte, length) // 创建一个长度为ContentLength的 byte slice r.Body.Read(body) // 将Body里面的内容，通过Read方法读取到body中 fmt.Fprintln(w, string(body)) &#125;) server.ListenAndServe()&#125; 2.2.5.7 查询参数（Query Parameters）URL Query http://www/example.com/post?id=123&amp;thread_id=456 r.URL.RawQuery会提供实际查询的原始字符串 上例的RawQuery的值就是 id=123&amp;thread_id=456 r.URL.Query() 会提供查询字符串对应的 map[string][]string 1234url := r.URLquery := url.Query() // map[string][]stringid := query[\"id\"] // []string&#123;\"123\"&#125;threadID := query.Get(\"thread_id\") // \"456\" 2.2.6 Form2.2.6.1 通过表单发送请求12345&lt;form action=\"/process\" method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 这个HTML表单里面的数据会以name-value对的形式，通过POST请求发送出去 它的数据内容会放在POST请求的Body里面 但name-value对在Body里面的格式是什么样的？ 表单Post请求的数据格式 通过POST发送的name-value数据对的格式可以通过表单的Content Type来指定，也就是enctype属性 表单的enctype属性 默认值是：application/x-www-form-urlencoded 浏览器被要求至少要支持： application/x-www-form-urlencoded、multipart/form-data html5的话，还需要支持text/plain 如果enctype是application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。 first_name=alex&amp;last_name=chang 如果enctype是multipart/form-data，那么 每一个name-value对都会被转换为一个MIME消息部分 每一个部分都有自己的Content Type 和Content Disposition 如何选择？ 简单的文本： application/x-www-form-urlencoded 大量数据，（文件上传）： multipart-MIME 甚至可以把二进制数据通过选择Base64编码，来当作文本进行发送 表单的GET 通过表单的method属性，可以设置POST还是GET GET请求没有Body，所有的数据都通过URL的name-value对 来发送 2.2.6.2 字段Request上的函数允许我们从URL或/和Body中提取数据，通过这些字段：Form，PostForm，MultipartForm Form里面的数据是key-value对 通常的做法是： 先调用ParseForm 或 ParseMultipartForm来解析Request 然后相应的访问Form、PostForm或MultipartForm字段 Form 12345&lt;form action=\"/process\" method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() // 解析form fmt.Fprintln(w, r.Form)&#125;) PostForm 上例中，如果只想得到first_name 这个key 的value，可使用r.Form[“first_name”],它返回含有一个元素的slice: [“Dave”] 如果表单和URL里有同样的Key，那么它们都会放在一个slice里：表单里的值靠前，URL的值靠后； 如果只想要表单的key-value对，不要URL的，可以使用PostForm字段； 12345&lt;form action=\"/process?first_name=Leo\" method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234567http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() // 解析form fmt.Fprintln(w, r.Form) // map[first_name:[alex Leo] last_name:[ruan]] fmt.Fprintln(w, r.PostForm) // map[first_name:[alex] last_name:[ruan]]&#125;) PostForm只支持application/x-www-form-urlencoded，必须使用MultipartForm MultipartForm 想要使用MultipartForm 这个字段，首先需要调用ParseMultipartForm这个方法； 该方法会在必要时调用ParseForm方法 参数是需要读取数据的长度 MultipartForm只包含表单的key-value对 返回的类型是一个struct而不是map，这个struct里有两个map： key是string，value是[]string 空的（key是string， value是文件） 12345&lt;form action=\"/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 12345http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseMultipartForm(1024) //1024 为字节数 fmt.Fprintln(w, r.MultipartForm)&#125;)// &amp;&#123;map[first_name:[alex] last_name:[ruan]] map[]&#125; MultipartReader 1func (r *Request)MultipartReader()(*multipart.Reader,error) 如果是multipart/form-data或multipart混合的POST请求： MultipartReader 返回一个MIME multipart reader 否则返回nil和一个错误 可以使用该函数代替ParseMultipartForm来把请求的body作为stream进行处理 不是把表单作为一个对象来处理的，不是一次性获得整个map 逐个检查来自表单的值，然后每次处理一个； 2.2.6.3 FormValue &amp; PostFormValue方法FormValue方法会返回Form字段中指定key对应的第一个value 无需调用ParseForm或ParseMultipartForm 12345&lt;form action=\"http://localhost:8000/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, r.FormValue(\"first_name\"))&#125;)// Leo 来自于查询字符串，来自表单里面的值靠前，来自url的靠后，FormValue只取一个值（如果enctype为application/x-www-form-urlencoded的话）； PostFormValue方法也一样，但只能读取PostForm FormValue和PostFormValue都会调用ParseMultipartForm方法 但如果表单的enctype设为multipart/form-data，那么即使你调用ParseMultipartForm方法，也无法通过FormValue获得想要的值； 12345&lt;form action=\"http://localhost:8000/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234567http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseMultipartForm(1024) //1024 为字节数 fmt.Fprintln(w, r.FormValue(\"first_name\")) fmt.Fprintln(w,r.PostFormValue(\"first_name\"))&#125;)// Leo// alex 2.2.6.4 上传文件（Files）Multipart/form-data最常见的应用场景就是上传文件（例子） 12345&lt;form action=\"http://localhost:8000/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"io/ioutil\" \"net/http\")func process(w http.ResponseWriter, r *http.Request) &#123; r.ParseMultipartForm(1024) fileHeader:= r.MultipartForm.File[\"uploaded\"][0] file,err := fileHeader.Open() // 从File字段 获得的FileHeader，调用其Open获得文件。 if err == nil &#123; data, err := ioutil.ReadAll(file) // 读取文件内容到byte切片里 if err == nil &#123; fmt.Fprintln(w, string(data)) &#125; &#125;&#125;func main() &#123; server := http.Server&#123; Addr: \":8000\", &#125; http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) &#123; fmt.Printf(request.URL.Path) http.ServeFile(writer, request, \"webroot2\"+request.URL.Path) &#125;) http.HandleFunc(\"/process\", process) server.ListenAndServe()&#125; FormFile方法 上传文件还有一个简便方法：FormFile 123456789func process(w http.ResponseWriter, r *http.Request)&#123; file,_,err := r.FormFile(\"uploaded\") if err == nil &#123; data, err := ioutil.ReadAll(file) if err == nil &#123; fmt.Fprintln(w, string(data)) &#125; &#125;&#125; 无需调用ParseMultipartForm方法 返回指定key对应的第一个value 同时返回File和FileHeader，以及错误信息 如果只上传一个文件，那么这种方式会快一些 2.2.6.5 POST JSON不是所有的POST请求都来自Form 有很多不同的方式对POST请求编码 application/x-www-form-urlencoded application/json ParseForm方法无法处理application/json 2.2.7 ResponseWriter从服务器向客户端返回响应需要使用ResponseWriter ResponseWriter是一个接口，handler用它来返回响应 真正支撑ResponseWriter的幕后struct是非导出的http.response 问题： 为什么Handler的ServeHTTP（w ResponseWriter, r*Request）,只有一个是指针类型？而w是按值传递的吗？ ResponseWriter本身是一个interface，而它代表了一个指针，这个指针指向response这个struct的。所以它也可以看作是一个指针。所以它的传递也是按引用进行传递的； 123456789101112type ResponseWriter interface &#123; Header() Header Write([]byte)(int error) WriteHeader(statusCode int)&#125;type response struct &#123; ...&#125;func (w *response) Header()Headerfunc (w *response) Write()Writerfunc (w *response) WriteHeader()WriteHeader// 所以说 response指针就是实现了ResponseWriter接口，所以ResponseWriter接口就代表着 response指针； 2.2.7.1 写入到ResponseWriterwrite方法接收一个byte切片作为参数，然后把它写入到HTTP响应的Body里面； 如果在Write方法被调用时，header里面没有设定content type，那么数据的前512字节就会被用来检测content type 12345678910111213141516func writeExample(w http.ResponseWriter, r *http.Request) &#123; str := `&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;go web&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;`w.Write([]byte(str))&#125;func main() &#123; server := http.Server&#123; Addr: \":8000\", &#125; http.HandleFunc(\"/write\", writeExample) server.ListenAndServe()&#125; 1curl -i localhost:8000/write 2.2.7.2 WriteHeader方法WriteHeader方法接收一个整数类型（HTTP状态码）作为参数，并把它作为HTTP响应的状态码返回 如果该方法没有显式调用，那么在第一次调用Write方法前，会隐式的调用WriteHeader(http.StatusOK) 所以WriteHeader主要用来发送错误类的HTTP状态吗 调用完WriteHeader方法之后，仍然可以写入到ResponseWriter，但无法再修改header了； 123456789101112131415161718192021func writeExample(w http.ResponseWriter, r *http.Request) &#123; str := `&lt;html&gt;&lt;head&gt;&lt;title&gt;go cProgramming&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;`w.Write([]byte(str))&#125;func writeHeaderExample(w http.ResponseWriter, r *http.Request)&#123; w.WriteHeader(501) fmt.Fprintln(w, \"No such service, try next port\")&#125;func main() &#123; server := http.Server&#123; Addr: \":8000\", &#125; http.HandleFunc(\"/write\", writeExample) http.HandleFunc(\"/writeheader\", writeHeaderExample) server.ListenAndServe()&#125; 2.2.7.3 Header方法Header方法返回headers的map，可以进行修改 修改后的headers将会体现在返回给客户端的HTTP响应里； 1234func headerExample(w http.ResponseWriter, r *http.Request)&#123; w.Header().Set(\"Location\",\"https://reactnative.dev/\") w.WriteHeader(302)&#125; json 12345678910func jsonExample(w http.ResponseWriter, r *http.Request)&#123; w.Header().Set(\"Content-Type\",\"application/json\") post:= &amp;Post&#123; User: \"alex\", Threads: []string&#123;\"first\",\"second\",\"third\"&#125;, &#125; json,_ := json2.Marshal(post) w.Write(json)&#125;// &#123;\"User\":\"alex\",\"Threads\":[\"first\",\"second\",\"third\"]&#125; 2.2.7.4 内置的ResponseNotFound函数，包装一个404状态吗和一个额外的信息 ServeFile函数，从文件系统提供文件，返回请求者 ServerContent函数，它可以把实现了io.ReadSeeker接口的任何东西里面的内容返回给请求者 还可以处理Range请求（范围请求），如果只请求了资源的一部分内容，那么ServeContent就可以如此响应，而ServeFile或io.Copy则不行 Redirect函数，告诉客户端重定向到另一个URL 3.connect sql3.1 Opensql.Open() 参数1 数据库驱动名称 参数2 数据源名称 返回值 得到一个指向sql.DB这个struct的指针 sql.DB是用来操作数据库的，它代表了0个或者多个底层连接的池，这些连接由sql包来维护，sql包会自动的创建和释放这些连接； 它对于多个goroutine并发的使用是安全的； Open()函数并不会连接数据库，甚至不回验证其参数，它只是把后续连接到数据库所必需的structs给设置好了； 而真正的连接是在被需要的时候才进行懒设置的； sql.DB不需要进行关闭（当然你想关闭也是可以的） 它就是用来处理数据库的，而不是实际的连接 这个抽象包含了数据库连接的池，而且会对此进行维护 在使用sql.DB的时候，可以定义它的全局变量进行使用，也可以将它传递函数/方法里； 3.2 如何获得驱动正常的做法是使用sql.Register()函数、数据库驱动的名称和一个实现了driver.Driver接口的struct，来注册数据库的驱动。 1sql.Register(\"sqlserver\", &amp;drv&#123;&#125;) 但是之前的例子却没有写这句话，为什么？ 因为Sql Server的驱动，是在这个包被引入的时候进行了自我注册 1234import ( _ \"github.com/go-sql-driver/mysql\") 当go-sql-driver包被引入的时候，它的init函数将会运行并进行自我注册（在Go语言里，每个包的init函数都会在自动的调用） 在引入go-sql-driver 包的时候，把该包的名称设置为下划线_，这是因为我们不直接使用数据库驱动（只需要它起的“副作用”），我们只使用database/sql 这样，如果未来升级驱动，也无需改变代码 Go语言没有提供官方的数据库驱动，所有的数据库驱动都是第三方驱动，但是它们都遵循sql.driver包里面定义的接口 3.3 下载驱动go get github.com/go-sql-driver/mysql 3.4 PingContext1func (*DB) PingContext db.PingContext 函数是用来验证与数据库的连接是否仍然有效，如有必要则建立一个连接 这个函数需要一个Context（上下文）类型的参数，这种类型可以携带截止时间，取消信息和其它请求范围的值，并且可以横跨API边界和进程。 上例中，创建context使用的是context.Background()函数，该函数返回一个非nil的空Context，它不会被取消，它没有值，没有截止时间； 它通常在main函数，初始化或测试中，作为传入请求的顶级Context 123456ctx := context.Background()err = db.PingContext(ctx)if err != nil &#123; log.Fatalln(err.Error())&#125;fmt.Println(\"Connected\") 3.5 查询sql.DB类型上用于查询的方法有： Query QueryRow （返回一行） QueryContext QueryRowContext 3.5.1 Query返回的类型是 type Rows struct{} Rows的方法： 12345678910111213func (rs *Rows) Close() error// 返回结果的列的信息func (rs *Rows) ColumnTypes()([]*ColumnType, error)// 返回所有列名func (rs *Rows) Columns()([]string, error)// 查询遍历中的错误func (rs *Rows) Err() error// 遍历结果集，每次读取一行，返回true说明还有数据 false表示读到最后一行了func (rs *Rows) Next() bool// 如果查询包含多个结果集，使用NextResultSet。它会准备好下一个结果集用来读取。func (rs *Rows) NextResultSet() bool// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；func (rs *Rows) Scan(dest...interface&#123;&#125;) bool 3.5.2 QueryRow返回类型是 type Row struct{} 1234// 查询遍历中的错误func (rs *Rows) Err() error// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；func (rs *Row) Scan(dest...interface&#123;&#125;) bool 3.6 更新sql.DB类型上用于更新（执行命令）的方法有： Exec ExecContext 123func (a * app)Update()(err error) &#123; _,err := db.Exc(\"sql 语句\")&#125; 3.7 其它Ping PingContext Prepare PrepareContext Transactions Begin BeginTx 4. 路由需要给架构增加Controller层 Controller的角色 main(): 设置类工作，比如设置http server Controller: 静态资源 （比如css，js文件） 把不同的请求送到不同的controller进行处理 go语言提供一个前置的ctrl，所有进来的请求都会经过ctrl，然后由ctrl分发 5. json12345type Post struct &#123; ID int `json:\"id\"` User string `json:\"user\"` Threads []string `json:\"thread\"`&#125; 5.1 类型映射1234Go bool: JSON booleanGo float64: JSON 数值Go string; JSON stringsGo nil: JSON null 5.2 未知结构的JSON如何映射Map[string]interface{} 可以存储任意json对象 []interface{} 可以存储任意的JSON数组 5.3 读取JSON需要一个解码器： 1dec := json.NewDecoder(r.Body) 参数需要实现Reader接口 在解码器上进行编码： dec.Decode(&amp;query) 5.4 写入JSON需要一个编码器 1enc := json.NewEncoder(w) 参数需要实现Writer接口 编码 ： enc.Encode(results) 1234567891011121314151617181920212223func json(w http.ResponseWriter, r *http.Request)&#123; switch r.Method &#123; case http.MethodPost: dec := json2.NewDecoder(r.Body) company := Company&#123;&#125; err:= dec.Decode(&amp;company) if err != nil &#123; log.Println(err.Error()) w.WriteHeader(http.StatusInternalServerError) return &#125; enc := json2.NewEncoder(w) err = enc.Encode(company) if err != nil &#123; log.Println(err.Error()) w.WriteHeader(http.StatusInternalServerError) return &#125; default: w.WriteHeader(http.StatusMethodNotAllowed) &#125;&#125; Marshal 和 Unmarshal Marshal （编码）： 把go struct转化为json格式 Marshalindent, 带缩进 Unmarshal（解码）： 把json转化为go struct 1234567891011121314151617181920212223242526272829303132type Company struct &#123; ID int `json:\"id\"` User string `json:\"user\"` Threads []string `json:\"thread\"`&#125;func main()&#123; jsonStr := `&#123; \"id\": 123, \"name\": \"alex\", \"thread\": \"asia\" &#125;` c:= Company&#123;&#125; _ = json2.Unmarshal([]byte(jsonStr), &amp;c) fmt.Println(c) bytes,_ := json2.Marshal(c) fmt.Println(string(bytes)) bytes1, _ := json2.MarshalIndent(c,\"\",\" \") fmt.Println(string(bytes1))&#125;//&#123;123 alex [asia]&#125;//&#123;\"id\":123,\"user\":\"alex\",\"thread\":[\"asia\"]&#125;&#123; \"id\": 123, \"user\": \"alex\", \"thread\": [ \"asia\" ]&#125; 两种方式的区别 针对string或bytes： Marshal =&gt; string Unmarshal &lt;= string 针对stream： Encode =&gt; Stream, 把数据写入到 io.Writer Decode &lt;= Stream, 从io.Reader 读取数据 6. 中间件 12http.ListenAndServe(addr string, handler Handler)error// handler 如果是nil： DefaultServeMux 1234// 想创建handler，必须实现handler接口，需要实现ServeHTTP这个方法type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; 6.1 创建中间件12345678type MyMiddleware struct &#123; Next http.Handler&#125;func (m MyMiddleware) ServeHTTP (w http.ResponseWriter, r *http.Request) &#123; // 在next handler之前做一些事情 m.Next.ServeHTTP(w, r) // 将该请求转发到下一个handler中 // 在 next handler之后做一些其它事情（对响应进行处理，中间件中创建的资源进行处理，此时响应仍然是没有返回至客户端的）&#125; m.Next.ServeHTTP(w, r) 将该请求转发到下一个handler中。至于下一个handler是什么，这个Next设置成什么，下一个handler就是什么，有可能是nil。在web应用中，如果只有一个中间件的话。那么next就是DefaultServeMux。它就会将这个请求 进行路由。然后进程的处理。 中间件的用途 Logging 安全（请求超时，用户身份认证） 响应压缩 6.2 使用请求上下文 比如中间件设置了请求超时，而这个请求到数据库的时候，这个数据库将会花费很长时间。这个时候就需要让访问数据库的代码知道设置了查询超时时间。这就需要使用到上下文来解决； 1234func (*Request) Context() context.Context// 返回当前请求的上下文func (*Request) WithContext(ctx context.Context)context.Context// 基于Context 进行 修改，（实际上）创建一个新的Context 123456789type Context interface &#123; Deadline() (deadline time.Time, ok bool) // 返回一个channel，用来做取消操作的。一旦context取消了。它就会接收到一个信号。这个channel也就关闭了；。比如在操作截止时间就会接到这个信号 Done() &lt;-chan struct&#123;&#125; // 取消操作 // 如果 Done 这个channel没有关闭的话，error就是nil，如果它关闭了，也就是context被取消了。那么error就存放被取消的原因；以后每次调用error都会显示同一个错误； Err()error // 使用参数key从context获取一些信息，得到的这些信息可以从架构中的一个层传给另一个层； Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 这些方法都是用于读取，不能进行设置； Context API - 可以返回新Context WithCancal() ,它有一个CancelFunc WithDeadline(), 带有一个时间戳 （time.Time） WithTimeout(), 带有一个具体的时间段（time.Duration） WithValue(), 在里面可以添加一些值； 7. HTTPSHTTP请求的过程 在http里面，参数都是以明文进行传输的。在客户端和服务端之间其它的东西，比如某个中间人/中间服务器也能懂得传输的信息。所以说，这种传输是非常不安全的 ； HTTPS https会稍微给传输层做一点改变，它不是直接在TCP上面传输数据的。会添加一个TLS层，在传输数据的时候，数据首先会被加密。加密之后只有客户端和服务器能够懂得这个加密数据里面真实的内容。中间人/中间服务器即使能获得数据，但是依然无法解析出来内容；也就无法懂得它真正代表的意思了； 7.1 HTTP.ListenAndServeTLS123456// ListenAndServeTLS 四个参数addrcertFilekeyFilehandlerhttp.ListenAndServeTLS() go 提供了生成证书的方法 12345678go run /usr/local/go/src/crypto/tls/generate_cert.go -hgo run /usr/local/go/src/crypto/tls/generate_cert.go -host localhost# time wrote cert.pem# time wrote key.pemhttp.ListenAndServeTLS(\":8080\", \"cert.pem\", \"key.pem\", nil) 12345678910111213141516171819Request Headers :authority: localhost:8080 :method: GET :path: /json :scheme: https accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache cookie: pragma: no-cache sec-ch-ua: \"Google Chrome\";v=\"89\", \"Chromium\";v=\"89\", \";Not A Brand\";v=\"99\" sec-ch-ua-mobile: ?0 sec-fetch-dest: document sec-fetch-mode: navigate sec-fetch-site: none sec-fetch-user: ?1 upgrade-insecure-requests: 1 user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36 Headers 以：开头，在go web应用里面，如果从http转到https，那么此应用会自动从http1.1 升级到http2协议。 8. HTTP/2http2带来效率提升的原因 Http1.1发送请求 首先建立tcp连接 发送请求时，通常header 和 body捆绑在一起发送的。尽管有时候body比较大，会被分到不同的包中发送。 响应返回的时候，基本和请求类似，也是header和body捆绑发送； 这就导致header无法被压缩，header描述了请求或者响应里面的内容比如content-type，length等等，有些时候header比较大。 HTTP2 依旧建立TCP服务 在TCP里建立stream，stream是在TCP里面独立通信的管道。各个stream不会相互影响。但是允许在同一个链接里面让多个信息来回发送但不相互干扰。在stream里面是通过Frame来发送消息的；所以它在发送请求的时候，不是将header和body绑在一起发送；而是将消息拆成多个Frame进行发送的；而每个Frame又可以单独的进行优化； 有哪些Frame 客户端往服务端发送header的时候，服务器知道它将接收到header。这个过程就能使用到一些压缩算法。 8.1 http2的特点 请求多路复用，可以在同一个TCP连接使用stream发送多个请求； Header压缩 默认安全 HTTP， 但很多决定不支持HTTP HTTPS Server Push 没有Server push 没有Server push的时候，请求是一来一回的。 server push 节省了一个步骤，从客户端往服务端请求app.css的部分； 9. 部署Nohup 1nohup ./it &amp; 守护进程 1$&gt; vim /etc/systemd/system/go-web.service 12345678910111213[Unit]Description=Go web App running on xxx[Service]ExecStart=/home/solenovex/it/itRestart=alwaysRestartSec=10KillSignal=SINGINTSyslogIdentifier=go-web-exampleUser=solenovex[Install]WantedBy=multi-user.target 123sudo systemctl start go-web.service# 查看状态sudo systemctl status go-web.service 10 IM项目10.1 构建基础server1234# 构建go build -o server main.go server.go./server$&gt; connect success 12# 客户端nc 127.0.0.1 8888 10.2 用户上线功能12345// 需要给server补充两个属性, OnlineMap 和 channeltype Server struct &#123; Ip string Port int&#125; OnlineMap key： 当前用户名 user.Name User Name1 User1 Name2 User2 Name3 user3 记录当前有哪些用户在线，一个客户端就是一个用户； 用一个User类来表示客户端 12345type User &#123; username conn // 可以跟客户端进行通信 channel // 每个用户都绑定一个channel，专门用来向user实例对应的客户端来发消息的；&#125; channel 每个用户都绑定一个channel，专门用来向user实例对应的客户端来发送消息。比如服务器往客户端1发送消息时，服务器就应该将消息发给User1.channel。channel又该如何将消息发送给客户端呢？ 每个User实例中都会有一个goroutine，此goroutine应该阻塞监听channel，查看它当中是否有数据存在。一旦监听到数据，立即将数据通过conn写到对应的客户端中； Message message本质上是个channel，它属于server的channel。Message是用来将消息进行广播的。（如果当前有一条消息需要让所有客户端都收听到的话） 如何广播？ 将消息发送到Message的管道中，Message中除了有管道，还需要有一个goroutine。不断在监听当前管道。一旦监听到有消息时，遍历OnlineMap依次将消息发送给每个的user的channel中； 1234567891011121314# server$&gt; ./server# client1$&gt; nc 127.0.0.1 8888$&gt;[127.0.0.1:51375]127.0.0.1:51375:online #1$&gt;[127.0.0.1:51753]127.0.0.1:51753:online #2$&gt;[127.0.0.1:51979]127.0.0.1:51979:online #3# client2$&gt; nc 127.0.0.1 8888$&gt;[127.0.0.1:51753]127.0.0.1:51753:online #2$&gt;[127.0.0.1:51979]127.0.0.1:51979:online #3# client3$&gt; nc 127.0.0.1 8888$&gt; [127.0.0.1:51979]127.0.0.1:51979:online #3 10.3 用户消息广播机制12345678910111213#im1# server$&gt; ./server# client1$&gt; nc 127.0.0.1 8888$&gt; [127.0.0.1:55858]127.0.0.1:55858:online$&gt; [127.0.0.1:55894]127.0.0.1:55894:online$&gt; [127.0.0.1:55894]127.0.0.1:55894:hello# client2$&gt; nc 127.0.0.1 8888$&gt; [127.0.0.1:55894]127.0.0.1:55894:online$&gt; hello$&gt; [127.0.0.1:55894]127.0.0.1:55894:hello 10.4 用户业务层封装10.5 在线用户查询10.6 修改用户名定义一种消息格式 rename|newUsername 10.7 超时强T用户的任意消息表示用户为活跃，长时间不发消息则视为超时，可强制下线。 那如何判断当前用户是否活跃； 12# 实现原理当服务端能从客户端 Read到一条信息的，开启定时器；等定时器达到一定阈值的时候，则判定客户端失联 10.8 私聊同修改用户名一样，也是定义一种消息格式 to|username|send message 10.9 客户端123# build$&gt; go build -o server main.go server.go user.go$&gt; go build -o client client.go","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"rust","slug":"rust","date":"2021-03-16T06:02:35.000Z","updated":"2021-03-16T06:12:42.988Z","comments":true,"path":"2021/03/16/rust/","link":"","permalink":"http://yoursite.com/2021/03/16/rust/","excerpt":"","text":"1. rust123rustc --versionrustup doc # 离线文档rustc main.rs # 编译main.rs c为compiler 2. cargo12cargo --versioncargo new hello_cargo # 创建一个 hello_cargo的项目 2.1 cargo.toml TOML (Tom’s Obvious Minimal Language) 格式，是Cargo是配置格式 123456789[package] # 区域标题，表示下方内容是用来配置包（package）的name = \"hello_cargo\" # 项目名version = \"0.1.0\"authors = [\"ruanhan1988 &lt;2856197796@qq.com&gt;\"]edition = \"2018\" # 使用的rust版本# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] # 区域标题， 另一个区域的开始，它会列出项目的依赖项 2.2 crate 在rust里面， 代码的包称为crate 2.3 非cargo创建的项目 非cargo创建的项目，转化为使用cargo 把源代码文件移动到src下 创建Cargo.html并填写相应的配置 2.4 Cargo 构建项目12cargo build # 构建# 会创建出来一个可执行文件: target/debug/hello_cargo 或 target\\debug\\hello_cargo.exe 2.4.1 cargo.lock 第一次运行 cargo build会在项目目录生成 cargo.lock文件 12345# This file is automatically @generated by Cargo.# It is not intended for manual editing.[[package]]name = \"hello_cargo\"version = \"0.1.0\" 该文件负责追踪项目以来的精确版本 不需要手动修改该文件 2.5 构建和运行cargo项目1cargo run 如果源代码没有更改，直接运行上次生成的二进制文件； 2.6 cargo check1cargo check # 检查代码，确保能通过编译，但是不产生任何可执行文件； cargo check效率较build命令高很多，编写代码时，可反复使用cargo check检查代码，提高效率； 2.7 发布123cargo build --release# 编译时会进行优化, 代码会运行更快，但是编译时间更长# 会在 target/release 而不是 target/debug 生成可执行文件 2.8 添加依赖包1234567891011# Cargo.html[package]name = \"guessing_number\"version = \"0.1.0\"authors = [\"ruanhan1988 &lt;2856197796@qq.com&gt;\"]edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]rand = \"0.3.14\" # 添加依赖包 在dependencies区域下，直接填写 rand = “0.3.14”即可； 3. guess number-pro12345678910111213fn main()&#123; println!(\"guess number\"); println!(\"guess a number\"); let mut guess = String::new(); // 创建一个可变的变量，rust中变量默认是 immutable的 // String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码 // 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数 // 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法 io::stdin().read_line(&amp;mut guess).expect(\"can not read_line\"); // rust中，引用默认也是不可变的，添加mut关键字，使其变为可变 // &amp;mut guess 即指guess的引用 .expect 如果读取发生错误，程序崩溃退出； print!(\"you guess the number is: &#123;&#125;\", guess);&#125; 3.1 read_line123pub fn read_line(&amp;self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt;// read_line 有一个叫 io::Result 类型的返回值，在rust标准库中，有很多类型都叫做Result。既有通用的result（范型的result），也有特定版本，子模块的Result，比如io::Result, Result类型实际上枚举类型，一个枚举类型有几个固定的值，这些值称做是这些枚举类型的变体。而io::Result枚举类型一共两个变体，Ok和Errio::stdin().read_line(&amp;mut guess).expect(\"can not read_line\"); 3.2 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950use std::io;use std::cmp::Ordering; // Ording 枚举类型use rand::Rng;// 默认情况下，rust会将 一个叫 prelude的模块 导入到每个程序的作用域中，// 如果需要使用的类型不在 prelude里面，就需要显式的导入 比如 use std::iofn main()&#123; println!(\"guess number\"); let secret_number = rand::thread_rng().gen_range(1, 101); // loop 添加一个无限循环 loop &#123; println!(\"guess a number\"); let mut guess = String::new(); // 创建一个可变的变量，rust中变量默认是 immutable的 // String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码 // 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数 // 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法 io::stdin().read_line(&amp;mut guess).expect(\"can not read_line\"); // rust中，引用默认也是不可变的，添加mut关键字，使其变为可变 // &amp;mut guess 即指guess的引用 .expect 如果读取发生错误，程序崩溃退出； println!(\"you guess the number is: &#123;&#125;\", guess); // 在rust中允许使用同名的新变量来 shadow原来同名的旧变量，也就是说从声明新guess之后， // 代码中出现的guess变量都将是这个 u32类型的变量；这种用法通常使用在需要有类型转换的场景 // 中，我们复用guess这个名而无需创建新的变量名； // let guess:u32 = guess.trim().parse().expect(\"plase type a number\"); // parse返回值是Result，所以可以使用expect处理未来可能存在的异常 let guess:u32 = match guess.trim().parse()&#123;// 使用match 提高程序健壮性 Ok(num) =&gt; num, Err(_) =&gt; &#123; println!(\"valid number\"); continue &#125; // 非合法数字，直接continue &#125;; // match关键字， 根据cmp返回的Ordering 这个枚举类型的值来决定下一步来做什么。 // 而match表达式 是有多个 arm /分支 组成的； match guess.cmp(&amp;secret_number) &#123; // cmp compare 返回值 Ordering Ordering::Less =&gt; println!(\"Too small!\"), // arm Ordering::Greater =&gt; println!(\"To big!\"), // arm Ordering::Equal =&gt; &#123; println!(\"you win\"); break; // 跳出 match &#125;, // arm &#125; &#125; &#125; 4. 通用编程概念4.1 变量与可变性声明变量用let 默认情况，变量是immutable 声明变量，在变量前面加上mut，就可以使变量可变； 4.1.1 变量与常量 常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别： 不可以使用mut，常量永远都是不可变的； 声明变量使用const关键字，它的类型必须被标注； 常量可以在任何作用域内进行声明，包括全局作用域 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值； 在程序运行期间，常量在其声明的作用域内一直有效 命名规范： Rust里常量使用全大写字母，每个单词之间用下划线分开； 1MAX_POINTS:u32 = 100_00; 4.1.2 Shadowing(隐藏) 可以使用相同的名字声明新的变量，新的变量就会shadow（隐藏）之前声明的同名变量 1234567fn main()&#123; let x = 5; let x = x+1; let x = x*2; // 在后续的代码中这个变量名代表的就是新的变量； println!(\"value is &#123;&#125;\", x); // 12 &#125; 4.1.3 shadow与mut Shadow和把变量标记为mut是不一样的， 如果不使用let关键字，那么重新给非mut的变量赋值会导致编译时错误 而使用let声明的同名新变量，也是不可变的； 使用let声明的同名新变量，它的类型可以与之前不同； 4.2 数据类型Rust是静态编译语言，在编译时必须知道所有变量的类型； 基于使用的值，编译器通常能够推断出它的具体类型； 但如果可能的类型比较多（例如把String转为整数的parse方法），就必须添加类型的 标注，否则编译会报错 12let num = '42'.parse(); // errorlet num:u32 = '42'.parse // ok 4.2.1 标量类型 一个标量类型代表一个单个的值； Rust有四个主要的标量类型： 4.2.1.1 整数类型整数类型没有小数部分 例如u32就是一个无符号的整数类型，占据32位的空间 无符号 以u开头 有符号 以i开头 Rust的整数类型列表如图 Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize isize 和 usize类型 isize 和 usize类型的位数由程序运行的计算机的架构所决定 如果是64位计算机，那就是64位，如果32位计算机，就是32位； 使用isize和usize 的主要场景是针对某中集合进行索引操作； 4.2.1.2 浮点类型f32 f64 4.2.1.3 布尔类型true false 4.2.1.4 字符类型char 4个字节 4.2.2 复合类型 复合类型可以将多个值放在一个类型里 Rust提供了两种基础的复合类型： 元祖（Tuple）、数组 4.2.2.1 TupleTuple可以将多个类型的多个值放在一个类型里 Tuple的长度是固定的：一旦声明就无法改变 12let tup: (i32, f64, u8) = (500, 6.4, 1);println!(\"&#123;&#125;, &#123;&#125;, &#123;&#125;\", tup.0, tup.1, tup.2); 4.2.2.2 数组数组中每个元素的类型必须相同 数组的长度也是固定的 数组的用处 如果想让你的数据存放在stack上而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处； 数组的类型 [类型; 长度] 1let a: [i32; 5] = [1,2,3,4,5]; 另一种声明数组的方法 如果数组的每个元素都相同，那么可以在： 在中括号里制定初始值； 123let a = [3;5]; // 相当于let a = [3,3,3,3,3] 访问数组的元素 数组是stack上分配的单个块的内存 可以使用索引来访问数组的元素（例子） 如果访问的索引超出了数组的范围，那么； 编译会通过 运行会报错（runtime时会panic） 123456fn main()&#123; let mouths = [1,2,3,4,5,6,7,8,9,10,11,12]; let index = [12,13,14,15]; let month = months[index[1]]; // 编译时不会报错，只有运行时才会检测 println!(\"&#123;&#125;\", month); &#125; Rust不会允许其继续访问相应的地址的内存； 4.3 函数函数名 多个单词用下划线连接； parameter 行参 arguments 实参 4.3.1 函数的返回值在-&gt; 符号后边声明函数返回值的类型，但是不可以为返回值命名； 在rust里面，返回值 4.4 注释4.5 控制流4.5.1 if elsematch 重构多重if else语句 4.5.2 循环Rust 提供了三种循环： loop， while 和 for 1234567891011fn main()&#123; loop&#123; // 无限循环； // &#125;&#125;fn main()&#123; while number !== 0 &#123; /// &#125;&#125; 4.5.2.1 使用for循环遍历集合由于for循环的安全，简洁性，所以它在Rust里用的最多； 1234567fn main() &#123; let a = [10, 20, 30, 40, 50]; for element in a.iter() &#123; println!(\"the value is: &#123;&#125;\", element); &#125;&#125; 例子： 用for循环显示倒计时的例子 载入标准库 Range 指定一个开始数字和一个结束数字，Range可以生成它们之间的数字（不含结束） rev方法可以反转Range 123456fn main() &#123; for number in (1..4).rev() &#123; println!(\"&#123;&#125;!\", number); &#125; println!(\"LIFTOFF!!!\");&#125; 5. 所有权所有权是Rust最独特的特性，它让Rust无需GC就可以保证内存安全； 所有程序在运行时都必须管理它们使用计算机内存的方式 有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存 在其他语言中，程序员必须显式地分配和释放内存； Rust采用了第三种方式 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则； 当程序运行时，所有权特性不会减慢程序的运行速度； 5.1 stack vs heap在像Rust这样的系统级编程语言里，一个值是在stack上还是在heap上对语言的行为和你为什么要做某些决定是有更大的影响的； 在你的代码运行的时候，stack 和 heap都是你可用的内存，但他们的结构很不相同； 存储数据 stack按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO） 添加数据叫做压入栈 移除数据叫做弹出栈 所有存储在Stack上的数据必须拥有已知的固定的大小； 编译时大小未知的数据或运行时大小可能发生变化的数据必须存在heap上 heap内存组织性差一点； 当你把数据放入heap时，你会请求一定数量的空间 操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址 这个过程叫做heap上进行分配，有时仅仅称为“分配” 把值压到stack上不叫分配 因为指针是已知固定大小的，可以把指针存放在stack上。 但如果想要实际数据，你必须使用指针来定位； 把数据压到stack上要比在heap上分配快得多： 因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在stack的顶端 在heap上分配空间需要做更多的工作： 操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配； 访问数据 访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据； 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack上） 如果数据之间的距离比较远，那么处理速度就会慢一些（heap上） 在heap上分配大量的空间也是需要时间的； 函数调用 调用函数时，值被传入到函数（也包括指向heap的指针），函数本地的变量被压到stack上，当函数结束后，这些值会从stack上弹出； 5.2 所有权存在的原因5.2.1 所有权解决的问题跟踪代码的哪些部分正在使用heap的哪些数据； 最小化heap上的重复数据量 情理heap上未使用的数据以避免空间不足 一旦懂得所有权，那么就不需要经常去想stack或heap了； 但是知道管理heap数据是所有权存在的原因，这有助于理解它为什么会这样工作； 5.3 所有权规则每个值都有一个变量，这个变量是该值的所有者； 每个值同时只能有一个所有者； 当所有者超出作用域（scope）时，该值将被删除； 5.3.1 变量作用域scope就是程序中一个项目的有效范围 12345fn main()&#123; // s不可用 let s = \"hello\"; // s 可用 // 可以对s进行相关操作&#125; // s作用域到此结束， s不再可用； 5.3.2 String类型Rust还有第二种字符串类型： String 在heap上分配，能够存储在编译时未知数量的文本； 5.3.2.1 创建String类型的值 可以使用from函数从字符串字面值创建出String类型 123let s = String::from(\"hello\")// :: 表示from是String类型下的函数// 这类字符串是可以被修改的； 12345fn main()&#123; let mut s = String::from(\"hi\"); s.push_str(\", world\"); println!(\"&#123;&#125;\", s); // hi, world&#125; 5.3.2.2 内存和分配为什么string类型的值可以修改，而字符串字面值不能修改 因为它们处理内存的方式不同； 字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里； 速度快、高效，是因为其不可变性； String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容： 操作系统必须在运行时来请求内存， 这步通过调用String::from来实现 当用完String之后，需要使用某种方式将内存返回给操作系统 这步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存 没有GC，就需要我们去识别内存何时不再使用，并调用代码将它返回； 如果忘了，那就浪费内存 如果提前做了，变量就会非法 如果做了两次，就是Bug，必须一次分配对应一次释放； Rust采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统； drop函数 当变量走出作用域的时候，会调用drop函数 5.4 变量和数据交互的方式5.4.1 移动（Move） 多个变量可以与同一个数据使用一种独特的方式来交互； 12345678fn main() &#123; let x = 5; let y = x; let s = String::from(\"hello\"); // borrow of moved value: `s` let s2 = s; println!(\"&#123;&#125;,&#123;&#125;\", x, y); // 5, 5 println!(\"&#123;&#125;\", s2); // hello&#125; 一个String由3部分组成： 一个指向存放字符串内容的内存的指针 ptr 一个长度 len 一个容量 capacity 上面这些东西放在stack上 存放字符串内容的部分在heap上 长度len，就是存放字符串内容所需的字节数； 12let s1 = String::from(\"hello\");let s2 = s1; 当把s1赋给s2，String的数据被复制了一份： 在stack上复制了一份指针、长度、容量 并没有复制指针所指向的heap上的数据 当变量离开作用域时，Rust会自动调用drop函数，并将变量使用的heap内存释放； 当s1、s2离开作用域时，它们都会尝试释放相同的内存 会引起二次释放（double free）的bug rust为了保证内存安全： Rust没有尝试复制被分配的内存 Rust让s1失效 当s1离开作用域的时候，rust不需要释放任何东西； 12345678fn main() &#123; let x = 5; let y = x; let s = String::from(\"hello\"); // borrow of moved value: `s` let s2 = s; println!(\"&#123;&#125;,&#123;&#125;\", x, y); // 5, 5 println!(\"&#123;&#125;\", s2); // hello&#125; 5.4.2 浅拷贝和深拷贝浅拷贝 深拷贝 你也许会将复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以我们用一个新的术语：移动（Move） 隐含的一个设计原则： Rust不会自动创建数据的深拷贝 就运行时性能而言，任何自动赋值的操作都是廉价的； 5.4.3 变量和数据交互的方式：克隆（Clone）如果真想对heap上面的String数据进行深度拷贝，而不仅仅是Stack上的数据，可以使用clone方法 123456fn main() &#123; let s &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; borrow of moved value: &#96;s&#96; let s2 &#x3D; s; let s3 &#x3D; s2.clone(); println!(&quot;&#123;&#125;, &#123;&#125;&quot;, s2, s3); &#x2F;&#x2F; hello hello&#125; Clone 相当于无论是Stack上还是heap上的数据，都统统复制一遍 5.4.4 复制12345fn main() &#123; let x = 5; let y = x; println!(\"&#123;&#125;,&#123;&#125;\", x, y); // 5, 5&#125; Clone 比较消耗资源；主要还是针对heap上的数据操作。 而针对Stack上的数据，只需要复制就好了； 5.4.4.1 Copy traitRust 提供了一个名为Copy的 trait，trait简单理解为接口 Copy trait，可以用于像整数这样完全存放在stack上面的类型； 如果一个类型实现了Copy这个trait，那么旧的变量在赋值后仍然可用； 如果一个类型或者该类型的一部分实现了Drop trait，那么Rust不允许让它再实现Copy trait了 5.4.4.2 一些拥有Copy trait的类型任何简单标量的组合类型都可以是Copy的 任何需要分配内存或某种资源的都不是Copy的 一些拥有Copy trait的类型 所有整数类型，例如 u32 bool char 所有浮点类型 例如f64 Tuple（元组），如果其所有的字段都是Copy的 (i32,i32)是 (I32, String) 不是 5.5 所有权与函数在语义上，将值传递给函数和把值赋给变量是类似的： 5.5.1 将值传递给函数将发生移动或复制123456789101112131415161718fn main() &#123; let s = String::from(\"alex\"); take_ownership(s); // 从这里之后，s的值被移动到函数里面； let x = 5; makes_copy(x); // x值是被拷贝到函数里面 println!(\"x: &#123;&#125;\", x); // x 被回收；&#125;fn take_ownership(str: String) &#123; println!(\"&#123;&#125;\", str);&#125; // rust会调用drop ，str占用的内存会被释放fn makes_copy(str: i32) &#123; println!(\"&#123;&#125;\", str);&#125; // 对于i32这种基础类型，不会有额外的事情发生 5.5.2 返回值与作用域函数在返回值的过程中同样也会发生所有权的转移 12345678910111213141516171819202122232425fn main() &#123; let s1 = gives_ownership(); // gives_ownership 将返回值 // 移给 s1 let s2 = String::from(\"hello\"); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃fn gives_ownership() -&gt; String &#123; // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(\"hello\"); // some_string 进入作用域. some_string // 返回 some_string 并移出给调用的函数&#125;// takes_and_gives_back 将传入字符串并返回该值fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数&#125; 一个变量的所有权总是遵循同样的模式： 把一个值赋给其它变量时就会发生移动 当一个包含heap数据的变量离开作用域时，它的值就会被drop函数清理，除非数据的所有权移动到另一个变量上了； 5.6 引用如果让函数使用某个值，但不获得其所有权？ 12345678910fn main() &#123; let s1 = String::from(\"alex\"); let (s2, len) = calculate_length(s1); println!(\"The length of '&#123;&#125;' is &#123;&#125;\", s2, len);&#125;fn calculate_length(str: String) -&gt; (String, usize) &#123;// usize 跟架构有关的无符号整数类型 let length = str.len(); (str, length)&#125; Rust有一个特性叫做 引用（Reference) 5.6.1 引用1234567891011fn main()&#123; let s1 = String::from('hi'); let len = calcuate_length(&amp;s1); //&amp;s1并不拥有s1，所有不会转移s1的所有权，而是将s1的引用传给了 函数， 当作用域结束之后，s1并不会被清理掉 println!(\"&#123;&#125;,&#123;&#125;\", s1, len);&#125;fn calcuate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; // 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，// 所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权// 这种将引用作为函数参数的行为，我们就将其称为借用； 如上图，s就是s1的引用， s实际上是一个指针，它指向s1。 s1也是一个指针，它指向存在heap上的真实的内容； calcuate_length 参数的类型是 &amp; String而不是String， &amp;符号就表示引用：允许你引用某些值而不取得其所有权 5.6.2 借用123fn calcuate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; // 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉， 所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权 这种将引用作为函数参数的行为，我们就将其称为借用； 是否可以修改借用的东西？ 不行 和变量一样，引用默认也是不可变的 只要设置mut，就可以修改借用的东西 1234567fn main() &#123; let mut s = String::from(\"hello\"); // 设置为可变的 change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(\", world\");&#125; 5.6.3 可变引用可变引用有一个重要的限制： 在特定作用域内，对某一块数据，只能有一个可变的引用； 这样做的好处是可在编译时防止数据竞争； 数据竞争是如何发生的 两个或多个指针同时访问同一个数据 至少有一个指针用于写入数据 没有使用任何机制来同步对数据的访问 可以通过创建新的作用域，来允许非同时的创建多个可变引用（例子） 1234567fn main()&#123; let mut s = String::from('alex'); &#123; let s1 = &amp;mut s; &#125; let s2 = &amp;mut s;&#125; 不可以同时拥有一个可变引用和一个不变的引用 多个不变的引用是可以的 123456fn main()&#123; let mut s = String::from('alex'); let r1 = &amp;s; let r2 = &amp;s; let s1 = &amp;mut s; // error! 不可以同时拥有可变引用和不可变引用&#125; 5.6.4 悬垂引用 Dangling References 一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了； Rust里，编译器可保证引用永远都不是悬空引用； 如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域； 1234567fn main()&#123; let r = dangle();&#125;fn dangle() -&gt; &amp;String &#123; // compiler error： let s = Sring::from('alex'); &amp;s&#125;// 随着s离开作用域，会调用drop释放内存，而对它的引用 &amp;s 却继续返回了。所以这个引用指向了一个被释放掉了的内存地址；即悬空指针，但Rust在编译阶段就规避掉了； 5.6.5 引用的规则在任何给定的时刻，只能满足下列条件之一： 一个可变的引用 任意数量不可变的引用 引用必须一直有效 5.7 切片 slice Rust的另外一种不持有所有权的数据类型：切片（slice） 编写一个函数： 它接收字符串作为参数 返回它在这个字符串里找到的第一个单词 如果函数没找到任何空格，那么整个字符串就被返回； 123456789101112131415161718192021fn main() &#123; let mut s = String::from(\"hello alex\"); let name_index = first_world(&amp;s); s.clear(); println!(\"&#123;&#125;\", name_index);&#125;fn first_world(s: &amp;String) -&gt; usize &#123; let bytes = s.as_bytes(); // 转成字节数组 // iter 方法为bytes创建一个迭代器，这个方法依次返回集合中的每个元素。然后 // 调用的enumerate方法，它会将iter方法的结果进行包装，并把结果作为tuple的一部分进行返回。 // 元祖的第一个元素，就是enumerate遍历的索引 i，第二个元素就是引用 item。 // (i, &amp;item) 实际上是模式匹配之后的解构 for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return i; &#125; &#125; s.len()&#125; 然而上面的函数设计是有问题的， name_index 和 s 太过耦合了。当s被清空之后，name_index的值就不再有意义了； 那如何确保 s 和 name_index 之间的同步性呢； 解决方案： 字符串切片 5.7.1 字符串切片 字符串切片是指向字符串中一部分内容的引用 形式： [开始索引…结束索引] 12let a = [1, 2, 3, 4, 5];let slice = &amp;a[1..3]; 几个语法糖 注意： 字符串切片的范围索引必须发生在有效的UTF-8字符边界内； 如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出 1234567891011121314151617fn main() &#123; let s = String::from(\"hello alex\"); let name_index = first_world(&amp;s); println!(\"&#123;&#125;\", name_index);&#125;fn first_world(s: &amp;String) -&gt; &amp;str &#123; // &amp;str 字符串切片 let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return &amp;s[..i]; &#125; &#125; &amp;s[..]&#125; 5.7.2 字符串字面值是切片字符串字面值被直接存储在二进制程序中； 12let s = \"he\" // s 为 &amp;str类型，即字符串切片// s就是一个指向二进制程序 特定位置的切片，而&amp;str是不可变的引用； 变量s的类型是&amp;str， 它是一个指向二进制程序特定位置的切片 &amp;str是不可变引用，所以字符串字面值也是不可变的； 5.7.3 将字符串切片作为参数传递12345678910111213141516171819202122232425fn main() &#123; let my_string = String::from(\"hello world\"); // first_word 中传入 `String` 的 slice let word = first_word(&amp;my_string[..]); let my_string_literal = \"hello world\"; // first_word 中传入字符串字面值的 slice let word = first_word(&amp;my_string_literal[..]); // 因为字符串字面值 **就是** 字符串 slice， // 这样写也可以，即不使用 slice 语法！ let word = first_word(my_string_literal);&#125;fn first_world(s: &amp;String) -&gt; &amp;str &#123; // &amp;str 字符串切片 let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return &amp;s[..i]; &#125; &#125; &amp;s[..]&#125; 定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能； 6. struct6.1 定义并实例化struct12345678910111213141516struct User &#123; username: String, emila: String, sign_in_count: u64, active: bool,&#125;fn main() &#123; println!(\"Hello, world!\"); let user1 = User &#123; username: String::from(\"alex\"), emila: String::from(\"123@qq.com\"), sign_in_count: 12, active: true, &#125;;&#125; 一旦struct的实例是可变的，那么实例中所有的字段都是可变的。不允许部分可变，部分不可变 6.1.1 tuple struct1234struct Color(i32,i32,i32);struct Point(i32,i32,i32);let black = Color(0,0,0);let origin = Point(0,0,0); black和origin是不同的类型，是不同tuple struct的实例 6.1.2 Unit-Like Struct（没有任何字段） 可以定义没有任何字段的struct，叫做Unit-Like Struct（因为与（），单元类型类似） 适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据 6.1.3 struct 数据的所有权123456struct User &#123; username: String, emila: String, sign_in_count: u64, active: bool,&#125; 这里的字段使用了String 而不是 &amp;str 该struct实例拥有其所有的数据 只要struct实例是有效的，那么里面的字段数据也是有效的 struct里也可以存放引用，但这需要使用生命周期； 声明周期保证只要struct实例是有效的，那么里面的引用也是有效的； 如果struct里面存储引用，而不使用生命周期，就会报错 6.1.4 计算面积的例子123456789101112131415// 例子1struct Rectangle &#123; width: u32, height: u32,&#125;fn area(rect: &amp;Rectangle) -&gt; u32 &#123; rect.height * rect.width&#125;fn main() &#123; let rect = Rectangle &#123; width: 30, height: 50, &#125;; println!(\"&#123;&#125;\", area(&amp;rect));&#125; 6.1.5 几种模式12345std::fmt::Displaystd::fmt::Debug#[derive(Debug)]&#123;:?&#125;&#123;:#?&#125; 6.2 struct的方法方法和函数类似： fn关键字、名称、参数、返回值 方法与函数不同之处： 方法是在struct（或enum、trait对象）的上下文中定义 第一个参数是self，表示方法被调用的struct实例 123456789101112131415161718struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // impl块中定义方法 fn area(&amp;self) -&gt; u32 &#123; // 方法第一个参数可以是 &amp;self self.height * self.width &#125;&#125;fn main() &#123; let rect = Rectangle &#123; width: 30, height: 50, &#125;; println!(\"&#123;&#125;\", rect.area());&#125; 6.2.1 方法调用的运算符在调用方法时， Rust根据情况自动添加 &amp;、 &amp;mut 或 *， 以便object可以匹配方法的签名； 123// 两行代码效果相同：p1.dis(&amp;p2);(&amp;p1).dis(&amp;p2); 6.2.2 方法参数方法可以有多个参数 1234567891011121314151617181920212223242526struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.height * self.width &#125; fn can_hole(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.height &gt; other.height &amp;&amp; self.width &gt; other.width &#125;&#125;fn main() &#123; let rect = Rectangle &#123; width: 30, height: 50, &#125;; let rect1 = Rectangle &#123; width: 20, height: 30, &#125;; println!(\"&#123;&#125;\", rect.area()); println!(\"&#123;&#125;\", rect1.can_hole(&amp;rect1));&#125; 6.3 关联函数可以在impl块里定义不把self作为第一个参数的函数，它们叫关联函数（不是方法） 例如： String::from() 关联函数通常用于构造器 ::符号 关联函数 模块创建的命名空间 1234567891011121314151617struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn square(size: u32) -&gt; Rectangle &#123; Rectangle &#123; width: size, height: size, &#125; &#125;&#125;fn main() &#123; let s = Rectangle::square(12);&#125; 7. 枚举与模式匹配7.1 定义12345enum Ip &#123; V4,V6&#125;let a = Ip::V4;let b = Ip::V6; 12345678910111213141516171819enum IpAddrKind &#123; V4, V6,&#125;struct IpAddr &#123; kind: IpAddrKind, address: String,&#125;let home = IpAddr &#123; kind: IpAddrKind::V4, address: String::from(\"127.0.0.1\"),&#125;;let loopback = IpAddr &#123; kind: IpAddrKind::V6, address: String::from(\"::1\"),&#125;; 7.1.1 将数据附加到枚举的变体中1234567enum IpAddr &#123; V4(String), V6(String),&#125;let home = IpAddr::V4(String::from(\"127.0.0.1\"));let loopback = IpAddr::V6(String::from(\"::1\")); 我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。 优点： 不需要额外使用struct 每个变体可以拥有不同的类型以及关联的数据量 1234enum Ip &#123; V4(u8,u8,u8,u8), V6(String)&#125; 7.2 option枚举定义于标准库中 在Prelude中 描述了： 某个值可能存在（某种类型）或不存在的情况 7.2.1 OptionRust中类似Null概念的枚举 - Option Rust没有Null 其它语言中： Null是一个值，它表示“没有值” 一个变量可以处于两种状态： 空值（null）、非空 Null引用： Billion Dollar Mistake Null的问题在于： 当你尝试像使用非Null值那样使用Null值的时候，就会引起某种错误 Null的概念还是有用的：因某种原因而变为无效或缺失的值； 12345// 标准库中的定义：enum Option&lt;T&gt; &#123; Some(T), None&#125; 它包含在Prelude（预导入模块）中，可直接使用； Option Some None 1234let some_number = Some(5);let some_string = Some(\"a string\");let absent_number: Option&lt;i32&gt; = None; Option比Null好在哪？ Option和T是不同的类型，不可以把Option直接当成T 12345fn main()&#123; let x:i8 = 5; let y: Option&lt;i8&gt; = Some(5); let sum = x + y; // error: cannot add Option&lt;i8&gt; to i8;&#125; 若想使用Option中的 T，必须将它转换为 T； 这就避免了其它语言中最常见的那个错误；那就是假设某个值存在，但它实际上为Null 123&#x2F;&#x2F; 比如在C#string a &#x3D; null;string b &#x3D; a + &quot;12345&quot;; &#x2F;&#x2F; error 7.3 match控制流运算符 - match match允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码； 模式可以是字面量、变量名、通配符 123456789101112131415enum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125; 7.3.1 绑定值的模式匹配的分支可以绑定到被匹配对象的部分值 因此，可以从enum变体中提取值 1234567891011121314151617181920212223242526272829#[derive(Debug)]enum UsState &#123; Alabama, Alaska,&#125;enum Coin &#123; Penny, Nickel, Dime, Quarter(UsState),&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; &#123; println!(\"penny\"); 1 &#125; Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; &#123; println!(\"State quarter from &#123;:?&#125;!\", state); 25 &#125; &#125;&#125;fn main() &#123; let c = Coin::Quarter(UsState::Alabama); println!(\"&#123;&#125;\", value_in_cents(c));&#125; 7.3.2 匹配Option123456789101112fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None);&#125;fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125; 7.3.3 match必须穷举所有可能_ 通配符： 替代其余没有列出的值； 12345678let some_u8_value = 0u8;match some_u8_value &#123; 1 =&gt; println!(\"one\"), 3 =&gt; println!(\"three\"), 5 =&gt; println!(\"five\"), 7 =&gt; println!(\"seven\"), _ =&gt; (),&#125; 7.4 if let处理只关心一种匹配而忽略其它匹配的情况 123456789101112let some_u8_value = Some(0u8);// match 方法match some_u8_value &#123; Some(3) =&gt; println!(\"three\"), _ =&gt; (),&#125;// if let 相当于只处理一种匹配的情况，其它的分支就不关心了if let Some(3) = some_u8_value &#123; println!(\"three\");&#125; if let 优缺点 更少的代码，更少的锁紧，更少的模版代码 放弃了穷举的可能 可以把 if let 看作是 match的语法糖 123456789// if let 搭配 elsefn main()&#123; let v = Some(0u8); if let Some(3) = v &#123; println!(\"three\"); &#125; else &#123; println!(\"others\"); &#125;&#125; 8. Package, Crate 和 Module模块系统： Package（包）， Cargo的特性，让你构建、测试、共享crate； Crate（单元包）， 一个模块树，它可产生一个library或执行文件； Module（模块）， use： 让你控制代码的组织、作用域、私有路径； path（路径）： 为struct、function 或module 等项命名的方式； 8.1 Package 和 Cratecrate上面是package， Crate的类型 binary library Crate Root 是源代码文件 Rust编译器从这里开始，组成你的Crate的根Module 一个Package 包含1个Cargo.toml, 它描述了如何构建这些Crates； 只能包含0-1个library crate； 可以包含任意数量的binary crate； 必须至少包含一个crate（library或binary） 12$&gt; cargo new my-pro# create binary (application) `my-pro` package 8.1.1 Cargo的惯例src/main.rs src/main.rs // package 的入口文件 Binary crate 的 crate root （cargo会默认让 main.rs做为crate的根） crate名与package名相同 （也是指这个binary crate的名和包名相同，都是my-pro） src/lib.rs Package 包含一个library crate library crate 的 crate root crate名与package名相同 （也都是my-pro） 复习： 如果有main.rs,就说明有一个 binary crate。 如果有lib.rs , 就说明有一个library crate。 两个都是入口文件，都是crate的根。而crate名都与package名相同。 cargo会把crate root文件交给rustc 来构建library 或 binary 一个Package可以同时包含main.rs 和 lib.rs, 表明，这个package含有一个 binary crate，一个library crate。名称都与package名相同 一个package可以有多个binary crate 文件都放在src/bin 每个文件是单独的binary crate 8.2 Crate的作用 将相关功能组合到一个作用域内，便于在项目间进行共享，也能防止命名冲突 例如： rand crate，访问它的功能需要通过它的名字： rand 8.3 定义module来控制作用域和私有性Module 在一个crate内，将代码进行分组； 增加可读性，易于复用； 控制项目（item）的私有性，public、private 8.3.1 建立module mod 关键字{} 可嵌套 可包含其它项（struct、enum、常量、trait、函数等）的定义 12345678910#cargo new my-pro|- crate |- front_of_house |- hosting |- add_to_waitlist |- seat_at_table |- serving |- take_over |- serve_order |- take_payment main.rs lib.rs 都叫crate roots； 这两个文件（任意一个）的内容形成了名为crate的模块，位于整个模块树的根部； 整个模块树在隐式的crate模块下 8.4 path根其它语言里面的命名空间有点类似 为了在Rust的模块中找到某个条目，需要使用路径 路径的两种形式 绝对路径： 从crate root开始，使用crate名或字面值crate 相对路径： 从当前模块开始，使用self，super或当前模块的标识符； 路径至少由一个标识符组成，标识符之间使用:: 123456789101112131415// 跟级别可以不加 pub 互相调用mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;// pub 关键字 设置该module为公共的pub fn eat_at_restaurant() &#123; // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // Relative path front_of_house::hosting::add_to_waitlist();&#125; 8.4.1 私有边界（private boundary）模块不仅可以组织代码，还可以定义私有边界 如果想把 函数 或 struct 等设为私有，可以将它放到某个模块中； Rust中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的； 父级模块无法访问子模块中的私有条目 私有条目都是隐藏实现细节，不允许其它模块进行访问。 子模块里可以使用所有祖先模块中的条目 8.4.2 super关键字123$&gt; ls..$&gt; hello hello.c$&gt; ../hello # hello super关键字 在Rust中，用来访问父级模块路径中的内容，类似文件系统中的.. 12345678910fn serve_order()&#123;&#125;mod back_of_house&#123; fn fix_incorrect_order()&#123; cook_order(); super::serve_order(); // 上一级模块的 serve_order 方法 crate::serve_order(); // 绝对路径的写法 &#125; fn cook_order()&#123;&#125;&#125; 8.4.3 use关键字可以使用use关键字将路径导入到作用域内 仍遵循私有性规则 1234567891011121314151617mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;// 使用use来指定相对路径use crate::front_of_house::hosting;// 函数 指定到父级模块； hostingpub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;// 使用use来指定绝对路径use front_of_house::hosting; struct, enum 其它： 指定完整路径（指定到本身） 12345use std::collections::HashMap;fn main()&#123; let mut map = HashMap::new(); map.insert(1,2);&#125; 同名条目： 指定到父级 8.4.3.1 使用pub use重新导出名称使用use将路径（名称）导入到作用域内后，该名称在此作用域内是私有的； 12345678910111213mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;pub use crate::front_of_house::hosting; // 从此，外部模块也能访问 hosting了// 函数 指定到父级模块； hostingpub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125; 8.4.3.2 使用嵌套路径清理大量的use语句如果使用同一个包或模块下的多个条目（例子） 可使用嵌套路径在同一行内将上述条目进行引入： 路径相同的部分::{路径差异的部分} 1234567// use std::cmp::Ordering;// use std::io;use std::&#123;cmp::Ordering, io&#125;;// use std::io;// use std::io::Writeuse std::io::&#123;self, Write&#125;; 8.4.4 通配符 *使用 * 可以把路径中所有的公共条目都引入到作用域 1use std::collections::* 谨慎使用 应用场景： 测试，将所有被测试代码引入到tests模块 有时被用于预导入（prelude）模块 8.4.5 as关键字as关键字可以为引入的路径指定本地的别名 12use std::io::Result as IoResult;fn f2() -&gt; IoResult&#123;&#125;; 8.4.6 使用外部包（package） cargo.toml 添加依赖的包（package） use将特定条目引入作用域； 8.4.6.1 切换国内镜像1234$&gt; where cargo$&gt; cd /Users/xx/.cargo/$&gt; ls -a$&gt; vim config 123456789[source.crates-io]registry = \"https://github.com/rust-lang/crates.io-index\"replace-with = 'tuna'[source.tuna]registry = \"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git\"[net]git-fetch-with-cli = true 8.5 将模块拆分为不同文件将模块内容移动到其它文件 模块定义时，如果模块名后边是； ，而不是代码块 Rust 会从与模块同名的文件中加载内容 模块树的结构不会变化 12345|- src |- /front_of_house |- hosting.rs |- front_of_houre.rs |- lib.rs 123456// front_of_house.rspub mod hosting;// lib.rsmod front_of_house;// hosting.rspub fn add_to_waitlist()&#123;&#125; 随着模块逐渐变大，该技术让你可以把模块的内容移动到其它文件中； 9. 集合9.1 Vector Vec,叫作vector 由标准库提供 可存储多个值 只能存储相同类型的数据 值在内存中连续存放 9.1.1 创建Vec 使用 vec! 宏 9.1.2 所有权和借用规则不能在同一作用域内同时拥有可变和不可变引用 12345fn main()&#123; let mut v = vec![1,2,3,4,5]; let first = &amp;v[0]; // 不可变借用 v.push(6); // 可变的借用&#125; vector的工作原理： vec里面的元素在内存中的摆放是连续的，所以再往vec中添加一个元素的时候，在内存中就没有这么大的连续内存块。就可能将内存重新分配一下了，再找一个足够大的内存来放置这些添加了元素之后的vector，原来那块内存可能被释放掉或者重新分配，而first变量仍然指向原来的内存地址，这样的话，程序必然出现问题了；所以，借用规则防止类似的情况发生 9.1.3 遍历123456789let v = vec![100, 32, 57];for i in &amp;v &#123; println!(\"&#123;&#125;\", i);&#125;let mut v = vec![100, 32, 57];for i in &amp;mut v &#123; *i += 50;&#125; 9.1.4 vector+enum使用enum来存储多种数据类型 enum的变体可以附加不同类型的数据 enum的变体定义在同一个enum类型下 1234567891011enum SpreadsheetCell &#123; Int(i32), Float(f64), Text(String),&#125;let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\"blue\")), SpreadsheetCell::Float(10.12),]; 9.2 String字符串困扰 Rust倾向于暴露可能的错误 字符串数据结构复杂 UTF-8 9.2.1 定义Rust的核心语言层面，只有字符串类型：字符串切片 str （&amp;str） 字符串切片： 对存储在其它地方、utf-8编码的字符串引用 字符串字面值： 存储在二进制文件中，也是字符串切片 9.2.2 String类型来自标准库 而不是核心语言 可增长，可修改，可拥有 UTF-8 编码 9.2.3 其它类型的字符串Rust标准库还包含了很多其它的字符串类型， OsString、OsStr、CString、CStr String vs Str后缀： 拥有或借用的变体 可存储不同编码的文本或在内存中以不同的形式展现 9.2.4 使用初始值创建String12345678let data = \"initial contents\";let s = data.to_string();// 该方法也可直接用于字符串字面值：let s = \"initial contents\".to_string();// 字符串字面值创建Stringlet s = String::from(\"initial contents\"); 9.2.5 更新1234567891011121314fn main()&#123; let mut s = String::from(\"foo\"); let s1 = String::from(\"bar\"); s.push_str(&amp;s1); println!(\"&#123;&#125;\",s);&#125;fn main()&#123; let s1 = String::from(\"bar\"); let s2 = String::from(\"foo\"); let s3 = s1 + &amp;s2; // // 注意 s1 被移动了，不能继续使用&#125;// 因为在使用了 +，实际上使用了类似 下面 add这样的方法,当然标准库里面是泛型方法，这里为了理解，给替换成string类型先fn add(self, s:&amp;str) -&gt; String&#123;...&#125; // 参数1是 String，而不是切片，所以s1失去了所有权； 标准库中的add使用了泛型 只能把&amp;str添加到String 解引用强制转换（deref coercion） 9.2.6 format! 连接多个字符串123456789fn main()&#123; let s1 = String::from('tic'); let s2 = String::from('tac'); let s3 = String::from('toe'); let s3 = s1 + \"-\" + &amp;s2 + \"-\" + &amp;s3; // 类似于 format!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;\", s1, s2, s3); // format! 宏不会取得后续所有参数的所有权 println!(\"&#123;&#125;\", s3);&#125; format! 宏不会取得后续所有参数的所有权 9.2.7 索引字符串Rust字符串不支持索引； 9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇123456789101112fn main()&#123; let w = \"नमस्ते\"; for b in w.bytes()&#123; println!(\"&#123;&#125;\", b); // [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135] &#125; for b in w.chars() &#123; println!(\"&#123;&#125;\", b); // ['न', 'म', 'स', '्', 'त', 'े'] &#125;&#125; 9.2.9 Rust不允许对String进行索引最后一个原因 索引操作应消耗一个常量时间（O（1）） 而String无法保证，需要遍历所有内容，来确定有多少个合法的字符 9.2.10 字符串切割12let hello = \"Здравствуйте\";let s = &amp;hello[0..4]; 9.3 HashMap对于实现Copy trait的类型（i32），值会被复制到HashMap中 对于拥有所有权的值（String），值会被移动，所有权会转移给HashMap 如果将值的引用插入到HashMap，值本身就不会移动 在hashMap有效的期间，被引用的值必须保持有效 9.3.1 get可以通过get方法并提供对应的键来从哈希map中获取值 123456789101112131415use std::collections::HashMap;fn main()&#123; let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); scores.insert(String::from(\"yellow\"), 50); let team_name = String::from(\"blue\"); let score = scores.get(&amp;team_name); match score &#123; Some(s) =&gt; println!(\"&#123;&#125;\", s), // 10 None =&gt; println!(\"team not exist\") &#125;;&#125; 9.3.2 更新HashMap K已经存在，对应一个V 替换现有的V 保留现有的V，忽略新的V 合并现有的V和新的V K不存在 添加一对K，V 123456789// 替换use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.insert(String::from(\"Blue\"), 25);println!(\"&#123;:?&#125;\", scores); 9.3.2.1 entryentry方法： 检查指定的K是否对应一个V 参数为K 返回enum Entry：代表值是否存在 123456789use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.entry(String::from(\"Yellow\")).or_insert(50);scores.entry(String::from(\"Blue\")).or_insert(50);println!(\"&#123;:?&#125;\", scores); Entry的 or_insert 方法 返回 如果K存在，返回到对应的V的一个可变引用 如果K不存在，将方法参数作为K的新值插进去，返回到这个值的可变引用； 12345678910111213// 根据旧值更新一个值use std::collections::HashMap;let text = \"hello world wonderful world\";let mut map = HashMap::new();for word in text.split_whitespace() &#123; let count = map.entry(word).or_insert(0); *count += 1;&#125;println!(\"&#123;:?&#125;\", map); 10. panic Rust错误分类 可恢复 例如文件未找到，可再次尝试 不可恢复 bug，例如访问的索引超出范围 Rust没有类似异常的机制 可恢复错误： Result&lt;T,E&gt; 不可恢复： painc！ 当执行painc！时，程序立即结束执行 不可恢复的错误与panic！ 当panic！宏执行： 你的程序会打印一个错误信息 展开（unwind）、清理调用栈（Stack） 退出程序 为应对panic，展开或中止（abort）调用栈 默认情况下，当panic发生： -程序展开调用栈（工作量大） rust沿着调用栈往回走 清理每个遇到的函数中的数据 或立即中止调用栈： 不进行清理，直接停止程序 内存需要OS进行清理 想让二进制文件更小，把设置从“展开”改为“中止”： 在Cargo.toml中适当的profile部分设置： 12[profile.release]panic = 'abort' 1234// 不可恢复的错误与panic！fn main()&#123; panic!(\"crash and burn\");&#125; 10.1 Result 与可恢复的错误1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E)&#125; T: 操作成功情况下，Ok变体里返回的数据的类型 E： 操作失败情况下，Err变体里返回的错误的类型 处理Result的一种方式： match表达式 和Option枚举一样，Result及其变体也是有prelude带入作用域 123456789101112use std::fs::File;fn main() &#123; let f = File::open(\"./0.txt\"); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; &#123; panic!(\"Error opening file &#123;:?&#125;\", error) &#125; &#125;; println!(\"&#123;:?&#125;\", f);&#125; 10.2 匹配不同的错误12345678910111213141516use std::fs::File;use std::io::ErrorKind;fn main() &#123; let f = File::open(\"hello.txt\"); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; match error.kind() &#123; ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") &#123; Ok(fc) =&gt; fc, Err(e) =&gt; panic!(\"Problem creating the file: &#123;:?&#125;\", e), &#125;, other_error =&gt; panic!(\"Problem opening the file: &#123;:?&#125;\", other_error), &#125;, &#125;;&#125; 上例使用了很多match match很有用，但是很原始 闭包（closure）。Result&lt;T,E&gt;有很多方法 它们接收闭包作为参数 使用match实现 1234567891011121314use std::fs::File;use std::io::ErrorKind;fn main() &#123; let f = File::open(\"hello.txt\").unwrap_or_else(|error| &#123; if error.kind() == ErrorKind::NotFound &#123; File::create(\"hello.txt\").unwrap_or_else(|error| &#123; panic!(\"Problem creating the file: &#123;:?&#125;\", error); &#125;) &#125; else &#123; panic!(\"Problem opening the file: &#123;:?&#125;\", error); &#125; &#125;);&#125; 10.2.1 unwrapunwrap： match表达式的一个快捷方法； 如果Result结果是Ok，返回Ok里面的值 如果Result结果是Err，调用panic！宏 12345678910111213141516use std::fs::File;fn main() &#123; let f = File::open(\"0.txt\"); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; &#123; panic!(\"Error opening file &#123;:?&#125;\", error) &#125; &#125;; let f = File::open(\"0.txt\").unwrap(); // 相当于上面的match表达式 println!(\"&#123;:?&#125;\", f);&#125; 10.2.2 expectexpect： 和unwrap类似，但可指定错误信息 12345use std::fs::File;fn main() &#123; let f = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");&#125; 10.3 传播错误当编写一个其实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误， 1234567891011121314151617181920use std::io;use std::io::Read;use std::fs::File;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(\"hello.txt\"); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); // 返回值 match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125; ?运算符 ?运算符： 传播错误的一种快捷方式 ？与from函数 Trait std::convert::From 上的from函数： 用于错误之间的转换 被？所应用的错误，会隐士的被from函数处理 当？调用from函数时： 它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型 用于： 针对不同错误的原因，返回同一种错误类型 只要每个错误类型实现了转换为所返回的错误类型的from函数 链式操作 12345fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); File::open(\"hello.txt\")?.read_to_string(&amp;mut s)?; Ok(s)&#125; ?运算符只能用于返回Result的函数 ?运算符与main函数 12345// 在main中使用？fn main()-&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;&#123; let f = File::open(\"hello.txt\")?; Ok(())&#125; main函数返回类型是：() main函数的返回类型也可以是： Result&lt;T,E&gt; Box是trait对象 简单理解： “任何可能的错误类型” 10.4 什么时候应该用panic!见示例 11. 泛型，Trait 生命周期11.1 泛型你编些的代码不是最终的代码，而是一种模版，里面有一些“占位符”； 编译器在编译时将“占位符”替换为具体的类型； 在编译的时候，会将泛型的类型参数编译成具体的类型。这个过程叫单态化； 1234567891011121314151617181920212223fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list.iter() &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125;fn main() &#123; let number_list = vec![34, 50, 25, 100, 65]; let result = largest(&amp;number_list); println!(\"The largest number is &#123;&#125;\", result); let char_list = vec!['y', 'm', 'a', 'q']; let result = largest(&amp;char_list); println!(\"The largest char is &#123;&#125;\", result);&#125; 11.2 Trait Trait告诉rust编译器： 某种类型具有哪些并且可以与其它类型共享的功能 Trait：抽象的定义共享行为 Trait bounds（约束）泛型类型参数指定为实现了特定行为的类型； Trait 与其它语言的接口（interface）类似，但有些区别； 11.2.1 如何定义一个trait类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。 trait 定义： 是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。 关键字： trait 只有方法签名，没有具体实现 trait可以有多个方法： 每个方法签名占一行，以；结尾 实现该trait的类型必须提供具体的方法实现； 123pub trait Sunmmary &#123; // 一个trait， 可以有多个方法的签名 fn sunmmary(&amp;self) -&gt; String;&#125; 11.2.2 在类型上实现trait与为类型实现方法类似 不同之处： impl 类型 for trait名{} // 为类型实现方法则是 impl 类型 {...} 在impl的块里，需要对Trait里的方法签名进行具体的实现 1234567891011121314151617181920212223242526272829pub trait Summary &#123; // 一个trait， 可以有多个方法的签名 fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;impl Summary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;, by &#123;&#125; (&#123;&#125;)\", self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;: &#123;&#125;\", self.username, self.content) &#125;&#125; 11.2.3 实现trait的约束可以在某个类型上实现某个trait的前提条件是： 这个类型或这个trait是在本地crate里定义的 无法为外部类型来实现外部的trait； 这个限制是程序属性的一部分（也就是一致性） 更具体地说是孤儿规则： 之所以这样命名是因为父类型不存在； 此规则确保其它人的代码不能破坏您的代码，反之亦然； 如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了； 11.2.4 默认实现有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。 123456789101112131415161718192021222324252627282930313233pub trait Sunmmary &#123; // 一个trait， 可以有多个方法的签名 // fn summarize(&amp;self) -&gt; String; fn summarize1(&amp;self)-&gt;String &#123; String::from(\"(...)\") &#125;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;impl Sunmmary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;, by &#123;&#125; (&#123;&#125;)\", self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Sunmmary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;: &#123;&#125;\", self.username, self.content) &#125;&#125; 默认实现的方法可以调用trait中其它的方法，即使这些方法没有默认实现 注意： 无法从方法的重写实现里面调用默认的实现 11.2.5 Trait作为参数impl Trait语法 适用于简单情况 12345678910pub trait Sunmmary &#123; // 一个trait， 可以有多个方法的签名 // fn summarize(&amp;self) -&gt; String; fn summarize1(&amp;self)-&gt;String &#123; String::from(\"(...)\") &#125;&#125;pub fn notify(item: impl Summary) &#123; // 类型区域 添加 impl Summary println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125; Trait bound语法 可用于复杂情况 impl Trait 语法是 Trait bound的语法糖 123pub fn notify&lt;T: Summary&gt;(item: T) &#123; println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125; 使用 + ，指定多个 Trait bound 123456pub fn notify(item: impl Summary + Display) &#123; // 类型区域 添加 impl Summary println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125;pub fn notify&lt;T: Summary + Display&gt;(item1: T, item2: T) &#123; println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125; Trait bound 使用where子句 1234567pub fn notify&lt;T, U&gt;(a: T, b: U) -&gt; Stringwhere T: Summary + Display, U: Clone + Debug,&#123; format!(\"Breaking news! &#123;&#125;\", a.summarize());&#125; 实现Trait作为返回类型 impl Trait 语法 123456pub fn notify1(s: &amp;str) -&gt; impl Summary &#123; NewsArticle &#123; headline: String::from(\"\"), ... &#125;&#125; 注意： impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错 使用Trait Bound的例子 例子： 使用Trait Bound修复largest函数 使用Trait Bound有条件的实现方法 在使用泛型类型参数的impl块上使用 Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法 12345678910111213141516171819202122232425use std::fmt::Display;struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(\"The largest member is x = &#123;&#125;\", self.x); &#125; else &#123; println!(\"The largest member is y = &#123;&#125;\", self.y); &#125; &#125;&#125; 可以为实现了其它Trait的任意类型有条件的实现某个Trait 为满足Trait Bound 的所有类型上实现Trait叫做覆盖实现； 11.3 生命周期Rust的每个引用都有自己的生命周期 声明周期： 引用保持有效的作用域 大多数情况： 声明周期是隐式的、可被推断的 当引用的声明周期可能以不同的方式互相关联时： 手动标注声明周期 11.3.1 生命周期——避免悬垂引用生命周期的主要目标： 避免悬垂引用（dangling reference） 12345678fn main()&#123; let r; &#123; let x = 5; r = &amp;x; // error , x走出作用域之后被释放掉了； &#125; println!(\"r: &#123;&#125;\",r);&#125; rust如何识别上面代码不合法呢？答案是 借用检查器 11.3.2 借用检查器Rust编译器的借用检查器： 比较作用域来判断所有的借用是否合法 12345678910&#123; let r; // ---------+-- 'a // | &#123; // | let x = 5; // -+-- 'b | r = &amp;x; // | | &#125; // -+ | // | println!(\"r: &#123;&#125;\", r); // ---------+ &#125; 11.3.3 函数中的泛型生命周期11.3.3.1 生命周期标注123456789101112131415fn main() &#123; let string1 = String::from(\"abcd\"); let string2 = \"abc\"; // 字符串字面量，也就是字符串切片类型 let result = longest(&amp;string1, string2); println!(\"longest -&gt; &#123;&#125;\", result);&#125;// 需要让参数 x，y 和 返回值 做生命周期的关联fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 11.3.3.2 生命周期标注生命周期标注语法 生命周期的标注不会改变引用的生命周期长度 当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用 生命周期的标注： 描述了多个引用的生命周期间的关系，但不影响生命周期 1234567891011121314151617fn main() &#123; let string1 = String::from(\"abcd\"); let string2 = \"abc\"; // 字符串字面量，也就是字符串切片类型 let result = longest(&amp;string1, string2); println!(\"longest -&gt; &#123;&#125;\", result);&#125;// 需要让参数 x，y 和 返回值 做生命周期的关联// 'a 为生命周期的标注： 描述了多个引用的生命周期的关系// 不影响生命周期fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 生命周期参数名： 以 单引号 开头 通常全小写非常短 很多使用’a 生命周期标注的位置 在引用的 &amp; 符号后 使用空格将标注 和 引用类型 分开 生命周期的标注 123&amp;i32 // 一个引用&amp; 'a i32 // 带有显式生命周期的引用&amp; 'a mut i32 // 带有显式生命周期的可变引用 单个生命周期标注本身没有意义 标注之所以存在，是为了向rust描述多个泛型生命周期参数之间的关系 12// 'a 生命周期取决于 x 和 y中 存活时间较短的那个fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str; 11.3.4 深入理解生命周期指定生命周期参数的方式依赖于函数所做的事情 从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配； 如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值： 这就是悬垂引用，该值在函数结束时就走出了作用域 1234567891011fn main()&#123; let string1 = String::from(\"abcd\"); let string2 = \"xyz\"; let result = longest(string1.as_str(), string2); println!(\"the longest string is&#123;&#125;\", result);&#125;fn longest&lt;'a&gt;(x: &amp; 'a str, y: &amp;str) -&gt; &amp;'a str &#123; let result = String::from(\"abc\"); // result.as_str() // 报错，字符串切片引用会随着函数执行完毕被释放，所以会导致 悬垂引用&#125; 解决方法一： 1234fn longest&lt;'a&gt;(x: &amp; 'a str, y: &amp;str) -&gt; String &#123; let result = String::from(\"abc\"); result // 把函数所有权移交给调用者；然后这块内存清理就交由调用者来清理&#125; 通过这个例子看出，生命周期语法就是用来关联函数的不同参数以及返回值之间生命周期的。一旦它们取得某种联系，rust就获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其它违反内存安全的行为； 11.3.4.1 Struct定义中的生命周期标注Struct里可包括： 自持有的类型 引用： 需要在每个引用上添加生命周期标注 12345678910111213struct ImportantExcerpt&lt;'a&gt; &#123; part: &amp;'a str,&#125;fn main()&#123; let novel = String::from(\"call me inhmael, Some years age...\"); // first_sentence 的生命周期反问大于 结构体内的 first_sentence；所以此段代码可以编译通过 let first_sentence = novel.split('.').next().expect(\"Could not found a '.'\"); let i = ImportantExcerpt&#123; part: first_sentence &#125;&#125; 11.3.4.2 生命周期的省略每个引用都有生命周期 需要为使用生命周期的函数或struct指定生命周期参数 123456789101112// 没有指定生命周期参数却通过编译fn first_word(s: &amp;str) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for(i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return &amp;s[0..i]; &#125; &#125; &amp;s[..]&#125;// 而之前的例子告诫我们应该写成下面这种才能编译通过fn first_word&lt;'a&gt;(s : &amp;'a str) -&gt; &amp; 'a str Rust发现，在某些特定情况下。程序员总是一遍又一遍编写同样的生命周期标注。而且这种场景是可预测的。它有一些明确的模式 于是，rust团队就将这些模式写入了编译器代码。就使得借用检查器在这些情况下可以自动的对生命周期进行推导，而无需显式的标注。 了解这段历史是有必要的，因为在未来可能会有更多的特定模式被直接添加到编译器当中；也就是说在未来需要手动标注生命周期的地方可能会越来越少； 11.3.4.3 生命周期省略规则这个在Rust引用分析中所编入的模式就称为生命周期省略规则； 这些规则无需开发者来遵守 它们是一些特殊情况，由编译器来考虑 如果你的代码复合这些情况，那么久无需显式标注生命周期 生命周期省略规则不会提供完整的推断： 如果应用规则后，引用的生命周期仍然模糊不清-&gt; 编译错误 解决方法： 添加生命周期标注，表明引用间的相互关系 11.3.4.4 输入、输出生命周期生命周期在 函数/方法的参数： 输入生命周期 函数/方法的返回值： 输出生命周期 11.3.4.5 生命周期省略的三个规则编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期； 规则1 应用于输入生命周期 规则2、3 应用于输出生命周期 如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用 -&gt; 报错 这些规则适用于fn定义 和 impl块 规则1: 每个引用类型的参数都有自己的生命周期 换句话说，单参数的函数它就拥有一个生命周期参数，而拥有两个参数的函数就拥有两个不同的生命周期参数。 规则2: 如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数 规则3： 如果有多个输入生命周期参数，但其中一个是 &amp;self 或者 &amp; mut self（是方法），那么self的生命周期会被赋给所有的输出生命周期参数 demo1 12345fn first_word(s: &amp;str) -&gt; &amp;str;// 首先适用第一条规则，单参数函数它拥有一个生命周期参数fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str;// 第二条规则，如果只有1个输入生命周期参数，该生命周期被赋给所有输出生命周期参数fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp; 'a str; demo2 1234567fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str;//首先应用规则1，两个参数都有自己的生命周期fn longest&lt;'a,'b&gt;(x: &amp;'a str, y: &amp;'b str)-&gt; &amp;str;// 因为有两个参数，所以第二条规则已经不适用了// 没有self，所有第三条也不适用//在应用完三条规则之后，依然无法计算出返回类型的生命周期。所以编译器报错。 11.3.5 方法定义中的生命周期标注在struct上使用生命周期实现方法，语法和泛型参数的语法一样 在哪儿声明和使用生命周期参数 依赖于 生命周期参数是否和字段、方法的参数或返回值有关 struct字段的生命周期名： 在impl后声明 在struct名后使用 这些生命周期是struct类型的一部分 impl块内的方法签名中： 引用必须绑定于struct字段引用的生命周期，或者引用是独立的也可以 生命周期省略规则经常使用方法中的生命周期标注不是必须的； 12345678910111213141516struct ImportantExcerpt&lt;'a&gt; &#123; part: &amp;'a str,&#125;// impl 后面 和结构体后面 的生命周期参数不能省略impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; &#123; fn level(&amp;self) -&gt; i32 &#123; 3 &#125;&#125;fn main()&#123; let novel = String::from(\"Call me Ishmael,Some...\"); let first_sentence = novel.split('.').next().expect(\"Could not found a '.'\"); let i = ImportantExcerpt &#123; part: first_sentence &#125;&#125; 11.3.6 静态生命周期‘static 是一个特殊的生命周期： 整个程序的持续时间； 例如： 所有的字符串字面值都拥有 ‘static 生命周期 12let s: &amp;'static str = \"i have a static lifetime\"// 这个字符串字面值，它是被直接存储在二进制程序里面。所以它总是可用的。所以所有字符串字面值的生命周期都是 'static 为引用指定 ‘static 生命周期前要三思 是否需要引用在程序整个生命周期内都存活 因为在大部分情况下，错误的原因都在于尝试创建一个悬垂引用或者是可用生命周期不匹配。这个时候应该去尝试解决这些问题，而不是指定一个 ‘static 一个涉及泛型参数类型、Trait Bound、生命周期的例子 12345678910111213use std::fmt::Display;fn longest_with_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a strwhere T: Display,&#123; println!(\"Announcement! &#123;&#125;\", ann); if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main()&#123;&#125; 12 编写自动化测试12.1 编写和运行测试测试 函数 验证非测试代码的功能是否和预期一致 测试函数体（通常）执行的3个操作 （3A操作） 准备数据/状态 Arrange 运行被测试的代码 Act 断言（Assert）结果 Assert 解剖测试函数 测试函数需要使用test属性（attribute）进行标注 Attribute 就是一段Rust代码的元数据，它不会被改变被它修饰代码的逻辑，它只是被代码进行修饰或标注 在函数上面一行加上 #[test]，可以函数变为测试函数 运行测试 使用cargo test命令运行所有测试函数 Rust会构建一个Test Runner可执行文件 它会运行标注了test的函数，并报错其运行是否成功 当使用cargo 创建library项目的时候，会生成一个test module，里面有一个test函数； 你可以添加任意数量的test module或函数 123456789101112131415161718192021$&gt; cargo new adder --lib # 创建一个库项目 adder$&gt; cd adder &amp;&amp; cargo test # 运行测试$&gt; Compiling adder v0.1.0 (/Users/ruanhan/rust_pro/adder)Finished test [unoptimized + debuginfo] target(s) in 1.25sRunning target/debug/deps/adder-710a662a5bf33e5erunning 1 test# 测试 tests::it_works test tests::it_works ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered outDoc-tests adderrunning 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out 测试失败 测试函数panic就表示失败 每个测试运行在一个新线程 当主线程看见某个测试线程挂掉了，那个测试标记为失败了； 12.2 断言宏（Assert）使用assert! 宏检查测试结果 assert！ 宏，来自标准库，用来确定某个状态是否为true true 测试通过 false 调用panic！，测试失败 1234567891011121314151617181920212223242526272829#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] fn larger_can_hold_smaller() &#123; let larger = Rectangle &#123; width: 8, height: 7, &#125;; let smaller = Rectangle &#123; width: 5, height: 1, &#125;; assert!(larger.can_hold(&amp;smaller)); &#125;&#125; 使用assert_eq! 和 assert_ne! 测试相等性 都来自标准库 判断两个参数是否 相等或不等； 实际上，它们使用的就是 == 和 != 运算符 断言失败： 自动打印出两个参数的值； 使用debug格式打印参数 要求参数实现了 PartiaEq 和 Debug Traits（所有的基本类型和标准库里大部分类型都实现了） 123456789101112pub fn add_two(a: i32) -&gt; i32 &#123; a + 2&#125;#[cfg(test)]mod tests1 &#123; use super::*; #[test] fn it_adds_two() &#123; assert_eq!(4, add_two(2)); &#125;&#125; 12.3 自定义错误信息可以向 assert! assert_eq! assert_ne! 添加可选的自定义信息 这些自定义消息和失败消息都会打印出来 assert!: 第1参数必填，自定义消息作为第2个参数 assert_eq! assert_ne! ： 前2个参数必填，自定义消息作为第3个参数； 自定义消息参数会被传递给 format! 宏，可以使用{} 占位符 12345678910111213pub fn greeting(name: &amp;str) -&gt; String &#123; format!(\"Hello &#123;&#125;!\", name)&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] fn greeting_contain_name() &#123; let result = greeting(\"Carol\"); assert!(result.contains(\"Caro1l\"), \"错误信息是 '&#123;&#125;'\", result); &#125;&#125; 12.4 用should_panic检查恐慌验证错误处理的情况 测试除了验证代码的返回值是否正确，还需验证代码是否如预期的处理了发生错误的情况； 可验证代码在特定情况下是否发生了panic 这种测试需要添加 should_panic 属性 1234567891011121314151617181920212223242526pub struct Guess &#123; value: i32,&#125;impl Guess &#123; pub fn new(value: i32) -&gt; Guess &#123; if value &lt; 1 || value &gt; 100 &#123; panic!(\"Guess value must be between 1 and 100, got &#123;&#125;.\", value); &#125; Guess &#123; value &#125; &#125;&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] #[should_panic] fn greater_than_100() &#123; Guess::new(200); &#125;&#125; 为should_panic 属性添加一个可选的expected参数，让should_panic更精确；将检查失败信息中是否包含所指定文字； 1#[should_panic(expected=\"guess value must be less than ...\")] 12.5 在测试中使用Result&lt;T,E&gt;无需panic，可使用Result&lt;T,E&gt; 作为返回类型编写测试： 返回Ok： 测试通过 返回Err： 测试失败 1234567891011#[cfg(test)]mode test &#123; #[test] fn it_works -&gt; Result&lt;(), String&gt; &#123; if 2+2 ==4 &#123; Ok(()) &#125; else &#123; Err(String::from(\"not equal\")) &#125; &#125;&#125; 注意： 不要在使用Result&lt;T,E&gt; 编写的测试上标注 #[should_panic] 12.6 控制测试如何运行改变cargo test的行为： 添加命令行参数 不添加任何参数就是默认行为 并行运行 所有测试 捕获（不显示）所有输出，使读取与测试结果相关的输出更容易 1234# 显示cargo test命令 所用的参数有哪些cargo test --help # 显示出所有可以用在-- 后的参数，给二进制程序添加的参数cargo test -- --help 12.7 并行/连续运行测试运行多个测试： 默认使用多个线程并行运行； 运行快 确保测试之间 不会互相依赖 不依赖于某个共享状态（环境、工作目录、环境变量等） 显式函数输出 默认，如测试通过，rust的test库会捕获所有打印到标准输出的内容 例如： 如果被测试代码中用到了println! 如果测试通过： 不会在终端看到println! 打印的内容 如果测试失败： 会看到println! 打印的内容和失败信息 如果想在成功的测试中看到打印的内容： –show-output 12.8 按名称运行测试运行单个测试： 指定测试名 运行多个测试： 指定测试名的一部分（模块名也可以） 12.9 忽略测试忽略某些测试，运行剩余测试 ignore属性（attribute） 12345678910111213#[cfg(test)]mod tests &#123; #[test] fn it_works()&#123; assert_eq!(4, 2+2); &#125; #[test] #[ignore] // 忽略 expensive_test这个测试 fn expensive_test()&#123; assert_eq!(5, 1+1+1+1+1); &#125;&#125; cargo test – –ignore 单独执行此忽略的测试 12.10 测试的分类Rust对测试的分类 单元测试 集成测试 单元测试 小、专注 一次对一个模块进行隔离的测试 可测试private接口 集成测试： 在库外部，和其它外部代码一样使用你的代码 只能使用public接口 可能在每个测试中使用多个模块 #[cfg(test)] 标注 test 模块上的 #[cfg(test)]标注 只有运行 cargo test 才编译和运行代码 运行cargo build则不会 集成测试在不同的目录，它不需要 #[cfg(test)] 标注 cfg：configuration 告诉rust下面的条目只有在特定的配置选项下才被包含 配置选项test： 由Rust提供，用来编译和运行测试 只有cargo test才会编译代码，包括模块中的helper函数和 #[test]标注的函数 测试私有函数 rust允许测试私有函数 12.11 集成测试在Rust里，集成测试完全位于被测试库的外部 目的：是测试被测试库的多个部分是否能正确在一起工作 集成测试的覆盖率很重要； 13 rustlingsThanks for installing Rustlings! Is this your first time? Don’t worry, Rustlings was made for beginners! We aregoing to teach you a lot of things about Rust, but before we can getstarted, here’s a couple of notes about how Rustlings operates: The central concept behind Rustlings is that you solve exercises. Theseexercises usually have some sort of syntax error in them, which will causethem to fail compliation or testing. Sometimes there’s a logic error insteadof a syntax error. No matter what error, it’s your job to find it and fix it!You’ll know when you fixed it because then, the exercise will compile andRustlings will be able to move on to the next exercise. If you run Rustlings in watch mode (which we recommend), it’ll automaticallystart with the first exercise. Don’t get confused by an error message poppingup as soon as you run Rustlings! This is part of the exercise that you’resupposed to solve, so open the exercise file in an editor and start yourdetective work! If you’re stuck on an exercise, there is a helpful hint you can view by typing‘hint’ (in watch mode), or running rustlings hint myexercise. If an exercise doesn’t make sense to you, feel free to open an issue on GitHub!(https://github.com/rust-lang/rustlings/issues/new). We look at every issue,and sometimes, other learners do too so you can help each other out! Got all that? Great! To get started, run rustlings watch in order to get the firstexercise. Make sure to have your editor open!","categories":[{"name":"rust","slug":"rust","permalink":"http://yoursite.com/categories/rust/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"go1","slug":"go1","date":"2021-03-09T12:15:16.000Z","updated":"2021-03-23T09:11:20.918Z","comments":true,"path":"2021/03/09/go1/","link":"","permalink":"http://yoursite.com/2021/03/09/go1/","excerpt":"","text":"1. 编译型语言Go 语言是一门编译语言 在运行程序之前，GO首先使用编译器把代码编译成机器可以识别的1和0 它会把代码编译成一个可执行文件，在编译的过程中，编译器能捕获一些错误； 解释型语言 python，js等都是使用解释器，随着程序运行，一个语句一个语句进行翻译，但也这意味着bug可能就潜伏在你还没测试过的路径上。这些就是解释型语言； 2. install gogo 代理 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 1234567/usr/local/go # go环境 编译器路径$&gt; cd go/bin &amp;&amp; ls$&gt; go # go语言编译环境 # 需要将这个路径配置到环境变量中 /usr/local/go/bin/go$&gt; gofmt$&gt; vim ~/.bashrc#编辑之后$&gt; source ~/.bashrc 1234# 设置go语言路径export GOROOT=/usr/local/go # 源码包所在路径export GOPATH=$HOME/go # go开发者 go的项目默认路径export PATH=$PATH:$GOROOT/bin:$GOPATH/bin 12$&gt; go env # 查看配置export GO111MODULE=on # 修改go env 3. const var常量与变量 1234567var ( a = 1 b = 2)var distance, speed = 56, 108const hours, minutes = 24, 60 3.1 短声明12345678910111213141516171819202122232425262728// 以下两种声明效果一样var count = 10count:= 10// 短声明可以在无法使用var的地方使用var count = 0for count= 10; count&gt;0; count-- &#123; fmt.Println(count)&#125;for count:=10; count&gt;0; count-- &#123; fmt.Println(count)&#125;if num:=rand.Intn(3);num==0 &#123; &#125; else &#123; &#125;switch num:=rand.Intn(10); num&#123; case 1: fmt.Printls(\"1\") case 2,3: fmt.Printls(\"2\") default: ..&#125; 短声明不能用来声明 package作用域的变量 era变量在main函数外声明的 它拥有package作用域 如果main package有多个函数，那么era对它们都可见 package作用域的变量不能用短声明 12345678package mainimport ( \"math/rand\")var era = \"AD\"func main()&#123; year := 2018&#125; 4. 运算符12345// 以下3个等价age = age + 1age += 1age++++age // error 4.1 逻辑运算符|| 或 &amp;&amp; 与 ！ 可以把true 变为 false，反之亦然 5. 包引用多个包 1234567891011121314package mainimport ( \"fmt\" \"math/rand\")func main() &#123; var number = rand.Intn(10) + 1 fmt.Println(number) number = rand.Intn(10) + 1 fmt.Println(number)&#125; 5.1 包路径管理把项目建在 GOPATH的src目录下； 1234567891011package mainimport ( \"golangStudy/00module/lib1\" // 路径需要写全 ，此路径针基于 gopath下的src 往下查找的 \"golangStudy/00module/lib2\")func main() &#123; lib1.Lib1Test1() lib2.Lib2Test2()&#125; 5.2 匿名导包1import \"_lib1\" // 添加下划线，某个场景只需要执行该包 init方法的时候 5.3 取别名1import mylib2 \"lib2\" 5.4 Go modulesGo modules 是go语言的依赖解决方案，发布于Go1.11， 成长于Go1.12，正式于Go1.14 推荐在生产上使用 Go modules解决Go1.11 前的几个常见争议问题 GO语言长久以来的依赖管理问题 淘汰 现有的GOPATH的使用模式 统一社区中的其它的依赖管理工具（提供迁移功能） GOPATH的工作模式 Go modules的目的之一就是淘汰GOPATH； 123$&gt; go env$&gt; GOPATH=Users/xxx/go$&gt; cd $GOPATH GOPATH的弊端 无版本控制概念， go get -u github.com/xxx/xxx 无法指定版本 无法同步一致第三方版本号 无法指定当前项目引用的第三方版本号 5.4.1 Go mod 命令12345678go mode init # 生成 go.modgo mode download # 下载go.mod 文件中指明的所有依赖go mode tidy # 整理现有的依赖go mode graph # 查看现有的依赖结构go mode edit # 编辑 go.mod 文件go mode vendor # 导出项目所有的依赖到vendorgo mode verify # 校验一个模块是否被篡改过go mode why # 查看为什么需要依赖某模块 5.4.2 Go mod环境变量GO111MODULE go提供 GO111MODULE 作为go modules的开关；其允许设置以下参数 auto 只要项目包含了go.mod文件的话启用Go modules， on 启用Go modules，推荐设置 off 禁用Go modules，不推荐设置 12# 设置 GO111MODULEgo env -w GO111MODULE=\"on\" GOPROXY 这个环境变量主要是用于设置Go模块代理（Go module proxy），其作用是用于使Go在后续拉取模块版本时直接通过镜像站点来快速拉取 代理 阿里云 https://mirrors.aliyun.com/goproxy 七牛云 https://goproxy.io,direct GOSUMDB 它的值是一个Go checksum database， 用于在拉取模块版本时，保证拉去的模块版本数据未经过篡改，若发现不一致，将会立即中止； GOPARVATE 私有仓库，设置了GOPARVATE的话，就不再需要去GOPROXY上去下载，也不需要从GOSUMDB上去校验了 go env -w GOPRIVATE=&quot;*.example.com&quot; 5.4.3 go mod 初始化项任意文件夹创建一个项目（不要求在 $GOPATH/src） 123$&gt; mkdir modules_test$&gt; cd modules_test &amp;&amp; go mod init github.com/orgs/TenonMortise/modules_test$&gt; go get github.com/go-sql-driver/mysql 1234567package mainimport ( _github.com/go-sql-driver/mysql)func main()&#123; &#125; Go mod模式中 包都下载到了 $GOPATH/pkg 中 在该项目编写源代码 123import ( \"github.com/go-sql-driver/mysql\") 12# 手动下载go get github.com/go-sql-driver/mysql go.sum 作用： 罗列当前项目直接或间接的依赖所有模块版本，保证今后项目以来的版本不会被覆盖 h1:hash 表示整体项目的zip文件打开之后的全部文件的校验和生成的hash， 如果不存在，可能表示依赖的库可能用不上； xxx/go.mod h1:hash. Go.mod文件做的hash 5.4.4 修改项目模块的版本依赖关系1$&gt; go mod edit -replace=zinx@v0.0.0-xxx=zin@v1.0.0-xxx 12# go.mod 会多一行replace语句replace zin -replace=zinx@v0.0.0-xxx=&gt;zin@v1.0.0-xxx 6 循环 分支6.1 Boolean类型true 和false go中，” “ 空串不会自动转为false 6.2 strings.Contains来自strings包的Contains函数可以判断某个字符串是否包含另外要给字符串 12345678910111213package mainimport ( \"fmt\" \"strings\")func main() &#123; fmt.Println(\"you find yourself in a dimlu lit cavern\") var command = \"walk outside\" var exit = strings.Contains(command, \"outside\") fmt.Println(\"you leave the cave: \", exit)&#125; 6.3 compare如果比较两个值，得到的结果也是 true 或false 比较运算符： == &lt;= &lt; != &gt;= &gt; 6.4 if判断条件不加括号 1234567if command == \"alex\" &#123; &#125; else if command == \"let\" &#123; &#125; else &#123; &#125; 6.6 swtch条件不加括号，不需要break关键字 还有一个fallthrough关键字，它用来执行下一个case的body部分。 123456789101112131415161718192021var command = \"alex\"switch command &#123; case \"gi\": .. case \"go\",\"run\": .. default: ..&#125;var room = \"cave\"switch room &#123; case \"cave\": fmt.Printls(\"1\") fallthrough case \"go\",\"run\": fmt.Printls(\"2\") default: ..&#125;// 输出 1，2 6.7 循环for关键字让代码重复执行 for后边没有根条件，那就是无限循环 可以使用break跳出循环 遍历数组 123456func main() &#123; numbers := [5]int&#123;1, 2, 3, 4, 5&#125; for i, num := range numbers &#123; fmt.Println(i, num) &#125;&#125; 6.8 变量的作用域当变量被声明以后，它就进入了作用域 只要变量在作用域内，你就可以访问它 否则，访问它会报错的 变量声明的位置，决定了它的作用域 作用域的好处？ 可以在不通的作用域内使用相同的变量名 在Go里面， 作用域的范围就是{}之间的部分 7. 数据类型7.1 声明浮点型变量下面这三个语句的效果是一样的 123days := 365.2425var days = 365.2425var days float64 = 365.2425 只要数字含有小数部分，那么它的类型就是float64 如果你使用一个整数来初始化某个变量，那么你必须指定它的类型为float64，否则它就是一个整数类型 7.2 单精度浮点数类型Go语言有两种浮点数类型 默认是float64 64位的浮点类型 占用8字节内存 某些编程语言把这种类型叫做double（双精度） float32 占用4字节内存 精度比float64低 有时叫做单精度类型 12345var pi64 = math.Pivar pi32 float32 = math.Pifmt.Println(pi64)fmt.Println(pi32) 7.3 单双精度的使用场景 当处理大量数据时，例如3D游戏中的数千个顶点，使用float32牺牲精度来节省内存是很有意义的； math包里面的函数操作的都是float64类型，所以应该首选使用float64，除非你有足够的理由不去使用它； 7.4 零值Go里面每个类型都有一个默认值，称作零值 当你声明却不对它进行初始化的时候，它的值就是零值 1234var price float64fmt.Println(price)price := 0.0 7.5 显示浮点类型 使用Print或Println打印浮点类型的时候，默认的行为是尽可能的多显示几位小数 结合%f格式显示小数的位置 12345third := 1.0/3fmt.Printf(\"%v\\n\", third)fmt.Printf(\"%f\\n\", third)fmt.Printf(\"%.3f\\n\", third)fmt.Printf(\"%4.2f\\n\", third) %4.2f %4 标识宽度 2f 表示precision 宽度： 会显示出的最少字符个数（包括小数点和小数） 如果宽度大于数字的个数，那么左边会填充空格 如果没指定宽度，那么就按实际的位数进行显示 精度： 小数点后边显示的位数 7.6 整数类型12var year int = 2018 // 常用整型var month uint = 2 // 无符号整数类型 7.6.1 int 和 uintint和uint是针对目标设备优化的类型 在old 的移动设备上，int 和 uint都是32位的 比较新的计算机上，int 和 uint都是64位的 虽然在某些设备上int可以看作int32，在某些设备上可以看作是int64，但他们其实是3种不同的类型 int并不是其它类型的别名 tip 如果你在较老的32位设备上，使用了超过20亿的整数，而且代码还能运行，那么最好使用int64 和 uint64 来代替 int和uint 7.6.2 uint8uint8 可以表示8位的颜色（红绿蓝： 0-255） 1var red, green, blue uint8 = 0,141,213 为什么不使用int uint8取值范围正好合适，而int则多出来几十亿不合理的数字 如果很多颜色数据连续存储，例如未被压缩的图片，那么使用uint8可以节省很多内存 7.7 输出数据类型12a:= 1.0fmt.Println(\"%T\", a) 7.8 文本7.8.1 声明字符串123peace := \"peace\"var peace = \"peace\"var peace string = \"peace\" 字符串的零值： 1var blank string 7.9 类型转换连接两个字符串，使用+运算符 1cout:= \"alex\" + \"leo\" // compiler success 如果想连接字符串和数值，是会报错的 1cout:= \"alex\" + 10 + \"leo\" // compiler error 整数和浮点数也不能直接连接 123// 如果想把age转化成浮点类型，需要使用目标类型将其“包裹”起来age := 41marsAge := float(age) 从浮点类型转为整数类型 可以从浮点类型转化为整数类型，小数点后面的部分会被截断，而不是舍入 12earthDays := 365.2425int(earthDays) 8. 函数8.1 函数声明在go里，大写字母开头的函数、变量或其它标识符都会被导出，对其它包可用； 小写字母开头的就不行； 8.2 方法也是一个函数，但是它根某一个类型相关联的； 声明新类型 关键字type可以用来声明新类型： 12type celsius float64var temperature celsius = 20 虽然celsius 是一种全新的类型，但是由于它和float64具有相同的行为和表示，所以赋值操作能顺利执行； 例如加法等运算，也可以像float64那样使用； 8.2.1 通过方法添加行为在C#、java里，方法属于类 在Go里，它提供了方法，但是没提供类和对象 go比其它语言的方法要灵活 可以将方法与同包中声明的任何类型相关联、但不可以是int、float64等预声明的类型进行关联； 12345678910111213141516171819202122232425262728func main()&#123; // 两种类型不能混用，哪怕底层指向的是同一类型 type celsius float64 type kelvin float64 var w float64 = 10 var k kelvin = 20 k+=w // compiler error&#125;type Point struct &#123; X float64 y float64&#125;// p为接收者， 类似this 的作用func (p Point) distance(q Point) bool &#123; return q.y &gt; p.y &amp;&amp; q.X &gt; p.X&#125;func main() &#123; var point = Point&#123;3.12, 3.14&#125; var point1 = Point&#123;4.10, 3.12&#125; fmt.Println(point.y) fmt.Println(point.distance(point1))&#125; 在每个方法可以有多个参数，但只能有一个接收者 在方法体中，接收者的行为和其它参数一样； 8.2.2 方法调用变量.方法() 123456789101112131415type Point struct &#123; X float64 y float64&#125;// p为接收者， 类似this 的作用func (p Point) distance(q Point) bool &#123; return q.y &gt; p.y &amp;&amp; q.X &gt; p.X&#125;func main() &#123; var point = Point&#123;3.12, 3.14&#125; var point1 = Point&#123;4.10, 3.12&#125; fmt.Println(point.distance(point1)) // 变量.方法()&#125; 8.3 一等函数在go里，函数是头等的，它可以用在整数、字符串或其它类型能用的地方； 将函数赋给变量 将函数作为函数的返回类型 1234567891011121314type kelvin float64func fakeSensor () kelvin &#123; ...&#125;func realSensor () kelvin &#123; ...&#125;func main()&#123; sensor:= fakeSensor sensor() sensor:= realSensor sensor()&#125; 将函数作为参数传递给函数 1234567891011type kelvin float64func measureTemperature (samples int, sensor func() kelvin) &#123; ...&#125;func fakeSensor () kelvin &#123; ...&#125;func main()&#123; measureTemperature(3, fakeSensor)&#125; 声明函数类型 为函数声明类型有助于精简和明确调用者的代码 12345type sensor func() kelvinfunc measureTemperature (samples int, s func() kelvin)// 可以优化为func measureTemperature (samples int, s sensor ) 闭包和匿名函数 匿名函数就是没有名字的函数，在Go里也称作函数字面值； 1234567891011121314package mainimport \"fmt\"func main()&#123; f := func()&#123; fmt.Println(\"&gt;&gt;.\") &#125; f() &#125;fn main()&#123; func()&#123; fmt.Println(\"&gt;&gt;.\") &#125;()&#125; 因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的； 123456789101112type k float64type sensor func() kfunc realSensor() k &#123;return 0&#125;func calibrate(s sensor, offset k) sensor &#123; return func() kelvin &#123; return s() + offset &#125;&#125;func main()&#123; sensor := calibrate(realSensor, 5) sensor()&#125; 闭包就是由于怒名函数封闭并包围作用域中的变量而得名的； 123456789101112func main() &#123; type k int64 type sersor func() k var f k = 3 ser := func() k &#123; return f &#125; fmt.Println(ser()) // 3 f++ fmt.Println(ser()) // 4&#125; 8.4 多返回值123456789101112131415161718192021func foo2()(int ,int) &#123; return 666, 777&#125;func foo3()(r1 int ,r2 int) &#123; // 有名称的返回值 r1= 666 r2 =777 return&#125;func foo4()(r1 ,r2 int) &#123; // 有名称的返回值 r1= 666 r2 =777 return&#125;func main()&#123; ret1, ret2 := foo2() r1, r2 := foo3() &#125; 9 数组9.1 数组的复制无论数组赋值给新的变量还是将它传递给函数，都会产生一个完整的数组副本 123456789func main() &#123; plants := [...]string&#123;\"a\", \"b\", \"c\"&#125; clones := plants plants[0] = \"alex\" fmt.Println(plants) fmt.Println(clones) // [alex b c] // [a b c]&#125; 数组也是一种值，函数通过值传递来接收参数，所以数组作为函数的参数就非常低效 123456789101112131415func clonefunc(p [3]string) [3]string &#123; for i := range p &#123; p[i] = \"pruffix\" + p[i] &#125; return p&#125;func main() &#123; plants := [...]string&#123;\"a\", \"b\", \"c\"&#125; fmt.Println(clonefunc(plants)) fmt.Println(plants) // [pruffixa pruffixb pruffixc] // [a b c]&#125; 数组的长度也是数组类型的一部分 尝试将长度不符的数组作为参数传递，将会报错 函数一般使用slice而不是数组作为参数 10 slice指向数组的窗口 假如p 是一个数组，那么 p[0:4] 就是一个切片，它切分出数组里面前4个元素 切分数组不会导致数组被修改，它只是创建了指向数组的一个窗口或视图，这种视图就是slice类型； 默认索引 [:10] [1:] [:] 切分数组的语法也可以用于切分字符串 切分字符串时，索引代表的是字节数而非 字符串的数； 12que := \"汉字^&amp;COMasf\"fmt.Println(que[:3]) // 汉 10.1 slice的字面值Go里面很多函数都倾向于使用slice而不是数组作为参数 想要获得与底层数组相同元素的slice，那么可以使用[:]进行切分 10.2 声明slice1234// 声明sliced := []string &#123;\"a\",\"b\",\"c\"&#125;// 声明arrayf := [...]string &#123;\"a\", \"c\"&#125; 1234567891011func hyper(worlds []string) &#123; for i := range worlds &#123; worlds[i] = strings.TrimSpace(worlds[i]) &#125;&#125;func main() &#123; planets := []string&#123;\"a \", \" b\", \" c \"&#125; hyper(planets) fmt.Println(planets) // a b c&#125; 10.3 带有方法的切片在go里，可以将slice或数组作为底层类型，然后绑定其它方法 1234567891011type StringSlice []stringfunc (p StringSlice) Sort() &#123;&#125;func main() &#123; planets := []string&#123; \"Mer\", \"Ven\", \"Ear\", &#125; sort.StringSlice(planets).Sort() fmt.Println(planets) // [Ear Mer Ven]&#125; 10.4 append函数append函数也是内置函数，它可以将元素添加到slice里面 123456planets := []string&#123; \"Mer\", \"Ven\", \"Ear\",&#125;sort.StringSlice(planets).Sort()planets = append(planets, \"Xyy\")fmt.Println(planets) // [Ear Mer Ven Xyy] 思考一个问题 当直接声明planets := []string{&quot;Mer&quot;, &quot;Ven&quot;, &quot;Ear&quot;,}的时候，会创建一个数组。该数组有3个元素。后面append又给 planets添加了1个元素。因为声明的数组是定长，那么append的这个元素被添加到哪里了呢？ 10.5 长度和容量 长度就是切片里有多少个元素， 容量就是指切片对应的底层数组，底层数组的容量是多少，那么切片的容量就是多少 slice中元素的个数决定slice的长度 如果slice底层数组比slice还大，那么就说该slice还有容量可供增长 获取切片的长度 len(slice) 获取切片的容量 cap(slice) 12345678910111213func dump(label string, slice []string) &#123; fmt.Printf(\"%v: length %v, cap %v \\n\", label, len(slice), cap(slice))&#125;func main() &#123; planets := []string&#123; \"Mer\", \"Ven\", \"Ear\", \"Xyy\", \"Z@@\", &#125; dump(\"planets\", planets) dump(\"planets[1:2]\", planets[1:2])&#125;// planets: length 5, cap 5 // planets[1:2]: length 1, cap 4 当往一个切片append元素的时候，要看一下底层数组的长度够不够，如果不够的话，新声明一个长度为当前数组长度两倍长度的数组，然后将老数组的值依次复制到新数组里面，再追加append的元素。如果够的话，直接追加不创建新数组； planets[1:2] cap为何是 4 ？ 10.6 三个索引的切分操作Go1.2 引入了能够限制新建切片容量的三索引切分操作 123456func main() &#123; planets := []string&#123; \"Mer\", \"Ven\", \"Ear\", \"Xyy\", \"Z@@\", &#125; ter := planets[0:4:4] // 第三个指定切片容量为4&#125; 10.7 使用make函数对slice进行预分配当slice的容量不足以执行append操作时，Go必须创建新数组并复制旧数组中的内容 但通过内置的make函数，可以对slice进行预分配策略 尽量避免额外的内存分配和数组复制操作 123456789101112func dump(label string, slice []string) &#123; fmt.Printf(\"%v: length %v, cap %v \\n\", label, len(slice), cap(slice))&#125;func main() &#123; planets := make([]string, 0, 10) // 设置 长度 容量 dump(\"aa\", planets) // aa: length 0, cap 10 planets = append(planets, \"Mer\", \"Ven\", \"Ear\", \"Xyy\", \"Z@@\", ) dump(\"bb\", planets) // bb: length 5, cap 10&#125; 10.8 声明可变参数的函数声明Printf append 这样的可变参数函数，需要在函数的最后一个参数前面加上 … 符号； 123456789101112131415161718192021// ...string 行参// planets... 实参func terraform(prefix string, worlds ...string) []string &#123; newWorlds := make([]string, len(worlds)) for i := range worlds &#123; newWorlds[i] = prefix + \" \" + worlds[i] &#125; return newWorlds&#125;func main() &#123; twoWorlds := terraform(\"New\", \"Venus\", \"Mars\") fmt.Println(twoWorlds) // [New Venus New Mars] planets := []string&#123;\"Venus\", \"Mars\", \"Jupiter\"&#125; newPlanets := terraform(\"New\", planets...) fmt.Println(newPlanets) // [New Venus New Mars New Jupiter]&#125; 11. map11.1 声明map[string]int 1234temperature := map[string]int &#123; \"E\": 15, \"M\": -65&#125; 11.2 map不会被复制数组，int 等类型在赋值给新变量或传递至函数/方法的时候会创建相应的副本 map不会, 123456789101112131415func main() &#123; planets := map[string]string&#123; \"E\": \"Sector zz9\", \"Mars\": \"Sector zz9\", &#125; planetsMark := planets planets[\"Earth\"] = \"whoops\" fmt.Println(planets) // map[E:Sector zz9 Earth:whoops Mars:Sector zz9] fmt.Println(planetsMark) // map[E:Sector zz9 Earth:whoops Mars:Sector zz9] delete(planets, \"Earth\") fmt.Println(planetsMark) // map[E:Sector zz9 Mars:Sector zz9]&#125; 11.3 使用make对map进行预分配1temperature := make(map[float64]int, 8) 创建map时，make函数可以接受一个或者两个参数 第二个参数用于为指定数量的key预先分配空间 使用make函数创建的map初始长度为0 123456789101112131415func main() &#123; temperatures := []float64&#123; -28.0, 32.0, -31.0, -29.0, -23.0, -29.0, -28.0, -33.0, &#125; frequency := make(map[float64]int) // key 为float64 value为int for _, t := range temperatures &#123; frequency[t]++ &#125; for t, num := range frequency &#123; fmt.Printf(\"%+.2f occurs %d times\\n\", t, num) &#125;&#125; 12. structstruct允许将不同的类型的东西组合在一起 12.1 声明123type location struct &#123; lat, long float64&#125; 12.2 将struct编码为JSONjson包的Marshal函数可以将struct中的数据转化为JSON格式 1234567891011121314151617func main() &#123; type location struct &#123; Lat, Long float64 &#125; curiosity := location&#123;-4.12, 123.23&#125; bytes, err := json.Marshal(curiosity) exitOnError(err) fmt.Println(string(bytes)) // &#123;\"Lat\":-4.12,\"Long\":123.23&#125;&#125;func exitOnError(err error) &#123; if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 12.3 使用struct标签来自定义JSONgo语言中的json包要求struct中的字段必须以大写字母开头，类似驼峰命名； 但有时候需要snake_case蛇形命名规范，那么该怎么办？ 可以为字段标注标签，使得json包在进行编码的时候能够按照标签里的样式修改字段名 123456789101112131415161718func main() &#123; type location struct &#123; Lat float64 `json:\"latitude\"xml:\"latitude\"` Long float64 `json:\"longitude\"` &#125; curiosity := location&#123;-4.12, 123.23&#125; bytes, err := json.Marshal(curiosity) exitOnError(err) fmt.Println(string(bytes)) // &#123;\"latitude\":-4.12,\"longitude\":123.23&#125;&#125;func exitOnError(err error) &#123; if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 12.3.1 结构体标签在json中的应用123456789101112131415161718192021222324252627282930313233package mainimport ( \"encoding/json\" \"fmt\")type Movie struct &#123; Title string `json:\"title\"` // 当前的字段在json中显示的名称是什么 Year int `json:\"year\"` Actors []string `json:\"actors\"`&#125;func main() &#123; movie := Movie&#123;\"alex\", 2000, []string&#123;\"xing\"&#125;&#125; // struct -&gt; json jsonStr, err := json.Marshal(movie) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(\"jsonStr = %s\\n\", jsonStr) // json -&gt; struct movie2 := Movie&#123;&#125; err = json.Unmarshal(jsonStr, &amp;movie2) if err != nil &#123; fmt.Println(err) return &#125;&#125;// jsonStr = &#123;\"title\":\"alex\",\"year\":2000,\"actors\":[\"xing\"]&#125;// struct=&#123;alex 2000 [xing]&#125; 12.4 将方法关联到struct方法可以关联到声明的类型上 1234567type coordinate struct &#123; d,m,s float64 h rune&#125;func (c coordinate) decimal() float64&#123; &#125; 12.4.1 构造函数可以使用struct复合字面值来初始化你所要的数据 但如struct初始化的时候还要做很多事情，那就可以考虑写一个构造用的函数 Go语言没有专用的构造函数，但以new或者New开头的函数，通常是用来构造数据的，例如 newPerson NewPerson 1234567891011121314151617181920212223242526type coordinate struct &#123; d,m,s float64 h rune&#125;func (c coordinate) decimal() float64&#123; sign := 1.0 switch c.h &#123; case 'S', 'W','s','w': sign = -1 &#125; return sign * (c.d + c.m/60 + c.s/3600)&#125;// 构造用的函数,在go中没有专业的构造函数func newLocation(lat, long coordinate) location &#123; return location&#123;lat.decimal(), long.decimal()&#125;&#125;type location struct &#123; lat, long float64&#125;func main()&#123; lat := coordinate&#123;...&#125; long := coordinate&#123;...&#125; curiosity := newLocation(lat, long)&#125; 12.4.2 New函数有一些用于构造的函数的名称就是New （例如errors包里面的New函数） 这是因为函数调用时使用 包名.函数名 的形式 如果该函数叫NewError，那么调用的时候就是errors.NewError()， 这就不如errors.New() 简洁 12.5 class的替代方案Go语言没有class，但使用struct并配备几个方法也可以达到同样的效果 12.6 反射对一个已经的变量作为输入，得出该变量的type 和 value 1234func Valueof(i interface&#123;&#125;) Value// valueof 用来获取输入参数接口中的数据的值，如果接口为空则返回0func Typeof(i interface&#123;&#125;) Type&#123;...&#125;// Typeof 用来动态获取输入参数接口的值的类型，如果接口为空则返回nil 123456func reflectName(num interface&#123;&#125;) &#123; fmt.Println(reflect.TypeOf(num)) fmt.Println(reflect.ValueOf(num)) // float64 // 1.23&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"reflect\")type User struct &#123; id int name string age int&#125;func (this User) Call() int &#123; return 0 &#125;func DoFileAndMethod(input interface&#123;&#125;) &#123; inputType := reflect.TypeOf(input) fmt.Println(\"inputType is:\", inputType.Name()) inputValue := reflect.ValueOf(input) fmt.Println(\"inputValue is:\", inputValue) // 通过type 获取里面的字段 for i := 0; i &lt; inputType.NumField(); i++ &#123; field := inputType.Field(i) value := inputValue.Field(i) fmt.Printf(\"%s: %v = %v\\n\", field.Name, field.Type, value) &#125; // 通过type获取里面的方法 for i := 0; i &lt; inputType.NumMethod(); i++ &#123; m := inputType.Method(i) fmt.Printf(\"%s: %v\\n\", m.Name, m.Type) &#125;&#125;func main() &#123; user := User&#123;1, \"alex\", 18&#125; DoFileAndMethod(user)&#125;// inputType is: User// inputValue is: &#123;1 alex 18&#125;// id: int = 1// name: string = alex// age: int = 18// Call: func(main.User) int 反射结构体标签 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"reflect\")type resume struct &#123; Name string `info:\"name\" doc:\"名字\"` Sex string `info:\"sex\"`&#125;func findTag(str interface&#123;&#125;) &#123; t := reflect.TypeOf(str).Elem() for i := 0; i &lt; t.NumField(); i++ &#123; tagstring := t.Field(i).Tag.Get(\"info\") tagdoc := t.Field(i).Tag.Get(\"doc\") fmt.Println(\"info:\", tagstring, \"doc:\", tagdoc) &#125;&#125;func main() &#123; var re resume findTag(&amp;re) // info: name doc: 名字 // info: sex doc:&#125; 13. 组合和转发13.1 组合在面向对象的世界中，对象由更小的对象组合而成 术语： 对象组合或组合 Go通过结构体视线组合（composition） Go提供了“嵌入”（embedding） 特性，他可以实现方法的转发（forwarding） 组合是一种更简单，灵活的方式 拆分类型 1234567891011121314151617181920212223type report struct &#123; sol int high, low float64 lat, long float64&#125;// 拆分类型type reportNew struct &#123; sol int temperature temperature location location&#125;type temperature struct &#123; high, low celsius&#125;type location struct &#123; lat, long celsius&#125;type celsius float64 duck type 12345678910111213141516171819202122232425262728293031323334package maintype reportNew struct &#123; sol int temperature temperature location location&#125;type temperature struct &#123; high, low celsius&#125;type location struct &#123; lat, long celsius&#125;type celsius float64func (t temperature) averae() celsius &#123; return (t.high + t.low) / 2&#125;// 或者func (r reportNew) averae() celsius &#123; return r.temperature.averae()&#125;func main() &#123; t := temperature&#123;high: 12.4, low: 134.5&#125; loc := location&#123;lat: 22.3, long: 34.9&#125; report := reportNew&#123; sol: 12, temperature: t, location: loc, &#125; t.averae() report.temperature.averae() // duck type&#125; 13.2 转发方法Go可以通过struct嵌入 来实现方法的转发 在struct中只给定字段类型，不给定字段名即可 1234567891011type reportNew struct &#123; sol int temperature temperature // 字段名 类型 location location&#125;type reportNew struct &#123; sol int temperature // struct 嵌入 location // 只有类型，没有字段名&#125; struct的嵌入之后，被嵌入的类型可以直接使用 嵌入类型上的方法了 在struct中，可以转发任意类型 13.3 命名冲突12345678910111213141516171819202122232425262728293031type report struct &#123; sol temperature location&#125;type temperature struct &#123; high, low celsius&#125;type location struct &#123; lat, long celsius&#125;type celsius float64type sol intfunc (s sol) days(s2 sol) int &#123; days := int(s2 - s) if days &lt; 0 &#123; days = -days &#125; return days&#125;func (l location) days(l2 location) int &#123; return 5&#125;func main() &#123; report := report&#123;sol: 15&#125; fmt.Println(report.sol.days(1446)) fmt.Println(report.days(1446)) // error 发生歧义， 编译器不知道该调 location类型还是sol类型下面的days方法&#125; 12345678910111213141516171819func (s sol) days(s2 sol) int &#123; days := int(s2 - s) if days &lt; 0 &#123; days = -days &#125; return days&#125;func (l location) days(l2 location) int &#123; return 5&#125;func (r report) days(s2 sol) int &#123; // 顶级类型，可以调用report.days直接访问 return r.sol.days(s2)&#125;func main() &#123; report := report&#123;sol: 15&#125; fmt.Println(report.sol.days(1446)) fmt.Println(report.days(1446)) // compiler success&#125; 13.4 继承还是组合优先使用对象组合而不是类的继承 对传统的继承不是必须额，所有使用继承解决的问题都可以通过其它方法解决； 14. 接口接口关注于类型可以做什么，而不是存储了什么 接口通过列举类型必须满足的一组方法来进行声明 在Go语言中，不需要显式声明接口； 1234567891011121314151617181920212223// 声明接口变量var t interface &#123; talk() string&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l laser) talk() string &#123; return strings.Repeat(\"pew\", int(l))&#125;func main() &#123; // 多态 t = martian&#123;&#125; // martian 类型实现了talk方法，所以可以直接赋值 fmt.Println(t.talk()) t = laser(3) // laser 类型实现了talk方法，所以可以直接赋值 fmt.Println(t.talk())&#125; 14.1 接口类型为了复用，通常会把接口声明为类型 按约定，接口名称通常以er结尾 123456789101112131415161718192021222324// 声明接口变量type talker interface &#123; talk() string&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l laser) talk() string &#123; return strings.Repeat(\"pew\", int(l))&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;func main() &#123; shout(martian&#123;&#125;) // martian 实现了 talker 类型，可以直接调用 shout(laser(2)) // laser实现了 talker类型，可以直接调用&#125; 接口可以和struct嵌入特性一同使用 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"strings\")// 声明接口变量type talker interface &#123; talk() string&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l laser) talk() string &#123; return strings.Repeat(\"pew\", int(l))&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;type starship struct &#123; laser&#125;func main() &#123; s := starship&#123;laser(3)&#125; // starship 类型包含了laser fmt.Println(s.talk()) // 因为laser实现talk方法，所以 starship可以调用talk方法 shout(s) // starship有talk方法，满足了 talker类型，而talker类型又能作为 shout函数的参数，所以可以将 starship 传入shout方法&#125; 同时使用组合和接口将构成非常强大的设计工具； 14.2 探索接口Go语言的接口都是隐式满足的 Go允许在实现代码的过程中，随时创建新的接口。任何代码都能实现接口。包括已经存在的代码 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"time\")type stardater interface &#123; YearDay() int Hour() int&#125;type sol intfunc (s sol) YearDay() int &#123; return int(s % 668)&#125;func (s sol) Hour() int &#123; return 0&#125;// func stardate(t time.Time) float64 &#123;func stardate(t stardater) float64 &#123; // 既然 stardater实现了 YearDay和Hour，可以更改此类型 doy := float64(t.YearDay()) h := float64(t.Hour()) / 24.0 return 1000 + doy + h&#125;func main() &#123; day := time.Date(2012, 8, 6, 5, 17, 0, 0, time.UTC) fmt.Printf(\"%.1f Has\\n\", stardate(day)) s := sol(1422) fmt.Printf(\"%.1f Happy\\n\", stardate(s)) // 因为sol类型也实现了stardater接口，所以可以传入stardate方法&#125; 14.3 满足接口Go标准库导出了很多只有单个方法的接口； Go通过简单的、通常只有单个方法的接口… 来鼓励组合而不是继承，这些接口在各个组件之间形成了简明易懂的界限 例如在fmt包 声明的Stringer接口 12345678910111213141516type Stringer interface &#123; String() string&#125;type location struct &#123; lat, long float64&#125;func (l location) String() string &#123; return fmt.Sprintf(\"%v, %v\", l.lat, l.long)&#125;func main() &#123; curiosity := location&#123;-4.5895, 137.4417&#125; fmt.Println(curiosity) // location实现了String方法，满足了 Stringer接口。 所以就能被fmt.Println 调用了&#125; 标准库中常用的接口还包括: io.Reader, io.Write, json.Marshaler 15 指针指针是指向另一个变量地址的变量 Go语言的指针同时也强调安全性，不会出现迷途指针（dangling pointers） 15.1 &amp; 和 *变量会将它们的值存储在计算机的RAM里，存储位置就是该变量的内存地址； &amp; ： 获得变量的内存地址 1234func main() &#123; answer := 42 fmt.Println(&amp;answer) // 0xc000014090&#125; &amp; 操作符无法获得字符串/数值/布尔字面值的地址； &amp;42， &amp;”hello” 这些都会导致编译器报错 *操作符与&amp;的作用相反，它用来解引用，提供内存地址指向的值； C语言中的内存地址可以通过 address++ 这样的指针运算进行操作，在Go里面不允许这种不安全的操作 15.2 指针类型指针存储的是内存地址 1234func main() &#123; answer := 42 address := &amp;answer // *int address就是一个指向int类型的指针&#125; 指针类型和其它普通类型一样，出现在所有需要用到类型的地方，如变量声明、函数行参、返回值类型、结构体字段等 将*放在类型前面表示声明指针类型 将*放在变量前面表示解引用操作 15.3 指针就是用来指向的两个指针变量持有相同的内存地址，那么它们就是相等的； 123// 说明下面语句的作用a = *b; // 将b指针解引用，赋值给a，这个是值拷贝*b = 'alex' // b地址解引用，重复赋值 15.4 指向结构的指针与字符串和数值不一样，复合字面量的前面可以放置&amp; 12345678910111213func main() &#123; type person struct &#123; name, superpower string age int &#125; timmy := &amp;person&#123; name: \"alex\", age: 10, &#125; // (*timmy).superpower = \"flying\" // 访问字段时， 解引用不是必须要做的 timmy.superpower = \"flying\" fmt.Printf(\"%+v\\n\", timmy) // &amp;&#123;name:alex superpower:flying age:10&#125;&#125; 访问字段时，对结构体进行解引用并不是必须的； 15.5 指向数组的指针和结构体一样，可以把&amp; 放在数组的复合字面值前面来创建指向数组的指针 数组在执行索引或切片操作时会自动解引用。没有必要写(*array)[0]这种形式 12345func main()&#123; arr := &amp;[3]string&#123;'a','b','c'&#125; arr[0] arr[1:2]&#125; 与C语言不一样，Go里面数组和指针是两种完全独立的类型 slice和map的复合字面值前面也可以放置 &amp;操作符，但是Go并没有为它们提供自动解引用的功能； 15.5.1 修改数组函数通过指针对数组的元素进行修改 12345678910// rune指的是？func reset(board *[8][8]rune) &#123; board[0][0] = 'r'&#125;func main() &#123; var board [8][8]rune reset(&amp;board) fmt.Printf(\"%c\", board[0][0]) // r&#125; 15.5.2 什么情况下应该使用指向数组的指针隐式的指针 Go语言里一些内置的集合类型就在暗中使用指针 map在被赋值或者被作为参数传递的时候不会被复制 map就是一种隐式指针 这种写法就是多此一举： func demo(planets *map[string]string) 应该去掉🌟 map的键值都可以是指针类型 需要将指针指向map的情况并不多见 15.5.3 slice指向数组之前说过slice是指向数组的窗口，实际上slice在指向数组元素的时候也使用了指针； 每个slice内部都会被表示为一个包含3个元素的结构，它们分别指向： 数组的指针 slice的容量 slice的长度 当slice被直接传递至函数或方法时，slice的内部指针就可以对底层数据进行修改 指向slice的显式指针的唯一作用就是修改slice本身： slice的长度、容量以及起始偏移量 123456789101112func reclassify(p *[]string) &#123; *p = (*p)[0:8] // 修改切片本身&#125;func main() &#123; planets := []string&#123; \"m\", \"v\", \"E\", \"MA\", \"ju\", \"sa\", \"ur\", \"ne\", \"pl\", &#125; reclassify(&amp;planets) fmt.Println(planets) // [m v E MA ju sa ur ne]&#125; 15.5.4 指针和接口1234567891011121314151617181920type talker interface &#123; talk() string&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;func main() &#123; shout(martian&#123;&#125;) shout(&amp;martian&#123;&#125;) // NACK NACK // NACK NACK&#125; 无论是martian 还是指向martian的指针，都可以满足talker接口 如果方法使用的指针接收者，那么情况会有所不同； 12345678910111213141516171819202122232425type talker interface &#123; talk() string&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l *laser) talk() string &#123; return strings.Repeat(\"pew\", int(*l))&#125;func main() &#123; pew := laser(2) shout(&amp;pew) // PEWPEW shout(pew) // compiler error&#125; 15.6 实现修改Go语言的函数和方法都是按值传递参数的，这意味着函数总是操作于被传递参数的副本； 当指针被传递到函数时，函数将接收传入的内存地址的副本，之后函数可以通过解引用内存地址来修改指针指向的值； 1234567891011121314151617181920type person struct &#123; name, superpower string age int&#125;func birthday(p *person) &#123; p.age++&#125;func main() &#123; rebecca := person&#123; name: \"alex\", age: 10, superpower: \"imagination\", &#125; birthday(&amp;rebecca) // 传入的虽然是指针副本，但是指向同一地址 // birthday(rebecca) // 传入的是引用类型副本，等于复制了一个引用类型，性能差 fmt.Printf(\"%+v\\n\", rebecca) // &#123;name:alex superpower:imagination age:11&#125;&#125; 15.7 指针接收者方法的接收者和方法的参数在处理指针方面是很相似的 Go语言在变量通过点标记法进行调用的时候，自动使用&amp;取得变量的内存地址 所以不用写 (&amp;nathan).birthday() 这种形式也可以正常运行 12345678910111213141516171819202122232425type person struct &#123; name, superpower string age int&#125;func (p *person) birthday() &#123; p.age++&#125;func main() &#123; terry := &amp;person&#123; name: \"alex\", age: 15, &#125; terry.birthday() fmt.Printf(\"%+v\\n\", terry) // &amp;&#123;name:alex age:16&#125; nathan := person&#123; name: \"leo\", age: 17, &#125; nathan.birthday() fmt.Printf(\"%+v\\n\", nathan) // &#123;name:leo age:18&#125;&#125; 使用指针作为接收者的策略应该始终如一： 如果一种类型的某些方法需要用到指针作为接收者，就应该为这种类型的所有方法都是用指针作为接收者； 15.8 内部指针Go语言提供了内部指针这种特性 它用于确定结构体中指定字段的内存地址 123456789101112131415161718192021type stats struct &#123; level int endurance, health int&#125;func levelUp(s *stats) &#123; s.level++ s.endurance = 42 + (15 * s.level) s.health = 5 * s.endurance&#125;type character struct &#123; name string stats stats&#125;func main() &#123; player := character&#123;name: \"alex\"&#125; levelUp(&amp;player.stats) // 结构体某个字段的地址 fmt.Printf(\"%+v\\n\", player.stats) // &#123;level:1 endurance:57 health:285&#125;&#125; &amp;操作符不仅可以获得结构体的内存地址，还可以获得结构体中指定字段的内存地址； 15.9 小结应合理使用指针，不要过度使用指针 16. nilnil是一个名字，表示“无” 或“零” Go里面，nil是一个零值 如果一个指针没有明确的指向，那么它的值就是nil 除了指针，nil还是slice、map和接口的零值 Go语言的nil，比以往语言中的null更为友好，并且用的没那么频繁，但是仍需谨慎使用 16.1 nil会导致panic如果指针没有明确的指向，那么程序将无法对其实施的解引用。 尝试解引用一个nil指针将导致程序崩溃 123456789func main() &#123; var nowhere *int fmt.Println(nowhere) // &lt;nil&gt; fmt.Println(*nowhere) // compiler error // 防范代码 if nowhere != nil &#123; fmt.Println(*nowhere) &#125;&#125; 保护方法 123456func (p *person) days ()&#123; if p != nil &#123; return &#125; p.age++&#125; 因为值为nil的接收者和值为nil的参数在行为上并没有区别，所以go语言即使在接收者为nil的情况下，也会继续调用方法； 16.2 nil函数值当变量被声明为函数类型时，它的默认值是nil 1234func main() &#123; var fn func(a, b int) int fmt.Println(fn == nil) // true&#125; 检查函数值是否为nil，并在有需要时提供默认行为 123456789101112func sortStrings(s []string, less func(i, j int) bool) &#123; if less == nil &#123; less = func(i, j int) bool &#123; return s[i] &lt; s[j] &#125; &#125; sort.Slice(s, less)&#125;func main() &#123; food := []string&#123;\"onion\", \"carrot\", \"celery\"&#125; sortStrings(food, nil) fmt.Println(food) // [carrot celery onion]&#125; 16.3 nil slice如果slice 在声明之后没有使用复合字面值或内置的make 函数进行初始化，那么它的值就是nil 幸运的是，range、len、append等内置数都可以正常处理值为nil的slice 12345678910func main() &#123; var soup []string fmt.Println(soup == nil) // true for _, ingredient := range soup &#123; fmt.Println(ingredient) &#125; fmt.Println(len(soup)) // 0 soup = append(soup, \"onion\", \"carrort\", \"celery\") fmt.Println(soup) // [onion carrort celery]&#125; 虽然空slice和值为nil的slice并不相等，但它们通常可以替换使用； 1234567func mirepoix(ingredients []string) []string &#123; return append(ingredients, \"onion\", \"carrot\", \"celery\")&#125;func main() &#123; soup := mirepoix(nil) fmt.Println(soup) // [onion carrort celery]&#125; 16.4 nil map和slice一样，如果map在声明后没有使用复合字面值或内置的make函数进行初始化，那么它的值将会是默认的nil 1234567891011func main() &#123; var soup map[string]int fmt.Println(soup == nil) // true measurement, ok := soup[\"onion\"] // 对值为nil的map读取不会报错 if ok &#123; fmt.Println(measurement) &#125; for ingredient, measurement := range soup &#123; // 对值为nil的 map进行 range操作依然不会报错 fmt.Println(ingredient, measurement) &#125;&#125; 16.5 nil接口声明为接口类型的变量在未被赋值时，它的零值是nil 对于一个未被赋值的接口变量来说，它的接口类型和值都是nil，并且变量本身也等于nil 123456func main() &#123; var v interface&#123;&#125; fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // &lt;nil&gt; &lt;nil&gt; true&#125;// %T 接口类型// %v 值 当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。 1234567func main() &#123; var v interface&#123;&#125; fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // &lt;nil&gt; &lt;nil&gt; true var p *int v = p fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // *int &lt;nil&gt; false&#125; 当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。 在Go中，接口类型的变量只有在类型和值都为nil时才等于nil 即使接口变量的值仍为nil，但只要它的类型不是nil，那么该变量就不等于nil； 1234567func main() &#123; var v interface&#123;&#125; fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // &lt;nil&gt; &lt;nil&gt; true var p *int v = p fmt.Printf(\"%#v\\n\", v) //(*int)(nil)&#125; 16.6 nil之外的另一个选择123456789101112131415161718192021type number struct &#123; value int valid bool&#125;func newNumber(v int) number &#123; return number&#123;value: v, valid: true&#125;&#125;func (n number) String() string &#123; if !n.valid &#123; return \"not set\" &#125; return fmt.Sprintf(\"%d\", n.value)&#125;func main() &#123; n := newNumber(42) fmt.Println(n) // 42 e := number&#123;&#125; fmt.Println(e) // not set&#125;s 17 处理错误Go语言允许函数和方法同时返回多个值 按照惯例，函数在返回错误时，最后边的返回值应用来表示错误 调用函数后，应立即检查是否发生错误； 如果没有错误发生，那么返回的错误值为nil 1234567891011121314151617import ( \"fmt\" \"io/ioutil\" \"os\")func main() &#123; files, err := ioutil.ReadDir(\".\") // . 表示当前目录 if err != nil &#123; fmt.Println(err) os.Exit(1) &#125; for _, file := range files &#123; fmt.Println(file.Name()) // 00.go &#125;&#125; 注意 当错误发生时候，函数返回的其它值通常就不再可信 17.1 优雅的错误处理减少错误处理代码是一种策略是： 将程序中不会出错的部分和包含潜在错误隐患的部分隔离开来 对于不得不返回错误的代码，应尽力简化相应的错误处理代码 17.2 go的谚语123456789101112131415161718192021222324252627Errors are value， Do not just check erros， handle them gracefully # 除了检查错误，还要优雅的处理它们Do not panicMake the zero value usefulthe bigger the interface, the weaker the abstraction # interface越大，抽象度越差interface &#123;&#125; says nothing # interface&#123;&#125; 相当于什么都没定义，可以表示任意类型Gofmt is style is no one is favorite, yet gofmt is everyone is favorite # gofmt的样式所有人都不喜欢，但gofmt 所有人都喜欢Doc is for usersa litter copying is better than a little dependency # 少许的拷贝要比少许的依赖要好clear is better than clever# 清晰比聪明更好concurrency is not parallelism# 并发并不是并行do not communicate by sharing memory, share memory by communicating# 不要通过共享内存来进行通信,通过通信来共享内存channels orchestrate； mutexes serialize# channels 应该进行编排，mutexes（互斥量）按序列化执行 17.3 文件写入写入文件的时候可能出错： 路径不正确 权限不够 磁盘空间不足 文件写入完毕后，必须被关闭，确保文件被刷到磁盘上，避免资源的泄漏； 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"os\")func proverbs(name string) error &#123; f, err := os.Create(name) if err != nil &#123; return err &#125; // 写入到 f文件内 _, err = fmt.Fprintln(f, \"Errors are values.\") if err != nil &#123; // write error f.Close() return err &#125; _, err = fmt.Fprintln(f, \"Do not just check erros, handle them gracefully\") f.Close() return err&#125;func main() &#123; err := proverbs(\"proverbs.txt\") if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 17.4 内置类型 error内置类型error用来表示错误 18 defer关键字使用defer关键字，Go可以确保所有deferred的动作可以在函数返回前执行； 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"os\")func proverbs(name string) error &#123; f, err := os.Create(name) if err != nil &#123; return err &#125; defer f.Close() // 写入到 f文件内 _, err = fmt.Fprintln(f, \"Errors are values.\") if err != nil &#123; // write error return err &#125; _, err = fmt.Fprintln(f, \"Do not just check erros, handle them gracefully\") return err&#125;func main() &#123; err := proverbs(\"proverbs.txt\") if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 可以defer任意的函数和方法 defer并不是专门做错误处理的； defer可以消除必须时刻惦记执行资源释放的负担 18.1 defer的动作什么时候会被执行有创意的错误处理 12345678910111213141516171819202122232425type safeWriter struct &#123; w io.Writer err error&#125;func (sw *safeWriter) writeln(s string) &#123; if sw.err != nil &#123; return &#125; _, sw.err = fmt.Fprintln(sw.w, s)&#125;func proverbs(name string) error &#123; f, err := os.Create(name) if err != nil &#123; return err &#125; defer f.Close() sw := safeWriter&#123;w: f&#125; sw.writeln(\"Errors are values\") sw.writeln(\"Do not juse check errors, handle them gracefully\") sw.writeln(\"do not panic\") return sw.err&#125; 18.2 New errorerros包里有一个构造用New函数，它接收string作为参数用来表示错误信息。该函数返回error类型 123456789101112131415161718192021222324252627282930313233343536373839import ( \"errors\" \"fmt\" \"os\")const rows, columns = 9, 9type Grid [rows][columns]int8func (g *Grid) Set(row, column int, digit int8) error &#123; if !inBounds(row, column) &#123; return errors.New(\"out of bounds\") &#125; g[row][column] = digit return nil&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(10, 0, 5) if err != nil &#123; fmt.Printf(\"An error occurred: %v, \\n\", err) os.Exit(1) // An error occurred: out of bounds, // exit status 1 &#125;&#125; 提示 错误信息应具有信息性 可以把错误信息当作用户界面的一部分，无论对最终用户还是开发者； 18.3 按需返回错误按照惯例，包含错误信息的变量名应以Err开头 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"errors\" \"fmt\" \"os\")const rows, columns = 9, 9type Grid [rows][columns]int8var ( // 按惯例，包含错误信息的变量名应以Err开头 ErrBounds = errors.New(\"out of bounds\") ErrDigit = errors.New(\"invalid digit\"))func (g *Grid) Set(row, column int, digit int8) error &#123; if !inBounds(row, column) &#123; return ErrBounds &#125; g[row][column] = digit return nil&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(0, 0, 15) if err != nil &#123; switch err &#123; case ErrBounds, ErrDigit: fmt.Println(\"Les erreurs de parametres hors limites.\") default: fmt.Println(err) &#125; os.Exit(1) &#125;&#125; errors.New 这个构造函数是使用指针实现的，所以上例中的switch语句比较的是内存地址，而不是错误包含的文字信息 18.4 自定义错误类型error类型是一个内置的接口：任何类型只要实现了返回string的Error()方法就满足了该接口； 可以创建新的错误类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( \"errors\" \"fmt\" \"os\" \"strings\")const rows, columns = 9, 9type Grid [rows][columns]int8var ( ErrBounds = errors.New(\"out of bounds\") ErrDigit = errors.New(\"invalid digit\"))type SudokuError []errorfunc (se SudokuError) Error() string &#123; var s []string for _, err := range se &#123; s = append(s, err.Error()) &#125; return strings.Join(s, \", \")&#125;func (g *Grid) Set(row, column int, digit int8) error &#123; var errs SudokuError if !inBounds(row, column) &#123; errs = append(errs, ErrBounds) &#125; if !validDigit(digit) &#123; errs = append(errs, ErrDigit) &#125; if len(errs) &gt; 0 &#123; return errs &#125; g[row][column] = digit return nil&#125;func validDigit(digit int8) bool &#123; return digit &gt;= 1 &amp;&amp; digit &lt;= 9&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(12, 0, 15) if err != nil &#123; switch err &#123; case ErrBounds, ErrDigit: fmt.Println(\"Les erreurs de parametres hors limites.\") default: fmt.Println(err) &#125; os.Exit(1) &#125;&#125;// out of bounds, invalid digit// exit status 1 按照惯例， 自定义错误类型的名字应以Error结尾 有时候名字就是Error，例如 url.Error 18.5 类型断言上例中，我们可以使用类型断言来访问每一种错误； 使用类型断言，你可以把接口类型转化成底层的具体类型 例如： err.(SudokuError) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( \"errors\" \"fmt\" \"os\" \"strings\")const rows, columns = 9, 9type Grid [rows][columns]int8var ( ErrBounds = errors.New(\"out of bounds\") ErrDigit = errors.New(\"invalid digit\"))type SudokuError []errorfunc (se SudokuError) Error() string &#123; var s []string for _, err := range se &#123; s = append(s, err.Error()) &#125; return strings.Join(s, \", \")&#125;func (g *Grid) Set(row, column int, digit int8) error &#123; var errs SudokuError if !inBounds(row, column) &#123; errs = append(errs, ErrBounds) &#125; if !validDigit(digit) &#123; errs = append(errs, ErrDigit) &#125; if len(errs) &gt; 0 &#123; return errs &#125; g[row][column] = digit return nil&#125;func validDigit(digit int8) bool &#123; return digit &gt;= 1 &amp;&amp; digit &lt;= 9&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(10, 0, 15) if err != nil &#123; // 使用类型错误断言， if errs, ok := err.(SudokuError); ok &#123; fmt.Printf(\"%d error(s) occurred: \\n\", len(errs)) for _, e := range errs &#123; fmt.Printf(\"- %v\\n\", e) &#125; &#125; os.Exit(1) &#125;&#125;// - out of bounds// - invalid digit// exit status 1 如果类型满足多个接口，那么类型断言使它从一个接口类型转化为另一个接口类型 18.6 do not panic（不要恐慌）Go没有异常，它有个类似机制panic 当panic发生，那么程序就会崩溃 18.7 其它语言的异常 vs Go的错误值其它语言的异常在行为和实现上与Go语言的错误值有很大的不同 如果函数抛出异常，并且附近没人捕获它，那么它就会 冒泡 到函数的调用者那里，如果还没有人进行捕获，那么就继续“冒泡”到更上层的调用者。。。直到达到栈（Stack）的顶部（例如main函数） 异常这种错误处理方式可被看作是可选的； 不处理异常，就不需要加入其它代码； 想要处理异常，就需要加入相当数量的专用代码 Go语言中错误值更简单灵活； 忽略错误是有意识的决定，从代码上看也是显而易见的； 18.8 如何panicGo里有一个和其它语言异常类似的机制： panic 实际上，panic很少出现 创建panic 1panic(\"i forgot my towel\") panic的参数可以是任意类型 18.9 错误值、panic、os.Exit通常，更推荐使用错误值，其次才是panic panic比Os.Exit更好： panic后会执行所有defer的动作，而Os.Exit则不会 有时候Go程序会panic而不是返回错误值 12345678package mainfunc main() &#123; var zero int _ = 42 / zero // panic: runtime error: integer divide by zero // exit status 2&#125; 为了防止panic导致程序崩溃，Go提供了recover函数(恢复) defer的动作会在函数返回前执行，即使发生了panic 但如果defer的函数调用了recover，panic就会停止，程序将继续运行； 1234567891011import \"fmt\"func main() &#123; defer func() &#123; // defer会在函数返回前执行，即使发生panic if e := recover(); e != nil &#123;// defer调用recover，panic就会停止，程序将继续执行 fmt.Println(e) &#125; &#125;() panic(\"i forgot my towel\") // i forgot my towel&#125; 19 goroutine和并发（concurrent）19.1 goroutine在Go中，独立的任务叫做goroutine 虽然goroutine与其它语言中的协程、进程、线程都有相似之处，但goroutine和它们并不完全相同 goroutine和它们并不完全相同， Goroutine创建效率非常高 Go能直截了当的协同多个并发（concurrent）操作 在某些语言中，将顺序式代码转化为并发式代码需要做大量修改。 在Go里，无需修改现有顺序式的代码，就可以通过goroutine以并发的方式运行任意数量的任务； 19.2 启动goroutine只需在调用前面加一个go关键字； 1234567891011121314import ( \"fmt\" \"time\")func main() &#123; go sleepGopher() // go 关键字相当于启动一个 goroutine,另开辟了一条道路，在那条道路里面执行。然后main函数是一条主干道。主干道继续往下执行，当main函数返回的时候，该程序运行的所有goroutine都会立即停止，无论有没有走完。所以想在main函数返回之前让 sleepGopher 函数输出 ...snore... 的话，就需要多等待一段时间，已知 sleepGopher sleep了3秒，所以选择让main函数sleep了4秒 time.Sleep(4 * time.Second)&#125;func sleepGopher() &#123; time.Sleep(3 * time.Second) // 3*time.Second = 3s fmt.Println(\"...snore...\")&#125; 19.3 不止一个goroutine每次使用go关键字都会产生一个新的goroutine 表面上看，goroutine似乎在同时运行，但由于计算机处理单元有限，其实技术上来说，这些goroutine不是真的在同时运行； 计算机处理器会使用“分时”技术，在多个goroutine上轮流花费一些时间； 在使用goroutine时，各个goroutine的执行顺序无法确定； 123456789101112func main() &#123; for i := 0; i &lt; 5; i++ &#123; go sleepGopher() &#125; time.Sleep(4 * time.Second)&#125;func sleepGopher() &#123; time.Sleep(3 * time.Second) fmt.Println(\"...snore...\")&#125; 19.3.1 goroutine的参数向goroutine传递参数就根向函数传递参数一样，参数都是按值传递的（传入的是副本） 123456789101112131415161718func main() &#123; for i := 0; i &lt; 5; i++ &#123; go sleepGopher(i) &#125; time.Sleep(4 * time.Second)&#125;func sleepGopher(id int) &#123; time.Sleep(3 * time.Second) fmt.Println(\"...snore...\", id)&#125;// ...snore... 2// ...snore... 3// ...snore... 0// ...snore... 1// ...snore... 4 在使用goroutine时，各个goroutine的执行顺序无法确定； 20. channel1234567891011func main() &#123; for i := 0; i &lt; 5; i++ &#123; go sleepGopher() // 已知该程序3秒后结束，返回 &#125; time.Sleep(4 * time.Second) // 所以main函数中，尽量大于3秒的时间来保证所有 goroutine能够足够时间执行完；但有些时候并不能显式的知道 goroutine需要耗费的时间，那么这个时候main函数无法确定什么时间点会有返回值回来；所以也无法确定需要等待的时长。 解决这个问题就需要引入 channel&#125;func sleepGopher() &#123; time.Sleep(3 * time.Second) fmt.Println(\"...snore...\")&#125; channel可以在多个goroutine之间安全的传值； 通道可以用作变量、函数参数、结构体字段。。。 创建通道用make函数，并指定其传递数据的类型 1c: make(chan int) 20.1 channel（通道）发送、接收使用左箭头操作符 &lt;- 向channel发送值或从channel接收值； 12c &lt;- 99 // 向通道发送值， 把值为 99 的值 发送给通道cr:= &lt;- c // 从通道接收值 从通道c接收一个值，并将此值赋给 r变量 发送操作会等待直到另一个goroutine尝试对该channel进行接收操作为止； 执行发送操作的goroutine在等待期间将无法执行其它操作 未在等待channel操作的goroutine仍然可以继续自由的运行 执行接收操作的goroutine将等待直到另一个goroutine尝试向该channel进行发送操作为止； 123456789101112131415161718func main() &#123; c := make(chan int) // create a channel for i := 0; i &lt; 5; i++ &#123; go sleepGopher(i, c) &#125; for i := 0; i &lt; 5; i++ &#123; // 一共有5个 //gopher会往此通道发送值； gopherID := &lt;-c // 当i=0时，等待大约3s之后，有其它gopher给它发送值了。 // 可能是 0 1 2 3 4 任意一个值，因为goroutine的顺序无法确定 fmt.Println(\"gopher\", gopherID, \"has finished sleeping\") &#125;&#125;func sleepGopher(id int, c chan int) &#123; time.Sleep(3 * time.Second) fmt.Println(\"...\", id, \"snore ...\") c &lt;- id // 向通道发送值&#125; 20.2 使用select处理多个通道前面的例子中是使用一个channel来等待多个 goroutine，这种做法在所有goroutine都产生相同类型值的时候是好用的。但实际开发中，情况并不只是如此；程序通常需要等待不同类型的值； 当等待通道中某些值的时候，不想等太久。或者想在网络请求等待数秒之后就将其设置为超时而不是白白等待好几分钟。go标准库提供了一个time.After函数，该函数返回一个channel，该channel在指定时间后会接收到一个值（这个值是由go运行时的一个goroutine发送的 ）； 如果程序想继续从goroutine接收值，那必须等到所有goroutine都结束睡眠或我们耐心耗尽为止。这意味着程序必须同时等到time.After这个计时器channel 和其它channel。这个时候就能使用select语句。select语句能做到这一点。 select语句与switch有点像 该语句包含的每个case都持有一个通道，用来发送或接收数据； select会等待直到某个case分支的操作就绪，然后就会执行该case 分支； select语句不包含任何case的情况下将永远等下去 12345678910111213141516171819202122func main() &#123; c := make(chan int) // create a channel for i := 0; i &lt; 5; i++ &#123; go sleepGopher(i, c) &#125; timeout := time.After(2 * time.Second) // 创建一个超时时间2s 的 channel for i := 0; i &lt; 5; i++ &#123; select &#123; case gopherID := &lt;-c: // 从通道接收值 fmt.Println(\"gopher\", gopherID, \"has finished sleeping\") case &lt;-timeout: //等2s 超时 还未接收到 fmt.Println(\"my patience ran out\") return // return 会跳出select &#125; &#125;&#125;func sleepGopher(id int, c chan int) &#123; time.Sleep(time.Duration(rand.Intn(4000)) * time.Millisecond) // 生成一个0-4s的随机时间 c &lt;- id&#125; 注意： 即使已经停止等待goroutine，但只要main函数还没返回，仍在运行的goroutine将会继续占用内存；（有条件，尽量清理掉） 20.3 nil通道 值为nil的通道 如果不使用make初始化channel，那么channel变量的值就是nil(零值) 对nil通道进行发送或接收不会引起panic，但会导致永久阻塞； 对nil通道执行close函数，那么会引起panic 20.3.1 nil通道的用处：对于包含select语句的循环，如果不希望每次循环都等待select所涉及的所有通道，那么可以先将某些channel设置为nil，等到发送值准备就绪之后，再将channel变成一个非nil值并执行发送操作； 21 阻塞和死锁当goroutine在等待channel的发送或接收时，我们就说它被阻塞了； 除了goroutine本身占用少量的内存外，被阻塞的goroutine并不消耗任何其它资源； goroutine静静地停在那里，等到导致其阻塞的事情来解除阻塞 当一个或多个goroutine因为某些永远无法发生的事情被阻塞时，我们称这种情况为死锁，而出现死锁的程序通常会崩溃或挂起； 12345678910111213141516// 引发死锁的例子func main() &#123; c := make(chan int) &lt;-c&#125;// fatal error: all goroutines are asleep - deadlock!// goroutine 1 [chan receive]:// 使用goroutine 解决死锁问题func main() &#123; c := make(chan int) go func() &#123; c &lt;- 2 &#125;() &lt;-c&#125; 21.2 地鼠装配线Go允许在没有值可供发送的情况下通过close函数关闭通道 例如close(c) 通道被关闭后无法写入任何值，如果尝试写入将引发panic 尝试读取被关闭的通道会获得与通道类型对应的零值； 注意： 如果循环里读取一个已关闭的通道，并没有检查通道是否关闭，那么该循环可能会一直运转下去，耗费大量CPU时间 执行以下代码可得知通道是否被关闭 v,ok := &lt;-c v为通道得到的值，ok bool类型，如果ok为false，那么说明此通道已关闭； 12345678910111213141516171819202122232425262728293031323334353637383940414243func sourceGopher(downstream chan string) &#123; for _, v := range []string&#123;\"hello, world\", \"a bad apple\", \"goodbye all\"&#125; &#123; downstream &lt;- v &#125; // downstream &lt;- \"\" // 重构为 close(downstream)&#125;func filterGopher(upstream, downstream chan string) &#123; for &#123; item, ok := &lt;-upstream // if item == \"\" &#123; 重构 if !ok &#123; // downstream &lt;- \"\" close(downstream) return &#125; if !strings.Contains(item, \"bad\") &#123; downstream &lt;- item &#125; &#125;&#125;func printGopher(upstream chan string) &#123; for &#123; v := &lt;-upstream if v == \"\" &#123; return &#125; fmt.Println(v) &#125;&#125;func main() &#123; c0 := make(chan string) c1 := make(chan string) go sourceGopher(c0) go filterGopher(c0, c1) printGopher(c1) // hello, world // goodbye all&#125; 21.3 常用模式从通道读取值，直到它关闭为止（常用） 可以使用range关键字达到该目的 12345678910111213141516171819202122232425262728293031323334func sourceGopher(downstream chan string) &#123; for _, v := range []string&#123;\"hello, world\", \"a bad apple\", \"goodbye all\"&#125; &#123; downstream &lt;- v &#125; // downstream &lt;- \"\" // 重构为 close(downstream)&#125;func filterGopher(upstream, downstream chan string) &#123; for item := range upstream &#123; if !strings.Contains(item, \"bad\") &#123; downstream &lt;- item &#125; &#125; close(downstream) // 关闭下游通道&#125;func printGopher(upstream chan string) &#123; for v := range upstream &#123; fmt.Println(v) &#125;&#125;func main() &#123; c0 := make(chan string) c1 := make(chan string) go sourceGopher(c0) go filterGopher(c0, c1) printGopher(c1) // hello, world // goodbye all&#125; homework 编写一个流水线部件（一个goroutine），他需要记住前面出现的所有值，并且只有在值之前从未出现过的情况下才会将值传递至流水线的下一个阶段，假定第一个值永远不是空字符串 编写一个流水线部件，它接收字符串并将它们拆分成单词，然后向流水线的下一阶段一个接一个发送这些单词（可以用strings.Fields函数） 22 并发状态22.1 共享值与竞争条件（race condition）工厂某些生产线出现库存不足的情况，它们需要订购更多的原材料。尽管每条生产线都有固定电话，但是工厂只有一条共享的电话路线。当一个工人拿起电话下订单的时候，另一只地鼠可能会拿起电话拨号。对正在讲话的前一个工人产生干扰，而之后可能还会有其它的工人尝试使用电话。最终就是所有工人一头雾水，订单也无法下达。 为了解决这个问题，工厂工人必须达成某些协议。使得同一时间之内只有一只地鼠使用电话。而go语言里共享值的概念就跟共享电话有些相似。 当有两个或者多个goroutine同时使用共享值的时候，程序可能出错。把这种多个goroutine争相使用值的情况称之为竞争条件或者竞争状态（race condition）而go的compiler实际上包含了尝试在代码里发现静态条件这个功能。 两个goroutine同时读取，并不会产生 race condition。 22.2 Go的互斥锁(mutex)Mutex= mutual exclusive ​ 相互的 独占的 一个工厂想出一个很好的主意，在工厂地板中间放置一个玻璃罐，并在玻璃罐中放置了一个金属令牌。每次想要打电话的地鼠都需要从罐子里面取出令牌。然后在打电话的过程中一直持有它。然后打完电话再把它放回到罐子里面。如果有一只地鼠想打电话，但是没有在罐子里面发现令牌。就需要轮训等待直到令牌归还为止。go语言的互斥锁就相当于此玻璃罐。goroutine就可以通过互斥锁阻止其它的goroutine在同一时间进行某些事情。为了保护互斥锁的互斥性质，程序在访问被保护的东西的时候必须得非常的小心。互斥锁有两个方法 Lock 和 Unlock, Lock相当于从金属罐里面取出令牌，Unlock相当于把令牌放回玻璃罐； 如果有goroutine尝试在互斥锁已经锁定的情况下，再调用lock方法，那么它就需要等待解锁之后再次上锁。为了正确使用互斥锁，就要确保锁访问共享值的代码必须先锁定互斥锁，然后才能执行所需的操作。并且在操作完成之后必须解除互斥锁，任何不遵循这一模式的代码都可能引发竞争条件。基于此原因，互斥锁在绝大多数情况下，只会在包内进行使用；这个包会通过互斥锁保护自定义的内容，并将相应的lock和unlock调用，巧妙的隐藏在函数和方法的背后。和channel不一样，互斥锁并未内置在go语言中。而是通过sync包来引入的； 1234567891011package mainimport \"sync\"var mu sync.Mutexfunc main() &#123; mu.Lock() defer mu.Unlock() // the lock is held until we return from the function&#125; 互斥锁定义在被保护的变量之上 12345# test1. 当两个goroutine同时修改一个值的时候，会发生什么2. 尝试对一个已经被锁定的互斥锁进行锁定操作，会发生什么3. 尝试多一个未被锁定的互斥锁进行解锁操作，会发生什么4. 同时在多个不同的goroutine里面调用相同类型的方法是安全的吗 22.3 互斥锁的隐患22.3.1 死锁 如果一个程序锁定之后，它执行的操作很多。就需要越来越加的小心。 如果一个goroutine在锁定互斥锁之后，因为某些事情而被阻塞。那么将要取得互斥锁的其它goroutine就可能会被耽搁很长时间。更严重的是，如果持有互斥锁的goroutine因为某些原因尝试锁定同一个互斥锁就会引发死锁（正在尝试加锁操作的goroutine将永远无法解除已经被锁定的互斥锁，最终导致这个lock调用被永久的阻塞）。 所以为了保证这个互斥锁的使用安全，遵守以下两个原则 尽可能的简化互斥锁保护的代码 对每一份共享状态只使用一个互斥锁 22.4 长时间运行的工作进程工作进程（worker） 把一直存在并且独立运行的goroutine称作为 工作进程 而工作进程通常被写成包含select语句的for循环 1234567func worker () &#123; for &#123; select &#123; // wait for channels here. &#125; &#125;&#125; 22.5 事件循环和goroutine事件循环（event loop） 中心循环（central loop） Go通过提供groutine作为核心概念，消除了对中心循环的需求； 某些编程语言会用事件循环的中心循环来等待时间，并在这个事件发生时调用相应的已注册函数。而go语言则是通过提供goroutine作为核心概念，消除对中心循环的需求。 我们可以把任何工作进程goroutine都看做是独立运行的事件循环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( \"fmt\" \"image\" \"log\" \"time\")func worker() &#123; pos := image.Point&#123;X: 10, Y: 10&#125; direction := image.Point&#123;X: 1, Y: 0&#125; next := time.After(time.Second) for &#123; select &#123; case &lt;-next: pos = pos.Add(direction) fmt.Println(\"current position is\", pos) next = time.After(time.Second) &#125; &#125;&#125;type command intconst ( right = command(0) left = command(1))type RoverDriver struct &#123; commandc chan command&#125;func NewRoverDriver() *RoverDriver &#123; r := &amp;RoverDriver&#123; commandc: make(chan command), &#125; go r.drive() return r&#125;func (r *RoverDriver) drive() &#123; pos := image.Point&#123;X: 0, Y: 0&#125; direction := image.Point&#123;X: 1, Y: 0&#125; updateInterval := 250 * time.Millisecond nextMove := time.After(updateInterval) for &#123; select &#123; case c := &lt;-r.commandc: switch c &#123; case right: direction = image.Point&#123;X: -direction.Y, Y: direction.X&#125; case left: direction = image.Point&#123;X: direction.Y, Y: -direction.X&#125; &#125; log.Printf(\"new direction %v\", direction) case &lt;-nextMove: pos = pos.Add(direction) log.Printf(\"moved to %v\", pos) nextMove = time.After(updateInterval) &#125; &#125;&#125;func (r *RoverDriver) Left() &#123; r.commandc &lt;- left&#125;func (r *RoverDriver) Right() &#123; r.commandc &lt;- right&#125;func main() &#123; r := NewRoverDriver() time.Sleep(3 * time.Second) r.Left() time.Sleep(3 * time.Second) r.Right() time.Sleep(3 * time.Second)&#125; 修改代码使得每次移动之间的间隔增加半秒 以RoverDriver类型为基础，定义start方法·stop方法和对应的命令，然后修改代码使得探测器可以接受这两个新命令","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"webpack5_1","slug":"webpack5-1","date":"2021-02-23T06:50:45.000Z","updated":"2021-03-11T04:40:37.230Z","comments":true,"path":"2021/02/23/webpack5-1/","link":"","permalink":"http://yoursite.com/2021/02/23/webpack5-1/","excerpt":"","text":"Webpack5 boilerplate1. Common2.1 initinstall webpack5 1npm install webpack webpack-cli --save-dev --save-exact 2.2 添加changelog2.3 添加CI/CD2.4 项目结构设计12345678|- &#x2F;config 一些配置文件，比如webpack config等|- &#x2F;internals 一些内部脚本，生成模版文件， 执行cleanAndSetup操作等；|- &#x2F;scripts 必要的npm scripts|- package.json|- index.html|- &#x2F;src |- index.ts 2.5 添加 prettier 格式化代码利器，配合vscode全局使用； install 1npm install --save-dev --save-exact prettier init 12echo &#123;&#125;&gt; .prettierrc.jsontouch .prettierignore 12345# .prettierignore # Ignore artifacts:buildcoverage 2.6 babelbabel简述 babel是一个js编译器，主要是将es6+转换为向后兼容的js语法；这样就能运行在旧版本浏览器或者其他低版本的环境中； 利用@Babel/polyfill可以通过Polyfill方式在目标环境中添加缺失的特性； babel能够转换jsx语法；主要用到@babel/preset-react; babel还可以删除类型注释，主要用到@babel/preset-typescript，但是无法做类型检查，类型检查需要Flow/Typescript这类的工具; babel是构建在插件之上的，使用现有的插件可以组成一个转换管道；通过使用或创建一个preset 即可轻松使用一组插件；使用generator-babel-plugin生成一个插件模版； 2.6.1 概念1npm install --save-dev --save-exact @babel/core @babel/cli @babel/preset-env 2.6.1.1 @babel/corebabel 核心功能包含在该模块中； 2.6.1.2 @babel/cli@babel/cli 是一个能够从终端（命令行）使用的工具； babelrc 1234&#123; \"presets\": [], \"plugins\": []&#125; 2.6.1.3 plugins 插件是小型的js程序，用于指导babel如何代码进行转换 现在，babel虽然开箱即用，但是什么动作都不做。类似于const babel = code =&gt; code，将代码解析之后再输出同样的代码，如果想要babel做一些实际的工作，就需要为其添加插件； 例如@babel/plugin-transform-arrow-functions之类的插件能将es6的箭头函数转换成es5的function；但是代码中依然有其他es6属性，比如class。 我们希望对它们也进行转换，不需要一个接一个添加所需要的插件。可以使用一个preset（即一组预先设定的插件） 就像插件一样，可以根据自己所需要的插件组合创建一个 自己的preset并将其分享出去； 插件参数 12345678910111213141516// 不加参数的时候,下面这几种是一致的；&#123; \"plugins\": [\"pluginA\", [\"pluginA\"], [\"pluginA\",&#123;&#125;]]&#125;// 添加参数，请传递一个以参数名作为（key）的对象&#123; \"plugins\": [ [ \"transform-async-to-module-method\", &#123; \"module\": \"bluebird\", \"method\": \"coroutine\" &#125; ] ]&#125; 2.6.1.4 preset （@babel/env） 除了一个一个添加插件，还可以以 preset 的形式启用一组插件，对比plugin来说，preset就是为了让不想自动手动组合插件的开发者提供的，preset可以作为Babel插件的组合； 可以简单把Babel Preset视为Babel Plugin的集合，比如babel-preset-es2015 就包含了所有跟es6转换有关的插件； 1./node_modules/.bin/babel src --out-dir lib --presets=@babel/env preset参数 格式与plugin一致； 官方Preset 1234@babel/preset-env@babel/preset-flow@babel/preset-react@babel/preset-typescript 2.6.1.5 Plugin与Preset执行顺序可以同时使用多个Plugin 和Preset，此时，它们执行顺序非常重要 先执行完所有Plugin，再执行Preset 多个Plugin，按声明次序顺序执行 多个Preset，按照声明次序逆序执行 12345678910&#123; \"plugins\": [ \"transform-react-jsx\", \"transform-async-to-generator\" ], \"presets\": [ \"es2015\", \"es2016\" ]&#125; 执行顺序 transform-react-jsx，transform-async-to-generator，es2016，es2015 2.6.1.6 babel-polyfillbabel默认只转换新的js句法（syntax），不转新的API，类似Proxy，Promise这些。举例来说，ES6在Array对象上新增了Array.from方法，babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill； 从babel7.4.0版本开始，这个软件包已经不推荐使用了，建议使用core-js/stable 和regenerator-runtime/runtime 12import 'core-js/stable'import 'regenerator-runtime/runtime' useBuiltIns 12345678910111213141516&#123; \"presets\": [ [ \"@babel/env\", &#123; \"targets\": &#123; \"edge\": \"17\", \"firefox\": \"60\", \"chrome\": \"67\", \"safari\": \"11.1\" &#125;, \"useBuiltIns\": \"usage\" // 当此参数设置为 \"usage\" 时，就会加载上面所提到的最后一个优化措施，也就是只包含你所需要的 polyfill. &#125; ] ]&#125; 1234Promise.resolve().finally();// 加了 \"useBuiltIns\": \"usage\" 之类转化为require('core-js/modules/es.promise.finally');Promise.resolve().finaly(); Babel将检查你的所有代码，以便查找目标环境中缺失的功能，然后只把必须的polyfill包含进来；如果没加useage，那必须在所有代码之前通过require加载一次完成的polyfill 2.6.1.7 小结使用@babel-cli从终端运行Babel； 利用 @babel/polyfill模拟所有新的js功能，比如Array.from, Promise等； 而@babel-envpreset 只对目标环境（如浏览器）中缺失的功能进行代码转换和加载polyfill； 2.6.2 配置1echo &#123;&#125;&gt;babel.config.json 2.6.2.1 typescript1npm install --save-dev --save-exact @babel/preset-typescript 2.6.2.2 react1npm install --save-dev --save-exact @babel/preset-react 2.7 引入typescriptinstall 1npm install --save-dev --save-exact typescript ts-loader tsconfig.json 1echo &#123;&#125; &gt;tsconfig.json 2.8 引入reactinstall 1npm install react react-dom react-router react-router-dom redux react-saga reselect react-redux immer connected-react-router history --save --save-exact 记得加入@types 1npm install @types/react @types/react-dom --save-dev --save-exact 2.9 载入css相关资源install 1npm install style-loader css-loader less less-loader --save-dev --save-exact 安装PostCSS Preset Env 1npm install --save-dev --save-exact postcss-preset-env postcss postcss-loader MiniCssExtractPlugin 生产模式下运行时使用来提取CSS 1npm install --save-dev --save-exact mini-css-extract-plugin 2.10 解析图片，字体之类的1npm install file-loader --save-dev --save-exact 2.11 HtmlWebpackPlugin1npm install --save-dev --save-exact html-webpack-plugin 2. Devinstall 1npm install --save-dev --save-exact webpack-hot-middleware express webpack-dev-middleware 3. Pro","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"graphics1","slug":"graphics1","date":"2021-02-09T10:24:13.000Z","updated":"2021-02-11T00:00:59.294Z","comments":true,"path":"2021/02/09/graphics1/","link":"","permalink":"http://yoursite.com/2021/02/09/graphics1/","excerpt":"","text":"前置 1. Course Topis（mainly 4 parts） Rasterization （光栅化） Curves and Meshes Ray Tracing （光线追踪） Animation/Simulation （动画/模拟） 1.1 Rasterization光栅化， 把三维空间的几何形体显示在屏幕上。这就是光栅化。 实时的计算机图形学的主要应用，在计算机图形学的范畴内，实时的定义我们认为是每秒钟生成30幅画面或者叫30帧，能达到这个级别就叫实时，否则叫离线； 1.2 Curves and Meshes在图形学中，如何表示一条光滑的曲线。如何表示曲面。 1.3 Ray Tracing （光线追踪）生成真实美观的画面； trade off 取舍","categories":[{"name":"graphics","slug":"graphics","permalink":"http://yoursite.com/categories/graphics/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"liner_Algebra","slug":"liner-Algebra","date":"2021-02-08T13:59:25.000Z","updated":"2021-02-21T10:25:54.752Z","comments":true,"path":"2021/02/08/liner-Algebra/","link":"","permalink":"http://yoursite.com/2021/02/08/liner-Algebra/","excerpt":"","text":"一系列简短可刷的视频，将线性代数中的几何直觉动画化； 即使你能跟上视频的速度，你也需要留点时间给自己思考，学习往往发生在此刻； 1. 向量1.1 含义线性代数中最基础、最根源的组成部分就是向量； 一般来说，有三种看待向量的观点，看似不同却有所关联； 1.1.1 物理专业视角向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向；但是只要以上两个特征相同，你可以自由移动一个向量而保持它不变； 二维向量 处在平面中的巷里那个是二维的； 三维向量 而处在我们所生活的空间中的向量是三维的； 1.1.2 计算机专业视角从计算机专业学生的视角看，向量是有序的数字列表；比如你正在做一些有关房价的分析；而你只关心两个特征： ``房屋面积和价格`。 你可能会用一对数字对每个房屋进行建模；第一个数代表房屋面积，第二个数代表价格； 注意，这里的数字顺序不可颠倒；用行话来讲，你会用二维向量对房屋进行建模；在这里，“向量”只不过是“列表”的一个花哨的说法；之所以这个向量是二维的，是因为这个列表的长度是2； 1.1.3 数学专业视角另一方面，数学家试图去概括这两种观点，大致地说，向量可以是任何东西。只要保证两个向量相加以及数字与向量相乘是有意义的即可； 向量加法和向量数乘贯穿线性代数始终，二者起着很重要的作用 一种思考“向量”的特定方式 现在关注的是它的几何方面，首先需要考虑一个箭头，考虑这个箭头在某个坐标系中，比如x-y平面。并且箭头起点位于原点；这与物理专业学生的看法略有不同。因为在他们眼中，向量可以在空间中自由落脚；但是在线性代数中，向量经常以原点作为起点； 一旦你理解了“向量是空间中的箭头”这种观点，就来看看“向量是有序的数字列表”这种观点； 在直角坐标系中，一个向量的坐标由一对数构成；（-2，3），这对数指导你如何从原点（向量起点）出发到达它的尖端（向量终点） 第一个数告诉你沿着X轴走多远，正数代表向右移动，负数代表向左移动； 第二个数告诉你沿着Y轴走多远；正数代表向上移动，负数代表向下移动； 为了把向量和点区别开，惯用方法是把这对数竖着写，然后用方括号括起来；每一对数给出唯一一个向量； 1.2 向量的和 平移第二个向量，使它的起点与第一个向量的终点重合。然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是它们的和； 顺便一提，这个向量加法的定义差不多是线性代数中唯一允许向量离开原点的情形； 1.2.1 数学角度看向量加法 我们重新编排它们的吮吸，使得我们先完成所有水平运送，再完成所有竖直运动； 所以新向量的坐标就是 (1+3, 2+(-1)); 即(x1+x2,y1+y2),总体来说，在“向量是有序的数字列表”观点里，向量加法就是把对应项相加； 1.3 向量数乘另一个向量基础运算就是向量数乘 1.3.1 缩放比如说你选择数字2，把它与一个给定向量相乘。意味着你把这个向量拉长为原向量的2倍。 如果将向量乘以1/3，就意味着这个向量长度缩短为原来的1/3.如果乘以-1.8，相当于往反方向拉长1.8倍；2,1/3,-1.8,它们用于缩放向量，被称为“标量”实际上自始至终，数字在线性代数中起到的主要作用就是缩放向量；所以，“标量”和“数字”两个词通常在这里可以相互替换； 这种拉伸或压缩，有时又使向量反向的过程被称为“缩放”； 1.3.2 数学角度看向量数乘从数字的角度来看，将一个向量伸长为原来的2倍；对应于将每一个分量分别乘以2； 所以将向量看作一个数字列表时，向量与标量相乘就是将向量中的每个分量与标量相乘； 1.4 向量点乘与叉乘1.5 总结线性代数围绕两种基本运算： 向量加法与向量乘法“究竟是什么意思了”； 为什么数学家只考虑这两种运算，并且又是如何将它们抽象独立出来，不管你选什么代表向量都与之无关； 实际上无论你怎么看待向量都无所谓，或把向量看作空间中的箭头；或者把向量看作数字列表；这种观点又恰好有漂亮的几何意义与之对应。线性代数的效用很少提现在这些观点的其中一个上，而是更多地体现在它能够在这些观点中相互转化； 线性代数为数据分析提供了一条将大量数据列表概念化、可视化的渠道；它让数据样式变得非常明晰，并让你大致了解特定运算的意义； 另一方面，线性代数给物理学家和计算机图形程序员提供了一种语言；让他们通过计算机能处理数字来描述并操纵空间； 2. 线性组合、张成的空间与基2.1 基向量关于向量坐标，还有一种有趣的方式来看待这些坐标，它对线性代数很重要。当你看到一对描述向量的数时，比如（3，-2），可以把它的每个坐标看作一个标量； 在xy坐标系中，有两个非常特别的向量。一个指向正右方，长度为1，通常被称为i 帽或者x方向的单位向量；另一个指向正上方，长度为1。通常被称为j帽 或者y方向的单位向量； 现在想象向量(3,-2)的x坐标是一个标量，它将i帽拉伸为原来的3倍；它将j帽拉伸为原来的2倍；从这个角度去看，这个向量实际上是两个经过缩放的向量的和； “缩放向量并且相加” 这一概念至关重要，i 与 j 是xy坐标系的“基向量”；它们合起来被称为坐标系的基； 这是在说，当你把坐标看作标量时；基向量实际上就是这些标量缩放的对象； 我们根据这两个特殊的基向量构建坐标系时，也浮现了一些有趣而微妙的问题，如果我们选择不同的基向量会怎么样？我们完全可以选择不同的基向量，获得一个合理的新坐标系； 比如说，随便选一个指向右上方的向量（红色），再随便选一个指向右下方的向量（蓝色）。想象一下，通过选择两个标量，分别用于缩放二者的其中一个；然后把它们相加，你能得到不同的结果； 通过改变所选择的标量，你可以得到哪些二维向量？ 答案是，你可以得到所有的二维向量。为什么呢？ 这样一对新的基向量，同样允许我们在一对数和二维向量之间自由转化； 但是这种变换关系与之前用i帽 和 j帽的变换关系完全不同； 每当我们用数字描述向量时，它都依赖于我们正在使用的基两个数乘向量和被称为这两个向量的线性组合。 2.2 向量张成的空间（span）“线性”这个词从哪儿来？这根直线又又什么关系？ 如果固定其中一个标量，让另一个标量自由变化。所产生的向量的终点会描出一条直线；(下面两张图分别为固定向量W缩放V 和 固定V缩放W) 如果你让两个标量同时自由变化，考虑所有可能得到的向量；可能有两种情况； 大部分情况下，对于一对初始向量，你能到达平面中的每一个点；所有二维向量都尽在掌握； 但是也有糟糕的情况，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上； 实际上还有第三种情况： 两个向量都是零向量。那就只能乖乖呆在原点了； 所有可以表示为给定向量线性组合的向量的集合；被称为给定向量张成的空间（span）; 现在用行话重新叙述刚才的内容；对大部分二维向量对来说，它们张成的空间是所有二维向量的集合。 但当共线的时，它们张成的空间就是终点落在一条直线上的向量的集合； 线性代数紧紧围绕向量加法与数乘 两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么？ 现在是时候讨论一下通常我们是如何将向量看作点的； 想象落在一条直接上的一些向量时，你会觉得拥挤。而同时想象所有二维向量填满平面时，你会觉得非常拥挤； 所以为了对抗这种情况，通常我们就用向量的终点代表改向量。而像以往一样，它的起点仍旧位于原点；用这种方法来看，如果你要考虑落在一条直线上的所有向量时，你需要考虑直线本身就行了；类似地，同时考虑所有二维向量时，将每个向量抽象为它的终点；实际上，你就不必考虑所有的箭头了，只需要考虑无限大的二维平面本身即可； 当你只考虑一个向量时，就把它看作箭头。当你考虑多个向量时，就把它们都看作点；前面有提到对大部分二维向量来说，它们张成的空间是整个无限大的二维平面；如果共线，它们张成的空间就是一条直线； 2.2.1 两个三维向量张成的空间是什么样的？如果我们再去考虑三维空间，张成空间这个概念就开始变得有趣了。这两个向量张成的空间就是它们所有可能的线性组合。 这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量张成的空间；或者说，所有终点落在这个平面上的向量的集合是这两个向量张成的空间； 如果再加上第三个向量，那么它们张成的空间又是什么样的呢？ 会有两种情况，如果第三个向量恰好落在前两个向量所张成的平面上。那么它们张成的空间并不会改变，还是被困在这个平面上； 另外一种情况，如果你随机选一个向量，它几乎不可能落在前面两个向量所张成的平面中。这种情况下，由于第三个向量指向不同的方向。当你缩放第三个向量时，它将前两个向量张成的平面沿它的方向来回移动，从而扫过整个空间； 2.3 线性无关与线性相关当有多个向量，并且可以移除其中一个而不减少张成的空间。当这种情况发生时，我们称它们是“线性相关”的；另一种表述方法是其中一个向量，可以表示为其它向量的线性组合，因为这个向量已经落在其它向量张成的空间之中； 另一方面，如果所有向量都给张成的空间增添了新的维度；它们就被称为是“线性无关”的。 2.4 小结“向量空间的一组基是张成该空间的一个线性无关的向量集；” 空间的一组基的严格定义是这样的： 张成该空间的一个线性无关向量的集合，基于目前对“张成” 和 “线性无关” 这两个词的理解。思考一下为什么这个定义合乎情理； 3. 矩阵与线性变换3.1 线性变换 很遗憾， Matrix（矩阵）是什么是说不清的，你必须得自己亲眼看看； “如果要我选出一个主题，它不仅让线性代数的其它内容一目了然，又经常被初次学习线性代数的人忽视，我会选择这个——线性变换的概念以及它和矩阵的关系” 在这期视频中，只会集中讨论这些变换在二维空间中长什么样。以及它们如何与矩阵向量乘法关联。尤其展示一种不用死记硬背的考虑矩阵向量乘法的方法； 首先，先来解析“线性变换”这个术语。“变换”本质上是“函数”的一种花哨的说法，它接收输入内容，并输出对应结果； 特别地，在线性代数的情况下。我么考虑的是接收一个向量并且输出一个向量的变换； 特别的，在线性代数的情况下。我们考虑的是接收一个向量并且输出一个向量的变换； 既然“变换”和“函数”意义相同，为什么还要使用前者而不是后者？因为使用“变换”是在暗示以特定方式来可视化这一输入-输出关系； 一种理解“向量的函数”的方法是使用运动。 如果一个变换接收一个向量并输出一个向量；我们想象这个输入向量移动到输出向量的位置； 接下来，要理解整个变换。我们可以想象每一个输入向量都移动到对应输出向量的位置；同样多个箭头显得很拥挤，只用终点表示该向量，用这种方法考虑所有输入向量都移动到对应输出向量的位置时。我们只用看空间中的所有点移动到其它点的位置； 各种个样对空间的变换所产生的效果是美妙的，任意一个变换可以非常复杂。幸运的是，线性代数限制在一种特殊类型的变换上；这种变换更容易理解，称为线性变换 直观地说，如果一个变换具有以下两条性质，我们就称它是线性的； 一是直线在变换后仍然保持为直线，不能有所弯曲； 二是原点必须保持固定； 举例： 上图变换保持原点不动，乍一看它好像保持直线平直；但实际并非如此，因为只展示了水平和竖直的网格线； 当你看看它对一条对角线的作用时，很明显它不是一个线性变换； 总体来说，你应该把线性变换看作是“保持网格线平行且等距分布”的变换； 3.1.1 如何用数值描述线性变换 当你在通过编程制作动画和视频来教授这一主题，你应该给计算机什么样的计算公式；使得你给它一个向量的坐标，它能给你变换后向量的坐标呢？ 实际结果是，你只需要记录两个基向量i帽和j帽变换后的位置； 比如说，考虑坐标为（-1，2）的向量V。 这个向量就是 -1 与 i帽之积与2与j帽之积的和； 如果运用一些变换，并且跟随这三个向量的运动。网格线保持平行且等距分布的性质有一个重要的推论； 变换后的向量V的位置，是-1与变换后的i帽之积，加上2与变换后的j帽之积； 换句话说，向量V是i帽和j帽的一个特定线性组合，那么变换后的向量V也是变换后i帽和j帽的同样的线性组合；这意味着，你可以只根据变换后的i帽和j帽，就推断出变换后的V； 如上图所示的变换，可以看出i帽落在坐标（1，-2）上。j帽落在x轴上，坐标为（3，0）；也就是说，-1乘以i帽加上2乘以j帽所代表的向量；会落在-1 乘以向量（1，-2）加上2乘以向量（3，0）的位置上；简单运算之后，你就能推断出向量V一定落在向量（5，2）上； 1Transformed V = -1(Transformed i) + 2(Transformed j) 实际上，因为展示出整个变换的样子。完全可以直接读出向量V在变换后落在坐标（5，2）上；但是更炫酷的是，只要记录了变换后的i帽和j帽。我们就可以推断出任意向量在变换之后的位置；完全必须观察变换本身是什么样。 一般情况下，一个向量的坐标是（x，y），变换后这个向量就是x乘以变换后的i帽（1，-2）；加上y乘以变换后的j帽（3，0）。简单运算之后你就知道它落在坐标（1x+3y, -2x+0y）上。运用这个公式，我给你任意一个向量，你都能告诉它在变换后的位置； 以上这些内容是在说，一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标。通常我们将这些坐标包装在一个2*2的格子中，称它为2*2矩阵； 你可以把它的列理解为两个特殊的向量，即变换后的i帽和j帽。如果你有一个描述线性变换的2*2矩阵，以及一个给定向量；你想了解线性变换对这个向量的作用；你只需要取出向量的坐标；将它们分别与矩阵的特定列相乘，然后将结果相加即可；这与“缩放基向量再相加”的思想一致 4. 矩阵乘法与线性变换复合5. 三维空间中的线性变换6. 行列式7. 逆矩阵、列空间与零空间8. 非方阵9. 点积与对偶性10. 叉积的标准介绍11. 以线性变换的眼光看叉积12. 基变换13. 特征向量与特征值14. 抽象向量空间15. 克莱姆法则，几何解释","categories":[{"name":"algebra","slug":"algebra","permalink":"http://yoursite.com/categories/algebra/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"}]},{"title":"cli","slug":"cli","date":"2021-02-07T07:50:09.000Z","updated":"2021-02-20T07:31:56.962Z","comments":true,"path":"2021/02/07/cli/","link":"","permalink":"http://yoursite.com/2021/02/07/cli/","excerpt":"","text":"1. Quick start1.1 创建文件夹12$&gt; mkdir sunmao &amp;&amp; cd sunmao &amp;&amp; npm init -y$&gt; touch sm.js 1.2 设置package.json12345678910111213141516171819202122&#123; \"name\": \"sunmao\", \"bin\": &#123; \"sunmao\": \"sm.js\" // 添加 bin 配置，sumao 命令即 指向 sm.js &#125;, \"version\": \"0.0.1\", \"description\": \"A Iterating scaffolding for react, redux-saga and Typescript\", \"main\": \"main.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/TenonMortise/sunmao\" &#125;, \"author\": \"ruanhan\", \"license\": \"MIT\", \"bugs\": &#123; \"url\": \"https://github.com/TenonMortise/sunmao/issues\" &#125;, \"homepage\": \"https://github.com/TenonMortise/sunmao#readme\"&#125; 1.3 npm link1234// sm.js#!/usr/bin/env nodeconsole.log('hello, sunmao') 123456789$&gt; chmod 755 sm.js$&gt; sudo npm linkup to date in 10.078s/usr/local/bin/sunmao -&gt; /usr/local/lib/node_modules/sunmao/sm.js/usr/local/lib/node_modules/sunmao -&gt; /Users/ruanhan/sunmao$&gt; sunmao$&gt; hello, sunmao 参考文档： npm link 1.4 npm unlink如果你的项目不再需要该模块，可以在项目目录内使用npm unlink命令，删除符号链接。 2. 第三方工具介绍2.1 commander.js可以自动的解析命令和参数，用于处理用户输入的命令。 2.2 download-git-repo,下载并提取 git 仓库，用于下载项目模板。 2.3 inrequire.js通用的命令行用户界面集合，用于和用户进行交互。 2.4 ora下载过程久的话，可以用于显示下载中的动画效果。 2.5 chalk可以给终端的字体加上颜色。 2.6 log-symbols可以在终端上显示出 √ 或 × 等的图标。 2.7 install1npm install commander download-git-repo inquirer ora chalk log-symbols","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"dp","slug":"dp","date":"2021-02-02T02:16:56.000Z","updated":"2021-02-09T10:27:09.525Z","comments":true,"path":"2021/02/02/dp/","link":"","permalink":"http://yoursite.com/2021/02/02/dp/","excerpt":"","text":"1 动态规划题目特点 计数类 有多少种方式走到右下角 有多少种方法选出K个数使得和是sum 求最大最小值（DP最大的一类） 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出K个数使得和是sum 2 dp解题步骤以 Coin Change 为例； 三种硬币，分别面值2元，5元和7元， 没种硬不都有足够多，去书店买本书需要27元。如何用最少的硬币组合正好付清，不需要对方找钱 分析： 这题出现求最少，显然可以使用DP方法来解决 2.1 动态规划组成部分一： 确定状态2.1.1 状态在动态规划中的作用属于定海神针2.1.2 简单来说，解动态规划的时候需要开一个数组，数组的每个元素f[i] 或者 f[i][j]代表什么； 类似于解数学题中，X， Y，Z代表什么；2.1.3 确定状态需要两个意识：2.1.3.1 最后一步 虽然我们不知道最优策略是什么，但是最优策略肯定是K梅硬币a1,a2,…,ak 面值加起来是27； 最后一步指的就是最优策略中的最后一个决策，对应到这一题就是一定会有一枚最后的硬币决策： ak， 那么除了这枚硬币，前面硬币的面值加起来是27-ak； 关键点1： 我们不关心前面的 k-1 枚硬币是怎么拼出27-ak的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道ak 和k， 但是我们确定前面的硬币拼出了 27-ak； 关键点2: 因为是最优策略，所以拼出27-ak的硬币数一定要最少，否则这就不是最优策略了； 解析关键点2： 比如最优策略要用5枚硬币，假设最后一枚是5元面额，那么4枚硬币组成了22元。你不可能用3枚，2枚甚至1枚拼成22元； 浅显的道理，如果用3枚可以拼出来22元的话，那么最优策略要用5枚的假设就不成立； 2.1.3.2 子问题我现在当然想求K，但是想求K的话，需要知道前面k-1等于几。（即最少需要多少枚硬币可以拼出27-ak） 所以，我们的要求就变成了：最少要用多少枚硬币可以拼出27-ak枚硬币； 原问题是最少用多少枚硬币拼出27； 我们将原问题转化成了一个子问题，而且规模更小： 27-ak 那该如何定义状态呢，一旦子问题出来了，状态就直接把相同的汉字copy下来。即最少用多少枚硬币拼出X 为了简化定义，我们设状态 f(x)=最少用多少枚硬币拼出x结合这一题就是f(x)=最少用多少枚硬币拼出27.整个问题就变成，以前求f(27),现在求f(27-ak); 等等，我们还不知道最后那枚硬币ak是多少， 当然最后那枚硬币ak只可能是2，5或者7 如果ak是2的话，f(27)应该是f(27-2)+1（加上最后这一枚硬币2） 如果ak是5的话，f(27)应该是f(27-5)+1（加上最后这一枚硬币5） 如果ak是7的话，f(27)应该是f(27-7)+1（加上最后这一枚硬币7） 除此之外，没有其他的可能了； 因为我们需求最少的硬币数，所以： 1f(27) = min&#123;f(27-2)+1, f(27-5)+1, f(27-7)+1&#125; 2.1.4 递归解法的问题递归做了很多重复计算，效率低下 如何避免？ DP是将计算结果保存下来，并改变计算顺序； 2.2 动态规划组成部分二： 转移方程设状态f[x] = 最少用多少枚硬币拼出X； 对于任意X 2.2.1 f[x] 与 f(x)的区别f[x] ，[] 代表数组下标 f(x) ，（）代表函数调用 2.3 动态规划组成部分三： 初始条件和边界条件f[x]=min{f[x-2]+1, f[x-5]+1, f[x-7]+1} 两个问题 x-2, x-5或者x-7 小于0怎么办？什么时候停下来？ 如果不能拼出Y，就定义f[Y] = 正无穷，例如 f[-1] = f[-2] = … = 正无穷 所以f[1] = min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1； 初始条件： f[0] = 0; 因为初始条件用转移方程是算不出来的。但我又需要它的定义。 根据 f[0] = min{f[-2]+1, f[-5]+1, f[-7]+1} 算，f[0]是正无穷的。而我们明明知道，f[0] 不等于正无穷，而是等于0，所以需要手动制定。有的时候初始条件不需要给很多个，比如f[0], f[1], f[2] 等等是不需要额外多个去定义，定不定义该值取决于能否根据其他预设的值;比如f[1] 是正无穷，f[2] = {f[0]+1, f[-3]+1, f[-5]+1} 是 1， 然后后面的值都能基于此算出来了； 初始条件的实质就是把那些最小的值定义下来，边界情况的实质就是不要数组越界；不管数组往下越界到负数，还是数组往上越界超过了都不行； 2.4 动态规划组成部分四：计算顺序拼出X所需要的最少硬币数： f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1} 初始条件： f[0] = 0 然后计算 f[1], f[2],… , f[27] （对于此题来说，是从小到大来计算，DP大多数情况下都是从小到大，二维的话就是从上到下，从左到右） 计算顺序只有一个原则，那就是当我们计算到f[X]时，f[X-2], f[X-5], f[X-7] 都已经出结果了； 2.5 动态规划计算步骤f[X] = 最少用多少枚硬币拼出X f[X] = 正无穷 表示无法用硬币拼出X 每一步尝试三种硬币，一共27步； 与递归算法相比，没有任何重复计算； 算法时间复杂度（即需要进行的步数）： 27*3 (总面额*多少种硬币) 1234567891011121314151617181920212223242526272829303132333435363738/** * * @param &#123;*&#125; A [2, 5, 7] * @param &#123;*&#125; M 27 */function coinChange(A, M) &#123; // 0 ... n: [n+1] // 0 ... n-1: [n] const f = new Array(M + 1); // number of kind of coins let n = A.length; // initialization f[0] = 0; let i, j; //最少用多少枚硬币 依次拼出 f[1], f[2], ... f[27]，从小到大的顺序 for (i = 1; i &lt;= M; ++i) &#123; // 初始设置为无穷大 f[i] = Number.MAX_VALUE; // last coin A[j] 要拼出i块钱，最后一枚硬币应该是谁（这枚硬币不应该跳出A的范围） // f[i] = min&#123;f[i-A[0]] + 1,..., f[i-A[n-1]]+1&#125;; for (j = 0; j &lt; n; ++j) &#123; if (i &gt;= A[j] &amp;&amp; f[i - A[j]] != Number.MAX_VALUE) &#123; // i - A[j] 可能是负数，所以需要添加判断 // 无穷大不能+1，会越界。所以需要添加校验； f[i] = Math.min(f[i - A[j]] + 1, f[i]); &#125; &#125; &#125; if (f[M] == Number.MAX_VALUE) &#123; // 如果拼不出来，要求返回-1； f[M] = -1; &#125; return f[M];&#125;console.log(coinChange([1, 5, 6], 27)); 2.6 小结求最值型动态规划 动态规划组成部分： 确定状态 最后一步 (最优策略中使用的最后一枚硬币ak) 化成子问题 （最少的硬币拼出更小的面值27-ak） 转移方程 f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1} 初始条件和边界条件 f[0] = 0, 如果不能拼出Y，f[Y]= 正无穷 计算顺序 f[0], f[1], f[2], … 消除冗余，加速计算；","categories":[{"name":"algo","slug":"algo","permalink":"http://yoursite.com/categories/algo/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"webgl01","slug":"webgl01","date":"2021-01-28T02:30:44.000Z","updated":"2021-02-17T08:29:26.395Z","comments":true,"path":"2021/01/28/webgl01/","link":"","permalink":"http://yoursite.com/2021/01/28/webgl01/","excerpt":"","text":"1. 图形系统绘图原理webgl绘图，要深入细节里，根内存、cpu交互，真正控制图形输出的每一个细节； webgl基础概念，GPU， 渲染管线，着色器； 1.1 计算机图形系统一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。 光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。 像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。 帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。 CPU（Central Processing Unit）：中央处理单元，负责逻辑计算。 GPU（Graphics Processing Unit）：图形处理单元，负责图形计算。 1.1.1 绘图通用过程首先，经过CPU处理，成为具有特定结构的几何信息，然后，这些信息会被送到GPU中进行处理。在GPU中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上； 这个过程主要分为两个步骤， 一是对 给定的数据结合绘图的场景进行计算（例如相机，光源，遮挡物体等等）进行计算，最终将图形变为屏幕空间的2D坐标。 二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上，这整个过程是一步一步进行的，前一步的输出就是最后一步的输入，这个过程叫做渲染管线（RenderPipelines） 1.1.2 GPUCPU 和 GPU 都属于处理单元，但是结构不同。 CPU像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物，一条CPU流水线串行处理这些任务的速度，取决于CPU（管道）的处理能力；一个计算机系统会有很多条CPU流水线，任何一个任务 都可以随机通过任意一个流水线，这样计算机就能够并行处理多个任务了，这样一条流水线对应的就是 thread； CPU处理大型任务是足够的，但是处理图像应用就不合适了。处理图像，实际上是处理计算图片上每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成一个简单的任务，而每一个图片应用又是由无数个个像素点组成的，所以，需要在同一时间处理无数个小任务。要处理这么多的小任务，使用更小，更多的处理单元，是一种更好的处理方式，GPU就是这样的处理单元； GPU由大量的小型处理单元构成，它没有CPU那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张800*600大小的图片，GPU也可以保证这48万个像素点分别对应一个小单元，这样就可以同时对每个像素点进行计算了； 2 .helloWorld浏览器提供的webgl API是 OpenGL ES的js绑定版本，它赋予了开发者操作GPU的能力。这一特点也让webGL的绘图方式略微复杂，无法直接调用API控制画笔。大致需要以下几个步骤 2.1 webGL绘图步骤 创建webgl上下文 创建webgl程序 将数据存入缓冲区 将缓冲区数据读取到GPU GPU执行webgl程序，输出结果 2.1.1 创建webgl上下文1const gl = canvas.getContext('webgl'); 2.2.2 创建webgl程序webgl程序是一个webGL Program对象，它是给GPU 最终运行着色器的程序； 首先编写两个着色器；两个着色器分别对应的是 顶点 和图元， webgl是以顶点和图元来描述图形几何信息的；所以顶点和图元是绘图过程中必不可少的。webgl绘制一个图形的过程，一般需要两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，一段叫片元着色器（Fragment Shader）负责处理图形的像素信息； 2.2.2.1 顶点顶点就是几何图形的顶点，三角形有三个顶点，四边形有四个顶点。 2.2.2.2 图元图元是webgl可直接处理的图形单元，由webgl绘图模式决定，有点、线、三角形等；webgl中最小的图元是三角形； webgl支持的图元类型有七种； gl.POINTS(点), gl.LINES(线段), gl.LINE_STRIP(线条), gl.LINE_LOOP(回路), gl.TRIANGLES(三角形), gl.TRIANGLE_STRIP(三角带), gl.TRIANGLE_FAN(三角扇)。 要绘制空心三角形，gl.LINE_STRIP(线条)、gl.LINES(线段)、 gl.LINE_LOOP(回路)都可以实现。 但是gl.LINES(线段)需要写入六个顶点([-1, -1, 0, 1, 0, 1, 1, -1, 1, -1,-1, -1]), gl.LINE_STRIP(线条)也需要写入四个顶点([-1, -1, 0, 1, 1, -1,-1, -1]), 而gl.LINE_LOOP(回路)，只需要是三个顶点([-1, -1, 0, 1, 1, -1])； 2.2.2.3 顶点着色器和片元着色器顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息（如顶点的坐标、法线方向、材质等等，从而改变我们绘制出来的图形的形状或者大小等等； 顶点处理完成之后，webgl就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单讲，就是对指定图元中的像素点着色； webgl从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是生成光栅信息的过程，也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化后的像素信息； 举例 将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。 将图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的； 因为图元是webGL可以直接处理的图形单元，所以其他非图元的圆形最终必须要转换为图元才可以被webGL处理。比如绘制实心四边形，就需要将四边形拆分成两个三角形，再交给webGL分别绘制出来； 1234567891011121314151617181920212223// 顶点着色器// attribute 相当于var const，声明变量的关键字// vec2 变量类型，vec2表示二维向量// position 变量名const vertex = `attribute vec2 position;void main()&#123; gl_PointSize = 1.0; gl_Position = vec4(position, 1.0, 1.0);&#125;`;// 通过gl_Position 设置顶点；// 片元着色器const fragment = `precision mediump float;void main()&#123; gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);&#125;`;// gl_FragColor 是webGL片元着色器内置变量，表示当前像素点颜色。 它是一个用RGBA色值表示的四维向量数据；// 变量类型 vec4 表示四维向量// webGL可以并行地对整个三角形的所有像素点同时运行片元着色器，并行处理是WebGL程序非常重要的概念；不论这个三角形是大是小，有几十个像素点还是上百万个像素点，GPU都是同时处理每个像素点的；也就是说，图形中有多少个像素点，着色器程序在GPU中就会被同时执行多少次； 123456789101112131415161718// 创建顶点着色器对象const vertexShader = gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vertexShader, vertex);gl.compileShader(vertexShader);// 创建片元着色器对象const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fragmentShader, fragment);gl.compileShader(fragmentShader);// 创建webGLProgram 对象const program = gl.createProgram();gl.attachShader(program, vertexShader);gl.attachShader(program, fragmentShader);gl.linkProgram(program);// 启用webGLProgram对象gl.useProgram(program); 2.2.2.4 向片元着色器传递数据（与绘图步骤无关）1234567891011121314151617181920// 顶点着色器attribute vec2 postion;varying vec3 color; // 顶点着色器可通过 varying变量传给片元着色器；void main()&#123; gl_PointSize = 1.0; color = vec3(0.5 + position * 0.5, 0.0); // 将顶点值映射为一个RGB颜色值； gl_Position = vec4(position*0.5, 1.0, 1.0);&#125;// 片元着色器precision mediump float;varying vec3 color;void main()&#123; gl_FragColor = vec4(color, 1.0);&#125;// 将gl_FragColor 的rgb值设为变量color的值；// 这个三角形是一个颜色均匀渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。webgl// 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值// 利用线性插值可以让像素点的颜色均匀渐变这一特点，可以绘制更多颜色丰富的图形； 2.2.3 将数据存入缓冲区123456789101112// 定义三角形的顶点const points = new Float32Array([ -1, -1, 0, 1, 1, -1,]);// 将points写入webGL缓冲区const bufferId = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW); 2.2.4 将缓冲区数据读取到GPU123456// 获取顶点着色器中的position变量的地址const vPosition = gl.getAttribLocation(program, 'position');// 给变量设置长度和类型gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);// 激活这个变量gl.enableVertexAttribArray(vPosition); 经过这样处理，在顶点着色器中，定义的points类型数组中对应的值，就能通过变量position读取到了； 2.2.5 GPU执行webgl程序，输出结果12gl.clear(gl.COLOR_BUFFER_BIT);gl.drawArrays(gl.TRIANGLES,0, points.length/2); 3. Math我们要建立一套与各个图形系统无关联的，简单基于向量和矩阵运算的数学体系，用它来描述所有的几何图形信息。 如何建立一套描述几何图形信息的数学体系，以及如何用这个体系来解决可视化图形呈现的问题； 3.1 坐标系坐标系与向量来描述基本图形的方法，从如何定义和变换图形的直角坐标系，以及如何运用向量表示点和线段； 3.1.1 HTML窗口坐标体系，以参考对象的元素盒子左上角为坐标原点，x轴向右，y轴向下，坐标值对应像素值； 3.1.2 SVG视区盒子（viewBox）坐标系，默认情况下，是以svg根元素左上角为坐标原点，x轴向右，y轴向下，svg根元素右下角坐标为它的像素宽高值。 如果设置了viewBox属性，那么svg根元素左上角为viewBox的前两个值，右下角为viewBox的后两个值； 3.1.3 Canvas画布左上角为坐标原点，右下角坐标值为canvas画布宽高值； 3.1.4 webGL三维坐标系，它默认以画布正中间为坐标原点，x轴朝右，y轴朝上，z轴朝外，x轴，y轴在画布中范围是 -1 到1； 3.1.5 坐标系转换(以canvas为例)因为html svg canvas webgl都是直角坐标系，所以它们可以方便地相互转化。html，svg，canvas提供了transform的api很方便进行坐标系转换； webgl本身不提供tranform的api，可以在shader里做矩阵运算来实现坐标转换。 在很多可视化场景下，要处理成千上万的图形，如果这个时候，在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。采用坐标变换的方式就是一个很好的优化思路，它能够简化计算量，这不仅让代码更容易理解，也可以节省CPU运算时间； 1234567891011121314151617181920const rc2 = rough.canvas(canvas2);const ctx = rc2.ctx;// 通过translate变换 ，将canvas坐标画布原点从左上角（0，0）移动至（256， 256）的位置，即画布的底边上的中心位置；ctx.translate(256, 256); // 以移动了原点后的新的坐标为参照，通过scale(1,-1) 将Y轴向下的部分，即y&gt;0的部分沿x轴翻转180度；这样就变成画布底边中点为原点，x轴向右，y轴向上的坐标系了；ctx.scale(1, -1); const hillOpts2 = &#123; roughness: 2.8, strokeWidth: 2, fill: \"blue\" &#125;;rc2.path(\"M-180 0L-80 100L20 0\", hillOpts2);rc2.path(\"M-20 0L80 100L180 0\", hillOpts2);rc2.circle(0, 150, 105, &#123; stroke: \"red\", strokeWidth: 4, fill: \"rgba(255,255, 0, 0.4)\", fillStyle: \"solid\",&#125;); 3.2 向量在直角坐标系里绘制图形，一般的几何图形都是由点，线段喝面构成，其中，点和线段是基础的图元信息，因此，如何描述它们是绘图的关键； 如何用向量来描述点和线段？一般用向量来表示一个点或者一个线段； 用二维向量来表示这个平面上的点和线段，二维向量其实就是一个包含了两个数值的数组，一个是x坐标值，一个是y坐标值； 向量V(x,y)有两个含义，一是表示该坐标系下位于（x，y）处的一个点，二是可以表示从原点（0，0）到坐标（x，y）的一根线段。 3.2.1 向量基本运算 现在有两个向量，v1和v2； v1+v2 相当于将V1的终点沿着v2向量的方向移动一段距离。这段距离等于v2向量的长度。 这样在平面上得到三个元素 一个新的点 (x1+x2, y1+y2)； 一条新的线段 [(0, 0), (x1+x2, y1+y2)]; 一段折线 [(0,0),(x1,y1),(x1+x2, y1+y2)]; 3.2.2 向量长度和方向一个向量包含长度和方向信息 它的长度可以用向量的 x、y 的平方和的平方根 （勾三股四弦五）来表示 1v.length = function()&#123;return Math.hypot(this.x, this.y)&#125;; 它的方向可以用与 x 轴的夹角来表示 12v.dir = function() &#123; return Math.atan2(this.y, this.x);&#125;// Math.atan2 的取值范围是 -π到π，负数表示在 x 轴下方，正数表示在 x 轴上方。 根据长度和方向的定义，还能推导出一组关系方式： 12v.x = v.length * Math.cos(v.dir);v.y = v.length * Math.sin(v.dir); 推导过程 12345678#角A 对边=y 邻边 = x, 斜边 = zx*x + y*y = z*zsinA = 对边/斜边 = y/zcosA = 邻边/斜边 = x/ztanA = 对边/邻边 = sinA/cosA = (y/z) / (x/z) = y/x;v.length * cosA = z * (x/z) = xv.length * sinA = z * (y/z) = y 结论： 可以很简单构造出一个绘图向量。如果以点 V（x0, y0）为起点，沿着某个方向画一段长度为length的线段，只需构造如下一个向量即可； 1v1 = length * v(cos(A), sin(A)) 推导过程 12345v1 = length * v(cos(A), sin(A))# 这里写成 v1 = length (cosA, sinA) 更容易理解一些cosA = x/z;sinA = y/z;length = z; 可视化呈现依赖于计算机图形学，而向量运算是整个计算机图形学的数学基础； 3.3 向量乘法向量的点乘Dot.product, 向量的点乘也叫向量的内积、数量积； 向量的叉乘Corss.product，也叫向量积，外积、叉积； 3.3.1 一个例子引出向量乘法的*判断：一个点是否在扫描器内 * 解答 如图所示，扫描器是60度，垂直向上，所以它的范围应该是60度到120度； 也就是 Math.PI/3 到 2*Math.PI/3 1234// 先求出目标向量与X轴的夹脚v.dir = Math.atan2(v.y, v.x); // 此方法是求解夹角的，比如 Math.atan2(1,1) === Math.PI/4 // true// 求解该 dir是否在扫描器之内isIn = v.dir &gt; Math.PI/3 &amp;&amp; v.dir &lt; 2*Math.PI/ 3 3.3.2 向量点乘两个N维向量，a和b， a = [a1,a2,a3,…an], b = [b1b2b3….bn]; 那向量的点积代码： 1a*b = a1*b1 + a2*b2 + .... an*bn a, b 向量点积的几何意义，是a向量乘以b向量在a向量上的投影分量。 它的物理含义相当于a力作用于物体，产生b位移所做的功。 1234// 当a、b向量平行时，那么它们的夹角为0a.x * b.x + a.y * b.y = a.length * b.length;// 当a、b两个向量垂直时，它们的夹角就是90度，那么a.b = 0；a.x * b.x + a.y * b.y === a*b*cos(90度) = a*b*0 = 0; 总结 向量的点乘， 对两个向量执行点乘运算，结果是一个【Scaler标量】（一个数字） （标量： scalar， 只有大小没有方向的量，例如物体移动中的平均速率·路程） 3.3.3 向量的叉乘向量的叉乘，则是针对两条向量的另一种运算方式。 向量叉乘运算的结果不是标量，而是一个新的向量；新的向量会 垂直于 原来的这两条向量； 向量A和向量B的叉积是向量C， 【向量C】同时垂直于【向量A和向量B】 【向量的叉乘】一个用途就是找到我们应该在哪一轴上施加【扭力Torque】（还有，跟踪导弹，比如合金弹头的C弹，也是可以通过叉乘的方法去实现的）； 如下示例： 【向量A】表示的是炮口【当前朝向】 【向量B】表示的是炮口将要【调整后的朝向】 【向量C】将两个向量进行叉乘后，找到炮口需要在哪一轴上进行旋转并且施加相应的扭力； 叉积几何意义 向量a和b的叉积，就相当于向量a（蓝色带箭头线段）与向量b沿垂直方向的投影（红色带箭头线段）的乘积。（如上图所示），二维向量叉积的几何意义就是向量a、b组成的平行四边形的面积； 1|a| 表示向量a的length； 思考题：求点到线段的距离 在了解向量叉积的几何意义之后， 我们通过向量叉积得到平行四边形的面积，再除以底边长；就能得到点到向量所在直线的距离 叉乘在数学上的计算方法 12// 其中，i，j，k 分别是 x，y，z 轴的单位向量，我们把行列式展开，就能得到如下公式：a X b = [y1 * z2 - y2 * z1, - (x1 * z2 - x2 * z1), x1 * y2 - x2 * y1] 更多点积差积相关知识参考https://geek-docs.com/linear-algebra/vector/vector-chaji.html 回到思考题3: 给任意一个点，判断这个点在不在扫描器内 归一化 归一化，用 v0的 x、y 分别除以它的绝对值。归一化后的向量方向不变，长度为 1。 在向量乘法里，如果 a、b 都是长度为 1 的归一化向量，那么|a X b| 的结果就是 a、b 夹角的正弦值，而|a • b|的结果就是 a、b 夹角的余弦值。 好了，再说回来，我们把归一化的向量 a 叉乘扫描器中线上的 v(0,1)，由于扫描器关于 y 轴对称，所以扫描器边缘与 y 轴的夹角是正负 30 度。那么在与单位向量求叉积的时候，就会出现 2 种情况： 点在扫描范围内，如向量 a，就一定满足： |a X v| &lt;= ||a||v|sin(30°)| = |sin(30°)| = 0.5； 点不在扫描范围内，如向量 b，就一定满足：|b X v| &gt; ||b||v|sin(30°)| = |sin(30°)| = 0.5。 因此，只要任意一点所在的向量与单位向量的叉积结果的绝对值不大于0.5（即sin30度），就说明这个点在扫描范围内，所以如下判断方法 123const isInRange = Math.abs(new Vec2(0, 1).cross(v0.normalize())) &lt;= 0.5; // v0.normalize()即将v0归一化 3.3.4 点乘与叉乘加述 Dot product 12345a向量 * b向量 = a长度 * b长度 * cos@ // @ 为a向量和b向量的夹角 // 点乘使用场景1， 快速得到两个向量的夹角 cos@ = （a向量 * b向量） / （a长度 * b长度） 点乘能快速得到两个向量的夹角， 特别是在两个向量都是单位向量的时候。它们的长度自然都是1；所以它们的点乘自然就是夹角的cos值； 点乘满足的计算规律 交换律，分配律，结合率； Cross product 3.4 向量和参数方程描述曲线用参数方程描述曲线的方法，通过此方法可以描述常见的圆，椭圆，抛物线，正余弦等曲线，还能描述更具一般性的曲线；比如贝塞尔曲线，或者Catmull-Rom曲线等等； 3.4.1 画圆 如下图所示的参数方程，圆心为（x0, y0），半径为r； 3.4.2 画圆椎曲线除了画圆，参数方程还可以描述很多其他圆椎曲线，比如椭圆的参数方程。它其实和圆的参数方程很接近。其中，a，b 分别是椭圆的长轴和短轴，当a=b=r时，这个方程就是椭圆的方程式。圆是椭圆的特例； 3.4.3 抛物线的参数方程，其中p是常数，为焦点到准线的距离 3.4.4 贝塞尔曲线3.5 三角剖分和向量操作描述并处理多边形3.6 仿射变换对几何图形进行坐标变换","categories":[{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/categories/webgl/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"canvas","slug":"canvas","date":"2021-01-26T10:08:55.000Z","updated":"2021-03-16T10:15:05.701Z","comments":true,"path":"2021/01/26/canvas/","link":"","permalink":"http://yoursite.com/2021/01/26/canvas/","excerpt":"","text":"1. canvas 基础API1.1 contextcontext对象 proto 指向CanvasRenderingContext2D，一些绘图API集中在这些地方 12const canvas = document.querySelector('canvas')const context = canvas.getContext('2d'); context对象API大体分两类 设置状态的 （颜色，线宽， 坐标变换） 绘制指令API，绘制不同形状的几何图形 1.2 绘图API1.2.1 rect绘制矩形指令 参数 四个参数，分别为要绘制矩形的x坐标，要绘制矩形y坐标, 矩形宽和矩形高； 1.2.2 缓存当前状态和恢复类似一个压栈和弹栈功能； save 保留当前的路径和颜色等状态 restore 123456789ctx.fillStyle = \"green\";ctx.save(); // 保存画笔初始坐标(0,0), 填充色为绿色ctx.fillRect(10, 10, 100, 100);// Restore the default statectx.restore();ctx.fillRect(150, 40, 100, 100); // 该图形的画笔坐标回到 初始状态，即 (0,0) ,填充色为绿色，而不是默认色； 1.3 绘制状态APIfillStyle 1context.fillStyle = color; 1.4 坐标系统 左上角为 (0, 0) 右下角为 (canvas.width, canvas.height) 1.5 绘图过程 获取canvas对象，getContext(‘2d’) 绘制状态， fillStyle， translate等； beginPath开始绘制 调绘图指令，rect等 调fill指令，将绘制内容输出到画布中； 1.6 图形信息有的时候，类似一份层级数据（城市 &gt; 省份 &gt; 中国）这样层级数据，要将它与绘图指令建立联系，建立联系指的是 要把数据的层级、位置、和要绘制的圆的半径、位置一一对应起来； 换句话说就是要把数据转换成图形信息，这个步骤需要数学计算； 假设，我们要将数据展现在一个画布宽高为 1600 * 1600 的 Canvas 中，那我们可以通过 d3.pack() 将数据映射为一组 1600 宽高范围内的圆形。 具体绘制的过程比较简单，只需要遍历数据并且根据数据内容绘制圆弧","categories":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/categories/canvas/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"C","slug":"C","date":"2021-01-25T02:12:49.000Z","updated":"2021-03-24T12:34:37.646Z","comments":true,"path":"2021/01/25/C/","link":"","permalink":"http://yoursite.com/2021/01/25/C/","excerpt":"","text":"前置1.程序 写程序前，先构想好程序的结构，而不是先从定义变量开始。 没有想好解决方案，不要急于动手写程序？ 有了解决方案以后，可以按照“先粗后细，先抽象后具体”的办法，先有程序的轮廓，如有必要可以解决“建模工具”画一些图，而后再动手写程序； 写程序时，可以先写出程序轮廓，而后再补充变量定义等细节； 程序并不纠结于是否更优。而在于程序结构是不是清楚，是不是容易被人看懂 1.1 写程序的过程 按照由大到小，由粗到细，由抽象到具体的方法分析、编写程序 程序的结构 （基本思想） 程序由若干个“模块”组成 模块之内“高内聚”（高内聚， 就是这个模块只做这个事情，不干别的。功能单一） 模块之间“低耦合” （当一个模块被改动的时候，只会印象它自己，而不会影响别的） 1.2 编程语言共性 （语法）程序设计语言的构成,语言种类千差万别，但是，一般来说，基本成分不外四种： 数据， 用以描述程序中所涉及的数据 （数据类型） 运算，用以描述程序中所包含的运算；（运算符） 控制，用以表达程序中的控制构造；（三种类型的控制语句是如何写的，顺序，分支，循环） IO，用以表达程序中数据的传输； （如何输入和输出数据） 1.3 大纲 基本概念 数据类型，运算符，表达式 IO 流程控制（顺序，分支，循转） 数组 指针 函数 构造类型 动态内存管理 调试工具，（gdb，make） 常用库函数 2. 基本概念 把内存想象成一个长长的带子,带子上面有很多小方格，每个格子都是一个字节（存储单元）。每个小方格都有它对应的地址，每个字节（单元）有八位，1B（byte） = 8b（bit）每一个位存储一个二进制的数。 2.1 变量与常量2.1.1 常量 在程序执行过程中值不会发生变化的量，数组名是一个典型的常量，一旦数组定义了，gcc为当前的数组分配了一段空间了。然后数组的位置就定死了。数组名就是一个数组的起始位置。是一个常量，如果你在=左边写上一个常量，就表示企图更改一个常量的值；比如1=f ，显然不成立； 常量的分类 整型常量 实型常量 3.14, 5.26; 字符常量 由单引号印起来的单个字符或者转义字符，如’a’ 转义字符： ‘\\n’, ‘\\r’, ‘\\t’ ，’\\015’(八进制数)， ‘\\x7f’(十六进制数) 字符串常量 由双引号印起来的一个或多个字符组成的序列，如: “”(空串) 一个字符串在存储的时候，最末尾会有一个结束标记，通常称作尾0\\0.所以&quot;&quot;是占空间的，空字符占一个字节的空间； 合法的字符串 （””, “a”, “abXYZ”） 暂时不确定是否合法的字符 （”abc\\n\\021\\018”) 因为\\018不是八进制，因为出现了8，而我们知道\\0是字符串数组的末尾。所以\\0到底能否插入进字符串中间，这个需要后续字符数组专题揭秘； 字符串常量需要借助构造类型——数组来保存 &#39;a&#39;和&quot;a&quot;的区别：前者是字符常量，后者是字符串常量。 标识常量 #define， 程序中一改全改 #define PI 3.14，在程序预处理之后，宏名被宏体完整的替换；define ADD 2+3 ADD*ADD = 2+3*2+3而不是(2+3)*(2+3)。 #define，处理在程序的预处理阶段，占编译时间。不占运行时间。一改全改；缺点： 不检查语法，只是单纯的宏体与宏名之间的替换； 带参数的#define 1234567891011121314151617#define MAX(a, b) a&gt;b?a:bint main() &#123; int i, j; i = 5; j=3; printf(\"/d\\n\", MAX(i, j)); exit(0);&#125;// gcc -E define.c int main() &#123; int i, j; i = 5; j=3; printf(\"/d\\n\", (i&gt;j?i:j)); exit(0);&#125; 一个特殊问题的解决方式 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))int max(int a, int b)&#123;return a&gt;b?a:b;&#125;int main()&#123; int i = 5; int j = 3; printf(\"max = %d\\n\", MAX(i++, j++)); printf(\"i=%d\\tj=%d\\n\", i, j); exit(0);&#125;((i++) &gt; (j++) ? (i++) : (j++))// max = 6// i=7 j=4 首先，max和MAX的区别，MAX只占用预编译时间，等运行的时候，实际上已经将所有宏体替换到程序中去了。不会再需要额外的时间了。而max则不同，在函数的调用位置，对当前的一个执行现场做一个压栈保存。然后去到指定的函数去执行。（跳往另外一个入口地址）然后再回来，弹栈恢复当前现场的过程。这个过程 占用了运行的时间； 什么时候用宏，什么时候用函数？在需要极致性能的场景用宏，前提是宏能满足；比如内核。在应用层面，系统层面，多用函数。因为应用层要求更高的是稳定性，而非实时性。 解决方案，需要找一个变量来接受；而不是让其继续做加运算； 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) (&#123;typeof(a) A = a, B = b;((A) &gt; (B) ? (A) : (B)); &#125;)// typeof(a) 用a的类型定义A，就很灵性了。有点泛型的意思了；int main()&#123; int i = 5; int j = 3; printf(\"max = %d\\n\", MAX(i++, j++)); printf(\"i=%d\\tj=%d\\n\", i, j); exit(0);&#125;// max = 5// i=6 j=4 2.1.2 变量 用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量； 当计算机执行到 int max=0 这句程序时，计算机会在内存里面找到一片存储空间（几个连续的存储单元），然后给该片存储空间取个名字叫 Max， 再把 0 这个初始值放在这个存储空间中来。并记下这个名字（Max）和这片连续的存储空间的起始的地址之间的对应关系 定义： [存储类型] 数据类型 标识符 = 值 TYPE NAME = VALUE; 存储类型 可选 2.1.2.1 标识符当定义一个某种类型的标识符的时候，编译器会为当前的值分配一块内存空间；如何称呼这块空间，就是房间号。房间号就是标识符。编译器会给标识符（房间号）和内存地址标识做关联。当搜索变量名的时候，编译器知道要去到哪块内存地址去搜索；简单说，标识符就是这块空间的临时别名； 2.1.3 存储类型 auto, static register extern(说明型) 2.1.3.1 auto 默认，自动分配空间，自动回收空间 auto类型分配在栈上，堆主要是来进行动态内存分配的空间；堆栈不挨着 12345678910int main ()&#123; auto int i; // 原则上不会 对 i所在这块空间进行初始化 int j; printf(\"i = %d\\n\", i); // 随机的结果，当然有的编译器会置为0 printf(\"j= %d\\n\", j); // 0 编译器会初始化为0 exit(0);&#125; 123456789101112131415161718192021void func(void)&#123; int x =0; x = x+1; printf(\"%p-&gt;%d\\n\", &amp;x, x);&#125;int main()&#123; func(); func(); func();&#125;// 0x7ffee6b3c928-&gt;1// 0x7ffee6b3c928-&gt;1// 0x7ffee6b3c928-&gt;1/**说明： 这三个地址未必一致，但一致的原因是 auto类型的变量都存放在栈上，栈上的空间按正常理论来讲，它实际上是连续分配的。而当前x在 func函数被调用的时候，它才会被产生。然后在当前函数执行结束的时候，这块空间被释放掉了。*/ 2.1.3.2 register 建议型关键字； 寄存器类型，资源少，速度快，寄存器存放在CPU当中，寄存器的数据比较吃紧， 1register int i =1; // 除非i在程序中，超高频率被使用，才建议编译器将i分配到寄存器中；至于有没有被放到寄存器中，由gcc来决定； register的苛刻条件； 只能定义局部变量，不能定义全局变量； 大小有限制，只能定义 32 位大小的数据类型，如double 就不可以 寄存器中没有地址，所以一个寄存器类型变量无法打印出地址查看或者使用； 2.1.3.3 static 静态型，自动初始化为0值或空值，并值其变量的值有继承性（继承性指的的static在内存中只此一份，所以下次使用的时候还是基于上一次的值，而不会被初始化）。另外，常用于修饰变量或函数 1234567891011121314151617181920void func(void)&#123; static int x =0; x = x+1; printf(\"%p-&gt;%d\\n\", &amp;x, x);&#125;int main()&#123; func(); func(); func();&#125;// 0x10c4b1018-&gt;1// 0x10c4b1018-&gt;2// 0x10c4b1018-&gt;3/**说明： static类型的变量，只用一块空间。*/ static 修饰函数： 防止该函数对外扩展，（简单说就是该函数只能在当前文件下使用，在别的文件下没法使用；） 123456789static void func(void)&#123; printf(\"hello func\");&#125;void call_func() // 外界可以通过 call_func 这个桥梁函数来引用 func&#123; func()&#125; 一般来说全局变量都要修饰成static，防止跟别的.c文件中同名变量冲突。然后用static来修饰函数，为的是强调当前函数不可外扩，（该函数只能在当前文件使用，别的文件下没法使用） 2.1.3.4 extern 说明型， 意味着不能改变被说明的变量的值或类型； 12345678910111213141516171819202122// proj.hvoid func(void);// main.cint i =10;int main()&#123; printf(\"%d\\n\", i); func(); exit(0);&#125;// proj.c#include \"proj.h\"extern int i; // 我的i不是自己定义的，是引用其他文件里面的i，编译器自己去找，extern不能改变声明的类型和值；void func(void)&#123; printf(\"%d\\n\", i); exit(0);&#125; 2.1.4 变量的生命周期和作用范围（即作用域） 全局变量和局部变量 局部变量和局部变量 参考图片 3. C程序3.1 程序规范 以helleworld为例对写程序的思路提出如下要求: 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//void main(void);//void main(int argc, char **argv); // char * argv[]//int main(int argc, char **argv);//int main(void);void main()&#123; printf(\"hello c!\\n\"); exit(0);&#125; 头文件正确包含的重要性； 知道程序中的所有警告gcc file.c -Wall 如何调试段错误，先把程序中的所有警告调好； 以函数为单位来进行程序编写； 声明部分 和 实现部分（变量先定义，后使用） return 0 （exit(0) 在单进程单线程的程序中 和 return 0意义一样的，exit(0)是给它父进程看的，当前main函数的父进程是shell） 多用空格空行 添加注释 1echo $? # 上一条语句执行的状态 3.2 注释 #if #endif 注释 12345#if(0)int main()&#123; return 0;&#125;#endif 3.3 编译12#gcc hello.c.c -&gt; .out gcc过程(c源文件到可执行文件需要经过的顺序) c源文件 - 预处理 - 编译 - 汇编 - 链接 - 可执行文件 预处理 gcc -E hello.c &gt; hello.i (预处理hello.c，保存至 hello.i 文件)以#开头的语句部分都是在预处理阶段解决掉的；`include`或者 `if define` 编译阶段gcc -S hello.i (编译hello.i)默认会生成一个 .s文件，编译成汇编文件； 汇编阶段gcc -c hello.s生成一个 .o文件； 链接阶段gcc hello.o -o hello (链接.o文件 生成可执行文件 hello)生成可执行文件hello; 3.3.1 C编译123gcc -o test test.c # 把test.c 编译成一个可执行文件 testgcc hello.c -Wall # 显示编译警告，原则上编码过程当中把程序调到没有警告为止；./test # 执行 test 3.3.2 多个.c文件 main() 里的代码太长了 适合分成几个函数 一个源文件太长适合分成几个文件 两个独立的源文件不能编译形成可执行的程序 3.3.3 头文件 把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件(.c文件)中 #include 这个头文件，就能让编译器在编译的时候知道函数的原型 12# main.c max.c max.hgcc main.c max.c 4. 数据类型 不同数据类型所占字节数 存储区别 不同类型的数据间转换 特殊性： 4.1 基本类型 数值类型 整型 短整型 short （2个字节，16位） 整型 int （4个字节，32位） 长整型 long （4个字节，32位） 浮点型 单精度型 float （4个字节，32位） 双精度型 double （8个字节，64位） 字符类型 char （1个字节，8位） 4.1.1 整形存储整型的存储都是以补码的形势来存储的 补码：正数的补码是它二进制本身，负数的补码是它绝对值的那个数的二进制形式取反再加1的结果； 254 -&gt; unsigned int(无符号 int) -&gt; 32位 -254 -&gt; 254-&gt; 1111 1110 取反 +1 有无符号的区别，最高位到底代表是符号还是正常有效值；有符号的话，为0表示正数，为1表示负数； (254)10 =&gt; (11111110)2 方法： 除2取余倒序排列；（转2进制）11111110 除8取余倒序排列；（转8进制）376 除16取余倒序排列；（转16进制） FE进制表示 254 十进制 B11111110 二进制 0376 八进制 0xFE 十六进制 4.1.2 浮点型存储12343.14 * 10^00.314 * 10^10.0314 * 10^2314 * 10^-2 浮点数是以0.314 * 10^1的方式来存储3.14的 整数部分为0，只是在意精度部分是多少。然后在意指数部分是多少。 浮点数在32 个bit上是如何存放的0～22位（共23个bit）用来记录精度部分。 22位～30位（共8个bit） 用来存储的是指数部分。最高位（第31位） 表示的是符号位置，表示是正数还是负数； 举例 0.000789 -&gt; 0.789 -&gt; 10^3 精度部分存储 789的二进制形式，8个位存储3 float 32位 double 64位 ，比float多出来的32位完全放在精度的控制上 4.1.3 char存储 char 8位。 -128～127 unsigned char 8位。 0～255 4.1.4 不同类型的数据间转换4.1.4.1 精度丢失12float f = 3.9;int i = f; // 4 4.1.4.2 隐式转换编译器默认做的 12345678int i;char ch;float f;double d;ch + i --&gt; i // 默认往精度高，或者所占字节长比较高的那一种数据类型去靠拢的f -d --&gt; d // 精度高的 double(ch + i) - (float - double) --&gt; double 4.1.4.3 显式转换强制类型转换 4.1.4.4 特殊性： 布尔型bool float类型； 1.0/3*3 ！= 1 char型是否有符号，不知道，一个未定义的行为 不同形式的0值； 12340;'0';\"0\";'\\0'; 数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾） 4.2 构造类型 数组 结构体 struct 共用体 union 枚举类型 enum 4.2.1 enum*语法: * 1234enum 标识符&#123; 成员1,&#125; 123456789101112131415enum day&#123; MON, //默认从0 开始往下排 TUS, THR, WES, FRI = 1, // 如果给FRI赋值为1的话，那么接下来会从1继续排 SAT, SUN&#125;int main () &#123; enum day a = FRI; printf(\"%d\\n\", a); // 5&#125; *把enum当宏使用: * 12345678910111213141516171819202122232425262728293031323334enum &#123; STATE_RUNNING = 1, STATE_CANCELED, STATE_OVER&#125;;struct time_t &#123;&#125;;struct job_st&#123; int id; int state; char start; char end;&#125;;int main() &#123; struct job_st job1; // job1.state = STATE_CANCELED; switch (job1.state) &#123; case STATE_CANCELED: break; case STATE_OVER: break; case STATE_RUNNING: break; default: abort(); // 信号，操作系统后续会讲 &#125; return 0;&#125; *这种场景可以用 enum代替宏的使用: * 因为宏经过预编译之后被替换掉了，宏的部分会被替换。影响调试。当然enum不是万能，并不能替代宏；宏还可以传递参数 4.2.2 结构体类型 类型描述 1234struct 结构体名 &#123; 数据类型 成员1; 数据类型 成员2;&#125; 类型嵌套 1234567891011121314151617181920212223242526272829struct birthdata_st &#123; int year; int month; int day;&#125;struct student_st&#123; int id; char name[NAMESIZE]; struct birthday_st birth; // 嵌套定义 int math; int chinese;&#125;// 或者struct student_st&#123; int id; char name[NAMESIZE]; struct birthdata_st // 嵌套定义 &#123; int year; int month; int day; &#125;birth; int math; int chinese;&#125; 定义变量（变量，数组，指针），初始化及成员引用； 12345struct student &#123; // student 不是变量名而是类型 int id; char name[20] .....&#125;; 成员引用： 变量名.成员名 指针名-&gt;成员名 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct simp_st&#123; /* data */ int bigint; float mfloat; char name;&#125;;int main()&#123; struct simp_st a = &#123; 123, 456.789, 'a'&#125;; a.bigint = 333; printf(\"%d, %f, %c\\n\", a.bigint, a.mfloat, a.name); exit(0);&#125; *定义结构体变量的方式: * student tudent1,student2;(结构体类型名) (结构体变量名) 12345struct student &#123; int id; char name[20] .....&#125; lige_1, lige_2; *结构体赋值: * 123456789101112int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; struct student mike2 = mike; // 结构体赋值相当于copy一份给对方 mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike2.name[i]!='\\0'; i++) &#123; mike2.name[i] = toupper(mike2.name[i]); printf(\"%d\\n\", mike2.id_num); printf(\"%s\\n\", mike2.name); &#125; return 0;&#125; *结构体内存 * 12345678struct simp_st &#123; int i; char ch; float f; char ch1;&#125;// 看上去是10个字节，结果打印出来的是16个字节；// 地址对齐， 结构体对齐的概念； 一个公式 address（当前准备存储的变量的地址）%（你当前要存放变量的sizeOf）如果能整除的话，那么这个变量就存放在这里，如果这个表达式不成立，那么address就得 + 1； 举例子说明,首先下面是一段内存 123456789101112131415161718192021222324252627----------0----------1----------2----------3----------4----------5----------6----------7----------8----------9----------10----------11----------12---------- 1234567// 目标结构体struct simp_st &#123; int i; char ch; float f; char ch1;&#125; *解释 * 首先内存第一个地址的值是0，结构体的第一个属性是int，我们知道int占4个字节。0/4 能整除，因此第一个int占据从0-3 这个几个内存中，然后 char占1个字节，4/1能整除，因此第二个char占据了4这个内存中。接着结构体第三个属性为float，占据4个字节。内存地址5/4没法整除，当前内存++，分别到6，7，都无法整除4.到了8，8/4能整除，所以，从8打11这一段内存就存放着float这个属性，接下来又是char12/1能整除，所以char属性占据了char12这个内存地址； 值得注意的是，不同的操作系统内存对齐的方式是不同的；因此在socket编程中，我们传过去的结构体数据在末端一定不能做对齐；因为不知道不同平台到底是什么字节对齐的 *结构体对齐 * 1234struct point &#123; int x; int y;&#125;__attribute__((packed)); 这个操作在网络编程当中很常用； 总结 如果没有内存对齐，就是指定attribute((packed))的话，那么结构体内存的大小就是各个属性的sizeof累加的结果。如果没加就需要考虑内存对齐的问题，不同的机器内存对齐的方式是不同的。因为在跨机器编程比如socket编程当中，是需要指定attribute((packed))来确保数据的完整性和 安全性； 4.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）123456789101112131415161718192021void renew (struct student mike) &#123; mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike.name[i]!='\\0'; i++) &#123; mike.name[i] = toupper(mike.name[i]); &#125; printf(\"%d\\n\", mike.id_num); printf(\"%s\\n\", mike.name);&#125;int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; renew(mike); printf(\"%d\\n\", mike.id_num); printf(\"%s\\n\", mike.name); return 0;&#125;#20130123#MIKE#123#mike 结论 结构体的传入是 值拷贝，函数内部执行的是副本 4.2.2.2 当把结构体当成形参传递的时候，意味着什么1234567891011void func (struct simp_st b)&#123; // 内存总是要分配一个完整的 结构体 体积所占的空间用来接受这个形参 printf(\"%d\\n\", sizeof(b)); // 12&#125;int main() &#123; struct simp_st a; struct simp_st *p = &amp;a; func(a); // func(a.i, a.ch, a.f)&#125; 小结： 所以我们一般不会这么去用。会有非常严重的性能浪费；一般我们会传递结构体指针； 4.2.2.3 结构体作为函数返回值时 总结： 结构体作为函数返回值时，相当于copy一份给调用者 4.2.2.4 指向结构体变量的指针12345678910int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; struct student *p = &amp;mike; printf(\"%d\\n\", (*p).id_num); // 123 printf(\"%d\\n\", p-&gt;id_num); // 123 另外一种写法 -&gt; 指向运算符 printf(\"%s\\n\", p-&gt;name); // mike 另外一种写法 printf(\"%s\\n\", (*p).name); // mike return 0;&#125; 4.2.2.5 指向结构体变量的指针作为参数传入函数1234567891011121314void renew (struct student mike) &#123; mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike.name[i]!='\\0'; i++) &#123; mike.name[i] = toupper(mike.name[i]); &#125;&#125;int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; renew(&amp;mike); printf(\"%d\\n\", mike.id_num); // 20130123 值被篡改 printf(\"%s\\n\", mike.name); // MIKE 值被篡改 return 0;&#125; 4.2.2.6 结构体数组12345678910111213141516int main()&#123; struct student myclass[3] = &#123; 123, &#123;'m','k','k','e'&#125;, 133, &#123;'j','o','y'&#125;, 143, &#123;'t','o','m'&#125; &#125;; struct student * p = &amp;myclass; printf(\"%d\\n\", p-&gt;id_num); // 123 printf(\"%s\\n\", p-&gt;name); // mkke p++; // 跳一个结构体 体积的内存 printf(\"%d\\n\", p-&gt;id_num); // 133 printf(\"%s\\n\", p-&gt;name); // joy return 0;&#125; 4.2.2.7 链表 动态地 申请内存空间 123456int *pint = new int(1024); // 开辟一片内存存储空间并返回起始地址； delete pint; // 释放掉指针所指向的内存空间；int *pia = new int[4]; // 申请一个 4个整型小数组的空间；并返回起始地址；delete [] pia; // 开个方括号，指的是释放掉的是一个数组区域 动态地 建立链表节点 123456struct student &#123; int id; student *next;&#125;student *head;head = new student; 4.2.3 共用体 共用体和结构体语法很像，但截然不同的是，结构体各个成员会占用不同的内存，结构体整体内存 &gt;= sizeof（所有属性）， 因为有内存缝隙的 概念，所以有时候会大一些； 而公用体的内存体积取决于最大属性的体积；共用体所有成员占据同一段内存；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来的值覆盖掉。 共用体是硬件稀缺时代的产物；结合实际场景，比如 checkbox 男女只能同时存在一个； 语法 123union 共用体名 &#123; 成员列表&#125; 类型嵌套 硬件存储分大小端的； 大端格式： 数据的低位保存在高地址中； 小端格式： 数据的低位保存在低地址中； 定义变量（变量，数组，指针），初始化及成员引用 (变量名.成员 指针名-&gt;成员) 占用内存大小 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;union test_un&#123; /* data */ int i; float f; double d; char ch;&#125;;int main()&#123; union test_un a; a.f = 345.678; printf(\"%d\\n\", sizeof(a)); // 8 验证多个成员共用一块空间 printf(\"%f\\n\", a.f); exit(0);&#125; 123456789101112131415161718union unioz&#123; int a; double d; struct &#123; int arr[10]; float f; &#125; c;&#125;;int main()&#123; union unioz x; printf(\"%d\\n\", sizeof(double)); // 8 printf(\"%d\\n\", sizeof(x)); // 48 exit(0);&#125; 函数传参（值，地址） 位域 5. 类型转换存储涉及到2进制，8进制，10进制，16进制。这几种进制之间的转换首先要区别开，如何去获得一个二进制 5.1 十进制转二进制 除2取余，余数倒序排列 254 -&gt; unsigned int -&gt; 32位 （4个字节） 254（10进制）-&gt; 11111110 (2进制) -&gt; 376 (8进制) -&gt; FE(16进制) c语言程序当中是不识别二进制的 254 默认10进制B11111110 二进制0376 八进制0xFE 十六进制 5.2 补码 一个正数的补码形式就是 它二进制本身,负数的补码是它绝对值的二进制形式取反 + 1 254 -&gt; unsigned int -&gt; 32位-254 -&gt; 254 -&gt; 1111 1110 取反 + 1 6. 运算符和表达式表达式与语句的区别 运算符部分： 每个运算符所需要的参与运算的操作个数 结合性 优先级 运算符的特殊性 % 要求 除数，被除数都是整型 位运算的重要性 8.1 自增和自减 运算符在前，先进行计算，再取变量值使用变量在前， 先取变量值使用，再进行计算 7. 位运算3.1 &gt;&gt; &lt;&lt; 位运算（左移右移）基本等同于乘2除2运算,像汇编当中乘以多少，除以多少，几乎按这种方式来实现的 123456int i = B1100 = 12~i -&gt; B0011 // 取反// 把i往右移一位，1100 变成 110， 转化为10进制就是12i &gt;&gt; 1 --&gt; 110 = 6 // 把i往左移一位， 1100变成11000， 转化为10进制就是24i &lt;&lt; 1 --&gt; 11000 = 24 3.2 ~ （取反）12int i = B1100 = 12~i -&gt; B0011 // 取反 3.3 按位或 按位或的计算原则是，同一个位上，两者有一者为1就为真，两者都为假才为假 1234567891011int i = B1100;int j = B1001;i|j 1 1 0 0｜ 1 0 0 1---------- 1 1 0 11101 -&gt; 13 3.4 按位与 按位与的计算原则是，同一个位上，两者有都为1就为真，否则为假 1234567891011int i = B1100;int j = B1001;i&amp;j 1 1 0 0&amp; 1 0 0 1---------- 1 0 0 01000 -&gt; 8 3.5 ^ (相同为0， 不同为1) 亦或计算原则， 同一个位上，相同为0， 不同为1 1234567891011int i = B1100;int j = B1001;i^j 1 1 0 0^ 1 0 0 1---------- 0 1 0 11000 -&gt; 5 3.6 位运算的重要意义 将操作数中第N位 置1， 其他位不变； 1234567891011121314//num = num | 1 &lt;&lt; n // 把某一位 置1的话，把1左移 N个位// 比如将i 的第二位 置1int i = B1011;int j = B1001;i = i | i &lt;&lt; 2; 1 0 1 1| 0 1 0 0 // 注意是把 1 左移动 N个位。 1 -&gt; 0100 空位补0---------- 1 1 1 11000 -&gt; 5 将操作数中第N位 清0， 其他位不变； 1234567891011121314//num = num &amp; ~(1 &lt;&lt; n) // 把某一位 置1的话，把1左移 N个位// 比如将i 的第1位 置0int i = B1011;int j = B1001;i = i | i &lt;&lt; 2; 1 0 1 1| 1 1 0 1 // -&gt; 把1左移N位取反---------- 1 0 0 11000 -&gt; 5 测试第n位： if (num &amp; i 1 &lt;&lt; n) 从一个指定宽度的数中取出其中的某几位 （练习题） 8. 内核代码位置12cd /linux/include/linuxvim list.h 9. 宏 #开头的是编译预处理指令 它们不是C语言的成分，但是C语言程序离不开它们 #define 用来定义一个宏； define (定义一个宏) 12345678910#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(\"%d\\n\", 2*PI*3.0); return 0;&#125;// C语言程序在编译之前，会做一次编译预处理；// 会把程序中所有的PI都替换成 3.14159 4.1 save-temps对一个 .c 文件执行 1gcc 02.c --save-temps 生成 四个文件 02.i02.s02.oa.out 过程依次是 .c -&gt; .i -&gt; .s -&gt; .o -&gt; a.out .c是源代码，经过编译预处理之后变成 .i 这种中间结果文件，当中所有编译预处理指令都执行完，比如 define 宏需要替换掉;然后由于编译器对 .i文件进行编译 生成汇编代码 .s文件；然后汇编代码文件，进行汇编变成目标文件， 目标文件再经过链接之后形成一个可执行的东西； 查看 .i 文件 12tail 03.itail -n 50 03.i # 看03.i文件 最后 50行 123456789extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));# 943 \"/usr/include/stdio.h\" 3 4# 3 \"03.c\" 2int main()&#123; printf(\"%f\\n\", 2*3.1415927*3.0); // 这里明显把宏替换成了值； return 0;&#125; ** 同样的可以把 “%f\\n” 也替换成宏** 12345678#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(FORMATTER, 2*PI*3.0); return 0;&#125; 4.2 宏的缺点 不检查语法，在预处理或者编译阶段是不报错的； 4.3 define #define &lt;名字&gt; &lt;值&gt; 结尾没有 分号，因为不是C的语句 名字必须是一个单词，值可以是各种东西 在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值； 完全的文本替换 gcc –save-temps 如果一个宏的值中有其他的宏的名字，也是会被替换的 如果一个宏的值超过一行，最后一行之前的行末需要加\\ 宏的值后面出现的注释不会被当作宏的一部分 123456789#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏#define PI2 2*PI // PI * 2// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(FORMATTER, 2*PI*3.0); return 0;&#125; 1234567891011#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏#define PI2 2*PI // PI * 2#define PRT printf(\"%f\", PI)\\ printf(\"%f\\n\", PI2)// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; PRT; return 0;&#125; 4.4 没有值的宏 #define_DEBUG 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了； 4.5 预定义的宏 用来表示一些特殊的东西，可以让编译器替我们插入一些特殊的值。 12345_LINE_ //这个源代码所在当前的行号；_FILE_ // 源代码的文件名_DATE_ // 编译时候的日期_TIME_ // 编译时候的时间_STDC_ 4.6 像函数的宏#define cube(x) ((x)*(x)*(x)) 宏可以带参数 123456#define cube(x) ((x)*(x)*(x))int main(int argc, char const *argv[])&#123; printf(\"%d\\n\", cube(5)); // 125 return 0;&#125; 打开 .i 文件 12345int main()&#123;printf(\"%d\\n\", ((5)*(5)*(5))); // 被预处理成这样了； printf(\"%f\\n\", 2*3.1415927*3.0);return 0;&#125; 4.7 错误定义的宏#define RADTODEG(x) (x*57.29578)#define RADTODEG(x) (x)*57.29578 1234567#define RADTODEG(x) (x*57.29578)#define RADTODEG(x) (x)*57.29578int main() &#123; printf(\"%f\\n\", RADTODEG(5+2)); printf(\"%f\\n\", 180/RADTODEG2(1));&#125; 被预处理的结果 1234int main() &#123; printf(\"%f\\n\", (5+2 * 57.29578)); printf(\"%f\\n\", 180/1*57.29678);&#125; 我们发现 被预处理的结果是不符合我们的要求的； 4.8带参数的宏的原则 一切都要有括号 整个值要有括号，指的是整个宏的值有括号 参数出现的每个地方都要括号 #define RADTODEG(x) ((x)*57.29578) 可以带多个参数 #define MIN((a,b) ((a)&gt;(b)?(b):(a)) 也可以组合（嵌套）使用其他宏 在大型程序的代码中使用非常普遍 可以非常复杂，如“产生”函数 在# 和 ## 这两个运算符的帮助下 存在中西方文化差异 部分宏会被inline函数替代 4.9 什么时候用宏 什么时候用函数应用求稳定，用函数追求极致性能，用宏 4.10 include “” 还是 &lt;&gt;include 做了什么？ include就是把头文件里头所有的文本插入到include所在.c文件的那一行. #include有两种形式来指出要插入的文件 “”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找 &lt;&gt; 让编译器只在指定的目录去找 编译器自己知道自己的标准库的头文件在哪里 环境变量和编译器命令行参数也可以指定寻找头文件的目录 4.11 头文件 （.h文件） 在使用和定义这个函数的地方都应该 #include 这个头文件 一般的做法就是任何.c都有对应的同名的.h,把所有对外公开的函数的原型和全局变量的声明都放进去 在函数前面加上static 就使得它成为只能在所在的编译单元中被使用的函数 在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量 4.12 变量的声明123// add.hint add(int a, int b);extern int gAll; // 全局声明一个 变量 int i； 是变量的定义 extern int i； 是变量的声明 4.13声明和定义 声明是不产生的代码的东西 函数原型 变量声明 结构声明 宏声明 枚举声明 类型声明 inline函数 定义是产生代码的东西 10. typedef 为已有的数据类型改名 typedef 已有的数据类型 新名字; 1234567typedef int INT;int main () &#123; INT i; printf(D, i); exit(0);&#125; 5.1 typedef 和 define的区别12345#define IP int *typedef int *IP;IP p,q --&gt; int *p, q;IP p,q --&gt; int *p, *q; ** 更多示例** 12typedef int ARR[6]; ---&gt; int [6] -&gt; ARR;ARR a; --&gt; int a[6]; 123456789101112131415161718192021222324252627struct node_st&#123; int i; float f;&#125;;typedef struct node_st NODE;NODE a; --&gt; struct node_st a;NODE *p; --&gt; struct node_st *p;typedef struct node_st *NODEP;NODEP p --&gt; struct node_st *p;struct&#123; int i; float f;&#125;NODE, *NODEP;typedef int FUNC(int); --&gt; int(int) FUNC;FUNC f; --&gt; int f(int);typedef int *FUNCP(int);FUNCP p; ---&gt; int *p(int);typedef int *(*FUNCP)(int);FUNCP p; ---&gt; int *(*p)(int); 数组类型 数组名[常量表达式] 12float sheep[10]int a2001[1000] 11. 一唯数组1.1.1 定义 【存储类型】 数据类型 标识符 【下标】 1.1.2 初始化不初始化全部初始化部分初始化 123456int main () &#123; int a[] = &#123;1,2,3,4&#125; // 不给长度也行 int b[4] = &#123;1,2&#125; // [1,2,0,0] 部分元素初始化 int c[4] = &#123;0&#125; // [0,0,0,0] 部分元素初始化 int d[4] = &#123;1,2,3,4,5,6&#125; // compile error&#125; 1.1.3 元素引用 数组名【下标】 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3int main()&#123; int arr[M]; int i; printf(\"%d\\n\", sizeof(arr)); for(; i&lt;M; i++) printf(\"%p-&gt;%d\\n\", &amp;arr[i], arr[i]); exit(0);&#125;// 0x7ffee4394940-&gt;-466007712// 0x7ffee4394944-&gt;32766// 0x7ffee4394948-&gt;201064485 下标 查找块 1.1.4 数组名 当前数组的起始位置，数组名本身就是表示地址的一个常量。 常量： 程序执行过程当中不会发生变化的量；正因为数组名是常量，所以它不能无条件出现在数组的左边； 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3int main()&#123; int arr[M] = &#123;1,2,3&#125;; int i; arr[M] = &#123;4,5, 6&#125;; // 语法错误，数组名是常量，无法被直接赋值 printf(\"%d\\n\", sizeof(arr)); for(; i&lt;M; i++) printf(\"%p-&gt;%d\\n\", &amp;arr[i], arr[i]); exit(0);&#125; 1.1.5 数组越界 溢出数组所在内存区域 1.1.6 fb12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main() &#123; int fib[10] = &#123;1,1&#125;; int i; for (i =2; i&lt;10; i++) fib[i] = fib[i-1] + fib[i-2]; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); printf(\"\\n\"); return; &#125; 12345678910111213141516171819202122232425262728293031// fb加个排序 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int fib[10] = &#123;1,1&#125;; int i; int j; int tmp; for (i =2; i&lt;10; i++) fib[i] = fib[i-1] + fib[i-2]; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); printf(\"\\n\"); i=0; j=sizeof(fib)/sizeof(fib[0]) -1; while(i&lt;j) &#123; tmp = fib[i]; fib[i] = fib[j]; fib[j] = tmp; i++; j--; &#125; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); return; &#125; 12. 二维数组1.2.1 定义，初始化 【存储类型】 数据类型 标识符 【行下标】 【列下标】 123int a[3][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;int b[][4] = &#123;1,2,3,4,5,6,7,8,9&#125;;int c[3][4] = &#123;0&#125;; 1234int main()&#123; int a[M][N]&#125; 1.2.2 二维数组元素引用数组名[行标][列标]int a[3][4] // 定一个三行四列的二维数组 1.2.3 存储形式 顺序存储，按行存储,二维数组在内存中的存储， 是拉平的 12345678910111213141516171819202122232425----------a[0][0]----------a[0][1]----------a[0][2]----------a[0][3]----------a[1][0]----------a[1][1]----------a[1][2]----------a[1][3]----------a[2][0]----------a[2][1]----------a[2][2]----------a[2][3]---------- 深入理解二维数组 1 a[0][0] 2 a[0][1] 3 a[0][2] 4 a[0][3] 5 a[1][0] 6 a[1][1] 7 a[1][2] 8 a[1][3] 9 a[2][0] 10 a[2][1] 11 a[2][2] 12 a[2][3] 1.2.4 二维数组练习题1.2.4.1 行列互换123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 3int main()&#123; int arr[M][N] = &#123;1,2,3,4,5,6&#125;; int b[N][M]; int i,j; for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; b[j][i] = arr[i][j]; printf(\"%d\",arr[i][j]); &#125; printf(\"\\n\"); &#125;; for (i=0;i&lt;N;i++) &#123; for (j=0;j&lt;M;j++) printf(\"%d\", b[i][j]); printf(\"\\n\"); &#125; exit(0);&#125; 1.2.4.2 求最大值及其所在位置12345678910111213141516171819202122232425262728293031#define M 2#define N 3static void max(void)&#123; int a[M][N] = &#123;43,4,23,89,9,7&#125;; int i,j; int max = a[0][0], row =0, col = 0; for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; if(a[i][j]&gt;max) &#123; max= a[i][j]; row = i; col = j; &#125; &#125; &#125; printf(\"%d\\n\",max); printf(\"%d --- %d\\n\", row, col);&#125;int main()&#123; int arr[M][N] = &#123;1,2,3,4,5,6&#125;; int b[N][M]; int i,j; max(); exit(0);&#125; 1.2.4.3 求各行与各列的和 123456789101112131415161718192021222324252627282930static void sum(void)&#123; int a[5][4] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;,&#123;10,11,12&#125;&#125;; int i, j; for (i=0; i&lt;4; i++) &#123; for (j=0;j&lt;3;j++) &#123; a[4][3] += a[i][j]; a[4][j] += a[i][j]; a[i][3] += a[i][j]; &#125; &#125; for(i=0;i&lt;5;i++) &#123; for(j=0;j&lt;4;j++) &#123; printf(\"%4d\",a[i][j]); &#125; printf(\"\\n\"); &#125;&#125;int main()&#123; sum(); exit(0);&#125; 1.2.4.4 矩阵乘积123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 3#define K 2 static void mul(void) &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125; ; int b[N][K]= &#123;1,0,0,1,1,0&#125;; int c[M][K]; int i,j,k; for(i=0;i&lt;M;i++) &#123; for(j=0;j&lt;K;j++) &#123; for(k=0; k&lt;N; k++) &#123; c[i][j] += a[i][k] * b[k][j]; &#125; &#125; &#125; for(i=0;i&lt;M;i++) &#123; for(j=0;j&lt;K;j++) &#123; printf(\"%4d\",c[i][j]); &#125; printf(\"\\n\"); &#125; &#125; int main() &#123; mul(); exit(0); &#125; 1.2.5 深入理解二维数组 1.2.5.1 三维数组a[5][3][4] 数据立方体 5 -&gt; 片3 -&gt; 行4 -&gt; 列 在内存中依然是打平存放； 13. 字符数组1.3.1 定义，初始化，存储特点 【存储类型】 数据类型 标识符 【下标】。。。 1.3.1.1 单个字符初始化1char str[3] = &#123;'a','b','c'&#125; char c[] = {‘C’, ‘h’, ‘i’, ‘n’, ‘a’};// c[0] = C c[1] = h c[2]= i c[3]=n c[4]=a 1.3.1.2 用字符串常量初始化1char str1[6] = \"hello\"; // 最后一位 以 '\\0' 结尾 char c[] = “China”// c[0] = C c[1] = h c[2]= i c[3]=n c[4]=a c[5]=\\0 1.3.2 输入输出1234567891011int main()&#123; char str[N], str1[N], str2[N]; int i; scanf(\"%s%s%s\", str, str1,str2); printf(\"%s\\n%s\\n%s\\n\", str, str1,str2);&#125;// how are you// how// are// you 1.3.2.1 单词计数12345678910111213141516171819202122#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; char str[128]; int count =0, flag = 0; int i; gets(str); for(i=0;str[i]!='\\0';i++) &#123; if(str[i]==' ') flag = 0; else if(flag == 0) &#123; count++; flag=1; &#125; &#125; printf(\"count = %d\\n\", count); &#125; 1.3.3 字符数组注意事项 所有字符串都是以 \\0 来结尾的；所有以 \\0结尾 的字符数组都可以被看为字符串 123456char c[6] = \"China\"; //只可以在数组定义并初始化的时候// 不能用赋值语句将一个字符串常量或字符数组直接赋给另一个字符数组str1[] = \"China\" // 赋值，不合法str1 = \"China\" // 赋值，不合法str2 = str1 // 赋值，不合法 指针 变量与地址 指针与指针变量 直接访问与间接访问 空指针与野指针 空类型指针 定义，初始化，书写规则 指针运算 指针与数组 指针与一维数组 指针与二维数组 指针与字符数组 const与指针 指针数组和数组指针 多级指针 14. 变量与地址变量名： 变量名就是用户对某一块内存空间的抽象表示；想把这块儿内存置成100，就写int i = 100;变量名就是某个内存空间的别名； 地址： 指针就是地址，指针就是指向某个内存空间地址的地址值； 1.1 变量的三要素int a = 3 在内存中， 即产生 0x0012FF78，3，a 三个要素。 0x0012FF78即变量的地址， 把这个变量的地址称为“指向该变量的指针”； 3即变量值； a即变量的签名； 1.2 输出变量的地址地址运算符 “&amp;” int a = 3; printf(&quot;%x&quot;, &amp;a) 15. 指针与指针变量语法 TYPE NAME = VALUE； 12int i = 1; // type 为 intint * p = &amp;i; // type 为 int *, 而不是 int 2.1 非法操作（野指针）12int * p = &amp;i; // 合法操作，指针一旦定义出来，就要给一个明确指向；没有的话，下回分解int * p = 0x7fffa37eac60; // 可能这个地址已经被占用了，一般情况下，是个非法操作； 2.2 指针变量 专门用于存放指针（某个变量的地址）的变量 123456789101112int c = 76;int * pointer; //定义名字为pointer的指针变量；只能存放地址！// int *pointer;// 1) int 是指针变量的基类型 所谓基类型：指针变量指向的变量的类型// 2) * 是指针运算符，表示pointer这个变量的类型// 3) pointer 是指指针变量的名字pointer = &amp;c;// 将变量c 的地址赋值给指针变量pointer；// 赋值后，称指针变量pointer指向了变量c； 则*pointer： 为pointer所指向的存储单元的内容；是变量c。因此*pointer可以当作 变量c 来使用 2.3 指针变量的地址 指针变量也是变量，是变量就有地址 12345678910int main() &#123; int a = 13; int * p = &amp;a; *p = 100; printf(P, p); printf(P, &amp;p); // 指针变量也有地址； // 0x7ffee6a26ac8 // 0x7ffee6a26ac0 return 0;&#125; 2.4 指针变量示例12345678910111213int main()&#123; int a = 0, b=3, temp; int *p1 = NULL, *p2 = NULL; p1 = &amp;a; p2 = &amp;b; printf(\"%p\\n\", &amp;a); printf(\"%p\\n\", &amp;b); if(*p1 &lt; *p2) &#123; temp = *p1; *p1 = *p2; *p2 = temp; &#125; printf(\"%d\\n\", *p1); // 3 printf(\"%d\\n\", *p2); // 0&#125; 2.5 指针作运算 (取地址 和 取 * 和关系运算) 2.5.1 取地址 要获取某个变量在内存中的房间号 2.5.2 取* 找到现在给定房间号里面存放的内容 16. 直接访问和间接访问3.1一级间接访问和 二级间接访问1234567891011121314int main ()&#123; int i = 1; int *p = &amp;i; int **q = &amp;p; printf(P, p); // 0x7ffee92579b8 printf(P, q); // 0x7ffee92579b0 printf(P, *q); // 0x7ffee92579b8 printt(D, i); // 1 直接访问 printf(D, *p); // 1 一级间接访问 printf(D, **q);// 1 二级间接访问 exit(0);&#125; 3.2 指针关系运算 当两个指针指向的是一块连续内存空间的时候， 比如两个指针指向同一个数组。在这种情况下，两个指针可以做一个关系上的比较； ++ -- ++ – 运算实际上改变指针位置； 3.3 指针变量类型与指针变量大小12345678910111213141516171819202122int main ()&#123;int i = 1;int * p;float *q;double *d;printf(D, sizeof(i)); // 8printf(D, sizeof(p)); // 8printf(D, sizeof(q)); // 8printf(D, sizeof(d)); // 8// 结构体指针的大小也是8/** 不管指针是多少级的指针，不管指针是什么样的类型。指针在某个平台下所占的地址空间是确定的。那既然如此为何 要给指针变量加类型呢，比如 int *p, float *q. 那是因为有 *p 取* 的操作，比如*q的时候，怎么就能知道去对应地址读取 4个字节呢？ 这个时候就要靠 指针变量的 变量类型加持了。所以这个变量类型之间的意义 就不尽相同了。*/char * s;s = &amp;i;printf(D, *s); // 这个时候，不知道要去读取 4个字节，所以结果不是1；&#125; 17. 空指针与野指针12345int main ()&#123; int * p = NULL;// 指针被定义出来，还未决定指向哪里的时候，可以先指向NULL，系统上 0 号不分配给任何进程；把指针置为空是为了预防野指针； exit(0);&#125; 4.1 野指针 当前这个指针的指向是不确定的，或者压根就没有指向；但是直接使用这个指针了。 1234567int main()&#123; int *p; printf(\"%p --&gt; %d\\n\", p ,*p); // 0x7ffee67879d8---&gt;0&#125; 1234567int main()&#123; int *p; printf(\"%p --&gt; %d\\n\", p ,*p); *p = 1; // 段错误&#125; 4.1.1 如何杜绝野指针 指针一经定义，就必须有一个明确的指向，没有暂时没有指向的话，就先指向NULL； 18. 空类型1void * p = NULL; // 即 空类型 void * 是一个百搭的类型，任何类型的指针值都可以赋值给它。void * 也可以把自己的值赋值给任何类型的指针； 5.1 空类型的使用场景1void *memcpy(void *dest, const void *src, size_t n); 19. 运算符优先级 上面优先级比下面高 后置++ – 前置++ – 逻辑非 (!) * &amp; // 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高 算术运算符 关系运算符 &amp;&amp;和｜｜ 赋值运算符 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高 如 12&amp;*pointer = &amp;(*pointer)*&amp;a = *(&amp;a) (*pointer)++ 不等于 *pointer++ (pointer)++ 是先 做取运算，得到的int类型自增， pointer++ 则是 指针变量移位，然后再取运算 *pointer++ 的含义 假设： pointer当前所存的地址是0x00000100 若pointer 的指针变量基类型是 指向一个 int或实型（占4个字节），则pointer++ 等于 iptr + 1*4 = 0x00000104 若pointer 指向一个 字符型（占1个字节），则pointer++ 等于 iptr + 1*1 = 0x00000101 12345678910111213int main() &#123; int a[5] = &#123;5,11,19,21,33&#125;; int *p = NULL; printf(P, a); // 0x7ffee0eeda20 p = a; printf(P, p); // 0x7ffee0eeda20 printf(D, *p); // 5 printf(D, *p++); // 5 printf(D, *p++); // 11 printf(D, *p); // 19 return 0;&#125;*p++ 是地址移动 ** 小结** 指针和指针变量是不同的。指针是地址，指针变量就是一个普通的变量。pointer指的是这个指针变量 所指向的那片内存空间里面的内容。(pointer)++ 不等于 *pointer++ 20. 指针与数组 数组名代表数组首元素的地址 （数组名相当于指向数组第一个元素的指针）；数组名不是变量，不能给a赋值；int *p = &amp;a[0]; a++是没有意义的（a只是个常量），但p++会引起p变化。p可以指向数组最后一个元素以后的元素。指针做加减运算时一定注意有效的范围；（指针理论上能够在内存中自由的漂移，很可能移除某一个数组的范围，有的时候就比较危险了） 7.1 数组名代表数组首元素的地址 数组名是指向数组第一个元素的指针； 对于数组a[10], 数组名 a代表数组 a[10]中第一个元素a[0]的地址； 即 a 与 a[0]等价 注意： a是地址常量，不是变量，不能给a赋值； 7.2 创建一个匿名数组 指针和数组的关系，其实就是一种引用方式而已。你的一维数组名和一级指针之间的关系其实除了一个是变量，一个是常量之外。完全可以等价代换。 1234567int main()&#123; int *p = (int [3])&#123;1,2,3&#125;; int i; for (i=0;i&lt;3;i++) printf(D, p[i])&#125; 7.3 利用指针变量引用数组元素 若定义 数组 int a[10]; 指针 int * pointer; 则: pointer =a; 等价于pointer = &amp;a[0]; 数组访问 pointer+ i; 等价于 a+i; 等价于 &amp;a[i]; *(pointer+i); 等价于 *(a+i); 等价于a[i]; 表示形式 pointer[i] 等价于 *(pointer+i); 1234567891011121314151617int main () &#123; int a[9] = &#123;4,5,6,7,8,9,1,2,3&#125;; int *p = NULL; p = a; // a 是 数组的地址， printf(\"%d\\n\", *p); // 4 printf(\"%d\\n\", *p++); // 4 ++的含义是先使用p，然后再++ printf(\"%d\\n\", *p); // 5 printf(\"%d\\n\", *++p); // 6 前+ 和 后+ 跟js一样 printf(\"%d\\n\", p[0]); // 因为p=a了，所以p[0] 即a[0] printf(\"%d\\n\", p[1]); printf(\"%d\\n\", p[2]); printf(\"%d\\n\", p[3]); printf(\"%d\\n\", p[4]); return 0;&#125; 7.4 抽象公式12345int * p = a;// a[i]: a[i] = *(a+i) = *(p+i) = p[i];// &amp;a[i]: &amp;a[i] = a+i = p+i = &amp;p[i];p = a; 7.5 重置指针变量1234567891011int a[3];int *p = a;int i;for (i=0; i&lt;sizeof(a)/sizeof(*a); i++) scanf(\"%d/n\", p++);p = a; // 这里需要 重置一下 p的指针；不然会数组越界；for (i=0; i&lt;sizeof(a)/sizeof(*a); i++) printf(\"%d\", *p++); 7.6 需要注意的问题 int * p = &amp;a[0]; , * a++是没有意义的（因为a是个常量），但p++会引起p变化；* p可以指向数组最后一个元素以后的元素；（因为p是内存中的一个指针），所以指针做加减运算时一定注意有效的范围。 123456int a[5],int *iPtr = &amp;a[1];iPtr--; // 指向&amp;a[0]*iPtr = 3; // a[0] = 3iPtr--; // 指向&amp;a[-1], dangerous*iPtr = 6; // (damage) 对内存造成损坏，影响内存中其他的变量 示例 123456789int main()&#123; int a[5] = &#123;6,7,8,9,0&#125;; int *p = &amp;a[3]; *p = 100; printf(\"%d\\n\", *p++); // 100 printf(\"%d\\n\", *p--); // 0 printf(\"%d\\n\", *--p); // 8 return 0;&#125; 7.7 指向二维数组的指针7.7.1 遍历数组元素1234567891011121314151617181920212223242526272829303132int main()&#123; int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int *p; for (p= &amp;a[0][0] ;p &lt; &amp;a[0][0]+12; p++) &#123; printf(\"%d\\n\", *p); &#125; return 0;&#125;// 0x7ffeefbff4f0// 1// 0x7ffeefbff4f4// 3// 0x7ffeefbff4f8// 5// 0x7ffeefbff4fc// 7// 0x7ffeefbff500// 9// 0x7ffeefbff504// 11// 0x7ffeefbff508// 13// 0x7ffeefbff50c// 15// 0x7ffeefbff510// 17// 0x7ffeefbff514// 19// 0x7ffeefbff518// 21// 0x7ffeefbff51c// 23 如上所示， 会将这个数组的内容都打印出来了，因为二维数组会被拉平存储到一段连续的内存空间当中 7.7.2 二维数组行列指针12345678910111213141516171819202122232425262728293031323334353637383940414243 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define M 3 #define N 4 #define D \"%d\\n\" #define P \"%p\\n\" int main () &#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i, j; printf(\"&amp;a = %p, &amp;a+1 = %p\\n\", &amp;a, &amp;a+1); printf(\"%&amp;a[0][0] = %p, &amp;a[1][0] = %p\\n\", &amp;a[0][0], &amp;a[1][0]); for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%p---&gt;%d\\n\", &amp;a[i][j], a[i][j]); &#125; printf(\"\\n\"); &#125; exit(0); &#125;// &amp;a = 0x7ffefe385370, &amp;a+1 = 0x7ffefe3853a0// %&amp;a[0][0] = 0x7ffefe385370, &amp;a[1][0] = 0x7ffefe385380// 0x7ffefe385370---&gt;1// 0x7ffefe385374---&gt;2// 0x7ffefe385378---&gt;3// 0x7ffefe38537c---&gt;4// 0x7ffefe385380---&gt;5// 0x7ffefe385384---&gt;6// 0x7ffefe385388---&gt;7// 0x7ffefe38538c---&gt;8// 0x7ffefe385390---&gt;9// 0x7ffefe385394---&gt;10// 0x7ffefe385398---&gt;11// 0x7ffefe38539c---&gt;12 小结： 所以a除了是二维数组的数组名（地址常量）之外，在使用上比较偏向一个指向行指针。 7.7.3 能够接收二维数组指针的指针变量引子 1234567891011&#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i=0, j=0; int *p = NULL; p =&amp;a[i][j]; // *(a+0) , *a for (i=0; i&lt;12; i++,p++) // for (i=0; i&lt;12; i++) printf(\"%d \", *p); // printf(\"%d \", p[i]); printf(\"\\n\"); exit(0); // 1 2 3 4 5 6 7 8 9 10 11 12 &#125; 7.7.4 另一段程序123456789int main()&#123; int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int (*p)[4], i,j; p = a; cin&gt;&gt;i&gt;&gt;j; // i&lt;3 代表行号， j&lt;4 代表列号； cout &lt;&lt; setw(4) &lt;&lt; *(*(p+i)+j); // 正误判断： 访问元素 a[i][j] return 0;&#125; 程序分析 从 p = a 开始 a相当于指向a[3][4]的“第一个元素”的指针； 所谓“第一个元素”是指一个“包含4个int型元素的一维数组”； 所以，a相当于一个“包含4个int型元素的一维数组”的地址； 因此，p的基类型应该是： “包含4个int型元素的一维数组” 变量定义语句的语法为： int (*p)[4]; *p(数组) p -&gt; | (p)[0] | (p)[1] | (p)[2] | (p)[3] | 7.7.5 利用指针变量引用多维数组中的数组((p+i)+j)是什么？ p 是指向一个“包含4个int型元素的一维数组”； p+i 是第i+1个“包含4个int型元素的一维数组”的地址; p+i 等价于&amp;a[i]； *(p+i)等价于a[i]； *(p+i)+j 等价于 a[i]+j; // 这里把a[i] 当作一个指针来看 因此， a[i]+j 等价于 &amp;a[i][j]; ((p+i)+j) 等价于 a[i][j]; 7.8 指针与字符数组12345678910111213 int main () &#123; char s[] = \"i love coding!\"; // codeing char *p = s+7; printf(\"%s\\n\", s+7); puts(s); puts(p); // puts(p) 相当于把p的起始位置拿进来， 依次输出，直到碰到\\0 为止； exit(0); &#125;// coding!// i love coding!// coding! 7.8.1 字符数组拼接12345678910#include &lt;string.h&gt;int main()&#123; char str[] = \"hello\"; // str = \"world\" false strcpy(str, \"world123\"); // 覆盖原来数组空的每一项 puts(str); // world123 exit(0);&#125;// world123 7.8.2 字符串长度和字符串字节数12char str[] = \"hello\";printf(\"%d ,%d\", sizeof(str), strlen(str)); // 6, 5 7.8.3 字符指针跟字符数组的区别12345678char *str = \"hello\";sizeof(str); // 8 指针变量不分类型 ， 64位系统下长度都是8个字节， 32位系统为4个字节；strlen(str); // 5 字符串长度strcpy(str, \"world\"); // 段错误， 字符指针跟字符数组的区别就在于此。因为str 指向的是一个 字符串常量的地址， strcpy是一个覆盖写操作，显然，企图去更改一个常量是无效的。之所以是常量，是串常量，这个串在当前存储位置是特殊的。在使用上不允许被改变和覆盖。// 正确的做法str = \"world123\"; //更改指针指向；puts(str); 21. 字符串与指针 指向字符串的指针 指向字符串的指针变量： char a[10]; char *p; p=a; 数组和字符串太接近了。那怎么去定义指向字符串的指针呢？也很简单， 我首先定义一个字符数组，它就是用来存放字符串的。 我们以前讲过字符串和字符数组其实区别就在于有没有最后的反斜杠零， 本质上都是字符数组。 123456789101112int main()&#123; int a = 5; int *p = &amp;a; char c[6] = &#123;'h', 'e', 'l', 'l', 'o','\\0'&#125;; char *s = c; printf(P, s); // 0x7ffee2066aba printf(P, c); // 0x7ffee2066aba printf(S, s); // hello printf(S, c); // hello s++; printf(S, s); // ello&#125; 8.1 字符串指针举例123456789101112int main() &#123; char buffer[10] = \"ABC\"; char *pc; pc = \"hello\"; // 虽然 hello赋值给了pc，但是却不能通过pc去改变hello， 因为hello是常量，常量在内存中被放在特殊的地方了；这片区域不允许修改； cout &lt;&lt; pc &lt;&lt; endl; // hello pc++; cout &lt;&lt; pc &lt;&lt; endl; // ello cout &lt;&lt; *pc &lt;&lt; endl; // e pc = buffer; cout &lt;&lt; pc; // ABC return 0;&#125; 22. const与指针 const是把某些内容常量化 1234567891011121314const int a;const float pi = 3.14; // 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。int const a;// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思 const int *p;int const *p;// 指针常量int *const p;const int *const p; 9.1 变量值常量化123const int a;const float pi = 3.14; // 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。int const a; 9.2 常量指针 指针的指向可以发生变化，但是指针所指向当前的那块内存的值是不可以发生变化的； 123// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思const int *p;int const *p; 12345678910int main ()&#123; const float pi = 3.14; // float *p = &amp;pi; // 警告： initialization discards ‘const’ qualifier from pointer target type const float *p = &amp;pi; *p = 3.14159; printf(\"%f\\n\", pi); printf(\"%f\\n\", *p); exit(0);&#125; 举例： 1int open(const chart * pathname, int flags); // 常量指针，保护pathname值不被篡改 9.3 指针常量int *const p; 指针常量指 指针的指向永远不能发生变化；但是指针指向的值可以有变化； 9.3.1 引用引用是C++语言的概念，C中并没有； 在《thinking c++》一书中有这么一句，“A reference (&amp;) is like a constant pointer that is automaticallydereferenced.” （引用（＆）就像一个常量指针，它会自动 取消引用） 这句话是什么意思呢？ 9.4 如何区分到底是 常量指针，还是指针常量1234const int *p; // 如果先碰到const关键字，就把常量先念出来int const *p; int *const p; // 如果先看到 *，就把指针先念出来 9.5 两个const修饰const int *const p; 12345678910int main ()&#123; int i = 1; int j = 100; const int * const p = &amp;i; p = &amp;j; // warning 因为p是只读的，不能更改指向； *p = 10; // warning 因为*p 也是只读的；&#125; 9.6 指向符号常量的指针const int * p; 当把p定义成一个指向符号常量的指针的时侯， 然后再让这个p指向什么东西， 它所指向的那个东西就不能被修改了。我们就不能通过p再去修改 它所指向的那个东西了。 深坑啊,要留意 1234567891011121314int main() &#123; const int a = 78; const int b = 28; int c = 18; const int * p1 = &amp;a; *p1 = 58; // (error, *p不能被赋值) p1 = &amp;b; // （可以给 p1 重新赋值） *p1 = 68; // (error, *p不能被赋值) printf(D, *p1); // 28 p1 = &amp;c; // （可以给 p1 重新赋值） *p1 = 88; // (error, *p不能被赋值) printf(D, *p1) // 18&#125; 9.7 再谈一维数组的地址数组名相当于指向数组第一个元素的指针 123456789101112131415int main() &#123; int a[4] = &#123;1,3,5,7&#125;; cout&lt;&lt;a&lt;&lt;endl; // a[1]的地址，管辖范围只有a[1] cout&lt;&lt;&amp;a&lt;&lt;endl; // a[1]的地址，管辖范围是整个a的内存空间 cout&lt;&lt;a+1&lt;&lt;endl; // a[2]的地址 cout&lt;&lt;&amp;a+1&lt;&lt;endl; // 跳出了a的内存范围，理论上是 a[5]的地址 printf(P, a); // 0x7ffee42adab0 printf(P, a+1); // 0x7ffee42adab4 跨越4个字节 printf(P, &amp;a); // 0x7ffee42adab0 printf(P, &amp;a+1); // 0x7ffee42adac0 // 跨越16个字节 printf(P, *(&amp;a)); // 0x7ffee42adab0 printf(P, *(&amp;a) + 1); // 0x7ffee42adab4&#125; 根据C语言的规范 *(&amp;a) 等同于 a; 即a数组第一个元素的内存地址*(&amp;a) + 1 等同于 a+1; 即a数组第二个元素的内存地址 &amp;a的管辖范围是整个数组a。c语言规范中，当它前面出现*时，管辖范围降级，即堕落成了 a[0]的地址； 9.8 总结 数组名相当于指向数组第一个元素的指针 &amp;运算符 - 升级 若 a 是指向数组第一个元素的指针，即a相当于 &amp;a[0]; &amp;a是“指向数组”的指针；&amp;a+1将跨越16个字节； &amp;a相当于管辖范围 “上升” 了一级; *运算符 - 降级*a是数组的第一个元素a[0]；即 *a等价于a[0]； *a 相当于管辖范围“下降”了一级； 9.9 指向二维数组的指针 二维数组的定义 二维数组a[3][4]包含三个元素： a[0] a[1] a[2] 每个元素都是一个“包含四个整型元素”的数组 | 1 a[0][0] | 2 a[0][1] | 3 a[0][2] | 4 a[0][3] || 5 a[1][0] | 6 a[1][1] | 7 a[1][2] | 8 a[1][3] || 9 a[2][0] | 10 a[2][1]| 11 a[2][2]| 12 a[2][3]| - 二维数组的第一个元素是a[0]; - a[0]是一个“包含四个整形元素”的一维数组； 推论 a 与 &amp;a[0] 等价a[0] 与 &amp;a[0][0] 等价a[0] 与 a 等价a[0][0] 与 *a 等价 9.10 总结三条规律1） 数组名相当于指向数组第一个元素的指针；2） &amp;E相当于把E的管辖范围上升了一个级别；3） *E相当于把E的管辖范围下降了一个级别； 23. 指针与函数10.1 指针用作函数参数123456789101112131415161718void Rank(int *q1, int *q2) &#123; int temp; if (*q1 &lt; *q2)&#123; temp = *q1; *q1 = *q2; *q2 = temp; &#125;&#125;int main() &#123; int a, b, *p1, *p2; scanf(a); scanf(b); p1 = &amp;a; p2 = &amp;b; Rank(p1, p2); // 指针传递，即地址传递 printf(\"%d\\n\", a); printf(\"%d\\n\", b); return 0;&#125; 10.2 将数组名作为实参123456789101112void sum(int *p, int n) &#123; int total = 0; for (int i=0; i&lt;n; i++)&#123; total += *p++; &#125; printf(\"%d\\n\", total); // 6&#125;int main() &#123; int a[3] = &#123;1,2,3&#125;; sum(a, 3); // 将数组名作为实参赋给指针型形参 return 0;&#125; 10.3 “数组名” 做形参12345678910111213// c++ 编译器将形参数组名 作为 指针变量来处理！int sum(int array[], int n)&#123; for (int i=0; i&lt;10-1; i++) &#123; *(array+1) = *array + *(array+1); // 数组从第二项开始，每一项都等于自己加上前一项的和； array++; &#125; return *array;&#125;int main() &#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; printf(\"%d\\n\", sum(a, 10)); return 0;&#125; 当程序里，把一个指针变量或者是数组的名字，传递给一个函数的时候，是挺危险的，因为这个函数拿到的，是这个变量或者是数组的地址， 它拿到了地址，它就可以直接对地址里面存放的这些值，进行肆意的修改，那有没有一种办法，可以呢 使我既能够把这个地址传递给某个函数，又能够确保不让这个函数随意的修改这片地址里面的值呢？ 如何 “限制” 指针的功能 如何“限制”指针实参的功能 10.4 即指向符号常量的指针123456789101112int sum(const int array[], int n)&#123; // 补充为const for (int i=0; i&lt;10-1; i++) &#123; *(array+1) = *array + *(array+1); // array变成常量之后，无法修改 array++; &#125; return *array;&#125;int main() &#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; printf(\"%d\\n\", sum(a, 10)); return 0;&#125; 符号常量声明语句 const 数组类型 常量名 = 常量值； 数据类型 const 常量名 = 常量值； 10.5 指针用作函数返回值函数的返回值可以是多种类型 返回整形数据的函数 int max(int x, int y); 返回指针类型数据的函数 int *min(int x, int y) 函数名字前面表示函数的类型 * 123456789101112// int arr[][4] 除了这么定义，还可以 int *(arr)[4]int *get(int arr[][4], int n, int m) &#123; int *pt; pt = *(arr+n-1) + m-1; return (pt);&#125;int main() &#123; int a[4][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16&#125;; int *p; p = get(a, 2,3); printf(\"%d\\n\", *p);&#125; 分析一下返回结果， 又一个需要注意的深坑 1234567891011int *getInt1() &#123; int value1 = 20; return &amp;value1;&#125;int main() &#123; int *p; p = getInt1(); printf(\"%d\\n\", *p); // 这里会打印未知数，也可能会打印20；为什么呢，因为随着getInt1的运行时完毕，导致它函数内部的所有引用被释放了。所以返回的地址&amp;value1 指向的内存空间被释放掉了；所以谁也不会知道这个地址现在存放的是个啥，如果该块内存没有被新写入值，那么还是20；新写入的话，那就是新的未知量了； return 0;&#125; 验证 1234567891011121314151617int *getInt1() &#123; int value1 = 20; return &amp;value1;&#125;int *getInt2() &#123; int value2 = 30; return &amp;value2;&#125;int main() &#123; int *p, *q; p = getInt1(); q = getInt2(); printf(\"%d\\n\", *p); // 这里大概率会是30 return 0;&#125; 那既然如此，有什么办法解决这个问题 静态局部变量 123456789101112131415161718int *getInt1() &#123; static int value1 = 20; return &amp;value1;&#125;int *getInt2() &#123; static int value2 = 30; return &amp;value2;&#125;int main() &#123; int *p, *q; p = getInt1(); q = getInt2(); printf(\"%d\\n\", *p); // 20 printf(\"%d\\n\", *q); // 30 return 0;&#125; 什么是静态局部变量 ** 静态局部变量 ** 函数中局部变量的值在函数调用结束后不消失而保留原值 即其占用的存储单元不释放，在下一次该函数调用时，仍可以继续使用该变量； 12345678910111213141516171819202122void function() &#123; int a = 0; static int b = 0; // 有点像 hooks，只初始化一次，后续不再重新将其赋值为0； a = a+1; b = b+1; printf(\"%d\\n\", a); printf(\"%d\\n\", b);&#125;int main() &#123; for (int i =3; i&lt;3;i--)&#123; function(); &#125; return 0;&#125;// 1// 1// 1// 2// 1// 3 小结 指针与函数 指针用做函数参数 函数拿到地址可对其所指内容进行修改； 可以使用const来“限制”指针的功能； 指针用做函数返回值 必须确保函数返回的地址是有意义的； 返回全局变量或静态局部变量；24. 指针数组和数组指针11.1 数组指针 归根结底是一个指针，是指向数组的指针。 【存储类型】 数据类型 （*指针名）【下标】 = 值； 如： int (*p)[3]; ---&gt; type name ----&gt; int[3] *p 解析： 定义一个指针变量 p, 用来指向 int[3] 类型的元素的起始位置。原来 int * p 的时候，p+1 的操作是移动一个 int 的大小。如果p的类型 变成了 int [3]的话，p+1的操作是一下移动三个 int 元素的大小。所以数组指针是在某种 大小的数组中进行移动。 12345678910111213141516171819202122232425262728293031323334353637383940int main () &#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i=0, j=0; int *p = *a; int (*q)[N]= a; printf(\"%p %p\\n\", a, a+1); printf(\"%p %p\\n\\n\", q, q+1); for (i =0; i&lt;M; i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%p -&gt; %d\\n\", *(a+i)+j, *(*(a+i)+j)); // printf(\"%p -&gt; %d\\n\", *(q+i)+j, *(*(q+i)+j)); // a 和 q现在是等价的，区别只是一个是常量，一个是变量； &#125; printf(\"\\n\"); &#125; exit(0); &#125;// 0x7ffd6f5ad1f0 0x7ffd6f5ad200// 0x7ffd6f5ad1f0 0x7ffd6f5ad200// 0x7ffd6f5ad1f0 -&gt; 1// 0x7ffd6f5ad1f4 -&gt; 2// 0x7ffd6f5ad1f8 -&gt; 3// 0x7ffd6f5ad1fc -&gt; 4// 0x7ffd6f5ad200 -&gt; 5// 0x7ffd6f5ad204 -&gt; 6// 0x7ffd6f5ad208 -&gt; 7// 0x7ffd6f5ad20c -&gt; 8// 0x7ffd6f5ad210 -&gt; 9// 0x7ffd6f5ad214 -&gt; 10// 0x7ffd6f5ad218 -&gt; 11// 0x7ffd6f5ad21c -&gt; 12 11.2 指针数组 归根结底是一个数组 【存储类型】 数据类型 * 数组名 【长度】 如： int * arr[3]; ---&gt; TYPE NAME ---&gt; int *[3] arr; 11.3 指针数组与数组指针的区别1234567891011121314151617181920212223242526272829int main()&#123; int i, k, j; // 指针数组 char *name[5] = &#123;\"Follow me\", \"Basic\", \"Great\", \"Fortran\", \"Computer\"&#125;; char *tmp; for (i = 0; i &lt; 5 - 1; i++) &#123; k = i; for (j = i + 1; j &lt; 5; j++) &#123; if (strcmp(name[k], name[j]) &gt; 0) &#123; k = j; &#125; &#125; if (k != i) &#123; tmp = name[i]; name[i] = name[k]; name[k] = tmp; &#125; &#125;; for (i = 0; i &lt; 5; i++) &#123; puts(name[i]); &#125;; return 0;&#125; 25 .多级指针 12345Line1 int num = 1;Line2 int *p = &amp;numLine3 int *p1 = p;Line4 int **p2 = &amp;p1;Line5 int ***p3 = &amp;p2; 多级指针的本质，只是C语言的一个书写规范，事实上任何指针都可以保存任何地址； 多级指针的存储的值的推理过程 12345Line1 int num = 1;Line2 int *p = &amp;numLine3 int *p1 = p;Line4 int **p2 = &amp;p1;Line5 int ***p3 = &amp;p2; 函数 函数的定义 函数的传参 函数的调用 （嵌套和递归） 函数与数组 函数与指针 （指针函数， 函数指针， 函数指针数组） 26. 函数的定义 数据类型 函数名 （【数据类型 形参名 。。。】） 函数的类型是指 函数的返回值的数据类型 1.1.1 main函数1234567891011121314/** argc： 参数计数器，统计终端上多少个参数传进来 *argv[]： 列表，用来传递刚才命令行传递进来的参数 *argv[]是一个数组； argv 是数组名； char* 指数组中每个元素的类型为 char*；即字符指针 argv 即字符数组指针的首地址；*/int main(int argc, char *argv[]);&#123; printf(\"argc=%d\\n\", argc); exit(0);&#125; 12./main /etc/a*.conf# 4 因为shell 会自动解析通配符，把结果都解析出来。 图示：char * argv 数组模型 ** 输出argv** 12345678int main (int argc, char * argv[]) &#123; int i; // for (i=0; i&lt;argc; i++) for (i=0; argv[i] !=NULL; i++) puts(argv[i]); exit(0);&#125; 1.1.2 C语言使用函数之前也需要先声明 函数在使用前都要声明，除非被调用函数的定义部分已经出现在主调函数之前, 在C语言中，函数声明就是函数原型。 123456789101112#include &lt;stdio.h&gt;void printf_hello(void);// 需要先声明，因为main函数在 printf_hello函数上面int main ()&#123; printf_hello(); return 0;&#125;void printf_hello(void)&#123; printf(\"hello world!\\n\"); return;&#125; 27. 函数的传参1.2.1 值传递12345678910int printf_value(int i, int j) &#123; // 参数i j 随着 print_value 调用栈执行结束就释放掉了。 printf(\"%d%d\\n\", i,l); return 0;&#125;int main() &#123; int i =3; l = 5; printf_value(i,l); return 0;&#125; 1.2.2 地址传递123456789101112int swap (int * i, int * j) &#123; int tmp; tmp = *i; *i = *j; *j = tmp;&#125;int main() &#123; int i =3; l = 5; swap(&amp;i,&amp;l); return 0;&#125; 28. 函数的调用（嵌套调用 和 递归调用）1.3.1 函数的调用方式 函数调用作为独立语句，stringPrint(); 函数作为表达式的一部分,number = max(numA,numB)/2; 以实参形式出现在其他函数的调用中,number = min(sum(-5, 100), numC); 1.3.2 嵌套调用123456789101112131415161718int minus(int a, int b, int c) &#123; return max(a,b,c) - min(a, b, c);&#125;int min(int a, int b, int c) &#123; int tmp = a &lt; b? a :b; return tmp &lt; c ? tmp : c;&#125;int max(int a, int b, int c) &#123; int tmp = a &gt; b? a :b; return tmp &gt; c ? tmp : c;&#125;int main () &#123; int result; int a = 3, b = 5, c = 10; result = minus(a,b,c); printf(\"%d\\n\", result); return 0;&#125; 39. 函数与数组1.4.1 函数与一唯数组问题：封装一个printf_arr方法来遍历数组；应该如何定义 printf_arr 的行参 12345678910111213141516171819202122int printf_arr(int a[])&#123; int i = 0; printf(\"printf_arr ---&gt; %p\\n\", a); // 传入的是 数组 a的 起始地址； for (i=0; i&lt;sizeof(a)/sizeof(a[0]); i++) // 是因为 a的 sizeof为 8， 所以只能访问数组前2位 &#123; printf(\"%d \",a[i]); // 1， 2 &#125; printf(\"\\n\");&#125;int main()&#123; int a[6] = &#123;1,2,3,4,5,6&#125;; printf(\"main ---&gt; %p\\n\",a ); // a 即 &amp;a, 即 &amp;a[0]; printf_arr(a); exit(0);&#125;// main ---&gt; 0x7ffd84a62eb0// printf_arr ---&gt; 0x7ffd84a62eb0 1234567891011void print_arr(int *p)&#123; int i; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(p));// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置&#125;int main()&#123; int a[] = &#123;1,3,5,7,9&#125;; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(a)); // 20，整个数组所占内存的大小，因为每个int是 4个字节； print_arr(a);&#125; ** 解决方法** 将数组的长度，当做第二个参数传入给 子函数。 1234567891011121314void print_arr(int *p, int n)&#123; int i; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(p));// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置 for (i=0; i&lt;n; i++) printf(\"%d\\n\", p[i]); // p[i] 与 *(p+i) 等价 printf(\"\\n\");&#125;int main()&#123; int a[] = &#123;1,3,5,7,9&#125;; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(a)); // 20，整个数组所占内存的大小，因为每个int是 4个字节； print_arr(a, sizeof(a)/sizeof(*a));&#125; 12void printf_arr(int p[], int n);// 当 p[] 作为行参时， [] 等同于 * 因此 int p[] 即为 int *p ** 示例** 12345678910111213int main() &#123; int a[N] = &#123;1,2,3,4,5,6&#125;; int *p = a; a -&gt; int * *a即*(a+0) -&gt; int a[0] -&gt; int &amp;a[3] -&gt; int * p[i] -&gt; int p -&gt; int * *p -&gt; int p+1 -&gt; int *&#125; ** 逆序** 12345678910111213141516171819202122void func(int *p, int n) &#123; int i=0, j, m, tmp; m = (n -1)/2; for (;i&lt;=m;i++) &#123; j = n -1 -i; tmp = p[i]; p[i] = p[j]; p[j] = tmp; &#125;&#125;;int main() &#123; int a[0] = &#123;1,3,5,7,9&#125;; for (i =0; i&lt; sizeof(a)/sizeof(*a); i++) printf(\"%d\\n\", a[i]); printf(\"\\n\"); func(a, sizeof(a)/sizeof(*a)); for (i =0; i&lt; sizeof(a)/sizeof(*a); i++) printf(\"%d\\n\", a[i]); printf(\"\\n\"); return 0;&#125; 1.4.2 函数与二维数组12345678910111213141516171819 int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; int i = 0; int j = 0; for (i = 0; i&lt; M; i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%d \", a[i][j]); &#125; printf(\"\\n\"); &#125; exit(0); &#125;// 1 2 3// 4 5 6 问题： 同样的把输出放到一个独立的函数中去，也就是考察一下 二维数组应该如何给函数传参 这个问题实际考察点在于 二维数组如何 过实参给函数，以及函数的二维数组行参应该如何定义 1234567891011121314151617181920212223// 第一种, 用一个二维数组的指针去接收int arr_traverse(int (*p) [N], int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;n;i++) &#123; printf(\"%d \",*(*p+i)); // 关键点在这里， 首先 p 指向的是 int [3] 这个类型。所以需要降级 为列指针 &#125;; printf(\"\\n\"); &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M*N); // *a === a[0] === *(a+0) exit(0); &#125; 1234567891011121314151617181920212223// 第二种，用一个普通一维数组指针去接收int arr_traverse(int *p, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;n;i++) &#123; printf(\"%d \",*(p+i)); &#125;; printf(\"\\n\"); &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(&amp;a[0][0], M*N); // 传递的是列指针 exit(0); &#125; 12345678910111213141516171819202122232425262728// 第三种 void arr_traverse(int (*p)[N],int m, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;m;i++) &#123; for (j=0; j&lt;n;j++) &#123; printf(\"%d \",*(*(p+i)+j)); &#125; &#125;; printf(\"\\n\"); return; &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M,N); exit(0); &#125; 1234567891011121314151617181920212223242526// 第四种void arr_traverse(int p[][N],int m, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;m;i++) &#123; for (j=0; j&lt;n;j++) &#123; printf(\"%d \", p[i][j]); &#125; &#125;; printf(\"\\n\"); return; &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M,N); exit(0); &#125; ** 小结 ** 123int a[M][N] = &#123;...&#125;;int * p = *a;int (*q)[N] = a; 二维数组 参与传参的一些基本内容 a[i][j] *(a+i)+j a[i]+j p[i] *p q[i][j] *q === *(q+0) q p+3 q+2 int int * int * int int int int * int (*)[N] int * int (*)[N] 1.4.2.1 示例： 求平均数1234567891011121314151617181920212223242526float average_score(int *p, int n)&#123; int i; float sum = 0; for (i=0; i&lt;n; i++) &#123; sum += p[i]; &#125; return sum/n;&#125;find_num(int (*p)[N], int num)&#123; int i = 0; for (i =0; i&lt;N; i++) &#123; printf(\"%d\\n\", *(*(p+num)+i)); &#125;&#125;int main ()&#123; int num = 1; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; average_score(*a, M*N); find_num(a, num);&#125; 1.4.2.2 二维数组什么时候传行指针，什么时候传列指针 当不区分行列的时候，可以把它当作一个大的一维数组。那就传递指针。 如果要区分行列来做某件事情的时候，那就需要把行指针传递过去。 1.4.3 函数与字符数组1234567int main () &#123; char str1[] = \"helloworld\"; char str2[128]; strcpy(str2, str1); //实现了拷贝 exit(0);&#125; 123456789101112131415//实现一个 mystrcpy 用于拷贝char * mystrcpy(char * dest, const char * src) &#123; char *ret = dest; if (dest != NULL &amp;&amp; src != NULL) while((*dest++ = *src++) != '\\n'); return ret;&#125;int main () &#123; char str1[] = \"helloworld\"; char str2[128]; mystrcpy(str2, str1); //实现一个 mystrcpy 用于拷贝 puts(str2); // 测试一下 exit(0);&#125; 123456789101112131415161718//实现一个 mystrncpy 用于拷贝char * mystrncpy(char *dest, const char * src, size_t n) &#123; int i=0; for (; i&lt;n &amp;&amp; (dest[i] = src[i]); i++) ; for (; i&lt;n; i++) dest[i] = '\\0'; return dest;&#125;int main () &#123; char str1[] = \"helloworld\"; char str2[128]; mystrncpy(str2, str1, 5); //实现一个 mystrcpy 用于拷贝 puts(str2); // 测试一下 exit(0);&#125; 30. 函数与指针 指针函数, 函数指针, 函数指针数组 1.5.1 指针函数 一个函数的返回值为指针，即为指针函数 返回值 * 函数名(形参);如： int * fun(int); 引子 123456789101112131415161718// 从find_num 这个函数说起，这个函数并不纯，而且没有实现它的功能；void find_num(int (*p)[N], int num)&#123; int i; for(i=0;i&lt;N;i++) &#123; printf(\"%d\", *(*(p+num)+i)); &#125; printf(\"\\n\");&#125;int main()&#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; float ave; int num = 0; find_num(a, num); // find_num 的设计不应该没有返回值；&#125; 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3#define N 4int * find_num(int (*p)[N], int num) // 将find_num 设计成为一个指针函数&#123; if (num &gt; M -1) return NULL; return *(p+num);&#125;int main()&#123; int i, j; int * res; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; float ave; int num =0; res = find_num(a, num); if (res != NULL) &#123; for (i=0;i&lt;N;i++) printf(\"%d\",res[i]); printf(\"\\n\"); &#125; else &#123; printf(\"can not find\\n\"); &#125;&#125;; 1.5.2 函数指针 一个指针指向的是函数， 在C语言里面。你并不能用一个普通变量去接收 函数啊，或者结构体等等数据类型，必须要使用相同的类型变量去接收相同的类型。比如函数要用函数指针变量去接收； 类型 (指针名) （形参） 如： int (p)(int); 123456789101112131415int add (int a, int b)&#123; return a+b;&#125;int main()&#123; int a=3, b=5; int ret; int (*p)(int, int); // 定义一个函数指针 p = add; // 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址， 也可以写成 p = &amp;add;这里之所以省略，是因为函数名(add)本身就是一个地址。所以在指针和函数的指向关系当中，地址符可以省略。同样的 `ret = *p(a, b)`； p前面的 *也可以省略。 `ret = p(a, b)`。指向函数的指针，让这个指针指向某一个函数的入口地址。下面通过指针来传参数就如同通过函数名来传参数是一样的； ret = p(a, b); printf(\"%d\\n\",ret); exit(0);&#125; 1.5.3 函数指针数组引子 12345678910111213141516171819202122int add (int a, int b)&#123; return a+b;&#125;int sub (int a, int b)&#123; return a*b;&#125;int main()&#123; int a=3, b=5; int ret1, ret2; int (*p)(int, int); // 定义一个函数指针 int (*q)(int, int); // 这里面定义两个相同的 函数指针有点浪费 p = add; // 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址 ret1 = p(a, b); ret2 = q(a, b); printf(\"%d\\n\",ret1); printf(\"%d\\n\",ret2; exit(0);&#125; 1.5.4 引出函数指针数组语法： 类型 （数组名[下标]）（形参）；如: int (arr[N])(int);arr是一个数组，这个数组有N个元素。这N个元素都是指向函数的指针。 1234567891011121314151617181920212223242526int main()&#123; int a=3, b=5; int ret1, ret2; int i; // int (int, int) *funcp[2]; funcp这个数组有两个指针，两个指针都是指向 int (int, int) 类型的函数； 转换一种写法就是 int (*funcp[2])(int, int); // p = add; // q = sub; // ret1 = p(a, b); // ret2 = q(a, b); funcp[0] = add; funcp[1] = sub; for (i=0; i&lt;2; i++) &#123; ret1 = funcp[i](a, b); printf(\"%d\\n\",ret1); &#125; // printf(\"%d\\n\",ret1); // printf(\"%d\\n\",ret2; exit(0);&#125; 1.5.5 指向指针函数的函数指针数组 int *(*func[N])(int) 31. 函数的执行过程1.6.1 main函数 —— 函数执行的入口 遇到函数，开辟内存空间； 在内存空间再碰到函数时候， 初始化内嵌函数； 传递参数 保存外层函数执行空间 执行完毕后。。。。释放函数执行栈 接收函数的返回值 恢复现场，从断点处继续执行 1.6.2 参数的传递 实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”。即拷贝 函数调用时，系统给行参分配存储单元，并将实参对应的值传递给形参； P.S. 实参与形参的类型必须相同或可以兼容； 1.6.3 变量的作用范围局部变量与全局变量 根据变量在程序中作用范围的不同，可以将变量分为局部变量和全局变量 局部变量在函数内或块内定义，只在这个函数或块内其作用的变量； 全局变量在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。 当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量 32. 数组与函数 数组名 做函数参数 1234567891011void change(int a[]) &#123; a[0] = 30; a[1] = 50;&#125;int main() &#123; int a[2] = &#123;3, 5&#125;; change(a); // 地址传递， 数组的名字代表着数组所在的地址； printf(\"%d, %d,\", a[0], a[1]); // 30 50 return 0&#125; 33. 缓冲区1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; // __FUNCTION__ 当前所在的函数， // __LINE__ 当前所在的行数 printf(\"[%s:%d]before\", __FUNCTION__, __LINE__); while(1); printf(\"[%s:%d]after\", __FUNCTION__, __LINE__); exit(0);&#125;./printf// 发现两个printf都没打印出来东西 ** 缓冲机制 ** 由于使用了终端设备，所以原本默认是全缓冲模式变成了行缓冲模式。所以printf是遇到了 \\n 才去刷新缓冲区的。或者是当前等缓冲区满了去自动刷新。\\n 是去强制刷新缓冲区。 没有加\\n 那个“before”这句话就放到了输出缓冲区当中，什么时候刷新呢？ 要么等程序结束自动刷新IO，要么就是遇到一些强制刷新的函数iflush 这种，要么就等到缓冲区攒满了一次性去刷新。 34. 动态内存管理 在编写程序时，通常并不知道需要处理的数据量，或者难以评估所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，就需要动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存管理原理； 以下几个函数都存在标准 stdlib.h 中 1.9.1 malloc calloc （分配新的内存区域）void *malloc(size_t, size); 它会在堆上分配这块连续的内存空间，并返回起始地址； void *calloc(size_t nmemb, size_t size) 一个成员 size个大小，nmemb这么多成员的空间；连续申请多块 size大的内存 1234567891011121314int *p;p = malloc(sizeof(int));if (p == NULL)&#123; printf(\"error\");&#125;else&#123; *p = 10; printf(\"%d\\n\", *p);&#125;;free(p); // 用完记得释放掉内存， 在同一个函数中做到 malloc 和 free一一对应printf(\"%d\\n\", *p);exit(0); 12345678910111213int *p;int num = 5;p = malloc(sizeof(int) * num);for (int i= 0 ;i&lt;num; i++) &#123; scanf(\"%d\", &amp;p[i]);&#125;for (int j=0; j&lt;num; j++) &#123; printf(\"%d \", p[j]);&#125;printf(\"\\n\");free(p);exit(0); *一道面试题 (提示： 这个程序当中已经产生了内存泄漏) * 12345678910111213141516void func(int *p, int n) &#123; p = malloc(n); if (p == NULL) exit(1); // p在这个函数当中是一个局部变量，随着func执行完毕之后，这块内存空间会丢失。导致内存泄漏，只有随着操作系统中这个进程结束掉，才会释放这100个单位的内存 return;&#125;int main()&#123; int num = 100; int *p = NULL; func(p, num); free(p); exit(0);&#125; 改法一： 12345678910111213141516void func(int **p, int n) &#123; // 用一个二级指针来接受 *p = malloc(n); // 此时*p 就是main函数中的p if (*p == NULL) exit(1); return;&#125;int main()&#123; int num = 100; int *p = NULL; func(&amp;p, num); free(p); exit(0);&#125; 改法二： 123456789101112131415161718void func(int *p, int n)&#123; p = malloc(n); if (p == NULL) exit(1); return p;&#125;int main()&#123; int num = 100; int *p = NULL; p = func(p, num); // 用p 来接触返回值 free(p); exit(0);&#125; 1.9.2 realloc （调整已分配的内存区域）void *realloc(void *ptr, size_t size); 重新分配一块动态的内存空间 ,比如之前用malloc calloc分配的内存空间太大或者太小，现在把 起始地址传进去(第一个参数); 然后要size 大小的这么一段(第二个参数)；所以 realloc会在当前地址往下继续扩展，凑足size返回回来；当然，如果*ptr 开始的这个区段，没有一整块size大小的空间，那么就会去别的内存上面去寻找。直到找到之后，再返回那块空间的起始地址回来； 1.9.3 free （释放已分配的内存区域） 原则， 谁申请谁释放， （防止内存泄露）；如果不能做到在同一函数中做到谁申请谁释放 就在同一模块中做到这些； 123456789101112131415161718int *p;int num = 10;p = malloc(sizeof(int));if (p == NULL)&#123; exit(1);&#125;;*p = 10;printf(\"%d\\n\", *p); // 10// 测试地址printf(\"%p--&gt;%d\\n\", *p); // 0xa--&gt;0free(p); // 正确的做法是p = NULL; // 正确的做法是，一个指针free了之后，立即赋值 NULL// free 代表着 变量p对于那片 内存空间 没有了 控制权限；所以free之后要 p = NULL*p = 123; // 实际上这是个野指针，该块内存释放掉了，有可能被其他人用来声明变量了。这里重新赋值，相当于可能把别人的变量给覆盖了printf(\"%d\\n\", *p); // 123 // 测试地址printf(\"%p--&gt;%d\\n\", *p); // 0x7b--&gt;145574408","categories":[{"name":"language","slug":"language","permalink":"http://yoursite.com/categories/language/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"ts declaration files","slug":"ts-declaration-files","date":"2021-01-21T03:16:49.000Z","updated":"2021-02-09T10:28:11.416Z","comments":true,"path":"2021/01/21/ts-declaration-files/","link":"","permalink":"http://yoursite.com/2021/01/21/ts-declaration-files/","excerpt":"","text":"10. Declaration Files10. 1 Declaration Reference本节显示一些API的文档以及该API的示例用法，并说明如何编写相应的声明。 10.1.1 具有属性的对象12345// codelet result = myLib.makeGreeting(\"hello, world\");console.log(\"The computed greeting is:\" + result);let count = myLib.numberOfGreetings; 12345// 声明declare namespace myLib &#123; function makeGreeting(s: string): string, let numberOfGreetings: number;&#125; 10.1.2 Overloaded Functions1234567// code let x : Widget = getWidget(43);let arr: Widget[] = getWidget(\"all of them\");// 声明declare function getWidget(n: number): Widget;declare function getWidget(s: string): Widget[]; 10.1.3 Reusable Types (Interfaces)1234567891011121314// codegreet(&#123; greeting: \"hello world\", duration: 4000&#125;);// 声明interface GreetingSettings &#123; greeting: string; duration?: number; color?: string;&#125;declare function greet(setting: GreetingSettings): void; 10.1.4 Reusable Types (Type Aliases)12345678910111213// code function getGreeting() &#123; return \"howdy\";&#125;class MyGreeter extends Greeter &#123;&#125;greet(\"hello\");greet(getGreeting);greet(new MyGreeter());// 声明// 使用类型别名来简化类型：type GreetingLike = string | (()=&gt; string) | MyGreeter;declare function greet(g: GreetingLike): void; 10.1.5 组织类型1234567891011121314151617181920212223242526272829// codeconst g = new Greeter(\"Hello\");g.log(&#123; verbose: true &#125;);g.alert(&#123; modal: false, title: \"Current Greeting\" &#125;);// 声明// 使用命名空间去组织类型declare namespace GreetingLib &#123; interface LogOptions &#123; verbose?: boolean; &#125; interface AlertOptions &#123; modal: boolean; title?: string; color?: string; &#125;&#125; // 使用嵌套的命名空间来声明declare namespace GreetingLib.Options &#123; // Refer to via GreetingLib.Options.Log interface Log &#123; verbose?: boolean; &#125; interface Alert &#123; modal: boolean; title?: string; color?: string; &#125;&#125; 10.1.6 Classes1234567891011121314151617// codeconst myGreeter = new Greeter(\"hello, world\");myGreeter.greeting = \"howdy\";myGreeter.showGreeting();class SpecialGreeter extends Greeter &#123; constructor() &#123; super(\"Very special greetings\"); &#125;&#125;// 声明// 使用 declare class 来描述类或类对象。类可以具有属性和方法以及构造函数。declare class Greeter &#123; constructor(greeting: string); greeting: string; showGreeting(): void;&#125; 10.1.7 Global Variables1234// codeconsole.log(f00/2);// 声明declare var foo: number 10.1.8 Global Functions1234// codegreet(\"hello\");// 声明declare function greet(str: string):void; 10.2 Library Structures针对不同类型的库，编写对应类型的声明文件。你是通过cdn获取这些库还是通过npm获取；你是require引入还是import引入； 10.2.1 模块化的库几乎每个现代的Node.js库都属于模块家族。这些类型的库仅在带有模块加载器的JS环境中工作。例如，express仅在Node.js中有效，并且必须使用CommonJS require函数加载。 12345var fs = require(\"fs\");import * as fs from \"fs\";var someLib = require(\"someLib\");define(..., ['someLib'], function(someLib) &#123;&#125;); 从代码中识别模块库 Unconditional calls to require or define Declarations like import * as a from &#39;b&#39;; or export c; Assignments to exports or module.exports They will rarely have: Assignments to properties of window or global 10.2.1.1 Modules.d.ts 常见的Commonjs 模式 123456789101112131415const maxInterval = 12;function getArrayLength(arr) &#123; return arr.length;&#125;module.exports = &#123; getArrayLength, maxInterval,&#125;;// This can be described by the following .d.ts:export function getArrayLength(arr: any[]): number;export const maxInterval: 12; Es module 1234567export function getArrayLength(arr) &#123; return arr.length;&#125;// This would have the following .d.ts equivalent:export function getArrayLength(arr: any[]): number; Default Exports 12345// codemodule.exports = /hello( world)?/;// .d.tsdeclare const helloWorld: RegExp;export default helloWorld; CommonJS中的一种导出样式是导出函数。由于函数也是对象，因此可以在导出中添加额外的字段。 1234567891011function getArrayLength(arr) &#123; return arr.slice;&#125;getArrayLength.maxInterval = 12;module.exports = getArrayLength;// Which can be described with:export default function getArrayLength(arr: any[]): number;export const maxInterval: 12;// 需要在 tsconfig.json 中设置 esModuleInterop: true 如果没有在 tsconfig.json 中设置 esModuleInterop: true 123456declare function getArrayLength(arr: any[]): number;declare namespace getArrayLength &#123; declare const maxInterval: 12;&#125;// 使用 export= 语法export = getArrayLength; 模块中的类型 可能需要提供一种不存在的JavaScript代码类型 123456789101112131415161718192021222324252627// code function getArrayMetadata(arr) &#123; return &#123; length: getArrayLength(arr), firstObject: arr[0], &#125;;&#125;module.exports = &#123; getArrayMetadata,&#125;;// describedexport type ArrayMetadata = &#123; length: number; firstObject: any | undefined;&#125;export function getArrayMetadata(arr: any[]):ArrayMetadata;// 泛型优化版export type ArrayMetadata&lt;ArrType&gt; = &#123; length: number; firstObject: ArrType | undefined;&#125;;export function getArrayMetadata&lt;ArrType&gt;( arr: ArrType[]): ArrayMetadata&lt;ArrType&gt;; Namespaces in Module Code 试图描述JavaScript运行时的关联可能很棘手。如果类似ES模块的语法没有提供足够的工具来描述导出，则可以使用名称空间。 您可能有足够复杂的类型来描述，因此您选择在.d.ts中对它们进行命名空间： 123456789101112131415161718// 运行时可用的JavaScript类export class API &#123; constructor(baseURL: string); getInfo(opts: API.InfoRequest): API.InfoResponse;&#125;// This namespace is merged with the API class and allows for consumers, and this file// to have types which are nested away in their own sections.declare namespace API &#123; export interface InfoRequest &#123; id: string; &#125; export interface InfoResponse &#123; width: number; height: number; &#125;&#125; 您可以使用export as namespace声明模块将在UMD上下文中的全局范围内可用 1export as namespaces moduleName; Template 为了让您了解所有这些部分如何组合在一起，这里是制作新模块时的参考.d.ts。 1234567891011121314151617181920212223242526272829// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*如果此模块是在模块加载程序环境之外加载时公开全局变量“ myLib”的UMD模块，请在此处声明该全局变量。否则，删除此声明。 */export as namespace myLib;/*~ If this module exports functions, declare them like so. */export function myFunction(a: string): string;export function myOtherFunction(a: number): number;/*~ You can declare types that are available via importing the module */export interface SomeType &#123; name: string; length: number; extras?: string[];&#125;/*~ You can declare properties of the module using const, let, or var */export const myField: number; 库文件布局 123456myLib +---- index.js +---- foo.js +---- bar +---- index.js +---- baz.js 声明文件布局应为 123456@types&#x2F;myLib +---- index.d.ts +---- foo.d.ts +---- bar +---- index.d.ts +---- baz.d.ts 12345// thest could be imported asvar a = require(\"myLib\");var b = require(\"myLib/foo\");var c = require(\"myLib/bar\");var d = require(\"myLib/bar/baz\"); Testing your types If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you: Create a new folder in node_modules/@types/[libname] Create an index.d.ts in that folder, and copy the example in See where your usage of the module breaks, and start to fill out the index.d.ts When you’re happy, clone DefinitelyTyped/DefinitelyTyped and follow the instructions in the README. Otherwise Create a new file in the root of your source tree: [libname].d.ts Add declare module &quot;[libname]&quot; { } Add the template inside the braces of the declare module, and see where your usage breaks 10.2.1.2 module:function1234import greeter from \"super-greeter\";greeter(2);greeter(\"Hello world\"); 如果模块可以像一个函数一样被调用，需使用module-function 模版 要同时通过UMD和模块引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for function modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' */// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style:// import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import:// import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myFuncLib;/*~ This declaration specifies that the function *~ is the exported object from the file */export = Greeter;/*~ This example shows how to have multiple overloads for your function */declare function Greeter(name: string): Greeter.NamedReturnType;declare function Greeter(length: number): Greeter.LengthReturnType;/*~ If you want to expose types from your module as well, you can *~ place them in this block. Often you will want to describe the *~ shape of the return type of the function; that type should *~ be declared in here, as this example shows. *~ *~ Note that if you decide to include this namespace, the module can be *~ incorrectly imported as a namespace object, unless *~ --esModuleInterop is turned on: *~ import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS! */declare namespace Greeter &#123; export interface LengthReturnType &#123; width: number; height: number; &#125; export interface NamedReturnType &#123; firstName: string; lastName: string; &#125; /*~ If the module also has properties, declare them here. For example, *~ this declaration says that this code is legal: *~ import f = require('super-greeter'); *~ console.log(f.defaultName); */ export const defaultName: string; export let defaultLength: number;&#125; 10.2.1.2 module:class1234const Greeter = require(\"super-greeter\");const greeter = new Greeter();greeter.greet(); 如果导出的对象是一个类的话； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for class modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' */// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style:// import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import:// import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myClassLib' when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myClassLib;/*~ This declaration specifies that the class constructor function *~ is the exported object from the file */export = MyClass;/*~ Write your module's methods and properties in this class */declare class MyClass &#123; constructor(customGreeting?: string); greet: void; myMethod(opts: MyClass.MyClassMethodOptions): number;&#125;/*~ If you want to expose types from your module as well, you can *~ place them in this block. *~ *~ Note that if you decide to include this namespace, the module can be *~ incorrectly imported as a namespace object, unless *~ --esModuleInterop is turned on: *~ import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS! */declare namespace MyClass &#123; export interface MyClassMethodOptions &#123; width?: number; height?: number; &#125;&#125; 10.2.1.3 Module: pluginIf you have a module which when imported, makes changes to other modules use template 12const jest = require('jest');require(\"jest-matchers-files\"); when you want to work with JavaScript code which extends another library. 123456789import &#123; greeter &#125; from \"super-greeter\";// Normal Greeter APIgreeter(2);greeter(\"Hello world\");// Now we extend the object with a new function at runtimeimport \"hyper-super-greeter\";greeter.hyperGreet(); The definition for “super-greeter” 12345678/*~ This example shows how to have 多个重载 for your function */export interface GreeterFunction &#123; (name: string): void (time: number): void&#125;/*~ This example shows how to export 一个接口指定的function */export const greeter: GreeterFunction; We can extend the existing module like the following: 12345678910111213141516171819202122// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module plugin template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*~ On this line, import the module which this module adds to */import &#123; greeter &#125; from \"super-greeter\";/*~ Here, declare the same module as the one you imported above *~ then we expand the existing declaration of the greeter function */export module \"super-greeter\" &#123; export interface GreeterFunction &#123; /** Greets even better! */ hyperGreet(): void; &#125;&#125; 10.2.2 Global Libraries全局库是可以从全局范围访问的库（即，无需使用任何形式的导入）。许多库只是公开一个或多个全局变量供使用。例如jquery; 123$(() =&gt; &#123; console.log(\"hello\");&#125;) 12&lt;!--一般情况，全局库的使用方式 --&gt;&lt;script src=\"http://a.great.cdn.for/someLib.js\"&gt;&lt;/script&gt; 现在，最流行的可全局库 实际上是作为 UMD标准 编写的（请参见下文）。 UMD库文档很难与全局库文档区分开。在编写全局声明文件之前，请确保该库不是UMD。 从代码中识别Global Library 查看全局库的代码时，通常会看到： Top-level var statements or function declarations One or more assignments to window.someName Assumptions that DOM primitives like document or window exist You won’t see: Checks for, or usage of, module loaders like require or define CommonJS/Node.js-style imports of the form var fs = require(&quot;fs&quot;); Calls to define(...) Documentation describing how to require or import the library 10.2.2.1 Global.d.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ If this library is callable (e.g. can be invoked as myLib(3)), *~ include those call signatures here. *~ Otherwise, delete this section. */declare function myLib(a: string): string;declare function myLib(a: number): number;/*~ If you want the name of this library to be a valid type name, *~ you can do so here. *~ *~ For example, this allows us to write 'var x: myLib'; *~ Be sure this actually makes sense! If it doesn't, just *~ delete this declaration and add types inside the namespace below. */interface myLib &#123; name: string; length: number; extras?: string[];&#125;/*~ If your library has properties exposed on a global variable, *~ place them here. *~ You should also place types (interfaces and type alias) here. */declare namespace myLib &#123; //~ We can write 'myLib.timeout = 50;' let timeout: number; //~ We can access 'myLib.version', but not change it const version: string; //~ There's some class we can create via 'let c = new myLib.Cat(42)' //~ Or reference e.g. 'function f(c: myLib.Cat) &#123; ... &#125; class Cat &#123; constructor(n: number); //~ We can read 'c.age' from a 'Cat' instance readonly age: number; //~ We can invoke 'c.purr()' from a 'Cat' instance purr(): void; &#125; //~ We can declare a variable as //~ 'var s: myLib.CatSettings = &#123; weight: 5, name: \"Maru\" &#125;;' interface CatSettings &#123; weight: number; name: string; tailLength?: number; &#125; //~ We can write 'const v: myLib.VetID = 42;' //~ or 'const v: myLib.VetID = \"bob\";' type VetID = string | number; //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);' function checkCat(c: Cat, s?: VetID);&#125; 10.2.2.2 Global: Modifying Module导入全局变量的模块会在全局范围内更改现有值。例如，可能存在一个库，该库在导入时将新成员添加到String.prototype。由于存在运行时冲突的可能性，该模式有些危险，但是我们仍然可以为其编写声明文件。 识别全局修改模块 全局修改模块通常易于从其文档中识别，它们类似全局插件，但是需要require方法的调用 才能激活它们的副作用； 123456789101112// 'require' call that doesn't use its return valuevar unused = require(\"magic-string-time\");/* or */require(\"magic-string-time\");var x = \"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());var y = [1, 2, 3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort()); 123456789101112131415161718192021222324252627282930313233// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the global-modifying module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*~ Note: If your global-modifying module is callable or constructable, you'll *~ need to combine the patterns here with those in the module-class or module-function *~ template files */declare global &#123; /*~ Here, declare things that go in the global namespace, or augment *~ existing declarations in the global namespace */ interface String &#123; fancyFormat(opts: StringFormatOptions): string; &#125;&#125;/*~ If your module exports types or values, write them as usual */export interface StringFormatOptions &#123; fancinessLevel: number;&#125;/*~ For example, declaring a method on the module (in addition to its global side effects) */export function doSomething(): void;/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */export &#123;&#125;; 10.2.3 UMDUMD模块既可以用作模块（通过import），也可以用作全局模块（在没有模块加载器的环境中运行时）。这样编写了许多流行的库，例如Moment.js。 1234// nodejs 环境下import moment = require('moment');// 浏览器环境下console.log(mement.format()); umd模版 12345678910111213141516(function (root, factory) &#123; if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define([\"libName\"], factory); &#125; else if (typeof module === \"object\" &amp;&amp; module.exports) &#123; module.exports = factory(require(\"libName\")); &#125; else &#123; root.returnExports = factory(root.libName); &#125;&#125;(typeof self !== 'undefined' ? self : this, function (b) &#123; // Use b in some fashion. // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;)); UMD库的文档通常还会演示一个显示require的“在Node.js中使用”示例，以及一个使用script标记加载该脚本的“在浏览器中使用”示例。 10.2.4 Consuming Dependencies你的库可能具有集中依赖关系，下面会说明如何将它们导入声明文件； Dependencies on Global Libraries If your library depends on a global library, use a /// &lt;reference types=&quot;...&quot; /&gt; directive: 123/// &lt;reference types=\"someLib\" /&gt;function getThing(): someLib.thing; Dependencies on Modules If your library depends on a module, use an import statement: 123import * as moment from \"moment\";function getThing(): moment; Dependencies on UMD libraries From a Global Library If your global library depends on a UMD module, use a /// &lt;reference types directive: 123/// &lt;reference types=\"moment\" /&gt;function getThing(): moment; From a Module or UMD Library If your module or UMD library depends on a UMD library, use an import statement: 1import * as someLib from \"someLib\"; Do not use a /// &lt;reference directive 来声明对UMD库的依赖！ 10.2.5 Preventing Name Conflicts编写全局声明文件时，可以在全局范围内定义许多类型。强烈不建议这样做，因为当项目中有许多声明文件时，它可能导致无法解决的名称冲突。 库定义的任何全局变量只声明 namespaces 12345678declare namespace cats &#123; interface KittySettings &#123;&#125;&#125; // But not // at top-level interface CatsKittySettings&#123;&#125; This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users. 10.3 Do’s and Don’ts10.3.1 基本类型不要使用Number,String,Boolean, Symbol, or Object 等类型； 10.3.2 anyany类型你懂得，尽量别用。anyScript毫无意义； 10.3.3 Callback Types对于返回值被忽略的回调，别使用any, 使用void更好； 12345678/* WRONG */function fn(x: () =&gt; any) &#123; x();&#125;/* OK */function fn(x: () =&gt; void) &#123; x();&#125; 10.3.4 重载和回调函数不要编写仅在回调函数上有所不同的单独重载： 12345678910111213/* WRONG */declare function beforeAll(action: () =&gt; void, timeout?: number): void;declare function beforeAll( action: (done: DoneFn) =&gt; void, timeout?: number): void;// ok// Do write a single overload using the maximum arity:declare function beforeAll( action: (done: DoneFn) =&gt; void, timeout?: number): void; 原因：回调忽略参数始终是合法的，因此不需要较短的重载。首先提供一个较短的回调允许输入错误类型的函数，因为它们与第一个重载匹配。 10.3.5 function 重载不要在更具体的重载之前放置更一般的重载； 1234567891011121314151617/* WRONG */declare function fn(x: any): any;declare function fn(x: HTMLElement): number;declare function fn(x: HTMLDivElement): string;var myElem: HTMLDivElement;var x = fn(myElem); // x: any, wat?// 通过将更一般的签名放在更具体的签名之后来对重载进行排序/* OK */declare function fn(x: HTMLDivElement): string;declare function fn(x: HTMLElement): number;declare function fn(x: any): any;var myElem: HTMLDivElement;var x = fn(myElem); // x: string, :) 原因：TypeScript在解决函数调用时选择第一个匹配的重载。当较早的过载比较晚的过载“更普遍”时，较晚的过载实际上是隐藏的，无法调用。 10.3.6 Use Optional Parameters不要写一些仅在尾随参数上有所不同的重载 1234567891011/* WRONG */interface Example &#123; diff(one: string): number; diff(one: string, two: string): number; diff(one: string, two: string, three: boolean): number;&#125;/* OK */interface Example &#123; diff(one: string, two?: string, three?: boolean): number;&#125; 10.3.7 Union Types不要只在一个参数位置编写因类型而异的重载 1234567891011121314151617181920/* WRONG */interface Moment &#123; utcOffset(): number; utcOffset(b: number): Moment; utcOffset(b: string): Moment;&#125;/* OK */interface Moment &#123; utcOffset(): number; utcOffset(b: number | string): Moment;&#125;function fn(x: string): void;function fn(x: number): void;function fn(x: number | string) &#123; // When written with separate overloads, incorrectly an error // When written with union types, correctly OK return moment().utcOffset(x);&#125; 10.4 Deep Dive10.4.1 Namespaces类型可以存在于名称空间中。例如，如果我们有声明let x：A.B.C，则说类型C来自A.B命名空间。A， B 不一定必须是类型或者值 10.4.2 简单组合，一个名字多种含义给定名称A，我们最多可以找到A的三种不同含义：类型，值或名称空间。名称的解释方式取决于所使用的上下文。例如，在一个声明文件中 中 let m：A.A = A ;，首先将A用作namespaces，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！ 10.4.2.1 User Combinations123456789// foo.d.tsexport var SomeVar: &#123; a: SomeType &#125;;export interface SomeType &#123; count: number;&#125;// consumedimport * as foo from \"./foo\";let x: foo.SomeType = foo.SomeVar.a;console.log(x.count); 这种方法不错，但我们可能会认为 SomeType 和 SomeVar 紧密相关，因此您希望它们具有相同的名称。我们可以使用合并相同的名称Bar呈现这两个不同的对象； 123456789// foo.d.tsexport var Bar: &#123;a : Bar&#125;;export interface Bar &#123; count: number&#125;// consumedimport &#123; Bar &#125; from \"./foo\";let x: Bar = Bar.a;console.log(x.count); 我们在这里使用Bar作为类型和值。请注意，我们不必将Bar值声明为Bar类型，它们是独立的。 10.4.2.2 Advanced Combinations某些声明可以跨多个声明进行组合，比如 class C {} 和 interface C{} 可以共存，并且都给类型C贡献了属性。 只要不造成冲突，就是合法的，一般的经验法则是， 值始终会与同名的其他值发生冲突，除非将它们声明为namespaces,； s, types will conflict if they are declared with a type alias declaration (type s = string), and namespaces never conflict. Adding using an `interface 1234567891011121314151617181920212223interface Foo &#123; x: number;&#125;// ... elsewhere ...interface Foo &#123; y: number;&#125;let a: Foo = ...;console.log(a.x + a.y); // OK// this also works with classesclass Foo &#123; x: number;&#125;// ... elsewhere ...interface Foo &#123; y: number;&#125;let a: Foo = ...;console.log(a.x + a.y); // OK// Note that we cannot add to type aliases (type s = string;) using an interface. Adding using a namespace 可以使用namespace声明以任何不会造成冲突的方式添加新的类型，值和namespace。 123456// 给class添加一个静态成员class C &#123;&#125;namespace C &#123; export let x: number;&#125; let y = C.x; // OK 在此示例中，我们向C的静态侧（其构造函数）添加了一个值。这是因为我们添加了一个值，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。 We could also add a namespaced type to a class: 123456class C &#123;&#125;// ... elsewhere ...namespace C &#123; export interface D &#123;&#125;&#125;let y: C.D; // OK 在我们为其编写 namespace 声明之前，没有 namespace C。作为命名空间的C的含义与该类创建的C的值或类型的含义不冲突。 我们可以使用名称空间声明执行许多不同的合并; 12345678910111213namespace X &#123; export interface Y &#123;&#125; export class Z &#123;&#125;&#125;// ... elsewhere ...namespace X &#123; export var Y: number; export namespace Z &#123; export class C &#123;&#125; &#125;&#125;type X = string; In this example, the first block creates the following name meanings: A value X (because the namespace declaration contains a value, Z) A namespace X (because the namespace declaration contains a type, Y) A type Y in the X namespace A type Z in the X namespace (the instance shape of the class) A value Z that is a property of the X value (该class的构造函数) The second block creates the following name meanings: A value Y (of type number) that is a property of the X value A namespace Z A value Z that is a property of the X value A type C in the X.Z namespace A value C that is a property of the X.Z value A type X 10.5 Publish to npm10.5.1 两种发布方法 bundling with your npm package publishing to the @types organization on npm. 12345678/// &lt;reference path=\"...\" /&gt;// Don’t use /// &lt;reference path=\"...\" /&gt; in your declaration files./// &lt;reference path=\"../typescript/lib/typescriptServices.d.ts\" /&gt;// Do use /// &lt;reference types=\"...\" /&gt; instead./// &lt;reference types=\"typescript\" /&gt; 10.5.2 Packaging dependent declarationsIf your type definitions depend on another package: Don’t combine it with yours, keep each in their own file. Don’t copy the declarations in your package either. Do depend on the npm type declaration package if it doesn’t package its declaration files. 10.5.3 Publish to @typesPackages under the @types organization are published automatically from DefinitelyTyped using the types-publisher tool. To get your declarations published as an @types package, please submit a pull request to DefinitelyTyped. You can find more details in the contribution guidelines page. 10.6 Find and Install Declaration Files loadsh 1npm install @types/lodash 123456// 如果 npm install 了 类型声明import * as _ from \"lodash\";_.padStart(\"hi\", 20, \"\");// or if you’re not using modules, you can just use the global variable _._.padStart(\"Hello TypeScript!\", 20, \" \");","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts modules","slug":"ts-modules","date":"2021-01-20T11:42:30.000Z","updated":"2021-02-09T10:28:43.410Z","comments":true,"path":"2021/01/20/ts-modules/","link":"","permalink":"http://yoursite.com/2021/01/20/ts-modules/","excerpt":"","text":"6. Modules6.1 import/export模块是在自己的范围内执行的，而不是在全局范围内执行的；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用导出形式之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种导入形式将其导入。 模块是声明性的，模块之间的关系是根据文件级别的导入和导出指定的； 模块使用模块加载器相互导入， 在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。 6.1.1 export可以通过添加export关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。 123export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125; 重命名导出 1234567class ZipCodeValidator implements StringValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s);&#125;&#125;export &#123; ZipCodeValidator &#125;;export &#123; ZipCodeValidator as mainValidator &#125;; 重新导出不会将其导入本地，也不会引入局部变量。 12345678export class ParseIntBasedZipCodeValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; parseInt(s).toString() === s;&#125;&#125;// Export original validator but rename itexport &#123; ZipCodeValidator as RegExpBasedZipCodeValidator &#125; from \"./ZipCodeValidator\"; 导出所有 123456export * from \"./StringValidator\"; // exports 'StringValidator' interfaceexport * from \"./ZipCodeValidator\"; // exports 'ZipCodeValidator' class and 'numberRegexp' constant valueexport * from \"./ParseIntBasedZipCodeValidator\"; // exports the 'ParseIntBasedZipCodeValidator' class// and re-exports 'RegExpBasedZipCodeValidator' as alias// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'// module. 6.1.2 import12345678910// single exportimport &#123; ZipCodeValidator &#125; from \"./ZipCodeValidator\";// renamedimport &#123; ZipCodeValidator as ZCV &#125; from \"./ZipCodeValidator\";let myValidator = new ZCV();// 将整个模块导入单个变量，并使用它来访问模块导出import * as validator from \"./ZipCodeValidator\";let myValidator = new validator.ZipCodeValidator();// 某些模块会设置一些可由其他模块使用的全局状态。这些模块可能没有任何出口import \"./my-module.js\" 6.1.3 default exports 默认导出 ​ 每个模块可以选择导出默认导出。默认导出用关键字default标记；每个模块只能有一个默认导出。默认导出使用其他导入形式导入。 ​ 默认出口真的很方便。例如，像jQuery之类的库可能具有jQuery或$的默认导出，我们也可能以$或jQuery的名称导入 1234567// JQuery.d.tsdeclare let $:JQueryexport default $;// App.tsimport $ from \"jquery\";$(\"button\").html(\"xxx\") 6.1.4 Export all as x12export * as utilities from \"./utilities\";import &#123;utilities&#125; from './index'; 6.1.4 export = import = require()TypeScript supports export = to model the traditional CommonJS and AMD workflow. export =语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。 当使用export =导出模块时, 必须用 import module = require(&quot;module&quot;) 导入模块 1234567891011121314151617// z.tslet numberRegexp = /^[0-9]+$/;class ZipCodeValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s);&#125;&#125;export = ZipCodeValidator;// t.tsimport zip = require(\"./ZipCodeValidator\");// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validator = new zip(); 6.2 code generation for Modulestypescript 会依据不同的模块规则，生成不同的代码 123// SimpleModule.tsimport m = require(\"mod\");export let t = m.something + 1; AMD / RequireJS SimpleModule.js 123define([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) &#123;exports.t = mod_1.something + 1;&#125;); CommonJS / Node SimpleModule.js 12var mod_1 = require(\"./mod\");exports.t = mod_1.something + 1; UMD SimpleModule.js 1234567891011(function (factory) &#123;if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") &#123; var v = factory(require, exports); if (v !== undefined) module.exports = v;&#125; else if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define([\"require\", \"exports\", \"./mod\"], factory);&#125;&#125;)(function (require, exports) &#123;var mod_1 = require(\"./mod\");exports.t = mod_1.something + 1;&#125;); System SimpleModule.js 1234567891011121314System.register([\"./mod\"], function (exports_1) &#123;var mod_1;var t;return &#123; setters: [ function (mod_1_1) &#123; mod_1 = mod_1_1; &#125;, ], execute: function () &#123; exports_1(\"t\", (t = mod_1.something + 1)); &#125;,&#125;;&#125;); Native ECMAScript 2015 modules SimpleModule.js 12import &#123; something &#125; from \"./mod\";export var t = something + 1; 6.3 可选模块加载和其他高级加载方案为了保持类型安全，我们可以使用typeof关键字。当在类型位置中使用typeof关键字时，将产生值的类型，在这种情况下为模块的类型。 6.3.1 Dynamic Module Loading in Node.js1234567891011declare function require(moduleName: string): any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123;let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");let validator = new ZipCodeValidator();if (validator.isAcceptable(\"...\")) &#123; /* ... */&#125;&#125; 6.3.2 Sample: Dynamic Module Loading in require.js123456789101112131415declare function require(moduleNames: string[],onLoad: (...args: any[]) =&gt; void): void;import * as Zip from \"./ZipCodeValidator\";if (needZipValidation) &#123;require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) =&gt; &#123; let validator = new ZipCodeValidator.ZipCodeValidator(); if (validator.isAcceptable(\"...\")) &#123; /* ... */ &#125;&#125;);&#125; 6.3.3 Sample: Dynamic Module Loading in System.js123456789101112declare const System: any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123;System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) =&gt; &#123; var x = new ZipCodeValidator(); if (x.isAcceptable(\"...\")) &#123; /* ... */ &#125;&#125;);&#125; 6.4 使用其他js库为了描述非ts编写的库，我们需要声明该库公开的API；通常将这些声明定义在.d.ts文件中，就类似c/c++程序中的 .h文件； Ts程序在开发过程中，会不可避免的引用到第三方js库，但是无法使用Typescript诸如类型检查等特性功能，为了解决这个问题，需要将这些库的函数和方法去掉后只保留导出类型声明，而产生一个描述js库和模块信息的声明文件，通过引用这个声明文件，就可以借用TS的各种特性来使用库文件； 6.4.1 声明文件的存放方式 在tsconfig include 字段包含 的范围内编写.d.ts，都能被自动识别 在x.js 相同目录创建同名声明文件x.d.ts，这样也会被自动识别； node_modules/@types/ 下存放的各个第三方模块声明文件，自己编写的声明文件不要放这里； 作为npm模块发布时，声明文件可捆绑发布，需在package.json中指明“types”：”./types/index.d.ts” 6.4.1 无配置使用js在tsconfig.json中关闭”noImplicitAny”: false时，可直接在Ts中引用js的库，所有的引入都会被默认为any类型。此方法不推荐使用； 6.4.2 Ts中引入js123456789// hello.jsexport const hello = () =&gt; console.log('hello');// index.tsimport &#123;hello&#125; from './hello'// 无法找到模块'./hello'的声明文件// 这就告诉用户，需要为hello.js编写声明文件了；// hello.d.tsexport declare const hello: () =&gt; void 上面的例子稍微简单一些，下面写一个相对复杂点的demo tsconfig.json 123456789101112&#123; \"compilerOptions\": &#123; \"outDir\": \"./dist/\", \"noImplicitAny\": true, \"allowJs\": true, \"module\": \"commonjs\", \"target\": \"es5\", \"experimentalDecorators\": true &#125;, \"exclude\": [\"node_modules\"], \"include\": [\"./src/**/*\"]&#125; dir 12345-src -swap -index.js -index.d.ts -index.ts 1234567891011121314// swap/index.jsconst NAME = \"A\";const swap = (a, b) =&gt; &#123; let temp; temp = a; a = b; b = temp; return `I am $&#123;NAME&#125;`;&#125;;export default &#123; swap,&#125;; 123456// swap/index.d.tsdeclare namespace swap &#123; // ts 编译运行时的 swap命名空间, 增加命名空间放置被全局污染。 function swap&lt;T&gt;(a: T, b: T): void;&#125;export default swap; // 注意这里要导出，有export/import 语句的文件 才是模块 12345678// index.tsimport swap from \"./swap\";let a = \"3\", b = \"4\";console.log(swap.swap&lt;string&gt;(a, b));console.log(a, b); 6.4.3 declarevar和declare的区别 ​ var表示创建一个新变量，declare用来告诉ts编译器这个变量已经在别处被创建过了， 如果你用declare，什么都不会添加到生成的js中， 它只是对编译器一个简单的提示； ​ 举例说明，如果你引入的第三方js文件中有 var externalModule，你需要定义declare var externalModule 去提示ts编译器，externalModule这个变量已经被创建了； 1export declare class Action &#123;&#125; 这个class Action的具体实现应该在其他什么地方，可以在个 .js文件里面 ​ 6.4.4 Ts中导入.png .json等导入.png .json 等文件时，同样也需要去编写声明文件； 提供一种方式，可以创建一个声明文件 src/@types/definition.d.ts 1234567891011121314// definition.d.tsdeclare module '*.png' &#123;const value: stringexport = value&#125;// index.ts// 之后在TS中导入也不会有问题import avatar from './img/avatar.png'const avatar = require('./img/avatar.png') // 可能会提示 require 未定义，有两种方式： // 1. 自行声明：declare const require: any // 2. yarn add -D @types/node 6.4.5 第三方模块没有可用的声明文件有些模块没有对应的声明文件时，需要我们自己编写声明文件，以rc-form为例子，需要在src/@types/defintion.d.ts中添加声明代码 1234567// defintion.d.tsdeclare module \"rc-form\" &#123;// 再次简单进行类型声明export const createForm: any;export const createFormField: any;export const formShape: any;&#125; 6.4.6 webpack 别名 aliases1234567891011121314151617181920212223242526// webpack.config.jsconst config = &#123;aliases: &#123; // 公共的工具类、容器和组件 utils: path.resolve('../utils'),&#125;// &#125;// index.tsimport &#123;ua&#125; from 'utils/broswer'// cannot find module 'utils/browser'// 只需要在tsconfig.json 添加baseUrl 和 paths&#123;\"compilerOptions\": &#123; // ... // 添加配置 \"baseUrl\": \".\", \"paths\": &#123; \"utils/*\": [\"../utils/*\"], \"components/*\": [\"../components/*\"] &#125;&#125;,\"include\": [\"./src/*\", \"./src/**/*\"],\"exclude\": [\"node_modules\"]&#125; 6.4.7 类型Window上不存在属性“X”需要对window进行扩展，直接在src/@types/definition.d.ts中扩展 1234567// definition.d.tsinterface Window &#123; x: any&#125;// index.tsconsole.log(Window.x) // success 注意全局声明和局部声明 1234567891011121314151617181920212223// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'interface Window &#123; X: any&#125;// index.tsconsole.log(window.X); // fail: 类型“Window\"上不存在属性“X”// 解决思路// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'declare global &#123; interface Window &#123; X: any &#125;&#125;// index.tsconsole.log(window.X) // success // 原因在于当一个 .ts文件加入import/export 语句的时候，该文件会变为一个模块；因为这个模块中的声明也会变为局部声明； 因此需要加到global的域上 6.5 Ambient Modules在nodejs中，很多任务的完成都需要引入一个或多个模块，我们可以给每个模块在他们的根目录建立一个.d.ts文件用来声明类型，但合并这些声明到一个大的.d.ts文件往往更方便一些。使用module关键字和 引号名 。这些引号名的名称将在以后的导入中使用； 1234567891011121314151617181920// node.d.tsdeclare module \"url\" &#123;export interface Url &#123; protocol?: string; hostname?: string; pathname?: string;&#125;export function parse( urlStr: string, parseQueryString?, slashesDenoteHost?): Url;&#125;declare module \"path\" &#123;export function normalize(p: string): string;export function join(...paths: any[]): string;export var sep: string;&#125; Now we can /// &lt;reference&gt; node.d.ts and then load the modules using import url = require(&quot;url&quot;); or import * as URL from &quot;url&quot;. 123/// &lt;reference path=\"node.d.ts\"/&gt;import * as URL from \"url\";let myUrl = URL.parse('...') 6.5.1 不想为第三方js写声明If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly. 123456// declarations.d.tsdeclare module \"hot-new-module\";// All imports from shorthand module will have the any type;import x, &#123;y&#125; from \"hot-new-module\";x(y); 6.5.2 通配符一些模块加载器（例如SystemJS和AMD）允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。 12345678910111213141516// declareations.d.tsdeclare module \"*!text\" &#123;const content: string;export default content;&#125;// Some do it the other way around.declare module \"json!*\" &#123;const value: any;export default value;&#125;// Now you can import things that match \"*!text\" or \"json!*\".import fileContent from \"./xyz.txt!text\";import data from \"json!http://example.com/data.json\";console.log(data, fileContent); 6.5.3 UMD modules一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为UMD模块。可以通过导入或全局变量访问这些库。 123// math-lib.d.tsexport function isPreme(x: number):boolean;export as namespace mathLib; The library can then be used as an import within modules: 123import &#123; isPrime &#125; from \"math-lib\";isPrime(2);mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports) 1mathLib.isPrime(2); 6.7 Guidance for structuring modules6.7.1 Export as close to top-level as possible如果要导入大量内容，请使用名称空间导入模式 12345678// MyLargeModule.tsexport class Dog &#123; ... &#125;export class Cat &#123; ... &#125;export class Tree &#123; ... &#125;export class Flower &#123; ... &#125;// Consumer.tsimport * as myLargeModule from \"./MyLargeModule.ts\";let x = new myLargeModule.Dog(); 6.7.2 Re-export to extend通常，您将需要扩展模块上的功能。常见的JS模式是使用扩展来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样合并。推荐的解决方案是不要变更原始对象，而是导出提供新功能的新对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081export class Calculator &#123;private current = 0;private memory = 0;private operator: string;protected processDigit(digit: string, currentValue: number) &#123; // 只能做10以内的计算； if (digit &gt;= \"0\" &amp;&amp; digit &lt;= \"9\") &#123; return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0)); &#125;&#125;protected processOperator(operator: string) &#123; if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) &gt;= 0) &#123; return operator; &#125;&#125;protected evaluateOperator( operator: string, left: number, right: number): number &#123; switch (this.operator) &#123; case \"+\": return left + right; case \"-\": return left - right; case \"*\": return left * right; case \"/\": return left / right; &#125;&#125;private evaluate() &#123; if (this.operator) &#123; this.memory = this.evaluateOperator( this.operator, this.memory, this.current ); &#125; else &#123; this.memory = this.current; &#125; this.current = 0;&#125;public handleChar(char: string) &#123; if (char === \"=\") &#123; this.evaluate(); return; &#125; else &#123; let value = this.processDigit(char, this.current); if (value !== undefined) &#123; this.current = value; return; &#125; else &#123; let value = this.processOperator(char); if (value !== undefined) &#123; this.evaluate(); this.operator = value; return; &#125; &#125; &#125; throw new Error(`Unsupported input: '$&#123;char&#125;'`);&#125;public getResult() &#123; return this.memory;&#125;&#125;export function test(c: Calculator, input: string) &#123;for (let i = 0; i &lt; input.length; i++) &#123; c.handleChar(input[i]);&#125;console.log(`result of '$&#123;input&#125;' is '$&#123;c.getResult()&#125;'`);&#125; 1234// 使用import &#123;Calculator, test&#125; from './ProgrammerCalculator';let c = new Calculator(2);test(c, \"1+2*33/11=\"); 新需求： 要求计算超过9的值 这个时候不在原类上更改，而是在继承类上做新功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ProgrammerCalculator.tsimport &#123; Calculator &#125; from \"./Calculator\";class ProgrammerCalculator extends Calculator &#123;static digits = [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\",];constructor(public base: number) &#123; super(); const maxBase = ProgrammerCalculator.digits.length; if (base &lt;= 0 || base &gt; maxBase) &#123; throw new Error(`base has to be within 0 to $&#123;maxBase&#125; inclusive.`); &#125;&#125;protected processDigit(digit: string, currentValue: number) &#123; if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) &#123; return ( currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit) ); &#125;&#125;&#125;// Export the new extended calculator as Calculatorexport &#123; ProgrammerCalculator as Calculator &#125;;// Also, export the helper functionexport &#123; test &#125; from \"./Calculator\"; 12345// TestProgrammerCalculator.tsimport &#123; Calculator, test &#125; from \"./ProgrammerCalculator\";let c = new Calculator(2);test(c, \"001+010=\"); // prints 3 6.7.3 Do not use namespaces in modules当首次转向基于模块的组织时，一种普遍的趋势是将导出包装在命名空间的附加层中。模块具有自己的作用域，并且从模块外部仅可见导出的声明。考虑到这一点，名称空间在使用模块时几乎没有价值。 7. Namespaces在TypeScript 1.5中，模块命名法则已更改。 “Internal modules”现在是“namespaces”。为了与ECMAScript 2015的术语保持一致，“External modules”现在简称为“modules”（module X {} 等同于 namespaceX {}） 在声明内部模块时，在使用module关键字的任何地方，可以并且应该改用namespace关键字。 7.1 多个相似对象添加namespaces123456789101112131415161718192021222324252627282930313233343536373839namespace Validation &#123;export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125;const lettersRegexp = /^[A-Za-z]+$/;const numberRegexp = /^[0-9]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125;&#125;export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;&#125;// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123;for (let name in validators) &#123; console.log( `\"$&#123;s&#125;\" - $&#123; validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" &#125; $&#123;name&#125;` );&#125;&#125; 7.2 Splitting Across Files​ 随着应用程序的扩展，我们希望将代码拆分为多个文件，以使其易于维护; 7.2.1 Multi-file namespaces 我们将Validation名称空间拆分为多个文件。即使文件是分开的，它们每个都可以贡献相同的名称空间，并且可以像将它们全部定义在一个位置一样使用。由于文件之间存在依赖性，因此我们将添加参考标记，以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。 Validation.ts 12345namespace Validation &#123;export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125;&#125; LettersOnlyValidator.ts 123456789/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123;const lettersRegexp = /^[A-Za-z]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125;&#125;&#125; ZipCodeValidator.ts 123456789/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123;const numberRegexp = /^[0-9]+$/;export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;&#125; Test.ts 12345678910111213141516171819202122/// &lt;reference path=\"Validation.ts\" /&gt;/// &lt;reference path=\"LettersOnlyValidator.ts\" /&gt;/// &lt;reference path=\"ZipCodeValidator.ts\" /&gt;// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123;for (let name in validators) &#123; console.log( `\"$&#123;s&#125;\" - $&#123; validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" &#125; $&#123;name&#125;` );&#125;&#125; 一旦涉及到多个文件，需要确保所有已编译的代码都已加载，有两种方法可以做到这点 7.2.1.1 级联输出使用 –outFile，将所有输入文件编译为单个js输出文件 tsc --outFile sample.js Test.ts 7.2.1.2 自动排序输出编译器将根据文件中存在的参考标记自动排序输出文件。您还可以分别指定每个文件： tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts 7.2.1.3 单个编译12tsc test.tstes Validation.ts 7.3 Aliases12345678910namespace Shapes &#123;export namespace Polygons &#123; export class Triangle &#123;&#125; export class Square &#123;&#125;&#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 7.3.1 使用第三方JavaScript库为了描述不是用TypeScript编写的库的形状，我们需要声明该库公开的API。因为大多数JavaScript库仅公开一些顶级对象，所以namespaces是表示它们的好方法。 D3在名为d3的全局对象中定义其功能。由于此库是通过script标签加载的，因此可以使用命名空间来声明它的shape。 1234567891011121314151617181920declare namspace D3 &#123;export interface Selectors &#123; select: &#123; (selector: string): Selection; (element: EventTarget): Selection; &#125;;&#125;export interface Event &#123; x: number; y: number;&#125;export interface Base extends Selectors &#123; event: Event;&#125;&#125;declare var d3: D3.Base; 8. 三斜杠指令三斜杠指令是包含单个XML标签的单行注释。注释的内容用作编译器指令。 三斜杠指令仅在其包含文件的顶部有效。三斜杠指令只能在单行或多行注释之前，包括其他三斜杠指令。如果在声明或声明之后遇到它们，则将它们视为常规的单行注释，并且没有特殊含义。 /// &lt;reference path=&quot;./lib/index.d.ts&quot; /&gt;：表示对一个文件的依赖。 /// &lt;reference types=&quot;jye&quot; /&gt;：表示对一个库的依赖。 三斜线的path &amp; types，和es6的import语义相似，同时三斜线指令必须放在文件的最顶端。例如，当我们的声明文件过于庞大，一般都会采用三斜线指令，将我们的声明文件拆分成若干个，然后由一个入口文件引入。 8.1 文件之间的依赖声明12///&lt;reference path=\"...\"/&gt;///&lt;reference path=\"...\"/&gt; 是这个group中最常见的，它用作文件之间依赖关系的声明； 三斜杠指令指示编译器在编译过程中包括其他文件； 当使用 –out 或 –outFile时，它们还可以用作对输出进行排序的方法。预处理通过后，文件以与输入相同的顺序输出到目标文件位置。 8.2 input files 预处理编译器对输入文件进行预处理，以解析所有三斜杠引用指令。在此过程中，其他文件将添加到编译过程中。 该过程从一组根文件开始；这些是在命令行或tsconfig.json文件的“files”列表中指定的文件名。这些根文件将按照指定的顺序进行预处理。在将文件添加到列表之前，必须先处理其中的所有三斜杠引用及其目标。按照在文件中出现的顺序，深度优先地解析三斜杠引用 A triple-slash reference path is resolved relative to the containing file, if unrooted. 8.3 typestypes=&quot;...&quot; 与 path=&quot;...&quot; 类似，前者声明对包的依赖，后者声明对一个文件的依赖 这些程序包名称的解析过程与import语句中的模块名称解析过程相似。考虑三重斜杠引用类型指令的一种简单方法是将其作为声明包的导入。 在一个声明文件中包括 types=&quot;node&quot; 则该声明文件使用@types/node/index.d.ts中声明的名称，因此，此包需要与声明文件一起包含在编译中; 仅当您书写d.ts文件时，才使用这些指令； 对于编译期间生成的声明文件，编译器会自动添加types=&quot;...&quot;。当且仅当reslulting file使用 referenced package中 任何声明的时候，才会在生成的声明文件中添加 types=&quot;...&quot; ； 在 .ts 文件声明对 一个@types 包的依赖， 使用命令行 –types 或者 tsconfig.json中设置； 8.4 liblib=&quot;...&quot; 此指令允许文件显式包括现有的内置lib文件。 例如，在编译中的一个文件中添加/// &lt;reference lib =“ es2017.string” /&gt;等效于使用–lib es2017.string进行编译。 123/// &lt;reference lib=\"es2017.string\" /&gt;\"foo\".padStart(4); 9. Namespaces and Modules9.1 使用modules模块可以包含代码和声明 从es6开始，模块是语言的原生机制，新的项目，模块将是推荐的代码组织机制； 9.2 使用namespaces命名空间是TypeScript特定的组织代码的方式。 命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。与模块不同，它们可以跨越多个文件，并且可以使用–outFile进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都作为script标记包含在HTML页面中。 就像所有全局命名空间污染一样，很难识别组件依赖性，尤其是在大型应用程序中。 9.3 使用namespaces 和 modules 遇到的一些坑9.3.1 不需要namespaces的时候123456789101112// `shapes.ts`export namespace Shapes &#123;export class Triangle &#123; /* ... */&#125;export class Square &#123; /* ... */&#125;&#125;// `shapeConsumer.ts`import * as shapes from \"./shapes\";let t = new shapes.Shapes.Triangle(); // shapes.Shapes? 推荐的做法，当一个文件中定义了import/export 的时候，那么它就变成了一个模块。模块中，命名空间显然多此一举了 推荐做法 12345678910// shapes.tsexport class Triangle &#123;/* ... */&#125;export class Square &#123;/* ... */&#125;// shapeConsumer.tsimport * as shapes from \"./shapes\";let t = new shapes.Triangle(); 9.3.2 reference 和import 的使用时机一个常见的错误是尝试使用/// reference ...语法来引用模块文件，而不是使用import语句； 编译器如何 基于 path of an import path(import X from &#39;xxx&#39;; import x = require(&#39;...&#39;)) 找到模块的类型信息； 编译器将尝试查找.ts，.tsx，然后找到具有适当路径的.d.ts。如果找不到特定的文件，然编译器会去找ambient module declaration 记得这些需要在 .d.ts 文件中声明 12345678// myModules.d.ts// In a .d.ts file or .ts file that is not a module:declare module \"SomeModule\" &#123; export function fn(): string;&#125;// myOtherModule.ts/// &lt;reference path=\"myModules.d.ts\" /&gt; 记得添加依赖import * as m from \"SomeModule\"; // 这里并不是导入 文件名，而是模块名，因为 myModules.d.ts 不是一个模块； /// reference path=&quot;myModules.d.ts&quot; 使我们能够找到包含环境模块声明的声明文件，This is how the node.d.ts file that several of the TypeScript samples use is consumed.","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts generics","slug":"ts-generics","date":"2021-01-20T11:42:15.000Z","updated":"2021-02-09T10:28:30.509Z","comments":true,"path":"2021/01/20/ts-generics/","link":"","permalink":"http://yoursite.com/2021/01/20/ts-generics/","excerpt":"","text":"5. Generics泛型，创建可重用组件的工具。 1234function loggingIdentity&lt;T&gt;(arg: T) &#123; console.log(arg.length); // Property 'length' does not exist on type 'T'. return arg;&#125; 5.1 泛型定义1234567891011function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;let myIdentity1: &#123; &lt;T&gt;(arg: T): T &#125; = identity;let myIdentity2: GenericIdentityFn = identity; 5.2 泛型类12345678910class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y;&#125;; 5.3 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 5.3.1 Using Type Parameters in Generic Constraints123456789function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\");getProperty(x, \"m\");// Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'. 5.3.2 泛型类使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型； 123function create&lt;T&gt;(c: &#123; new (): T &#125;): T &#123; return new c();&#125; 使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系 1234567891011121314151617181920212223242526class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts doc","slug":"ts-doc","date":"2021-01-19T08:12:21.000Z","updated":"2021-02-09T10:28:20.873Z","comments":true,"path":"2021/01/19/ts-doc/","link":"","permalink":"http://yoursite.com/2021/01/19/ts-doc/","excerpt":"","text":"handbookA reader who completes the walkthrough should be able to: Read and understand commonly-used TypeScript syntax and patterns Explain the effects of important compiler options Correctly predict type system behavior in most cases Write a .d.ts declaration for a simple function, object, or class 1. basic Types 在TypeScript中，我们支持与JavaScript中期望的类型相同的类型，并添加了一个额外的枚举类型以帮助处理问题。 Boolean, Number, String, Array,Tuple,Enum,Unkown,Any,Void, Null and Undefined, Never, Object, Tuple 元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对字符串和一个数字： 123456// Declare a tuple typelet x: [string, number];// Initialize itx = [\"hello\", 10]; // OK// Initialize it incorrectlyx = [10, \"hello\"]; // Error Enum 枚举是JavaScript标准数据类型集的一个有用补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。 123456789enum Color &#123; Red = 1, Green, Blue,&#125;let colorName: string = Color[2];// Displays 'Green'console.log(colorName); Unknown 我们可能需要描述编写应用程序时不知道的变量类型。这些值可能来自动态内容，例如来自用户-或者我们可能要有意接受我们API中的所有值。在这些情况下，我们希望提供一种类型，该类型告诉编译器和将来的读者此变量可以是任何变量，因此我们将其赋予未知类型。 12345let notSure: unknown = 4;notSure = \"maybe a string instead\";// OK, definitely a booleannotSure = false; 如果您有一个类型未知的变量，则可以通过进行typeof检查，比较检查或更高级的类型防护来将其范围缩小到更具体的范围; 1234567891011121314151617181920declare const maybe: unknown;// 'maybe' could be a string, object, boolean, undefined, or other typesconst aNumber: number = maybe;//Type 'unknown' is not assignable to type 'number'.if (maybe === true) &#123; // TypeScript knows that maybe is a boolean now const aBoolean: boolean = maybe; // So, it cannot be a string const aString: string = maybe;//Type 'boolean' is not assignable to type 'string'.&#125;if (typeof maybe === \"string\") &#123; // TypeScript knows that maybe is a string const aString: string = maybe; // So, it cannot be a boolean const aBoolean: boolean = maybe;//Type 'string' is not assignable to type 'boolean'.&#125; Any 在某些情况下，并非所有类型信息都可用。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况，可能要选择退出类型检查。将这些值标记为any类型： 123declare function getValue(key: string): any;// OK, return value of 'getValue' is not checkedconst str: string = getValue(\"myString\"); 与 unknown 不同，any类型的变量使您可以访问任意属性，甚至是不存在的属性。这些属性包括函数，并且TypeScript不会检查它们的存在或类型 123456789let looselyTyped: any = 4;// OK, ifItExists might exist at runtimelooselyTyped.ifItExists();// OK, toFixed exists (but the compiler doesn't check)looselyTyped.toFixed();let strictlyTyped: unknown = 4;strictlyTyped.toFixed();// Object is of type 'unknown'. Void void有点像任何其他的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型： 123function warnUser(): void &#123; console.log(\"This is my warning message\");&#125; Null and Undefined 在TypeScript中，undefined和null实际上实际上分别将其类型命名为undefined和null。就像void一样，它们本身并不是非常有用： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Never The never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never. 1234567891011121314// Function returning never must not have a reachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must not have a reachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; Object object是代表非基本类型的类型，即不是数字，字符串，布尔值，bigint，symbol，null或undefined的任何类型。 123456789101112131415// With object type, APIs like Object.create can be better represented.declare function create(o: object | null): void;// OKcreate(&#123; prop: 0 &#125;);create(null);create(42);//Argument of type '42' is not assignable to parameter of type 'object | null'.create(\"string\");//Argument of type '\"string\"' is not assignable to parameter of type 'object | null'.create(false);//Argument of type 'false' is not assignable to parameter of type 'object | null'.create(undefined);//Argument of type 'undefined' is not assignable to parameter of type 'object | null'. Type assertions 类型断言是一种告诉编译器“相信我，我知道我在做什么”的方法。类型断言就像其他语言中的类型转换一样，但是它不执行数据的特殊检查或重构。它对运行时没有影响，仅由编译器使用。 TypeScript假定您（程序员）已经执行了所需的任何特殊检查。 类型断言的两种形式 123456// 类型1: as 语句let someValue: unknown = \"this is a string\";let strLength: number = (someValue as string).length;// 类型2: 尖括号let someValue: unknown = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; jsx中无法使用 类型2； About Number, String, Boolean, Symbol and Object 可能会认为数字，字符串，布尔值，符号或对象类型与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎永远不应将其用作类型。 2. interface2.1 readonly1234interface Point &#123; readonly x: number; readonly y: number;&#125; TypeScript具有与Array 相同的ReadonlyArray 类型，并且删除了所有变异方法，因此可以确保创建后不更改数组： 1234567891011let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!//Index signature in type 'readonly number[]' only permits reading.ro.push(5); // error!//Property 'push' does not exist on type 'readonly number[]'.ro.length = 100; // error!//Cannot assign to 'length' because it is a read-only property.a = ro; // error!//The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'. 在代码片段的最后一行，您可以看到，即使将整个ReadonlyArray分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它： 1234let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;a = ro as number[]; ReadOnly or const 记住是使用只读还是const的最简单方法是询问是否在变量或属性上使用它。变量使用const，而属性使用只读。 2.2 Optional1234interface SquareConfig &#123; color?: string; width?: number;&#125; 2.3 Excess Property Checks但是，TypeScript认为此代码中可能存在错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行过多的属性检查。如果对象文字具有“目标类型”所没有的任何属性，则会出现错误： 123456789101112131415interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; return &#123; color: config.color || \"red\", area: config.width ? config.width * config.width : 20, &#125;;&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;);//Argument of type '&#123; colour: string; width: number; &#125;' is not assignable to parameter of type 'SquareConfig'. // Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 解决方案 解决这些检查实际上非常简单。最简单的方法是只使用类型断言： 1const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125; as SquareConfig); 如果对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。 12345678910interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125;);// 只要您在squareOptions和SquareConfig之间具有一个公共属性，上述变通办法就会起作用。但是，如果变量没有任何公共对象属性，它将失败。let squareOptions = &#123; colour: \"red\" &#125;;let mySquare = createSquare(squareOptions);// Type '&#123; colour: string; &#125;' has no properties in common with type 'SquareConfig'. 2.4 Function Types为了描述带有接口的函数类型，我们给接口一个调用签名。这就像只声明参数列表和返回类型的函数声明。参数列表中的每个参数都需要名称和类型。 1234567891011121314151617181920212223242526interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function (source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125;;let mySearch2: SearchFunc;// 参数不定义string，ts会自动推断mySearch2 = function (src, sub): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125;;let mySearch: SearchFunc;mySearch = function (src, sub) &#123; // 返回值需要遵守interface//Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.// Type 'string' is not assignable to type 'boolean'. let result = src.search(sub); return \"string\";&#125;; 2.5 Indexable Types可索引类型具有索引签名，该签名描述了可用于索引对象的类型以及建立索引时对应的返回类型 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为在用数字索引时，JavaScript实际上会在将其索引到对象之前将其转换为字符串。这意味着使用100（一个数字）进行索引与使用“ 100”（一个字符串）进行索引是同一回事，因此两者必须保持一致。 1234567891011121314interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;// Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay &#123; [x: number]: Animal;Numeric index type 'Animal' is not assignable to string index type 'Dog'. [x: string]: Dog;&#125; 尽管字符串索引签名是描述“字典”模式的强大方法，但它们还强制所有属性与其返回类型匹配。这是因为字符串索引声明obj.property也可以作为obj [“ property”]使用。在以下示例中，名称的类型与字符串索引的类型不匹配，并且类型检查器给出错误： 123456interface NumberDictionary &#123; [index: string]: number; length: number; // ok, length is a number name: string; // error, the type of 'name' is not a subtype of the indexer// Property 'name' of type 'string' is not assignable to string index type 'number'.&#125; 但是，如果索引签名是属性类型的并集，则可以接受不同类型的属性： 12345interface NumberOrStringDictionary &#123; [index: string]: number | string; // 属性类型 length: number; // ok, length is a number name: string; // ok, name is a string&#125; 最后，您可以将索引签名设为只读，以防止分配给它们的索引： 1234567interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];myArray[2] = \"Mallory\"; // error!// Index signature in type 'ReadonlyStringArray' only permits reading. 2.6 Class Types2.6.1 Implement123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 这是因为当类实现接口时，仅检查该类的实例侧。由于构造函数位于静态端，因此它不包含在此检查中。 123456789101112interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; // Class 'Clock' incorrectly implements interface 'ClockConstructor'. // Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'. currentTime: Date; constructor(h: number, m: number) &#123;&#125;&#125;const clock = new Clock(1, 3); 需要直接使用类的静态方面。在此示例中，我们定义了两个接口，用于构造函数的ClockConstructor和用于实例方法的ClockInterface。然后，为方便起见，我们定义了一个构造函数createClock，该函数创建传递给它的类型的实例 1234567891011121314151617181920212223242526272829303132interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;function createClock( ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"tick tock\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 另一种简单的方法是使用类表达式： 1234567891011121314151617interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;;let clock = new Clock(12, 17);clock.tick(); 2.7 Extending Interfaces12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &#123;&#125; as Square;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 2.8 Hybrid Typesan object that acts as both a function and an object, with additional properties: 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = function (start: number) &#123;&#125; as Counter; counter.interval = 123; counter.reset = function () &#123;&#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 与第三方JavaScript交互时，您可能需要使用上述模式来完全描述类型的形状 2.9 Interfaces Extending ClassesWhen an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it. This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example: 12345678910111213141516171819202122class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;class ImageControl implements SelectableControl &#123;//Class 'ImageControl' incorrectly implements interface 'SelectableControl'. // Types have separate declarations of a private property 'state'. private state: any; select() &#123;&#125;&#125; ​ In the above example, SelectableControl contains all of the members of Control, including the private state property. Since state is a private member it is only possible for descendants of Control to implement SelectableControl. This is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible. ​ Within the Control class it is possible to access the state private member through an instance of SelectableControl. Effectively, a SelectableControl acts like a Control that is known to have a select method. The Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method). The ImageControl class has it’s own state private member rather than extending Control, so it cannot implement SelectableControl. 3. Functions在TypeScript中，尽管有类，名称空间和模块，但是函数仍然在描述操作方式中起着关键作用。 TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。 3.1 thisLearning how to use this in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use this and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of this with a couple of techniques. If you need to learn how this works in JavaScript, though, first read Yehuda Katz’s Understanding JavaScript Function Invocation and “this”. Yehuda’s article explains the inner workings of this very well, so we’ll just cover the basics here. this and arrow functions In JavaScript, this is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument. Let’s look at an example: 1234567891011121314151617let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; return function () &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Notice that createCardPicker is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the this being used in the function created by createCardPicker will be set to window instead of our deck object. That’s because we call cardPicker() on its own. A top-level non-method syntax call like this will use window for this. (Note: under strict mode, this will be undefined rather than window). We can fix this by making sure the function is bound to the correct this before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original deck object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the this where the function is created rather than where it is invoked: 123456789101112131415161718let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Even better, TypeScript will warn you when you make this mistake if you pass the --noImplicitThis flag to the compiler. It will point out that this in this.suits[pickedSuit] is of type any. this parameters Unfortunately, the type of this.suits[pickedSuit] is still any. That’s because this comes from the function expression inside the object literal. To fix this, you can provide an explicit this parameter. this parameters are fake parameters that come first in the parameter list of a function: 123function f(this: void) &#123; // make sure `this` is unusable in this standalone function&#125; Let’s add a couple of interfaces to our example above, Card and Deck, to make the types clearer and easier to reuse: 1234567891011121314151617181920212223242526272829interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function (this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Now TypeScript knows that createCardPicker expects to be called on a Deck object. That means that this is of type Deck now, not any, so --noImplicitThis will not cause any errors. this parameters in callbacks You can also run into errors with this in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, this will be undefined. With some work you can use this parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with this: 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this: 123456789101112131415class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used `this` here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error!//Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. //The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'.Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. // The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'. With this annotated, you make it explicit that onClickBad must be called on an instance of Handler. Then TypeScript will detect that addClickListener requires a function that has this: void. To fix the error, change the type of this: 12345678910class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use `this` here because it's of type void! console.log(\"clicked!\"); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); Because onClickGood specifies its this type as void, it is legal to pass to addClickListener. Of course, this also means that it can’t use this.info. If you want both then you’ll have to use an arrow function: 123456class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message; &#125;;&#125; This works because arrow functions use the outer this, so you can always pass them to something that expects this: void. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler. 3.2 OverloadsJavaScript本质上是一种非常动态的语言。一个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。 1234567891011121314151617181920212223242526272829let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123; suit: string; card: number &#125;[]): number;function pickCard(x: number): &#123; suit: string; card: number &#125;;function pickCard(x) &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [ &#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;,];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 4. Classes4.1 abstract abstract关键字用于定义抽象类以及抽象类中的抽象方法。 抽象类， 是可以从中派成出其他类的基类；简单说就是只能被继承，不能new出实例；与interface不同的是，抽象类中可以有成员实现的详细信息。 12345678910111213141516171819202122232425export abstract class App &#123; public setTargetProps&lt;T&gt; (target: T, source: Partial&lt;T&gt;): T &#123; try &#123; Object.keys(target).forEach((property: keyof T) =&gt; &#123; this.setTargetPropsByProperty(target, property, source[property]) &#125;) &#125; catch (error) &#123; throw new Error(error) &#125; return target &#125;&#125;const app = new App();// Cannot create an instance of an abstract class.class B extends App&#123;&#125;;// 非抽象类“ B”未实现从类“ App”继承的抽象成员“ make”class C extends App&#123; make()&#123;&#125; // 需要实现抽象类中定义的抽象方法&#125; 抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含abstract关键字，并且可以选择包括访问修饰符。 4.2 public,private, and protected4.2.1 类型兼容12345678910111213141516171819202122232425262728class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super(\"Rhino\"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal(\"Goat\");let rhino = new Rhino();let employee = new Employee(\"Bob\");animal = rhino;animal = employee; // Type 'Employee' is not assignable to type 'Animal'. 没有继承关系的类型无法做赋值操作；// Types have separate declarations of a private property 'name' 4.2.2 protectedprotected修饰符的行为与private修饰符非常相似，除了声明为protected的成员也可以在派生类中访问之外； 123456789101112131415161718192021222324252627class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; // 派生类中可以访问到 基类中的 protected 属性； return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());// 虽然我们不能从Person外部使用name，但仍可以在Employee的实例方法中使用它，因为Employee源自Person。console.log(howard.name);// Property 'name' is protected and only accessible within class 'Person' and its subclasses. 构造函数也可能被标记为受保护的。这意味着该类不能在其包含的类之外实例化，但是可以扩展。 123456789101112131415161718192021222324class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee can extend Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\");// Constructor of class 'Person' is protected and only accessible within the class declaration. 因为 new Person的时候是需要调 Person的构造函数，由于其构造函数添加了 protected关键字。实例是无法调类的构造函数的，所以就无法被实例化了； 4.2.3 Readonly12345678910111213class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(readonly theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\";// Cannot assign to 'name' because it is a read-only property.console.log(dad.name) 4.2.4 accessorsTypeScript支持getters / setter方法，以拦截对对象成员的访问。这使您可以更好地控制如何访问每个对象上的成员的方式。 12345678910class Employee &#123; fullName: string;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 在此版本中，我们添加了一个setter来检查newName的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是这样，我们会抛出错误通知客户端代码出了点问题。 123456789101112131415161718192021222324const fullNameMaxLength = 10;class Employee &#123; private _fullName: string = \"\"; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123; throw new Error(\"fullName has a max length of \" + fullNameMaxLength); &#125; this._fullName = newName; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 注意事项 首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。 其次，带有get和no set的访问器会自动推断为只读。当代码生成.d.ts文件时很有用，因为用户通过ide可以看到这些无法进行更改。 4.2.5 Static1234567891011121314151617class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123; let xDist = point.x - Grid.origin.x; let yDist = point.y - Grid.origin.y; return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123;&#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 4.2.6 Using a class as an interface12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;; 5. Decorators随着TypeScript和ES6中类的引入，现在存在某些情况，这些情况需要附加功能来支持 annotating or modifying classes and class members。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的第2阶段提议，可作为TypeScript的实验功能使用。 JavaScript引入class之后，我们需要在不同的类之间共享或者扩展一些方法或行为的时候，代码会变得很复杂，不够优雅，这也是装饰器被提出的一个很重要原因之一； 要为装饰器启用实验性支持，必须在命令行或tsconfig.json中启用experimentalDecorators编译器选项 1tsc --target ES5 --experimentalDecorators 1234567// tsconfig.json&#123; \"compilerOptions\": &#123; \"target\": \"ES5\", \"experimentalDecorators\": true &#125;&#125; 装饰器是一种特殊的声明，可以附加到类声明，方法，访问器，属性或参数上。装饰器使用@expression形式，其中expression求值之后必须也是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入； 5.1 class decorators12345678910111213141516171819function addAge(constructor: Function) &#123; constructor.prototype.age = 18;&#125;function addName(constructor: Function) &#123; constructor.prototype.name = \"leo\";&#125;@addAge@addNameclass Person &#123; name: string; age!: number;&#125;let person = new Person();console.log(person.age, person.name); // 18 ,'age' 12345678910111213141516171819202122232425262728293031323334353637// bundle.jsvar __decorate = function (decorators, target, key, desc) &#123; var c = arguments.length, r = c &lt; 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc; var d; if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.decorate === \"function\") &#123; r = Reflect.decorate(decorators, target, key, desc); &#125; else &#123; for (var i = decorators.length - 1; i &gt;= 0; i--) if ((d = decorators[i])) // 核心代码就是 d(r) r为构造函数Person r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; &#125; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;&#125;;function addAge(constructor) &#123; constructor.prototype.age = 18;&#125;function addName(constructor) &#123; constructor.prototype.name = \"leo\";&#125;var Person = /** @class */ (function () &#123; function Person() &#123;&#125; Person = __decorate([addAge, addName], Person); return Person;&#125;)();var person = new Person();console.log(person.age, person.name);export &#123;&#125;; 5.2 reflect-metadatainstall npm install reflect-metadata demo 1234567891011121314151617181920212223242526272829303132import \"reflect-metadata\";let target = &#123;&#125;;Reflect.defineMetadata(\"name\", \"alex\", target);Reflect.defineMetadata(\"name\", \"world\", target, \"hello\");console.log(Reflect.getOwnMetadata(\"name\", target)); // alexconsole.log(Reflect.getOwnMetadata(\"name\", target, \"hello\")); // worldfunction classMetadata(key: any, value: any) &#123; return function (target: any) &#123; Reflect.defineMetadata(key, value, target); &#125;;&#125;function methodMetadata(key: any, value: any) &#123; return function (target: any, propertyName: any) &#123; //Person.prototype.hello.name=world Reflect.defineMetadata(key, value, target, propertyName); &#125;;&#125;//给类本身增加元数据//@Reflect.metadata('name','Person')@classMetadata(\"name\", \"Person\")class Person &#123; //给类的原型增加元数据 //@Reflect.metadata('name', 'world') @methodMetadata(\"name\", \"world\") hello(): string &#123; return \"world\"; &#125;&#125;console.log(Reflect.getMetadata(\"name\", Person)); // Personconsole.log(Reflect.getMetadata(\"name\", new Person(), \"hello\")); // world","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"html5vedio","slug":"html5vedio","date":"2021-01-04T07:02:23.000Z","updated":"2021-02-09T10:27:48.301Z","comments":true,"path":"2021/01/04/html5vedio/","link":"","permalink":"http://yoursite.com/2021/01/04/html5vedio/","excerpt":"","text":"html5 播放器加速123const video = document.querySelector('video');video.playbackRate = 2 // 播放器播放速度","categories":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"}]},{"title":"browser-sync","slug":"browser-sync","date":"2020-12-21T06:07:39.000Z","updated":"2021-02-09T10:26:03.847Z","comments":true,"path":"2020/12/21/browser-sync/","link":"","permalink":"http://yoursite.com/2020/12/21/browser-sync/","excerpt":"","text":"全局安装1231312312312123sudo npm install -g browser-sync 快速使用1234# 启动服务器 监听所有的html文件$ browser-sync start --server --files \"*.html\"# 启动服务器 监听所有的文件$ browser-sync start --server --files \"**\" 启动browser-sync start --server --port 3333 --files &quot;*.css,*.html,*.js&quot; start options1234567891011121314151617181920212223242526272829--help #输出使用信息--version #输出的版本号--browser #选择哪个浏览器应该是自动打开--files #文件路径看--exclude #文件模式忽视--server #运行本地服务器（使用您的CWD作为Web根）--index #指定哪些文件应该被用作索引页--extensions #指定文件扩展名回退--startPath #指定起始路径，打开浏览器--https #启用S​​SL地方发展--directory #显示服务器的目录列表--proxy #代理现有的服务器--xip #使用xip.io域路由--tunnel #使用公共网址--open #选择哪个URL是自动打开（本地，外部或隧道）--config #指定为BS-config.js文件的路径--host #指定主机名使用--logLevel #设置记录器输出电平（沉默，信息或调试）--port #指定要使用的端口--reload-delay #以毫秒为单位的时间延迟重装事件以下文件的变化--reload-debounce #限制在浏览器中的频率：刷新事件可以被发射到连接的客户机--ui-port #指定端口的UI使用--no-notify #禁用浏览器的通知元素--no-open #不要打开一个新的浏览器窗口--no-online #强制离线使用--no-ui #不要启动用户界面--no-ghost-mode #禁用幽灵模式--no-inject-changes #刷新上的每个文件更改--no-reload-on-restart #不要自动重新加载在重新启动所有浏览器","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"gitlab3","slug":"gitlab3","date":"2020-12-17T07:30:43.000Z","updated":"2021-02-09T10:27:24.991Z","comments":true,"path":"2020/12/17/gitlab3/","link":"","permalink":"http://yoursite.com/2020/12/17/gitlab3/","excerpt":"","text":"gitlab 分支策略 考虑到gitlab一般在企业内部使用，一般不存在社区开发者，所以在管理上不会采用github的upstream/origin双仓库模式。gitlab下，开发者们面向一个仓库进行提交即可； 设置对分支的保护权限 顾名思义，分支的权限必不可少，它可以约束开发者们的提交行为和提交策略。避免失误操作将未测试过的代码强制提交到生产分支；developer可以不关心； issue与Milestones issue可以理解为一个最小原子的任务，多个任务组成一个 milestones；Milestones 可以理解为某个时间区间内的任务集；一个Milestones可包含多个issue； 当该Milestones中所有issue完成，则标志着此Milestones的结束； 创建issue和mr 创建一个issue 关联一个mr branch name branch name 会以issue的序号开始，然后抓取title中的英文和数字做连接。 可采用index-categroy-content-[username]-[time]的自定义方式，括号部分可选 category feature bugfix chore enhance content，一到三个词简述任务 username，任务认领人 time，创建分支的时间，一般 201217或者1225 source 基于什么分支创建当前分支，feature/chore/enhance选择dev-0.3, bugfix选择env-dev 提交代码流程 123456git fetch # 获取issue关联的分支名git checkout -b 6-feature-pivotDrill origin/6-feature-pivotDrill # 基于远端新建一个本地开发分支git rebase dev-0.3 # 在开发过程中，不定时rebase 宿主分支，防止版本隔断git push origin 6-feature-pivotDrill # 提交至远程映射# 通知maintainer完成代码合并，并关闭issue commits规范&#39;type(module) some desc&#39; 1234567891011121314151617181920212223242526type = [ \"build\", // 构建执行 \"chore\", // 构建工具相关 \"ci\", // CI 相关 \"docs\", // 文档更新 \"feat\", // 新功能 \"fix\", // bug 修复 \"perf\", // 性能优化 \"refactor\", // 功能重构 \"release\", \"revert\", // 回滚操作 \"style\", // 样式变动 \"test\", // 单元测试]moduele = [ // 以davinci为例,只列出前端模块 \"project\", \"dashboard\", \"display\", \"widget\", \"schdule\", \"view\", \"source\", \"user\"] review代码的参考标准 格式化后的代码，在vscode中安装prettier工具，设置ctrl+s默认对当前页进行prettier格式化； 所有commits必须要关联issue，如果没有issue要新建issue然后关联mr（merge request），基于当前mr提交代码； 原则上，不能有肉眼可见的bug，一般review代码时会进行简单的测试； 其他规则（代码规范） 代码规范 原则上，所有新提交的代码参考项目代码风格即可。简述为下面几个方面 原则上，变量名含义精准，（ps：严禁全局作用域中出现单字符命名空间；） 不要求一定要加注释或者不加注释，我们的愿景是能够书写无注释就能看懂的代码。根据业务逻辑难易程度，自行决定。 尽量英文注释； 不建议提交大量重复代码，须做好代码的抽象复用； 尽量使用被主流浏览器支持的的es规范书写代码，原则上新es规范下已有的工具类和函数，不重复造轮子； 其他涉及html/css/javascript相关的推荐规范会渐进式纳入规范集；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab2","slug":"gitlab2","date":"2020-12-16T10:41:24.000Z","updated":"2020-12-18T05:41:03.023Z","comments":true,"path":"2020/12/16/gitlab2/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab2/","excerpt":"","text":"label 标签组 标签组的意义就是定义一次，多个项目统一使用 Platform 前端还是后端，ios 还是 android angular node Problems 目前产品中存在的问题，以及该问题的优先级程度 bug： 常规bug security： 安全漏洞 production： 涉及到生产环境 Mindless 影响较小的任务，比如更改文件夹目录，适配规范 chore legal Experience 影响用户体验，或者用户对产品的理解. These can be both opportunities and “UX bugs”. copy design ux: User Experience Environment 服务器环境，开发环境，生产环境或者测试环境 staging test Feedback 待确认的问题，比如一些拍脑袋的需求；或者某个需求我们还没决定怎么实现 discussion question： 还没到需要讨论的情况 rfc Improvements 现有功能或基础架构上的迭代。 enhancement: 现有模块有更高的完成度 optimization: 现有功能代码层面的重构，或者交互流程上的梳理 Additions 新功能，新页面 feature Pending 现在不好说，未来肯定有结果，可能做成功， 可能做不成； in progress： 进行中的需求 watchlist： 先拖着的需求，有可能就拖掉了 Inactive 无需采取任何行动或可能采取任何行动。该问题已解决，可以通过其他问题更好地解决； invalid： 无效的 wontfix： 不会修复 duplicate： 重复 on hold： 等待候听","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab 使用","slug":"gitlab-使用","date":"2020-12-16T06:52:39.000Z","updated":"2020-12-18T05:43:13.922Z","comments":true,"path":"2020/12/16/gitlab-使用/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"软件开发阶段 软件开发十个阶段在gitlab中对应的管理方式方法 IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了Mattermost 它类似一个聊天工具。 ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在工单追踪器issue tracker中帮助你去提升这个点子。 PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用工单看板Issue Board。 CODE： 现在，当一切准备就绪，我们可以开始写代码了。 COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。 TEST： 通过GitLab CI，我们可以运行脚本来构建和测试我们的应用。 REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行代码复审code review以及批准。 STAGING：： 预发布环境。 PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了。 FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 Cycle Analytics来对当前项目中关键的部分进行的反馈 issue 和 milestone milestone里程碑，用来标识\b阶段性目标， 对目标进行细化，化整为零一个个的issues，然后根据每个issues的紧急程度选择性的完成。等所有issues解决完之后 就标志着阶段性目标已完成； 使用方法 把实际问题转化为issue，这些问题可以标记为正在解决和计划解决； milestone对应着阶段性项目计划，然后细分为多个issues，而且可以指定完成时间，gitlab会自动生成完成进度情况概略图。 issues也可以是一个建议，共给大家一起讨论； milestone 和issue建立时我们通常可以对问题进行简单描述，并且记录问题的解决过程，包括他人提出的疑问也可以在这里记录，后期可以随时查看； 创建milestone 可以在项目开始前创建milestone，后面建issues时关联它，也可以先建issues，后期由项目负责人建milestone，然后把所有issues关联过来； 创建一个名字 简单描述，简述创建的原因，这个里程碑最终的目的，编辑的时候可以直接贴图，也可以添加附件（支持markdown格式，可以预览） 指定计划的完成时间； 新建issues 一个issues表示一个功能、一个bug、一个建议; 新建议题很简单，标题+描述+计划时间+指定人+里程碑，里程碑一定要指定一下，还可以加标签。 功能：里程碑的细分，尽量小，方便merger时的代码审核； bug：解决程序中存在的某些问题； 建议：可以作为一个讨论交流区，也可以实现它; 一个issues 对应一个指定人，一个git 分支；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"nginx","slug":"test","date":"2020-12-09T14:19:03.750Z","updated":"2020-12-18T05:42:10.435Z","comments":true,"path":"2020/12/09/test/","link":"","permalink":"http://yoursite.com/2020/12/09/test/","excerpt":"","text":"配置hexo到阿里云 网上大多数教程问题不大，额外需要注意修改一些文件的写入权限 1234567# 将post-receive 设置为可执行文件chmod +x ~/hexo.git/hooks/post-receivecd ~# 设置博客源地址文件夹权限，不然git hooks写入不了，Unable to unlink 就是这种原因sudo chmod -R 777 /home/www/hexo","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo","slug":"hello-world","date":"2020-06-04T03:45:32.772Z","updated":"2020-12-18T05:41:36.853Z","comments":true,"path":"2020/06/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy test12345function helloworld() &#123; return 'hello world'&#125;console.log(helloworld); More info: Deployment","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"},{"name":"net","slug":"net","permalink":"http://yoursite.com/categories/net/"},{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"},{"name":"rust","slug":"rust","permalink":"http://yoursite.com/categories/rust/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"},{"name":"graphics","slug":"graphics","permalink":"http://yoursite.com/categories/graphics/"},{"name":"algebra","slug":"algebra","permalink":"http://yoursite.com/categories/algebra/"},{"name":"algo","slug":"algo","permalink":"http://yoursite.com/categories/algo/"},{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/categories/webgl/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/categories/canvas/"},{"name":"language","slug":"language","permalink":"http://yoursite.com/categories/language/"},{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"},{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"},{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}