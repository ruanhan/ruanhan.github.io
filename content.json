{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-08-20T05:55:31.000Z","updated":"2020-08-20T07:19:22.806Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-20T05:58:38.000Z","updated":"2020-08-20T07:18:21.424Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java基础","slug":"java基础","date":"2021-07-31T14:31:01.000Z","updated":"2021-08-02T14:30:00.440Z","comments":true,"path":"2021/07/31/java基础/","link":"","permalink":"http://yoursite.com/2021/07/31/java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 快速开始编译1234567# HelloWorld.java # 类名要与文件名一致public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(\"hi java\"); &#125;&#125; 123$&gt; javac Hello.java$&gt; java Hello.class# hi java idea安装12345create new projectjavajdk11 Groovynextnext 类型转换1234int bigRandom = (int)(Math.random() * (rangeEnd * 100));// (int)(...)// 将。。。 转为int类型 I/O12Scaner in = new Scanner(System.in);int guess = in.nextInt(); // 获取 数组 相同类型的变量的集合，指定数组包含元素个数。 12345数组元素类型[] 变量名 = new 数组元素类型[数组长度]int[] intArray = new int[9];double[] doubleArray = new double[100];// 对于没有初始化的数组类型，初始值都是其类型的初始值，比如int类型就是0 通过 变量名[索引] , 可读写 for循环1234MerchandiseV2[] all; for(MerchandiseV2 m:all) &#123; // 将all里面的值，遍历赋给m&#125; 2. OO类创建类123456789// 类 public class 开头，类名和文件名一致public class Merchandise&#123; // 类中可以定义描述这个类的属性的变量，称为成员变量； String name; String id; int count; double price;&#125;// Merchandise 类，其实就是创建了一个模版，描述了一种我们需要的数据类型 类的实例/对象 从数据类型的角度来看，类就是自己创建了一种新的数据类型，类也叫“自定义类型”。一个java程序中不允许类同名； 1Merchandise m1 = new Merchandise(); 使用new操作符，创建类的实例 使用new创建一个类实例之后，类中定义的每种变量会被赋以其类型的初始值； 使用一个同类型的对象变量（m1），可以指向并操作这个实例。 引用类型 引用类型包含两个部分信息：类型和实例，每个引用（引用数据类型的变量，m1）都是指向某个类的一个实例/对象（instance/object），不同类型的引用在java世界里面都是引用的类型信息在创建时就已经确定，可以通过引用赋值，让其指向不同的实例。比如m1 = m5; 引用数据类型的值还是一个地址，需要通过“二级跳”找到实例； 所有new出来的实例，都会放在heap上。引用里面存放的就是指向实例的地址； 12345678public class SuperMaret &#123; public static void main(String[] args) &#123; // new People() 创建一个地址，把地址赋值给people； People people = new People(); System.out.println(people); &#125;&#125;// People@5e025e70 引用和类以及对象的关系 引用必须是、只能是一个类的引用 引用只能指向其所属的类型的类的对象 相同类型的引用之间可以赋值 只能通过指向一个对象的引用，来操作一个对象，比如访问某个成员变量； null null是引用类型的缺省值，null代表空，不存在，可以读作空。引用类型的数组创建出来，初始值都是空 null带来的问题 大名鼎鼎的NullPointerException 如果不确定，使用前要先判断引用是不是空 1234567891011121314public class SuperMaret &#123; public static void main(String[] args) &#123; People[] people = new People[9]; for (int i = 0; i &lt; people.length; i++) &#123; if (i % 2 == 0) &#123; people[i] = new People(); &#125; &#125; ; for (int i = 0; i &lt; people.length; i++) &#123; System.out.println(people[i].age);//NullPointerException &#125; &#125;&#125; 像自定义类型一样使用类 类就是一种自定义类型 在类定义中可以使用类，创建类的引用 在类定义中，甚至可以使用类自己的类创建引用 引用类型的缺省值是null，一个类定义中如果有引用，创建出来的实例，其缺省值是null 123456public class Phone &#123; Screen screen; Mainboard mainboard; double price; boolean lock;&#125; 静态变量/类变量 VIP的折扣作为一个成员变量，hin浪费 123public class MerchandiseV2WithStaticVariable &#123; public static double DISCOUNT_FOR_VIP = 0.95&#125; 静态变量使用static修饰符 静态变量如果不赋值，Java也会给它赋以其类型的初始值 静态变量一般使用全大写字母加下划线分割，这是一个习惯用法； 所有的代码都可以使用静态变量，只要根据防范控制符的规范，这个静态变量对其可见即可；静态变量不会随着对象创建而创建，它是一个类变量。一经改动，影响全局。 比如public的静态变量，所有的代码都可以使用它； 如果没有public修饰符，只能当前包的代码能使用它； 1234567import com.MerchandiseV2WithStaticVariable // 引入类public class M &#123; public static void main(String[] args) &#123; // 引入类之后，直接用 DISCOUNT_FOR_VIP System.out.println(DISCOUNT_FOR_VIP) &#125;&#125; 包与类访问符 为了避免类在一起混乱，可以把类放在文件夹里。这时就需要用package语句告诉java这个类在哪个package中，class名与文件名一致，文件所在的路径就是package名；package语句要和源文件的目录完全对应，大小写要一致。 package读作包，一般来说，类都会在包里，而不会直接放在跟目录； 不同的包可以有相同名字的类 一个类只能有一个package语句，如果有package语句，则必须是类的第一行有效代码（也就是说要放在顶部） 123456-a -b -c MyClass.java # MyClass的package就是 a.b.c import 当使用另一个包里类的时候，需要带上包名 每次使用都带包名很繁琐，可以在使用类的上面使用import语句， import语句可以有多个 如果需要import一个包中的很多类，可以使用*通配符 1import com.phone.parts.* 属性访问修饰符 可见性修饰符用在类，成员方法，构造方法，静态方法和属性上，其可见性的范围是一样的； 看代码，学习可见性修饰符： public public：全局可见 缺省： 当前包可以见 private： 当前类可以见 private理解访问修饰符：不只是为了限制不让人用，更为了有规矩才成方圆。成员变量应该是private的，不需要让外部使用的方法应该都是private的； 类，静态方法，静态变量，成员变量，构造方法，成员方法都可以使用访问修饰符 成员变量应该都声明为private 如果要读写这些成员变量，最好使用get set方法，这些方法应该是public的，这样做的好处是，如果有需要，可以通过代码，检查每个属性值是否合法； 构造方法如果是private，那么就只有当前的类可以调用这个构造方法； 有些时候，会把所有的构造方法都定义成private的，然后使用静态方法调用构造方法 同样的，这样的好处是可以通过代码，检查每个属性值是否合法； 12345678910111213public class Demo &#123; private Demo (String name, String id)&#123; this.name = name; this.id = id; &#125; // 使用静态方法调用构造方法，检查每个属性值是否合法； public static Demo createMerchandise(String name, String id) &#123; if (name == \"\" || id == \"\") &#123; return null &#125; return new Demo(name, id); &#125;&#125; public方法类似一种约定，既然外部的代码可以使用，就意味着不能乱改，比如签名不能改之类的； 对于private的方法，因为类外面调不到，所以无论怎么改，也不会影响（直接影响）类外面的代码 protected protected = default + 继承者们可见 覆盖可以，但是不能让可见性更低 构造方法可以是protected，但是如果是private，子类就不可以覆盖了； 如果父类只有一个private的构造方法，相当于这个类不能有子类； 子类覆盖父类的方法，不可以用可见性更低的修饰符，但是可以用更高的修饰符， 原因是？ final final修饰符最见不得变化 final修饰类：不可被继承 final修饰方法： 不可被子类覆盖 final修饰变量：不可被修改，只能在构造函数里面或者声明变量时赋值。必须赋值一次且只能赋值一次；（这个最难理解） 构造方法不能用final修饰，（没有意义） final修饰引用, 锁定了引用，而不锁定引用指向的对象； 1private final MerchandiseV2 gift; debug设置断点，debug调试模式运行程序 断点（breakpoint）：可以让程序在调试模式停在某一行 程序调试标准动作 查看变量的值，展开实例看哪部成员变量的值 程序继续执行之step Over：执行一行 程序继续执行之step Out：继续执行直到遇到下一个断点或程序结束 执行任意代码之Evaluate Expression：在对话框输入代码，直接执行看结果值 条件断点：给断点设置条件，只有满足条件时，程序才会在该断点停住； Evaluate 在断点所在行处右键选择 Evaluate Expression，弹出Evaluate对话框；输入目标值点evaluate按钮直接计算出结果； condition 在断点右击弹出对话框，在Condition输入框输入表达式； m.soldPrice&gt;200; 那么当程序满足这一条件时，程序会停止住； 方法返回值 java中一个方法只能有一种返回值，如果不需要返回值则用void表示，用return 返回。 12345678910// 返回值如果是基本类型，则要类型完全相同，或者符合类型自动转换规则public class Apple&#123; public double getxxx()&#123; return 1.0 &#125; // 如果不符合规则，可以使用强制类型转换 public int get1xxx()&#123; return (int)(xxx) &#125;&#125; 参数类型 标识符(参数名) 123public double buy(int number)&#123; &#125; 参数与返回值是怎么传递的 参数与方法里面的局部变量可以认为是一样的东西，只是在方法调用之前，会用实参给参数的行参赋值； 发生在代码块里的，就让它留在代码块里。方法执行完毕，参数和方法的局部变量的数据就会被删除回收； 调用一个有返回值的方法时，就好像访问了一个成员变量； 方法里的代码并不能改变实参的值，方法里使用的参数相当于一个局部变量。使用方法前，会用实参给局部变量赋值； 1234567891011121314151617public void willOutsideValueChangePrime(int p)&#123; p = 10000;&#125;public void willOutsideValueChangeRef(type r)&#123; r = r1;&#125;//int pramPrime = 7;type r = new type();m.willOutsideValueChangePrime(pramPrime);// 内部实现相当于// int p = pramPrime;// int p = 10000;m.willOutsideValueChangeRef(paramRef);// 内部实现相当于// type r = paramRef; // r = r1; 这一点跟JavaScript类似，传参都是拷贝操作。要么值拷贝，要么拷贝地址； this 方法中参数与局部变量同名会怎么样, IDE会报错，参数和局部变量不能重名；javascript也是如此； 方法中隐藏着一个this自引用，指向调用这个方法的对象； 访问一个成员变量的完整形态，是”this.成员变量的名字” 总结 方法不是对象的一部分，它是类的一部分，每个对象可以给成员变量赋不同的值，但是无法让方法有不同的行为。同理，无论在一个类中定义多少方法，都不会让影响创建一个对象所占用的内存； 12345678// 递归public void makeEnoughForOneByOne(int count) &#123; boolean hasEnough = this.hasEnoughCountFor(count); if(!hasEnough) &#123; //递归调用自己，不用加this makeEnoughForOneByOne(count); &#125;&#125; 方法签名与重载12345public class MerchandiseV2&#123; public double buyOne()&#123;&#125; public double buyCount(int count)&#123;&#125; public double buyAsVIP(int count, boolean isVIP)&#123;&#125;&#125; 方法功能很类似，大部分同质化的代码 方法重载(overload) 方法签名： 方法名 + 依次参数类型，注意，返回值不属于方法签名。方法签名是一个方法在一个类中的唯一标识； 同一个类中方法可以重名，但是签名不可以重复，一个类中如果定义了名字相同，签名不同的方法，就叫做方法的重载 方法签名 1234567891011public class MerchandiseV2&#123; public double buyOne()&#123;&#125; public double buyCount(int count)&#123;&#125; public double buyAsVIP(int count, boolean isVIP)&#123;&#125;&#125;// 比如上面这个类，方法的签名依次是// buyOne()// buyCount(int)// buyAsVIP(int, boolean)// 方法签名不包括返回值，因为如果带返回值的话，编译器就很难决定要去调哪个方法啦；// 方法参数只看类型，不看参数名，参数类型相同也不行 方法重载 类中方法签名不能重复，但是方法名可以重复 123456789101112131415161718192021// 改写MerchandiseV2 使用方法重载public class MerchandiseV2&#123; public double buy()&#123; return buy(1) &#125; public double buy(int count)&#123; return buy(count, false) &#125; public double buy(int count, boolean isVIP)&#123; if (this.count &lt; count) &#123; return -1; &#125;; this.count -= count; double totalCost = count * soldPrice; if(isVIP) &#123; return totalCost * 0.95; &#125; else &#123; return totalCost; &#125; &#125;&#125; 重载的参数匹配规则 有了论斤卖的商品，数据编程double类型，有论整个卖，有散装称重卖的，事情开始复杂起来； 方法调用时，参数就不必完全类型一样，对于数字类型的参数，实参数可以自动类型转换成行参类型即可 重载时如果参数类型不完全匹配怎么样 如果重载的函数签名分别是 byte，short，int，long，float，doule类型的参数调用buy方法，哪个方法会被调用呢？ 无论是否重载参数类型可以不完全匹配的规则是“实参数可以自动类型转换成行参类型” 重载的特殊之处是，参数满足自动类型转换的方法有好几个，重载的规则是选择最“近”的去调用； 123456byte count = 11;v2.buy(count); // int// byte 往后找 ，顺序分别为 byte short int long float doublelong count1 = 11;v2.buy(count1); // double// long不能转化为int，只能往上找，就近转为double 构造方法：构造实例的方法 如果init方法能在对象创建的时候就自动被调用多方便； 自动调用的唯一的问题：调用哪个方法呢？ 构造方法（constructor）的语法 12345678910111213public class MerchandiseV2WithConstructor &#123; String name; String id; int count; double soldPrice; public MerchandiseV2WithConstructor(String name, String id, int count, double soldPrice) &#123; this.name = name; this.id = id; this.count = count; this.soldPrice = soldPrice; &#125;&#125; 构造方法的方法名与类名一样，而且构造方法没有返回值， 构造方法可以有参数，规则和语法于普通方法一样，参数传递给new语句后类名的括号方法； 如果没有显示的添加一个构造方法，java会给每个类都默认自带一个无参数的构造方法； 如果我们自己添加类的构造方法，java就不会给该类添加无参数的构造方法，这时候，就不能直接new一个对象不传递参数了； 所以我们一直都在使用构造方法，这也是为什么创建对象的时候类名后面要有一个括号的原因； 构造方法无法被点操作符调用或者在普通方法里调用，只能通过new语句在创建对象的时候，间接调用； 所以为何构造方法不能有返回值，因为有返回值也没有意义，new语句永远返回的是创建出来的对象的引用； 构造方法的重载和互相调用12345678910111213141516171819202122232425262728293031323334public class MerchandiseV2WithConstructor &#123; String name; String id; int count; // 构造方法执行前，会执行给局部变量赋初始值的操作 // 之前说过，所有的代码都必须在方法里，那么这种给成员变赋初始值的代码在哪个方法里？怎么看不到呢？ // 原来构造方法在内部变成了&lt;init&gt;方法， // 实际上是 public &lt;init&gt; ()&#123; // this.soldPrice = 1.1; // &#125; // 值得注意的是 构造方法也会 被封装到&lt;init&gt;里面； double soldPrice = 1.1; // 构造方法的重载与普通方法一样； public MerchandiseV2WithConstructor(String name, String id, int count, double soldPrice) &#123; this.name = name; this.id = id; this.count = count; this.soldPrice = soldPrice; &#125; // 在构造方法里面才能调用重载的构造方法，语法为this(实参列表) // 构造方法不能自己调用自己，这会是一个死循环 // 在调用重载的构造方法时，不可以使用成员变量。因为用语意上讲，这个对象还没有被初始化完成，处于中间状态； // 在构造方法里才能调用重载的构造方法时，必须是方法的第一行，后面可以继续有代码； public MerchandiseV2WithConstructor(String name, String id, int count) &#123; // this(), this指向的是其中一个构造函数 this(name, id, count, count+0.11); &#125; // 因为我们添加了构造方法之后，Java就不会再添加无参数的构造方法，如果需要的话，我们可以自己添加这样的构造方法 public MerchandiseV2WithConstructor()&#123; this(\"无名\".\"1\",0,1.1) &#125; &#125; 123456public class Demo &#123; public static void main(String [] args)&#123; // new 的时候直接传入参数，类的内部会调用构造函数执行初始化； LitteSuperMarket littleSuperMarket = new LitteSuperMarket(100, 19.11, \"1\", \"2\") &#125;&#125; 静态方法 没有this自引用的方法 1234567891011public class Demo&#123; public static double getVIPDiscount(LittleSuperMarket littleSuperMarket)&#123; // &gt;&gt; TODO 静态方法可以访问静态变量，包括自己类的静态变量和在访问控制符允许的别的类的静态变量； // 除了没有this，静态方法的定义和成员方法一样，也有方法名，返回值和参数 // 静态变量没有this自引用，它不属于某个实例，调用的时候也无需引用，直接用类名调用，所以它也不能直接访问成员； // 当然在静态方法里面，也可以自己创建对象，或者通过参数，获得对象的引用，进而调用方法和访问成员变量 // 静态方法只是没有this自引用的方法而已 double activeityDiscount = littleSuperMarket.activitDiscount; return DISCOUNT_FOR_VIP * activeityDiscount; &#125;&#125; 静态方法的重载 静态方法的重载和成员方法（实例方法）一样 12345678910111213141516public class Demo&#123; public static double getDiscount()&#123; return BASE_DISCOUNT; &#125;; public static double getDiscount(boolean isVIP)&#123; double svipDiscount = (isVip?VIP_DISCOUNT:1); return getDiscount() * svipDiscount; &#125;; public static double getDiscount(int svipLevel)&#123; double ret = getDiscount() * VIP_DISCOUNT; for(int i=0; i&lt;svipLevel; i++) &#123; ret *= SVIP_DISCOUNT; &#125; return ret; &#125;;&#125; 静态方法的重载也是一样，方法签名不同即可；同样返回值不算事方法签名 判断调用哪个方法，也是根据调用时参数匹配决定的； 静态代码块12345678public class Demo &#123; public static int base1; public static int base2; static &#123; base1 = 1; base2 = 2 &#125;&#125; 使用某个静态变量的代码块必须在静态变量后面，类似js预解析机制； 类的对象自己做事情 之前的代码，赋值的到处都是， 想一下到处复制代码的话，一旦有变化，就得到处改； 解决这个问题的关键是什么？成熟的类会说：成熟的类自己操作自己的成员变量。 把操作成员变量的代码放在类里 初始化成员变量 简单访问和设置成员变量的值（Java Bean） 专有的一些计算逻辑 用类定义成员变量，并把操作成员变量的代码都放在类里，就是封装； 可以集中管控，自己的成员变量别人不可以乱来，避免出现非法的状态，比如库存为负数； 代码逻辑可以共用，避免代码重复，修改的时候只需改一处； 封装的好，可以更好的抽象一类事物； 初始化成员变量 12Merchandise v2 = new Merchandise();v2.init(\"1\",\"2\",40,999.9); String类 String对象最重要的特点：不可变（immutable）不可变不可变，重要的事情说三遍，String用来存储字符的数据是private的，而且不提供任何修改内容的方法，所以String对象一旦生成，其内容就是完全不可能被修改的； 1234567891011121314151617181920212223public class LearnString &#123; public static void main(String[] args) &#123; String string = \"0123456789\"; System.out.println(string.length()); System.out.println(string.toLowerCase()); System.out.println(string.toUpperCase()); // string指向对象的内容并没有变化 System.out.println(string); System.out.println(string.charAt(1)); System.out.println(string.substring(5)); System.out.println(string.substring(1, 5)); &#125;&#125;100123456789012345678901234567891567891234 StringBuilder StringBuilder是一个非常方便的用来拼接和处理字符串的类，和String不同的是，它是可变的； 12345678910111213141516171819202122232425public class LearnStringBuilder &#123; public static void main(String[] args) &#123; // StringBuilder首先是可变的； // 而且对它进行操作的方法，都会返回this自引用。这样我们就可以一直点下去，对String进行构造； StringBuilder str = new StringBuilder(\"start\"); long longVal = 123456789; // append函数内部返回this，链式调用； str.append(true).append(\"abc\").append(longVal); System.out.println(str.toString()); System.out.println(str.reverse().toString()); System.out.println(str.reverse().toString()); System.out.println(str.toString()); System.out.println(str.delete(0, 4).toString()); System.out.println(str.insert(3, \"LLLLLL\").toString()); &#125;&#125;starttrueabc123456789987654321cbaeurttratsstarttrueabc123456789starttrueabc123456789ttrueabc123456789ttrLLLLLLueabc123456789 System取当前时间 12System.currentTimeMillis(); // hao miaoSystem.nanoTime(); // 纳秒 继承 子类继承父类的方法和属性 使用子类的引用可以调用父类的公有方法 使用子类的引用可以访问父类的共有属性 就好像子类的引用可以一物二用，既可以当作父类的引用使用，又可以当作子类的引用使用 1public class PhoneExtendsMerchandise extends Merchandise&#123;&#125; 继承的语法就是在类名后面使用extends加要继承的类名 被继承的类叫做父类，继承者叫子类 java只允许一个类有一个直接的父类，即所谓的单继承 没错，别的类也可以继承子类 子类继承父类的所有属性和方法 子类不能访问父类的private的成员（包括方法和属性） 子类对象藏着一个父类对象 另一种解决问题的思路：组合 继承和组合的区别 1234567public class PhoneHasAMerchandise &#123; // 除了继承，我们也可以在Phone中添加一个商品的引用； // 这样，我们也是可以实现类似的功能。 // 这种在自己的类里，使用别的类的两类之间的关系，我们叫做“has-a”,也称为组合； // 具体到我们这个例子，在我们用类构造的世界中，“Phone中有一个商品，但是Phone本身不是商品（划重点！）” private MerchandiseV2 merchandise;&#125; 1234567891011121314public class UsePhoneHasAMerchandise()&#123; public static void main(String[] args) &#123; merchandise = new MerchandiseV2(); PhoneHasAMerchandise phone = new PhoneHasAMerchandise(); phone.describePhone(); // 所有和商品相关的操作，先从Phone里获得商品的引用，然后再通过这个引用操作商品； phone.getMerchandise().describe(); // 如果我们想要让手机返回不一样的商品名字，比如加上手机厂商和型号，但是不容易 // 我们可以再每次修改手机的厂商和型号的时候，都去set一下商品的名字。繁琐，但是做得到； phone.getMerchandise().getName(); // 如果要限制购买的数量不超过5怎么办？ phone.getMerchandise().buy(100); &#125;&#125; 继承，其实表达的是一种“is-A”的关系，也就是说，在你用类的构造的世界中，“子类”是父类的一种特殊类别； 组合和继承，是拿到一个问题，设计相应的java类的时候，不得不面对的来自灵魂拷问 XX到底是YY的一种，还是只是组合了YY？ 手机到底是手电筒的一种，还是组合了一个可以当手电的闪光灯？ 如果要限制购买数量不超过5怎么办？ 首先，不能修改MerchandiseV2 这个类，否则你会限制所有商品一次购买的数量 其次，在现实情况下，这个类可能根本不受你控制，你无权修改其代码 在每次调用buy方法的地方做限制，是不行的； 你无法控制别人怎么用你的类； 而且会面临到处赋值代码的糟糕情况 如果说限制改成10个，所有复制的代码都要改，程序员都应该很懒，这不是一个程序员该做的事情； 在只能修改手机类的情况下，我们可以提供一个buyPhone的方法，实现限制购买数量的逻辑；但是这样并不能阻止别人像下面这样调用merchandise的buy方法，这个方法是会修改库存的，所以还是无法硬性的限制一次性购买； 我们来理清一下自己的核心诉求：针对手机，限制一次性购买的数量，必须限制死，必须不影响别的商品，必须只能改手机类的代码。这时候，组合就无能为力，继承可以发挥其应有的作用； 继承不是组合，继承也只是为了能简单的拿来父类的属性和方法，如果仅仅如此，原封不动拿来主义，组合也能做到。 继承也不是通过组合的方式来实现的，和组合相比，继承更像是“融合” 覆盖：子类想要一点不一样 覆盖才是继承的精髓和终极奥义 从覆盖的角度理解为什么使用方法读写属性，优于直接访问属性 为了避免代码重复，在子类里使用父类的buy和describe方法。如何在子类里，调用父类的方法？ 12345678910111213package com.tenon.supermarket;public class MerchandiseV2 &#123; public int count; public double soldPrice; public double buy(int count) &#123; if (this.count &lt; count) &#123; return -1; &#125; return this.count -= count; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.tenon.supermarket;public class Phone extends MerchandiseV2 &#123; private double screenSize; private double cpuHZ; private int memoryG; private int storageG; private String brand; private String os; private static int MAX_BUY_ONE_ORDER = 5; public Phone( String name, String id, int count, double soldPrice, double purchasePrice, double screenSize, double cpuHZ, int memoryG, int storageG, String brand, String os) &#123; this.screenSize = screenSize; this.cpuHZ = cpuHZ; this.memoryG = memoryG; this.storageG = storageG; this.brand = brand; this.os = os; this.setName(name); this.setId(id); this.setCount(count); this.setSoldPrice(soldPrice); this.setPurchasePrice(purchasePrice); &#125; public void setName(String name) &#123;&#125; public void setId(String id) &#123;&#125; public void setCount(int count) &#123;&#125; public void setSoldPrice(double soldPrice) &#123;&#125; public void setPurchasePrice(double purchasePrice) &#123;&#125; // &gt;&gt; TODO 通过使用父类方法签名一样，并且返回值也一样的方法，可以让子类覆盖掉父类的方法 // &gt;&gt; TODO 也就是说，子类并不是只能把父类的方法拿过来，并且可以通过覆盖来替换其中不适合子类的方法 // &gt;&gt; TODO // &gt;&gt; TODO 为什么使用方法读写属性，优于直接访问属性？ // &gt;&gt; TODO 属性是联动的，可能是有特殊意义的，所以直接给属性赋值是危险的，因为没有办法检查是否有意义， // &gt;&gt; TODO 也没法对这个修改做联动的修改 public double buy(int count) &#123; // todo 这个方法里代码大部分和父类一样，肯定有方法解决； if (count &gt; MAX_BUY_ONE_ORDER) &#123; return -2; &#125; if (this.count &lt; count) &#123; return -1; &#125; this.count -= count; return count * soldPrice; &#125;&#125; super: 和父类对象沟通的桥梁 子类对象可以认为有一个特殊的父类的对象，这个父类对象和子类对象之间通过super关键字来沟通 super用法 1234567891011public class Phone extends MerchandiseV2 &#123; public double buy(int count) &#123; if (count &gt; MAX_BUY_ONE_ORDER) &#123; return -2; &#125; if (this.count &lt; count) &#123; return -1; &#125; return super.buy(count); &#125;&#125; super是子类和父类交流的桥梁，但是并不是父类的引用 所以，super和this自引用不一样，不是简单可以模拟的（可以模拟的话不就成了组合了吗） 使用super可以调用父类的public属性，但是super不是一个引用； super的用法就像是一个父类的引用，它是继承的不一部分，像组合的那部分；但不是全部； super：调用父类的构造方法123456789101112131415public class Phone extends MerchandiseV2 &#123; public Phone( String name, String id, int count, double soldPrice, double purchasePrice, double screenSize, double cpuHZ, int memoryG, int storageG, String brand, String os) &#123; super(name,id,count,soldPrice*1.2,purchasePrice); &#125; 使用super调用父类的构造方法，必须是子类构造方法的第一个语句 可以使用表达式 super调用构造方法，不可以使用super访问父类的属性和方法，不可以使用子类成员变量和方法 可以使用静态变量和方法 都是方法； 父类和子类的引用赋值关系 父类引用可以指向子类对象，子类引用不可以指向父类的对象 可以进行强制类转换，如果类型不对，会出错 可以调用的方法，是受引用类型决定的； idea-&gt;navigate-&gt;type hierarchy 1234Object - MerchandiseV2 - Phone - ShellColorChangePhone 123456789101112131415public class RefernceAssign&#123; public static void main(String[] args)&#123; Phone ph = new Phone( \"phone\",\"001\",100,1999,999,4.5,3.5,4... ); // 子类的引用赋值给父类的引用，也就是说，父类的引用可以指向子类的对象；反之则不行，因为父类并没有子类的属性和方法； MerchandiseV2 m = ph; // 如果确定一个父类的引用指向的对象，实际上就是一个子类的对象（或者子类的子类的对象），可以强制类型转换； Phone aPhone = (Phone) m2; // 父类的引用，可以指向子类的对象，即可以用子类（以及子类的子类）的引用给父类的引用赋值 MerchandiseV2 ccm = new ShellColorChangePhone(); &#125;&#125; 因为子类继承了父类的方法和属性，所以父类的对象能做到的，子类的对象肯定能做到； 换句话说，可以在子类的对象上，执行父类的方法； 当父类的引用指向子类的实例，只能通过父类的引用，像父类一样操作子类的对象 也就是说“名”的类型，决定了能执行哪些操作 ph 和 m都指向同一个对象，通过ph可以调用getBrand方法；因为ph的类型是Phone，Phone里定义了getBrand方法； ph和m都指向同一个对象，但是通过m就不可以调用getBrand方法；因为m是MerchandiseV2 类型，MerchandiseV2里面没有定义getBrand方法； 静态方法继承 静态方法可以被继承；子类.静态方法，可以访问到父类的同名静态方法；但是签名和返回值要一致； 用引用调用静态方法没有覆盖； 使用引用调用静态方法，本身就是一种在规则边缘试探的用法，IDE都没提示。这些东西学了之后最好忘了，不是最佳实践； 多态 可以调用哪些方法，取决于引用类型。具体调用哪个方法，取决于实例所属的类是什么 覆盖的奥义 覆盖是多态里面最重要的一种形式 从this自引用角度，理解覆盖 12345LittleSuperMarket superMarket = new LittleSuperMarket();superMarket.getMerchandisOf(0).getName();superMarket.getMerchandisOf(10).getName();superMarket.getMerchandisOf(100).getName(); 虽然是用的父类的引用指向的不同类型的对象，调用getName方法时，实际执行的方法取决于对象的类型，而非引用的类型 也就是说，能调用哪些方法，是引用决定的，具体执行哪个类的方法，是引用指向的对象决定的； 这就是覆盖的精髓，覆盖是多态的一种，是最重要的一种； 以getName为例，父类里面有这个方法，所以肯定都可以调用，但是Phone覆盖了父类的getName方法； 之前我们使用子类的引用指向子类的对象，调用子类里覆盖父类的方法，比如getName，执行的是子类的getName方法，我们觉得很自然； 这里变换的是，我们用父类的引用指向子类的对象，调用被子类覆盖的方法，实际执行的还是子类里的getName方法； 我们用父类的引用指向一个Phone的实例，并调用getName方法时，实际调用的就是Phone类里定义的getName方法； 如果子类里没有覆盖这个方法，就去父类里找，父类里没有，就去父类的父类找，反之只要能让一个引用指向这个对象； 就说明这个对象肯定是这个类型或者其子类的一个实例（否则赋值会发生ClassCaseException），总归有父类兜底； 12345678public class polymorpismAppMainComplex &#123; public static void main(String[] args) &#123; LitterSuperMarket superMarket = new LitterSuperMarket(); superMarket.getMerchandisOf(0).describe(); superMarket.getMerchandisOf(10).describe(); superMarket.getMerchandisOf(100).describe(); &#125;&#125; 一个复杂的例子 1234// MerchandiseV2.javapublic void describe()&#123; System.out.println(calculateProfit())&#125; MerchandV2 里的describe方法，调用了calculateProfit方法； 12345// Phone.javapublic void describe()&#123; sout(\"本手机下架\"); super.describe();&#125; Phone的describe方法，覆盖了直接父类MerchandiseV2里的describe方法，并且使用super调用了父类的describe方法； 1234567891011// ShellColorChangePhone.java@Overridepublic void describe&#123; super.describe(); sout(enableShellColorChange);&#125;@Overridepublic double calculateProfit()&#123; // TODO 促销，提供10个返点 return super.calculateProfit() + super.getPurchasePrice() * 0.1;&#125; ShellColorChangePhone里的describe方法，覆盖了直接父类Phone里的describe方法，并且使用super调用了父类的describe方法。更复杂的是，ShellColorChangePhone还覆盖了间接父类MerchandiseV2 里的 calculateProfit方法； 总结 无论一个方法是使用哪个引用被调用的，“它都是在实际的对象上执行的”。执行的任何一个方法，都是这个对象所属的类的方法。 如果没有，就去父类找，再没有，就去父类的父类找，依次寻找，直到找到； 换个角度理解，我们一直说子类里又一个（特殊的）父类的对象，这时候，这个特殊的父类的对象里的this自引用，是子类的引用； 那么自然的，即使是在继承自父类的代码里，去调用一个方法，也是先从子类开始，一层层继承关系的找； 这也是Java选择单继承的原因，在多继承的情况下，如果使用不当，多态可能会非常复杂，以至于使用的代价超过其带来的好处； 多态里更多的语法点 静态多态： 重载Overload 动态多态： 覆盖Override 勿忘初心：程序的执行就是找到要执行的代码，并且知道执行的代码能访问哪些数据，数据从哪里来。多态和核心问题就是：要调用哪个类的哪个方法，这个方法用到的数据（this引用）是谁 1234567891011121314151617181920212223242526272829303132333435package com.tenon.supermarket;public class MerchandiseTest &#123; // todo 之前重载的时候，参数是用的自定义类型。现在理解了父类和子类的引用赋值关系，重载又多了一层复杂性 public void testMerchandiseOverload(MerchandiseV2 me) &#123; System.out.println(\"参数为MerchandiseV2的testMerchandiseOverload\"); &#125; public void testMerchandiseOverload(ShellColorChangePhone shellColorChangePhone) &#123; System.out.println(\"参数为ShellColorChangePhone的testMerchandiseOverload\"); &#125; public void testMerchandiseOverload(String str) &#123; System.out.println(\"参数为String的testMerchandiseOverload\"); &#125; public void testMerchandiseOverload(Phone ph) &#123; System.out.println(\"参数为Phone的testMerchandiseOverload\"); &#125; public void testMerchandiseOverloadNotExactlyMatchType(MerchandiseV2 me) &#123; System.out.println(\"参数为MerchandiseV2的testMerchandiseOverloadNotExactlyMatchType\"); &#125; ; public void testMerchandiseOverloadNotExactlyMatchType(Phone me) &#123; System.out.println(\"参数为Phone的testMerchandiseOverloadNotExactlyMatchType\"); &#125; ; public void testMerchandiseOverloadNotExactlyMatchType(String me) &#123; System.out.println(\"参数为String的testMerchandiseOverloadNotExactlyMatchType\"); &#125; ;&#125; 123456789101112131415161718192021222324252627package com.tenon;import com.tenon.supermarket.MerchandiseTest;import com.tenon.supermarket.MerchandiseV2;import com.tenon.supermarket.Phone;import com.tenon.supermarket.ShellColorChangePhone;public class Main &#123; public static void main(String[] args) &#123; // write your code here MerchandiseV2 m; MerchandiseTest merchandiseTest = new MerchandiseTest();// 重载调用哪个方法，和参数的引用类型相关，和引用实际指向的类型无关； merchandiseTest.testMerchandiseOverload(m); merchandiseTest.testMerchandiseOverload((Phone) m); merchandiseTest.testMerchandiseOverload((ShellColorChangePhone) m); // 甚至是null也可以，但是要用强制类型转换，告诉java这个类型是什么，否则找不到一个唯一的方法去调用。 // 重载的参数类型，相同位置，不一定要有继承或者兼容的关系，完全freestyle merchandiseTest.testMerchandiseOverload((String) null); // 引用本身是null没关系，确定调用哪个方法只需要引用的类型，这叫做静态多态，即在编译器就知道该调用哪个方法； m = null; merchandiseTest.testMerchandiseOverload(m); &#125;&#125; 1234参数为MerchandiseV2的testMerchandiseOverload参数为Phone的testMerchandiseOverload参数为ShellColorChangePhone的testMerchandiseOverload参数为String的testMerchandiseOverload 如果引用类型没有完全匹配的，则会根据继承关系，沿着参数当前类型，向下撸； 重载总结 静态多态，调用的方法和参数实际指向的对象无关，只和引用本身的类型相关； 因为调用时参数类型是确定的，所以，在编译期间就可以明确的知道哪个方法会被调用。如果有多种可能，则会编译错误； 如果没有类型完全匹配的候选，则根据类型的继承关系向下撸着找。找到最贴切参数类型的那个方法； 无论是静态方法，还是成员方法，重载寻找方法的顺序是一样的； java没有多继承，（先贤的馈赠，保护了发际线）； instanceof instanceof操作符，可以判断一个引用指向的对象是否是某一个类型或者其子类；是则返回true，否则返回false 如果引用是null，则肯定返回false 12345678910if (m instanceof Phone) &#123; // 先判断，再强制类型转换，比较安全 Phone ph = (Phone)m; sout(\"\")&#125;if (m instanceof ShellColorChangePhone) &#123; // 先判断，再强制类型转换，比较安全 Phone ph = (ShellColorChangePhone)m; sout(\"\")&#125; 万类之组：Object类 所有的类，都简洁或者直接的继承自Object类 Object类中的方法 Object类中的引用 toString方法 equals 和 hasCode Class类 Class类是代表类的类，每个Class类的实例，都代表了一个类 1234567891011121314151617181920212223242526272829import com.tenon.supermarket.MerchandiseV2;import java.lang.reflect.Field;import java.lang.reflect.Method;public static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException &#123; MerchandiseV2 m = new MerchandiseV2(); Class clazz = m.getClass(); // 通过一个类的Class 实例，可以获取一个类所有的信息，包括成员变量，方法，等 Field countField = clazz.getField(\"count\"); Field nameField = clazz.getField(\"soldPrice\"); // 变长参数和它的等价形式 Method equalsMethod = clazz.getMethod(\"equals\", Object.class); Method buyMethod = clazz.getMethod(\"buy\", int.class); System.out.println(clazz.getName()); System.out.println(clazz.getSimpleName()); System.out.println(countField); System.out.println(nameField); System.out.println(equalsMethod); System.out.println(buyMethod); &#125;// com.tenon.supermarket.MerchandiseV2// MerchandiseV2// public int com.tenon.supermarket.MerchandiseV2.count// public double com.tenon.supermarket.MerchandiseV2.soldPrice// public boolean java.lang.Object.equals(java.lang.Object)// public double com.tenon.supermarket.MerchandiseV2.buy(int) 反射 使用反射（reflection）访问属性 使用反射访问方法 使用反射访问静态方法和属性 使用反射访问private的方法和属性 反射是什么 12345// 另外一种获得Class实例的方法，直接类点名MerchandiseV2 m100 = superMarket.getMerchandiseOf(100);Class clazz = MerchandiseV2.class;Field countField = clazz.getField(\"count\");countField.get(m100); // 相当于 m100.count;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"product","slug":"product","date":"2021-07-02T01:54:30.000Z","updated":"2021-07-02T01:54:30.337Z","comments":true,"path":"2021/07/02/product/","link":"","permalink":"http://yoursite.com/2021/07/02/product/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DDD","slug":"DDD","date":"2021-06-30T06:18:04.000Z","updated":"2021-06-30T10:13:33.815Z","comments":true,"path":"2021/06/30/DDD/","link":"","permalink":"http://yoursite.com/2021/06/30/DDD/","excerpt":"","text":"如果对开发的业务领域没有清晰的定义和边界，没有设计系统的领域模型，而仅仅跟着所谓的需求不断开发功能，一旦需求来自多个方面，就可能发生需求冲突，或者随着时间的推移，前后功能也会发生冲突；这时越是试图弥补这些冲突，就越是陷入更大的冲突之中； 产品经理的需求零零散散，不断变更。工程师在各处代码中寻找可以实现这些需求变更的代码，修修补补。软件只有需求分析，并没有真正的设计，系统没有一个统一的领域模型维持其内在的一致性。功能特性并不是按照领域模型内在的逻辑设计，而是按照各色人等自己的主观想象设计。项目时间一长，各种困难重重，需求不断延期，bug不断，管理者考虑是不是要推到重来，而程序员则考虑要不要跑路； 1. 领域模型模式1.1 事务脚本模式事务脚本的模式典型就是Controller-&gt; Service -&gt; Dao 这样的程序设计模式。 Controller封装用户请求，根据请求参数构造一些数据对象调用Service， Service里面包含大量业务逻辑代码，完成对数据的处理，期间可能需要通过DAO从数据库中获取数据，或者将数据写入数据库中； 举例说明 请求走controller，controller调service 的 calculateRecongnition方法, 入参是 合同ID，该方法是为了计算确认收入。 Service根据合同ID调DAO；取得合同详情， 然后根据合同详情，得到产品类型 在Service层，通过产品类型计算收入，然后将结果通过DAO存入数据库； 问题： 不同产品类型收入的计算方法不同，如果修改计算方法，或者增加新产品类型的支持，都需要修改这个Service类； 随着业务不断复杂， 这个类会变得越来越难以维护； 由于事务脚本模式中，Service， DAO 这些对象只有方法，没有数值成员变量，而方法调用时传递的数值对象没有方法，因此事务脚本又被称为贫血模型； 1.2 领域模型在领域模型模式下，业务逻辑围绕领域模型设计，比如收入确认是和合同强相关的，是合同对象的一个职责，那么合同对象就应该提供一个calculateRecognition方法计算收入； 领域模型中的对象和事务脚本中的对象有很大的不同，比如事务脚本中也有合同Contract这个对象，但是这个Contract只包含合同的数据信息，不包含和合同有关的计算逻辑，计算逻辑在Service类里； 而领域模型的对象则包含了对象的数据和计算逻辑，比如合同对象，（包含合同数据，合同相关的计算） 计算收入的请求直接提交给合同对象Contract，这个时候，就无需传递合同ID，因为请求的合同对象就是这个ID的对象。 合同对象聚合了一个产品对Product，并调用这个product的calculateRecognition方法，把合同对象传递过去。不同产品关联不同的收入确认策略recognitionStrategy，调用recongnitionStrategy的calculateRecognition,完成收入对象revenueRecognition的创建，也就完成了收入计算； 这里的Contract和Product都是领域模型对象，领域模型是合并了行为和数据的领域的对象模型，通过领域模型对象的交互完成业务逻辑的实现，也就是说，设计好了领域模型对象，也就设计好了业务逻辑实现。和事务脚本被称作贫血模型相对应的，领域模型也被称为充血模型； 对于复杂的业务逻辑实现来说，用领域模型模式更有优势，特别是在持续的需求变更和业务迭代过程中，把握好领域模型，对业务逻辑本身也会有更清晰的认识。使用领域模型增加新的产品类型的时候，就不需要修改现有的代码，只需要扩展新的产品类和收入策略类就可以了； 在需求变更过程中，如果一个需求和领域模型有冲突，和模型的定义以及模型间的交互逻辑不一致，那么很有可能这个需求本身就是伪需求，很多看似合理的需求其实和业务的内在逻辑是有冲突的，这样的需求也不会带来业务的价值，通过领域模型分析，可以识别出这样的伪需求，使系统更好地保持一致性； 1.3 领域驱动设计 领域是一个组织所做的事情以及其包含的一切，通俗点，组织的业务范围和做事方式，也是软件开发的目标范围，比如对于淘宝这样一个以电子商务为主要业务的组织，C2C电子商务就是它的领域。 领域驱动设计就是从领域出发，分析领域内模型及其关系，进而设计软件系统的方法； 如果对C2C 电子商务这个领域进行建模设计，这个范围就太大了，不知道该如何下手。 子域 所以通常的做法是把整个领域拆分成多个子域，比如用户，商户，订单，库存，物流，发票等。 界限上下文 强相关的多个子域组成一个界限上下文。界限上下文是对业务领域范围的描述，对于系统实现而言，可以想象成相当于是一个子系统或者一个模块， 界限上下文和子域共同组成组织的领域； 不同的界限上下文，也就是不同的子系统或者模块之间会有各种的交互合作。如何设计这些交互合作呢？DDD使用上下文映射图 在DDD中，领域模型对象也被称为实体，每个实体都是唯一的，具有一个唯一标识，一个订单对象是一个实体，一个产品对象也是一个实体，订单ID 或者产品ID是它们的唯一标识。实体可能会发生变化，比如订单的状态会变化，但是它们的唯一标识不会变化； 实体设计是DDD的核心所在，通过业务分析，识别出实体对象，然后通过相关的业务逻辑设计实体的属性和方法。这里最重要的，是要把握住实体的特征是什么，实体应该承担什么职责，不应该承担什么职责，分析的时候要放在业务场景和界限上下文中，而不是想当然认为这样的实体就应该承担这样的角色； 事实上，并不是领域内的对象都应该被设计为实体，DDD推荐尽可能将对象设计为值对象，比如像住址这样的对象就是典型的值对象，也许减灾低智商的房子可以被当做一个实体，但是住址仅仅是对房子的一个描述，像这样仅仅用来做度量或描述的对象应该被设计为值对象； 值对象的一个特点是不变性，一个值对象创建以后就不能再改变了，如果地址改变了，那就是一个新地址，而一个订单实体则可能会经历创建、待支付、已支付、待发货、已发货、。。。 领域实体和界限上下文包含了业务的主要逻辑，但是最终如何构建一个系统，如何将领域实体对外暴露，开发出一个完整的系统。事实上，DDD支持各种架构方案，比如 分层架构 领域实体被放置在领域层，通过应用层对领域实体进行包装，最终提供一组访问接口，通过接口层对外开放； 六边形架构是 DDD中比较知名的一种架构方式，领域模型通过应用程序封装成一个相对比较独立的模块，而不同的外部系统则通过不同的适配器和领域模型交互，比如可以通过HTTP接口访问领域模型，也可以通过Web Service或者消息队列访问领域模型，只需要为这些不同的访问接口提供不同的适配器就可以了； 领域模型本身，通过领域实体及其交互完成业务逻辑处理才是DDD的核心目标，至于是不是用了CQRS，是不是事件驱动，有没有事件溯源，并不是DDD的核心； 小结 如果一个人有多年领域经验，那么必然对领域模型设计有更深刻的认识，把握好领域模型在不断的需求变更中演进，使系统维持更好的活力，并因此体现自己真正的价值； 2. 组件设计原则2.1 组件内聚原则 组件内聚原则主要讨论哪些类应该聚合在同一个组件内，以便组件能够提供相对完成的功能，又不至于太过庞大，具体设计，可以遵循以下三个原则 复用发布等同原则 软件复用的最小粒度应该等同于其发布的最小粒度，也就是说，如果你希望别人以怎样的粒度复用你的 软件，你就应该以怎样的粒度发布你的软件。 组件是软件复用和发布的最小粒度软件单元，这个粒度既是复用的粒度，也是发布的粒度； 做好版本号管理 主版本.次版本.修订号 主版本号升级，表示组件发生了不向前兼容的最大修订； 次版本升级，表示组件进行了重要的功能修订或者bug修复，但是组件是向前兼容的 修订号升级，表示组件进行了不重要的功能修订或者bug修复 共同封闭原则 应该将那些会同时修改，并且为了相同目的而修改的类放到同一个组件中。而将不会同时修改，并且不会为了相同目的而修改的类放到不同的组件中； 组件的目的虽然是为了复用，然而开发中常常引发问题的，恰恰在于组件本身的可维护性。如果组件在自己的生命周期中必须经历各种变更，那么最好不要涉及其他组件，相关的变更都在同一个组件中。这样，当变更发生的时候，只需要重新发布这个组件就可以，而不是一大堆组件都受到牵连； 也许将某些类放入这个组件中对于复用是便利的，合理的，但如果组件的复用与维护发生冲突，比如这些类将来变更和整个组件将来的变更是不同步的，不会由于相同的原因发生变更，那么为了可维护性，应该谨慎考虑，是不是应该将这些类和组件放在一起； 共同复用原则 不要强迫一个组件的用户依赖他们不需要的东西 这个原则一方面是说，我们应该将互相依赖，共同复用的类放在一个组件中。比如一个数据结构容器的组件，提供数组，hash等数据结构容器，对数据结构遍历的类，排序的类也应该放在这个组件中，以使这个组件中的类共同对外提供服务； 另一方面，如果不是被共同依赖的类，就不应该放在同一个组件，如果不被依赖的类发生变更，就会引起组件变更，进而引发使用组件的程序发生变更，这样就会导致组件的使用者发生不不要的困扰，甚至讨厌使用这样的组件，也造成了组件复用的困难； 三个内聚原则有一定冲突，具体问题需要具体分析 2.2 组件耦合原则 讨论组件之间的耦合关系应该如何设计 无循环依赖原则 A依赖B，B依赖C，C依赖A， 就循环依赖了 很多时候，循环依赖是在组件变更过程中逐渐形成的， 如果组件设计边界不清晰，组件开发设计缺乏评审，开发者只关注自己开发的组件，整个项目对组件依赖管理没有统一的规则，很有可能出现循环依赖 稳定依赖原则 组件依赖关系必须指向更稳定的方向，不稳定的组件应该依赖稳定的组件，而不是反过来； 组件不应该依赖一个比自己还不稳定的组件； 稳定抽象原则 一个组件的抽象化程序应该与其稳定性程度一致；也就是说，一个稳定的组件应该是抽象的，而不稳定的组件应该是具体的； 指导意义： 如果你设计的组件是具体的，不稳定的。那么可以为这个组件对外提供服务的类设计一组接口，并把这组接口封装在一个专门的组件中，那么这个组件相对就比较抽象、稳定； 抽象接口的组件设计（依赖倒置）不应该由底层具体实现组件定义，而应该由高层使用组件定义，高层使用组件依赖接口组件进行编程，而低层实现组件实现接口组件；（依赖倒置，即框架不应该依赖应用程序，因为开发框架的时候，应用程序还没有。同时，应用程序也不应该依赖框架。这样应用程序就可以灵活更换框架，比如Tomcat提供的编程接口就是servlet，应用程序只需要实现Servlet接口，就可以在Tomcat框架下运行，不需要依赖Tomcat，可以随时切换到Jetty等其他web容器） JDBC就是这样一个例子，在JDK中定义JDBC接口组件，这个接口组件位于java.sql包，我们开发应用程序的时候只需要使用JDBC接口编程就行，而发布用的时候，我们制定具体的实现组件，可以是mysql实现的jdbc组件，也可以是oracle实现的jdbc组件；","categories":[{"name":"patten","slug":"patten","permalink":"http://yoursite.com/categories/patten/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"chan","slug":"chan","date":"2021-06-26T02:21:25.000Z","updated":"2021-06-30T06:18:56.005Z","comments":true,"path":"2021/06/26/chan/","link":"","permalink":"http://yoursite.com/2021/06/26/chan/","excerpt":"","text":"业务 你了解业务吗? 那么目前你了解你对接的业务吗?不妨尝试回答下以下问题: 业务做的是什么?产品大图有吗? 业务的核心指标是什么?KPI 目标是什么，这些数字背后的含义是什么?要达成这些目 标，业务策略是什么? 业务的用户是谁?流量怎么分层?占比多少?分别在业务中是怎样的定位? 业务的商业模式?靠什么吸引流量，盈利模式是怎样的? 我们做的页面是什么东西?为业务带来什么价值?要创造更多的价值，我们可以做什 么? 如何学习业务? 业务领域知识的阅读 找到该领域相关的评分较好的书籍集中阅读，快速形成知识框架。 了解业务背景和规划。 刚刚接手新的业务，可以邀请业务方老板或者资深的运营/产品同学，给你讲讲这块业 务的过去、现在、未来、愿景、财年规划，以及对技术同学的期望。 花时间读合作方(运营、产品、研发)的周报，了解现在在发生什么，是不是离目标越 来越近了。 了解业务目标、落地策略、衡量目标的数据口径，关注数据，关注目前做的项目是否为 了达成目标而战，如果不是，提出你的想法和建议。 多参会，建立产品 sense。收集信息最好的方式就是参加所处业务老大的 KO 会，各 种 KO 会会把战略上的拆解和背后的思考整体梳理之后宣讲传达给BU或部门的同学。 多交流 与服务端同学聊天，与 PM 聊天，与用户聊天，多角度看业务，但要注意的是，针对专业 型比较强的业务，需要先做功课，至少一些英文的缩写要清楚的明白意思。 谨记数字 如果前面还需要花比较长的时间，那这一个可以现在就做起来，那就是把业务相关的数字记 得越精细约好，越具体越好，越全面越多越好。这样做有两个好处: \\1. 所记的数字指标本身，很大程度已经涵盖了这个业务价值方向，你便知道了这个业务重 点关注的是哪个维度的东西。 \\2. 这些数字可作为和业务方以及产品“平等对话”的源头，否则连最基本对话基础都没有。 从日常需求入手 对于项目中的需求，我们要尝试分析背后的目的和价值，做了之后有什么预期的收益，为什 么这么做就可以达到这个收益，跟总体目标是否契合，还要判断业务方提到的点是不是有效 的方案或者说成本太大的方案，看能不能给出替代方案，用现有的方案或者小成本的方式来 满足业务方。 而在项目提测上线后，还要仔细分析以及多关注上线之后的业务数据和效果，会有如下好处: \\1. 提高自己对业务的理解能力，你在关注业务数据的同时，也就会更多的从业务的角度来 看到这个功能所带来的价值是否符合预期，当出现不符合预期的时候，可以和业务方一 起进行数据漏斗的分析从而找到问题所在，避免我们的劳动成果成为一次性的工作。 总结的同时可以帮助自己梳理这个项目中自己哪些地方做的不足，或者相关推进中存在 什么问题，以及后面怎么改进，提高了下次项目中的迭代效率和质量。比如这个项目是 否存在需求理解不到位存在返工，或者沟通 &amp; 联调低效，环境不稳定，自己设计的方 案是否合理等问题，后续要怎么解决。 也可以从数据和总结中判断出什么样的需求是靠谱的 &amp; 什么的样业务方是靠谱的，频 繁争取资源上线效果又不好的业务方，下次再有需求过来则需要多增加一个心眼和思考 的过程。 坚持 业务思考力，没有个至少半年是不会见效的。 助力业务 思考 尽管平时的业务很忙，但再忙，也要抽时间思考，那么思考哪些内容呢?以下举一些例子: 养成每天记工作内容的习惯，分析一下自己的时间到底耗在哪了? 在业务开发中，有遇到让你特别想吐槽的点吗?想下问题背后的原因，有什么方法可以 避免下次不犯，能不能提炼为更加通用的解决方案，其他同学怎么解决的，我可以怎么 解决? 不断地输入、观察，业务的真实需求是什么?站在业务方的角度思考，业务遇到的痛点、 挑战在哪里? 沟通 和老板、团队同学、业务方对焦，确认“我想做的”是不是“大家想要的”?你可能会提出很多 意见，但一般会遭到老板或者业务方无情的拒绝，而且问得你一脸懵逼，就比如: 当前业务背景下，为什么要做?(有什么业务价值?有什么技术价值?) 现在必须做么? 为什么是你做? 怎么做?(体系化、全链路、单点技术挑战) 有什么业务和技术结果?能否被复用? 未来规划(能否跟 BU 或集团的方案联动、共建) 而这往往是因为你提出要做的事情，有价值但不是必须做的，没有结合目前业务需要什么。 也就是说，你想做的技术是个人和纯技术角度思考的，没有基于业务的现状和痛点去考虑技 术方案，不接地气，投入产出比不高。 所以给技术产出先找好业务的阵地，看看有没有可以借力的地方，不要重复造轮子。快速验 证这个方向的正确性后，再逐渐多加投入、丰满技术设计。不要自己 YY、默默地做完，这 样做出来的东西没有业务场景埋单。 技术规划 业务赋能其实是需要我们紧贴业务规划，制定技术规划和方案。在了解业务方今年的 KPI 重点是什么，预计的拆解和实现路径是什么后，再结合自己的和团队情况，想想自己能做哪 些事情来帮助业务实现其 KPI，这里有两点需要注意下: 抓住本质从点及面，通盘考虑: 很多时候，我们收到的痛点和业务需求都是单点的，这时我 们不能着眼于眼前的单点问题，而需要通盘来考虑，比如 SEO 的页面对性能非常敏感，经 常可能会收到一些业务方来反馈，说目前我们的 SEO 有这个地方，那个地方需要优化下， 而单点解决这些问题可能对业务带来的收益并不大，对自己的技能也没有什么成长。这时候 如果通盘考虑这个命题，其实会发现做 SEO 页面的优化，其实目的是为了提升 SEO 页面的 收录和排名。而提升 SEO 页面的收录和排名其实不仅有前端性能优化这一个路径，而是还 有一些其他的路径:比如优化关键词&amp;长尾词，采用 Google 的 AMP 技术改造 SEO 页面， 优化爬虫爬取页面的耗时提升爬取率等等。这样就能吧点的问题转化为面的问题，才能制定 更有效和全面的抓手来赋能业务。 既要解决眼前痛点，也要长远谋划: 很多时候我们不能仅满足于眼前的 KPI，还需要了解业 务方长远的想法和可以预见的规划。就比如试点的新业务，一层规划是保证业务项目的按时 上线，考虑到未来，另一层规划可能就是如何做到技术方案的可以复制性。 站在巨人的肩膀上 当你需要制定一个产品化的方案或者工具和框架的时候，最好先放眼集团内部和行业进行一 番调研，看看业界和其他同事是怎么解决这个问题的。尽量站在别人的肩膀上做出创新或者 参与共建，避免小团队内造出重复和质量低的轮子 技术深度 技术知识与技术能力 “技术”不能是一个笼统的词汇，我想它至少可以分为“技术知识”和“技术能力”两大部分。 什么是“技术知识”?知识就是 I KNOW  《TypeScript 从入门到放弃》  《React 从入门到放弃》  《Webpack 从入门到放弃》  …… 什么是“技术能力”?能力就是 I CAN  我用 TypeScript 重构了一个大型系统，代码健壮性及研发效率大幅提升。  我用 React Hooks 给全栈同学进行前端培训，培训效果大幅提升。  我深入研究了 Webpack，优化配置，使得系统构建速度大幅提升。  ….. 培养技术视野 关注日常业界新技术。不一定要深入了解，但对新技术保持好奇心，大概了解它是做什 么的，如果在工作中遇到匹配的落地环境，可以考虑写个 demo 看看是不是有价值。 关注集团和业界的解决方案。在业务中发现问题，做解决方案的时候，我们很容易陷入 自己的设计中，一脑子地想把所有东西都自己做出来，但投入会非常大，产出的价值是 否一样大呢?不知道。大部分情况下，你想做的，在 ATA 能搜到，前人踩的坑，或者 已有的成熟的解决方案，只要你去沟通去接触，就可以轻松地接进来，为什么要花大量 的时间去造轮子呢?可以借力的地方，就去借力吧，把时间剩下来，做你的解决方案中 更核心更有价值的事情。 技术深度 一聊到“技术深度”，可能很自然地会认为是在某项技术上挖得很深，或者解决了一个业界公 认难度很高的技术难题，但这只是“技术深度”的其中一部分: 体系化 / 系统化 体系化思维是认识事物的一种方式，在面对问题的时候，能够针对复杂的问题，列出关 键的要素和解决方法，将散乱无序的问题，变得逻辑清晰，有章可循。 在问题的定位和解决的体现，从表象到本质，拆解出造成问题背后的原因，针对性地去 解决本质的原因，而非治标不治本，有解决方案有节奏地解决。 全链路 除了前端的部分，向前向后的技术栈，还能挖多深。 单点技术挑战 在某个技术挑战上，你的思考和解决方案是怎样的。 技术与业务共赢 真正有突破性的、带来重大价值的业务成果必然伴随着技术上的深入乃至创新，所以在做业 务成果的时候，一定会有让我们增加技术深度的场景。","categories":[{"name":"chan","slug":"chan","permalink":"http://yoursite.com/categories/chan/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"patten","slug":"patten","date":"2021-06-18T01:59:24.000Z","updated":"2021-06-18T04:39:00.543Z","comments":true,"path":"2021/06/18/patten/","link":"","permalink":"http://yoursite.com/2021/06/18/patten/","excerpt":"","text":"焦虑 所有的渴望，在内心的投射其实都是焦虑。任何一个渴望成长的人，不管处于什么阶段，一线工程师，架构师，还是总监，副总裁，其实内心中都是充满了焦虑的，无一例外。 对于这种焦虑，我们所要做的是接纳，而不需要过度担忧。这种焦虑并不是说，想明白如何成长了就会没有了，到了某个阶段就会没有了的。成长的脚步和期待一刻不止，内心的焦虑也一刻不会停歇。正是这种焦虑感，驱使你写代码追查问题到星夜，驱使你牺牲休息娱乐的时间和一本本厚厚枯燥的书作伴，驱使你不断努力向前，不舍昼夜。 35危机背后的根本原因是，太多太多的人在工作几年以后，就觉得自己什么都会了，之后的十几年工作只不过是头2-3年的简单重复而已。在我们这样一个行业里面，在照片的时候，如果摆在管理面前的两个人， 一个刚出校园工作2-3年，充满对成长的渴望，另一个工作十多年但水平和工作2-3年的人差不多，只是更熟练一些，不过在舒适区已经躺了十年了。如果你负责招聘，那么招谁进来再显然不过了； 另一方面，高端人才在行业内极度极度稀缺，这在行业是非常普遍的现象，真正的大牛太稀缺了。在这样一个行业里面，如果一个人能够持续成长，能力和工作年限成正比的持续提升，这样的人，任何时候在行业里都是被疯抢，不可能遇到所谓年龄危机； 如何学习刻意练习 找到你要学习这个领域体系的范式（patten）；梳理这个领域的技术栈 针对每个范式，技术栈 反复学习和练习 及时反馈 当学习方法不正确的时候，刻苦的学习常常只是看起来很勤奋。 当接触一个陌生领域的时候，错误的学习方法是不带目的性，上来就找一堆相关的大部头开始啃。 而正确的学习方法应该是快速梳理该领域的知识点，形成框架体系（寻找pattern），这里有些小窍门可以快速构建起一个领域的知识点体系， 例如看一些该领域的综述性或开创性的文章（看论文，别瞎看网上的文章），或者找本该领域综述性的教科书看它的目录（注意，好的教科书的目录往往就是这个领域的知识框架，内容倒不一定非要看下去）。 然后，针对每个知识点，找书里的相关章节，该领域相关paper里的相关section深入学习，建立起自己对这个知识点的理解（刻意练习）。 最后，再把知识点和现实工作中的情况（自己工作，或其他公司相关的工作）进行对照（及时反馈），从而建立对一个知识点的深度理解，最后融会贯通建立对一个领域的理解。 拿打羽毛球举例 把打羽毛球拆解成步法和手上动作，小碎步，米字步，正反手挑球，。。。（拆解，寻找范式） 然后针对每个动作反复练习，（反复学习） 请教练或者录下来看视频纠正自己的动作（及时反馈） 错误示范： 上来就盲目找人打比赛，以赛代练，这样的进步是很慢的，而且错误动作形成习惯以后未来反而很难纠正； 类比编程：一上来，找框架撸业务代码，快速crud。不追求最佳实践。无脑一把梭，正确的做法，应该是先弄明白底层原理 linux（内存管理/工程化/编程语言范式/设计模式/高质量代码/数据结构）/浏览器（浏览器架构/渲染进程原理/网络/v8机制/css，html，js/DOM/BOM/vue，react，angular等）然后针对开发框架，最好先弄懂实现原理以及该框架在开发中的最佳实践。真正做到 做一个项目之后就能成为 该框架的专家级玩家； 至于反馈就是找更高水平的人讨论。 学习分布式存储的例子 先结合自己的工作内容梳理出需要深入了解的知识点（例如，元信息组织，Meta Server设计和HA，副本组织和管理，Recovery，Rebalance，单机存储引擎，数据/元信息流，纠删码，一致性，多租户，存储介质，网络环境和IDC等等）， 同时看很多综述性的材料，梳理分布式存储的知识点（有网上各种整理的比较好的文章，也有从各种系统实现的paper里抽出），不断迭代构建分布式存储领域的知识点（寻找pattern，这是最难的一个过程）； 然后针对每一个知识点，找相关材料进行深度学习，例如，对于分布式一致性，需要阅读CAP理论，Paxos的论文，Raft的论文等等以及周边的很多材料（刻意练习）； 然后找各种系统实现的论文或文章，比如GFS，Dynamo，Aurora，OceanBase，Ceph，Spanner等等，看看和对比它们在一致性上是如何考虑和取舍的，当然，最重要的是结合自己工作中的反复实践和所学知识点进行比对（及时反馈）。 这三个阶段并不是割裂的，而是周而复始的，经常会在刻意练习和及时反馈的学习过程中，发现自己遗漏的知识点，或者发现自己梳理的两个知识点其实是重合的。通过这种交叉比对，以及在实践中不断检验的方式建立的知识点是非常可落地的，而不会看了几篇论文以后就人云亦云。拿分布式存储的一致性举例子，如果不是反复对比、思考和反复实践，你不会发现GFS论文里最难的一段，多个Writer对一个文件进行append的逻辑，在实践中根本没用；你也不会发现看起来优雅而学术的CAP三选二的理论，实践中压根不是这么完美，很多时候只能三选一；你也不会发现Dynamo论文里的Vector Clock，网上有无数文章摇头晃脑的解读，但在Amazon的应用场景里是个典型的over design，Cassandra在这点就务实很多。 忙碌的工作如何抽时间来学习工作和学习是不应该割裂的，工作本来就应该是学习的一部分，是学习中的实践和及时反馈的部分。学习如果脱离工作的实践，其实是非常低效的；每个同学都应该对自己工作所在 的这个技术和业务领域进行系统性的学习，并在工作中反复实践和验证；不同的领域之间其实是融会贯通的； 当你对一个领域精通并总结出方法论的时候，很容易就能上手别的领域了。因为花几年实践彻底研究透一个领域，对于刚工作几年的同学来说，是非常重要的，甚至是必须的，也只有在一个领域打透之后才谈得上跨领域迁移，去拓展自己的知识面，更直接的说，对于一个领域还未完全掌握的同学，深度是最重要的，不用像广度的事情，等掌握了一个领域之后，再去拓展广度就变得很容易了； 一个常见的误区就是学习的内容和工作的领域没有太多直接的关系软件工程是一门实践科学，从书本上得到的知识如果没有在实践中应用和检验，基本上是没有用处的。举一个例子，很多优秀的架构师，尽管日常工作中可能反复在用，但未必说得出开闭原则，里氏替换原则，迪米特法则等等，反过来，对面向对象设计这7大原则出口成章的人，很多其实离真正的架构师还远得很，有些甚至只是博客架构师而已。实践远远比看书，看文章重要得多，上文所述的我构建自己分布式存储知识体系的过程，看起来好像都是看材料，看论文，而实际上80%的收获都来源于带着理论的实践，和从实践中总结沉淀的理论。因此，彻底搞明白自己工作所在的技术和业务领域，是最务实高效的做法，工作和学习割裂，会导致工作和学习都没做好。 感觉日常工作非常琐碎，学不到什么东西，怎么办？如果把学习分成从书本中学，和从工作中学这两种的话，那毫无疑问，工作中的“知识密度”，比起书本的“知识密度”，肯定是要低很多的，因为书本里的知识，那都是人家从他们的工作中抽象总结出来的。这也是为什么大家普遍觉得日常工作“琐碎”。然而工作中每个点滴的琐事与平凡，都是可以抽象总结成为方法论的，更别说工作所在的领域自身的博大精深了。从日常工作中学习的秘诀，就是“行动中思考”。 对于每一个软件工程师，最重要的两个能力，是写代码的能力和trouble shooting的能力。 写代码并且，要成为优秀的架构师，出色的开发能力和追查问题的能力是一切的基础。提高写代码的能力的核心，首先在于坚持不断的写，但更重要的，在于每天，每周，持续不断的review自己之前的代码；同时，多review牛人写的代码，比如是团队里你觉得代码写的比你好的同事，比如社区里以代码漂亮著称的开源代码（作为一个C++程序员，当年我的榜样之一是boost库）。 一旦觉得自己之前的代码不够好，就立刻复盘，立刻重构。更重要的是，多思考自己代码和好的代码之间不同之处背后的为什么，通常这就是为什么这些代码更好的背后的秘密。 特别要说明的是，代码规范除了知道是什么外，要格外重视思考每一个代码规范背后的为什么。代码规范的每一句话，背后无一例外都是一片江湖上的血泪史。 trouble shooting要提高trouble shooting的能力，关键在于要深度复盘自己遇到的每一个问题，包括线上的，包括测试发现的，寻找每一个问题，每一次事故背后的root cause，并且思考后续如何避免同类问题，如何更快的发现同类问题。要对团队内外遇到的所有问题都要保持好奇心，关注一下周边的事故、问题背后的root cause。 Trouble shooting能力的提高是几乎无法从书本上得到的，完全来源于对每一个问题的深度思考，以及广泛积累每一个问题。对于架构师而言，可能未必在一线写代码了，但看团队中一个架构师是否真正牛逼的一个很重要标准，就是看他是否能够追查出团队其他同学查不出来的问题。我见过的一个真正牛的架构师，对于系统中疑难杂症，通常问几个问题，就能大致猜出是哪里出的问题，以及可能的原因是什么，准确程度如同算命，屡试不爽，令人叹为观止。 构建完整的当前技术领域的知识体系对于一个架构师，除了更加优秀的代码能力和trouble shooting能力外，需要构建相对完整的当前技术领域的知识体系，需要有体系化的思维能力，需要对技术所服务的业务有非常深入的了解。体系化的思维能力，来源于两个方面。一方面是在日常工作中，对每一个接口设计，每一个逻辑，每一个模块、子系统的拆分和组织方式，每一个需求的技术方案，每一个系统的顶层设计，都要反复思考和推敲，不断地复盘。另一方面，需要大量广泛地学习行业内相似系统的架构设计，这其实就是开天眼，只是技术相对来说，行业内的交流更加频繁。淘宝、美团、百度、Google、Facebook、Amazon等各个公司介绍系统架构的论文和PPT铺天盖地，需要带着问题持续学习。除了技术领域本身外，架构师需要非常了解业务上是如何使用我们的系统的，否则非常容易over design，陷入技术的自嗨中，这也是为什么我说Amazon Dynamo论文里讲的Vector Clock是个over design的原因。 另一方面，很多时候技术上绕不过去的坎，可能非常复杂的实现，往往只需要上层业务稍微变通一下，就完全可以绕过去，这也是为什么我说GFS论文里，多个Writer同时Append同一个文件是个根本没用的设计（实际上Google内部也把这个功能去掉了）。只有真正知道上层业务是如何使用系统的，才可能真正做好架构。深入了解业务并不难，对于每个同学，只要对于每一个接到的需求，对于每一个需求评审中的需求，对于周边同学或团队要做的需求，都深入思考为什么业务要提出这个需求，这个需求解决了业务的什么问题，有没有更好的方案。遇到不明白的多和周边同学、产品、运营同学请教。最怕的是自己把自己限定为纯粹的研发，接到需求就无脑做，这等于放弃了主动思考。衡量一个人是不是好的架构师，也有一个方法。对于一个需求，如果他给出了好几个可行的方案，说这些方案也可以，那些方案也可以，往往说明他在架构师的路上还没有完全入门。架构师的难点不在于给出方案，而在于找到唯一的那一个最简单优雅的方案。 总结 行动中思考，就是始终保持好奇，不断从工作中发现问题，不断带着问题回到工作中去；不断思考，不断在工作中验证思考；不断从工作中总结抽象，不断对工作进行复盘，持续不断把工作内容和全领域的知识交叉验证，反复实践的过程。 在工作所在的技术和业务领域中刻意练习，加上行动中思考，就是成为技术大牛的秘诀。 看起来方法也不复杂，为什么大牛还是非常稀少？ 尽管我们通篇都在讲方法，但其实在成为技术大牛的路上，方法反而是没那么重要的。 真正困难的，在于数年，数十年如一日的坚持。太多人遇到挫折，遇到瓶颈，就觉得手头的事情太乏味枯燥，就想要换一个方向，换一个领域，去学新的技术，新的东西。而真正能够成为大牛的，必须是能够青灯古佛，熬得住突破瓶颈前长时间的寂寞的，必须是肯下笨功夫的聪明人。因此，和坚持相比，方法其实并没有那么重要。","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"microservice","slug":"microservice","date":"2021-06-09T03:18:15.000Z","updated":"2021-06-15T06:22:50.484Z","comments":true,"path":"2021/06/09/microservice/","link":"","permalink":"http://yoursite.com/2021/06/09/microservice/","excerpt":"","text":"微服务绪论 工程方法论，方法， 理念； 抛出一个实际问题是如何解答； 1. 微服务概览1.1 组件服务化 传统实现组件的方式是通过库，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署； 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程； kit： 一个微服务的基础库（框架）如spring cloud service： 业务代码 + kit依赖 + 第三方依赖组成的业务微服务 rpc + message queue： 轻量级通讯 （服务与服务之间的通讯）message queue 如kafka 本质上等同于，多个微服务组合（compose）完成了一个完整的用户场景（usecase）； 多个微服务之间做数据的组装； 面向场景的api设计； 1.2 康威定律 “设计系统的架构受制于产生这些设计的组织的沟通结构。” 微服务鼓励闭环团队； Ownership 意识，全栈工程师。自己写的代码，自己测试，自己搞定线上问题； you build it，you fix it 那测试和运维干什么？他们提供好用的测试平台，运维平台，指标采集体系，日志平台，让你去很方便的定位到问题； 运维全部转开发来做平台， 测试转开发做CI/CD，devops之类的工具；还有一些用户场景的测试； 大前端（移动/Web） =&gt; 网关接入 =&gt; 业务服务 =&gt; 平台服务 =&gt; 基础设施（Paas/Saas） 网关做什么： 所有流量要经过网关，网关对移动端API设计比较熟悉，协议也比较熟悉。网关和移动端同学沟通无成本形成闭环；（暂时就理解为给搞静态页面那个组前端 提供 组装接口的人）网关同事总归要聚合各种业务数据，服务端天然沟通无障碍（API契约之间的沟通），又形成了闭环； 服务端怎么和运维沟通，扔过来一个工具和文档，自己学习怎么用； 开发团队对软件在生产环境的运行负全部责任！ 类似传统模式，想zz那样 程序在线上怎么跑的，开发完全不晓得；日志都不让看 1.3 按业务组织服务 服务提供的能力和业务功能对应，比如订单服务和数据访问服务，前者反应真实的订单相关业务，后者是一种技术抽象服务；按微服务架构理念来划分服务时，是不应该存在数据访问服务这样的一个服务的； 微服务下每个服务背后的小团队，要包含实现业务所需的全面的技能； 1.4 去中心化核心是数据去中心化和治理去中心化； 数据去中心化： ​ 每一个微服务独占一个DB，独占一个redis，服务与服务之间rpc 治理去中心化 ​ 流量变大了之后，服务与服务之间很多环节会出现流量热点。比如账号服务是所有微服务都要依赖的服务，如果所有的流量入口都要先走nginx的话，是否能改成直连账号服务； 技术去中心化 ​ 比较理想，选择最合适的语言来做不同的事情。 技术栈还是尽量统一的好； 1.5 基础设施自动化无自动化不微服务，拆分微服务之后，意味着开发，调试，测试，监控和部署的复杂度都会响应增大；必须要有合适的自动化基础设施来支持微服务架构模式； CICD： Testing 在线运行时： k8s 1.6 可用性&amp;兼容性设计 Design For Failure， 所以依赖的东西都会炸；每一行代码都可能painc 微服务架构采用粗粒度的进程间通信， 隔离 超时控制 负载保护 限流 降级 重试 负载均衡 一旦采用微服务架构模式，那么在服务需要变更时要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性； 发送时要保守，（发送时，要最小化发送必要的信息） 接收时要开放 （接收时最大限度容忍冗余数据，保证兼容性） 2. 微服务设计2.1 网关 1.0版本，外网通过 AWS（ngix）可以直连到 提供的所有服务（用户，稿件，推荐，广告）。 对外暴露了一批微服务，缺乏统一的出口； 用户等于是直连了 某个微服务； 坑 客户端到微服务直接通信，强耦合。移动端的版本是可以不升级的。这导致后续服务端重构是要兼容老版本的。如果移动端直连微服务。那服务端也是无法随心所欲重构的；很难大规模重构； 客户端需要多次请求，客户端需要自己聚合数据，工作量巨大不谈，主要延迟高；各服务之间接口的协议有时候还特么不一样；就没法降级；客户端是Landing Page，很重要；要讲究效率； 重的数据聚合最好在服务端全部做掉；面向资源的API是屁，面向用户业务场景的API才是王道； 面向“端”的API适配，耦合到了内部服务；（不同的机型/终端要的字段不一样，得适配） 统一逻辑无法收敛，比如安全认证、限流（每一个微服务做安全认证，token验证之类的） 2.0版本，新增了一个 app-interface用于统一的协议出口，在服务内进行大量的dataset join，按照业务场景来设计粗粒度的API，给后续服务的演进带来很多优势：这个所谓的app-interface就是BFF层； 传说中的BFF，Backend for Frontend （面前前端业务场景的后端） 现在BFF负责跟微服务对接，BFF跟客户端对接；然后说白了，垃圾代码，耦合代码就写进BFF了； BFF可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务； 3.0版本，解决2.0单个 BFF会造成的单点故障；严重代码缺陷或流量洪峰可能引发集群宕机； 按照业务域将 BFF拆分成几个大的BFF，如app-interface, app-view, account-interface；随着拆分的越来越多，变得越来越难以维护。基础库更新，意味着所有BFF都需要更新； 很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多； 4.0版本，网关选手出场； 跨横切面（Cross-Cutting Concerns）的功能，需要协调更新框架升级发版（路由，认证，限流，安全），因此全部上沉，引入API Gateway， 把业务及程度高的BFF层和通用功能服务层API Gateway进行了分层处理； 在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器，在网关的配合下，单块BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升，另外，把跨横切面逻辑从BFF剥离到网关上去之后，BFF的开发人员可以更加专注业务逻辑交付，实现架构上的关注分离 移动端-&gt;API Gateway -&gt; BFF -&gt; Mircoservice 在FE Web业务中，BFF可以是nodejs来做服务端渲染（SSR，Server-Side Rendering） 2.2 Mircoservice 划分 在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能或是DDD 一般还没搞清楚公司业务的时候，划分微服务的依据即业务职能 业务职能 根据部门处理业务不同，拆分。比如稿件 和 视频拆分开来 DDD 面向业务场景，比如一个用户在创作的时候，他的制作流程是先稿件后视频，那么就将稿件和视频放在一起，作为一个业务场景的服务组合； 2.2.1 微服务到底要拆多细两个角度： 从组合结构来讲， 是否能形成业务闭环。如果能够闭环，那么闭环的团队own一个服务，不要一个功能散在好几个职能部门当中；（会带来沟通不畅） 拆的比较细，需要请求比较多的时候，再考虑整合； 2.2.2 CQRS2.3 mircoservice安全 外网安全 对于外网请求，通常在API Gateway进行统一的认证拦截，一旦认证成功，会使用JWT方法通过RPC原数据传递的方式带到BFF层，BFF层校验Token完整性后把身份信息注入到应用的Context中，BFF到其他下层的微服务，建议是直接在RPC Request中带入用户身份信息（UserID）请求服务； ​ 网关 到 BFF 是token传递，BFF到service是 用户id传递； 内网安全 对于服务内部，一般要区分身份认证和授权；先做身份认证，再做授权； ​ 身份认证： 谁来连我，我就知道你是谁，grpc基于证书判断是谁。知道对方是谁之后很容易利用配置中心来做一个RBAC服务，做一个微服务控制面板来配置哪些服务对你有权限，这些数据可以写到配置中心，然后下推到服务；在服务加载的时候，构建RBAC序列的权限认证，判定这个人对这个接口有无权限； 有些严格内网微服务，服务与服务之间的通信都需要加解密；避免有人抓包嗅探，它的等级分为 Full Trust 完整的tls Half Trust 知道你是谁，但通讯不加密 Zero Trust 裸奔 3. gRPC和服务发现3.1 gRPC3.1.1 HealthCheck Discovery ：服务发现 Provider： 生产者要定时注册（发送心跳）给服务发现，注册rpc协议，协议端口（rpc://ip:port） 假设Provider和Consumer之间发生网络抖动，这个只能通过healthCheck来解决了。 平滑发布 一个应用上线，什么时候要往 服务发现注册。一种做法就是 外挂探测，就是在容器外边有一个脚本去check 服务发现，去判断当前服务是否可用（一个服务启动之后往往不能立即提供服务，因为需要加载DAO，service以及缓存等等。最终才能产生正常的服务，然后需要有一种外挂方式让外面的人知道当前能够提供服务了） 平滑下线 版本滚动 升级，先下线1.0，然后上线1.1； k8s向APP发送sigterm信号，进入优雅退出过程；go的main 函数会拦截到这个信号，这个时候进程还在跑。还有大量数据进出； 第一步，收到sigterm信号， 第二步， 先告诉注册中心，服务提供者收到一个信号之后。告诉服务注册中心，注销掉自己，然后其他节点都会收到这个消息，其他节点陆陆续续要下线了； 第三步，把自己health check接口也标记为待下线，自己进入一个优雅退出的状态。 （基本两个心跳周期之内，所有的消费者节点均能收到该服务要下线的通知；） 第四步：用http或者rpc的 shut down接口。 第五步： 如果发现此进程一直退出不了，就要kill -9了 3.2 服务发现客户端发现 服务端发现 3.2.1 CAP 一个分布式系统最多只能同时满足一致性(Consistency)，可用性(Availability)，分区容错性(Partition tolerance)这三项中的两项; 分布式数据存储不可能同时满足以下三个条件： 一致性：每次读取要么获得最近写入的数据，要么获得一个错误； 可用性：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据； 分区容错性：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行 核心理解： 在出现网络分区的时候， 如果系统不允许写入，那么意味着降低了系统的可用性，但不同分区的数据能够保持一致，即选择了一致性； 如果系统允许写入，那么意味着不同分区之间的数据产生不一致，系统可用性得到保障，即选择可用性； 分区容忍： 分区容忍就是指分布式系统在出现网络分区的时候，仍然能够继续运行，对外提供服务； 可用性范围： 对于分布式系统中每个节点，都能够对外部请求作出响应，但不要求一致性； 衡量系统可用性的标准是什么？ 关键点在于可用性的范围。讨论可用性要有具体场景来划分边界； 举例子： 谷歌文档就是非常典型的AP系统，它在网络断了的情况下也能够使用。诀窍在于它发现网络断掉之后会进入离线模式。允许用户继续进行编辑，然后在网络恢复之后再对修改的内容进行合并处理。 可以发现对于谷歌文档来说，用户的浏览器也是系统的一个节点，当出现网络分区时，它仍然能够为用户提供服务，代价是放弃一致性（离线用户编辑了啥，服务器并不知道）。在这个例子里面，可用性的范围是包括了用户浏览器在内的，不是常规理解的分布式系统节点一定就是服务端的机器； 一致性的范围： 讨论一致性的时候必须要明确一致性的范围，即在一定的边界内状态是一致的，超出边界之外的一致性是无从谈起的； 管理分区： 网络分区是分布式系统中必然发生的事情，经典的CAP理论是忽略网络延迟的，但是在现实世界中，网络延迟跟分区密切相关，也就是说当系统在有限的时间内无法通信达成一致（网络延迟很高），就意味着发生了分区。此时就需要在一致性和可用性之间作出选择：选择继续重试就意味着选择一致性，放弃可用性；放弃数据一致性让操作完成就意味着选择了可用性。值得注意的是在分区的时候放弃数据一致性并不是意味着完全不管，一般工程实现会采用重试的方式达到最终的一致性； 结论 分析：平衡分区期间的可用性和一致性的影响是分布式系统设计中的关键问题。因此，管理分区不仅是需要主动发现分区，还需要针对分区期间产生的影响准备恢复过程。 可以从另外一个角度来应用CAP理论：系统进入分区模式的时候，如何在一致性和可用性之间作出选择； 管理分区的三个步骤： 检测到分区开始 明确进入分区模式，限制某些操作 当通信恢复后启动分区恢复过程 当系统进入分区模式之后，有两种选择： 选择一致性：例如Paxos算法，只有大多数的主分区能够进行操作，其他分区不可用，当网络恢复之后少数节点跟多数节点同步数据； 选择可用性： 例如谷歌文档，出现分区进入离线模式，等网络恢复了客户端跟服务端数据进行合并恢复； 3.3 euerka实现原理 AP服务发现，牺牲一致性； 采用的异步复制机制； 3.4 多集群&amp;多租户3.4.1 多集群统一为一套逻辑集群（物理上多套资源池），即gRPC客户端默认忽略服务发现中的cluster信息，按照全部节点，全部连接。能不能找到一种算法从全集群中选取一批节点（子集），利用划分子集限制连接池大小； 长连接导致的内存和CPU开销，HealthCheck可以高达30%。 短连接极大的资源成本和延迟； 合适的子集大小和选择算法； 通常20-100个后端，部分场景需要大子集，比如大批量读写操作； 后端平均分给客户端 客户端重启，保持重新均衡，同时对后端重启保持透明，同时连接的变动最小； 3.4.2 多租户在一个微服务架构中， 允许多系统共存 是利用微服务稳定性以及模块化最有效的方式之一， 这种方式一般被称为多租户， 租户可以是测试，金丝雀发布，影子系统（shadow system），甚至服务层或者产品线，使用租户能够保证代码的隔离性 并且能够基于 流量租户做路由决策； 对于传输的数据，以及静态数据，租户都能够保证隔离性和公平性，以及基于租户的路由机会； 如上图所示，如果对服务B作出改变，我们需要确保它仍然能够和服务A，C，D正常交互在微服务架构中，我们需要做这些集成测试场景，也就是测试和该系统中其他服务的交互。通常来说，微服务架构有两种基本的集成测试方法：并行测试 和 生产环境测试； 具体一个场景，分布式的测试环境上，一个用户正在测试很容易因为别人一套push操作，把自身的环境给冲掉了；就像当时在zz，你push一个版本侧着侧着，别人push一套代码把你的环境污染了；尽管zz那个不一定是分布式系统； 混用环境导致的不可靠测试； 多套环境带来的硬件成本； 难以做负载测试，仿真线上真实流量情况； 把待测试的服务B在一个隔离的沙盒环境中启动，并且在沙盒环境下可以访问集成环境（UAT）C和D。我们把测试流量路由到服务B，同时保持生产流量正常流入到集成服务。服务B仅仅处理测试流量而不处理生产流量。另外要确保集成流量不要被测试流量影响。生产中的测试提出了两个基本要求，它们也构成了多租户体系结构的基础： 流量路由：能够基于流入栈中的流量类型做路由 隔离性：能够可靠的隔离测试和生产中的资源，这样可以保证对于关键业务微服务没有副作用； 灰度测试成本代价很大，影响1/N的用户。其中N为节点数量； 当测试完毕之后，将B`的代码推到 集成测试中B的位置做回归测试（回跑一些历史的case，不会做功能测试）。","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"goparallel","slug":"goparallel","date":"2021-06-01T03:49:13.000Z","updated":"2021-07-22T14:22:30.033Z","comments":true,"path":"2021/06/01/goparallel/","link":"","permalink":"http://yoursite.com/2021/06/01/goparallel/","excerpt":"","text":"1. 并行与并发1.1 并行（parallel） 并行，同一时刻，有多条指令在多个处理器上同时执行。并行需要借助多核cpu实现。 1.2 并发宏观：在用户体验上，程序在并行执行 微观：多个计划任务，顺序执行。在飞快的切换，轮换使用cpu时间轮片；（cpu时间调度算法） 进程状态： 初始态、 就绪态、 运行态、 挂起（阻塞）态、终止（停止）态 线程并发： 什么是线程 Lwp（light weight process）轻量级进程，本质上仍是进程（Linux下） 进程： 独立地址空间，拥有PCB 线程： 有独立的PCB，但没有独立的地址空间（共享） 区别： 在于是否共享地址空间，独居（进程）； 合租（线程） 线程： 最小的执行单位 进程： 最小分配资源单位，可看成是只有一个线程的进程； 1.3 线程同步同步即协同步调，按预定的先后次序运行。 线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回，同时其它线程为保证数据一致性，不能调用该功能； 举例：A，B两张银行卡取钱。当两个线程访问共享资源时，如果没有协调机制，会产生与时间有关的错误。—— 锁 因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。 1.3.1 线程同步机制：互斥锁（互斥量）：建议锁，拿到锁以后，才能访问数据，没有拿到锁的线程，阻塞等待。等到拿锁的线程释放锁。 读写锁： 一把锁（读属性、写属性），写独占，读共享，写锁优先级高 信号量： 条件变量： 1.4 协程并发协程： coroutine，也叫轻量级线程。 与传统系统级线程和进程相比，协程最大优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源崩溃。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。 一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行。多个协程分享该线程分配到的计算机资源。 在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。 1.5 小结在一次并发任务中，进程、线程、协程都可以实现，从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。 进程并发：优点是稳定性强，开销较线程大。 线程并发：优点是节省资源，尤其是调度时，线程与线程之间切换的时候。而进程间切换的开销就比较大一些。 协程并发： 效率高，系统利用率高 2. goroutineGo语言为并发编程而内置的上层API基于顺序通信进程模型CSP（communicating sequential processes）。这就意味着显式锁都是可以避免的。因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。 Go语言中的并发程序主要是用两种手段来实现。goroutine 和 channel 3.1 概论1234567func main() &#123; go sing() go dance() for &#123; &#125;&#125; Goroutine 的并发机制；main goroutine中的for{} 占据较长的时间。可以确保两个goroutine能执行完毕； Goroutine的特性： 主go程结束，子go程随之退出； 在Go里，无需修改现有顺序式的代码，就可以通过goroutine以并发的方式运行任意数量的任务； 3.1.1 启动goroutine只需在调用前面加一个go关键字； 123456789101112131415import ( \"fmt\" \"time\")func main() &#123; go sleepGopher() // go 关键字相当于启动一个 goroutine,另开辟了一条道路，在那条道路里面执行。然后main函数是一条主干道。主干道继续往下执行，当main函数返回的时候，该程序运行的所有goroutine都会立即停止，无论有没有走完。 //所以想在main函数返回之前让 sleepGopher 函数输出 ...snore... 的话，就需要多等待一段时间，已知 sleepGopher sleep了3秒，所以选择让main函数sleep了4秒 time.Sleep(4 * time.Second)&#125;func sleepGopher() &#123; time.Sleep(3 * time.Second) // 3*time.Second = 3s fmt.Println(\"...snore...\")&#125; 3.1.2 不止一个goroutine每次使用go关键字都会产生一个新的goroutine 表面上看，goroutine似乎在同时运行，但由于计算机处理单元有限，其实技术上来说，这些goroutine不是真的在同时运行； 计算机处理器会使用“分时”技术，在多个goroutine上轮流花费一些时间； 在使用goroutine时，各个goroutine的执行顺序无法确定； 1234567891011func main() &#123; for i := 0; i &lt; 5; i++ &#123; go sleepGopher() &#125; time.Sleep(4 * time.Second)&#125;func sleepGopher() &#123; time.Sleep(3 * time.Second) fmt.Println(\"...snore...\")&#125; 3.1.3 goroutine的参数向goroutine传递参数就根向函数传递参数一样，参数都是按值传递的（传入的是副本） 1234567891011121314151617func main() &#123; for i := 0; i &lt; 5; i++ &#123; go sleepGopher(i) &#125; time.Sleep(4 * time.Second)&#125;func sleepGopher(id int) &#123; time.Sleep(3 * time.Second) fmt.Println(\"...snore...\", id)&#125;// ...snore... 2// ...snore... 3// ...snore... 0// ...snore... 1// ...snore... 4 在使用goroutine时，各个goroutine的执行顺序无法确定； 3.2 runtime包3.2.1 Goschedruntime.Gosched() 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次再获得cpu时间轮片的时候，从该让cpu的位置恢复执行。 当再次获得cpu时，从出让位置继续回复执行； —— 时间片轮转调度算法； 123456789101112func main()&#123; go func()&#123; for &#123; fmt.Println(\"this is goroutine\") &#125; &#125; for &#123; runtime.Gosched() // fmt.Println(\"this is main test\") &#125;&#125; 3.2.2 Goexit调用runtime.Goexit(), 将立即终止 当前goroutine执行，调度器确保所有已注册defer延迟调用被执行； return和Goexit之间的差异 return：返回当前函数调用给调用者；后续语句不糊执行了。return之前的defer生效，之后的defer不生效了； Goexit：结束调用该函数的当前goroutine，Goexit()之前注册的defer都生效； 123456789101112131415func test()&#123; defer fmt.Println(\"ccc\") runtime.Goexit(); fmt.Println(\"ddd\")&#125;func main()&#123; go func()&#123; fmt.Println(\"aaa\") test() fmt.Println(\"bbb\") &#125;() for&#123;&#125;&#125;// aaa// ccc 3.2.3 runtime.GOMAXPROCS()调用runtime.GOMAXPROCS() 设置可以并行计算的CPU核数最大值，并返回之前的值； 返回值：上一次设置的核心数 3. channelchannel是Go语言中的一个核心类型，可以把它看成管道（FIFO，first in ，first out）。并发核心单元通过它就可以发送或接收数据进行通讯，这在一定程度上又进一步降低了编程难度； channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享的问题 goroutine运行在相同的地址空间，因此访问共享内存必须做好同步，goroutine奉行通过通信来共享内存，而不是共享内存来通信； 引用类型channel可用于多个gouroutine通讯，其内部实现了同步，确保并发安全； CSP是Communicating Sequential Process的简称，直译为通讯顺序进程，或者叫做交换信息的循序进程，是用来描述并发系统中进行交互的一种模式； csp允许使用进程组件来描述系统，它们独立运行，并且只通过消息传递的方式通信；go通过引入Channel这个新的类型，来实现CSP的思想； Don‘t communicate by sharing memory, share memory by communication; (执行业务处理的goroutine不要通过共享内存的方式通信，而是要通过Channel通信的方式分享数据) Don‘t communicate by sharing memory: 是传统的并发编程处理方式，就是指，共享的数据需要锁保护，goroutine需要获取到锁，才能并发访问数据； share memory by communication：类似CSP模型的方式，通过通信的方式，一个goroutine可以把数据“所有权”交给另外一个goroutine； 啥时候用channel Go开发者极力推荐使用channel，不过，这两年，大家意识到，channel并不是处理并发问题的“银弹”，有时候使用并发原语更简单，并且不容易出错。 共享资源的并发访问使用传统并发原语； 复杂的任务编排和消息传递使用channel； 消息通知机制使用channel，除非只想signal一个goroutine，才使用Cond； 简单等待所有任务的完成用WaitGroup，也有Channel的推崇者用Channel，都可以； 需要和Select语句结合，使用Channel； 需要和超时配合时，使用Channel和Context； 3.0 channel应用场景的五种类型3.0.1 数据交流 当作并发的buffer或者queue，解决生产者 - 消费者问题。多个goroutine可以并发当作生产者（producer）和消费者(Consumer) 3.0.2 数据传递 一个goroutine将数据交给另一个goroutine，相当于把数据的拥有权（引用）托付出去； 例题：有4个goroutine，编号为，1，2，3，4 没秒会有一个goroutine打印出它自己的编号，要求你编写程序，让输出的编号总是按照1，2，3，4，1，2，3，4.。。 这个顺序打印出来； 为了实现顺序的数据传递，可以定一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌传递给下一个goroutine，我们尝试使用chan来实现； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( \"fmt\" \"time\")// select，通过select 可以监听channel上的数据流动// 如果给出default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复// 如果没有default语句，那么select语句将会被阻塞，直到至少有一个通信可以进行下去type Token struct&#123;&#125;func newWorker(id int, ch chan Token, nextCh chan Token) &#123; for &#123; token := &lt;-ch // 从自己的chan 中读取令牌 fmt.Println(id + 1) // id 从1开始 time.Sleep(time.Second) nextCh &lt;- token &#125; //for &#123; // token := &lt;- chs[0] // fmt.Println(0 + 1) // time.Sleep(time.Second) // chs[1] &lt;- token //&#125; //for &#123; // token := &lt;-chs[1] // fmt.Println(1 + 1) // time.Sleep(time.Second) // chs[2] &lt;- token //&#125; //for &#123; // token := &lt;- chs[2] // fmt.Println(2 + 1) // time.Sleep(time.Second) // chs[3] &lt;- token //&#125; //for &#123; // token := &lt;-chs[3] // fmt.Println(3 + 1) // time.Sleep(time.Second) // chs[0] &lt;- token //&#125;&#125;func main() &#123; chs := []chan Token&#123;make(chan Token), make(chan Token), make(chan Token), make(chan Token)&#125; // 创建4个worker for i := 0; i &lt; 4; i++ &#123; go newWorker(i, chs[i], chs[(i+1)%4]) // 启动每个worker的goroutine //newWorker(0, chs[0], chs[1]) //newWorker(1, chs[1], chs[2]) //newWorker(2, chs[2], chs[3]) //newWorker(3, chs[3], chs[0]) &#125; // 首先把令牌交给第一个worker chs[0] &lt;- struct&#123;&#125;&#123;&#125; select &#123;&#125;&#125; 如上面注释代码所示，channel实现顺序打印1，2，3，4.实际上就是利用token的，来将多个channel串联；因为每个for循环中的channel如果在读写两端没有数据写入或读取的话。channel是被阻塞挂起的； 这类场景有一个特点，就是当前持有数据的goroutine都有一个信箱，信箱使用chan实现，goroutine只需要关注自己的信箱中的数据，处理完毕后，就把结果发送到下一家的信箱中； 4.0.3 信号通知 一个goroutine可以将信号（closing，closed, data ready等）传递给另一个或者另一组goroutine chan类型有这样一个特点，chan如果为空，那么receiver接收数据的时候就会阻塞等待，直刀chan被关闭或者有新的数据到来，利用这个机制，我们可以实现wait/notify的设计模式； 除了正常业务处理时的wait/notify，经常碰到的一个场景，就是程序关闭的时候，我们需要在退出之前做一些清理，这个时候，经常用到chan 退出的时候分为两个阶段 closing，代表程序退出，但是清理工作还没做 closed，代表清理工作已经做完； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"os\" \"os/signal\" \"syscall\" \"time\")func main() &#123; var closing = make(chan struct&#123;&#125;) var closed = make(chan struct&#123;&#125;) go func() &#123; for &#123; select &#123; case &lt;-closing: return default: // .... 业务计算 time.Sleep(100 * time.Millisecond) &#125; &#125; &#125;() // 处理 ctrl+c 等中断信号 termChan := make(chan os.Signal) signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM) &lt;-termChan close(closing) // 执行退出之前的清理动作 go doCleanup(closed) select &#123; case &lt;-closed: case &lt;-time.After(time.Second): fmt.Println(\"清理超时，不等了\") &#125; fmt.Println(\"优雅退出\")&#125;func doCleanup(closed chan struct&#123;&#125;) &#123; time.Sleep(time.Minute) close(closed)&#125; 4.0.4 任务编排 可以让一组goroutine按照一定的顺序并发或者串行的执行，这就是编排的功能； 多个chan的编排方式，共5种 4.0.4.1 Or-Done模式 使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义一个类型为chan struct{}类型的done变量，等通知任务结束后，我们就可以close这个变量，然后，其他receiver就会收到这个通知； 这是有一个任务的情况，如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是Or-Done模式 比如，你发送同一个请求到多个微服务节点，只要任意一个微服务节点返回结果，就算成功，实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( \"fmt\" \"time\")func or(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123; // 特殊情况，只有0个或者1个chan switch len(channels) &#123; case 0: return nil case 1: return channels[0] &#125; orDone := make(chan interface&#123;&#125;) go func() &#123; defer close(orDone) switch len(channels) &#123; case 2: // 2也是一种特殊情况 select &#123; case &lt;-channels[0]: case &lt;-channels[1]: &#125; default: // 超过2个，二分递归处理 m := len(channels) / 2 select &#123; case &lt;-or(channels[:m]...): case &lt;-or(channels[m:]...): &#125; &#125; &#125;() return orDone&#125;// testfunc sig(after time.Duration) &lt;-chan interface&#123;&#125; &#123; c := make(chan interface&#123;&#125;) go func() &#123; defer close(c) time.Sleep(after) &#125;() return c&#125;func main() &#123; start := time.Now() &lt;-or( sig(10*time.Second), sig(20*time.Second), sig(30*time.Second), sig(40*time.Second), sig(50*time.Second), sig(01*time.Minute), ) fmt.Printf(\"done after %v\", time.Since(start))&#125; 4.0.4.2 扇入模式4.0.4.3 扇出模式4.0.4.4 Stream 介绍一种把Channel当作流式管道使用的方式，也就是把Channel看作流（Stream）,提供跳过几个元素，或者是只取其中几个元素等方法 下面这个方法一个数据slice转换成流 1234567891011121314func asStream(done &lt;-chan struct&#123;&#125;, values ...interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123; s := make(chan interface&#123;&#125;) go func() &#123; defer close(s) for _, v := range values &#123; // 遍历数组 select &#123; case &lt;-done: return case s &lt;- v: // 将数组元素塞入chan中 &#125; &#125; &#125;() return s&#125; 流创建好之后，下面介绍实现流的方法 takeN: 只取流中前n个数据 takeFn: 筛选流中数据，只保留满足条件的数据： takeWhile: 只取前面满足条件的数据，一旦不满足条件，就不再取： skipN: 跳过流中前几个数据； skipFn: 跳过满足条件的数据； skipWhile: 跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给Channel的receiver 1234567891011121314func takeN(done &lt;-chan struct&#123;&#125;, valueStream &lt;-chan interface&#123;&#125;, num int) &lt;-chan interface&#123;&#125; &#123; takeStream := make(chan interface&#123;&#125;) go func() &#123; defer close(takeStream) for i := 0; i &lt; num; i++ &#123; select &#123; case &lt;-done: return case takeStream &lt;- &lt;-valueStream: // 从输入流中读取元素 &#125; &#125; &#125;() return takeStream&#125; 4.0.4.5 Map-Reduce123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport \"fmt\"// mapfunc mapChan(in &lt;-chan interface&#123;&#125;, fn func(interface&#123;&#125;) interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123; out := make(chan interface&#123;&#125;) if in == nil &#123; close(out) return out &#125; go func() &#123; // 启动一个goroutine，实现map的主要逻辑 defer close(out) for v := range in &#123; // 从输入chan读取数据，执行业务操作，也就是map操作 out &lt;- fn(v) &#125; &#125;() return out&#125;// reducefunc reduce(in &lt;-chan interface&#123;&#125;, fn func(r, v interface&#123;&#125;) interface&#123;&#125;) interface&#123;&#125; &#123; if in == nil &#123; return nil &#125; out := &lt;-in // 先读取第一个元素 for v := range in &#123; // 实现reduce 主要逻辑 out = fn(out, v) &#125; return out&#125;// 写一个程序，这个程序使用 map-reduce 模式处理一组整数，map函数就是为每个整数乘以10， reduce函数就是把map处理的结果累加起来// 生成一个数据流func AsStream(done &lt;-chan struct&#123;&#125;) &lt;-chan interface&#123;&#125; &#123; s := make(chan interface&#123;&#125;) values := []int&#123;1, 2, 3, 4, 5&#125; go func() &#123; defer close(s) for _, v := range values &#123; // 从数组生成 select &#123; case &lt;-done: return case s &lt;- v: &#125; &#125; &#125;() return s&#125;func main() &#123; in := AsStream(nil) // map *10 mapFn := func(v interface&#123;&#125;) interface&#123;&#125; &#123; return v.(int) * 10 &#125; // reduce 累加 reduceFn := func(r, v interface&#123;&#125;) interface&#123;&#125; &#123; return r.(int) + v.(int) &#125; sum := reduce(mapChan(in, mapFn), reduceFn) // 返回累加结果 fmt.Println(sum) // 150&#125; 4.0.5 锁 利用Channel也可以实现互斥锁的机制； 要想使用chan实现互斥锁，至少有两种方法， 一种方式是先初始化一个capacity等于1的channel，然后再放入一个元素。这个元素就代表锁，谁取得了这个元素，就相当于获取了这把锁。 另一种方式是，先初始化一个capacity等于1的channel，它的空槽代表锁，谁能成功把元素发送这个Channel，谁就获取了这把锁； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport ( \"fmt\" \"time\")type Mutex struct &#123; ch chan struct&#123;&#125;&#125;// 使用锁需要初始化func NewMutex() *Mutex &#123; mu := &amp;Mutex&#123;make(chan struct&#123;&#125;, 1)&#125; mu.ch &lt;- struct&#123;&#125;&#123;&#125; return mu&#125;// 请求锁，直到获取func (m *Mutex) Lock() &#123; &lt;-m.ch&#125;// 解锁func (m *Mutex) unlock() &#123; select &#123; case m.ch &lt;- struct&#123;&#125;&#123;&#125;: default: panic(\"unlock of unlocked mutex\") &#125;&#125;// 尝试获取锁func (m *Mutex) TryLock() bool &#123; select &#123; case &lt;-m.ch: return true default: &#125; return false&#125;// 加入一个超时的设置func (m *Mutex) LockTimeout(timeout time.Duration) bool &#123; timer := time.NewTimer(timeout) select &#123; case &lt;-m.ch: timer.Stop() return true case &lt;-timer.C: &#125; return false&#125;// 锁四否已被持有func (m *Mutex) IsLocked() bool &#123; return len(m.ch) == 0&#125;func main() &#123; m := NewMutex() ok := m.TryLock() fmt.Printf(\"locked v %v\\n\", ok) ok = m.TryLock() fmt.Printf(\"locked %v\\n\", ok)&#125;//locked v true//locked false 用buffer等于1的chan实现互斥锁，在初始化这个锁的时候往Channel中先塞入一个元素，谁把这个元素取走，谁就获取这把锁，把元素放回去，就是释放了锁。元素在放回chan之前，不会有goroutine能从chan中取出元素的，这就保证了互斥性； 利用select+chan的方式，很容易实现TryLock，Timeout的功能。具体来说就是，在select语句中，我们可以使用default实现TryLock，使用一个Timer来实现Timeout的功能； 4.1 channel语法channel可以在多个goroutine之间安全的传值； 通道可以用作变量、函数参数、结构体字段。。。 创建通道用make函数，并指定其传递数据的类型 1c:= make(chan int) Channel类型分为 只能接收，只能发送，既可以接收又可以发送三种类型； 1ChannelType=(\"chan\" | \"chan\" \"&lt;-\" | \"&lt;-\" \"chan\") 123chan string // 可以发送接收stringchan&lt;- struct&#123;&#125; // 只能发送struct&#123;&#125;&lt;-chan int // 只能从chan接收int channel是一个对应make创建的底层数据结构的引用； 当复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和 其它的引用类型一样，channel的零值也是nil 定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的make函数来创建。 1234// Type 指定channel收发数据的类型；make(chan Type) // 等价于 make(chan Type, 0) 容量为0 称为 unbuffered chan// capacity 容量 make(chan Type, capacity) // 称为 buffered chan 当参数 capacity=0 时，channel是无缓冲阻塞读写的，当capacity&gt;0 时，channel有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入； channel一边可以存东西，另一边可以取东西。channel通过 &lt;- 来接收和发送数据，发送和接收数据语法； 1234channel &lt;- value // 发送value到channel&lt;- channel // 接收并将其丢弃x := &lt;-channel // 从channel中接收数据，并赋值给xx, ok:= &lt;-channel // 功能同上，同时检查通道是否已经关闭或者是否为空 nil是 chan的零值，是一种特殊的chan，对值是nil的chan的发送接收调用者总是会阻塞； go内建的函数 close，cap，len都可以操作chan类型： close会把chan关闭掉，cap返回chan的容量，len返回chan中缓存的还未被取走的元素数量； for range ch{} 用于清空chan 4.2 channel实现原理4.2.1 channel的数据结构 qcount ：代表chan中已经接收但还没被取走的元素的个数，内建函数len可以返回这个字段的值； dataqsiz： 队列的大小，chan使用一个循环队列存放元素，循环队列很适合这种生产者 - 消费者的场景； buf： 存放元素的循环队列的buffer elemtype 和elemsize： chan中元素的类型和size，因为chan一旦声明，它的元素类型是固定的，即普通类型或者指针类型，所以元素大小也是固定的； sendx： 处理发送数据的指针在buf中的位置，一旦接收了新的数据，指针就会加上elemsize，移向了下一个位置。buf的总大小是elemsize的整数倍，而且buf是一个循环列表 recvx： 处理接收请求时的指针在buf中的位置，一旦取出数据，此指针会移动到下一个位置 recvq： chan是多生产者多消费者的模式，如果消费者因为没有数据可读而被阻塞了，就会被加入到recvq队列中； sendq：如果生产者因为buf满了而阻塞，会被加入到sendq队列中； 4.2 groutine 通信每当一个进程启动时，系统会自动打开三个文件，标准输入·标准输出·标准错误 —— 对应三个文件：stdin、 stdout、 stderr stdin对应的硬件 ——硬盘 stdout对应的硬件—— 屏幕 stderr对应的硬件——屏幕 当进程圆形结束，操作系统会自动关闭三个文件； 12345678910111213141516171819202122232425func printer(s string) &#123; for _, ch := range s &#123; fmt.Printf(\"%c\", ch) time.Sleep(300* time.Millisecond) &#125;&#125;// define tow people use printerfunc person1() &#123; printer(\"person1\")&#125;func person2()&#123; printer(\"person2\")&#125;func main()&#123; go person1() go person2() for &#123; ; &#125; // ppeerrssoonn21&#125; 12345678910111213141516171819func person1() &#123; channel&lt;-891 printer(\"person1\")&#125;func person2()&#123; printer(\"person2\")&#125;func main()&#123; go person1() go person2() for &#123; ; &#125; // person2 // 因为channel不设置容量是 无缓冲阻塞读写的；所以go程person1的printer方法没发输出数据了；只能是go程序2 执行&#125; channel有两个端： 一端： 写端（传入端） chan &lt;- 另一端： 读端（传出端）&lt;- chan 要求： 读端和写端必须同时满足条件，才能在chan上进行数据流动。否则，则阻塞； （读端去读了，chan没有，就是读端阻塞。写端写了，但是chan没有读，就是写端阻塞。总之就是谁操作了，阻塞谁。） 4.3 无缓冲的channel无缓冲的channel(unbuffered channel)是指在接收前没有能力保存任何值的通道； 这种类型的通道要求发送goroutine 和接收 goroutine同时准备好，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的goroutinue阻塞。 这种对通道进行发送和接收的交互行为本身就是同步的，其中任意一个操作都无法离开另一个操作单独存在。 阻塞：由于某种原因数据没有到达，当前协程持续处于等待状态，直到条件满足，才解除阻塞。 同步： 在两个或多个协程（线程）间，保持数据内容一致性的机制； 123456ch: make(chan string)// 写端ch &lt;- \"he\" // 写端写数据，读端不在读，阻塞// 读端str:=&lt;-ch // 读端读数据，同时写端不在写，读端阻塞 4.3.1 channel同步，数据传递12345678910111213141516func main() &#123; channel := make(chan string) go func() &#123; for i := 0; i &lt; 2; i++ &#123; fmt.Println(\"i=\", i) &#125; channel &lt;- \"123\" &#125;() str := &lt;-channel // 阻塞写，上面的go程才有机会执行； fmt.Println(str) // i= 0// i= 1// 123&#125; 第1步，两个goroutine都到达通道，但哪个都没有开始执行发送或接收 第2步，左侧的goroutine将它的手伸进了通道，这模拟了向通道发送数据的行为，这时，这个goroutine会在通道中被锁住，直到交换完成； 第3步，右侧的goroutine将它的手放入通道，这模拟了从通道里接收数据，这个goroutine一样也会在通道中被锁住，直到交换完成 在第4步和第5步，进行交换，并最终，在第6步，两个goroutine都将它们的手从通道里面拿出来，这模拟了被锁住的goroutine得到释放，两个goroutine现在都可以去做其他事情了； 123456789101112131415161718192021222324252627func main() &#123; ch := make(chan int) go func() &#123; for i := 0; i &lt; 5; i++ &#123; fmt.Println(\"子go程 i=\", i) ch &lt;- i // // 1.当程序一个值往ch中写入时，由于channel中读的goroutine未就位，当前goroutine阻塞，下一个goroutine得以执行 &#125; &#125;() for i := 0; i &lt; 5; i++ &#123; num := &lt;-ch // // 2. 当执行到这里，读gorutine就位；上面的`ch&lt;-i` gorouine立即被唤醒并继续执行。执行之后，读gorouine也脱离channel，开始往下继续执行； fmt.Println(\"主go程读\", num) &#125;&#125;子go程 i= 0子go程 i= 1 // 这里为什么不是 主go程读 0主go程读 0主go程读 1子go程 i= 2子go程 i= 3主go程读 2主go程读 3子go程 i= 4主go程读 4 *为什么第二行不是 “子go程 i= 1” * 因为fmt.Println(&quot;主go程读&quot;, num)是IO操作，耗时（访问硬件）可能需要等待； channel应用与 两个goroutine中，一个读，一个写； 具备同步的能力，读、写同步 有缓冲channel 4.3.2 channel的len和cap123var channel = make(chan int)len(channel) // 0 channel中剩余未读取数据个数cap(channel) // 0 channel的容量 有缓冲channel 通道容量为非0， len(ch): channel中剩余未读取数据个数。cap(ch): 通道容量 channel应用于两个go程中，一个读，另一个写 缓冲区可以进行数据存储，存储至容量上限，阻塞，具备异步能力，不需要同时操作channel缓冲区（发短信） 1234567891011121314151617181920212223242526272829func main() &#123; ch := make(chan int, 2) // 存满3个元素之前不会阻塞 fmt.Println(\"len=\", len(ch), \"cap=\", cap(ch)) go func() &#123; for i := 0; i &lt; 6; i++ &#123; ch &lt;- i fmt.Println(\"子go程 i=\", i) &#125; &#125;() // time.Sleep(300 * time.Millisecond) for i := 0; i &lt; 6; i++ &#123; num := &lt;-ch fmt.Println(\"主go程读\", num) &#125;&#125;len= 0 cap= 2子go程 i= 0子go程 i= 1子go程 i= 2主go程读 0主go程读 1主go程读 2主go程读 3子go程 i= 3子go程 i= 4子go程 i= 5主go程读 4主go程读 5 4.4 关闭channel如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现； 确定不再向对端发送接收数据时，使用close关闭channel 对端可以判断channel是否关闭 1234if num, ok:= &lt;-ch; ok == true &#123; // 如果对端已经关闭， ok--&gt;false, num无数据 // 如果对端没有关闭，ok--&gt; true，num保存读到的数据&#125; 12345678910111213141516171819202122func main() &#123; ch := make(chan int) go func() &#123; for i := 0; i &lt; 5; i++ &#123; ch &lt;- i &#125; close(ch) &#125;() for &#123; // 不再需要指定循环次数 if num, ok := &lt;-ch; ok == true &#123; fmt.Println(\"读取数据\", num) &#125; else &#123; break &#125; &#125;&#125;读取数据 0读取数据 1读取数据 2读取数据 3读取数据 4 总结 1:数据没发送完，不应该关闭。 2 已经关闭的channel，不能再写入数据 3 写端已经关闭的channel，可以从中读取数据， ​ 读无缓冲channel 读到0， —— 说明写端关闭 ​ 读有缓冲channel，如果缓冲区有数据，先读数据。读完数据可以无限读，读到0 4.5 单向channel默认的channel是双向的， var ch chan int ch:=make(chan int) 单向写channel： var sendCh chan &lt;- int sendCh = make(chan &lt;- int) 单向读channel： var recvCh &lt;- chan int recvCh = make(&lt;- chan int) 转换： 双向channel 可以隐士转换为任意一种单向channel 1sendCh = ch 单向channel不能转换为双向channel 1ch = sendCH/recvCh // error!!! 传参：传【引用】 12345678ch := make(chan int)var sendCh chan&lt;- int = ch // 双向channel赋值给写channelsendCh &lt;- 789var recvCh &lt;-chan int = ch // 双向channel赋值给读channelnum := &lt;-recvChfmt.Println(\"num\", num)var ch2 chan int = sendCh //compiler error 单向channel无法赋值给双向channel 单向channel的好处，约束子函数行为。 12345678910111213141516171819package mainimport \"fmt\"func send(out chan&lt;- int) &#123; out &lt;- 123 // 只能往channel写，无法做读取操作 close(out)&#125;func recv(into &lt;-chan int) &#123; n := &lt;-into // 只能从channel读，无法做写入操作 fmt.Println(\"into=\", n) // 123&#125;func main() &#123; ch := make(chan int) go func() &#123; send(ch) &#125;() recv(ch)&#125; 4.6 生产者消费者模型单向channel最典型的应用是“生产者消费者模型” 所谓“生产者消费者模型”： 某个模块（函数等）负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、协程、线程、进程等）产生数据的模块，就形象地成为生产者，而处理数据的模块，就称为消费者。 单单抽象出生产者和消费者，还够不上是生产者/消费者模型。改模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。 1生产者——》缓冲区——》消费者 举例，假如需要寄出一封信，大致流程如下： 把信写好——相当于生产者制造数据 把信放入油桶——相当于生产者把数据放入缓冲区 邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区 生产者：发送数据端 消费者：接收数据端 缓冲区的好处 解耦（降低生产者和消费者之间耦合度） 生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据了；（生产者和消费者数量不对等时，能保持正常通信）基本不需要依赖消费者的处理速度； 缓存，生产者和消费者处理数据速度不一致时，暂存数据（如果生产者制造数据时快时慢，缓冲区的好处就提体现出来了。当数据制造快消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉） Channel 实现缓冲区 有缓冲channel和无缓冲channel都能实现缓冲区 有缓冲channel 异步通信 用于对实时不敏感的需求； 无缓冲channel 同步通信，用于实时需求； 4.7 channel作为参数传递，是引用传递4.8 模拟订单订单处理就是典型的生产消费模式 当很多用户单击下订单按钮后，订单生产的数据全部放到缓冲区，然后消费者将队列中的数据取出来发送到管理系统 通过生产者消费模式，将订单系统与仓库管理系统隔离开，且用户可以随时下单。如果订单系统直接调用仓库系统，那么用户单击下订单按钮后，要等到仓库系统的结果返回，这样速度会很慢； 4.9 定时器time.Timer Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间 1234type Timer struct &#123; C &lt;- chan Time r runtimeTimer&#125; 它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统自动向timer.C这个channel中写入当前时间，阻塞即被解除； 4.10 channel（通道）发送、接收使用左箭头操作符 &lt;- 向channel发送值或从channel接收值； 12c &lt;- 99 // 向通道发送值， 把值为 99 的值 发送给通道cr:= &lt;- c // 从通道接收值 从通道c接收一个值，并将此值赋给 r变量 发送操作会等待直到另一个goroutine尝试对该channel进行接收操作为止； 执行发送操作的goroutine在等待期间将无法执行其它操作 未在等待channel操作的goroutine仍然可以继续自由的运行 执行接收操作的goroutine将等待直到另一个goroutine尝试向该channel进行发送操作为止； 123456789101112131415161718func main() &#123; c := make(chan int) // create a channel for i := 0; i &lt; 5; i++ &#123; go sleepGopher(i, c) &#125; for i := 0; i &lt; 5; i++ &#123; // 一共有5个 //gopher会往此通道发送值； gopherID := &lt;-c // 当i=0时，等待大约3s之后，有其它gopher给它发送值了。 // 可能是 0 1 2 3 4 任意一个值，因为goroutine的顺序无法确定 fmt.Println(\"gopher\", gopherID, \"has finished sleeping\") &#125;&#125;func sleepGopher(id int, c chan int) &#123; time.Sleep(3 * time.Second) fmt.Println(\"...\", id, \"snore ...\") c &lt;- id // 向通道发送值&#125; 4.11 使用select处理多个通道前面的例子中是使用一个channel来等待多个 goroutine，这种做法在所有goroutine都产生相同类型值的时候是好用的。但实际开发中，情况并不只是如此；程序通常需要等待不同类型的值； 当等待通道中某些值的时候，不想等太久。或者想在网络请求等待数秒之后就将其设置为超时而不是白白等待好几分钟。go标准库提供了一个time.After函数，该函数返回一个channel，该channel在指定时间后会接收到一个值（这个值是由go运行时的一个goroutine发送的 ）； 如果程序想继续从goroutine接收值，那必须等到所有goroutine都结束睡眠或我们耐心耗尽为止。这意味着程序必须同时等到time.After这个计时器channel 和其它channel。这个时候就能使用select语句。select语句能做到这一点。 select语句与switch有点像 该语句包含的每个case都持有一个通道，用来发送或接收数据； select会等待直到某个case分支的操作就绪，然后就会执行该case 分支； select语句不包含任何case的情况下将永远等下去 12345678910111213141516171819202122func main() &#123; c := make(chan int) // create a channel for i := 0; i &lt; 5; i++ &#123; go sleepGopher(i, c) &#125; timeout := time.After(2 * time.Second) // 创建一个超时时间2s 的 channel for i := 0; i &lt; 5; i++ &#123; select &#123; case gopherID := &lt;-c: // 从通道接收值 fmt.Println(\"gopher\", gopherID, \"has finished sleeping\") case &lt;-timeout: //等2s 超时 还未接收到 fmt.Println(\"my patience ran out\") return // return 会跳出select &#125; &#125;&#125;func sleepGopher(id int, c chan int) &#123; time.Sleep(time.Duration(rand.Intn(4000)) * time.Millisecond) // 生成一个0-4s的随机时间 c &lt;- id&#125; 注意： 即使已经停止等待goroutine，但只要main函数还没返回，仍在运行的goroutine将会继续占用内存；（有条件，尽量清理掉） 4.12 nil通道 值为nil的通道 如果不使用make初始化channel，那么channel变量的值就是nil(零值) 对nil通道进行发送或接收不会引起panic，但会导致永久阻塞； 对nil通道执行close函数，那么会引起panic 2.3.1 nil通道的用处：对于包含select语句的循环，如果不希望每次循环都等待select所涉及的所有通道，那么可以先将某些channel设置为nil，等到发送值准备就绪之后，再将channel变成一个非nil值并执行发送操作； 3 阻塞和死锁当goroutine在等待channel的发送或接收时，我们就说它被阻塞了； 除了goroutine本身占用少量的内存外，被阻塞的goroutine并不消耗任何其它资源； goroutine静静地停在那里，等到导致其阻塞的事情来解除阻塞 当一个或多个goroutine因为某些永远无法发生的事情被阻塞时，我们称这种情况为死锁，而出现死锁的程序通常会崩溃或挂起； 12345678910111213141516// 引发死锁的例子func main() &#123; c := make(chan int) &lt;-c&#125;// fatal error: all goroutines are asleep - deadlock!// goroutine 1 [chan receive]:// 使用goroutine 解决死锁问题func main() &#123; c := make(chan int) go func() &#123; c &lt;- 2 &#125;() &lt;-c&#125; 3.1 地鼠装配线Go允许在没有值可供发送的情况下通过close函数关闭通道 例如close(c) 通道被关闭后无法写入任何值，如果尝试写入将引发panic 尝试读取被关闭的通道会获得与通道类型对应的零值； 注意： 如果循环里读取一个已关闭的通道，并没有检查通道是否关闭，那么该循环可能会一直运转下去，耗费大量CPU时间 执行以下代码可得知通道是否被关闭 v,ok := &lt;-c v为通道得到的值，ok bool类型，如果ok为false，那么说明此通道已关闭； 12345678910111213141516171819202122232425262728293031323334353637383940414243func sourceGopher(downstream chan string) &#123; for _, v := range []string&#123;\"hello, world\", \"a bad apple\", \"goodbye all\"&#125; &#123; downstream &lt;- v &#125; // downstream &lt;- \"\" // 重构为 close(downstream)&#125;func filterGopher(upstream, downstream chan string) &#123; for &#123; item, ok := &lt;-upstream // if item == \"\" &#123; 重构 if !ok &#123; // downstream &lt;- \"\" close(downstream) return &#125; if !strings.Contains(item, \"bad\") &#123; downstream &lt;- item &#125; &#125;&#125;func printGopher(upstream chan string) &#123; for &#123; v := &lt;-upstream if v == \"\" &#123; return &#125; fmt.Println(v) &#125;&#125;func main() &#123; c0 := make(chan string) c1 := make(chan string) go sourceGopher(c0) go filterGopher(c0, c1) printGopher(c1) // hello, world // goodbye all&#125; 3.2 常用模式从通道读取值，直到它关闭为止（常用） 可以使用range关键字达到该目的 123456789101112131415161718192021222324252627282930313233func sourceGopher(downstream chan string) &#123; for _, v := range []string&#123;\"hello, world\", \"a bad apple\", \"goodbye all\"&#125; &#123; downstream &lt;- v &#125; // downstream &lt;- \"\" // 重构为 close(downstream)&#125;func filterGopher(upstream, downstream chan string) &#123; for item := range upstream &#123; if !strings.Contains(item, \"bad\") &#123; downstream &lt;- item &#125; &#125; close(downstream) // 关闭下游通道&#125;func printGopher(upstream chan string) &#123; for v := range upstream &#123; fmt.Println(v) &#125;&#125;func main() &#123; c0 := make(chan string) c1 := make(chan string) go sourceGopher(c0) go filterGopher(c0, c1) printGopher(c1) // hello, world // goodbye all&#125; homework 编写一个流水线部件（一个goroutine），他需要记住前面出现的所有值，并且只有在值之前从未出现过的情况下才会将值传递至流水线的下一个阶段，假定第一个值永远不是空字符串 编写一个流水线部件，它接收字符串并将它们拆分成单词，然后向流水线的下一阶段一个接一个发送这些单词（可以用strings.Fields函数） 4 并发状态4.1 共享值与竞争条件（race condition）工厂某些生产线出现库存不足的情况，它们需要订购更多的原材料。尽管每条生产线都有固定电话，但是工厂只有一条共享的电话路线。当一个工人拿起电话下订单的时候，另一只地鼠可能会拿起电话拨号。对正在讲话的前一个工人产生干扰，而之后可能还会有其它的工人尝试使用电话。最终就是所有工人一头雾水，订单也无法下达。 为了解决这个问题，工厂工人必须达成某些协议。使得同一时间之内只有一只地鼠使用电话。而go语言里共享值的概念就跟共享电话有些相似。 当有两个或者多个goroutine同时使用共享值的时候，程序可能出错。把这种多个goroutine争相使用值的情况称之为竞争条件或者竞争状态（race condition）而go的compiler实际上包含了尝试在代码里发现静态条件这个功能。 两个goroutine同时读取，并不会产生 race condition。 4.2 Go的互斥锁(mutex)Mutex= mutual exclusive ​ 相互的 独占的 一个工厂想出一个很好的主意，在工厂地板中间放置一个玻璃罐，并在玻璃罐中放置了一个金属令牌。每次想要打电话的地鼠都需要从罐子里面取出令牌。然后在打电话的过程中一直持有它。然后打完电话再把它放回到罐子里面。如果有一只地鼠想打电话，但是没有在罐子里面发现令牌。就需要轮训等待直到令牌归还为止。go语言的互斥锁就相当于此玻璃罐。goroutine就可以通过互斥锁阻止其它的goroutine在同一时间进行某些事情。为了保护互斥锁的互斥性质，程序在访问被保护的东西的时候必须得非常的小心。互斥锁有两个方法 Lock 和 Unlock, Lock相当于从金属罐里面取出令牌，Unlock相当于把令牌放回玻璃罐； 如果有goroutine尝试在互斥锁已经锁定的情况下，再调用lock方法，那么它就需要等待解锁之后再次上锁。为了正确使用互斥锁，就要确保锁访问共享值的代码必须先锁定互斥锁，然后才能执行所需的操作。并且在操作完成之后必须解除互斥锁，任何不遵循这一模式的代码都可能引发竞争条件。基于此原因，互斥锁在绝大多数情况下，只会在包内进行使用；这个包会通过互斥锁保护自定义的内容，并将相应的lock和unlock调用，巧妙的隐藏在函数和方法的背后。和channel不一样，互斥锁并未内置在go语言中。而是通过sync包来引入的； 1234567891011package mainimport \"sync\"var mu sync.Mutexfunc main() &#123; mu.Lock() defer mu.Unlock() // the lock is held until we return from the function&#125; 互斥锁定义在被保护的变量之上 12345# test1. 当两个goroutine同时修改一个值的时候，会发生什么2. 尝试对一个已经被锁定的互斥锁进行锁定操作，会发生什么3. 尝试多一个未被锁定的互斥锁进行解锁操作，会发生什么4. 同时在多个不同的goroutine里面调用相同类型的方法是安全的吗 4.2 互斥锁的实现机制互斥锁是并发控制的一个基本手段；是为了避免竞争二建立的一种并发控制机制； 临界区： ​ 临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作，对一个IO设备的使用；对一个连接池中的连接的调用； 使用互斥锁，限定临界区只能同时由一个线程持有；互斥锁又名排他锁 Mutex是使用最广泛的同步原语，有人也叫做并发原语； 4.2.1 同步并发原语 mutex是使用最广泛的同步原语； 同步原语 互斥锁Mutex 读写锁RWMutex 并发编排WaitGroup 条件变量Cond Channel 同步原语适应的场景 共享资源： ​ 并发读写共享资源，会引发数据竞争，所以需要Mutex，RWMutex这样的并发原语来保护 任务编排： ​ 需要goroutine按照一定的规律执行，而goroutine之间有相互等待或者依赖的顺序关系，常常使用WaitGroup或Channel来实现； 消息传递： ​ 信息交流以及不同的goroutine之间的线程安全的数据交流，常常使用channel； 4.2.2 Locker 接口1234type Locker interface &#123; Lock() Unlock()&#125; Mutex 和 RWMutex都实现了Locker接口； 4.2.3 sync.Mutex 控制等待一组goroutine全部做完任务； 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"sync\")var mutex sync.Mutex // mutex的零值是还没有goroutine等待的未加锁的状态，不需要额外初始化；var wg sync.WaitGroupfunc main()&#123; var count int64 = 0 wg.Add(10) for i:=0; i&lt;10; i++ &#123; go func() &#123; defer wg.Done() // 对变量count执行10次加1 for j:=0 ;j&lt; 100000; j++ &#123; mutex.Lock() count++ mutex.Unlock() &#125; &#125;() &#125; // 等待10个goroutine完成 wg.Wait() fmt.Println(count)&#125; 上面如果不加 mutex.Lock，我们发现最终结果得不到100000， 说明count++ 不是个原子操作；因为操作不原子，所以就可能有并发问题； 4.2.4 go race detectorgo run -race atomic.go 123456789101112131415161718192021==================WARNING: DATA RACERead at 0x00c0000bc008 by goroutine 8: main.main.func1() /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:20 +0x78Previous write at 0x00c0000bc008 by goroutine 7: main.main.func1() /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:20 +0x91Goroutine 8 (running) created at: main.main() /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:15 +0xe4Goroutine 7 (running) created at: main.main() /Users/ruanhan/2020/go/concurrent/mutex/atomic.go:15 +0xe4==================365768Found 1 data race(s)exit status 66 4.2.5 mutex的用法12345// 很多情况，mutex会嵌入到其他struct中使用；mutex不会因为没有初始化出现空指针或者是无法获取到锁的情况；type Counter struct &#123; mu sync.Mutex Count uint64&#125; 把获取锁，释放锁，计数加一的逻辑封装程一个方法，对外不需要暴露锁等逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"sync\")func main()&#123; var count Counter var wg sync.WaitGroup wg.Add(10) for i:=0; i&lt;10; i++ &#123; go func() &#123; defer wg.Done() // 对变量count执行10次加1 for j:=0 ;j&lt; 100000; j++ &#123; count.Incr() &#125; &#125;() &#125; // 等待10个goroutine完成 wg.Wait() fmt.Println(count.Count())&#125;type Counter struct &#123; CounterType int Name string mu sync.Mutex count uint64&#125;func (c *Counter) Incr ()&#123; c.mu.Lock() c.count++ c.mu.Unlock()&#125;func (c *Counter) Count() uint64&#123; c.mu.Lock() defer c.mu.Unlock() return c.count&#125; 4.3 互斥锁的隐患和易错点4.3.1 死锁 两个或者两个以上的进程（线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或者系统产生了死锁； 如果你想避免死锁，只要破坏这四个条件中的一个或者几个就可以了 互斥； 持有和等待 goroutine持有一个资源，并且还在请求其他goroutine持有的资源； 不可剥夺 资源只能有持有它的goroutine来释放； 环路等待 存在一组等待的进程，p={p1,p2,…pn},p1等待p2, p2等待 pn, pn等待 p1，这就形成了一个环路等待的死结； 环路等待； 物业需要派出所证明，派出所需要物业证明。结果就陷入死锁状态。派出所和物业是两个goroutine，派出所证明和物业证明是两个资源，双方都持有自己的资源而要求对方的资源；而且自己的资源自己持有，不可剥夺； 所以为了保证这个互斥锁的使用安全，遵守以下两个原则 尽可能的简化互斥锁保护的代码 对每一份共享状态只使用一个互斥锁 4.3.2 Lock/Unlock不成对出现4.3.3 Copy已使用的Mutexpackage sync的同步原语在使用后是不能复制的，Mutex是最常用的一个同步原语，它也是不能复制的；原因在于Mutex是一个有状态的对象，它的state字段记录这个锁的状态； 12345678910111213141516type Counter struct &#123; sync.Mutex Count int&#125;func main()&#123; var c Counter c.Lock() defer c.Unlock() c.Count++ foo(c) // 复制锁&#125;func foo(c Counter)&#123; c.Lock() defer c.Unlock() fmt.Println(\"in foo\")&#125; 4.3.4 重入可重入锁： ​ 当一线程获取锁时，如果没有其他线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其他线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时也叫做递归锁）。只要你拥有这把锁，你可以一直调用，比如通过递归实现一些算法，调用者不会阻塞或死锁 mutex不是可重入锁 因为mutex的实现中没有记录哪个goroutine拥有这把锁，理论上，任何goroutine都可以随意地Unlock这把锁，所以没办法计算重入条件； 123456789101112131415func foo(l sync.Locker)&#123; fmt.Println(\"in foo\") l.Lock() bar(l) l.Unlock()&#125;func bar(l sync.Locker)&#123; l.Lock() fmt.Println(\"in bar\") l.Unlock()&#125;func main()&#123; l:=&amp;sync.Mutex&#123;&#125; foo(l)&#125; 如何实现一个可重入锁，实现锁的关键点要记住当前是哪个goroutine持有这个锁； 4.4 WaitGroup WaitGroup很简单，就是package sync用来做任务编排的一个并发原语，它要解决的就是并发-等待的问题；现在有一个goroutine A在检查点（checkpoint）等待一组goroutine全部完成，如果在执行任务的这些goroutine还没全部完成，那么goroutine A就会阻塞在检查点，直到所有goroutine都完成后才能继续执行； 很多操作系统和编程语言都提供了类型的并发原语，比如Linux的barrier，Pthread(POSIX线程)中的barrier; 123func (wg *WaitGroup) Add(delta int) // 设置计数值func (wg *WaitGroup) Done() // 将计数减1，其实就是Add(-1)func (wg *WaitGroup) Wait() // 调用这个方法的goroutine会一直阻塞，直到WaitGroup计数值为0； 123456789101112131415161718192021222324252627282930313233343536type Counter struct &#123; mu sync.Mutex count uint64&#125;func (c *Counter) Incr()&#123; c.mu.Lock() c.count++ c.mu.Unlock()&#125;func (c *Counter) Count() uint64&#123; c.mu.Lock() defer c.mu.Unlock() return c.count&#125;func worker(c *Counter, wg *sync.WaitGroup) &#123; defer wg.Done() // 计数减1， 当有一个goroutine完成了就减1 time.Sleep(time.Second) c.Incr()&#125;func main()&#123; var counter Counter var wg sync.WaitGroup wg.Add(10) // 设置计数值 for i:=0; i&lt;10;i++&#123; go worker(&amp;counter, &amp;wg) &#125; wg.Wait() // 阻塞 main goroutine 等待waitGroup计数归0 fmt.Println(counter.Count())&#125; 4.5 Cond go标准库提供Cond的原语的目的是，为等待/通知场景下的并发问题提供支持，Cond通常应用于等待某个条件的一组goroutine，等条件变为true的时候，其中一个goroutine或者所有的goroutine都会呗唤醒执行； 真正使用Cond的场景比较少，一旦遇到需要使用Cond的场景，更多地会使用Channel的方式去实现； Cond的基本用法 Cond关联的Locker实例可以通过c.L访问，它内部维护着一个先入先出的等待队列； 12345type Condfunc NewCond(l Locker) *Condfunc (c *Cond) Broadcase()func (c *Cond) Signal()func (c *Cond) Wait() // 会把调用者Caller 放入Cond的等待队列中并阻塞，直到Signal或者广播方法从等待队列中移除并唤醒； 1234567891011121314151617181920212223242526272829303132func main()&#123; c:= sync.NewCond(&amp;sync.Mutex&#123;&#125;) var ready int for i:=0; i&lt;10;i++&#123; go func(i int) &#123; time.Sleep(time.Duration(rand.Int63n(10))*time.Second) // 加锁更改等待条件 c.L.Lock() ready++ c.L.Unlock() log.Printf(\"player #%d is ready\\n\", i) //broadcast c.Broadcast() &#125;(i) &#125; c.L.Lock() for ready != 10&#123; c.Wait() // 把调用者放入cond队列中并阻塞，等待被唤醒； log.Println(\"裁判员被唤醒一次\") &#125; c.L.Unlock() // 所有运动员是否准备就绪 log.Println(\"所有运动员都准备就绪，game start,3,2,1...\")&#125; 4.6 once once可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景 1func (o *Once) Do(f func()) sync.Once只暴露了一个方法Do，你可以多次调用Do方法，但是只有第一次调用Do方法时f参数才会执行，这里的f是一个无参无返回值的函数； 12345678910111213141516171819package mainimport ( \"fmt\" \"sync\")func main()&#123; var once sync.Once f1:= func()&#123; fmt.Println(\"in f1\") &#125; once.Do(f1) // 输出 in f1 f2:=func()&#123; fmt.Println(\"in f2\") &#125; once.Do(f2) // 无输出&#125; 4.7 context 在API之间或者方法调用之间，所传递的除了业务参数之外的额外信息； 123456type Context interface&#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 4.8 atomic 原子操作，一个原子在执行的时候，其他线程不会看到执行一半的操作结果；在其他线程看来，原子操作要么执行完了，要么还在执行；就像一个最小的例子-原子一样，不可分割; 再来看一个例子，假设你在开发应用程序的时候，需要从配置服务器中读取一个节点的配置信息。而且，在这个节点的配置发生变更的时候，你需要重新从配置服务器中拉去一个份新的配置并更新。你的程序中可能有多个goroutine都依赖这份配置，涉及到对这个配置对象的并发读写，你可以使用读写锁实现对配置对象的保护，在大部分情况下，你也可以利用atomic实现配置对象的更新和加载； atomic原子操作还是实现lock-free数据结构的基石 在实现lock-free的数据结构时，我们可以不使用互斥锁，这样就不会让线程因为等待互斥锁阻塞休眠，而是让线程保持继续处理的状态。另外，不使用互斥锁的话，lock-free的数据结构还可以提供并发的性能； 4.8.1 atomic提供的方法 atomic操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法； Add 12func AddUint32(addr *uint32, delta uint32) (new uint32)// Add方法就是给第一个参数地址中的值增加一个delta值； CAS(compareAndSwap) 123456789// 要操作的地址，原数据值，新值；func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)// 这个方法会比较当前addr地址里面的值是不是old，如果不等于old，就返回false；如果等于old，就把此地址的值替换成new值，返回true，这就相当于“判断相等才替换”if *addr == old &#123; *addr = new return true&#125;return false Swap 如果不需要比较旧值，只是比较粗暴地替换的话，就可以使用Swap方法，它替换后还可以返回旧值，伪代码如下； 123old= *addr*addr = newreturn old Load Load方法会取出addr地址中的值，即使在多处理器、多核、有cpu cache的情况下，这个操作也能保证Load是一个原子操作； 1func LoadInt32(addr *int32)(val int32) Store Store方法会把一个值存入到指定的addr地址中，即使在多处理器、多核、有cpu cache的情况下，这个操作也能保证Store是一个原子操作。别的goroutine通过Load读取出来，不会看到存取了一半的值； 1func StoreInt32(addr *int32, val int32) 4.8.2 Value类型 Value类型，可以原子地存取对象类型，但也只能存取，不能CAS和Swap，常常用在配置变更等场景中 123type Valuefunc(v *Value) Load()(x interface&#123;&#125;)func(v *Value) Store(x interface&#123;&#125;) 123456789101112131415161718192021222324252627282930313233343536373839type Config struct &#123; NodeName string Addr string Count int32&#125;func loadNewConfig() Config &#123; return Config&#123; NodeName: \"beijing\", Addr: \"10.13.12.88\", Count: rand.Int31(), &#125;&#125;func main() &#123; var config atomic.Value config.Store(loadNewConfig()) var cond = sync.NewCond(&amp;sync.Mutex&#123;&#125;) // 设置新config go func() &#123; for &#123; time.Sleep(time.Duration(5+rand.Int63n(5)) * time.Second) config.Store(loadNewConfig()) cond.Broadcast() // 通知等待着配置已变更 &#125; &#125;() go func() &#123; for &#123; cond.L.Lock() cond.Wait() // 阻塞等待变更信号 c := config.Load().(Config) // 读取新的配置 fmt.Printf(\"new config:%+v\\n\", c) cond.L.Unlock() &#125; &#125;() select &#123;&#125;&#125; 4.9 map1map[k]v key类型的k必须是可比较的（comparable），也就是可以通过 == 和 != 操作符进行比较： value的值和类型无所谓，可以是任意类型，或者是nil go内建的 map对象不是线程（goroutine）安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic 123456789101112131415func main&#123; var m = make(map[int]int, 10) go func()&#123; for &#123; m[1] = 1 // 设置key &#125; &#125;() go func()&#123; for&#123; _ = m[2] // 访问这个map &#125; &#125;&#125;// panic 4.9.1 实现线程安全的map类型加读写锁； 4.9.2 应对特殊场景的sync.Mapsync.Map是线程安全的； 在以下两个场景中使用sync.Map ，会比使用map.RWMutex的方式，性能要好得多； 只会增长的缓存系统中，一个key只写入一次而被读很多次； 多个goroutine为不相交的键集读、写和重写键值对； sync.Map很少使用，我们可以把sync.Map看成一个生产环境中很少使用的同步原语； 4.10 pool 如果你想使用go开发一个高性能的应用程序时，就必须考虑垃圾回收给性能带来的影响；毕竟Go的自动垃圾回收机制还是有一个STW（stop-the-world，程序暂停）的时间，而且，大量地创建在堆上的对象，也会影响垃圾回收标记的时间； 所以，一般做性能优化的时候，会采用对象池的方法，把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必在堆上重新创建了； 像数据库连接，TCP长连接，这些连接在创建的时候是一个非常耗时的操作，如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上； Go标准库提供了sync.Pool，使用它可以创建池化的对象； 4.4 长时间运行的工作进程工作进程（worker） 把一直存在并且独立运行的goroutine称作为 工作进程 而工作进程通常被写成包含select语句的for循环 1234567func worker () &#123; for &#123; select &#123; // wait for channels here. &#125; &#125;&#125; 4.5 事件循环和goroutine事件循环（event loop） 中心循环（central loop） Go通过提供groutine作为核心概念，消除了对中心循环的需求； 某些编程语言会用事件循环的中心循环来等待时间，并在这个事件发生时调用相应的已注册函数。而go语言则是通过提供goroutine作为核心概念，消除对中心循环的需求。 我们可以把任何工作进程goroutine都看做是独立运行的事件循环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( \"fmt\" \"image\" \"log\" \"time\")func worker() &#123; pos := image.Point&#123;X: 10, Y: 10&#125; direction := image.Point&#123;X: 1, Y: 0&#125; next := time.After(time.Second) for &#123; select &#123; case &lt;-next: pos = pos.Add(direction) fmt.Println(\"current position is\", pos) next = time.After(time.Second) &#125; &#125;&#125;type command intconst ( right = command(0) left = command(1))type RoverDriver struct &#123; commandc chan command&#125;func NewRoverDriver() *RoverDriver &#123; r := &amp;RoverDriver&#123; commandc: make(chan command), &#125; go r.drive() return r&#125;func (r *RoverDriver) drive() &#123; pos := image.Point&#123;X: 0, Y: 0&#125; direction := image.Point&#123;X: 1, Y: 0&#125; updateInterval := 250 * time.Millisecond nextMove := time.After(updateInterval) for &#123; select &#123; case c := &lt;-r.commandc: switch c &#123; case right: direction = image.Point&#123;X: -direction.Y, Y: direction.X&#125; case left: direction = image.Point&#123;X: direction.Y, Y: -direction.X&#125; &#125; log.Printf(\"new direction %v\", direction) case &lt;-nextMove: pos = pos.Add(direction) log.Printf(\"moved to %v\", pos) nextMove = time.After(updateInterval) &#125; &#125;&#125;func (r *RoverDriver) Left() &#123; r.commandc &lt;- left&#125;func (r *RoverDriver) Right() &#123; r.commandc &lt;- right&#125;func main() &#123; r := NewRoverDriver() time.Sleep(3 * time.Second) r.Left() time.Sleep(3 * time.Second) r.Right() time.Sleep(3 * time.Second)&#125; 修改代码使得每次移动之间的间隔增加半秒 以RoverDriver类型为基础，定义start方法·stop方法和对应的命令，然后修改代码使得探测器可以接受这两个新命令 4.6 互斥锁的实现4.6.1 初版mutex实现 CAS CAS指令是将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的；原子性保证这个指令总是基于最新的值进行计算，如果同时有其他线程已经修改了这个值，那么CAS会返回失败 CAS是实现互斥锁和同步原语的基础； mutex结构包含两个字段： 字段key: ​ 一个flag，用来标识这个排外锁是否被某个goroutine所持有，如果key大于1，说明这个排外锁已经被持有； 字段sema: ​ 是个信号量变量，用来控制等待goroutine的阻塞休眠和唤醒； Unlock方法可以被任意的goroutine调用释放锁，即使是没有持有这个互斥锁的goroutine，也可以进行这个操作，这是因为，Mutex本身并没有包含持有这把锁的goroutine的信息，所以，Unlock也不会对此进行检查，Mutex的这个和手机一直保持至今； 因此写代码时要遵循谁申请谁释放，以防造成死锁； 5. select5.1 select的作用Go里面提供了一个关键字select，通过select可以监听channel上的数据流动 select与switch相似，但select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作（读写操作，读channel写channel也是一种IO操作） 12345678select &#123; case &lt;- chan1: // 如果chan1成功读取到数据，则进行该case处理语句 case chan2 &lt;-1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程&#125; 在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句； 如果其中的任意一语句可以继续执行（即没有被阻塞）那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况 如果给出default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复 如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去 1234567891011for &#123; select &#123; case &lt;- chan1: // 如果chan1成功读取到数据，则进行该case处理语句 case chan2 &lt;-1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 &#125;&#125;// 如果需要轮训select监听channel数据流向的话，那么需要加上for语句。但是这样每次循环进来都需要default:这样就形成忙轮询死循环了。CPU一致被占用。所以一般在for的时候 不写default。这样的话select语句就会因为阻塞而挂起。挂起会出让cpu时间片。这样会提升计算机的效率 5.2 select基本使用123456789101112131415161718192021222324252627282930313233343536373839// select package mainimport ( \"fmt\" \"runtime\" \"time\")func main() &#123; ch := make(chan int) // 用来进行数据通信的channel quit := make(chan bool) // 用来判断是否退出的channel go func() &#123; // 写数据 for i := 0; i &lt; 5; i++ &#123; ch &lt;- i time.Sleep(time.Second) &#125; close(ch) quit &lt;- true // 通知主goroutine退出 runtime.Goexit() &#125;() for &#123; // 主goroutine 读数据 select &#123; case num := &lt;-ch: fmt.Println(num) case &lt;-quit: return // 终止进程 &#125; &#125;&#125;012340 select总结： 作用： 用来监听channel上的数据流动方向。读？写？ 用法： 参考switch case语句，但！ case后面必须是IO操作，不可以任意写判别表达式 注意事项： 监听的case中，没有满足监听条件，阻塞 监听的case中，有多个满足监听条件，任选一个执行 可以使用default来处理所有case都不满足监听条件的状况，通常不同（会产生忙轮训） select自身不带有循环机制，需要借助外层for来循环监听 break只能跳出select，类似swtich中的用法 5.3 select实现斐波那契数列5.4 超时有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时。 12345678910111213141516171819202122func main()&#123; c:= make(chan int) quit:=make(chan bool) go func()&#123; for &#123; select &#123; case v:= &lt;-c: case &lt;-time.After(3*time.Second): // 设置超时 quit&lt;-true break; &#125; &#125; &#125;() for i:=0; i&lt;2; i++ &#123; ch &lt;- i; time.Sleep(time.Second * 2) &#125; &lt;-quit // 主go程，阻塞等待子go程通知，退出 fmt.Println(\"finish!\")&#125; select超时处理： select监听time.After中channel的读事件，如果定时时间到，系统会向该channel中写入系统当前时间 1234select &#123; case &lt;- time.After(time.Second*5) // 定时到达后，要处理的内容&#125; 6. Lock什么是锁，就是某个协程（线程）在访问某个资源的时候先锁住，防止其他协程的访问，等访问完毕解锁后其他协程再来加锁访问。 6.1 死锁 不是锁的一种！！！ 是一种错误使用锁导致的现象 死锁是指两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁； 单go程死锁,（channel应该至少2个以上的go程中进行通信，否则死锁！） 12345func main()&#123; ch:=make(chan int) ch&lt;-789 // 阻塞 num:=&lt;-ch&#125; go程间channel访问顺序导致死锁 123456789func main() &#123; ch := make(chan int) num := &lt;-ch fmt.Println(num) go func() &#123; ch &lt;- 123 &#125;()&#125; 使用channel一端读（写），要保证另一端写（读）操作，同时有机会执行。否则死锁； 多go程，多channel交叉死锁 （日常编程当中，逻辑控制不严谨。出现频率比较高） 12345678910111213141516171819func main() &#123; ch1 := make(chan int) ch2 := make(chan int) go func() &#123; // 子 for &#123; select &#123; case num := &lt;-ch1: ch2 &lt;- num &#125; &#125; &#125;() for &#123; select &#123; case num := &lt;-ch2: ch1 &lt;- num &#125; &#125;&#125; 在go语言中，尽量不要将互斥锁，读写锁与channel混用，—— 隐形死锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"math/rand\" \"sync\" \"time\")var count intvar rwlock sync.RWMutex // 锁只有1把func readGo(in &lt;-chan int, idx int) &#123; for &#123; rwlock.RLock() // 以读模式枷锁 num := &lt;-in fmt.Printf(\"-----%dth 读go程，读出：%d\\n\", idx, num) rwlock.RUnlock() // 以读模式解锁 &#125;&#125;func writeGo(out chan&lt;- int, idx int) &#123; for &#123; // 生成随机数 num := rand.Intn(1000) rwlock.Lock() //以写模式枷锁 out &lt;- num fmt.Printf(\"%dth 写go程,写入：%d\\n\", idx, num) time.Sleep(time.Millisecond * 300) rwlock.Unlock() &#125;&#125;func main() &#123; // 播种随机种子 rand.Seed(time.Now().UnixNano()) ch := make(chan int) // 用于数据传递的channel for i := 0; i &lt; 3; i++ &#123; go readGo(ch, i+1) &#125; for i := 0; i &lt; 3; i++ &#123; go writeGo(ch, i+1) &#125; for &#123; &#125;&#125; 6.2 互斥锁每个资源都对应一个可称为“互斥锁”的标记，这个标记是用来保证在任意时刻，只能有一个协程（线程）访问该资源，其他的协程只能等待； 互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock，Lock锁定当前的共享资源，Unlock进行解锁； 在使用互斥锁时，一定要注意：对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。 123456789101112131415161718192021222324252627282930313233// 使用channel完成同步package mainimport ( \"fmt\" \"time\")var ch = make(chan int)func printer(str string) &#123; for _, ch := range str &#123; fmt.Printf(\"%c\", ch) time.Sleep(time.Millisecond * 300) &#125;&#125;func person1() &#123; ch &lt;- 98 printer(\"hello\")&#125;func person2() &#123; &lt;-ch printer(\"mutex\")&#125;func main() &#123; go person1() go person2() for &#123; &#125;&#125; 锁：强制锁建议锁 建议锁和强制锁并不是真正存在的锁，而是一种能对诸如记录锁、文件锁产生影响的两种机制； 这里的互斥锁是属于建议锁，操作系统不强制提供；（建议锁只是建议性存在的，并不强制执行，内核和系统总体上都坚持不使用建议性锁机制，它们依靠程序猿遵守这个规定，Linux默认是采用建议性锁） 建议锁只在合作进程（cooperating precess）之间才有效。破坏性的IO操作会成功 合作进程： 考虑数据库访问例程库，如果该库中所有函数都以一致性的方法处理记录锁，责成使用这些函数访问数据库的任何进程集为合作进程 上层应用使用的锁全部都是建议锁 强制锁机制是这样规定的：所有记录或文件锁功能内核执行的。破坏性的IO操作会被内核禁止。被锁的文件，内核会强制阻止任何对该文件的读或写违规访问。每次读或写访问都得检查锁是否存在。也就是强制性锁机制。 强制锁只在操作系统底层它自己会用到，编程用不上 阻塞在锁上 1234567891011121314151617181920212223242526// 使用互斥锁完成同步var mutex sync.Mutexfunc printer(str string) &#123; mutex.Lock() // 访问共享数据之前， for _, ch := range str &#123; fmt.Printf(\"%c\", ch) time.Sleep(time.Millisecond * 300) &#125; mutex.Unlock() // 访问共享数据之后&#125;func person1() &#123; printer(\"hello\")&#125;func person2() &#123; printer(\"mutex\")&#125;func main() &#123; go person1() go person2() for &#123; &#125;&#125; 6.3 读写锁互斥锁的本质是当一个goroutine访问的时候，其他goroutinue都不能 访问，这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。 其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在竞争的问题的。因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的； 所以问题不是出在读上，主要是修改，也就是“写”，修改的数据要同步，这样其他goroutinue才可以感知到。所以真正的互斥应该是读取和修改、修改和修改之间，读和读是没有互斥操作的必要的； 因此，衍生出另外一种锁，叫做读写锁。 读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutinue既不能进行读操作，也不能进行写操作。 Go中的读写锁由结构体类型sync.RWMutex表示，此类型的方法集合中包含两对方法： 一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”。 12func (*RWMutex) Lock()func (*RWMutex) Unlock() 另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁” 12func (*RWMutex)RLock()func (*RWMutex)RUlock() 数据同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( \"fmt\" \"math/rand\" \"sync\" \"time\")var count intvar rwlock sync.RWMutex // 锁只有1把func readGo(idx int) &#123; for &#123; rwlock.RLock() // 以读模式枷锁 num := count fmt.Printf(\"-----%dth 读go程，读出：%d\\n\", idx, num) rwlock.RUnlock() // 以读模式解锁 &#125;&#125;func writeGo(idx int) &#123; for &#123; // 生成随机数 num := rand.Intn(1000) rwlock.Lock() //以写模式枷锁 count = num fmt.Printf(\"%dth 写go程,写入：%d\\n\", idx, num) rwlock.Unlock() &#125;&#125;func main() &#123; // 播种随机种子 rand.Seed(time.Now().UnixNano()) for i := 0; i &lt; 3; i++ &#123; go readGo(i + 1) &#125; for i := 0; i &lt; 3; i++ &#123; go writeGo(i + 1) &#125; for &#123; &#125;&#125;//1th 写go程,写入：42//-----1th 读go程，读出：42//-----1th 读go程，读出：42//-----3th 读go程，读出：42//1th 写go程,写入：86//-----2th 读go程，读出：86//-----2th 读go程，读出：86//-----1th 读go程，读出：86 总结 读时共享，写时独占。写锁优先级比读锁高 6.4 条件变量12345678910111213141516171819202122232425262728293031323334353637383940// 引出问题func producer(out chan&lt;- int, idx int) &#123; for i := 0; i &lt; 50; i++ &#123; num := rand.Intn(800) fmt.Printf(\"%dth:product -&gt; %d,\\n \", idx, num) out &lt;- num &#125; close(out)&#125;func consumer(in &lt;-chan int, idx int) &#123; for num := range in &#123; fmt.Printf(\"-----%dth:consum -&gt; %d,\\n \", idx, num) &#125;&#125;func main() &#123; rand.Seed(time.Now().Unix()) product := make(chan int) for i := 0; i &lt; 5; i++ &#123; go consumer(product, i+1) &#125; for i := 0; i &lt; 5; i++ &#123; go producer(product, i+1) &#125; for &#123; &#125;&#125; 1th:product -&gt; 15, 3th:product -&gt; 481, 2th:product -&gt; 546, -----4th:consum -&gt; 15, -----4th:consum -&gt; 481, 1th:product -&gt; 790, 1th:product -&gt; 738, -----4th:consum -&gt; 790, // 546 空过去了 -----4th:consum -&gt; 738, 本身不是锁！！但条件变量总是与锁一起使用 条件变量的作用并不保证在同一时刻仅有一个协程访问某个共享的数据资源，而是在对应的共享数据的状态发生变化时，通知阻塞在某个条件上的协程（线程）。条件变量不是锁，在并发中不能达到同步的目的，因此条件变量总是与锁一块使用 例如，如果仓库队列满了，我们可以使用条件变量让生产者对应的go程暂停（阻塞），但是当消费者消费了某个产品后，仓库就不再满了，应该唤醒（发送通知给）阻塞的生产者go程继续生产产品 在抢锁之前，咨询条件变量。是否有必要抢锁（如果缓冲区满或空的时候） 以前的顺序 抢锁 访问公共区 解锁 条件变量版本的顺序 判断条件变量 抢锁 访问公共区 解锁 唤醒阻塞在条件变量上的对端 go标准库中的sync.Cond类型代表了条件变量，条件变量要与锁（互斥锁，或者读写锁）一起使用。成员变量L代表与条件变量搭配使用的锁 123456type Cond struct &#123; noCopy noCopy L Locker // 创建条件变量的时候，要指定其用的是什么锁 notify notifyList checker copyChecker&#125; 对应的有3个常用方法，Wait，Signal，Broadcase 123456789101112func (C *Cond)Wait()/**该函数的作用（一旦调用，会做下面三件事）1. 阻塞等待条件变量满足2. 释放已掌握的互斥锁相当于cond.L.Unlock() // 注意，1，2 两步为一个原子操作3. 当被唤醒，Wait()函数返回时，解除阻塞并重新获取互斥锁，相当于cond.L.Lock()*/// 下面两个函数为 唤醒操作func (c *Cond)Signal()// 单发通知，给一个正等待（阻塞）在该条件变量上的goroutinue 发送通知func (c *Cond)Broadcase()// 广播通知，给正在等待（阻塞）在该条件变量上的所有goroutinue发送通知 // 惊群效应 使用条件变量 123451. 定义条件变量cond2. cond.L--&gt;mutex ,指定一把锁3. cond.L.lock() 4 if xxxxwait() // 如果满足条件，做wait操作， wait包含3件事（一段时间的阻塞，解锁，加锁） 一段时间的阻塞，解锁，加锁 为什么在等待的时候，要解开锁，一会儿又加上呢？ 因为针对的对象是公共区（有缓冲channel），执行wait函数说明公共区达到了容器设定的条件。没办法继续往公共区读（写）数据。所以，当挂起等待的过程当中需要将锁让给对端。当对端写（读）数据之后，容器出现富余，它再唤醒对端，对端重新加上锁从而来访问公共区； 7. 定时器time.Timer Timer是一个定时器，代表未来的一个单一时间，你可以告诉timer你要等待多长时间 1234type Timer struct &#123; C &lt;- chan Time r runtimeTimer&#125; 它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞，直到定时时间到，系统会自动向timer.C这个channel中写入当前时间，阻塞即被解除； 12345678910func main() &#123; fmt.Println(\"current time\", time.Now()) mytimer := time.NewTimer(time.Second * 2) // 定时时间到，系统会自动向timer.C这个channel写入了当前时间； currentTime := &lt;-mytimer.C fmt.Println(\"currentTime is:\", currentTime)&#125;//current time 2021-03-28 19:27:55.330078 +0800 CST m=+0.000082012//currentTime is: 2021-03-28 19:27:57.330273 +0800 CST m=+2.000328165 7.1 三种定时方法1234567891011func main()&#123; // 1. sleep time.Sleep(time.Second) // 2. Timer.C myTimer:= time.NewTimer(time.Second * 2) // 定时器慢，系统自动写入系统时间 currentTime := &lt;-mytimer.C fmt.Println(\"currentTime is:\", currentTime) // 3. time.After nowTimer2 := time.After(time.Second*2)&#125; time.After定时： 指定定时时长，定时到达后，系统会自定向定时器的成员写入 系统当前时间。 返回可读 chan，读取，可获得系统写入时间； 总结： Sleep NewTimer， After 都是 time包的 7.2 定时器的停止和重置12345678910func main()&#123; myTimer := time.NewTimer(time.Second * 3) // 创建定时器 myTimer.Reset(1 *time.Second) //重置定时器时长为1 go func()&#123; &lt;- myTimer.C fmt.Println(\"子go程，定时完毕\") &#125;() myTimer.Stop() //设置定时器停止 for &#123;&#125;&#125; 7.3 定时器周期定时周一到周五每天早上8点起床上班 123456789101112131415161718func main() &#123; fmt.Println(\"startTime:\", time.Now()) myTicker := time.NewTicker(time.Second) go func() &#123; for &#123; nowTime := &lt;-myTicker.C fmt.Println(\"nowTime:\", nowTime) &#125; &#125;() for &#123; &#125;&#125;//startTime: 2021-03-28 20:47:03.563903 +0800 CST m=+0.000099792//nowTime: 2021-03-28 20:47:04.575006 +0800 CST m=+1.011228039//nowTime: 2021-03-28 20:47:05.579668 +0800 CST m=+2.015915392//nowTime: 2021-03-28 20:47:06.577759 +0800 CST m=+3.014031618 可控的周期性定时器 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"time\")func main() &#123; quit := make(chan bool) myTimer := time.NewTicker(time.Second) fmt.Println(\"now Time:=\", time.Now()) i := 0 go func() &#123; for &#123; currentTime := &lt;-myTimer.C i++ fmt.Println(\"current Time:= \", currentTime) if i == 5 &#123; fmt.Println(\"done\") quit &lt;- true runtime.Goexit() &#125; &#125; &#125;() &lt;-quit&#125; 创建一个周期定时器 time.NewTicker，定时时长到达后，系统会自动向Ticker的C中写入系统当前时间，并且，每隔一个定时时长后，循环写入系统当前时间； 在子go程中循环读取C，获取系统写入的时间 8. 内存模型：Go如何保证并发读写的顺序8.1 重排和可见性 由于指令重排，代码并不一定会按照你写的顺序执行 1234567891011121314151617package mainimport \"fmt\"var a stringvar done boolfunc setup() &#123; a = \"hello world\" done = true&#125;func main() &#123; go setup() for !done &#123; &#125; fmt.Println(a) // 这里未见一定输出 hello world，尽管你运行了100次都打印出来了；&#125; 8.2 happens-before 在一个goroutine内部，程序的执行顺序和它们的代码指定的顺序是一样的，即时编译器或者CPU重排了读写顺序，从行为上来看，也和代码指定的顺序一样； 但是对于另一个goroutine来说，重排却产生非常大的影响。因为Go只保证goroutine内部重排对读写的顺序没有影响； 如果两个action（read或write）有明确的happens-before关系，你就可以确定它们之间的执行顺序（或者是行为表现上的顺序） Go内存模型通过happens-before定义两个事件（读、写action）的顺序： 如果事件e1 happens before 事件 e2，那么，我们就可以说事件e2在事件e1之后发生（happens after） 如果e1不是happens before e2，同时也不happens after e2，那么，我们就可以说事件 e1 和 e2 是同时发生的； 如果要保证对 “变量v 的 读操作r” 能够观察到一个对 ”变量v 的 写操作w“， 并且r只能观察到w对变量v的写，没有其他对v的写操作，也就是说，我们要保证r绝对能观察到w操作的结果，那么就需要同时满足两个条件： w happens before r； 其他对v的写操作（w2，w3，w4，。。。）要么happens before w，要么happens after r， 绝对不和w、r同时发生，或者是在它们之间发生； 在goroutine内部对一个局部变量v的读，一定能观察到最近一次对这个局部变量v的写。如果要保证多个goroutine之间对一个共享变量的读写顺序，在Go语言中，可以使用并发原语为读写操作建立happens-before关系；这样就可以保证顺序了； 在Go语言中，对变量进行零值的初始化就是一个写操作； 如果对超过机器word（64bit，32bit或者其它）大小值进行读写，那么，就可以看作是对拆成word大小的几个读写无序进行； Go并不提供直接的CPU屏障（CPU fence）来提示编译器或者CPU保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语； 8.3 Go语言中保证happens-before关系8.3.1 init函数应用程序的初始化是在单一的goroutine执行，如果包p导入了包q， 那么，q的init函数的执行一定happens before p的任何初始化代码； 12package pimport \"q\" // q的init函数执行一定 happens before p的任何代码； main函数一定在导入包的init函数之后执行 8.3.2 goroutine启动goroutine的go语句的执行，一定happens before此goroutine内的代码执行； 根据上面的规则，我们知道，如果go语句传入的参数是一个函数执行的结果，那么，这个函数一定先于goroutine内部的代码被执行； 123456781 var a string2 func f()&#123;3 print(a)4 &#125;5 func hello()&#123;6 a = \"hello,world\"7 go f()8 &#125; 第6 和 第7 在同一个goroutine执行，在main goroutine看来， 6 happens before 7. 7 子gouroutine happens before 第3行的变量输出，那么，可以推断出，第6行 happens before 第3行。 也就是说，在第3行 打印a的值的时候，肯定会打印出“hello world”； 启动goroutine的情况，goroutine退出的时候，是没有任何happens-before保证的。所以，如果你想观察某个goroutine的执行效果，你需要使用同步机制建立happens-before关系，比如Mutex或者Channel。 8.3.3 channel通用的Channel happens-before关系保证有4条规则 第一条规则 往Channel中的发送操作，happens before 从该channel接收相应数据的动作完成之前； 12345678910111213var ch = make(chan struct&#123;&#125;, 10)var s stringfunc f()&#123; s= \"hello,go\" // 赋值 ch&lt;-struct&#123;&#125;&#123;&#125; // 写channel&#125;func main()&#123; go f() &lt;-ch // 读channel print(s) // 打印&#125; 首先‘赋值’ happens before ‘写channel’， ‘写channel’ happens before ‘读channel’； ‘打印’happens after ‘读channel’； 所以 ‘打印’必然输出 hello，go 第二条规则 close一个channel的调用，肯定 happens before 从关闭的Channel中读取出一个零值； 第三条规则 对于unbuffered的channel，读取channel数据的调用 一定 happens before 写入channel数据的调用 123456789101112131 var ch = make(chan int)2 var s string34 func f()&#123;5 s = \"hello, go\"6 &lt;-ch7 &#125;89 func main()&#123;10 go f()11 ch&lt;-struct&#123;&#125;12 print(s)13 &#125; 如果第11行发送语句执行成功，那么根据这个规则，第6行（接收）的调用肯定发生了，（执行完成不完成不重要，重要的是这一句“肯定执行了”），那么s也肯定初始化了，所以一定会打印出“hello ，go” 因为channel是unbuffered的Channel，所以这个规则也成立 第四条规则 如果Channel的容量是m（m&gt;0），那么第n个 receive 一定 happens before 第 n+m 个 send 的完成； 8.3.4 Mutex/RWMutex 第n次的m.Unlock 一定happens before第n+1 m.Lock方法的返回； 对于读写锁 RWMutex m，如果它的第 n 个 m.Lock 方法的调用已返回，那么它的第 n 个 m.Unlock 的方法调用一定 happens before 任何一个 m.RLock 方法调用的返回，只要这些 m.RLock 方法调用 happens after 第 n 次 m.Lock 的调用的返回。这就可以保证，只有释放了持有的写锁，那些等待的读请求才能请求到读锁。 对于读写锁 RWMutex m，如果它的第 n 个 m.RLock 方法的调用已返回，那么它的第 k （k&lt;=n）个成功的 m.RUnlock 方法的返回一定 happens before 任意的 m.RUnlockLock 方法调用，只要这些 m.Lock 方法调用 happens after 第 n 次 m.RLock。 对于读写锁 i 的i.RLock方法调用，如果存在一个n，这次的 l.RLock 调用 happens after 第 n 次的 l.Unlock，那么，和这个 RLock 相对应的 l.RUnlock 一定 happens before 第 n+1 次 l.Lock。意思是，读写锁的 Lock 必须等待既有的读锁释放后才能获取到。 12345678910111213141 var mu sync.Mutex2 var s string34 func foo()&#123;5 s = \"go\"6 mu.Unlock()7 &#125;89 func main()&#123;10 mu.Lock()11 go foo()12 m.Lock()13 print(s)14 &#125; 第6行第一次unLock 一定happens before第二次的Lock（第12行），所以这也能保证正确输出“go” 8.3.5 WaitGroupWait方法等到计数值归零之后才返回 8.3.6 Once对于once.Do(f) 调用，f函数的那个单次调用一定happens before任何once.Do(f)调用的返回。换句话说，就是函数f一定会在Do方法返回之前执行； 12345678910111 var s string2 var once sync.Once34 func foo()&#123;5 s = \"go\"6 &#125;78 func twoprint()&#123;9 once.Do(foo)10 print(s)11 &#125; 第5行的执行一定happens before第9行的返回，所以执行到第10行的时候，s已经初始化了，所以会正确打印“go” 8.3.7 atomic现阶段还是不要使用atomic来保证顺序性； 9. 信号量 信号量 是用来控制多个goroutine同时访问多个资源的并发原语； 信号量的概念是1963年提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等到可以继续进行的信号到来 最简单的信号量就是一个变量加一些并发控制的能力，这个变量是 0 到 n 之间的一个数值。当 goroutine 完成对此信号量的等待（wait）时，该计数值就减 1，当 goroutine 完成对此信号量的释放（release）时，该计数值就加 1。当计数值为 0 的时候，goroutine 调用 wait 等待该信号量是不会成功的，除非计数器又大于 0，等待的 goroutine 才有可能成功返回。 举例 举个例子，图书馆新购买了 10 本《Go 并发编程的独家秘籍》，有 1 万个学生都想读这本书，“僧多粥少”。所以，图书馆管理员先会让这 1 万个同学进行登记，按照登记的顺序，借阅此书。如果书全部被借走，那么，其他想看此书的同学就需要等待，如果有人还书了，图书馆管理员就会通知下一位同学来借阅这本书。这里的资源是10本《Go 并发编程的独家秘籍》，想读此书的同学就是 goroutine，图书管理员就是信号量。 9.1 P/V操作P操作（descrease, wait, acquire） 减少信号量的计数值 V操作（increase, signal, release） 增加信号量的计数值 12345678func V(semaphore S, integer I): [S &lt;- S + I]func P(semaphore S, integer I): repeat: [if S&gt;= I: S &lt;- S-I break] 初始化信号量S有一个指定数量（n）的资源，它就像是一个有n个资源的池子。P操作相当于请求资源，如果资源可用，就立即返回； 如果没有资源或者不够，那么，它可以不断尝试或阻塞等待。 V操作会释放自己持有的资源，把资源返还给信号量，信号量的值除了初始化的操作以外，只能由P/V操作改变； 信号量的实现 初始化信号量：设定初始的资源的数量 P操作： 将信号量的计数值减去1，如果新值已经为负，那么调用者会被阻塞并加入到等待队列中。否则，调用者会继续执行，并且获得一个资源； V操作：将信号量的计数值加1，如果先前的计数值为负，就说明有等待的P操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行； 其实，信号量可以分为计数信号量（counting semaphre）和二进位信号量（binary semaphore）。刚刚所说的图书馆借书的例子就是一个计数信号量，它的计数可以是任意一个整数。在特殊的情况下，如果计数值只能是 0 或者 1，那么，这个信号量就是二进位信号量，提供了互斥的功能（要么是 0，要么是 1），所以，有时候互斥锁也会使用二进位信号量来实现。 我们一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接，几个打印机资源，等等。如果信号量蜕变成二进位的信号量，那么，它的P/V就和互斥锁的Lock/Unlock一样了； 9.2 官方扩展库实现在运行时，Go内部使用信号量来控制goroutine的阻塞和唤醒。 信号量的p/V操作是通过函数实现的 123func runtime_Semacquire(s *uint32)func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)func runtime_Semrelease(s *uint32, handoff bool, skipframes int) 信号量的几个实现方法 Acquire 相当于 P 操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是 Context，这就意味着，你可以通过 Context 增加超时或者 cancel 的机制。如果是正常获取了资源，就返回 nil；否则，就返回 ctx.Err()，信号量不改变。 Release 相当于V操作，可以将n个资源释放，返还给信号量。 TryAcquire 尝试获取n个资源，但是它不会阻塞，要么成功获取n个资源，返回true，要么一个也不获取。返回false 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"context\" \"fmt\" \"log\" \"runtime\" \"time\" \"golang.org/x/sync/semaphore\")var ( maxWorkers = runtime.GOMAXPROCS(0) // worker 数量 sema = semaphore.NewWeighted(int64(maxWorkers)) // 信号量 task = make([]int, maxWorkers*4) // 任务数，是worker的四倍)/**main goroutine 相当于一个dispatcher，负责任务的分发，它先请求信号量，如果获取成功，就会启动一个goroutine去处理计算，然后这个 goroutine会释放这个信号量（信号量的获取是在main goroutine，释放是在worker goroutine），如果获取不成功，就等到信号量可以使用的时候，再去获取；*/func main() &#123; ctx := context.Background() for i := range task &#123; // 如果没有worker可用，会阻塞在这里，直到某个worker被释放 if err := sema.Acquire(ctx, 1); err != nil &#123; break &#125; // 启动worker goroutine go func(i int) &#123; defer sema.Release(1) time.Sleep(100 * time.Millisecond) // 模拟一个耗时操作 task[i] = i + 1 &#125;(i) &#125; // 请求所有worker，这样能确保前面的worker都执行完 （想等所有的Worker都执行完，就可以获取最大计数值的信号量） if err := sema.Acquire(ctx, int64(maxWorkers)); err != nil &#123; log.Printf(\"获取所有worder失败: %v\", err) &#125; fmt.Println(task)&#125; 10. SingeFlight 和 SyclicBarrier SingeFlight将并发请求合并成一个请求， SyclicBarrier是一个可重用的栅栏并发原语，用来控制一组请求同时执行的数据结构 11 分组操作 共享资源保护、任务编排和消息传递是Go并发编程中常见的场景，而分组执行一批相同的或类似的任务则是任务编排中一类情形，分组编排的一些常用场景和并发原语，ErrGroup，gollback，Hunch和schedgroup 11.1 ErrGroup经常会碰到将一个通用的父任务拆成几个小任务并发执行的场景，其实，将一个大的任务拆成几个小任务并发执行。可以有效地提高程序的并发度， ErrGroup就是用来应对这种场景的，它和WaitGroup有些类似，但是它提供功能更加丰富： 和Context集成 error向上传播，可以把子任务的错误传递给Wait的调用者 Api 123func WithContext(ctx context.Context)(*Group, context.Context)func (g *Group) Go(f func() error)func (g *Group) Wait() error 11.1.1 ErrGroup使用例子 返回第一个错误 启动三个子任务，其中，子任务2会返回执行失败，其他两个执行成功。在三个子任务都执行后，group.Wait 才会返回第2个子任务的错误。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"errors\" \"fmt\" \"time\" \"golang.org/x/sync/errgroup\")func main() &#123; var g errgroup.Group g.Go(func() error &#123; time.Sleep(5 * time.Second) fmt.Println(\"exec #1\") return nil &#125;) g.Go(func() error &#123; time.Sleep(10 * time.Second) fmt.Println(\"exec #2\") return errors.New(\"failed to exec #2\") &#125;) g.Go(func() error &#123; time.Sleep(15 * time.Second) fmt.Println(\"exec #3\") return nil &#125;) // 等待第三个任务都完成 if err := g.Wait(); err == nil &#123; fmt.Println(\"successfully exec all\") &#125; else &#123; fmt.Println(\"failed:\", err) &#125;&#125; exec #1exec #2exec #3failed: failed to exec #2 返回所有子任务的错误 Group只能返回子任务的第一个错误，后续的错误都会被丢弃，但是，有时候我们需要知道每个任务的执行情况， 我们使用一个result slice保存子任务的执行结果，这样，通过查询result，就可以知道每一个子任务的结果了； 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"errors\" \"fmt\" \"time\" \"golang.org/x/sync/errgroup\")func main() &#123; var g errgroup.Group var result = make([]error, 3) g.Go(func() error &#123; time.Sleep(5 * time.Second) fmt.Println(\"exec #1\") result[0] = nil //保存成功或者失败的结果 return nil &#125;) g.Go(func() error &#123; time.Sleep(10 * time.Second) fmt.Println(\"exec #2\") result[1] = errors.New(\"failed to exec #2\") return result[1] &#125;) g.Go(func() error &#123; time.Sleep(15 * time.Second) fmt.Println(\"exec #3\") result[2] = nil return nil &#125;) // 等待第三个任务都完成 if err := g.Wait(); err == nil &#123; fmt.Printf(\"successfully exec all. result:%v\\n\", result) &#125; else &#123; fmt.Printf(\"failed: %v\\n\", result) &#125;&#125; exec #1exec #2exec #3failed: [ failed to exec #2 ] Goroutine 先用对姿势，go chan。 再去review底层实现 1. Goroutines and Parallelism go关键字可以快速让一个函数创建为goroutine，我们可以认为main函数就是作为goroutine执行的。操作系统调度线程在可用处理器上运行，go运行时调度goroutine在绑定到耽搁操作系统线程的逻辑处理器中运行（P）。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万goroutine以惊人的效率和性能并发运行。 并发不是并行，并行是 指两个或多个线程同时在不同的处理器执行代码，如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配goroutine，这将导致goroutine在不同的操作系统线程上运行。但是，要获得真正的并行性，需要在具有多个物理处理器的计算机上运行程序。否则，goroutine将针对单个物理处理器并发运行，即使Go运行时使用多个逻辑处理器； keep yourself busy or do the work yourself 空的select语句将永远阻塞 1234567891011121314151617// badfunc main() &#123; http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, \"Hello, GopherCon SG\") &#125;) // go关键字之后，可以理解为被扔到某一个核心上执行。并行或者并发执行。 go func() &#123; if err := http.ListenAndServe(\":8090\", nil); err != nil &#123; log.Fatal(err) &#125; &#125;() // go func出去之后，main是无法感知到的执行后续结果的；而且log.Fatal会导致当前goroutine的defer无法执行； // 永远阻塞，防止main函数退出，main可看作是一个goroutine；main退出后导致main相关的资源被回收； select &#123;&#125;&#125; 如果你的goroutine在从另一个goroutine获得结果之前无法取得进展，那么通常情况下，你自己去做这项工作比委托它（go func()) 更简单。 这通常消除了将结果从goroutine返回到其启动器所需的大量状态跟踪和chan操作； 12345678910111213141516package mainimport ( \"fmt\" \"log\" \"net/http\")func main() &#123; http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, \"Hello, GopherCon SG\") &#125;) if err := http.ListenAndServe(\":8080\", nil); err != nil &#123; log.Fatal(err) // 底层调用 os.Exit(1),会导致 defer无法执行； &#125;&#125; 1.1不要启动一个goroutine，当你不知道它什么时候会结束 （我们不仅要管error的panic，还要管goroutine的生命周期） 123456789func main() &#123; mux := http.NewServeMux() mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) &#123; fmt.Fprintln(resp, \"hi\") &#125;)// go出去的代码不知道什么时候会退出，什么时候会结束。我们需要管理goroutine的生命周期； go http.ListenAndServe(\"127.0.0.1:8001\", http.DefaultServeMux) http.ListenAndServe(\"0.0.0.0:8080\", mux)&#125; 在启动goroutine的时候通常需要问两个问题 它什么时候结束； 如何让它结束； 通过将serveApp 和 serveDebug处理程序分解为各自的函数，我们将它们与main.main 解耦，我们还遵循了上面的建议，并确保serveApp和serveDebug将它们的并发性留给调用者 如果serveApp返回，则main.main将返回导致程序关闭，只能靠类似supervisor进行管理来重新启动 123456789101112131415161718192021222324252627282930313233/**通过将serveApp 和 serveDebug处理程序分解为各自的函数，我们将它们与main.main 解耦，我们还遵循了上面的建议，并确保serveApp和serveDebug将它们的并发性留给调用者。如果serveApp返回，则main.main将返回导致程序关闭，只能靠类似supervisor进行管理来重新启动*/package mainimport ( \"fmt\" \"log\" \"net/http\")func serveApp() &#123; mux := http.NewServeMux() mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) &#123; fmt.Fprintln(resp, \"Hello, QCon\") &#125;) if err := http.ListenAndServe(\"0.0.0.0:8080\", mux); err != nil &#123; log.Fatal(err) &#125;&#125;func serveDebug() &#123; if err := http.ListenAndServe(\"127.0.0.1:8001\", http.DefaultServeMux); err != nil &#123; log.Fatal(err) &#125;&#125;func main() &#123; go serveDebug() // 如果serveDebug异常，该goroutine会退出，而程序的其余部分继续运行，main函数依然感知不到； serveApp() // 因为serveApp会阻塞，所以main不会被退出；，如果该函数异常退出，则进程退出；只能依赖类似supervisor进程管理来拉起&#125; 继续迭代 123456789101112131415161718192021222324func serveApp() &#123; mux := http.NewServeMux() mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) &#123; fmt.Fprintln(resp, \"Hello, QCon\") &#125;) if err := http.ListenAndServe(\"0.0.0.0:8080\", mux); err != nil &#123; log.Fatal(err) &#125;&#125;func serveDebug() &#123; if err := http.ListenAndServe(\"127.0.0.1:8001\", http.DefaultServeMux); err != nil &#123; log.Fatal(err) &#125;&#125;// ListenAndServe 返回nil error，最终main.main无法退出// log.Fatal调用了os.Exit,会无条件终止程序；defers不会被调用到；// 一般log.Fatal 只会在main.main和init functions中使用；func main() &#123; go serveDebug() go serveApp() select&#123;&#125;&#125; 解决方案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960func serve(addr string, handler http.Handler, stop &lt;-chan struct&#123;&#125;) error &#123; s := http.Server&#123; Addr: addr, Handler: handler, &#125; go func() &#123; &lt;-stop //wait for stop signal // 通过外部的信号，通知内部的goroutine； // 让其可以正常执行Shutdown方法 s.Shutdown(context.Background()) // 执行Shutdown之后，s.ListenAndServe() 就会退出； &#125;() return s.ListenAndServe() // 一旦报错会返回error，然后告诉调用方安全退出goroutine。&#125;func ServeApp(stop &lt;-chan struct&#123;&#125;) error &#123; mux := http.NewServeMux() mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) &#123; fmt.Fprintln(resp, \"Hello, QCon\") &#125;) return serve(\"0.0.0.0:8080\", mux, stop)&#125;func ServeDebug(stop &lt;-chan struct&#123;&#125;) error &#123; if err := http.ListenAndServe(\"127.0.0.1:8001\", http.DefaultServeMux); err != nil &#123; log.Fatal(err) &#125; return serve(\"127.0.0.1:8001\", http.DefaultServeMux, stop)&#125;func main() &#123; // done 是知道对方什么时候退出； done := make(chan error, 2) // stop 是控制内部相互通知两个人可以退出； stop := make(chan struct&#123;&#125;) // 空结构体，表示0 size的一个东西 // 让调用者启goroutine go func() &#123; done &lt;- ServeDebug(stop) &#125;() go func() &#123; done &lt;- ServeApp(stop) &#125;() var stopped bool // cap(done) = 2; for i := 0; i &lt; cap(done); i++ &#123; if err := &lt;-done; err != nil &#123; fmt.Println(\"error: %v\", err) &#125; if !stopped &#123; // 但凡有一个报错，就调用close，来唤醒serveDebug和serveApp stopped = true close(stop) &#125; &#125;&#125; 总结 让调用者决定一个goroutine到底需要在后台执行还是前台执行。 如果要启动一个goroutine，那么一定要知道它什么时候能够结束。有没有一个手段让它结束。知道它什么时候可以返回。 1. 2 Leave concurrency to the caller 将并发逻辑交给调用者,不应该在内部去搞goroutine然后让消费者来处理。 1234// 传一个目录路径做参数，然后将目录路径列举出来；// dir 目录路径，func ListDirectory(dir string)([]string, error)func ListDirectory(dir string) chan string 万一传递的目录树很大，是否可以使用chan 不断的去读取 上面两个function的做法 将目录读取到一个slice中，然后返回整个切片，或者如果出现错误，则返回错误。这是同步调用的，ListDirectory的调用方会阻塞，直到读取所有目录条目。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目名称的slice； 第二个函数的做法是返回一个chan string, 将通过该chan 传递目录，当通道关闭时，这表示不再有目录。由于在ListDirectory返回后发生通道的填充，ListDirectory可能内部启动goroutine来填充通道； ListDirectory chan版本还有两个问题： 通过使用一个关闭的通道作为不再需要处理的项目的信号，ListDirectory无法告诉调用者通过通道返回的项目集不完整，因为中途遇到了错误。调用方无法区分空目录（读完了）与完全从目录读取的错误之间的区别，这两种方法都会导致从ListDirectory返回的通道会立即关闭； 调用者必须继续从通道读取，直到它关闭，因为这是调用者知道开始填充通道的goroutine已经停止的唯一方法。这对ListDirectory的使用是一个严重的限制，调用者必须花时间从通道读取数据，即使它可能已经收到了它想要的答案。对于大中型目录，它可能在内存使用方面更为高效，但这种方法并不比原始的基于slice的方法快； 建议的做法 12func ListDirectory(dir string, fn func(string))// 不断枚举目录，然后执行回调函数fn filepath.WalkDir也是类似的模型，如果函数启动goroutine，则必须向调用方提供显式停止该goroutine的方法。通常，将异步执行函数的决定权交给该函数的调用方通常更容易； 因此，设计一个并发函数的时候。可以参考官方的API吧； 1.3 不用启动一个不知道什么时候结束的goroutine123456789101112131415161718192021/**search函数是一个模拟实现，用于模拟长时间运行的操作，如数据库查询或者rpc调用*/func search(term string) (string, error) &#123; time.Sleep(200 * time.Millisecond) return \"some value\", nil&#125;/**定义一个名为process的函数，接受字符串参数，传递给search，对于某些应用程序，顺序调用产生的延迟可能是不可接受的；*/func process(term string) error &#123; record, err := search(term) // 不确定search返回的时机；所以goroutine就会阻塞堆积 if err != nil &#123; return err &#125; fmt.Println(\"Received:\", record) return nil&#125; 所以，一定要做代码超时控制； 123456789101112131415161718192021222324252627282930313233343536func search(term string) (string, error) &#123; time.Sleep(200 * time.Millisecond) return \"some value\", nil&#125;type result struct &#123; record string err error&#125;func process(term string) error &#123; // 创建一个100 之后结束的context ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond) defer cancel() // make a channel for the goroutine to report result. ch := make(chan result) // launch a goroutine to find the record. Create a result // from the returned values to send through the channel go func() &#123; // 此goroutine也会被context级联取消退出； record, err := search(term) // 将search执行结果拿给chan来接收 ch &lt;- result&#123;record, err&#125; &#125;() // Block waiting to either receive from the goroutine's // channel or for the context to be canceled; select &#123; case &lt;-ctx.Done(): return errors.New(\"search canceled\") case result := &lt;-ch: if result.err != nil &#123; return result.err &#125; fmt.Println(\"Received:\", result.record) return nil &#125;&#125; 1.4 另外一种导致goroutine泄漏1234567891011121314151617181920212223242526272829303132// 使用服务端埋点来跟踪记录一些事件// Tracker knows how to track events for the applicationtype Tracker struct&#123;&#125;type App struct &#123; track Tracker&#125;// 上报event事件func (t *Tracker) Event(data string) &#123; // Simulate network write latency time.Sleep(time.Millisecond) log.Println(data)&#125;// 无法保证创建的goroutine生命周期管理，会导致最场景的问题，// 就是在服务关闭时候，有一些事件丢失// App holds application state// Handle represents example handler for the web servicefunc (a *App) Handle(w http.ResponseWriter, r *http.Request) &#123; // Do some actual work // Respond to the client w.WriteHeader(http.StatusCreated) // Fire and Hope // BUG: We are not managing this goroutine // 无法管控这个goroutine，因为Event函数内部可能sleep 1毫秒，可能sleep一分钟 go a.track.Event(\"this event\")&#125; good part 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func main() &#123; tr := NewTracker() go tr.Run() _ = tr.Event(context.Background(), \"test\") _ = tr.Event(context.Background(), \"test\") _ = tr.Event(context.Background(), \"test\") ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2*time.Second)) defer cancel() tr.Shutdown(ctx)&#125;func NewTracker() *Tracker &#123; return &amp;Tracker&#123; ch: make(chan string, 10), &#125;&#125;// Tracker knows how to track events for the applicationtype Tracker struct &#123; ch chan string stop chan struct&#123;&#125;&#125;// 传递context为了管控生命周期// 用channel来做，而不是创建大量的goroutinefunc (t *Tracker) Event(ctx context.Context, data string) error &#123; select &#123; case t.ch &lt;- data: return nil case &lt;-ctx.Done(): return ctx.Err() &#125;&#125;// 在后台消费消息func (t *Tracker) Run() &#123; for data := range t.ch &#123; time.Sleep(1 * time.Second) fmt.Println(data) &#125; t.stop &lt;- struct&#123;&#125;&#123;&#125;&#125;func (t *Tracker) Shutdown(ctx context.Context) &#123; close(t.ch) select &#123; case &lt;-t.stop: case &lt;-ctx.Done(): &#125;&#125; 1.5 总结用channel而不是大量创建goroutine； 搞清楚channel什么时候退出， 同时能够控制channel什么时候退出； 将函数的并发主动权 交给调用者； 管理goroutine的生命周期就是管其什么时机退出， 毛毛学go（最快的学习方式） 通篇看文档 然后看二手资料（别人的理解） Memory model 如何保证在一个goroutine中看到在另一个goroutine修改的变量的值，如果程序中修改数据时有其他goroutine同时读取，那么必须将读取串行化，为了串行化访问，请使用channel或其他同步原语，例如sync 和 sync/atomic来保护数据 Happen-Before在一个goroutine中，读和写一定是按照程序中的顺序执行的，即编译器和处理器只有在不会改变这个goroutine的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine可能会看到不同的执行顺序。例如，一个goroutine执行a=1,b=2;另一个goroutine可能看到b在a之前更新 线程1 线程2 1 A=1 3 B=1 2 print(B) 4 print(A) 是有可能打印出来两个1，原因就是产生了内存重排； Memory Reordering 用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU的设计者们，为了榨干CPU的性能，无所不用其极，像流水线、分支预测等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的内存重排，英文Memory Recordering 123456789// 编译器重排x = 0for i in range(100): x = 1 print xx = 1for i in range(100): print x 但是，如果这时有另外一个线程同时干了这么一件事： x=0 在多核心场景下，没有办法轻易判断两段程序是“等价”的； 现代CPU为了“抚平”内核、内存、硬盘之间的速度差异，搞出了各种策略，例如三级缓存等。 为了让（2）不必等待（1）的执行“效果”可见之后才能执行， 我们可以把（1）的效果保存到store buffer： store buffer 对单线程是完美的； 先执行（1）和（3），将他们直接写入store buffer，接着执行（2）和（4） （2）看了下store buffer，并没有发现有B的值，于是从Memory读出了0，（4）同样从Memory读出了0，最后，打印出了0 0； 因此，对于多线程的程序，所有的CPU都会提供“锁”支持，称之为barrier，或者fence。它要求：barrier指令要求所有对内存的操作都必须要“扩散”到memory之后才能继续执行其他对memory的操作。因此，我们可以用高级点的atomic compare-and-swap，或者直接用更高级的锁，通常是标准库提供； Memory model 为了说明读和写的必要条件，我们定义了先行发生（Happens Before）。如果事件e1 发生在 e2 前，我们可以说e2 发生在e1 后。如果e1 不发生在e2 前也不发生在e2 后，我们就说e1 和 e2 是并发的； 在单一的独立的goroutine中先行发生的顺序即是顺序中表达的顺序； 当下面条件满足时，对变量v的读操作r是被允许看到对v的写操作w的： r不先行发生于w 在w后r前没有对v的其他写操作 为了保证对变量v的读操作r看到对v的写操作w，要确保w是r允许看到的唯一写操作。即当下面条件满足时，r被保证看到w w先行发生于r 其他对共享变量v的写操作要么在w前，要么在r后； 这一对条件比前面的条件更严格，需要没有其他写操作与w或r并发发生； 单个goroutine中没有并发，所以上面两个定义是相同的： 读操作r看到最近一次的写操作w写入v的值。 当多个goroutine访问共享变量v时，它们必须使用同步事件来建立先行发生这一条件来保证读操作能看到需要的写操作 对变量v的零值初始化在内存模型中表现的与写操作相同 对大量single machine word（机器字：多个内存是可以原子赋值的）的变量的读写操作表现的像以不确定顺序对多个single machine word的变量的操作 https://www.jianshu.com/p/5e44168f47a3 Package syncShare Memory By Communication传统的线程模型（通常在编写Java、C++和Python程序时使用）程序员在线程之间通讯需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构（如Pyhton的Queue），这会变得更容易； Go的并发原语goroutine和channels 为构造并发软件提供了一种优雅而独特的方法。Go没有显式地使用锁来协调对共享数据的访问，而是鼓励使用chan在goroutine之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine可以访问数据； Do not communicate by sharing memory；instead，share memory by communicating； demo1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 使用 锁type Resource struct &#123; url string polling bool lastPolled int64&#125;type Resources struct &#123; data []*Resource lock *sync.Mutex&#125;func Poller(res *Resources) &#123; for &#123; // get the lease recently-polled Resource // and mark it as being polled res.lock.Lock() var r *Resource for _, v := range res.data &#123; if v.polling &#123; continue &#125; if r == nil || v.lastPolled &lt; r.lastPolled &#123; r = v &#125; &#125; if r != nil &#123; r.polling = true &#125; res.lock.Unlock() if r == nil &#123; continue &#125; // poll the URL // update the Resource's polling and lastPolled res.lock.Lock() r.polling = false r.lastPolled = time.Nanoseconds() res.lock.Unlock() &#125;&#125;// 使用channeltype Resource1 stringfunc Poller1(in, out chan *Resource1) &#123; for r := range in &#123; // poll the URL // send the processed Resource to out out &lt;- r &#125;&#125; Detecting Race Conditions With Go data race 是两个或多个goroutine 访问同一个资源（如变量或数据结构），并尝试对该资源进行读写而不考虑其他goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的bug。通常需要大量的日志记录和运气才能找到这些类型的bug； 早在6月份的Go1.1中，Go工具引入了一个race detector。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作； go build -race go test -race 123456789101112131415161718192021222324var Wait sync.WaitGroupvar Counter int = 0func main() &#123; for routine := 1; routine &lt;= 2; routine++ &#123; Wait.Add(1) go Routine(routine) &#125; Wait.Wait() fmt.Printf(\"Final Counter: %d\\n\", Counter)&#125;func Routine(id int) &#123; for count := 0; count &lt; 2; count++ &#123; value := Counter value++ Counter = value &#125; Wait.Done()&#125;// Final Counter: 4// Final Counter: 2 试图通过i++ 方式来解决原子赋值的问题，但是我们通过查看底层汇编： 123MOVQ Couner+0(SB), BX ; Copy the value of Counter to BXINCQ,BX ; Increment the value of BXMOVQ, BX, Counter+0(SB); Move the new value to Counter 实际上有三行汇编代码在执行以增加计数器。这三行汇编代码看起来很像原始的Go代码。在三行汇编代码之后可能有一个上下文切换。尽管程序现在正在运行，但从技术上讲，这个bug仍然存在。我们在Go代码看起来像是在安全地访问资源，而实际上底层的程序集代码根本就不安全； 我们应该使用Go同步语义：Mutex，Atomic 工具似乎检测到代码的争用条件，如果您查看race condition报告下面，您可以看到程序的输出：全局计算器变量的值为4 12345678910func Routine(id int) &#123; for count := 0; count &lt; 2; count++ &#123; value := Counter time.Sleep(1*time.Nanosecond)// 尽管只有一纳秒，但刚好触发goroutine的上下文切换； value++ Counter = value &#125; Wait.Done()&#125; 我们第一感觉是 single machine word （机器字，x86架构下 最小操作单位是8个bit）应该是原子赋值，为啥-race 会乱报，我们执行这个代码看看会发生什么； 1234567891011121314151617181920212223242526272829303132333435363738394041424344type IceCreamMaker interface &#123; Hello()&#125;type Ben struct &#123; id int name string&#125;func (b *Ben) Hello() &#123; fmt.Printf(\"ben says, %s\\n\", b.name)&#125;type Jerry struct &#123; name string&#125;func (j *Jerry) Hello() &#123; fmt.Printf(\"Jerry says,%s\\n\", j.name)&#125;func main() &#123; var ben = &amp;Ben&#123;id: 10, name: \"Ben\"&#125; var jerry = &amp;Jerry&#123;\"jerry\"&#125; var maker IceCreamMaker = ben var loop0, loop1 func() loop0 = func() &#123; maker = ben go loop1() &#125; loop1 = func() &#123; maker = jerry go loop0() &#125; go loop0() for &#123; maker.Hello() &#125;&#125; 对于一个interface的结构体来说，它内部是有两个字段（指针）组成。一个是Type指针，一个是Data指针。一个指向具体类型，一个指向原始数据。 12345// 所以不要假设，比如interface内部就不是完整的single machine wordtype interface struct &#123; Type uintptr // points to the type of the interface implementation Data uintptr // holds the data for the interface's receiver&#125; 对于语句var maker IceCreamMaker = ben,编译器将生成执行以下操作的代码。 所以很有可能在执行中，因为其不是一个完成的single machine word，很有可能Type指向Jerry，而Data则指向Ben。打印数据的时候就会报错； Go memory model提到过：表示写入单个machine word将是原子的，但interface内部是两个machine word的值。另一个goroutine可能在更改接口值时观察到它的内容； 在上面这个例子中，Ben和Jerry内存结构布局是相同的，因此它们在某种意义上是兼容的。想象一下，如果他们有不同的内存布局会发生什么混乱？比如给Ben加上id字段，发现程序panic了；因此更改后Ben和Jerry的内存模型发生改变了；所以即便熟悉runtime，（比如制造两个类型一致的结构体）也不要挑战data race 如果一个普通的指针、map、slice可以安全的更新吗？ 没有安全的data race（safe data race），您的程序要么没有data race，要么其操作未定义（undfined behavior）。 原子性 可见性 Lock 最晚加锁，最早释放，锁里面的代码越少越好，越简单越好，轻量。 多把锁的情况，注意它们的顺序，避免死锁； sync.atomic123456789101112131415161718192021222324252627282930type Config struct &#123; a []int&#125;func main() &#123; cfg := &amp;Config&#123;&#125; go func() &#123; i := 0 for &#123; i++ cfg.a = []int&#123;i, i + 1, i + 2, i + 3, i + 4, i + 5&#125; &#125; &#125;() var wg sync.WaitGroup for n := 0; n &lt; 4; n++ &#123; wg.Add(1) go func() &#123; for n := 0; n &lt; 100; n++ &#123; fmt.Printf(\"%v\\n\", cfg) &#125; wg.Done() &#125;() &#125; wg.Wait()&#125;//&amp;&#123;[118277 118308 118309 118310 118311 118312]&#125;//&amp;&#123;[81757 81758 81759 81760 81761 81762]&#125;//&amp;&#123;[119327 119328 119329 119330 119334 119340]&#125; 上面的例子，cfg作为包级全局对象，在这个例子中被多个goroutine同时访问，因此这里存在data race，会看到不连续的内存输出； 我们想到使用Go同步语义解决： Mutex RWMutex Atomic 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859type Config struct &#123; a []int&#125;func (c *Config) T() &#123;&#125;func BenchmarkAtomic(b *testing.B) &#123; var v atomic.Value v.Store(&amp;Config&#123;&#125;) go func() &#123; i := 0 for &#123; i++ cfg := &amp;Config&#123;a: []int&#123;i, i + 1, i + 2, i + 3, i + 4, i + 5&#125;&#125; v.Store(cfg) &#125; &#125;() var wg sync.WaitGroup for n := 0; n &lt; 4; n++ &#123; wg.Add(1) go func() &#123; for n := 0; n &lt; b.N; n++ &#123; cfg := v.Load().(*Config) cfg.T() // fmt.Printf(\"%v\\n\", cfg) &#125; wg.Done() &#125;() &#125; wg.Wait()&#125;func BenchmarkMutex(b *testing.B) &#123; var l sync.RWMutex var cfg *Config go func() &#123; i := 0 for &#123; i++ l.Lock() cfg = &amp;Config&#123;a: []int&#123;i, i + 1, i + 2, i + 3, i + 4, i + 5&#125;&#125; l.Unlock() &#125; &#125;() var wg sync.WaitGroup for n := 0; n &lt; 4; n++ &#123; wg.Add(1) go func() &#123; for n := 0; n &lt; b.N; n++ &#123; l.RLock() cfg.T() l.RUnlock() &#125; wg.Done() &#125;() &#125; wg.Wait()&#125; 12345678# go test -bench=. config_test.gogoos: darwingoarch: amd64cpu: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHzBenchmarkAtomic-8 228998002 4.660 ns/opBenchmarkMutex-8 610880 1685 ns/opPASSok command-line-arguments 2.672s 数据很明显，读写锁明显慢于原子操作； Benchmark是出结果真相的真相，即便我们知道可能Mutex VS Atomic的情况的，Mutex相对更重。因为涉及到更多的goroutine之间的上下文切换pack blocking goroutine，以及唤醒goroutine； 简单聊聊互斥锁的实现，fast pass和slow pass。死循环查找锁有没有释放，slow pass会把goroutine给休眠掉，等好了再唤醒。这就涉及到切换。切换会保存一些必要信息。所以会慢很多。 go help test chanPackage context 及联的传递 References Need all read","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"GMP","slug":"GMP","date":"2021-05-28T09:49:40.000Z","updated":"2021-05-31T09:12:22.543Z","comments":true,"path":"2021/05/28/GMP/","link":"","permalink":"http://yoursite.com/2021/05/28/GMP/","excerpt":"","text":"本节为重点章节本章节含视频版: 一、Golang“调度器”的由来？(1) 单进程时代不需要调度器我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代” 一切的程序只能串行发生。 早期的单进程操作系统，面临2个问题： 1.单一的执行流程，计算机只能一个任务一个任务处理。 2.进程阻塞所带来的CPU时间浪费。 那么能不能有多个进程来宏观一起来执行多个任务呢？ 后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。 (2)多进程/线程时代有了调度器需求 在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。 但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。 怎么才能提高CPU的利用率呢？ 但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。 很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。 (3)协程来提高CPU利用率多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。 大量的进程/线程出现了新的问题 高内存占用 调度的高消耗CPU 好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。 一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。 这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”. 看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。 之后，我们就看到了有3中协程和线程的映射关系： N:1关系 N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上 缺点： 某个程序用不了硬件的多核加速能力 一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。 1:1 关系 1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点， 缺点： 协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。 M:N关系 M个协程绑定1个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。 协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。 瓶颈就在协程调度器上了，协程调度器做的越好，整个架构性能越好；因为这个架构底层的线程涉及的CPU调度器是内核级别，是无法改变的； (4)Go语言的协程goroutineGo为了提供更容易使用的并发方法，使用了goroutine和channel。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。 Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。 Goroutine特点： 占用内存更小（几kb） 调度更灵活(runtime调度) (5)被废弃的goroutine调度器 好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。 Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？ 大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。 下面我们来看看被废弃的golang调度器是如何实现的？ M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。 老调度器有几个缺点： 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。 M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。 二、Goroutine调度器的GMP模型的设计思想面对之前调度器的问题，Go设计了新的调度器。 在新调度器中，出列M(thread)和G(goroutine)，又引进了P(Processor)。 Processor，处理器，它是用来处理goroutine的，它包含了运行每一个goroutine的资源， 如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。 (1)GMP模型在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。 全局队列（Global Queue）：存放等待运行的G。 P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。 P列表：所有的P都在“程序启动时”创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。可通过环境变量$GOMAXPROCS或者在程序中通过runtime.GOMAXPROCS来设置； M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。 有关P和M的个数问题 1、P的数量： 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。 2、M的数量: go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。 runtime/debug中的SetMaxThreads函数，设置M的最大数量 一个M阻塞了，会创建新的M。 M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。 P和M何时会被创建 1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。 2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。 (2)调度器的设计策略复用线程：避免频繁的创建、销毁线程，而是对线程的复用。 1）work stealing机制 当本线程（本P）无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。 2）hand off机制 当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。 利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。 抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。 全局G队列：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。 (3) go func() 调度流程 从上图我们可以分析出几个结论： 1、我们通过 go func()来创建一个goroutine； 2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中； 3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行； 4、一个M调度G执行的过程是一个循环机制； 5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P； 6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。 (4)调度器的生命周期 当启动一个go进程的时候，它是如何创建初始化这些线程和协程的。包括是如何启动main函数这么样的一个过程。调度器是如何完成的； M0和G0: 一个特殊的线程和协程 特殊的M0和G0 M0 M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。 (M0跟进程数量绑定，1比1的关系) G0 每次启动一个M，都会第一个创建的goroutine，就是G0. G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G（保存一个调度，栈的信息，它来提供环境，来去调度其他的G），G0不指向任何可执行的函数,（当一个M从G1切换到G2，首先要先切换到G0，然后通过G0把G1干掉，然后把G2再加过来。G0是中间的桥梁） 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。 （G0根M绑定，每个M都会有第一个G） 我们来跟踪一段代码 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello world\")&#125; 接下来我们来针对上面的代码对调度器里面的结构做一个分析。 也会经历如上图所示的过程： runtime创建最初的线程m0和goroutine g0，并把2者关联。 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。 G拥有栈，M根据G中的栈信息和调度信息设置运行环境 M运行G G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。 调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。 (5)可视化GMP编程有2种方式可以查看一个程序的GMP的数据。 方式1：go tool trace trace记录了运行时的信息，能提供可视化的Web页面。 简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。 trace.go 12345678910111213141516171819202122232425262728package mainimport ( \"os\" \"fmt\" \"runtime/trace\")func main() &#123; //创建trace文件 f, err := os.Create(\"trace.out\") if err != nil &#123; panic(err) &#125; defer f.Close() //启动trace goroutine err = trace.Start(f) if err != nil &#123; panic(err) &#125; defer trace.Stop() //main fmt.Println(\"Hello World\")&#125; 运行程序 12$ go run trace.go Hello World 会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。 1234$ go tool trace trace.out 2020&#x2F;02&#x2F;23 10:44:11 Parsing trace...2020&#x2F;02&#x2F;23 10:44:11 Splitting trace...2020&#x2F;02&#x2F;23 10:44:11 Opening browser. Trace viewer is listening on http:&#x2F;&#x2F;127.0.0.1:33479 我们可以通过浏览器打开http://127.0.0.1:33479网址，点击view trace 能够看见可视化的调度流程。 G信息 点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。 一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。 其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。 M信息 点击Threads那一行可视化的数据条，我们会看到一些详细的信息。 一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。 P信息 G1中调用了main.main，创建了trace goroutine g18。G1运行在P1上，G18运行在P0上。 这里有两个P，我们知道，一个P必须绑定一个M才能调度G。 我们在来看看上面的M信息。 我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下： 多了一个M2应该就是P0为了执行G18而动态创建的M2. 方式2：Debug trace 12345678910111213package mainimport ( \"fmt\" \"time\")func main() &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(time.Second) fmt.Println(\"Hello World\") &#125;&#125; 编译 1$ go build trace2.go 通过Debug方式运行 1234567891011$ GODEBUG&#x3D;schedtrace&#x3D;1000 .&#x2F;trace2 SCHED 0ms: gomaxprocs&#x3D;2 idleprocs&#x3D;0 threads&#x3D;4 spinningthreads&#x3D;1 idlethreads&#x3D;1 runqueue&#x3D;0 [0 0]Hello WorldSCHED 1003ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]Hello WorldSCHED 2014ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]Hello WorldSCHED 3015ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]Hello WorldSCHED 4023ms: gomaxprocs&#x3D;2 idleprocs&#x3D;2 threads&#x3D;4 spinningthreads&#x3D;0 idlethreads&#x3D;2 runqueue&#x3D;0 [0 0]Hello World SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出； 0ms：即从程序启动到输出这行日志的时间； gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置； idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量； threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量； spinningthreads: 处于自旋状态的os thread数量； idlethread: 处于idle状态的os thread的数量； runqueue=0： Scheduler全局队列中G的数量； [0 0]: 分别为2个P的local queue中的G的数量。 下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。 三、Go调度器调度场景过程全解析(1)场景1P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P1的本地队列。 (2)场景2 M1优先从本地队列取G，并且切换G时，通过G0来调度； G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了线程M1的复用。 场景3，场景4，场景5是相连的； (3)场景3假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。 (4)场景4G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列) （实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列） 这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。 (5)场景5G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。 G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。 (6)场景6规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。 假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。 (7)场景7M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。M2从全局队列取的G数量符合下面的公式： 1n &#x3D; min(len(GQ)&#x2F;GOMAXPROCS + 1, len(GQ&#x2F;2)) 至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是从全局队列到P本地队列的负载均衡。 假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。 (8)场景8假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。 全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。 (9)场景9G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。 为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU. 为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS=4，所以一共4个P)，多余的没事做线程会让他们休眠。 (10)场景10 假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。 (11)场景11G8创建了G9，假如G8进行了非阻塞系统调用。 M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。 四、小结总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"go_pro","slug":"go-pro","date":"2021-05-15T14:12:55.000Z","updated":"2021-05-19T15:22:53.309Z","comments":true,"path":"2021/05/15/go-pro/","link":"","permalink":"http://yoursite.com/2021/05/15/go-pro/","excerpt":"","text":"项目架构 协议处理层： 支持各种协议 Controller： 服务入口，负责处理路由，参数校验，请求转发 Logic/Service: 逻辑（服务）层，负责处理业务逻辑 DAO/Repository: 负责数据与存储相关功能；（和数据库和缓存打交道） 搭建通用脚手架模版 一个通用的脚手架模版需要做那些年事情呢？ 加载配置 初始化日志 初始化mysql 初始化redis 注册路由 启动服务 （优雅关机） 1. 加载配置12$&gt; mkdir settings &amp;&amp; cd settings &amp;&amp; touch settings.go$&gt; cd settings &amp;&amp; touch config.yaml 12345678910111213141516171819202122232425# config.yamlapp: name: \"web_app\" mode: \"dev\" port: 8081log: level: \"debug\" # 日志的级别 filename: \"web_app.log\" max_size: 200 # 默认大小 max_age: 30 # 默认存储30天 max_backups: 7mysql: host: \"\" port: \"3306\" user: \"\" password: \"\" dbname: \"pro\" max_open_conns: 200 max_idle_conns: 50redis: host: \"\" port: \"6379\" password: \"\" db: 0 # 默认连0 pool_size: 100 2. 初始化日志3. 初始化mysql3.1 建表语句1234567891011121314151617create table user( id bigint auto_increment primary key, user_id bigint not null, username varchar(64) not null, password varchar(64) not null, email varchar(64) null, gender tinyint default 0 not null, create_time timestamp default CURRENT_TIMESTAMP null, update_time timestamp default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP, constraint idx_user_id unique (user_id), constraint idx_username unique (username)) collate = utf8mb4_general_ci; 4. 用户认证 http是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个IP不代表同一个用户），在web应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋； 4.1 Cookie-Session认证模式 在web应用发展初期，大部分采用基于Cookie-Session的会话管理方式，逻辑如下 客户端使用用户名、密码进行认证 服务端验证用户名·密码正确后生成并存储session，将sessionID通过Cookie返回给客户端 客户端访问需要认证的接口时在Cookie中携带SessionID 服务端通过SessionID查找Session并进行鉴权，返回给客户端需要的数据 基于Session方式存在多种问题 服务端需要存储Session，并且由于Session需要经常快速查找，通常存储在内存或内存数据库中，同时在线用户较多时需要占用大量的服务器资源； 当需要扩展时，创建Session的服务器可能不是验证Session的服务器，所以还需要将所有Session单独存储并共享 由于客户端使用Cookie存储SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范CSRF攻击 4.2 Token认证模式 鉴于基于Session的会话管理方式存在上述多个缺点，基于Token的无状态会话管理方式诞生了，所谓无状态，就是服务端可以不再存储信息，甚至是不再存储Session，逻辑如下 客户端使用用户名， 密码进行认证 服务端验证username password正确后生成Token返回客户端 客户端保存Token，访问需要认证的接口时在URL参数或HTTP Header中加入Token 服务端通过解码Token进行鉴权，返回给客户端需要的数据 基于Token的会话管理模式有效解决了基于Session的会话管理方式带来的问题 服务端不需要存储和用户鉴权有关的信息，鉴权信息会被加密到Token中，服务端只需要读取Token中包含的鉴权信息即可 避免了共享Session导致的不易扩展的问题 不需要依赖Cookie，有效避免了Cookie带来的CSRF攻击问题 使用CORS可以快速解决跨域问题 4.3 JWT JWT是JSON Web Token的缩写，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准 JWT本身没有定义任何技术实现，它只是定义了一种基于Token的会话管理的规则，涵盖Token需要包含的标准内容和Token的生成过程，特别适用于分布式站点的单点登录（SSO）场景 一个JWT Token就像这样： 12# 参考davinciey...... 它由 . 分隔的三部分组成，这三部分依次是 头部（Header） 负载（Payload） 签名（Signature） 头部和负载以JSON形式存在，这就是JWT中的JSON，三部分的内容都分别单独经过base64编码，以 . 拼接成一个JWT ； Header JWT的Header中存储了所使用的加密算法和Token类型 1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; Payload Payload表示负载，也是一个JSON对象，JWT规定了7个官方字段供选用 1234567iss(issuer): 签发人exp(expiration time): 过期时间sub(subject): 主题aud (audience)： 受众nbf(Not Before)： 生效时间iat(Issued At)： 签发时间jti(JWT ID)： 编号 除了官方字段，开发者也可以自己制定字段和内容，例如下面的内容 12345&#123;\"sub\": \"1234567890\",\"name\": \"alex\",\"admin\": true&#125; 注意JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个JSON对象也要使用Base64URL算法转成字符串； Signature Signature 部分好似对前两部分的签名，防止数据篡改 首先，需要制定一个密钥（secret）这个密钥只有服务器才知道，不能泄漏给用户。然后，使用Header里面制定的签名算法（默认是HMAC SHA256），按照下面的共识产生签名 1HMACSHA256(base64UrlEncode(header)+\".\"+base64UrlEncode(payload),secret) JWT优缺点JWT拥有基于Token的会话管理方式所拥有的一切优势，不依赖Cookie，使其可以防止CSRF攻击，也能在禁用Cookie的浏览器环境中正常运行 而JWT的最大优势是服务端不再需要存储Session，使得服务端认证鉴权业务方便扩展，避免存储Session所需要引入的Redis等组件，降低了系统架构的复杂度，但也是JWT最大的劣势，由于有效期存储在Token中，JWT Token一旦签发，就会在有效期内一直可用，无法在服务端废止，当用户进行登出操作，只能依赖客户端删除本地存储的JWT Token，如果需要禁用用户，单纯使用JWT就无法做到了； 基于JWT实现认证实践 前面讲的Token，都是Access Token，也就是访问资源接口时所需要的Token，还有另外一种Token，Refresh Token，通常情况下，Refresh Token的有效期会比较长，而Access Token的有效期比较短，当Access Token由于过期而生效时，使用Refresh Token就可以获取新的Access Token，如果Refresh Token也失效了，用户就只能重新登录了； 在JWT的实践中，引入Refresh Token，将会话管理流程改进如下 Access Token(访问token，客户端访问服务时需要携带) 客户端使用用户名密码进行认证 服务端生成有效时间较短的Access Token（例如10分钟），和有效时间较长的Refresh Token（例如7天） 客户端访问需要认证的接口时，携带Access Token 如果Access Token没有过期，服务端鉴权后返回给客户端需要的数据 如果携带Access Token访问需要认证的接口时鉴权失败（例如返回401错误），则客户端使用Refresh Token向刷新接口申请新的Access Token 如果Refresh Token没有过期，服务端向客户端下发新的Access Token 客户端使用新的Access Token，访问需要认证的接口 后端需要对外提供一个刷新Token的接口，前端需要实现一个当Access Token过期时自动请求刷新Token接口获取新Access Token的拦截器 4.4 实践jwt-go这个库来实现生成JWT和解析JWT的功能； 基于Token的会话管理方式有效解决了基于Session的会话管理方式带来的问题； 4.4.1 限制同一账号同一时间只能登录一个 jwt方案的引入就是不想在服务端存储token，但一些需求比如限制同一账号同一时间只能登录一个的问题，既有的jwt方案就无法满足了； 它的实现规则是，在用户登录成功之后，服务端正常生成token，并做userid和token的关联。 等待后续，在下一个地点重新登录的时候，旧的userid 和 token关联就失效了；会建立新的userid和token关联； 4.5 循环引用问题 什么时候会出现循环引用问题， import cycle not allowed 1234package main import pro/controller import pro/middlewares import pro/controller middlewares 调用了 controller 在controller里面又调用了middlewares a导入 b, b导入 a 就形成 循环引用 4.6拿 前端处理大数字失真的问题 操作json的技巧 123type data struct &#123; ID int64 `json: \"id,string\"`&#125; 知其然，知其所以然。 js的number是双精度的，取值范围在 -(2^52-1) 和 2^52-1 之间。服务端一旦超过，需要转string 然后更高级的操作，是顺带查资料总结一下go操作 json所有的用法；求知欲； 5. makefile 借助makefile，我们可以在编译过程中不再需要每次手动输入编译的命令和编译的参数，可以极大简化项目编译过程； make是一个构建自动化工具，会在当前目录下寻找makefile或Makefile文件，如果存在相应的文件，它就会依据其中定义好的规则完成构建任务； 6. 使用Air实现gin框架实时重新加载 Air能够实时监听项目的代码文件，在代码发生变更之后自动重新编译并执行，大大提高gin框架项目的开发效率 7 vote功能提炼： 谁给哪个帖子投了什么票 谁 -&gt; userID （登陆到系统的当前用户） 哪个帖子 -&gt; postID (帖子ID) 什么票 -&gt; 1/-1 (赞/踩) zset：有序的集合，给key存值的时候，可以给值指定分数。届时根据值的大小从高到低或者从低到高去查询； 这里用两个zset来存储相关数据，实现vote功能； 给某个帖子投票的用户有哪些？ 设计redis key 123456const ( KeyPrefix = \"pro:\" KeyPostTimeZSet = \"pro:time\" // zset 帖子以及发帖时间 KeyPostScoreZSet = \"pro:score\" // zset 帖子以及投票的分数 KeyPostVotedPrefix = \"pro:voted:\" //zset 记录用户以及投票类型，参数是post_id)","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"hooks","slug":"hooks","date":"2021-05-12T11:48:36.000Z","updated":"2021-05-15T13:13:59.695Z","comments":true,"path":"2021/05/12/hooks/","link":"","permalink":"http://yoursite.com/2021/05/12/hooks/","excerpt":"","text":"简版hooks实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322import React from \"react\";import ReactDOM from \"react-dom\";const TEXT_ELEMENT = \"TEXT_ELEMENT\";let nextUnitOfWork = null;let wipRoot = null;// 定义一个引用用来保存最近一次commit给DOM时的fiber tree并且当此fiber tree在完成commit之后。let currentRoot = null;// 定义一个数组来跟踪要删除的节点let deletions = null;let wipFiber = null;let hookIndex = null;function createDOM(fiber) &#123; const dom = fiber.type === TEXT_ELEMENT ? document.createTextNode(\"\") // nodeValue 可以直接赋值 : document.createElement(fiber.type); updateDOM(dom, &#123;&#125;, fiber.props); return dom;&#125;function render(element, container) &#123; wipRoot = &#123; dom: container, props: &#123; children: [element], &#125;, // alternate 连接 上个阶段 commit 给DOM 的 fiber， alternate: currentRoot, &#125;; deletions = []; nextUnitOfWork = wipRoot;&#125;// Here we recursively append all the nodes to the dom.function commitRoot() &#123; deletions.forEach(commitWork); commitWork(wipRoot.child); // 当最近一次fiber tree完成commit之后, 保存该fiber tree的引用 currentRoot = wipRoot; wipRoot = null;&#125;/** * * @param &#123;*&#125; dom * @param &#123;*&#125; alternateProps 上一次commit的fiber * @param &#123;*&#125; props */// event 类型的props，需要以不同的方式处理他们；const isEvent = (key) =&gt; key.startsWith(\"on\");function isProperty(key) &#123; return key !== \"children\" &amp;&amp; !isEvent(key);&#125;const isNew = (prev, next) =&gt; (key) =&gt; prev[key] !== next[key];const isGone = (prev, next) =&gt; (key) =&gt; !(key in next);// 这个updateDOM的作用在于，比较新旧两次fiber， 删除已经移除的props，// set新的props或者更新的propsfunction updateDOM(dom, prevProps, nextProps) &#123; //Remove old or changed event listeners Object.keys(prevProps) .filter(isEvent) .filter((key) =&gt; !(key in nextProps) || isNew(prevProps, nextProps)(key)) .forEach((name) =&gt; &#123; const eventType = name.toLowerCase().substring(2); dom.removeEventListener(eventType, prevProps[name]); &#125;); // Remove old properties Object.keys(prevProps) .filter(isProperty) .filter(isGone(prevProps, nextProps)) .forEach((name) =&gt; &#123; dom[name] = \"\"; &#125;); // Set new or changed properties Object.keys(nextProps) .filter(isProperty) .filter(isNew(prevProps, nextProps)) .forEach((name) =&gt; &#123; dom[name] = nextProps[name]; &#125;); // Add event listeners Object.keys(nextProps) .filter(isEvent) .filter(isNew(prevProps, nextProps)) .forEach((name) =&gt; &#123; const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, nextProps[name]); &#125;);&#125;function commitWork(fiber) &#123; // commitWork 需要重构，重构的根据就是 fiber上面的 effectTag // 而不在是全部不分青红皂白，domParent.appendChild(fiber.dom) 了 // 'UPDATE' | 'PLACEMENT' | 'DELETION' if (!fiber) &#123; return; &#125; let domParentFiber = fiber.parent; // 因为有function 组件的存在，比如App，App就不是一个合法的tag while (!domParentFiber.dom) &#123; domParentFiber = domParentFiber.parent; // 如果App节点没有dom，那么就递归网上找 &#125; const domParent = domParentFiber.dom; // 新增没什么好说的，add if (fiber.effectTag === \"PLACEMENT\" &amp;&amp; fiber.dom != null) &#123; domParent.appendChild(fiber.dom); &#125; else if (fiber.effectTag === \"DELETION\") &#123; // 删除也没什么好说的 domParent.removeChild(fiber.dom); &#125; else if (fiber.effectTag === \"UPDATE\" &amp;&amp; fiber.dom != null) &#123; // update 操作 updateDOM(fiber.dom, fiber.alternate.props, fiber.props); &#125; commitWork(fiber.child); commitWork(fiber.sibling);&#125;function workLoop(deadline) &#123; let shouldYield = false; while (nextUnitOfWork &amp;&amp; !shouldYield) &#123; nextUnitOfWork = performUnitOfwork(nextUnitOfWork); shouldYield = deadline.timeRemaining() &lt; 1; &#125; // And once we finish all the work //(we know it because there isn’t a next unit of work) // we commit the whole fiber tree to the DOM. if (!nextUnitOfWork &amp;&amp; wipRoot) &#123; commitRoot(); &#125; requestIdleCallback(workLoop);&#125;// 启动任务requestIdleCallback(workLoop);function performUnitOfwork(fiber) &#123; // 添加处理原生节点和function component的逻辑判断 const isFunctionComponent = fiber.type instanceof Function; if (isFunctionComponent) &#123; console.log(fiber); updateFunctionComponent(fiber); &#125; else &#123; updateHostComponent(fiber); &#125; if (fiber.child) &#123; return fiber.child; &#125; let nextFiber = fiber; while (nextFiber) &#123; if (nextFiber.sibling) &#123; return nextFiber.sibling; &#125; nextFiber = nextFiber.parent; &#125;&#125;function updateFunctionComponent(fiber) &#123; // 我们还向fiber 添加了一个hooks数组，以支持在同一 // 组件中多次调用useState。并且我们跟踪当前的 hookIndex。 wipFiber = fiber; hookIndex = 0; wipFiber.hooks = []; const children = [fiber.type(fiber.props)]; reconcileChildren(fiber, children);&#125;// 当函数组件调用useState，// 检查是否有 old hook// 依据hookIndex 检查 fiber的 alternate// 如果有old hook，复制其state到新hook中， 如果没初始化statefunction useState(initial) &#123; const oldHook = wipFiber.alternate &amp;&amp; wipFiber.alternate.hooks &amp;&amp; wipFiber.alternate.hooks[hookIndex]; const hook = &#123; state: oldHook ? oldHook.state : initial, queue: [], &#125;; const actions = oldHook ? oldHook.queue : []; actions.forEach((action) =&gt; &#123; hook.state = action(hook.state); &#125;); const setState = (action) =&gt; &#123; hook.queue.push(action); wipRoot = &#123; dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot, &#125;; nextUnitOfWork = wipRoot; deletions = []; &#125;; wipFiber.hooks.push(hook); hookIndex++; return [hook.state, setState];&#125;function updateHostComponent(fiber) &#123; if (!fiber.dom) &#123; fiber.dom = createDOM(fiber); &#125; const elements = fiber.props.children; reconcileChildren(fiber, elements);&#125;// reconcile old fiber and new elementsfunction reconcileChildren(wipFiber, elements) &#123; let index = 0; let oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child; let prevSibling = null; while (index &lt; elements.length || oldFiber != null) &#123; // element 是需要渲染到DOM的东西，而oldFiber是上次渲染的东西 // 需要比较 element 和 oldFiber的差异来决定是否需要对DOM进行修改 const element = elements[index]; let newFiber = null; const sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type; // 如果oldFiber 和 element 拥有同样的type，保持这个DOM 节点，仅仅更新props即可 if (sameType) &#123; // update the node newFiber = &#123; // type: element.type, type: oldFiber.type, // 既然是更新，那type不用改 props: element.props, // props用 新的 dom: oldFiber.dom, parent: wipFiber, alternate: oldFiber, // newFiber alternate 指回 oldFiber effectTag: \"UPDATE\", // 在commit阶段需要使用的属性， &#125;; &#125; // 如果type不同，是个新的element， if (element &amp;&amp; !sameType) &#123; // add this node newFiber = &#123; type: element.type, props: element.props, // props用 新的 dom: null, parent: wipFiber, alternate: null, effectTag: \"PLACEMENT\", // 在commit阶段需要使用的属性， &#125;; &#125; // 如果type不同，old filber存在 if (oldFiber &amp;&amp; !sameType) &#123; // delete the oldFiber's node // delete的时候，是没有 element的，只有oldFiber,所以标记需要加到oldFiber上 oldFiber.effectTag = \"DELETION\"; deletions.push(oldFiber); &#125; if (oldFiber) &#123; oldFiber = oldFiber.sibling; &#125; // react用 key属性体现在这里，就是为了更好的reconciliation，比如子节点 // 只是在element array中改变位置；如果没有key，那便意味着当child只是移动位置 // 但在diff时候无法判断，就只能 做update node的操作； if (index === 0) &#123; wipFiber.child = newFiber; &#125; else &#123; prevSibling.sibling = newFiber; &#125; prevSibling = newFiber; index++; &#125;&#125;const Didact = &#123; createElement, render, useState,&#125;;function createElement(type, props, ...children) &#123; return &#123; type, props: &#123; ...props, children: children.map((child) =&gt; typeof child === \"object\" ? child : createTextElement(child) ), &#125;, &#125;;&#125;function createTextElement(text) &#123; return &#123; type: TEXT_ELEMENT, props: &#123; nodeValue: text, // 只能给createTextNode 创建的节点赋值 children: [], &#125;, &#125;;&#125;const container = document.getElementById(\"root\");function Counter() &#123; const [state, setState] = Didact.useState(1); return Didact.createElement( \"h1\", &#123; onClick: () =&gt; setState((c) =&gt; c + 1), &#125;, \"Count: \", state );&#125;const element = Didact.createElement(Counter, null);Didact.render(element, container); hook代码组织构成UI = fn(state) fn接受全局状态，这个函数调用的结果就是视图的UI this.setState的调用就是这个函数的快门 state：Reconciler 计算出状态变化； 在Reconciler中会执行一个被称为reconcile的算法，也就是常说的diff算法； fn：Renderer 将状态变化渲染在视图中； 用户调用this.setState =&gt; 进入reconcile部分计算出状态变化 =&gt; 将状态变化渲染在视图中； 状态变化会进入渲染器并被渲染在视图中； 代码在reconcile中被称render阶段，组件的render函数就是在这个阶段被调用 代码在Renderer中执行时，被称为commit阶段；是因为可以将状态变化的提交类比于代码提交的git commit命令； 生命周期函数调用过程 12345root = AppApp.child = P1P1.sbling = P2P1.child = C1C1.sbling = C2 调用ReactDOM.render， 进入render阶段， 采用深度优先遍历创建fiber树，即虚拟DOM树 在深度遍历时，会针对每个fiber进行执行声明周期函数（constructor，getDerivedStateFromProp/componentWillMount/render） render阶段完成进入commit阶段，首先会将fiber树对应的DOM渲染到视图中；渲染完成后，我们会从子节点开始执行对应的生命周期函数componentDidMount,顺着子节点依次回溯到根节点； 这次交互会调用this.setState，交互结果是将C2从蓝色变为绿色,此时重新进入render阶段 依旧是深度优先遍历的方式，创建一个fiber树，首先创建App节点，然后是P1，C1。 每次调用setState时都会创建一课完整的fiber树，接着是兄弟节点C2，此时reconcile算法发现了C2存在更新的副作用， reconcile算法标记变化；然后调用C2的生命周期函数(getDerivedStateFromProps/render),当render完成之后，再次进入commit阶段 执行reconcile算法标记的变化对应的视图操作，即DOM操作，然后执行此节点对应的生命周期函数。 执行完毕之后，这颗fiber树又会替换掉之前的那一颗fiber树；等待下一次调用this.setState再生成一颗新的fiber树； this.setState同步还是异步react的三种不同模式 legacy模式：ReactDOM.render(&lt;App/&gt;, rootNode) ,当前React app使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能 blocking模式：ReactDOM.createBlockingRoot(rootNode).render(&lt;App/&gt;)实验中，作为迁移到concurrent模式的第一个步骤 concurrent模式：ReactDOM.createRoot(rootNode).render(&lt;App/&gt;)实验中，未来稳定之后，打算作为React默认开发模式，这个模式开启了所有的新功能； 12345678910111213141516171819class App extends React.Component &#123; state = &#123; num: 0 &#125; updateNum = () =&gt; &#123; console.log('before setState', this.state.num); this.setState(&#123;num: this.state.num + 1&#125;); console.log('after setState', this.state.num); &#125; render()&#123; const &#123;num&#125; = this.state console.log(\"AppClass render \", num); return &lt;p onClick=&#123;this.updateNum&#125;&gt;hello &#123;num&#125;&lt;/p&gt; &#125;&#125;// AppClass render 0// before setState 0// after setState 0// AppClass render 1 从这个demo可以看出，setState是异步的。造成这个结果的原因是，react中对setState有一个优化措施，即batchedUpstates(批处理) 如果当前触发了多个setState，但也会触发一次render，这是因为react将多次setState合并成了一次更新。这样就能提高react的性能； 批处理的实现 1234567# react/ReactFiberWorkLoop.js一个函数调用栈周期内的 作用域会有一个BatchedContext flag，此时，该调用栈中所有setState会被合并成一个；因此，当切换函数调用栈的时候，作用域中自然不会有同一个BatchedContext flag；当不存在此flag时，react中有一个源码叫scheduleUpdateOnFiber，if(executionContext === NoContext) &#123; resetRenderTimer(); flushSyncCallbackQueue(); # 同步直接更新&#125; 123456789101112131415161718192021class App extends React.Component &#123; state = &#123; num: 0 &#125; updateNum = () =&gt; &#123; console.log('before setState', this.state.num); setTimeout(()=&gt;&#123; this.setState(&#123;num: this.state.num + 1&#125;); console.log('after setState', this.state.num); &#125;) &#125; render()&#123; const &#123;num&#125; = this.state console.log(\"AppClass render \", num); return &lt;p onClick=&#123;this.updateNum&#125;&gt;hello &#123;num&#125;&lt;/p&gt; &#125;&#125;// AppClass render 0// before setState 0// AppClass render 1// after setState 1 总结，不同模式。setState是不同的，legacy模式下，当代码命中batchedUpdates时是异步，没命中便是同步； 对于Concurrent模式来说，都是异步的； useEffect(fn, []) 与 componentDidMount 的区别探讨的其实是fn与componentDidMount的执行时机有什么不同，对于useEffect的回调函数来说，他的执行是依赖于他的第二个参数也就是他的依赖项的。 所以，此问题可以概括为 useEffect 第二个参数[] 是如何影响fn的执行？ 第二个参数是如何影响对应的fiber创建Passive effect的呢？ 第一种情况，不包含第二个参数，他会在mount时以及update时创建对应的Passive effect，也就是说，如果一个函数组件使用了第一种情况。每次render时都会创建一个Passive effect。 第二种情况，包含一个空数组作一个依赖项。那么他会在mount时创建Passive effect； 第三种情况，那么他会在mount时以及依赖项发生变化时创建， fn和component的执行时机 回顾上面生命周期，react中render阶段是如何将状态变化传递给commit阶段的呢？ 是通过在fiber上搭载被叫做effect（新版叫flags）的数据结构， 插入DOM Placement 更新DOM Update 删除DOM Deletion 更新Ref Ref useEffect Passive 左边是更新前的fiber树，右边是更新后的fiber树； 我们从最后一个字节点开始C2，代表有DOM属性变化，标记Update effect，P2之前不存在，标记Placement， App这个节点，它在之后的fiber上包含了useEffect的执行。所以它会被标记Passive effect，这些不同fiber节点的effect会通过一条链条连接在一起； 所以render阶段与commit阶段之间，传递的是什么 传递的是一条包含了不同fiber节点的effect的链表 1Passive ---&gt; Placement ---&gt; Update 之后进入commit阶段，是如何处理这条链表上的每个effect的呢？ commit阶段要做的事将effect渲染到视图中 简单将commit阶段分为三个子阶段 渲染视图前（beforeMutation） 渲染视图 （mutation） 渲染视图后 （layout） 对于placement来说，它会在mutation阶段执行对应DOM节点appendChild操作。这样DOM节点就会被插入到视图中。接下来会在layout阶段调用componentDIdMount。 而对于我们的Passive effect来说，它会在commit阶段的三个子阶段执行完成之后。异步调用useEffect回调。 所以对于开篇的疑问，useEffect和componentDidMount有什么区别？ ​ 首先useEffect会在commit节点执行完之后，异步的调用回调函数。而componentDidMount则会在layout这个子阶段同步的调用；可见他们的调用时机是完全不同的。那么有没有什么hook它的调用时机和componentDidMount是一致呢？ 这就是useLayoutEffect它也会在layout阶段同步调用；","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"js_async","slug":"js-async","date":"2021-05-10T07:09:30.000Z","updated":"2021-05-10T15:16:20.827Z","comments":true,"path":"2021/05/10/js-async/","link":"","permalink":"http://yoursite.com/2021/05/10/js-async/","excerpt":"","text":"async从一个例子开始 1234567891011121314function loop0()&#123; loop0()&#125;function loop1()&#123; return Promise.resolve().then(loop1)&#125;function loop2()&#123; setTimeout(loop2, 0)&#125;loop0()loop1()loop2() 在浏览器那个章节，我们已经提到过这三个function在渲染进程的执行情况； 首先loop0函数会栈溢出，这个几乎任何编程语言都会如此； 其次loop1，因为在切换下一个宏任务之前，要清空当前宏任务的微任务队列。由于loop1函数不断的产生微任务，导致当前宏任务的调用栈无法释放。下一个宏任务永远无法得到调用；所以在浏览器上的表现是block渲染进程，页面进入假死状态 最后loop2函数，该函数的执行会创造新的宏任务，由于宏任务的切换是根消息队列有关系的。此消息队列有一定的事件优先级。所以loop2这种代码从形式上来讲是合法的代码，只是0毫秒的间隔时间，js引擎并不会严格执行，这个还需要参考当前消息队列实际情况来定； 众所周知，js是单线程的语言。它原生不支持多线程并发。这与当初js的定位有关系，决定了它单线程的特性； 但就算是单线程的环境，依然存在异步任务的需求，比如我要在三秒之后执行弹窗脚本，或者我需要用户第一个请求的结果信息作为第二个请求的headers，这些都是异步的需求； 那根据js提供的消息队列机制； 宏任务有着强制性的优先级； 微任务，更细粒度的调度，在当前宏任务执行完毕之前全部执行完毕； 开发者，只有这两把武器，那么该如何使用好这两把武器来组织好代码； 如何组织异步代码1. 回调函数提到回到函数，上面的loop0，loop1, loop2。loop2是最安全的回调方式。因为我们并不能控制使用者在回调函数中传回来什么，调用者可以清晰堵死当前调用栈； 如果我们在回调函数的外层，加上setTimeout等将任务放入消息队列。那么我们便可以实现异步 12345function loop(fn)&#123; if (typeof fn === 'function') &#123; setTimeout(fn, 0) &#125;&#125; 回调函数解决了异步问题，但是有一个问题 12345678910111213141516171819function move(ball, act, cb)&#123; const Timer = setInterval(function()&#123; const left = parseInt(ball.style.marginLeft); if (left &lt; act) &#123; ball.style.marginLeft = (left + 1)+'px'; &#125; else &#123; clearInterval(Timer); cb(); &#125; &#125;, 4)&#125;move(ball1, 500, function()&#123; move(ball2, 500, function()&#123; move(ball3, 500, function()&#123; console.log('over') &#125;) &#125;)&#125;) 这样的代码，明显就不太合理了。我相信大多数开发者都不想自己的工程上充斥这样的代码； 2. Promise结合上面的代码，setTimeout既然给的0毫秒，那么调用者肯定是希望立即执行的；那样的话，其实使用微任务做异步也是可以的。这里便引入promise Promise在最新版本的chrome浏览器已经被实现了。我们先来看一下Promise异步代码的写法； 123456789101112131415161718192021222324function move(ball, act) &#123; return new Promise(function (resolve, reject) &#123; let index = 0; const Timer = setInterval(function () &#123; if (index++ &lt; act) &#123; ball.style.transform = `translateX($&#123;index&#125;px)`; &#125; else &#123; clearInterval(Timer); resolve(); &#125; &#125;, 4); &#125;);&#125;move(ball1, 500) .then(function () &#123; return move(ball2, 500); &#125;) .then(function () &#123; return move(ball3, 500); &#125;) .then(function () &#123; console.log(\"over\"); &#125;); Promise的then方法的写法比回调嵌套地狱要好上很多； 下面探讨一下Promise的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214const PENDING = 'pending'; //初始状态const FULFILLED = 'fulfilled';const REJECTED = 'rejected';function Promise(executor) &#123; let self = this; // 缓存 self.status = PENDING; // 定义存放成功的回调的数组 self.onResolvedCallbacks = []; // 定义存放失败的回调的数组 self.onRejectedCallbacks = []; // 当调用此方法的时候，如果promise状态为pending的话，可以转成成功态， 如果已经是成功态或者失败态了，则什么都不做； function resolve(value)&#123; // 2.1.1 if (value instanceof Promise) &#123; return value.then(resolve, reject); &#125; // 如果是初始态，则转成成功态 if(self.status === PENDING) &#123; self.status = FULFILLED; self.value = value // 成功后会得到一个值，这个值不能改 // 调用所有成功的回调 self.onResolvedCallbacks.forEach(cb =&gt; cb(self.value)); &#125; &#125; function reject(reason)&#123; // 2.1.2 // 初始态变失败态 if (self.status === PENDING) &#123; self.status = REJECTED; self.value = reason; // 失败的原因给了value self.onRejectedCallbacks.forEach(cb =&gt; cb(self.value)); &#125; &#125; try &#123; // 因为 此函数执行可能会异常，所以需要捕获，如果出错了，需要用错误对象 reject； executor(resolve, reject); &#125; catch (error) &#123; // 如果这函数执行失败了，则用失败的原因 reject这个promise reject(error); &#125;&#125;function resolvePromise (promise2, x, resolve, reject) &#123; if(promise2 === x) // 如果promise2 和 x指向了相同的对象， reject promise with a TypeError as the reason. &#123; return reject(new TypeError('循环引用')); &#125;; let called = false; // promise2 是否已经 resolve 或者 reject if(x!= null &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) &#123; // 当我们的promise 和别的promise 进行交互；编写这段代码的时候尽量的考虑兼容性，允许别人瞎写 try &#123; let then = x.then; if (typeof then === 'function')&#123; // 有些promise 会同时执行成功和失败的回调 then.call(x, function(y)&#123; // 如果promise2 已经成功或失败了，则不会再处理了 if(called)return; called = true; resolvePromise(promise2, y, resolve, reject); // 递归调用 &#125;, function(error)&#123; if(called)return; called = true; reject(error); &#125;); &#125; else &#123; // 到此的话，x不是一个thenable 对象，那直接把它当成值 resolve promise2 就可以了 resolve(x); &#125; &#125; catch (error) &#123; if(called)return; called = true; reject(error); &#125; &#125; else &#123; resolve(x); // 如果x是一个普通的值，则用x的值去 resolve promise2 &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; // 如果成功和失败的回调没有传，则表示这个then 没有任何逻辑，只会把值往后抛； // 2.2.1 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val =&gt; val; onRejected = typeof onRejected === 'function' ? onRejected: reason =&gt; &#123;throw reason&#125;; let self = this; let promise2; // 2.2.3.1 it must be called after promise is rejected, with promise’s reason as its first argument. if (self.status === FULFILLED) &#123; // 如果当前promise 状态已经是成功态了， onFulfilled直接取值； return promise2 = new Promise(function(resolve, reject)&#123; // 因为onFulfilled 有可能 异常，所以这里需要 trycatch setTimeout(function()&#123; try &#123; let x = onFulfilled(self.value); // 如果获取到了 返回值，会走解析promise的过程。 因为x可能是个普通值，也可能是个promise对象，也可能是个thenable对象（别人的写的promise），最终需要实现各种不同的promise实现之间的交互。 resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; // 如果执行成功的回调 过程中出错了，用错误原因把promise2 reject掉 reject(error); &#125; &#125;, 0) &#125;); &#125; if (self.status === REJECTED) &#123; return promise2 = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; try &#123; let x = onRejected(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0) &#125;) &#125; if (self.status === PENDING) &#123; return promise2 = new Promise(function(resolve, reject)&#123; self.onResolvedCallbacks.push(function()&#123; setTimeout(function()&#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0) &#125;); self.onRejectedCallbacks.push(function()&#123; setTimeout(function()&#123; try &#123; let x = onRejected(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error) &#125; &#125;, 0) &#125;); &#125;) &#125;&#125;// catch 原理就是只传失败的回调Promise.prototype.catch = function(onReject) &#123; this.then(null, onReject)&#125;Promise.deferred = Promise.defer = function() &#123; let defer = &#123;&#125;; // 延迟对象，Q angular 里面用的多 defer.promise = new Promise(function(resolve,reject)&#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125; function gen(times, cb)&#123; let result= [], count =0; return function(i, data)&#123; result[i] = data; if (++count === times)&#123; cb(result); &#125; &#125;&#125;Promise.all = function(promises) &#123; return new Promise(function(resolve, reject) &#123; let done = gen(promises.length, resolve) for(let i=0; i&lt;promises.length; i++) &#123; promises[i].then(function(data)&#123; done(i, data); &#125;, reject); &#125; &#125;)&#125;Promise.race =function(promises)&#123; return new Promise(function(resolve, reject)&#123; for(let i=0; i&lt;promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;)&#125;// 返回一个立即成功的promise对象Promise.resolve = function(value)&#123; return new Promise(function(resolve, reject)&#123; resolve(value); &#125;)&#125;// 返回一个立即失败的promise对象Promise.reject = function(reason)&#123; return new Promise(function(resolve, reject)&#123; reject(reason); &#125;)&#125;module.exports = Promise;/** * 测试脚本 * * promises-aplus-tests Promise.js */ 3. gen+promise123456789101112131415161718192021222324252627282930313233343536function move(ball, act)&#123; return new Promise(function(resolve, reject)&#123; let index = 0; const Timer = setInterval(function()&#123; if(index++ &lt; act) &#123; ball.style.transform = `translateX($&#123;index&#125;px)` &#125; else &#123; clearInterval(Timer); resolve(); &#125; &#125;, 4) &#125;)&#125;function *go()&#123; yield move(ball1, 500); yield move(ball2, 500); yield move(ball3, 500);&#125;// run 即 co库的核心实现，因为gen不会自己执行，所以需要有一个迭代器帮它执行完毕；function run(gen)&#123; let it = gen(); // 让生成器持续自执行 return new Promise(function(resolve, reject)&#123; !function next(lastVal)&#123; let &#123;value, done&#125; = it.next(lastVal); if(done) &#123; resolve(); &#125; else &#123; value.then(next, reject); &#125; &#125;(); &#125;)&#125;run(go) 4. async+await Async await 是 gen+promise的语法糖 12345678910111213141516171819202122function move(ball, act)&#123; return new Promise(function(resolve, reject)&#123; let index = 0; const Timer = setInterval(function()&#123; if(index++ &lt; act) &#123; ball.style.transform = `translateX($&#123;index&#125;px)` &#125; else &#123; clearInterval(Timer); resolve(); &#125; &#125;, 4) &#125;)&#125;async function go()&#123; await move(ball1, 500); await move(ball2, 500); await move(ball3, 500);&#125;go() 至此，单线程JavaScript的异步代码组织方式就告一段落了。相比回调地狱，async+await的方式在组织代码的方式上好了太多；","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"mysql","slug":"mysql","date":"2021-05-10T02:15:24.000Z","updated":"2021-05-10T03:06:55.954Z","comments":true,"path":"2021/05/10/mysql/","link":"","permalink":"http://yoursite.com/2021/05/10/mysql/","excerpt":"","text":"1. 数据库能够做什么 存储大量数据，方便检索和访问 保持数据信息的一致、完整 共享和安全 通过组合分析，产生新的有用信息 2. 数据库的基本概念2.1 实体只要是在客观世界存在的、可以被描述出来的都是实体 2.2 数据库(DB) 数据库就是数据的仓库，可以存放结构化的数据 2.3 数据库管理系统(DBMS)是一种系统软件，提供操作数据库的环境，可以通过数据库管理系统对数据进行插入、修改、删除和查询等操作。 2.4 SQL结构化查询语言 专门用来和数据库进行交流的语言,几乎所有的DBMS都支持SQL 2.5 SQL规范 SQL语句不区分大小写，建议SQL关键字大写，表名和列表小写 命令用分号结尾 命令可以缩进和换行，一种类型的关键字放在一行 可以写单行和多行注释 , #和–是单行注释，/***/多行注释 3. 数据表 表是数据库中包含所有数据的数据库对象，也是其它对象的基础。 表定义是一个列的集合，数据在表中是按行和列的格式组织的，用来存放数据 行也称为记录用来存放一个个实体，列称为字段用来描述实体的某一个属性 学生管理系统2 4.MYSQL简介4.1 MYSQL特点 开源免费 性能高 安装使用都简单 4.2 MYSQL安装 mysql下载 安装MYSQL 4.3 MYSQL配置C:\\Program Files\\MySQL\\MySQL Server 5.5\\my.ini port 端口号 basedir 安装目录 datadir 数据存放访目录 character_set_server 字符集 default-storage-engine 存储引擎 sql-mode 语法模式 max-connections 最大连接数 4.4 MYSQL启动和停止12net start MySQLnet stop MySQL 4.5 通过命令行连接MYSQL12mysql -h 127.0.0.1 -P 3306 -uroot -p123456exit 4.6 切换数据库1use test; 4.7 显示有哪些表12show tables;show tables from mysql; 4.8 显示当前数据库1select database(); 4.9 查询表结构1DESC user; 5. 创建表 6. 数据完整性 为了实现数据完整性，需要检验数据库表中的每行和每列数据是否符合要求 在创建表的时候，应该保证以后的数据输入是正确的，错误的数据不允许输入 6.1 域完整性不同的字段需要设置为各种合适的类型，比如年龄就是整数类型 6.2 默认值默认值是指如果用户没有指定值的情况下会记录的此字段指定一个提供一个预先设定的值 可以把居住地默认值设置为北京 6.3 非空约束我们可以指定某个字段不能不输入，必须提供一个非空的值 姓名字段不能为空 7.实体完整性7.1 主键约束 表中一列或者几列组合的值能用来唯一标识表中的每一行，这样的列或者列组合称为表的主键，主键表的数据不同重复。 如果两列或者多列组合起来唯一标识表中的每一行，则该主键又称为”组合键” 主键的选择标准 最少性 尽量选择单个键作为主键 稳定性 ，由于主键是用来在两个表间建立联接的，所以不能经常更新，最好就不更新 7.2 外键成绩表中的学生ID应该在学生表中是存在的 我们应该让成绩表中的ID只能引用学生表中的ID，它们的值应该是一一对应的，也就是说成绩表中的ID是成绩表中的外键，对应学生表的主键 ，这样就可以保证数据的引用完整性 7.3 唯一约束唯一约束是指某个字段值是唯一的，在所有的记录中不能有重复的值. 学生的身份证号可以设置为唯一约束 7.4 标识列 当表中没有合适的列作为主键时可以考虑增加标识列，标识列是一个无实际业务含义的列，仅仅用来区分每条记录。 标识列的值是自动生成的，不能在该列上输入数据 7.5 外键约束一个表的外键必须引用另一个表的主键,比如成绩表中的学生ID会引用学生表的主键，课程ID会引用成绩表的主键 主表没有记录，子表中不能添加相应的记录 修改和删除主表记录不能让子表记录孤立，必须相应修改和删除 8. 数据操作8.1 创建学生表123456CREATE TABLE `student` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT ,`name` varchar(50) NOT NULL ,`age` int(11) NULL DEFAULT NULL ,`city` varchar(50) DEFAULT '北京' ,) 8.2 增加身份证号字段123ALTER TABLE `student` ADD COLUMN `idcard` varchar(15) NULL AFTER `city`; --增加身份证字段ALTER TABLE `student` MODIFY COLUMN `idcard` varchar(18) DEFAULT NULL AFTER `name`; --修改身份证字段ALTER TABLE `student`DROP COLUMN `idcard`; --删除身份证字段 8.3 添加约束12345678910-- 主键约束ALTER TABLE `student` ADD PRIMARY KEY (`id`);-- 唯一约束ALTER TABLE `student` ADD UNIQUE INDEX `uq_idcard` (`idcard`) ;-- 默认约束ALTER TABLE `student` MODIFY COLUMN `city` varchar(50) DEFAULT '北京' AFTER `age`;-- 外键约束ALTER TABLE `score` ADD CONSTRAINT `fk_stuid` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`);-- 删除约束ALTER TABLE `score` DROP FOREIGN KEY `fk_stuid`; 8.4 准备数据 123456789101112131415161718192021222324CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(50) NOT NULL, `idcard` varchar(18) DEFAULT NULL, `age` int(11) DEFAULT NULL, `city` varchar(50) DEFAULT '', PRIMARY KEY (`id`));CREATE TABLE `course` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`));CREATE TABLE `score` ( `student_id` int(11) NOT NULL DEFAULT '0', `course_id` int(11) NOT NULL DEFAULT '0', `grade` float DEFAULT NULL, PRIMARY KEY (`student_id`,`course_id`), KEY `fk_courseid` (`course_id`), CONSTRAINT `fk_courseid` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`), CONSTRAINT `fk_stuid` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 9. SQL9.1 SQL是什么Structured Query Language：结构化查询语言 9.2 为什么要用SQL 使用界面操作数据库不方便 我们需要通过应用程序去操作数据库 9.3 SQL组成9.3.1 DDL（data definition language）是数据定义语言主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用 9.3.2 DML（data manipulation language）是数据操纵语言它们是SELECT、UPDATE、INSERT、DELETE`，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言 9.3.3 DCL（DataControlLanguage）是数据库控制语言是用来设置或更改数据库用户或角色权限的语句，包括（grant,revoke等）语句 9.4 SQL运算符是一种符号，它是用来进行列间或者变量之间的比较和数学运算的 9.4.1 算术运算符 运算符 说明 + 加运算，求两个数或表达式相加的和，如1+1 - 减少减运算，求两个数或表达式相减的差，如4-1 * 乘运算，求两个数或表达式相乘的积，如2*2 / 除运算，求两个数或表达式相除的商，如6/4的值为1 % 取模运算，求两个数或表达式相除的余数，如：6%4的值为2 查询姓名全称 9.4.2 逻辑运算符 运算符 说明 AND 当且仅当两个布尔表达式都为true时，返回TRUE OR 当且仅当两个布尔表达式都为false，返回FALSE NOT 布尔表达式的值取反 9.4.3 比较运算符 运算符 说明 = 等于 &gt; 大于 &lt; 小于 &lt;&gt; 不等于 &gt;= 大于等于 &lt;= 小于等于 != 不等于 9.5 查询窗口 9.6 数据操作语言9.6.1 插入数据行9.6.1.1 语法1INSERT [INTO] 表名 [(列名)] VALUES (值列表) 9.6.1.2 插入记录向学生表插入一条记录, 姓名张三,身份证号123456,年龄30,城市北京 1234INSERT INTO [school].[student](name,idcard,age,city)VALUES('张三','123456',30,'北京') 9.6.1.3 注意事项 每次插入一行数据，不能只插入一部分数据，插入的数据是否有效将按照整行的完整性要求来检验 每个数据值的数据类型、精度、位数必须与要应的列名精确匹配 不能为标识符指定值 如果某字段设置为不能为空，则必须插入数据 插入数据时还要符合检查性约束的要求 有缺省值的列，可以使用DEFAULT关键字来代替插入实际的值 9.6.2 更新数据行9.6.2.1 语法1UPDATE 表名 SET 列名 = 更新值 [WHERE 更新条件] 9.6.2.2 更新记录 更新ID等于7的学生年龄改为40，城市改为上海 123UPDATE [school].[student] SET age = 40,city = '上海'WHERE id=7 9.6.2.3 注意 多列时用逗号隔开，一定要加更新条件以免错误更新 多个联合条件使用 AND id=7 and idcard=&#39;410787&#39; 判断某字段是否为空 email is null or email = &#39;&#39; 9.6.3 删除数据9.6.3.1 语法1DELETE [FROM] 表名 [WHERE &lt;删除条件&gt;] 9.6.3.2 删除记录 删除ID=7的学生记录 1DELETE FROM [school].[student] WHERE id=7 9.6.3.3 注意 Delete语句是对整行进行操作，因此不需要提供列名 如果要删除主表数据，则要先删除子表记录 9.6.4 TRUNCATE 截断表截断整个表中的数据 9.6.4.1 语法1TRUNCATE TABLE 表名 9.6.4.2 截断学生表1TRUNCATE TABLE student 数据全部清空,但表结构、列、约束等不被改动 不能用于有外键约束引用的表 标识列重新开始编号 因为要删除的数据不会写入日志，数据也不能恢复，所以工作中请尽量不要使用此命令 9.7 数据查询 查询就是从客户端 发出查询请求数据库服务器，并从数据库返回查询结果的过程 每次执行查询只是从数据表中提取数据，并按表的方式呈现出来 查询产生的是虚拟表,并不会保存起来 9.7.1 查询9.7.1.1 语法1234SELECT &lt;列名&gt; FROM &lt;表名&gt; [WHERE &lt;查询条件表达式&gt;] [ORDER BY &lt;排序的列名&gt;[ASC或DESC]] 9.7.1.2 排序 查询北京的学生信息，并按ID正序排列 1234SELECT id,name,idcard,age,cityFROM studentWHERE home= '北京'ORDER BY id asc 9.7.1.3 别名1234SELECT id,name,idcard,age,city AS homeFROM studentWHERE city= '山东'ORDER BY id asc 9.7.1.4 查询空行123SELECT id,name,age,cityFROM studentWHERE city is null or city ='' 9.7.1.5 常量列12SELECT id,name,age,city,'中国' as countryFROM student 9.7.1.6 限制返回的行数12SELECT id,name,age,city,'中国' as countryFROM student limit 2 9.7.1.7 DISTINCT 查询同学们一共来自哪些不同的城市 12SELECT id,name,age,DISTINCT city,'中国' as countryFROM student 9.7.1.8 + 在MYSQL中+号只能用作于数字 12345SELECT 1+1SELECT 1+'1'SELECT 1+'zfpx' SELECT 1+nullSELECT CONCAT(last_name,first_name) FROM user; 9.7.1.7 练习9.7.1.7.1 准备数据12345ALTER TABLE `student`ADD COLUMN `province` varchar(50) NULL AFTER `city`,ADD COLUMN `birthday` date NULL AFTER `province`,ADD COLUMN `gender` int(11) NULL AFTER `birthday`,ADD COLUMN `email` varchar(50) NULL AFTER `gender`; 1234567891011121314151617181920INSERT INTO `student`(id,name,gender,age,city,province,birthday,idcard,email) VALUES ('1', '郭靖', '1', '1', '济南', '山东省', '1982-09-03', 1, '1@qq.com');INSERT INTO `student`(id,name,gender,age,city,province,birthday,idcard,email) VALUES ('2', '黄蓉', '2', '2', '济南', '山东省', '1982-09-03', 0, '2@qq.com');INSERT INTO `student`(id,name,gender,age,city,province,birthday,idcard,email) VALUES ('3', '杨过', '3', '3', '终南山', '陕西省', '1979-09-03', 1, '3@qq.com');INSERT INTO `student`(id,name,gender,age,city,province,birthday,idcard,email) VALUES ('4', '小龙女', '4', '4', '终南山', '陕西省', '1970-09-03', 0, '4@qq.com');INSERT INTO `student`(id,name,gender,age,city,province,birthday,idcard,email) VALUES ('5', '欧阳锋', '5', '5', '白驼山', '新疆', '1989-09-09', 1, '5@qq.com');INSERT INTO `course` VALUES ('1', '语文');INSERT INTO `course` VALUES ('2', '数学');INSERT INTO `course` VALUES ('3', '英语');INSERT INTO `score` VALUES ('1', '1', '100');INSERT INTO `score` VALUES ('1', '2', '90');INSERT INTO `score` VALUES ('1', '3', '70');INSERT INTO `score` VALUES ('2', '1', '100');INSERT INTO `score` VALUES ('2', '2', '90');INSERT INTO `score` VALUES ('2', '3', '80');INSERT INTO `score` VALUES ('3', '1', '100');INSERT INTO `score` VALUES ('3', '2', '90');INSERT INTO `score` VALUES ('3', '3', '80'); 9.7.1.7.2 查询山东省的同学全部信息1select * from student where province = '山东'; 9.7.1.7.3 查询山东省的男同学的全部信息1select * from student where province = '山东' and gender=1; 9.7.1.7.4 查询没有填写电子邮箱的同学的姓名和身份证号1SELECT name,idcard FROM student WHERE email IS NULL 9.7.1.8 排序9.7.1.8.1 把学生的分数按升序排列1select * from score order by grade asc; 9.7.1.8.2 把学生的分数按降序排列1select * from score order by grade desc; 9.7.1.8.3 课程编号按升序，成绩按降序1select * from score order by course_id asc, grade desc; 9.8 函数9.8.1 字符函数 函数名称 描述 CONCAT 字符串连接 CONCAT_WS 使用指定的分隔符进行字符连接 FORMAT 数字格式化 LOWER 转小写字母 UPPER 转大写字母 LEFT 返回字符串s开始的最左边n个字符 RIGHT 返回字符串s开始的最左边n个字符 9.8.1.1 LENGTH123SELECT LENGTH('zfpx');SELECT LENGTH('珠峰培训');SHOW VARIABLES like '%char%'; 9.8.1.2 拼接字符串 [CONCAT]1SELECT CONCAT(last_name,'_',first_name) FROM employees; 9.8.1.3 拼接字符串 [UPPER]1SELECT UPPER('zfpx') FROM employees; 9.8.1.4 拼接字符串 [LOWER]1SELECT LOWER('ZFPX') FROM employees; 9.8.1.5 截取字符串 [SUBSTR]12SELECT SUBSTR('zfpx',2);-- 截取从指定索引处开始的所有的字符SELECT SUBSTR('zfpx',2,3);--截取从指定索引处开始的指定数量的字符 9.8.1.6 姓名的首字符大写，其它字符小写然后用_拼接1SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2))); 9.8.1.7 返回子串在原始字符串的起始索引1SELECT INSTR('zfpx','f'); 9.8.1.8 去掉左右空格[TRIM]1234SELECT TRIM(' zfpx ');SELECT LTRIM(' zfpx ');SELECT RTRIM(' zfpx ');SELECT TRIM('x' FROM 'xxzfpxxx'); 9.8.1.9 用空格补齐[LPAD]123SELECT LPAD('zfpx',10,'@');SELECT LPAD('1',8,'0');SELECT RPAD('1',8,'0'); 9.8.1.10 替换1SELECT REPLACE('zfpx','f','q') 9.8.1.11 FORMAT1234SELECT FORMAT(100000,2); 100,000.00select format(100.31111,2) 100.31select format(100.31111,0); 100SELECT FORMAT(423423234.65534453,2); 423,423,234.66 9.8.1.12 LEFT RIGHT12select left('abcde12345',5); //abcdeselect left('abcde12345',5); //12345 9.8.2 数学函数 函数名称 描述 CEIL 向上取整 FLOOR 向下取整数 DIV 整数取 MOD 取余(取模) POWER 幂运算 ROUND 四舍五入 TRUNCATE 数字截取 9.8.2.1 四舍五入12SELECT ROUND(2.5);SELECT ROUND(2.555,2); 9.8.2.2 向上取整1SELECT CEIL(1.00); 9.8.2.3 向下取整1SELECT FLOOR(1.00); 9.8.2.4 截断1SELECT TRUNCATE(1.66,1); 9.8.2.5 取余1SELECT mod(10,3); 9.8.3 日期函数 函数名称 描述 NOW 当前日期和时间 CURDATE 当前日期 CURTIME 当前时间 DATE_ADD 日期变化 DATEDIFF 计算日期差 DATE_FORMAT 日期格式化 9.8.3.1 返回日期时间1SELECT NOW(): 9.8.3.2 返回日期1SELECT CURDATE(): 9.8.3.3 返回日期1SELECT CURTIME(): 9.8.3.4 返回日期中指定的部分年 月 日 小时 分钟 秒 1234567SELECT YEAR(NOW());SELECT MONTH(NOW());SELECT MONTHNAME(NOW());SELECT DAY(NOW());SELECT HOUR(NOW());SELECT MINUTE(NOW());SELECT SECOND(NOW()); 9.8.3.5 str_to_date将日期格式的字符串转成指定格式的日期 1SELECT STR_TO_DATE('2018-09-09','%Y-%m-%d') 序号 格式符 功能 1 %Y 4位的年份 2 %y 2位的年份 3 %m 月份(01,02) 4 %c 月份(1,2) 5 %d 日(01,02) 6 %H 小时(24小时制) 7 %h 小时(12小时制) 8 %i 分钟(00,01) 9 %s 秒(00,01) 9.8.3.6查询入职日期为1984-8-4的员工信息 1SELECT * FROM employees WHERE hiredate = STR_TO_DATE('12-30 1984','%m-%d %Y'); 9.8.3.7 DATE_FORMAT将日期转换成指定字符串 1SELECT DATE_FORMAT(NOW(),'%Y年%m月%d日') 9.8.3.8 DATE_ADD123SELECT DATE_ADD(NOW(),INTERVAL 365 DAY);SELECT DATE_ADD(NOW(),INTERVAL 1 MONTH);SELECT DATE_ADD(NOW(),INTERVAL 1 YEAR); 9.8.3.9 DATEDIFF1SELECT DATEDIFF('2019-1-1',NOW()); 9.8.4 其它函数123456789SELECT CONNECTION_ID();SELECT DATABASE();SELECT VERSION();select LAST_INSERT_ID();SELECT USER();SELECT MD5('123456');//摘要算法SELECT PASSWORD('123456');//修改当前用户的密码SELECT User,Password from mysql.user; 9.8.5 流程控制函数9.8.5.1 IF1SELECT IF(1&gt;0,'A','B'); 9.8.5.2 CASE函数12345678910111213141516171819CASE 要判断的字段和表达式WHEN 常量1 then 要显示的值或语句1WHEN 常量2 then 要显示的值或语句2ELSE 要显示的值ENDSELECT CASE WHEN grade&lt;60 then '不及格'WHEN grade&gt;=60 then '及格'ELSE '未知'ENDFROM score;SELECT CASE levelWHEN 'A' then '优秀'WHEN 'B' then '良好'ELSE '未知'ENDFROM score; 9.9 自定义函数 自定义函数是对MySQL的扩展，使用方式和内置函数相同 函数必须要有参数和返回值 函数可以接收任意类型的值，也可以接收这些类型的参数 函数体由合法的SQL语句组成 函数体可以是简单的SELECT语句或INSERT语句，如果是复合结构要用BEGIN…END 函数体也可以包含声明，循环和流程控制 返回值只能有一个 9.9.1 语法12CREATE FUNCTION func_name() RETURNS VARCHAR(64)body 9.9.2 znow 注意函数名一定要跟着小括号表示参数 12CREATE FUNCTION znow() RETURNS VARCHAR(30)RETURN DATE_FORMAT(NOW(),'%Y年%m月%d日 %H点:%i分%s秒'); 9.9.3 zadd12CREATE FUNCTION zadd(num1 INT,num2 INT) RETURNS INTRETURN num1+num2; 9.9.4 addUser123456789CREATE TABLE stu(id int PRIMARY KEY AUTO_INCREMENT,name VARCHAR(50));CREATE FUNCTION addUser(name VARCHAR(50)) RETURNS INTBEGIN INSERT INTO stu(name) VALUES(name); RETURN LAST_INSERT_ID();ENDSELECT addUser('zfpx');DROP FUNCTION addUser 9.10 模糊查询就是查询的条件是模糊的，不是特别明确的 9.10.1 通配符代替一个或多个真正的字符，与LIKE 关键字一起使用 _表示一个任意字符 %表示任意长度的字符串 9.10.2 BETWEEN AND查询某一列在指定的规范内的记录，包括两个边界 1select * from score where grade between 80 and 100 9.10.3 IN查询某一列中的值在列出的内容列表中 1select * from student where city in ('北京','上海','广东') 9.10.4 IS NUL 查询没有邮箱的 IS NUL 查询有邮箱的 IS NOT NULL 10. DCL10.1 创建用户12CREATE USER 用户名@访问地址 IDENTIFIED BY '密码'CREATE USER user1@localhost IDENTIFIED BY '123456' 10.2 授予权限123GRANT 权限1,权限2,,, ON 数据库.* TO 用户名GRANT CREATE,DROP ON db1.* TO user1@localhost; 10.3 授予权限12REVOKE 权限1，权限2，，，ON 数据库.* FROM 用户名;REVOKE CREATE,DROP ONT db1.* FROM user1@localhost; 10.4 查看用户权限12SHOW GRANTS FROM 用户名SHOW GRANTS FROM user1@localhost; 10.5 删除用户12DROP USER 用户名DROP USER user1@localhost; 10.6 修改密码12UPDATE USER SET PASSWORD=PASSWORD('password') WHERE User='username' and Host='localhost';FLUSH PRIVILEGES; 11. 存储过程 大多数SQL语句都是针对一个或多个表的单条语句。但是并不是所有的操作都是可以用一条语句来完成的，经常有一些操作是需要多条语句配合才能完成。我们引入的存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它 11.1 语法1CREATE PROCEDURE([[IN |OUT |INOUT ] 参数名 数据类形...]) 11.2 调用 因为存储过程实际上是一种函数,所以存储过程名后需要有 () 符号(即使不传递参数也需要) 1CALL Avg_Price() 11.3 删除1DROP PROCEDURE IF EXISTS Avg_Price; 11.4 参数 存储过程并不显示结果，而是把结果返回给你指定的变量 1234567create procedure sum (in a int,in b int,out result int)beginselect a+b INTO result;endcall sum5(1,2,@result);select @result; 12. 索引 索引可以提高数据库的查询速度 12.1 准备数据1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 构建一个8388608条记录的数据 -- 创建用户表create table user( id int, username varchar(64), userno int)-- 创建生成随机字符串的函数CREATE FUNCTION `rand_string`(n INT) RETURNS varchar(255)BEGIN DECLARE chars_str varchar(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; DECLARE return_str varchar(255) DEFAULT ''; DECLARE i INT DEFAULT 0; WHILE i &lt; n DO SET return_str = concat(return_str,substring(chars_str , FLOOR(1 + RAND()*62 ),1)); SET i = i +1; END WHILE; RETURN return_str; END; -- 产生随机数字 create function rand_num() returns int(5) begin declare i int default 0; set i = floor(10+rand()*500); return i; end-- 创建存储过程，向用户表添加海量数据 create procedure insert_user(in start int(10),in max_num int(10)) begin declare i int; set i=0; while i&lt;max_num do set i=i+1; insert into user(id,username,userno) values((start+i),rand_string(6),rand_num()); end while; end;call insert_user(1,8388608); 12.2 创建普通索引123create table user(id int primary key,name varchar(32),email varchar(32));alter table user add index(name);create index idx_name on user(name); 12.3 查看索引12show index from 表名;show index from user 12.4 删除索引123alter table 表名 drop primary;alter table 表名 drop index 索引名;drop index 索引名 on 表名; 12.5 慢查询123explainselect * from users where userno=4593;alter table users add index(userno); 12.6 索引创建的原则 比较频繁作为查询条件的字段应该创建索引 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 更新非常频繁的字段不适合作创建索引 不会出现在where子句中的字段不该创建索引 13. 什么是聚合函数对一组值进行计算，并返回计算后的值，一般用来统计数据 1.1 SUM累加所有行的值 12计算ID=1的学生的的总分select SUM(grade) as '总分' from score where student_id = 1; 1.2 AVG计算所有行的平均值 12计算ID=1的学生的的平均分select AVG(grade) as '平均分' from score where student_id = 1; 1.3 MAX、MIN 计算所有行的最大值和最小值 1select MAX(grade) 最高分,MIN(grade) 最低分 from score where student_id = 1; 1.4 AVG 计算所有行的平均值 1select AVG(grade) as '平均分' 最低分 from score where student_id = 1; 1.5 COUNT 计算值不为NULL的行 1234select COUNT(*) from student;select COUNT(1) from student;select COUNT(name) from student;select COUNT(NULL) from student; 14. 分组分组查询就是按某列的值进行分组，相同的值分成一组，然后可以对此组内进行求平均、求和等计算 2.1 语法1234567SELECT 列名,查询表达式FROM &lt;表名&gt; WHERE &lt;条件&gt;GROUP BY &lt;分组字段&gt;HAVING 分组后的过滤条件ORDER BY 列名 [ASC,DESC]LIMIT 偏移量,条数 SELECT列表中只能包含： 被分组的列 为每个分组返回一个值的表达式，如聚合函数 2.2 练习 统计每位同学的平均成绩-单列分组 1select student_id,avg(grade) from score group by student_id; 统计每门课程的最高分，并按分数从高到低排列 1select course_id,max(grade) 平均分 from score group by course_id order by max(grade) desc 统计各省的男女同学人数-多列分组 1select province,gender,COUNT(*) from student group by province,gender 2.3 分组筛选2.3.1 语法123456SELECT FROM &lt;表名&gt;WHERE GROUP BY &#123;col_name|expr|position&#125;HAVING &#123;col_name|expr|position&#125;ORDER BY &#123;col_name|expr|position&#125; [ASC|DESC]LIMIT offset,row_count WHERE用于过滤掉不符合条件的记录 HAVING 用于过滤分组后的记录 GROUP BY用于对筛选后的结果进行分组 2.3.2 练习 统计学生人数超过1人的省份 1select province,COUNT(*) from student group by province having COUNT(*)&gt;1 不及格次数大于1次的学生 1select student_id,COUNT(*) 不及格次数 from score where grade &lt;60 group by student_id having COUNT(*)&gt;1 15. 子查询 子查询就是指出现在其它SQL语句中的SELECT语句,必须始终出现在圆括号中 子查询可以包含多个关键字或条件 子查询的外层查询可以是: SELECT、INSERT、UPDATE、SET等 子查询可以返回常量、一行数据、一列数据或其它子查询 3.1 比较运算符的子查询 = 等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 &lt;&gt; 不等于 != 不等于 &lt;=&gt; 安全不等于 3.2 查询年龄大于平均年龄的学生123SELECT ROUND(AVG(age),2) FROM student; SELECT * from student WHERE age &gt; (SELECT ROUND(AVG(age),2) FROM student) 3.2 ANY SOME ALL = &lt; &lt;= = &lt;&gt; != ANY 任何一个 SOME 某些 ALL 全部 123456年龄大于陕西省任何一位同学SELECT * from student WHERE age &gt; ANY (SELECT age FROM student WHERE province = '陕西省');年龄大于陕西省某些同学SELECT * from student WHERE age &gt; SOME (SELECT age FROM student WHERE province = '陕西省');年龄大于陕西省所有同学SELECT * from student WHERE age &gt; ALL (SELECT age FROM student WHERE province = '陕西省'); 3.3 查询一下有考试成绩的学生信息 [IN] [NOT IN] 1SELECT * FROM student where id in (SELECT distinct student_id from score); [EXISTS] [NOTEXISTS] 1SELECT * FROM student where EXISTS (SELECT distinct student_id from score where student.id = score.student_id ) 16. 表连接4.1 连接类型 INNER JOIN 内连接 LEFT JOIN 左外连接 RIGHT JOIN 右外连接 ON 连接条件 4.2 连接条件使用ON关键字来设定连接条件，也可以使用WHERE来代替 ON来设定连接条件 也可以使用WHERE来对结果进行过滤 4.3 内连接显示左表和右表中符合条件的 1SELECT * FROM student INNER JOIN score ON student.id = score.student_id; 4.4 左外连接显示左表的全部和右表符合条件的 1SELECT * FROM student LEFT JOIN score ON student.id = score.student_id; 4.5 右外连接显示右表的全部和左表符合条件的 1SELECT * FROM student RIGHT JOIN score ON student.id = score.student_id; 4.6 多表连接123SELECT student.name,course.name,score.grade FROM score INNER JOIN student ON student.id = score.student_idINNER JOIN course ON course.id = score.course_id; 4.7 无限分类[自身连接]4.7.1 建表12345CREATE table category( id int(11) PRIMARY KEY AUTO_INCREMENT NOT NULL, name varchar(50), parent_id int(11)) 4.7.2 插入语句123INSERT INTO category(id,name,parent_id)VALUES (1,'数码产品',0),(2,'服装',0),(3,'食品',0),(4,'iPad',1),(5,'李宁',2),(6,'康师傅',3); 4.7.3 查询所有的顶级分类下面分类的数量1234SELECT c1.id,c1.name,COUNT(1) FROM category c1 INNER JOIN category c2 ON c1.id = c2.parent_idWHERE c1.parent_id = 0GROUP BY c1.id; 4.7.4 父类变成名称12SELECT c1.id,c1.name,p.nameFROM category c1 LEFT JOIN category p ON c1.parent_id = p.id 4.8 删除重复记录[多表删除]12345INSERT INTO category(id,name,parent_id)VALUES(7,'iPad',1),(8,'李宁',2),(9,'康师傅',3); 4.8.1 子查询找要删除的ID123SELECT * FROM category c1 LEFT JOIN (SELECT id,name from category GROUP BY name HAVING COUNT(1)&gt;1) c2ON c1.name = c2.name WHERE c1.id != c2.id 4.8.2 通过IN找要删除的ID12345SELECT * FROM category c1 WHERE c1.name IN (SELECT name from category GROUP BY name HAVING COUNT(1)&gt;1)AND c1.id NOT IN (SELECT MIN(id) from category GROUP BY name HAVING COUNT(1)&gt;1) 4.8.3 删除重复记录12345DELETE FROM categoryWHERE name IN (SELECT NAME FROM ( SELECT name from category GROUP BY name HAVING COUNT(1)&gt;1) AS T1 )AND id NOT IN (SELECT id FROM (SELECT MIN(id) id from category GROUP BY name HAVING COUNT(1)&gt;1) AS T2) 4.9 多表更新4.9.1 (插入省份)INSERT SELECT12CREATE TABLE province(id int PRIMARY KEY AUTO_INCREMENT,name varchar(50))INSERT INTO province(name) SELECT DISTINCT province FROM student; 4.9.2 更新省份12UPDATE student INNER JOIN province ON student.province=province.name SET student.province=province.id 4.9.3 修改字段12ALTER TABLE student CHANGE COLUMN `province` `province_id` int(11); 17. 为什么需要设计数据库1.1 良好的数据库设计 节省数据的存储空间 能够保证数据的完整性 方便进行数据库系统的开发 1.2 糟糕的数据库设计 数据冗余，存储空间浪费 内存空间浪费 数据和更新插入异常 18. 软件项目开发周期中的数据库设计 需求分析阶段: 分析客户的业务和数据处理需求 概要设计阶段： 设计数据库的E-R模型图，确认需求的正确和完整性 详细设计阶段： 应用三大范式审核数据库 代码编写阶段： 物理实现数据库，编码实现应用 软件测试阶段 安装部署 现实世界-&gt;信息世界-&gt;数据库模型图-&gt;数据库 19.设计数据库的步骤3.1 收集信息与相关人员进行交流、访谈充分了解用户需求，理解数据库需要完成的任务 3.2 标示实体(Entity)标识数据库要管理的关键对象或者实体，实体一般是名词 3.3 标示实体的属性(Attribute)3.4 标示实体之间的关系(RelationShip)20. 数据库ER图ER图：实体关系图，简记E-R图，是指以实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据结构的概念模式 4.1 ER图的实体（entity） ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示 4.2 ER图的属性（attribute） ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示 属性分为唯一属性（ unique attribute）和非唯一属性 唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。 4.3 ER图的关系（relationship） ER图的关系（relationship）用来表现数据对象与数据对象之间的联系 例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。 4.4 ER图中关联关系4.4.1 1对1 (1:1)1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。 4.4.2 1对多（1:N）1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。 4.4.3 多对多（M:N）多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。 21. 数据库设计三大范式5.1 不合理的表设计 信息重复 更新异常 插入异常 删除异常 5.2 三大范式5.2.1 第一范式（1NF） 数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性； 5.2.2 第二范式（2NF） 满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情 一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余 5.2.3 第三范式（3NF） 必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，(表中的每一列只能依赖于主键) 数据不能存在传递关系,即每个属性都跟主键有直接关系而不是间接关系 5.2.4 如何更好的区分三大范式 第一范式和第二范式的区别在于有没有分出两张表,第二范式是说一张表中包含了所种不同的实体属性，那么要必须分成多张表 第三范式是要求已经分成了多张表，那么一张表中只能有另一张表中的id（主键），而不能有其他的任何信息（其他的信息一律用外键在另一表的主键看查询）。 22.RBAC 基于角色的权限访问控制（Role-Based Access Control） RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联 简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限-资源”的授权模型 在这种模型中，用户与角色之间，角色与权限之间，权限与资源之间一般是多对多的关系。 在RBAC中最重要的概念包括：用户(User)，角色(Role)，权限(Permission)，资源(Resource) 5.1 安全原则 最小权限原则之所以被RBAC所支持，是因为RBAC可以将其角色配置成其完成任务所需要的最小的权限集 责任分离原则可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐。 数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限 5.2 ER图 5.2.1 用户表 字段 字段名 类型 默认 id ID int(11) username 用户名 varchar(255) password 密码 varchar(255) email 邮箱 varchar(255) phone 手机号 varchar(255) gender 性别 tinyint birthday 生日 datetime addresss 地址 varchar(255) create_time 创建时间 datetime CURRENT_TIMESTAMP last_login 上次登录时间 datetime status 状态 tinyint 1 5.2.2 角色表 字段 字段名 类型 默认 id ID int(11) name 名称 varchar(255) create_time 创建时间 datetime CURRENT_TIMESTAMP status 状态 tinyint 1 5.2.3 资源表 字段 字段名 类型 默认 id ID int(11) name 名称 varchar(255) key 路径 varchar(255) create_time 创建时间 datetime CURRENT_TIMESTAMP status 状态 tinyint 1 5.2.4 用户角色表 字段 字段名 类型 user_id 用户ID int(11) role_id 角色ID int(11) 5.2.5 角色资源 字段 字段名 类型 role_id 角色ID int(11) resource_id 资源ID int(11) 5.3 数据库脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125ALTER TABLE `categories` DROP FOREIGN KEY `fk_category_parent_id`;ALTER TABLE `articles` DROP FOREIGN KEY `fk_article_category_id`;ALTER TABLE `user_role` DROP FOREIGN KEY `fk_user_role_user_id`;ALTER TABLE `user_role` DROP FOREIGN KEY `fk_user_role_role_id`;ALTER TABLE `role_resource` DROP FOREIGN KEY `fk_role_resource_role_id`;ALTER TABLE `role_resource` DROP FOREIGN KEY `fk_role_resource_resource_id`;DROP TABLE `users`;DROP TABLE `carousels`;DROP TABLE `categories`;DROP TABLE `articles`;DROP TABLE `navigations`;DROP TABLE `links`;DROP TABLE `config`;DROP TABLE `roles`;DROP TABLE `user_role`;DROP TABLE `resources`;DROP TABLE `role_resource`;CREATE TABLE `users` (`id` int(11) NOT NULL AUTO_INCREMENT,`username` varchar(255) NULL,`password` varchar(255) NULL,`last_login` datetime NULL DEFAULT CURRENT_TIMESTAMP,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,`email` varchar(255) NULL,`phone` varchar(255) NULL,`gender` tinyint(255) NULL,`birthday` datetime NULL,`address` varchar(255) NULL,PRIMARY KEY (`id`) );CREATE TABLE `carousels` (`id` int(11) NOT NULL AUTO_INCREMENT,`title` varchar(255) NULL,`url` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,PRIMARY KEY (`id`) );CREATE TABLE `categories` (`id` int(11) NOT NULL AUTO_INCREMENT,`title` varchar(255) NULL,`description` varchar(255) NULL,`keywords` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,`parent_id` int(11) NULL,PRIMARY KEY (`id`) );CREATE TABLE `articles` (`id` int(11) NOT NULL AUTO_INCREMENT,`category_id` int(11) NULL,`title` varchar(255) NULL,`content` text NULL,`user_id` int(255) NULL,`keywords` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,`pv` int(255) NULL,PRIMARY KEY (`id`) );CREATE TABLE `navigations` (`id` int(11) NOT NULL AUTO_INCREMENT,`title` varchar(255) NULL,`url` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,PRIMARY KEY (`id`) );CREATE TABLE `links` (`id` int(11) NOT NULL AUTO_INCREMENT,`title` varchar(255) NULL,`logo` varchar(255) NULL,`url` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,PRIMARY KEY (`id`) );CREATE TABLE `config` (`id` int(11) NOT NULL AUTO_INCREMENT,`name` varchar(255) NULL,`logo` varchar(255) NULL,`url` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,`keywords` varchar(255) NULL,`description` varchar(255) NULL,`icp` varchar(255) NULL,`about` varchar(255) NULL,PRIMARY KEY (`id`) );CREATE TABLE `roles` (`id` int(11) NOT NULL AUTO_INCREMENT,`name` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,PRIMARY KEY (`id`) );CREATE TABLE `user_role` (`user_id` int(11) NOT NULL AUTO_INCREMENT,`role_id` int(255) NOT NULL,PRIMARY KEY (`user_id`, `role_id`) );CREATE TABLE `resources` (`id` int(11) NOT NULL AUTO_INCREMENT,`name` varchar(255) NOT NULL,`key` varchar(255) NULL,`create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,`status` tinyint(255) NULL DEFAULT 1,PRIMARY KEY (`id`) );CREATE TABLE `role_resource` (`role_id` int(11) NOT NULL AUTO_INCREMENT,`resource_id` int(255) NOT NULL,PRIMARY KEY (`role_id`, `resource_id`) );ALTER TABLE `categories` ADD CONSTRAINT `fk_category_parent_id` FOREIGN KEY (`parent_id`) REFERENCES `categories` (`id`);ALTER TABLE `articles` ADD CONSTRAINT `fk_article_category_id` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`);ALTER TABLE `user_role` ADD CONSTRAINT `fk_user_role_user_id` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`);ALTER TABLE `user_role` ADD CONSTRAINT `fk_user_role_role_id` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`);ALTER TABLE `role_resource` ADD CONSTRAINT `fk_role_resource_role_id` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`);ALTER TABLE `role_resource` ADD CONSTRAINT `fk_role_resource_resource_id` FOREIGN KEY (`resource_id`) REFERENCES `resources` (`id`); 23.事务6.1 为什么需要事务 银行转账问题 A账户资金减少 B账户资金增加 123456789101112create database bank;use bank;create table account( name varchar(64), balance decimal(10,2)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into account(name,balance) values('张三',100);insert into account(name,balance) values('李四',100);update account set balance = balance - 10 where name = '张三';update account set balance = balance + 10 where name = '李四'; 6.2 什么是事务 事务是作为单个逻辑工作单元执行的一系列操作 多个操作作为一个整体向系统提交，要么都执行，要么都不执行 事务是一个不可分割的工作逻辑单元 转账过程就是一个整体，它需要两条UPDATE语句，如果任何一个出错，则整个转账业务取消，两个账户的余额都恢复到原来的数据，确保总余额不变 6.3 事务的特性 原子性(Atomicity) 事务是一个完整的操作，事务各个部分是不可分的，要么都执行，要么都不执行 一致性(Consistency) 当事务完成后，数据必须处理完整的状态 隔离性(Isolation) 并发事务彼此隔离、独立，它不应该以任何方式依赖于其它事务 持久性(Durability) 事务完成后，它对数据库的修改被永久保持 6.4 如何创建事务 开始事务 START TRANSACTION 或者 BEGIN 提交事务 COMMIT 回滚或者说撤销事务 ROLLBACK 123BEGIN;update account set balance = balance - 10 where name = '张三';ROLLBACK; 默认情况下，每条单独的SQL语句视为一个事务 关闭默认提交状态后，可手动开启、关闭事务 关闭/开启自动提交状态 SET autocommit=0|1 0关闭 1开启 关闭自动提交后，从下一条SQL语句开始开启新的事务，需要使用COMMIT或ROLLBACK结束该事务 24.在node中使用mysql mysql 1npm install mysql 7.1 使用mysql12345678910111213141516var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', user : 'me', password : 'secret', database : 'my_db'&#125;);connection.connect();connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;);connection.end(); 7.2 使用mysql连接池12345678910111213var mysql = require('mysql');var pool = mysql.createPool(&#123; connectionLimit : 10, host : 'example.org', user : 'bob', password : 'secret', database : 'my_db'&#125;);pool.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;); 7.3 使用mysql事务12345678910111213141516171819202122232425262728connection.beginTransaction(function(err) &#123; if (err) &#123; throw err; &#125; connection.query('INSERT INTO posts SET title=?', title, function (error, results, fields) &#123; if (error) &#123; return connection.rollback(function() &#123; throw error; &#125;); &#125; var log = 'Post ' + results.insertId + ' added'; connection.query('INSERT INTO log SET data=?', log, function (error, results, fields) &#123; if (error) &#123; return connection.rollback(function() &#123; throw error; &#125;); &#125; connection.commit(function(err) &#123; if (err) &#123; return connection.rollback(function() &#123; throw err; &#125;); &#125; console.log('success!'); &#125;); &#125;); &#125;);&#125;); 25.锁 锁时计算机协调多个进程或线程并发访问某一资源的机制 8.1 锁的分类 从对数据库操作的类型分，分为读锁和写锁 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁 从对数据操作的粒度分，分为 表锁 行锁 8.2 表锁 表锁偏向MyISAM存储引擎，开销小，加锁快，锁定粒度大，发生锁冲突的概率最高，并发度最低 8.2.1 准备数据1234567891011121314CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `NAME` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8;INSERT INTO `users` (`id`, `NAME`) VALUES ('1', 'a');INSERT INTO `users` (`id`, `NAME`) VALUES ('2', 'b');INSERT INTO `users` (`id`, `NAME`) VALUES ('3', 'c');INSERT INTO `users` (`id`, `NAME`) VALUES ('4', 'd');lock table 表名称 read(write),表名称2 read(write);unlock tables; 8.2.2 加读锁 会话1 会话2 说明 lock table users read; 连接数据库 select * from users; select * from users; 都可以查询 select * from role; select * from role; 会话1不能查询没有锁定的表，会话2可以查询没有锁定的表或更新未锁定的表 INSERT INTO users (id, NAME) VALUES (‘5’, ‘e’); INSERT INTO users (id, NAME) VALUES (‘5’, ‘e’); 会话1插入或更新会提示错误，会话2插入或更新会提示等待 unlock tables; INSERT INTO users (id, NAME) VALUES (‘5’, ‘e’); 会话1释放锁后，会话2完成插入操作 8.2.3 加写锁 会话1 会话2 说明 lock table users write; 连接数据库 select * from users; select * from users; 会话1可以对锁定表进行插入更新和删除操作,会话2的查询操作也会被阻塞 unlock tables; 会话1释放锁，会话2返回结果 读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞 8.3 行锁 行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高 InnoDB与MYISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁 8.3.1 行锁支持事务8.3.1.1 并发事务处理带来的问题8.3.1.1.1 更新丢失（Lost Update） 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。 后面的事务覆盖了前面的值,这是正常现象 1234567891011create table account3 (id int,balance int) ENGINE=InnoDB;insert into account3(id,balance) values(1,100);insert into account3(id,balance) values(2,100);set autocommit=0;begin;update account3 set balance=90 where id=1;commit;set autocommit=0;begin;update account3 set balance=80 where id=1;commit; 8.3.1.1.2 脏读（Dirty Reads） 一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做脏读。 一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。 脏读是事务B里面修改了数据 ,这是不正常的 解决办法：如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可 以避免该问题。 修改日志的隔离级别 1234567891011121314-- 支持的存储引擎SHOW ENGINES;-- 当前的数据库默认引擎SHOW VARIABLES LIKE 'storage_engine';SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;SELECT @@global.tx_isolation;SELECT @@session.tx_isolation;SELECT @@tx_isolation;start TRANSACTION;insert into account3(id,balance) values(3,100);start TRANSACTION;select * from account3; 8.3.1.1.3 不可重复读（Non-Repeatable Reads） 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做”不可重复读”。 一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性,这是不正常的 解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题 针对的是update或delete 修改日志级别 12345SET SESSION TRANSACTION ISOLATION LEVEL read committed;SET GLOBAL TRANSACTION ISOLATION LEVEL read committed;SELECT @@global.tx_isolation;SELECT @@session.tx_isolation;SELECT @@tx_isolation; 会话2 12start TRANSACTION;select * from account3; 会话2 123start TRANSACTION;delete from account3 where id=1;commit; 8.3.1.1.4 幻读（Phantom Reads） 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为”幻读”。 一句话：事务A读取到了事务B提交的新增数据，不符合隔离性 幻读是事务B里面新增了数据,这是不正常的 解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题 针对的是 insert 要更新隐藏的行之后才能看到幻读现象 12345678910111213SELECT @@tx_isolation;SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;SET GLOBAL TRANSACTION ISOLATION LEVEL repeatable read;SELECT @@global.tx_isolation;SELECT @@session.tx_isolation;SELECT @@tx_isolation;start TRANSACTION;insert into account3(id,balance) values(5,100);commit;start TRANSACTION;select * from account3;update account3 set balance =balance-10;commit; 8.3.1.2 事务隔离五种级别 read uncommitted : 读取尚未提交的数据 ：就是脏读 read committed：读取已经提交的数据 ：可以解决脏读 repeatable read：可重读读取：可以解决脏读和不可重复读 —mysql默认的 serializable：串行化：可以解决 脏读、不可重复读和幻读—相当于锁表 Innodb的默认事务隔离级别是重复读 repeatable read 123SELECT @@tx_isolation;set session transaction isolation levelset session transaction isolation level read uncommitted; 隔离级别 脏读 非重复读 幻读 read uncommitted 允许 允许 允许 read committed 允许 允许 repeatable read 允许 serializable 8.3.2 死锁 只有在INNODB引擎上的索引键上才会启用行级锁 Deadlock found when trying to get lock; try restarting transaction 会话1 会话2 说明 set autocommit=0 set autocommit=0 都关闭默认提交 update account set balance = balance -10 where name = ‘张三’ update account2 set balance = balance -10 where name = ‘李四’ update account2 set balance = balance -10 where name = ‘李四’; update account2 set balance = balance -10 where name = ‘张三’;","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"davinci dev","slug":"davinci-dev","date":"2021-05-08T07:06:07.000Z","updated":"2021-05-08T09:45:16.628Z","comments":true,"path":"2021/05/08/davinci-dev/","link":"","permalink":"http://yoursite.com/2021/05/08/davinci-dev/","excerpt":"","text":"先安装maven 点击idea编辑器的Projects Structure 配置两个jar包；（在Libray中的java目录中） 打zip包至target 1mvn clean install -Dmaven.test.skip=true 解压zip，打包davinci-ui， 启动服务 Wh","categories":[{"name":"davinci","slug":"davinci","permalink":"http://yoursite.com/categories/davinci/"}],"tags":[{"name":"pro","slug":"pro","permalink":"http://yoursite.com/tags/pro/"}]},{"title":"browser","slug":"browser","date":"2021-04-28T13:51:17.000Z","updated":"2021-05-14T02:01:44.494Z","comments":true,"path":"2021/04/28/browser/","link":"","permalink":"http://yoursite.com/2021/04/28/browser/","excerpt":"","text":"前言​ 就像一个服务端开发程序员需要掌握操作系统运行机制一样，前端开发程序员必须对浏览器的运行机制清晰掌握。了解释浏览器的机制是做出高性能web页面的基础。 ​ 同样浏览器也是运行在操作系统之上的软件，科技发展到今天。用户对web服务的质量要求越来越高。表现在软件的UI界面，需要首屏更早的显示，页面交互更加的人性化和智能化。浏览器也在日益完善这些需求之中不断进化，软件架构日趋完善。截止到现在，一个浏览器的构架越来越复杂，其复杂程度也越来越趋向操作系统内核。 ​ 1. 现代浏览器架构概述 以chrome浏览器为例 浏览器是个多进程的架构，但启动chrome，打开一个web页面的时候。我们通过chrome的任务管理器能准确看到，尽管只启动一个页面，浏览器多出了8个进程。 1.1 浏览器进程架构1.1.1 浏览器进程浏览器主进程，主要负责界面显示，用户交互，子进程管理，同时提供存储等功能； 1.2 渲染进程（标签页：chrome.storage-Chrome）核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中； 默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。值得注意的是，如果页面有iframe，那么iframe的页面也会运行在单独的进程中！ 出于安全考虑，渲染进程都是运行在沙箱模式下。 1.3 GPU进程绘制UI界面 1.4 Network Service单拎出来一个进程，管理整个浏览器的网络资源加载； 1.5 备用渲染程序1.6 Storage Service使用chrome.storage API可以存储，检索和跟踪对用户数据的更改 1.7 扩展程序（插件进程）负责插件的运行，因插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响； 1.2 多进程架构的好处浏览器并非一开始就是多进程架构，软件之所以革新，主要的原因无非是，现有的软件功能和使用体验跟不上用户需求，远远落后于竞争对手。 源代码变💩山迭代功能困难。 早期的浏览器（为IE6）为例。 IE6是单进程的也是单标签的，也就是说一个页面一个窗口。所有页面运行在一个主线程中的，意味着，所有的页面都共享着同一套JavaScript运行环境，同样，对于存储Cookie也都是在一个线程里面操作的。 早期浏览器厂商基于IE6开发多标签的形式，发现其中的一个标签页面的卡顿都会影响到整个浏览器。 基于卡顿的原因，浏览器厂商就开始尝试支持页面多线程，也就是让部分页面运行在单独的线程之中，运行在单独的线程之中，意味着每个线程拥有单独的JavaScript执行环境，和Cookie环境，这时候问题就来了： 比如A站点页面登陆一个网站，保存了一些Cookie数据到磁盘上，再在当前线程环境中保存部分Session数据，由于Session是不需要保存到硬盘上的，所以Session只会保存在当前的线程环境中。这时候再打开另外一个A站点的页面，假设这个页面在另外一个线程中里面，那么它首先读取硬盘上的Cookie信息，但是，由于Session信息是保存在另外一个线程里面的，无法直接读取，这样就要实现一个Session同步的问题，由于IE并没有源代码，所以需要自己实现这部分功能。 Session问题解决了，但是假死的问题依然有，因为进程内使用了一个窗口，这个窗口是依附到浏览器主窗口之上的，所以他们公用一套消息循环机制，这也就意味这一个窗口如果卡死了。也会导致整个浏览器的卡死。 这里还要提一下为什么Chrome中的一个页面假死不会影响到主窗口呢？这是因为chrome输出的实际上图片，然后浏览器端把图片贴到自己的窗口上去，在Chrome的渲染进程内，并没有一个渲染窗口，输出的只是图片，如果卡住了，顶多图片不更新了。 一些基于IE6开发的浏览器厂商实现这一套技术花了四五年时间，等这套技术差不多成熟时，Chrome发布了。 诚然，我们看到了历史进程。但很多东西依然需要结合时代背景去看。硬件设备近二十年更新实在太快，IE6被发明的那个时代，电脑多是单核架构的。不像现在的电脑，几乎都是4核起步， 有条件的大多数都是8核的机器。所以，IE6在那个时候直接开发多进程的浏览器模型且不说当时的电脑带不带的动，怕是能给喷死。 所以结合历史来看，从单进程架构升级到多进程架构也是自然而然的事情 多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题： 因为每个渲染进程都需要加载js运行环境，这就意味着浏览器总体上更消耗内存资源， 第二就是架构复杂度高，等前面的各种之父老去，后生接手困难。 但总体来说，chrome还是以一个非常快的速度在迭代，现在的普通软件应用开发中，前端也越来越重。因此，对于一个开发来说，能跟还是一定得跟住的； 2. HTML，CSS，Js等文件是如何变成页面的 当用户键入一个url之后，数据包通过漫长的运输跑到目标服务器，再返回到浏览器客户端，直到收到第一个html文件开始。浏览器做了哪些操作才能呈现出页面的呢？ 我人为的将它们拆分为两个阶段，第一个阶段是创建阶段，第二个阶段为等待更新阶段，第三个阶段为消亡阶段； 之所以人为区分三个阶段，是因为浏览器在每个阶段所做的事情，并不尽相同。尤其是第一阶段和第二阶段，第一阶段的优化重点是如何尽早获取到服务端的相关资源； 第二阶段则需要了然页面的循环机理，优化的重心是不要写出死循环代码，从而卡住页面，还要知道内存是如何管理，不能写出需要频繁GC的页面，造成页面卡顿。 第三阶段，要关注的地方虽然不多，但是在一些实际开发场景中，比如对于关闭页面之后如何有效进程数据提交； 2. 1 创建阶段 创建阶段指的是，浏览器将请求过来的html 代码字符串， css代码字符串，js代码字符串解析之后，然后首次绘制出第一帧并呈现到显示器上的这一过程。 创建阶段同样可以理解为页面加载阶段的场景，在这个阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于招呼和合成并不是这个阶段的核心诉求，因此我们需要调整策略，在加载阶段将页面解析，js脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级； 上面架构的章节有提到，每个标签页都是一个渲染进程，那每个渲染进程中也分别对应一个呈现引擎实例。所谓呈现引擎，功能诸多，下面将几种介绍其主要用途，即显示使用css格式化的HTML内容和图片； 2.1.1 呈现流程的基本流程渲染流水线 按照渲染的时间顺序，流水线可分为如下几个子阶段： 构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。 2.1.1.1 构建DOM树将html代码字符串转化为计算浏览器方便读取的对象结构，这部分就涉及词法分析和语法分析的内容了。最终生成的DOM树形结构就存到当前渲染进程的内存当中了。 通过DOM编程提供的API接口，就能访问到对应的DOM节点对象了。 浏览器的容错机制 在浏览HTML网页时从来不会看到html语法无效的错误，这是因为浏览器会纠正任何无效的内容，然后继续工作； 12345678910&lt;html&gt; &lt;mytag&gt; &lt;/mytag&gt; &lt;!-- mytag 是无效的tagName，但是浏览器不会报错，而是默默修复它们并继续往下解析--&gt; &lt;div&gt; &lt;p&gt; &lt;/div&gt; Really lousy HTML &lt;/p&gt;&lt;/html&gt; 截止到这里，浏览器已经生成DOM树了，但是DOM节点的样式我们依然不知道，让DOM节点拥有正确的样式，这就需要样式计算了； HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？ HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。 网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。 2.1.1.2 样式计算（Recalculate Style）样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。 2.1.1.2.1 样式计算的步骤把 CSS 转换为浏览器能够理解的结构 首先css代码可以写在页面的各个地方 12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;link href=\"theme.css\" rel=\"stylesheet\"/&gt; &lt;!-内联的方式---&gt; &lt;style&gt; body &#123; background: red; &#125; div &#123; width: 300px; height: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"color: red\"&gt; &lt;!--行内式--&gt; 123 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets 类似DOM树，styleSheets在内存中也可以查询和修改，这为后面的样式操作提供基础； 转换样式表中的属性值，使其标准化 123456body &#123; font-size: 2em &#125;p &#123;color:blue;&#125;span &#123;display: none&#125;div &#123;font-weight: bold&#125;div p &#123;color:green;&#125;div &#123;color:red; &#125; 转化后为 123456body &#123; font-size: 32px &#125;p &#123;color: rgb(0,0,255);&#125;span &#123;display: none&#125;div &#123;font-weight: 700&#125;div p &#123;color: rgb(0, 128, 0);&#125;div &#123;color: rgb(255, 0, 0); &#125; 将属性值标准化，有利于后续进一步操作的便捷度；这点类似软件分层机制； 计算出 DOM 树中每个节点的具体样式 接下来就需要计算 DOM 树中每个节点的样式属性 这就涉及CSS继承的规则和层叠规则了； CSS继承，CSS继承就是每个 DOM节点都包含有父节点的样式。 12345body &#123; font-size: 20px &#125;p &#123;color:blue;&#125;span &#123;display: none&#125;div &#123;font-weight: bold;color:red&#125;div p &#123;color:green;&#125; 从图上可以看出，所有子节点都继承了父节点样式。 样式计算过程中的第二个规则是样式层叠，样式层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法，它在CSS处于核心位置 总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。 2.1.1.2.2 the order of processing scripts and styles sheets在研究一个网页的中所有元素加载顺序的时候，我们不妨去想一个问题。我们如何保证一个页面的一致性。 浏览器是一个多进程的结构，为提高机器的使用率，我们可以在每个进程中可以创建多个线程。结合到页面的时候，我们能不能让多个线程来操作页面元素或者绘制页面呢？ 答案显然是不行，在上层文档 我们总能看到DOM文档渲染是同步的，是按着顺序执行。多线程的不稳定让我们在执行同样代码的时候可能产生出不同的视图。比如两个线程同时操作一个DOM节点，其中一个线程给字体变成红色，两一个线程给字体变成黄色。那么最终的结果，这个元素的字体颜色会时而红，时而黄的。 这显然是不能接受，因此渲染进程在渲染页面的时候，一定是运行在一个单线程上的； 第二，浏览器能识别HTML，CSS，JS代码。但也并不意味着浏览器是由js语言开发的。（这么说可能有点蠢，但对于初次了解浏览器机制的非科班开发者并非一无是处），我们明确一个事实，浏览器是运行在操作系统上的，我们的mac os windows 有无界面的linux均能安装浏览器比如chrome。 nodejs程序，浏览器都是直接运行在操作系统上，但我们的前端页面却是运行在浏览器上面的。像浏览器这种容器应用，必然需要追求极致性能。那GC类语言（GC类语言在进行垃圾回收的时候，会全停顿，那对跑在浏览器上面的web页面是致命的）自然是不能用了。主流的非GC语言就C/C++了。C/C++是原生的系统级语言，可以直接调用操作系统原生API，性能最强。 那既然如此，为何页面还要用发明一种js语言去开发网页呢？为何不直接用C/C++去开发网页。这就要追溯当时那个时期，开发者也就只想在html页面操作个表单罢了。C/C++语言学习曲线陡峭，哪怕直到今天依然是难学难用的计算机语言。 那最终便设计出了诸如 html，css，js这几种标记和脚本语言来进行页面的开发，html描述一个界面的骨架，css绘制这个骨架的样式，js负责定义这个骨架的行为。 这里面牵涉到一个问题，生成DOM树，生成CSSOM是C++干的，可不是js干的，这一定需要明确。我们先不提解释器，也不提V8 jsbinding等，我们先粗暴的理解，html，css，js翻译成C++语言，然后统一在渲染进程的某一个固定的线程去执行。单线程环境里面不存在插队，大家在个什么位置他就是个什么位置。人家在执行的时候，你就乖乖等着，同样，你执行的时候，别人也坐着没动弹。就便是传说中的 js引擎和渲染线程互斥。 如果对js语言底层的实现以及浏览器的架构模型没有概念的话，是很难理解这句话的意思。 我们结合上面说的，可以粗暴的先理解为，翻译成C++的那部分html，css代码跟翻译成C++的那部分js代码在运行引擎上是互斥的。是不能同时运行的。 为啥，我们想一个页面。html是DOM结构对吧。js可以操作DOM对吧。那这两个必然不能一直执行吧。一起执行遇到冲突听谁的，那不乱套了吗？ html和css能不能一起执行？为什么不能呢？html生成的DOM结构是主体，css生成样式，css就是装修，装修刷墙粉面又不会改变主体，那一起呗。 那css和js能不能一直执行？这个就不能了，因为js能改变css样式啊，那两个一起执行遇到冲突听谁的？ 那问题就清晰了,以下面这段代码为例 123456789&lt;html&gt; &lt;head&gt; &lt;script src=\"index.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;渲染进程&lt;/p&gt; &lt;div&gt;&lt;p&gt;red&lt;/p&gt; &lt;div&gt;green&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 从html标签开始，C++代码开始解析这个html代码字符串生成DOM，到head标签之后碰到一个script标签，这个时候生成DOM的程序就停了。 执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。 不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。 再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。等index.js执行完，这个时候js引擎就停了，就又开始执行生成DOM的程序了。就便是互斥； 另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示： 12&lt;script defer src=\"index.js\"&gt;&lt;/script&gt; &lt;script async src=\"index.js\"&gt;&lt;/script&gt; 这里不得不提到 defer和async，defer是让浏览器别管我，你自己先解析你的DOM吧。我会在你解析完整个页面的时候才执行。那这就很高效了。我的首屏可以不受加载js脚本的影响了； async是异步脚本，就比较自由。加载完了就立即执行，这种脚本必然就不会轮到主渲染线程来执行了。它应该是渲染进程创建出来的其他线程来执行的； 而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。 我们上面提到css和js，这个当然css会阻塞js的执行。chrome表现的要优秀一些，它的机制是，只有当脚本尝试访问样式属性可能尚未加载的样式表影响时，它才会禁止该脚本。 一句话总结就是说，DOM的生成会被js脚本阻塞，css的解析同样有几率阻塞js脚本的执行（当js中存在访问未加载充分的样式表的时候，也就是说js依赖该样式表）。所以CSS优先级是最高的，其次是js，DOM碰到js要等等，当然html css一对好基友彼此不耽误，可以同时解析； 2.1.1.2.3 白屏优化通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 2.1.1.3 布局树构建（layout） 现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。 2.1.1.3.1 创建呈现树就是结合DOM和CSSOM，将需要隐藏的节点，隐藏掉。把每个节点的样式信息写进去。 2.1.1.3.2 布局计算布局计算就是把每个节点的信息计算出来并写到该节点中，比如每个节点的宽高位置，计算每个布局点的节点坐标；这个过程就相对复杂了； 2.1.1.4 分层我们知道CSS代码里面有个z-index,渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）,然后绘制图层 2.1.1.5 绘制（paint） 在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。 全量绘制和增量绘制 和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其children）。 绘制顺序 background color background image border children outline 2.1.1.6 重排（relayout）与重绘（replaint）简单列出渲染流水线的核心步骤 1DOM -&gt; Style -&gt; Layout -&gt; Layer -&gt; Paint 重排就是更新几何属性吧，比如改变了位置，大小，布局等等。重排需要重新走一遍，Layout -&gt; Layer -&gt; Paint 重绘就是改变某些元素的颜色，这样只需要 Paint就行了； 当然你改一个既不会改变布局，又不会改变颜色的属性，那流水线会跳过这些步骤，直接走合成阶段； 1tiles -&gt; raster -&gt; draw quad -&gt; display 2.2 等待更新阶段 等待更新阶段，指的是在创建阶段之后（首次渲染之后）用户可以自由操作页面，页面上也可能自由自由请求服务端，或者服务端定时推送数据给页面做呈现。直到用户使用完之后关掉当前标签页的这个过程。这个阶段同样也可以理解为交互阶段。 这里需要陈述一下，等待更新阶段是杜撰的一个概念，可能在其他资料上面也不会查得到。基于web页面的生命周期，我将其人为割裂为，页面首次显示到浏览器视口中，接下来在用户关闭此标签页的时候，浏览器程序并不是静止不动，而是一直在运行中的，大概是怎么运行的呢？代码大概就像下面这个样子； 123// 这是一个近乎无限的循环。while (!mExiting) NS_ProcessNextEvent(thread); 为了解释清楚这个阶段，我先聊聊显示器和渲染帧； 2.2.1 渲染帧提到帧数，思绪回到十年前，去网吧玩玩魔兽世界的时候。我第一在乎的是机器能达到多少帧？尽管那时候不知道帧数到底是什么意思，但是明白帧数越高越好，而帧数一旦低于多少，说明机器很卡。也会经常听到网吧有人抱歉，“我的机器卡成幻灯片了” 幻灯片有什么特征？幻灯片在切换时候会有一个明显的缓动动画，比如淡入淡出啊 缓动啊之类的。 我们再说显示器，为何显示器能呈现页面啊。首先，显示器是由一个一个很小的晶体管组合而成，每个晶体管是一个像素点，像素点能显示所有不同的颜色。当所有像素点同时点亮的时候，就形成了一幅画面。 结合本能，我们应该知道。决定游戏界面质量的无非是显卡，GPU，显示器这些关键字了； 在显卡中有一块叫做前缓冲区的地方，这里存放着显示器要显示的图像，显示器回按照一定的频率来读取前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是60HZ，也就是说显示器会每间隔1/60秒就读取一次前缓冲区； 为何是60HZ，因为当一个显示器达到60HZ的时候，人眼就很难觉察页面显示器在跳动，而是精致的画面了。那么动画效果将会特别流畅，我们说动画不过就是一张张有差异的图片在高速的切换，这个高速有多高。就是1/60秒次切换一次就可以了。达到这个帧率，足够欺骗人眼了； 接着说GPU，如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的后缓冲区中，提交完成之后，GPU会将缓冲区和前缓冲区交换位置，也就是前缓冲区变成后缓冲区，后缓冲区变成前缓冲区，这就保证了显示器下次能读取到GPU中最新的图片； 这时候我们会发现，显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的； 这种显示器读取图片和浏览器生成图片不同步，容易造成诸多问题， 比如丢帧，或者卡顿。为了解决这个问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来； 当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号给GPU，简称VSync 具体来讲就是，当GPU接收到Vsync信号后，会将该信号同步给浏览器，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到该信号，就可以准备绘制新的一帧； 接下来，我们思考一个问题。我们说一个流畅的页面的最好满足60帧，每帧的时间大概是16.67毫秒。 不知道我们是否还记得页面创建阶段的渲染流水线。 1DOM -&gt; Style -&gt; Layout -&gt; Layer -&gt; Paint 也就是说DOM解析也好，style解析也好。最终都是为了Paint， 那么在交互阶段，当有js脚本改变DOM的时候。页面同样需要重新走一遍Layout 之后的渲染流水线；而且这一遍最好在16.66毫秒之内完成。不然，会跨帧，频繁跨帧的话，那必然导致页面帧数极速下跌，页面将变得卡顿或者丢帧； ok，那既然在16.66毫秒之内完成。那我们来继续盘点一下这16.66毫秒之内都要执行哪些东西呢？ 2.2.2 schedule我们前面说，渲染进程是用一个单线程来执行js脚本和页面绘制的。js引擎和页面绘制单元是互斥的。 那既然是单线程的，这条生产线又有那么多的事情要干。那具体谁先谁后呢？比如用户的event，js引擎的异步代码，web api（比如requestAnimateFrame，requestIdleCallback等等） 解释这张图之前，我先强调一下，前端领域经常提的宏队列 微队列。跟这张图没直接关系啊。这张图是整个浏览器渲染线程做的事情，而宏队列和微队列只是js引擎里面调度，js是单线程的和渲染进程这个单线程不是一码事儿； 说回，这个渲染帧的调度， 首先最高优先级是用户事件； 其次会去检查js引擎中定时器相关的程序，有没有已经到点了的。当然如果该任务中含有micro的任务，也一并执行了 接下来是BOM事件； 再然后是requestAnimationFrame layout paint requestIdleCallback 遇事不决直接上代码 12345678910111213141516171819202122232425262728293031323334353637383940window.requestAnimationFrame(animation);let num = 0;function animation() &#123; if (num &lt; 10) &#123; num++; window.requestAnimationFrame(animation); &#125; console.log(\"requestAnimationFrame\", num); if (num &gt;= 10) &#123; return; &#125;&#125;setTimeout(() =&gt; &#123; console.log(\"setTimeout\"); Promise.resolve().then(() =&gt; &#123; console.log(\"promise----\"); &#125;);&#125;, 0);// eventType &#123;mouseEvent: 鼠标事件，Event： 自定义事件&#125;// eventName 事件名称function imitatEvent(EventType, EventName) &#123; let event = document.createEvent(EventType); event.initEvent(EventName, true, true); return event;&#125;document.addEventListener(\"click\", function () &#123; console.log(2222, event1.type);&#125;);let event1 = imitatEvent(\"MouseEvents\", \"click\");// element2 为任何dom元素document.dispatchEvent(event1);window.requestIdleCallback(() =&gt; &#123; console.log(\"requestIdleCallback\");&#125;); 当然细心的小朋友会发现，有的时候，requestAnimationFrame会跑到setTimout之前，有的时候 requestIdleCallback会执行的更加靠后； 首先，rAf的执行时机是尽可能的接近帧头。而setTimeout虽然给定了一个0毫秒，但还是取决于当时轮训消息队列的时候，是否有取到这个任务，有取到就有机会执行，没取到就先执行rAf了。再说rIC，rIC的执行时机尽可能放在每一帧的末尾去执行。当然前提是该帧有空余时间，没有空余时间也不行。如果什么时候那一帧有空闲，就有机会执行了。 好了，到这里我们知道每个渲染帧在干着哪些事情了。 我们再review一下这些阶段，我们发现我们不能在rAf里面做复杂计算，这种每一帧都需要执行的函数，如果回调过于复杂，那带来的结果就是一些耗时长的任务会横穿一个或多个帧，导致掉帧，页面卡顿； 这里提一嘴react fiber架构，react fiber架构解决什么问题？ 为什么需要重构到react fiber架构，为什么react15的架构不能满足需求了； 这是因为 react 在更新的时候需要做diff运算，react的diff是从根节点diff的。这种diff的运算量大，长时间占据渲染帧。导致性能瓶颈。 后期react fiber架构的出现，主要解决两个问题，首先引进了链表式的数据结构，可以随时存储当前diff的状态，这就解决了单次diff长期占据渲染帧的问题，其次，让每个fiber节点的运算时机尽量在帧尾做，避开渲染帧的正常渲染周期。这样就在维持页面性能的同时，也给足了react节点的计算时间；总体而言，fiber更加的细粒度化了；对资源的使用也更加细粒度化了； 2.3 消亡阶段 消亡阶段很好理解，就是点击浏览器标签页的关闭按钮，或者在任务管理器中选择某个页面渲染进程，点右下角的结束进程按钮；当执行这些操作之后，浏览器通过操作系统释放相关渲染进程的所有资源； 3. 浏览器中的V8引擎通过上面的阐述，我们大概知道了js引擎在整个浏览器渲染进程中的位置。它的使命和它的能力范围； 3.1 单线程的js是如何实现异步的首先，灵魂拷问，什么是异步？ 在计算机系统中，有一些任务一旦执行，比如socket编程。鬼都不晓得啥时候能执行完。所以我不能一直死等着吧。 那我能不能先干点别的事儿。好在，计算机系统设计的足够健壮。支持多任务并行； 表现在实际编程中就是——多线程编程。当一个socket请求进来，要求去读取数据库10万条数据，那我当前进程环境中，创建一个子线程（更高级一点，我会在进程中维护一个线程池。如果有空闲线程，我会让空闲的线程去承接时间未知的IO任务。如果没有空闲，再新建不迟。当然这个线程池上限还取决于硬件环境以及，当前和数据库那边的连接情况来设定，并不是随便给的一个值。），用来处理这条请求，并注册一个回调，如果你10万条数据拿到手了，你告诉我一声。 然后主进程接着迎接下一个socket请求。 这个时候10万条好了，主线程拿着10万条数据，然后告诉该子线程去线程池候命。自己唤醒当初客户端connection对象，然后将字节写入该connction。此时，如无后续连接进来，free掉该connection。 在上面这个事例中，多线程模型就是对异步支持的一种具体表现。用线程池的设计思路去解决IO任务耗时不稳定的问题； 那我们js引擎怎么弄呢？众所周知，js是单线程的。单线程怎么支持异步呢。 那就是第二种方案了 进入队列排队 在一个单线程环境调度，本来就不是一件容易的事情。 js引擎将 js代码人为分成拆分成不同的任务 3.1.1 script首先，每个script标签包裹的是一个任务, 当解析到script标签的时候，js引擎会将两个script包裹的代码依次放入队列当中； 123456789101112131415161718&lt;script&gt; setTimeout(() =&gt; &#123; console.log(\"1\"); Promise.resolve().then(() =&gt; &#123; console.log(\"promise1\"); &#125;); &#125;, 0); console.log(\"script1\"); &lt;/script&gt; &lt;script&gt; setTimeout(() =&gt; &#123; console.log(\"2\"); Promise.resolve().then(() =&gt; &#123; console.log(\"promise2\"); &#125;); &#125;, 0); console.log(\"script2\"); &lt;/script&gt; 然后在另一端 123while(isHasTask) &#123; next = queue.pop() &amp;&amp; next()&#125; 这个死循环会一直试图从队列中读取任务，然后执行。直到队列中所有任务执行殆尽，然后挂起出让调度器等待。 123456script1script2 1promise1 2promise2 上面代码执行出这个结果，我们得出结论，除了script标签，setTimeout这种定时器代码也会被当作一个任务放在队列当中。然后Promise这种微任务会在当前任务执行完毕并释放之前全部执行完毕。 为什么有了任务队列，还要弄个微任务呢。这其实是调度器的一个取舍问题。简单说 就是任务队列颗粒度太大了。 3.1.2 其他宏任务 渲染事件（如解析 DOM、计算布局、绘制）； 用户交互事件（如鼠标点击、滚动页面、放大缩小等）； JavaScript 脚本执行事件； 网络请求完成、文件读写完成事件。 3.1.3 其他微任务第一种方式是使用 MutationObserver 监控某个 DOM 节点 3.2 任务队列与阻塞直接上代码 12345678 &lt;button onclick=\"console.log('click me')\"&gt;click me&lt;/button&gt; &lt;script&gt; function loop() &#123; Promise.resolve().then(loop); &#125; loop(); &lt;/script&gt;&lt;/body&gt; 我们发现，button点击无效。页面一直转圈状态卡死 12345678&lt;button onclick=\"console.log('click me')\"&gt;click me&lt;/button&gt; &lt;script&gt; function loop() &#123; setTimeout(loop, 0); &#125; loop(); &lt;/script&gt;&lt;/body&gt; 跟上面代码类似，但是button点击依然可以输出click me； 12345678&lt;button onclick=\"console.log('click me')\"&gt;click me&lt;/button&gt; &lt;script&gt; function loop() &#123; loop() &#125; loop(); &lt;/script&gt; &lt;/body&gt; 迅速栈溢出； 分别来陈述一下原因； 首先，说最后一个同步操作，这个很好理解。大部分编程语言的内存模型都存在堆栈结构，栈上存放着函数作用域的执行语句。这个栈虽然足够深，但也不是深到无限。一次同步任务会一次性在一个栈空间的生命周期执行到结束。当执行结束后，栈被回收，操作系统释放栈上内存。直到任务队列下一个任务拿出来，才重新将其函数语句拉入栈中来计算。这个loop函数属于一个任务。所以，栈空间没理由中途释放。那无限递增必然造成栈溢出。 说中间这个setTimeout，setTimeout会创建一个新任务，当前任务执行完毕之后，栈空间会被释放。所以，这段代码虽然很蠢。但并不是错误代码。早年前，很多人用这种方式做动画。它做动画的坏处在于定时器的间隔无法根渲染帧同步。所以效果肯定不如每一帧都会执行的rAf。 setTimeout的诸多问题 1234567891011function bar() &#123; console.log('bar')&#125;function foo() &#123; setTimeout(bar, 0); for (let i = 0; i &lt; 5000; i++) &#123; let i = 5+8+8+8 console.log(i) &#125;&#125;foo() 如果当前任务执行时间过久，会影响延迟到期定时器任务的执行 在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒 12345678static const int kMaxTimerNestingLevel = 5; // Chromium uses a minimum timer interval of 4ms. We'd like to go// lower; however, there are poorly coded websites out there which do// create CPU-spinning loops. Using 4ms prevents the CPU from// spinning too busily and provides a balance between CPU spinning and// the smallest possible interval timer.static constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4); 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒 如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。 延时执行时间有最大值 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。 1setTimeout(showName,2147483648);// 会被理解立即调用执行 最后说Promise，为什么会卡死。是因为Promise产生的是当前任务的微任务，这里强调一个重点是，微任务和宏任务一样，不会公共栈的同一个生命周期。什么意思呢？就是说，当前一个微任务回调执行完了，会释放栈空间，然后再从栈中取任务拉过来执行；届时又是一个全新的栈环境。所以，当前这个宏任务被永远夯住。任务队列的其他任务，任何优先级很高的 user events都休想执行。 所以，这也是为什么微任务会像同步函数一样 有阻塞线程的能力； 说到阻塞，我们需要明晰一个知识细节。js引擎的阻塞 根操作系统维度上的阻塞差不多是一码事儿。 操作系统的阻塞，只是某个线程阻塞， 123select &#123; &#125; 比如上面这句代码，它阻塞了当前线程。但是这并不影响进程内其他线程的运行。kernel会将当前阻塞的线程挂起。在调度的时候也不会想起他； 而在js环境中的阻塞，比如下面这段代码 123456&lt;body&gt; &lt;script&gt; while (true) &#123;&#125; &lt;/script&gt; &lt;button onclick=\"console.log('click me')\"&gt;click me&lt;/button&gt;&lt;/body&gt; 我们发现界面的button都渲染不出来，页面也一直在无限加载。其实这也是一种挂起。也能从侧面渲染线程和js的执行确实是在一个单线程的环境中的。 4. 浏览器缓存4.1 HTTP缓存 减少不必要的网络传输，缓解服务器压力 4.1.1 强缓存 不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache（存放在硬盘中）和 Memory Cache（存放在内存中），存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。 ExpiresExpires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。 Cache-ControlCache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有： max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效 no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜 no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源 private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应 public：响应可以被中间代理、CDN 等缓存 must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证 PragmaPragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。 本地通过 express 起一个服务来验证强缓存的 3 个属性，代码如下： 123456789const express = require('express');const app = express();var options = &#123; etag: false, // 禁用协商缓存 lastModified: false, // 禁用协商缓存 setHeaders: (res, path, stat) =&gt; &#123; res.set('Cache-Control', 'max-age=10'); // 强缓存超时时间为10秒 &#125;,&#125;;app.use(express.static((__dirname +'/public'), options));app.listen(3000); 第一次加载，页面会向服务器请求数据，并在 Response Header 中添加 Cache-Control ，过期时间为 10 秒。 第二次加载，Date 头属性未更新，可以看到浏览器直接使用了强缓存，实际没有发送请求。 过了 10 秒的超时时间之后，再次请求资源： 当 Pragma 和 Cache-Control 同时存在的时候，Pragma 的优先级高于 Cache-Control。 4.1.2 协商缓存当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。 ETag/If-None-MatchETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash 码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。 Last-Modified/If-Modified-SinceLast-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。 本地通过 express 起一个服务来验证协商缓存，代码如下： 12345678910111213const express = require('express');const app = express();var options = &#123; etag: true, // 开启协商缓存 lastModified: true, // 开启协商缓存 setHeaders: (res, path, stat) =&gt; &#123; // 浏览器不走强缓存 res.set(&#123;'Cache-Control':'max-age=00', 'Pragma': 'no-cache', // 浏览器不走强缓存 &#125;); &#125;,&#125;;app.use(express.static((__dirname + '/public'), options));app.listen(3001); 第一次请求资源: 第二次请求资源，服务端根据请求头中的 If-Modified-Since 和 If-None-Match 验证文件是否修改。 我们再来验证一下 ETag 在强校验的情况下，只增加一行空格，hash 值如何变化，在代码中，我采用的是对文件进行 MD5 加密来计算其 hash 值。 注：只是为了演示用，实际计算不是通过 MD5 加密的，Apache 默认通过 FileEtag 中 FileEtag INode Mtime Size 的配置自动生成 ETag，用户可以通过自定义的方式来修改文件生成 ETag 的方式。 为了保证 lastModified 不影响缓存，我把通过 Last-Modified/If-Modified-Since 请求头删除了，源码如下： 123456789101112131415161718const express = require('express');const CryptoJS = require('crypto-js/crypto-js');const fs = require('fs');const app = express();var options = &#123; etag: true, // 只通过Etag来判断 lastModified: false, // 关闭另一种协商缓存 setHeaders: (res, path, stat) =&gt; &#123; const data = fs.readFileSync(path, 'utf-8'); // 读取文件 const hash = CryptoJS.MD5((JSON.stringify(data))); // MD5加密 res.set(&#123;'Cache-Control': 'max-age=00', // 浏览器不走强缓存 'Pragma': 'no-cache', // 浏览器不走强缓存 'ETag': hash, // 手动设置Etag值为MD5加密后的hash值 &#125;); &#125;,&#125;;app.use(express.static((__dirname + '/public'), options));app.listen(4000); // 使用新端口号，否则上面验证的协商缓存会一直存在 第一次和第二次请求如下： 然后我修改了 test.js ，增加一个空格后再删除一个空格，保持文件内容不变，但文件的修改时间改变，发起第三次请求，由于我生成 ETag 的方式是通过对文件内容进行 MD5 加密生成，所以虽然修改时间变化了，但请求依然返回了 304，读取浏览器缓存。 ETag/If-None-Match 的出现主要解决了 Last-Modified/If-Modified-Since 所解决不了的问题： 如果文件的修改频率在秒级以下，Last-Modified/If-Modified-Since 会错误地返回 304 如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304，上面的例子就说明了这个问题 在实际使用场景中，图片、不常变化的 JS 等静态资源都会使用缓存来提高页面的加载速度 4.2 浏览器缓存浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？ from disk cache和from memory cacheChrome的网络请求的Size会出现三种情况from disk cache(磁盘缓存)、from memory cache(内存缓存)、以及资源大小数值。 浏览器读取缓存的顺序为memory –&gt; disk。 以访问https://github.com/xiangxingchen/blog为例 我们第一次访问时https://github.com/xiangxingchen/blog 关闭标签页，再此打开https://github.com/xiangxingchen/blog时 F5刷新时 简单的对比一下 浏览器可以在内存、硬盘中开辟一个空间用于保存请求资源副本。我们经常调试时在 DevTools Network 里看到 Memory Cache（內存缓存）和 Disk Cache（硬盘缓存），指的就是缓存所在的位置。请求一个资源时，会按照优先级（Service Worker -&gt; Memory Cache -&gt; Disk Cache -&gt; Push Cache）依次查找缓存，如果命中则使用缓存，否则发起请求。这里先介绍 Memory Cache 和 Disk Cache。 200 from memory cache 表示不访问服务器，直接从内存中读取缓存。因为缓存的资源保存在内存中，所以读取速度较快，但是关闭进程后，缓存资源也会随之销毁，一般来说，系统不会给内存分配较大的容量，因此内存缓存一般用于存储较小文件。同时内存缓存在有时效性要求的场景下也很有用（比如浏览器的隐私模式）。 200 from disk cache 表示不访问服务器，直接从硬盘中读取缓存。与内存相比，硬盘的读取速度相对较慢，但硬盘缓存持续的时间更长，关闭进程之后，缓存的资源仍然存在。由于硬盘的容量较大，因此一般用于存储大文件。 下图可清晰看出差别： 200 from prefetch cache 在 preload 或 prefetch 的资源加载时，两者也是均存储在 http cache，当资源加载完成后，如果资源是可以被缓存的，那么其被存储在 http cache 中等待后续使用；如果资源不可被缓存，那么其在被使用前均存储在 memory cache。 CDN Cache 以腾讯 CDN 为例：X-Cache-Lookup:Hit From MemCache 表示命中 CDN 节点的内存；X-Cache-Lookup:Hit From Disktank 表示命中 CDN 节点的磁盘；X-Cache-Lookup:Hit From Upstream 表示没有命中 CDN。 4.3 http1，http2，http3概述 转载 为了更好理解文章，需要解释一下什么是RTT？ RTT是Round Trip Time的缩写，通俗地说，就是通信一来一回的时间。 TCP建立连接时间 最早大家使用TCP来运输HTTP，TCP想必大家很熟悉了，需要三次握手，建立了TCP虚拟通道，那么这三次握手需要几个RTT时间呢？ 一去 （SYN） 二回 （SYN+ACK） 三去 （ACK） 相当于一个半来回，故TCP连接的时间 = 1.5 RTT 。 HTTP交易时间 这意味着，用户在浏览器里输入的网址URL，直到时间流逝了1.5RTT之后，TCP才开始运输HTTP Request，浏览器收到服务器的HTTP Response，又要等待的时间为： 一去（HTTP Request） 二回 （HTTP Responses） 故HTTP的交易时间 = 1 RTT 那么基于TCP传输的HTTP通信，一共花费的时间总和： HTTP通信时间总和 = TCP连接时间 + HTTP交易时间 = 1.5 RTT + 1 RTT = 2.5 RTT 安全加密通信 随着互联网的爆发式增长，人类发现完全明文传输的HTTP通信很不安全。做为OSI七层参考模型的现实实现的TCP/IP协议，在设计之初没有考虑安全加密的环节。 互联网先驱Netscape公司，创造性发明了SSL（Secure Socket Layer），SSL位于TCP与HTTP之间，做为HTTP的安全供应商，全权负责HTTP的安全加密工作。 IP / TCP / SSL / [HTTP] 各个通信模块之间的站位如上所示，将HTTP用[ ]括起来，表示HTTP被SSL安全加密了。 随着SSL的名气攀升，互联网标准化组织IETF，觉得SSL是一个好东西，就拿来用了。 但SSL最初只是用于加密HTTP的，IETF觉得这是一个硬伤，为什么不能用来做为所有应用层协议的安全供应商呢？来传输邮件、文件、新闻等等。实现这一点很简单，只要在协议里增加一个Application Protocol 类型字段。 在Application Protocol 有一个类型是“IP”, 意味着TLS不仅可以运输应用层协议如HTTP、FTP，还可以运输IP，这就是Cisco Any Connect的应用场景。 TLS (Transport Layer Security) 于是，IETF在SSL 3.0版本的基础上，重新设计并命名了这个协议，其全新的名字为TLS，最初的版本为1.0版本。从其名字就可以看出，其核心使命就是保证传输层的安全。各个通信部门成员的占位与SSL占位一致： IP / TCP / TLS / [HTTP] 到目前为止，浏览器支持的TLS版本为TLS 1.0、1.1、1.2，当然版本越高越成熟、越安全。 HTTPS 通常将TLS安全保护的HTTP通信，称之为HTTPS，以区别于没有TLS安全防护的HTTP明文通信。 交待了上文的背景知识，还是要回到本文的主题，来看看自从引入了TLS安全防护，看看HTTPS通信的RTT增加到了多少？ TLS 1.2 以1.2 版本为例，看看HTTPS通信一共要消耗几个RTT时间？ \\1. 浏览器给服务器发送的Client Hello消息（一去） 首长好，我支持1.2版本，加密套件列表1、2、3…，以及我的随机码N1，请出示您的证件。 \\2. 服务器给浏览器发送的Server Hello消息（二回） 同志们好，那就1.2版本通信吧，加密套件我选用1，我的随机码N2，ECDHE密钥交换素材2，这是我的证件。 同志们辛苦了！ \\3. 浏览器给服务器发送的Key Exchange消息（三去） 为人民服务！ 嘴里虽这么说着，私下还要偷偷验证首长的证件是否伪造的。 首长证书验证成功之后，还要给首长会话呢？会话内容如下： 首长辛苦了！ 我的ECDHE密钥交换素材1，接下来我发给您的消息都要加密了（Change Spec）。 从这以后，双方的HTTP通信将使用TLS加密了。一共花费了1.5个RTT时间。 让我们来计算一下整个HTTPS通信花费的时间总和： HTTPS通信时间总和 = TCP连接时间 + TLS 连接时间 + HTTP交易时间 = 1.5 RTT + 1.5 RTT + 1 RTT = 4 RTT 如果浏览器与服务器物理距离很近，RTT &lt; 10 ms，即使4 RTT最大也不过40 ms的时间，用户压根感觉不到慢。 如果浏览器与服务器相隔上万公里，一个RTT时间通常在200ms以上，4RTT时间通常在1秒以上，用户会明显感觉到网速慢了。 HTTP 1.x 和很多人想象不一样的是，浏览器从服务器获取的一个页面，通常由很多资源链接所组成。 服务器给浏览器推送的第一个页面，页面里通常嵌入了图片资源文本链接、以及动态页面资源链接、或第三方网站的链接资源，还需要浏览器根据这些文本链接内容，去链接所对应的服务器，继续下载链接所对应的内容。 浏览器通常采用的流程是，重新建立一个TCP连接、TLS连接、HTTP交易。 这又是一个漫长的4RTT等待过程，用户看到浏览器完整页面的时间为 完整页面加载时间 = 4RTT *2 = 8RTT HTTP /2 自然有人会问，既然第一次页面与第二次页面都是同一个网站服务器，为何第二次页面要重新建立一个TCP连接，一个TLS连接？ 如果重用第一个TCP连接，那么就少了1.5 RTT + 1.5 RTT = 3 RTT的时间。 这是一个好主意，就是用户的多个HTTP Request请求，使用同一个逻辑通道进行运输，这样会大大减少重新建立连接所花费的时间。 但是，这样会带来一个副作用，多个HTTP流使用同一个TCP连接，遵守同一个流量状态控制。只要第一个HTTP流遭遇到拥塞，剩下的HTTP流压根没法发出去，这就是头部阻塞（Head of line Blocking）。 既然TCP不好用，那为何要吊死在TCP这一棵树上呢？ 外面的世界很精彩，到外面的世界逛逛。 QUIC（Quick UDP Internet Connection） 逛下来的感受是，UDP不需要连接，不会带来附加的RTT时间，UDP是一个好的合伙人被HTTP /2拉上了贼船，各合伙人的占位如下： IP / UDP / QUIC 这个就是Google开发QUIC协议，QUIC协议集成了TCP可靠传输机制、TLS安全加密、HTTP /2 流量复用技术，其页面的加载时间为2.5 RTT时间。 此外，完成QUIC交易的连接的Session ID会缓存在浏览器内存里，如果用户再次打开该页面，无需建立TLS连接，直接使用缓存Session ID 对应的加密参数，服务器可以根据Session ID在缓存里查找对应的加密参数，并完成加密。 换句话说，重连TLS连接是一个0 RTT 事件，用户所要等待的页面加载事件 = HTTP交易事件 = 1 RTT。 HTTP /3 这一次IETF又觉得QUIC是一个好东西，但是希望QUIC不仅可以运输HTTP，还可以运输其它协议，把QUIC与HTTP分离，最终各合伙人的占位如下所示： IP / UDP / QUIC / HTTP 这样整体的页面加载时间为2 RTT。 TLS 1.3 IETF的QUIC标准集成了TLS 1.3版本，1.3版本更简练，建立TLS连接不再需要1.5 RTT，而只需要1 RTT，是因为浏览器第一次就把自己的密钥交换的素材发给服务器，这样就节省了第三次消息，少了0.5个RTT时间。 页面的整体加载时间 = TLS 1.3连接时间 + HTTP交易时间 = 1RTT + 1RTT = 2 RTT 重连页面的加载时间 = HTTP交易时间 = 1 RTT 上文协议的进化过程就是人类与RTT斗争史，目标是减少用户等待页面加载时间、同时保证用户看到的页面安全，没有在传输过程中被偷窥、篡改。 HTTP /3所带来的挑战 99%+以上的手机移动终端、电脑终端，都使用私有IP，都需要NAT设备来完成私有IP与全球IP的转换。这意味着NAT设备通常会记忆用户的通信状态，一旦用户完成了通信，NAT设备会释放这些记忆。 对于基于TCP的HTTP、HTTPS传输，NAT设备可以根据TCP报文头的SYN / FIN状态位，知道通信什么时候开始，什么时候结束，对应记忆的开始、记忆的结束。 但是基于UDP传输的HTTP/3，NAT设备收到流量会知道连接什么时候开始，但是却无法知道流量什么时候结束。 NAT设备的记忆如果短于用户会话时间，则用户会话会中断。 NAT设备的记忆如果大大长于用户会话时间，则意味着NAT设备的端口资源会白白被占用！ 最直接的解决方案是，在QUIC的头部模仿TCP的SYN/FIN状态，让沿途的NAT设备知道会话什么时候开始、什么时候结束。但这需要升级全球所有的NAT设备的软件！ 另外一个可行的方案是，让QUIC周期性地发送Keepalive消息，刷新NAT设备的记忆，避免NAT设备释放自己的记忆 为何HTTP/3不直接站在IP身上，而是站在UDP身上？ 可以少8个字节的UDP头部开销不是很好嘛？ 上文已经说了，全球的通信终端绝大多数位于NAT的身后，地球上任何NAT产品都支持TCP/UDP运输的货物，即可以根据端口号来识别不同的终端、不同终端的会话。 如果QUIC站在IP身上，如下所示： IP /QUIC / HTTP QUIC并没有端口号，意味着每一个NAT设备只能记忆一个终端的会话，一个全球IP 与一个私有IP的一一映射。 那将意味着NAT设备后只能有一个会话可以访问同一个服务器的页面，这肯定是无法接受的！ 5. 浏览器中的网络8. 浏览器中的V8 在V8出现之前，所有js虚拟机所采用的都是解释执行的方式，这是js执行速度过慢的一个主要原因，而V8率先引入即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给js的执行速度带来的极大的提升； 另外，V8也早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制；进一步优化了js代码的编译执行效率； 8.1 了解V8的意义单纯的使用js和调用web API，并不了解虚拟机内部是怎么工作的，在项目中遇到的很多问题都可能找不到解决的途径。 比如，有时候项目的占用内存过高，或者页面响应速度过慢，又或者使用Nodejs的时候导致任务被阻塞等问题，都与V8的基本运行机制有关，如果你熟悉V8的工作机制，就会有系统性的思路来解决这些问题； 8.2 V8编译流水线概览V8执行js代码的完整流程（V8的编译流水线） 编译流水线本身并不复杂，但是其中涉及到了很多技术，JIT，延迟解析，隐藏类，内联缓存等等。这些技术决定一段js代码能否正常执行，以及代码的执行效率； V8使用的隐藏类（Hide Class），这是将JS中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行过慢的问题，熟悉V8这一机制之后，在你编写js时，就能充分利用好隐藏类这种强大的优化特性，写出更高效的代码； V8实现了代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，你可以优化你的代码更加适应这个机制，从而提供程序性能； 另外两个非常重要的特性需要了解，事件循环系统 和 垃圾回收机制 事件循环系统和js中的难点——异步编程特性紧密相关，js是单线程的，js代码都是在一个线程上执行，如果同一时间发送了多个js执行的请求，就需要排队，也就是进行异步编程； V8事件循环系统会调度这些排队任务，保证js代码被V8有序的执行，因此也可以说，事件循环系统就是V8的心脏，它驱动了V8持续工作； js是一种自动垃圾回收的语言，V8在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，也是我们经常会遇到一个问题，你需要知道V8是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完成的系统，当下次遇到内存问题的，就知道如何去排查了； 8.3 V8是如何执行一段js代码 其主要核心流程分为编译和执行两步，首先需要将js代码转换为低级中间代码或机器码，然后执行转换后的代码并输出结果； 可以将V8看成是一个虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的CPU，堆栈、寄存器等，虚拟机还具有它自己的一套指令系统； 对于js来说，V8就是它的一切，当V8执行js时，开发者并不需要担心不同os之间的差异，也不需要担心不同体系结构计算机的差异，你只需要按照虚拟机的规范写好代码就可以了； 8.3.1 计算机语言 CPU是如何执行机器代码的，你可以把CPU看成是一个非常小的运算机器，开发者可以通过二进制的指令和CPU进行沟通，当处理器执行到某条指令时，便会按照指令的意思去实现相关的操作； 为了能够完成复杂的任务，工程师为CPU提供了一大推指令，来实现各种功能，我们就把这一大堆指令称为指令集（instructions），也就是机器语言； 8.3.1.1 汇编cpu只能识别二进制指令，但是对程序员来说，二进制代码难以阅读记忆，于是，先驱又将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令集； 121000100111011000 # 机器指令mov ax,bx. # 汇编指令 CPU并不能直接识别一段汇编程序，还需要一个汇编编译器，其作用是将汇编代码编程成机器代码； 虽然汇编语言对机器语言做了一层抽象，减少了程序员理解机器语言的复杂度，但是汇编语言依然是复杂且繁琐的，即便你写了一个简单的功能，也需要大量的汇编代码，主要原因在于 首先，不同cpu有着不同的指令集，如果开发者要使用机器代码或者汇编语言来实现一个功能，需要为每种架构的CPU编写特定的汇编代码； 其次，在编写汇编代码时，还需要了解和处理器架构相关的硬件知识，比如需要使用寄存器，内存，操作CPU等；大部分程序员在编写应用的时候，只想专心处理业务逻辑，并不想要过多理会这些处理器架构相关的细节；因此需要一种屏蔽计算机架构细节的语言，能够适应多种不同CPU架构的语言，能专心处理业务逻辑的语言，如C/C++，java，js等多种“高等语言”； 和汇编语言一样，处理器不能直接识别由高级语言所编写的代码，通常，要用两种方式来执行这些代码； 解释执行 和 编译执行 8.3.1.2 解释执行 解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果； 8.3.1.3 编译执行 编译执行，也需要先将源代码转换为中间代码，然后编译器再将中间代码编译成机器代码，通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了，还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码； 8.3.1.4 总结以上就是计算机执行高级语言的两种基本方式： 解释执行和编译执行。针对不同的高级语言，这个实现方式还是有很大差异的，比如要执行C语言编写的代码，需要将其编译成二进制代码的文件；然后直接执行二进制文件，而对于像java/js 语言等，则需要不同虚拟机，模拟计算机的这个编译执行流程，执行java语言，需要经过java虚拟机的转换，执行js需要经过js虚拟机的转换； 8.3.2 V8执行javascript代码 实际上，V8并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为JIT（Just In Time）技术 这是一种权衡策略，因为这两种方法都有各自的优缺点，解释执行启动速度快，但是执行速度慢，而编译执行启动速度慢，但是执行时的速度快。 在V8启动执行js之前，它还需要准备执行js是所需要的一些基础环境； 基础环境准备之后，接下来就可以向V8提交要执行的js代码了；这时候的js代码对于V8来说只是一堆字符串，V8需要先结构化它；也就是生成AST，在生成AST的同时，V8还会生成相关的作用域；有了AST和作用域之后，接下来就可以生成字节码了； 生成字节码之后，解释器就登场了，它会按照顺序解释执行字节码，并输出执行结果； 8.3.2.1 运行时(基础环境) 在V8启动执行js之前，它还需要准备执行js时所需要的一些基础环境，这些基础环境包括了“堆空间”，“栈空间”， “全局执行上下文”，“全局作用域”，“消息循环系统”，“内置函数”等，这些内容都是在执行js过程中需要使用到的；准备好运行时环境之后，V8才可以执行js代码，这包括解析源码，生成字节码，解释执行或者编译执行等一系列操作； js全局执行上下文就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息； 全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中； V8采用经典的堆栈的管理内存管理模式，所以V8还需要初始化内存中的堆栈结构； V8系统活起来，还需要初始化消息循环系统，消息循环系统包含了消息驱动器和消息队列，它如同V8的心脏，不断接受消息并决策如何处理消息； 对运行时足够理解，能够帮助我们更好理解V8的执行流程，比如事件循环系统可以让你清楚各种回调函数是怎么被执行的，栈空间可以让你了解函数是怎么被调用的，堆空间和栈空间让你了解为什么要有传值和传引用，等等； 宿主环境宿主是指为寄生物提供生存环境的生物，V8和浏览器的渲染进程就是 寄生物和宿主细胞的关系，浏览器为V8提供基础的消息循环系统，全局变量，web API，而V8的核心是实现了ECMAScript标准；这相当于病毒自己的DNA，V8只提供了ECMAScript定义的一些对象和一些核心的函数，还包括了Object，Function，String，除此之外，V8还提供了垃圾回收器、协程等基础内容，不过这些功能依然需要宿主环境的配合才能完整执行； 如果V8使用不当，比如不规范的代码触发了频繁的垃圾回收，或者某个函数执行时间过久，这些都会占用宿主环境的主线程，从而影响到程序的执行效率，甚至导致宿主环境的卡死； 同样，除了浏览器，Nodejs也算是V8的宿主环境之一，它提供了不同的宿主对象和宿主的API，但是整个流程依然是相同的，比如Node.js也会提供一套消息循环系统，也会提供一个运行时的主线程； Ok,我们知道，要执行V8，则需要有一个宿主环境，宿主环境可以是浏览器中的渲染进程，可以是Nodejs进程，也可以是其他的定制开发的环境，而这些宿主则提供了很多V8执行js时所需的基础功能部件；比如 构造数据存储空间：堆栈V8是寄生在浏览器或者Nodejs这些宿主中的，V8也是被这些宿主启动的，在Chrome中，只要打开了一个渲染进程，渲染进程便会初始化V8，同时初始化堆空间和栈空间； 栈空间主要是用来管理js函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略，在函数调用过程中，涉及到上下文相关的内容都会存放栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this值等都会存在在栈上，当一个函数执行结束，那么该函数的执行上下文便会被销毁掉； 栈空间的最大特点是空间连续，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8对栈空间的大小做了限制，如果函数调用层过深，那么V8就有可能抛出栈溢出的错误，比如 12345function factorial(n) &#123; if (n==1) return -1 return n*factorial(n-1)&#125;factorial(50000) // maximum call stack size exceeded 如果有一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，使用栈空间就显得不合适了，而且栈上分配的数据过大，也会导致栈溢出，基于栈不方便存储大的数据，所以有了堆空间； 堆空间是一种树形存储结构，用来存储对象类型的离散的数据，存放在堆空间中的数据是不要求连续存放的，从堆上分配内存没有固定模式的，可以在任何时候分配和释放它。js中除了原生类型的数据，其他的都是对象类型，诸如函数，数组，在浏览器中还有window对象，document对象都是存在堆空间的； 另外 12int *z = new int;Point *pp = new Point() 诸如 new int, new Point这些语句，当执行这些语句时，表示要在堆中分配一块内存，然后返回指针，通常返回的指针会被保存到栈中， 如上图，当使用new时，会在堆中分配一块空间，在堆中分配空间之后，会返回分配后的地址，我们会把改地址保存在栈中，如上图中p和pp都是地址，它们保存在栈中，指向了在堆中分配的空间；当栈中的函数调用执行完毕，栈中的指针地址 也被清理掉了；因此c语言中函数返回指针地址的操作，通常都是不合法的。而且在函数执行完毕之后，没有及时 free掉堆上数据的话，那么造成的影响就是内存泄漏了； 宿主在启动V8的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中； （这里会有一个问题，这个堆栈空间到底是V8创建的还是宿主环境（浏览器渲染进程）创建的？其实这个问题不用太过纠结，因为v8和宿主同在一个进程，那必然是共用一套内存空间，通常在启动V8过程中，宿主会创建好堆栈空间，在V8里面叫solate，然后V8利用创建好的堆和栈） 为什么使用栈结构来管理函数调用 大部分高级语言都不约而同地采用栈这种结构来管理函数调用 函数通常有两个主要特征 函数可以被调用，你可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制权将从父函数转移到子函数，子函数执行结束之后，又会将代码执行控制权返还给父函数； 函数具有作用域机制，所谓作用域机制，是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量我们称为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁； 123456789101112int getZ()&#123; return 4;&#125;int add(int x, int y) &#123; int z = getZ(); return x+y+z;&#125;int main()&#123; int x = 5; int y = 6; int ret = add(x,y);&#125; 当main函数调用add函数时，需要将代码执行控制权给add； add函数又调用了getZ函数，于是又将代码控制权交给getZ函数； 接下来getZ执行完毕，需要将控制权返回给add函数； 同样当add函数执行结束之后，需要将控制权返还给main函数； 然后main函数继续向下执行； 函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者的生命周期结束（先出） 站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数（后进），而函数资源的释放则总是先于调用函数（先出） 栈如何管理函数调用 如图所示，函数在执行过程中，其内部的临时变量会按照执行顺序被压入到栈中的 当执行到add函数时，会先把num1和num2压栈，接着再把x，y，ret的值依次压栈，但是当add函数执行完毕之后，需要将执行代码的控制权转交给main函数，这意味着需要将栈的状态恢复到main函数上次执行时的状态，我们将这个过程叫做恢复现场，那么应该怎么恢复main函数的执行现场呢？ 答案是，在寄存器中保存一个永远指向当前栈顶的指针，栈顶指针的作用就是告诉你应该往哪个位置添加新元素，这个指针通常存放在esp寄存器中。然后增删元素都要实时将地址值更新esp寄存器中的这个值，恢复现场，只需要将栈顶指针向下移动就可以了 如上图所示，从100000f97 -&gt; 100000f92就可以了； 但问题是，我怎么知道要移动到 f92，而不是f90或者其他什么位置；解决这个问题的操作是，CPU增加了一个ebp寄存器保存当前函数的开始位置；我们把一个函数的起始位置也称为栈帧指针； 如上图所示，在main函数调用add函数的时候，main函数的栈顶指针 100000f93就变成了add函数的栈帧指针（ebp）了，所以需要将main函数的栈顶指针保存到ebp中， 当add函数执行结束之后，我需要销毁add函数的栈帧，并恢复main函数的栈帧，那么只需要取出main函数的栈顶指针写到esp中即可（main函数的栈顶指针是保存在ebp中的），这就相当于将栈顶指针移动到main函数的区域； 那main函数的ebp中的值写到esp了。那main函数的ebp怎么处理？ 通常的做法是，CPU在调用add函数时，会将当前main函数的栈帧指针保存在栈中； 当函数调用结束之后，就需要恢复main函数的执行现场了，首先取出ebp中的指针，写入esp中，然后从栈中取出之前保留的main的栈帧地址，将其写入ebp中，到了这里ebp和exp就都恢复了，可以继续执行main函数了； 栈帧 每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数返回地址和局部变量，如果调用一个新函数，那么V8会为该函数创建栈帧，等函数执行结束之后，销毁该栈帧，而帧结构的容量是固定的，所有如果重复嵌套执行一个函数，那么就会导致栈会栈溢出； 全局执行上下文和全局作用域V8初始化了基础的存储空间之后，接下来就需要初始化全局执行上下文和全局作用域了。这两个内容是V8执行后续流程的基础； 当V8开始执行一段可执行代码时，会生成一个执行上下文，V8用执行上下文来维护执行当前代码所需要的变量声明，this指向等； 执行上下文主要包含了“变量环境，词法环境，this关键字”等，比如在浏览器的环境中，全局执行上下文就包括了window对象，还是默认指向window的this关键字，另外还有一些web API函数，诸如setTimeout，XMLHttpRequest等内容； 而词法环境中，则包含了使用let，const等变量的内容 全局执行上下文在V8的生存周期内是不会被销毁的，它会一直保存在堆中，这样当下次在需要使用函数或者全局变量时，就不需要重新创建了，另外，当执行一段全局代码时，如果全局代码中有声明的函数或定义的变量，那么函数对象和声明的变量都会被添加到全局执行上下文中。 1234var x = 1function show_x () &#123; console.log(x)&#125; v8在执行这段代码中，会在全局执行上下文中添加变量x和函数show_x;这里需要提示一个消息就是，浏览器环境下，全局中使用var声明的对象或者变量都会被写入window对象，这带来的坑就是gc不会主动去收集这部分内存空间； 当V8调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈结构，比如执行下面这段代码 12345678var x = 1function show_x()&#123; console.log(x)&#125;function bar()&#123; show_x()&#125;bar() 当执行到show_x()，其栈的状态如下 123|-- show_x 执行上下文|- bar执行上下文| 全局执行上下文 构造事件循环系统有了堆空间和栈空间，生成全局执行上下文和全局作用域，接下来还不能执行js代码； 因为V8还需要一个主线程，用来执行js和执行垃圾回收等工作，V8是寄生在宿主环境中的，它并没有自己的主线程，而是使用宿主所提供的主线程，V8所执行的代码都是在宿主的主线程上执行的； 只有一个主线程依然不行，因为如果你开启了一个线程，在该线程执行一段代码，那么当该线程执行完这段代码之后，就会自动退出了；执行过程中的一些栈上的数据也随之被销毁，下次再执行另外一个段代码时，你还需要重新启动一个线程，重新初始化栈数据，这会严重影响到程序执行时的性能； 为了在执行完代码之后，让线程继续运行，通常的做法是在代码中添加一个循环语句，在循环语句中监听下个事件，这在一个http服务器程序中会被经常使用 1234while(true) &#123; Task task = GetNewTask(); RunTask(task)&#125; 如果主线程正在执行一个任务，这时候又进来一个新任务，比如V8正在操作DOM，这时候浏览器的网络线程完成了一个页面下载的任务，而且V8注册监听下载完成的事件，那么这种情况下就需要引入一个消息机制，让下载完成的事件暂存到消息队列中，等当前的任务（DOM操作）执行结束之后，再从消息队列中取出正在排队的任务。当执行完一个任务之后。事件循环系统会重复这个过程，继续从消息队列中取出并执行下个任务； 因为所有的任务都是运行在主线程的，在浏览器的页面中，V8会和页面共用主线程，共用消息队列，所以如果V8执行一个函数过久，会影响到浏览器页面的交互性能； 8.3.2.2 AST和作用域 在基础环境准备好之后，接下来就可以向V8提交要执行的js代码了； js代码输入进来是一段字符串，需要先结构化它。也就是先生成AST，AST是便于V8理解的结构； 在生成AST的同时，V8还需要生成相关的作用域，作用域中存放相关变量； 有了AST和作用域之后，接下来就可以生成字节码了，字节码是介于AST和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行； 8.3.2.2.1 V8是如何查找变量的 上文提到，在生成AST时，V8还需要生成相关的作用域，并在相关的作用域中存放相关变量。V8是如何查找变量的，答案是通过作用域链； 作用域就是存放变量和函数的地方，全局作用域中存放了全局环境中声明的变量和函数，函数作用域中存放了函数中声明的变量和函数，当在某个函数中使用某个变量时，V8就会去这些作用域中查找相关变量，沿着这些作用域查找的路径，就称为作用域链； 全局作用域和函数作用域类似，也是存放变量和函数的地方，但是它们还是有点不一样： 全局作用域是在V8启动过程中就创建了，且一直保存在内存中不会被销毁，直至V8推出，而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了 要了解查找路径，需要明白词法作用域，词法作用域是按照代码定义时的位置决定的，而js所采用的作用域机制就是词法作用域，所以作用域链的路径就是按照词法作用域来实现的； 8.3.2.2.2 V8是如何实现闭包的（延迟解析） 在编译js代码的过程中，V8不会一次性将所有js解析为中间代码，这主要基于以下几点； 首先，一次性解析和编译所有的js代码，过多的代码会增加编译事件，这会严重影响到首次执行js代码的速度，让用户感觉到科顿，因为有时候一个页面的js代码都有10多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间； 其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有js代码，那么这些中间代码和机器代码将会一直占用内存，特别是移动端普及的年代，内存是非常宝贵的资源； 基于这些原因，所有主流js虚拟机都实现了惰性解析，所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成AST和字节码，而仅仅生成顶层代码的AST和字节码； 惰性解析的过程 12345678function foo(a, b)&#123; var d = 100; var f = 10; return d+f+a+b;&#125;var a = 1var c = 4foo(1, 5) 当把这段代码交给V8处理时，V8会自上而下解析这段代码，在解析过程中首先会遇到foo函数，由于这只是一个函数声明语句，V8在这个阶段只需要将该函数转换为函数对象，如下图所示： 注意，这里只是将该函数转换为函数对象，但是并没有解析和编译函数内部的代码，所以也不会为foo函数的内部代码生成抽象语法树； 接下来因为后续代码都是顶层代码，所以V8会为它们生成抽象语法树，最终生成的结果如下； 代码解析完成之后，V8便会按照顺序自上而下执行代码，首先会执行‘a=1’ ‘c=4’ 这两个赋值表达式；接下来执行foo函数的调用；过程是从foo函数对象中取出函数代码，然后和编译顶层代码一样，V8会先编译foo函数的代码，编译时同样需要先将其编译为抽象语法树和字节码，然后再解释执行；这便是惰性解析，也是就是除了顶层外，没真正执行的代码，先不解析。而是作为一个code属性先存入一个对象中去； 不过在V8实现惰性解析的过程中，需要支持js的闭包特性，这会使得V8的解析过程变得异常复杂； 闭包——js三个特性 第一，js语言允许在函数内部定义新的函数 1234function foo()&#123; function inner()&#123;&#125; inner()&#125; 在其他大部分语言中，函数只能声明在顶层代码中，而js中之所以可以在函数中声明另外一个函数，主要是因为js中的函数即对象，可以在函数中声明一个变量，当然你也可以在函数中声明一个函数； 第二， 可以在内部函数中访问父函数中定义的变量 12345678910var d = 20// inner 函数的父函数，词法作用域function foo()&#123; var d = 55 // foo的内部函数 function inner()&#123; return d+2 &#125; inner()&#125; inner是foo函数的子函数，foo函数是inner函数的父函数。这里的父子关系是针对词法作用域而言的。因为词法作用域在函数声明时就决定了，比如inner函数是在foo函数内部声明的，所以inner函数可以访问foo函数内部的变量，比如inner就可以访问foo函数中的变量d （词法作用域和词法作用域链，每个函数有自己的词法作用域，该函数中定义的变量都存在于该作用域中，然后V8会将这些作用域按照词法的位置，也就是代码位置关系，将这些作用域串成一个链，这就是词法作用域链，查找变量的时候会沿着词法作用域的途径来查找） 所以，inner函数在自己的作用域中没有查找到变量d，就接着在foo函数的作用域中查找，再查找不到才会查找顶层作用域中的变量，所以inner函数中使用的变量d就是foo函数中的变量d 第三，因为函数是一等公民，所以函数可以作为返回值 1234567function foo()&#123; return function inner(a, b) &#123; const c = a +b return c &#125;&#125;const f = foo() 我们将inner函数作为foo函数的返回值，也就是说，当调用foo函数时，最终会返回inner函数给调用者，比如上面我们将inner函数返回给了全局变量f，接下来就可以在外部像调用inner函数一样调用f了； 以上就是js闭包相关的三个重要特性： 可以在js函数内部定义新的函数； 内部函数中访问父函数中定义的变量； 因为js中的函数是一等公民，所以函数可以作为另外一个函数的返回值； 闭包给惰性解析带来的问题 12345678function foo()&#123; var d = 20 return function inner(a,b) &#123; const c = a+b+d return c &#125;&#125;const f = foo() 上面这段代码的执行过程： 当调用foo函数时，foo函数会将它的内部函数inner返回给全局变量f； 然后foo函数执行结束，执行上下文被V8销毁了； 虽然foo函数的执行上下文被销毁了，但是依然存活的inner函数引用了foo函数作用域中的变量d； 按照通用的做法， d已经被V8销毁了，但是由于存活的函数inner依然引用了foo函数中的变量d，这样就会带来两个问题： 当foo执行结束时，变量d该不该被销毁？ 如果不应该被销毁。那么应该采用什么策略？ 如果采用了惰性解析，那么当执行到foo函数时，v8只解析foo函数，并不会解析内部的inner函数，那么这时候V8就不知道inner函数中是否引用了foo函数的变量d； 那么怎么处理呢？ 在执行foo函数的阶段，虽然采取了惰性解析，不会解析和执行foo函数中的inner函数，但是V8还是需要判断inner函数是否引用了foo函数中的变量，负责处理这个任务的模块叫做预解析器； 预解析器如何解决闭包所带来的问题？ V8引入预解析器，比如当解析顶层代码的时候，遇到一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个； 第一，是判断当前函数是不是存在一些语法上的错误，如下面这段代码； 1234function foo(a,b)&#123; // 语法错误&#125;foo(1,5); 第二，除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题； 8.3.2.3 解释器生成字节码之后，解释器就登场了，它会按照顺序执行字节码，并输出执行结果； 解释执行字节码 监听热点代码 优化热点代码为二进制的机器代码 反优化生成的二进制机器代码 8.4 V8异步编程8.4.1 V8是怎么实现回调函数的诸如setTimeout，XMLHTTPRequest来异步下载资源文件，在Node中可以使用readFile来读取文件，这些操作都有一个共同的特点，那就是需要给调用API传入回调函数，然后浏览器或者Node会将执行处理的结果通过回调函数来触发； 从内部了解回调函数，可以帮助我们梳理清楚很多问题 有助于我们理解浏览器中的Web API到底是怎么工作的； 有助于我们理解宏任务和微任务到底有哪些区别； 理解回调函数，是理解异步编程模型async/await的基础； 只有当某个函数被作为参数，传递给另外一个函数，或者传递给宿主环境，然后该函数内部或者在宿主环境中被调用，才称为回调函数 回调函数有两种不同的形式，同步回调和异步回调。通常，我们需要将回调函数传入给另外一个执行函数，那么同步回调和异步回调的最大区别在于同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的 同步回调无需多言，下面只说异步回调 1234function foo()&#123; console.log(\"hello\");&#125;setTimeout(foo, 3000) 异步回调在什么时机和什么位置被调用呢？ 要解释清楚这个问题，我们就需要了解V8在运行时的线程模型，因为这涉及到了消息队列，事件循环等概念，这些概念都和线程模型是直接相关的，所以接下来就先来分析下V8的线程架构模型； UI线程宏观架构 早期浏览器的页面是运行在一个单独的UI线程中，所以要在页面中引入js，那么js也必须要运行在和页面相同的线程上，这样才能方便使用js来操纵DOM，所以从一开始，js就被设计成运行在UI线程中； 所谓UI线程，是指运行窗口的线程，当你运行一个窗口时，无论该页面是windows的窗口系统，还是android或者ios的窗口系统，它们都需要处理各种事件，诸如触发绘制页面的事件，有鼠标点击，拖拽，放大缩小的事件，有资源下载，文件读写的事件； 在页面线程中，当一个事件被触发时，比如用户使用鼠标点击了页面，系统需要将该事件提交给UI线程来处理； 在大部分情况下，UI线程并不能立即响应和处理这些事件，比如在你在移动鼠标的过程中，每移动一个像素都会产生一个事件，所以鼠标移动的事件会频繁地被触发，在这种情况下，页面线程可能正在处理前一个事件，那么最新的事件就无法被立即执行； 针对这种情况，我们为UI线程提供一个消息队列，并将这些待执行的事件添加到消息队列中，然后UI线程会不断循环地从消息队列中取出事件，执行时间，我们把UI线程每次从消息队列取出事件，执行事件的过程称为一个任务； 这就是通用的UI线程的结构，有消息队列，通过鼠标，键盘，触控板等产生的消息都会被添加进消息队列，主线程会循环地从消息队列中取出消息并执行； 异步回调函数的调用时机 setTimeout(foo,3000)，在执行setTimeout函数的过程中，宿主就会将foo函数封装成一个事件，并添加到消息队列中，然后setTimeout函数执行结束； 通用UI线程是如何处理下载事件的 UI线程会从消息队列中取出一个任务，并分析该任务； 分析过程中发现该任务是一个下载请求，那么主线程就会将该任务交给网络线程去执行； 网络线程接到请求之后，便会和服务端建立连接，并发出下载请求； 网络线程不断地收到服务器端传过来的数据； 网络线程每次接收到数据时，都会将设置的回调函数和返回的数据信息，如大小，返回了多少字节，返回的数据在内存中存放的位置等信息封装成一个新的事件，并将该事件放到消息队列中； ui线程继续循环地读取消息队列中的事件，如果是下载状态的事件，那么UI线程会执行回调函数，程序员便可以在回调函数内部编写更新下载进度的状态的代码； 直到最后接收到下载结束事件，UI线程会显示该页面下载完成； 8.4.2 V8是如何实现微任务的 基于上文提到基础UI框架，js衍生出很多新技术，诸如宏任务和微任务 宏任务： 指消息队列中的等待被主线程执行的事件；每个宏任务在执行时，V8都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务； 微任务： 微任务是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前； 之所以引入微任务，一来是因为主线程执行消息队列中宏任务的时间粒度太粗，无法胜任一些对精度和实时性要求较高的场景，那么微任务可以在实时性和效率之间做一个有效的权衡； 另外，使用微任务，可以改变现在的异步编程模型，使我们可以使用同步形式的代码来编写异步调用； 微任务解决了宏任务执行时机不可控的问题 虽然我们可以通过将某些函数封装成宏任务的方式来解决，但是宏任务需要先被放到消息队列中，如果某些宏任务的执行时间过久，那么就会影响到消息队列后面的宏任务的执行，而且这个影响不可控，因为你无法知道前面宏任务需要多久才能执行完毕； V8会为每个宏任务维护一个微任务队列，当V8执行一段js时，会为这段代码创建一个环境对象，微任务队列就是存放在该环境对象中的。当你通过Promise.resolve生成一个微任务，该微任务会被V8自动添加进微任务队列，等整段代码快要执行结束时，该环境对象也随之被销毁，但是在销毁之前，V8会先处理微任务队列中的微任务； 能否在微任务中循环地触发新的微任务 1234function foo()&#123; return Promise.resolve().then(foo)&#125;foo() 答案必然是不能，因为函数在退出宏任务之前会检查微任务队列，如果循环创建微任务，那么导致当前宏任务永远无法被退出。那造成的结果就是后续的宏任务永远得不到执行； 8.5 V8内存管理8.5.1 内存模型js原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的 js是gc语言；开发者无需手动清理堆内存 所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。 在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。 8.5.2 垃圾回收算法第一步，通过GC Root标记空间中活动对象和非活动对象 GC Root有很多，通常包括 window对象 DOM树 存放在栈上变量 第二步，回收非活动对象所占据的内存，其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象 第三步，内存整理，清理之后的内存必然存在大量不连续的空间，这些不连续的内存空间称为内存碎片。出现大量内存碎片，会导致无法分配较大的连续内存，就可能出现内存不足的情况。所以最后一步需要整理这些内存碎片。但其实这步是可选的，因为有的垃圾回收器不会产生内存碎片；比如副垃圾回收（Minor GC（Scavenger）） 8.5.3 垃圾回收首先像一些没有垃圾回收机制的语言，比如C/C++。 是需要调用free函数来清楚堆内存的。 js内置的垃圾回收工具，并不需要手动去释放； 8.5.2.1 栈中代码如何回收JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。 8.5.2.2 堆中代码如何回收ESP能解决栈内存，不过保存在堆中的两个对象依然占用着空间，如下图所示： 从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。 目前V8采用了两个垃圾回收器， 主垃圾回收和副垃圾回收，之所以使用两个垃圾回收，主要是受到代际假说的影响 代际假说有以下两个特点： 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。 第二个是不死的对象，会活得更久。 其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。 V8 的垃圾回收策略，就是建立在代际假说的基础之上的。 通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。 所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。 新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。 副垃圾回收器 Minor GC（Scavenger ），主要负责新生代的垃圾回收。 主垃圾回收器 Major GC，主要负责老生代的垃圾回收。 8.5.2.2.1 副垃圾回收器副垃圾回收器主要负责新生代垃圾回收，通常情况，大多数小的对象都被分配到新生代，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的； 新生代垃圾数据用Scavenge算法来处理，所谓Scavenge算法，是把新声代空间对半划分为两个区域，一半是对象区域（from-space），一半是空闲区域（to- space） 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作； 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。 由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。 也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。 8.5.2.2.2 主垃圾回收器主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点， 一个是对象占用空间大 另一个是对象存活时间长 由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。 比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示： 从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程： 上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图： 下面这段代码如何优化 1234567891011121314151617function strToArray(str)&#123; let i = 0; const len = str.length let arr = new Uint16Array(str.length) for(;i&lt;len;++i)&#123; arr[i] = str.charCodeAt(i) &#125; return arr;&#125;function foo()&#123; let i =0 let str = \"test v8 gc\" while(i++ &lt; 1e5) &#123; strToArray(str) &#125;&#125; 8.5.2.2.3 全停顿现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。 比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示： 在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。 8.5.2.4 GC优化为了降低老生代的垃圾回收而造成的卡顿，V8团队向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术，这些技术主要是从两方面来解决垃圾回收效率问题的 第一， 将一个完整的垃圾回收的任务拆分成多个小的任务，这样就消灭了单个长的垃圾回收任务 第二。将标记对象，移动对象等任务转移到后台线程进行，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅； 8.5.2.5.1 并行回收GC时候，引入多个辅助线程来并行处理，采用并行回收时，垃圾回收所消耗的时间，等于总体辅助线程所消耗的时间。这种方式较简单，因为在执行垃圾标记的过程中，主线程并不会同时执行js代码，因此js代码也不会改变回收的过程，所以我们可以假定内存状态是静止的，因此只要确保同时只有一个协助线程在访问对象就好了； V8副垃圾回收器就是用的并行策略，在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针； 值得一提的事，并行策略仍然是一种全停顿的垃圾回收方式； 8.5.2.5.2 增量回收V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示： 使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。 增量标记的算法，比全停顿要稍微复杂，这主要是因为增量回收是并发的，要实现增量执行，需要满足两点要求： 垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后，才能继续启动 在暂停期间，被标记好了垃圾数据如果被js代码修改了，那么垃圾回收器需要能够正确处理 v8是如何实现垃圾回收器的暂停和恢复执行的 在没有采用增量算法之前，V8使用黑色和白色来标记数据，在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记，然后垃圾回收器在会从GC root出发，将所有能访问到的数据标记为黑色。遍历结束之后，被标记为黑色的数据就是活动数据，那些白色数据就是垃圾数据； 如果内存中的数据只有两种状态，非黑即白，那么当你暂停了当前的垃圾回收器之后，再次恢复垃圾回收器，那么垃圾回收器就不知道从哪个位置继续开始执行了； 比如垃圾回收执行了一小段增量回收后，被V8暂停了，然后主线程执行了一段js代码，然后垃圾回收器又被回复了，那么回复时内存状态就如上图所示了。 那么当垃圾回收器再次被启动的时候，它到底是从A节点开始标记，还是从B节点开始执行标注过程呢？ 因为没有其他额外的信息，所以垃圾回收器也不知道该如何处理了； 为了解决这个问题，V8采用了三色标记法，除了黑色和白色，还额外引入了灰色； 黑色表示这个节点被GC Root引用到了，而且该节点的字节点都已经标记完成了 灰色表示这个节点被GC Root引用到，但字节点还没有被垃圾回收器标记处理，也表明目前正在处理这个节点； 白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回； 引入灰色标记之后，垃圾回收器就可以依据当前内存中有没有灰色节点，来判断整个标记是否完成，如果没有灰色节点了，就可以进行清理工作了，如果还有灰色标记，当下次回复垃圾回收器时，便从灰色的节点开始继续执行； 因此采用三色标记，可以很好地支持增量式垃圾回收 示例 123window.a = Object()window.a.b = Object()window.a.b.c = Object() 然后又执行了另外一个代码 1window.a.b = Object() 由于b重新指向了d对象，所以b和c对象的连接就断开了。这时候的代码应该如上图所示 就说明一个问题，当垃圾回收器将某个节点标记成了黑色，然后这个黑色的节点被续上了一个白色节点，那么垃圾回收器就不会再次将这个白色节点标记为黑色节点，因为它已经走过这个路径了； 但是这个新的白色节点的确被引用了，所以还是需要想办法将其标记为黑色； 为了解决这个问题，增量垃圾回收器添加了一个约束条件，不能让黑色节点指向白色节点 通常使用 写屏障机制 实现这个约束条件，也就是说，当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的，这样就保证了黑色节点不能指向白色节点的约束条件。这个方法也被称为强三色不变性，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时的所有白色对象，对于垃圾回收器来说，都是不可到达的，可以安全释放； 所以在V8中，每次执行window.a.b = value的写操作之后，V8会插入写屏障代码，强制将value这块内存标记为灰色； 8.5.2.5.3 并发回收虽然通过三色标记法和写屏障机制很好实现增量垃圾回收，但是由于这些操作都是在主线程上执行，如果主线程繁忙的时候，增量垃圾回收操作依然会增加降低主线程处理任务的吞吐量 并发回收机制，可以在不阻塞主线程的情况下，执行垃圾回收操作； 所谓并发回收，是指主线程在执行js的过程中，辅助线程能够在后台完成执行垃圾回收的操作 但是并发回收却是这三种技术中最难的一种，这主要由以下两个原因导致的： 当主线程执行js时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全无效； 主线程和辅助线程极有可能在同一时间去更改同一对象，这就需要额外实现读写锁的一些功能了； V8的主垃圾回收器就融合了这三种机制，来实现垃圾回收。 可以看出来，主垃圾回收器同时采用了这三种策略： 首先主垃圾回收器主要使用并发标记，在主线程执行js，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的； 标记完成之后，再执行并行清理操作，主线程在执行清理操作时，多个辅助线程也在执行清理操作； 另外，主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种js任务之间执行； 8.5.2.5 如何判断内存泄漏使用chrome的performace面板，观察内存变化，如果多次垃圾回收后，整体趋势是向上，就存在内部泄漏的可能！ 闭包形成的对象刚开始是属于新声代还是老生代 看对象大小，小对象一开始就会跌倒新生代中去，当GC执行多次后，会被移动到老生代中； 8.6 V8内存优化 V8为了提升js的执行速度，借鉴了很多静态语言的特性，比如实现了JIT机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存 8.6.0 快慢属性js在运行时，对象的属性是可以被修改的，所以当V8使用了一个对象时，比如使用了start.x的时候，它并不知道该对象中是否有x，也不知道x相对于对象的偏移量是多少，也可以说V8并不知道该对象的具体形状； 那么，当在js中要查询对象start中的x属性时，V8会按照具体的规则一步一步来查询，这个过程是非常慢且耗时； 那么，V8采用了哪些策略提升了对象属性的访问速度？ 从js语言的角度来看，js对象像一个字典，字符串作为键名，任意对象可以做为键值，可以通过键名读写键值； 然而在V8存储的时候，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线形表，查询效率会低于线形的数据结构；V8为了提升存储和查找效率，采用了一套复杂的存储策略； 常规属性和排序属性 12345678910111213141516function Foo()&#123; this[100] = 'test-100'; this[1] = 'test-1'; this[\"B\"] = 'bar-B'; this[50] = 'test-50'; this[9] = 'test-9'; this[8] = 'test-8'; this[3] = 'test-3'; this[5] = 'test-5'; this[\"A\"] = 'bar-A'; this[\"C\"] = 'bar-C';&#125;var bar = new Foo()for (key in bar) &#123; console.log(`index: $&#123;key&#125; value: $&#123;bar[key]&#125;`)&#125; 12345678910index: 1 value: test-1index: 3 value: test-3index: 5 value: test-5index: 8 value: test-8index: 9 value: test-9index: 50 value: test-50index: 100 value: test-100index: B value: bar-Bindex: A value: bar-Aindex: C value: bar-C 阿拉伯数字的key 居然排序了，非阿拉伯数据的key按照定义的顺序在输出； 是因为ECMAscript规范中定义数字属性应该按照索引值大小生序排列，字符串属性根据创建时候的顺序生序排列 数字属性-&gt; 排序属性（element） 字符串属性 -&gt; 常规属性 （properties） 如上图所示，bar对象包含两个隐藏属性： element属性和properties属性，elements属性指向了elements对象，在elements对象中，会按照顺序存放排序属性，properties属性则指向了properties对象，在properties对象，会按照创建时候的顺序保存常规属性；值得注意的是，存储排序属性和常规的属性的容器是两个线形数据结构； 快属性和慢属性 将不同属性分别保存在elements和properties，简化了程序的复杂度，但是查找元素时，多了一步操作。比如执行bar.B茶渣B的属性值，那么在V8会先查找出properties属性所指向的对象properties，然后再在properties对象中查找B属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率； 基于此，V8采取一个权衡的策略，这个策略是将部分常规属性存储到对象本身，称为“对象内属性（in -object properties）” 如上图所示，对象内属性解决了查找的问题，但是对象内属性的个数上限被限定在了10.如果超过10就被存储到properties了；虽然属性存储多了一层，但可以自由扩容； 保存在线形结构的属性，称为“快属性”。因为线形结构中只需要通过索引即可以访问到属性，缺点就是从线形结构添加删除大量属性，执行效率会非常低，这主要因为会产生大量时间和内存开销； 如果一个对象的属性过多的时候，V8会采取“慢属性”策略，慢属性的对象内部会有独立的非线性数据结构（词典）作为属性存储容器，所有的属性元信息不再是线形存储的，而是直接保存在属性字典中； 示例： chrome中查看对象布局 12345678910function Foo(prop_num, ele_num )&#123; for (let i=0; i&lt; ele_num; i++) &#123; this[i] = `elements$&#123;i&#125;` &#125; for(let i=0; i&lt; prop_num; i++)&#123; let ppt = `property$&#123;i&#125;` this[ppt] = ppt &#125;&#125;var bar = new Foo(10,10) 后面我们依次加多属性个数,来观察对象的分布 12var bar = new Foo(20,10)var bar = new Foo(100,10) 观察上图，除了elements和properties属性之外，V8还为每个对象实现了map属性和__proto__属性。 map属性就是隐藏类 总结 从这个快慢属性的机制来看，尽可能避免出现很大的对象；最好约束在“对象内属性”，这样在查找的时候能节约一个中间步骤。也就是尽量只有10个之内；如果大于10个，使得对象不得不启用线形表存储额外属性的时候，尽量不要动态delete和add属性，防止线形表内存反复的数据搬移；如果对象中的属性过多时，或者存在反复添加或者删除的操作，那么V8就会将线形的存储模式降级为非线形的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度； 尽可能一次性缓存对象指针，而不是在代码中频繁出现对象索引代码，如下 12345678// badconst d = a.b.c + x.y.z;const e = a.b.c * x.y.z;// goodconst c = a.b.cconst z = x.y.zconst d = c+zconst e = c*z 8.6.1 隐藏类为什么静态语言效率更高 首先，静态语言比如C++，在声明一个对象的时候需要定义该对象的结构，比如Point类就是一种结构；C++在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中，Point的形状是无法被改变的； 那么在C++访问一个对象的属性时，自然就知道该属性相对于该对象地址的偏移值了；比如使用start.x时，编译器直接将X相对start的地址写进汇编指令中，那么当使用对象start中的x属性时，CPU就可以直接去内存地址中找了，没有任何中间商赚差价 这便是静态语言效率高的原因 但是动态语言js没法这么做，js在声明一个对象的时候，可以在后续代码中手动增加删除属性。完全free灵动； 既然静态语言效率这么高，那么能够将这种特性引入到V8中去呢？ 答案就是 隐藏类 目前所采用的一个思路就是将js中的对象静态化，也就是V8在运行js的过程中，会假设js中的对象是静态的，V8对每个对象做如下两点假设； 对象创建好了就不会添加新的属性 对象创建好了之后也不会删除属性 然后V8就可以对js中的对象做深度优化了， 具体讲，V8会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点 对象所包含的所有属性 每种类型相对于对象的偏移量 有了隐藏类之后，那么当V8访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么久大大提升了V8查找对象的效率； 1let point = &#123;x:100, y:200&#125; 当V8执行这句代码时，会纤维point对象创建一个隐藏类，即上面提到的map属性，每个对象都有一个map属性，值都指向内存中的隐藏类 隐藏类描述了对象的属性布局，它主要包括了属性名称和每个属性所对应的偏移量，比如point对象的隐藏类久包括了x和y属性，x的偏移量是4，y的偏移量是8； 有了map之后，当你再次使用point.x访问x属性时，v8会查询point的map中x属性相对point对象的偏移量，然后将point对象的起始位置加上偏移量，就得到了x属性的值在内存中的位置，有了这个位置也就拿到了x的值，这样就省去一个比较复杂的查找过程； 8.6.1.1 多个对象共用一个隐藏类如果两个对象的形状是相同的，v8就会为其复用同一个隐藏类。好处是 减少隐藏类的创建次数，也间接加速了代码的执行速度 减少了隐藏类的存储空间 那么，什么情况下两个对象的形状是相同的 相同的属性名称 相等的属性个数 12let point = &#123;x: 100, y:200&#125;;let point2 = &#123;x:3, y:4&#125;; 8.6.1.2 重新构建隐藏类js是动态语言，意味着对象是可以被改变的；如果某个对象形状变了，那么隐藏类也会跟着改变。意味着V8要为新改变的对象重新构建新的隐藏类，这对于V8的执行效率来说，是一笔大的开销； 8.6.1.3 最佳实践V8为每个对象分配隐藏类的执行过程 如果对象的形状没有发生改变，那么该对象就会一直使用该隐藏类 如果对象的形状发生了改变，那么V8会重建一个新的隐藏类给该对象 触发V8重构该对象的隐藏类，会直接影响到程序的执行性能 尽量注意以下几点： 使用字面量初始化对象时，要保证属性的顺序是一致的； 12x1 &#x3D; &#123;a: 1,b:1&#125;;x2 &#x3D; &#123;b:1,a:1&#125;; 虽然x1，x2属性一致，但是初始化顺序不一样，也会导致形状不同，所以尽量避免这种情况为好； 尽量使用字面量一次性初始化完整对象属性；（每增加一个属性，V8都会为该对象重新设置隐藏类） 尽量避免使用delete方法；（delete破坏对象形状，同样触发V8重构该隐藏类） 8.6.2 内联缓存123456789function loadX(o) &#123; return o.x&#125;var o = &#123;x:1, y:3&#125;var o1 = &#123;x:3, y:6&#125;for (var i=0; i&lt;90000; i++)&#123; loadX(o) loadX(o1)&#125; 当V8调用loadX时，会先查找参数O的隐藏类，然后利用隐藏类中的x属性的偏移量查找到x的属性值，虽然利用隐藏类能够快速提升对象属性的查找速度，但是依然有一个查找隐藏类和查找隐藏类中的偏移量两个操作，如果loadX在代码中会被重复执行，依然影响到了属性的查找效率； V8是采取什么措施来提供loadX函数的执行效率的？ 答案就是内联缓存，简称IC； 什么是内联缓存？ IC原理，直观理解就是， 在V8执行函数的过程中，会观察函数中一些调用点（CallSite）上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此V8利用IC，可以有效提升一些重复代码的执行效率； IC会为每个函数维护一个反馈向量，反馈向量记录了函数在执行过程中的一些关键的中间数据，关于函数和反馈向量的关系 反馈向量其实就是一个表结构，由很多项组成，每一项为一个插槽（Slot），V8依次将执行loadX函数的中间数据写入到反馈向量的插槽中 12345function loadX(o) &#123; o.y = 4 return o.x&#125;loadX(&#123;x:1&#125;) 当V8执行上面语句时它会判断o.y = 4 和return o.x 这两段是调用点（CallSite），因为它们使用了对象和属性，那么V8会在loadX函数的反馈向量中为每个调用点分配一个插槽；。。。 等到反馈向量缓存了数据之后， 当V8再次调用loadX函数时，比如执行到loadX函数中的return o.x语句时，它就会在对应的插槽中查找x属性的偏移量，之后V8就能直接去内存中获取o.x的属性值了。这样就大大提升了V8的执行效率； 8.6.2.1 多态和超态123456789function loadX(o) &#123; return o.x&#125;var o = &#123;x:1, y:3&#125;var o1 = &#123;x:3, y:6,z:4&#125;for (var i=0;i&lt;90000; i++) &#123; loadX(o) loadX(o1)&#125; 如上，o和o1形状不同，意味着V8为它们创建的隐藏类也是不同的； 第一次调用loadX。V8将o的隐藏类记录在反馈向量中，并记录属性x的偏移量，那么当再次调用loadX函数时，V8会取出反馈向量中记录的隐藏类，并和新的O1的隐藏类进行比较，发现不是一个隐藏类，那么此时V8就无法使用反馈向量中记录的偏移量信息了； 面对这种情况，V8会选择将新的隐藏类也记录在反馈向量中，同时记录属性值的偏移量，这时，反馈向量中的第一个槽就包含了两个隐藏类和偏移量， 现在我们知道了，一个反馈向量的一个插槽中可以包含多个隐藏的信息；那么 如果一个插槽中只包含1个隐藏类，那么我们称这种状态为单态 如果一个插槽中包含了2-4个隐藏类，那我们称呼这种状体为多态 如果一个插槽中超过4个隐藏类，我们称这种状态为超态 尽量保持单态吧，单态的性能优于多态和超态 1比如定一个loadX(o)的签名，那么当传递参数时，尽量不要使用多个不同形状的o对象； 8.6.3 总结​ 虽然用了大量篇幅介绍隐藏类和内联缓存，但是说实在的，并不需要过度担忧代码是否破坏了隐藏类或者IC的机制，一个TS解决大多数问题；对于优化而言，隐藏类和IC机制对效率的影响可能是微不足道的； 8.7 V8的类型系统8.7.1 什么是类型对机器语言来说，所有的数据都是一堆二进制代码，CPU处理这些数据的时候，并没有类型的概念，CPU能做的仅仅是移动数据，比如对其进行移位，相加或者相乘； 而在高级语言中，我们都会为操作的数据赋予指定的类型，类型可以确认一个值或者一组值具有特定的意义和目的，所以，类型是高级语言中概念； js在定义变量的时候，并需要像C++那样去指定类型，因为V8会根据数据自动推导类型； 每种语言都定义了自己的类型，还定义了如何操作这些类型，另外还定义了这些类型应该如何相互作用，我们就把这称为“类型系统” 这个定义类型应该如何相互作用，更像是一种协议，比如两种不同类型相加应该如何处理，相同类型相加又应该如何处理等等；同时还规定了各种不同类型应该如何相互转换，比如string -&gt; number 一个语言的类型系统越强大，那编译器能帮程序员检查的东西就越多，程序员定义“检查规则”的方式就越灵活； 8.7.2 V8如何执行加法操作 V8基本照搬并实现了ECMAscript规范 AdditiveExpression : AdditiveExpression + MultiplicativeExpression 把第一个表达式（AdditiveExpression）的值复制给左引用（lref） 使用GetValue(lref)获取左引用（lref）的计算结果，并赋值给lval 使用ReturnlfAbrupt(lval)如果报错就返回错误 把第二个表达式（MultiplicativeExpression）的值赋值给右引用（rref） 使用GetValue(rref)获取右引用（rref）的计算结果，并赋值给rval 使用ReturnlfAbrupt(rval)如果报错就返回错误 使用ToPrimitive(lval)获取左值（lval）的计算结果，并将其赋值给左原生值（lprim） 使用ToPrimitive(rval)获取右值（rval）的计算结果，并将其赋值给右原生值（rprim） 如果Type(lprim)和Type(rprim)中有一个是String，则： 把ToString(lprim)的结果赋给左字符串(lstr) 把ToString(rprim)的结果赋值给右字符串(rstr) 返回左字符串(lstr)和右字符串(rstr)拼接的字符串 把ToNumber(lprim)的结果赋给左数字（lnum） 把ToNumber(rprim)的结果赋值给右数字（rnum） 返回左数字（lnum）和右数字（rnum）相加的数值； 通俗的讲，V8会提供一个ToPrimitive 方法，将a和b转换为原生数据类型，其转换流程如下 先检测该对象中是否存在valueOf方法，如果有并返回了原理类型，那么就使用该值进行强制类型转换； 如果valueOf没有返回原始类型，那么就使用toString方法的返回值； 如果valueOf和toString两个方法都不返回基本类型值，便会触发一个TypeError的错误； 当V8执行1+’2’时，因为这是两个原始值相加，原始值相加的时候，如果其中一项是字符串，那么V8会默认将两外一个值也转换为字符串； 1Number(1).toString() + \"2\" 这里，把数字1偷偷转换为字符串“1”的过程也称为强制类型转换，因为这种转换是隐式的； 8.7.3 demo：验证流程12345678910// demo1var obj = &#123; toString()&#123; return '200' &#125;, valueOf()&#123; return 100 &#125;&#125;obj+3 先使用ToPrimitve方法将Obj转换为原生类型，而ToPrimitve会优调用对象中的valueOf方法，由于valueOf返回了100，那么Obj就会被转换为数字100，那么数字100加数字3，就是103了 1234567891011// demo2var obj = &#123; toString()&#123; return new Object() &#125;, valueOf()&#123; return new Object() &#125;&#125;obj+3// cannot convert object to primitive value 错误的原因是无法将对象类型转换为原生类型 因为ToPrimitve会先调用valueOf方法，发现返回的是一个对象，并不是原生类型，当ToPrimitive继续调用toString方法时，发现toString返回的也是一个对象，都是对象，就无法执行相加运算了。 所以说，在执行加法操作时。V8会通过ToPrimitve方法将对象类型转换为原生类型，最后就是两个原生类型相加，如果其中一个值的类型是字符串时，则另一个值也需要强制转换为字符串，然后做字符串的连接运算，在其他情况时，所有的值都会转换为数字类型值，然后做数字的相加； 结语： 如何创建属于自己的技术栈如果进入的是一个成熟的领域，那么一般都有比较完整的技术栈的资料，我们需要花些时间分析资料，系统性地了解这一领域知识的宏观架构、它的过往历史、它的优缺点，然后结合现在资料和我们自身的特点来建立我们自己的技术栈。如果你所在的领域还在高速发展中，并没有人总结出完成的技术栈，那么为了更好地理解技术的发展脉络，我们需要花更多一些的时间去整理出该领域的技术栈； 当你要开发一个新项目或者学习一门手艺之前，应该将其所涉及到的知识做一个全方位的了解，“技术栈”非常形象地表达了学习一门手艺所需要的是哪些知识，以及应该按照什么顺序来学。 比如学习前端这门手艺，栈底到栈顶依次是浏览器架构、web网络、事件循环机制、js core、V8内存管理，浏览器渲染流程、web安全、css、react/vue、node、构建工具链等； 学习技术栈的每一层都不难，难的是当你抛开底层栈的内容去理解上层栈的内容，那么就有可能陷入知识点的盲区； 我们在学习一门手艺的时候，即便没有完善的技术栈资料，只要肯花费更多的时间，也可以克服困难，甚至我们的学习过程可以像一个无头苍蝇，横冲直撞，某一个也会突然顿悟整个知识体系，俗话说，在一个领域耕耘十年，必定能成为该领域的专家； 但是，如果三年能搞定为何要花上10年呢； 系统性学习一门技术，花费的时间也是最短的，也可以说是最性价比的，因为系统性、循序渐进地学习，那么学习到每个知识点时，其实并没有其他的知识盲区。这样学习起来是最轻松、简单的；","categories":[{"name":"browser","slug":"browser","permalink":"http://yoursite.com/categories/browser/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"go_dev","slug":"go-dev","date":"2021-04-21T02:35:57.000Z","updated":"2021-05-15T13:24:57.265Z","comments":true,"path":"2021/04/21/go-dev/","link":"","permalink":"http://yoursite.com/2021/04/21/go-dev/","excerpt":"","text":"golang开发环境搭建 环境搭建是开发的一部分，砍柴之前磨磨刀还是很必要的。所以，学习之前我打算在linux上搭建一套golang的开发环境；这里以某厂商的云虚拟机为例，操作系统应该是centos7 1. 安装golang1234567$&gt; wget https://studygolang.com/dl/golang/go1.16.3.linux-amd64.tar.gz -P /data/ # 下载并存放到跟目录的 data文件夹中$&gt; tar xzvf /data/go1.16.3.linux-amd64.tar.gz -C /usr/local/# -x --extract = extract files from an archive# -v, --verbose = verbosely list files processed# -z, --gzip = gzipped files eg. for tar.gz packages# -f, --file ARCHIVE = use archive file or device ARCHIVE# -C /usr/local，tar将在执行任何操作之前将其当前目录更改为dir, 也就是将当前文件解压到 /usr/local； 配环境变量 1$&gt; vim ~/.profile 123456export GOPATH=/opt/goexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/bin/export GOTOOLS=$GOROOT/pkg/tool/export PATH=$PATH:$GOBIN:$GOTOOLSexport GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy,direct 1234mkdir /opt/go$&gt; source ~/.profile$&gt; go version$&gt; go1.15.5 linux/amd64 # 安装成功 2. 配置goland连接orgingoland是jetbrains公司开发的IDE，开发go程序体验不错，这里以goland为例，配置一个连接origin的环境 1preferences -&gt; Build,Execution,Deployment-&gt;Deployment 点左上角 + 并选择SFTP类型 在connection tabs上添加虚拟机地址 在mappings分别填上本地的path和远端的path 点击apply ok 即可； 选择always，保持文件更新之后往远程push 在Tools&gt;ssh configuration配置origin机器信息，这样就可以在IDE的tool工具栏中开启origin的命令行并愉快的使用了； 3. 安装protobuf和grpc123456$&gt; wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protobuf-all-3.13.0.tar.gz -P /data/ # 将文件下载至data文件夹中$&gt; tar -zxvf protobuf-all-3.13.0.tar.gz$&gt; cd protobuf-3.13.0/$&gt; ./configure --prefix=/usr/local/protobuf # 编译安装$&gt; make$&gt; make install 配置环境变量 123456789101112131415$&gt; vim ~/.profile#protobuf config#(动态库搜索路径) 程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/protobuf/lib/#(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/protobuf/lib/#执行程序搜索路径export PATH=$PATH:/usr/local/protobuf/bin/#c程序头文件搜索路径export C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/local/protobuf/include/#c++程序头文件搜索路径export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/protobuf/include/#pkg-config 路径export PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/ 123source ~/.profileprotoc --version# libprotoc 3.13.0 install complate! 安装go语言插件，因为protobuf并没有直接支持go语言，需要手动安装一下相关插件 12345$&gt; go get -v -u github.com/golang/protobuf/proto$&gt; cd 到 github.com/golang/protobuf/protoc-gen-go/$&gt; go build # 执行打包，生成 protoc-gen-go 可执行文件$&gt; sudo cp protoc-gen-go /bin/ 将可以执行命令复制到/bin中# 尝试补全 protoc-gen-go， 如果成功，则表示ok 测试编译是否成功 123protoc --go_out=./ *.proto # 在远程执行编译# grpc编译protoc --go_out=plugins=grpc:./ *.proto 安装grpc 1go get -u -v google.golang.org/grpc 4. 安装微服务相关工具4.1 安装consul123$ wget https://releases.hashicorp.com/consul/1.5.2/consul_1.5.2_linux_amd64.zip$ unzip consul_1.5.2_linux_amd64.zip$ sudo mv consul /usr/local/bin/ # 将可执行目录移动到bin目录 4.2 consul测试1consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=0.0.0.0 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0 4.3 consul和grpc结合使用1$&gt; go get -u -v github.com/hashicorp/consul 4.4 go-micro安装1234567#安装go-microgo get -u -v github.com/micro/go-micro#安装工具集go get -u -v github.com/micro/micro#安装protobuf插件go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;go get -u github.com/micro/protoc-gen-micro","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"http","slug":"http","date":"2021-04-14T03:51:53.000Z","updated":"2021-05-09T16:35:36.826Z","comments":true,"path":"2021/04/14/http/","link":"","permalink":"http://yoursite.com/2021/04/14/http/","excerpt":"","text":"http1. 概览2. 搭建条件环境在Mac上， 拷贝项目（需要Git） git clone https://github.com/chronolaw/http_study 安装OpenResty （推荐使用Homebrew） brew tap openresty/brew brew install openresty 运行项目 cd http_study/www/ openresty -p pwd -c conf/nginx.conf 停止项目 openresty -s quit -p pwd -c conf/nginx.conf 补充 遇到了访问 localhost 时，网页报 403 错误的情况，原因是没有 html/index.html 文件的访问权限。 解决方案：先 ls -la html，查看文件的权限，得到 user 和 group，如果是 fstar 和 staff。 那么在 conf/nginx.conf 文件的顶部添加 user fstar staff; 然后再启动 openresty 就可以正常访问了。 启动docker systemctl start docker 关闭docker systemctl stop docker 查看docker的运行状态 systemctl status docker 1234567docker run -it --rm --user root -p 0.0.0.0:8888:80 chronolaw/http_study bash# 访问主机的8888端口会被定向到容器的80端口cat ~/http_study/hosts &gt;&gt; /etc/hostscd ~/http_study/www./run.sh start 解决nginx 403 Forbidden的问题 1ps -aux|grep nginx","categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"learn","slug":"learn","date":"2021-04-02T08:20:39.000Z","updated":"2021-04-07T03:56:35.502Z","comments":true,"path":"2021/04/02/learn/","link":"","permalink":"http://yoursite.com/2021/04/02/learn/","excerpt":"","text":"1. 核心算法 知道自己是如何学会的 回顾不忘、类推 学会（下）一个 什么是学？ 学的本质是模仿 冯先生学英语的秘诀： 背诵好文章（例如著名的小说，百科全书） 他的背诵极其精准——只字不差（促使他跟人交流的时候，能用更高级的语言，精准的高级语言） 学语言的同时拓展了他对其他领域的知识和文化的认知 这并不需要天生的超常记忆力 林语堂： 学习英语的唯一正轨， 不出仿效与熟诵。 仿效要是整句的仿效 热诵则效仿之后必回环练习 最重要的，是学时必整句吞下 再整句吐出来 每日选二三句 回环熟诵 什么叫回环练习？ 天文学著作看上去看困难，中学生想读懂大学的天文学教科书非常困难。但是你从头开始往下读，读哪卡住了，再从头开始读。原来卡住你的地方就卡不住你了；再持续推进，再从头开始读，这叫回环练习； 为何整句仿效，整句吐出？ 整句会有明显的成就感和收获感，随着时间的推移。这种收获感会越来越强。会让人上瘾，这是强调整句的重要性； 为什么是两三句呢？ 第一就是每日选两三句，可以确保能拿下来。 另外一个随着时间的推移，一天两三句，十天就是二三十句。一百天就是二三百句。这二三百句你都要回环熟诵的。这样工作量就大了。 丘吉尔（诺贝尔文学奖）： 背诵麦考利的1200行史记 辜鸿铭（9国语言）： 德语背诵歌德的《浮士德》、英语弥尔顿的《失乐园》 阿西莫夫（最高产的科学科幻作家）： 背诵《伊利亚特》 苏轼 背诵80万字的《汉书》 1.1 学习的本质按照学习的本质定义学习就是捷径 思维训练程序 选择优秀文章背诵，具有永久价值、不枯燥、历久弥新 拆成单个句子，复杂句子拆分成短句 循环往复、循序渐进背诵、默写 理解文章含义 背诵下一句之前，把以往所学背默一遍，遇到卡顿错漏重复背默； 直到这些文章成为自己身体的一部分，随意调遣使用； “不要为你在数学上遇到的苦难感到担忧，我可以向你保证，我遇到的困难更大” —— 爱因斯坦 1.1.1 回环练习顶级数学家如何学数学 “对我来说，没有比数学书更难念了，数百页的书从头到尾念至难念完。因为知道“数学”读懂了，也就是成为最简单不过的事情而已。 所以只念定理。努力想了解它。证明就自己想。而在一般情形之下是想不透的，只好看书上的证明。但是读一两次也不觉得懂，便把证明写在笔记上看看。 这回注意到证明有不中意的地方，就想有没有别的证明法？这样子好不容易读完一章时，前面的部分已经忘了。没法子，又从头复习。这回倒在意起整本书章节的排列方式来。” 这不就是林语堂说的 “回环练习”吗？ 这回倒在意起整本书章节的排列方式来，他发现前后章节有联系的。你从后面的知识能理解前面的知识，你前面的知识可以有助于理解后面的知识。这是什么？ 这就是融会贯通。 短期内突破的思维程序是什么？ 第一点 基本概念基本定义一定要背熟，尤其像数理这样的学科。 第二点 能够独立推导出来的一切可以推导的东西，你一定要独立去推导；而且要推导得熟练。比如说课本上教科书里面有的定理公式的证明和推导，这个过程你一定要熟练的掌握。 因为这些基本定理、基本公式的推导证明过程就是数学思维的核心 什么是核心？ 就是你在所有的数学的阅读理解，读书做题的时候，你会反反复复一而再再二三地运用这些思维方式。 数学最核心的思维操作。就是蕴含在定理公式的推导和证明里面。 所以必须拿下，拿下就意味着，很可能你会达到一通百通的状态。你不知道是第几个定理证明，你熟练之后你突然豁然开朗。 数学原来如此简单；不就是这几套思路反复用对不对？一通百通，效率就大大提升。 第三， 当你这么去做的时候。你去抄写去背诵去默写定义概念，去尝试理解它、去尝试推导定理公式的时候。你会有很多感悟、很多感想。那你把它记下来。一定要将它记下来。这是宝贵的财富。这是你付出努力的一个重要的收获就是你的感悟。你突然发现数学是怎么回事了。数学思维是怎么回事了。把它记下来； 进步本 然后，弄懂的题目要装进进步本里面去； 你不会做的后来会做了，做错弄正确了的。你要放进进步本里面去。去反复的复习。 因为你错了，那意味着你之前的认知一定是有错的地方。 你能把它补上来，还有不会做的题目你弄懂了，为什么弄懂了，一定是之前的概念定义， 要不然忘掉了，要不然是理解错了。现在纠正过来了，为什么不要记录下来？ 第四点 要反复重复做标注，达到不忘达到熟练。就是回环练习。把卡住的地方弄错的地方不断标注强化它； 第四点就是回还往复的循环渐进，用前面的知识理解后面的。反之亦然，用后面的知识理解前面的。达到融会贯通。 “优秀者模仿，伟大者剽窃” —— 乔布斯 牛人都来自模仿牛人 1.1.3 学习=模仿+刻意练习爱因斯坦： 牛顿、麦克斯韦、。。。。 巴菲特： 格雷厄姆、费雪 马斯克： 乔布斯、福特、洛克菲勒 稻盛和夫： 王阳明 松下幸之助 孙正义：坂本龙马、松下幸之助 刘强东： 沃尔玛的山姆博尔顿 1.2 思考题你最成功的模仿经历是什么？ 这就是你迈向高效能学习的一个台阶 2. 让学习成为一种习惯学会一个东西有多难？ 2.1 康奈尔笔记法记录： 在听讲或阅读过程中，在主栏尽量多记 简化： 课后，及早将归纳、提炼记录在副栏 背诵： 把主栏遮住，只用回忆栏复现所学 思考： 记录各种问题、感悟体会 复习： 每周花十分钟左右时间，快速复习笔记 学习会产生生理变化，所以需要反复练习； 2.1.1 康奈尔笔记法跟进步本是什么关系？进步本把记忆法则推到了极端、极致。 比如记录这个环节，把当天所有的进步，知识点、框架、框图、做错的修正过来的。不会弄懂的题目全都要记进去，而且要标注一切让你感到有收获的地方。包括思路技巧方法知识点等等。 然后第二步复习，记在本子上的东西是潜在的进步。那不是你实在的进步，除非巩固住了，那才是真实的进步。 如何巩固住。随时随地的检测式的复习 康奈尔说，通过五步。后面每星期复习10分钟，那是不够的。你要产生极端的效果。你必须随时随地的复习。还要检测式的复习。自己考自己，拿什么叫做随时随地？ 当你回忆起来映像模糊了，你赶紧回去重复， 标注。 包括题目， 题目感觉已经做会了。做会了哪够啊？考试都是计时的，你必须要熟练。熟练都不行，还要高度熟练。那题目反复做做到熟练。然后知识的话就要在大脑里面反复呈现。然后知识的话就要在大脑里面反复呈现。呈现以清晰为标准。 越高水平的人对细节的关注越是变态 天下大事必作于细，天下难事必作于易 —— 道德经 记录 潜在进步，记录当天所有进步，知识点、框图、做错误修正的，不会弄懂的题目 复习巩固，随时随地的检测式复习，随时随地的考自己。题目反复做直到熟练，知识反复在大脑中呈现直到清晰，过程中不断标注，丰富进步本内容 检测发现进步空间 做题，测试。模拟考试，努力去发现还有哪些不会做的题目，还有哪些模糊点，发现进步空间 2.1.2 好的进步本是什么样 第一就是题目和答案要分离，目的是为了方便考察自己。这就叫真的学习，必须这么做。 那么第二点要分析所有选项的正误。知道正确的，但是那几个不对的选项它为何是错误的，你要去分析。一道题知道哪个对是不行，还要知道剩下的为什么不对。假学习浪费生命 分析出题人的意图，一道题目你都要整理道进步本了。目的是什么，目的是你要百分之百的把这个题目都掌握了。为什么会这么出题？这个题目为什么是合理的？它能成为一道考题。出题是很难的，题目本身的信息量是远远大于答案的。还大于解题过程。所以在抄题过程中，要分析它为什么这么出题。如果从题目到解题过程到正确答案全都分析透的话，那你就能够出一道类似的题目。那知识真的掌握透了 一道题，题目写得很清晰。各个选项都写的清晰。还有把这个图也配得非常好。然后正确答案写很后面不起眼的地方。这就非常有利于后面再考察自己； 2.2 学习的根本价值学习的根本价值就是创造价值，一个人将来在社会上立足； 立足的根本就是给别人提供服务。提供有价值的作品，有价值的东西；那么你从学习的过程中就在做这件事情。你想想他的将来的前途如何？一定比好多人都光明的多； 2.3 让学习成为创作艺术从一开始就按照大师的水准要求自己，想要成为顶尖学者吗？那么，学习的时候就要力图写成一本书。 想成为领域的专家，无论是什么领域。只要你想成为顶级专家。当你学习的时候，你就要力图写成一本书。 2.4 笔记的等级为什么说你从一开始就要按照顶级的水平去做呢？ 因为“信念即自我预言效应”，这么去想这么去做。这么实现的可能性就大。如果你一开始笔记都记得乱七八糟的。就不要想成为哪个领域专家。 你从一开始一点一滴的就按照最高的水平去要求自己； 3. 极致心态把能把握住的点滴做到百分之百，每一块砖每一块瓦人生大厦的基础材料你做好。那么后面的各种可能性就都出来了。 99% is the same as zero, if you are gonna do 99, go ahead and stay home -- Will Smith 欲求其上，必求上上； 想取得很好的结果，必须要要求自己达到杰出的、顶尖的水平；你才能有更大的可能性达到你想要的非常好的结果。 能不能达到100%是第二个环节，第一个环节是力图去达到。然后才有更大的可能性达到。 各个领域的高手全都是这样子 —— 对自己要求，标准，目标是极高的； 要去淘汰自己，否则会被对手淘汰。 3.1 进步回路： 记录潜在进步，记录当天所有的进步，知识点 框图，做错修正的，不会弄懂的题目标注一切让你感到收获的地方，包括思路，技巧方法和知识点； 复习巩固进步，随时随地的检测式复习，随时随地考自己，题目反复做直到熟练，知识反复在大脑中呈现直到清晰，过程中不断标注，丰富进步本内容 检测发现进步空间，做题，测试，模拟考试，努力去发现还有哪些不会做的题目，还有哪些模糊点，发现进步空间； 3.2 思考题 在你学业中，哪个环节做到了极致？效果如何？ 哪个环节，你可以做到极致？ 4. 让成就感加快学习步伐4.1 聪明的目标具体 可测量 兴奋 现实 时效 当你把目标做的足够细小的时候，那么这个smart目标就容易设定了。不但容易设定，而且容易达成。不但容易达成，而且容易频繁地体验到成就感。让目标粉末化 比如一句一句学好英语，具体到几分钟之内就完成一句的目标； 4.1.1 实例： 5篇文章那么这5篇文章可以分成五组 5篇（为一组）是一个里程碑 第一组，已经突破，建立自信，建立方法 第二组， 挑战更大，训练元认知 第三组 ， 进入细节，整合到自己的生命 第四组， 浑然忘我，欲罢不能 第五组， 整体回顾，构建强大的知识体系 以前没有完整地熟练过一篇文章，一旦一篇文章拿下来了。那是突破的感觉就形成了，然后就建立了自信。第一篇拿下了，以此类推第二篇也可以拿下来。除了建立自信，还建立了方法。 如何将一篇文章拿下来的方法已经建立了。往后无非是重复一遍再把各个环节精致一下，精炼一下，做到更好。训练元认知； 进入细节，尝试去调用这些文章。假如写一篇新的文章。写作上你能不能用上其中的句子。你要整合到自己的生命里去。 到了第四篇的时候，那可能就是浑然忘我了。熟能生巧。不断不断体验到这种成就感，欲罢不能了。 第五组的话，就是你可以把第五章文章拿下来。五篇文章综合起来，整体回顾。那就能够帮你构建一个强大的知识体系了； 五篇长文，托福级别的长文它包含着很多知识的细节；所以这五篇文章就是一个里程碑 21篇文章200多个句子，就能产生这么大的效果吗？ 4.1.2 书籍推荐《微习惯——简单到不可能失败的自我管理法则》 从很小的小细节小单位做起，它很容易入手；那么行动又促进你的认知，行动产生效果；效果又牵引着你继续去行动逐渐养成了（习惯） 4.1.3 上瘾目标粉末话=频繁体验成功=上瘾 学到了什么 大于 学了什么 学到什么说不清 = 慢行自杀 4.2 思考题 拟定的目标总是达不成，原因是什么？ 你有哪些成功达成目标的经历？（哪些可以继承和复制） 5.构建学习方案， 构建学习方案，增幅学习效果，指数增长 5.1 方案和计划什么是方案 所谓方，药方。能显著解决问题 所谓案， 它要极其缜密，要像破案那样子 实现指数增长的巴菲特 不要亏钱 永远不要忘记法则1 学习也是如此，忘掉的知识就等于亏了吗。所以需要温故。然而一旦投入学习的时候 就会忘记法则一。 新学的东西 - 忘记的东西 = 退步 第一法则： 不要遗忘，就是反反复复的回环去复习。去确保已经学到的东西百分之百掌握了，然后再图进步。 （高筑墙，广积粮，缓称王）（结硬寨，打呆仗） 第二法则： 永远不要忘记法则1 5.2 三小时见效的数学课你觉得数学这一科里面哪个专项或哪一章哪一节是你的弱点；别选最难的，选那些花一些力气就能够见效果的章节。 把这样的章节的题目分成5组或6组，每组5道题或者6道题。分组练习，每一组都用这个进步本的方法。6道题做下来，发现错了3道。要详细把这三道题目整理下来，你到底从这道题里面学到了什么。不管是请教同学还是老师，把题目弄懂，这些为何自己不会 以及后来听懂之后的思路原原本本记录再进步本里面。记录的过程中就是熟练的过程，加深记忆，加深理解的过程。然后这三道题整个梳理完之后，你要重新做一遍。那叫做进步本的复习和巩固环节。 虽然通过这个读答案或者听同学讲明白了，但是你独立的重新做能不能再做出来那是两回事。你必须要确认你能够做出来。这三道以前做错的题目或者不会做的题目。你真的弄懂了会做了。然后你再进行下一组的练习。下一组的五道题或六道题目去练习。那么在大多数情况下它是一定有进步的。 比如第一组只有50%的正确率，那么第二组就70%的准确率了。第二组依然按照这个回路迭代。就又掌握了一些解题技巧，方法，思路。你再巩固再把之前的你做错的部分再重新做一遍。不单要记住，而且要熟练，还要去理解，增加这个熟练度。然后你再进行第三组练习。因为题型很少。随着组数增多，正确率会可预见的提高的； 内心感触是什么？ 是知识高度清晰了，而且高度熟练。然后信心油然而生就这样一个过程。 一天之内实现学习越迁 巩固所学，永远是最重要的 划分明确的专题 分组练习，力图达到100%正确率，实现越迁 5.3 思考题 如何可持续的跃迁 如何体验到熟练掌握知识的感觉？（对于没有100%掌握过一个东西的人来讲的话，他很难有学到一个东西的感觉。就学习的高级状态是什么他很难体验到，这个只能通过自己努力实现了） 6. 构建增长引擎我不断地看到有些人在生活中越过越好，他们不是最聪明的，甚至不是最勤奋的，但他们是学习机器，他们每天夜里睡觉时都比那天早晨聪明一点点； —— 查理芒格 机器的本质是什么？ 持续运转，而且可以组装和改进它；那么对于人来讲，实际上本质就是一套思维的程序。 6.1 学习算法学习算法可以称得上是终极学习方法的一个算法，一旦掌握，那我们对自己的人生的发展趋势就能够有预判。 这个核心算法是什么呢？ 三个环节 第一： 我们每个人无论遇到多么复杂的知识和技能，一定能学到其中的一点。尤其是最开始那一点。一定能学会的。 第二： 我们知道如何学会，学会的过程，哪怕是一个很微小的点。要知道如何去学会， 然后第三个环节，是学会的东西。不要再忘了，就不断去巩固它。通过巩固，别再遗忘然后再把这个学会的过程类推到学更多的东西到下一个 比尔盖茨 如果你指定一个明确的目标，并且找到一种能够朝着目标推进的计量手段。就是某种反馈回路那样的计量手段。他说： 你就可以取得不可思议的进步。 对应上面的内核引擎，尤其对于数学物理这种理工科的知识，它是层层递进的，是个大厦的结构。做完前一个，才可能学到后一个，那意味着什么？就是你是不是真的学到了一个东西是能够得到检验的。当你前一个东西没有把握住的时候，前一个知识点没有掌握的情况下，你不可能往前推进的，你只要往前推进就意味着你掌握了前面的东西。所以，这构成了一个明确的回路。 另外 这是一个计量手段，一章一节你是用多长时间完成的？然后完成了多少题目？这里面含了多少个知识点，重复了多少遍？这都是可以计量的。一旦你有这个量化的形式来度量自己的学习效果和进步的速度。那你就可以去改进它，不断去改进它。这就是很多人在用的这个手段。一种工作 学习高效能的手段。 ok 那我们看这个进步本是不是也满足这个条件？ 进步本就把刚才那个核心算法把它给升级了，就在那个基础上做了一个升级。升级到我们学习过程中更宏观的三个环节。 比如记录，大家所有人都在做记录是吧？听课笔记，读书笔记等等；我们只不过是在进步本里面要求把这个环节做到极致； 首先呢，就是任何一点你感到有收获的地方，把它记下来。无论是知识还是题目还是框图等等。 第二呢，是全部。你只要是能记下来的东西，你都要把它记下来。 然后是复习，所有人都在复习。只不过我们把它推到极致了。你学到的东西不要再忘记了。 通过什么方式复习，就是检测式复习。随时随地考察自己。如果是知识的话就是大脑里面回想。如果回想不清楚的话就说明将要遗忘了。就马上要重新翻笔记。如果是题目就重新做，如果说是回忆起来这个题目，有个思路，但是详细的细节想不起来了。那你原则上是要重做的，达到熟练。最后让这些知识和题目在大脑中达到清晰。这是复习 然后呢，第3个环节是检测，我们每天都在做题目，各种测试。关键是你要把那些模糊进步的空间给找出来，你下一步就可以专项突破了。专项突破的话一旦突破了就实现了一个里程碑。那么这个寻找进步空间的过程中。就又发现了一系列你学到的东西。又进行记录等等。这样的话，这三个环节就有效的首尾相连，连在一起。形成一个正反馈的回路。这里的关键是，它是可以量化的。 比如我在高中那一年，平均每天20页。按320天来算的话，就是6400页。如果说内容都掌握了。那肯定是你考试的时候是很难紧张起来的 那这个进步本的回路呢，实际有两个回路，一个是认知回路，知道自己为何这么去做。 原因是什么？原因呢就是你踏踏实实的这么去行动。要产生效果也只能这么做。为什么？你想想再好的效果 都是由一点一滴的那个小的成就构成的。 这个进步本就是在把握一点一滴的这个小的成就。小的进步，知道它的原理是什么。知道所以然，然后就可以踏踏实实的行动了。 然后，付出行动之后又有行动回路。一旦这么去做的话，那个效果是很容易检验的。以此类推做知识管理。 6.2 再说进步本当时为什么对进步本这么有信心？ 不是说，要怎么说服自己。而是直观的效果告诉我。它说一个高速进步的方法。而这个检测的时间并不长。一周的时间都可以检测出来了。拿它来攻克一章的内容。那顶多也就一周的时间，看上去以前从来没有达到过90%的正确率。 如果你的学习闭环了，你从怎么操作，怎么去认知它到产生效果，能够封闭起来。一个环节 促进另外一个环节。旋转起来，那么考试是很容易上瘾的。 能用进步本的时候，再考试的时候。一看到某些题就知道一定能拿下来 就不再有焦虑了。因为太熟练了，头脑高速清晰。能拿到的一定能拿到那个分数。拿不到的分数，那有些题目却是没思路吗。那就意味着进步空间呀。在考试结束的时候你把那几个不明确的。没把握的题目 将专题明确下来。 用专题突破的方式用进步本来突破。很快就达到90%以上的准备度和熟练度。不断扩大疆域，一个月以内就把整个心态完全扭转了。考虑不单单是衡量掌握知识程度的这么一个定量化的方法。也不仅仅是因为学习方法的选择，改进提供标准。也不仅仅是让我们学习上瘾/而且能够综合锻炼人的一系列素质。 如果你对学习的本质 有深刻的认知的话。考试实际上是一个难得的机遇。 珍惜有考试的高中啊，考试就是反馈啊。可惜，人生再也没有了； 在职场里面，你自己一旦把这个方法明确之后，那它时时刻刻也在给你提供反馈。那么学习增长引擎和企业增长引擎是同样的本质。都是正反馈回路。 比如亚马逊 增长飞轮。它核心是为了增长。为了它的价值增长，用户增长。它有几个环节构成的闭环。比如它提供了一个平台。很多商品供用户选择。然后极可能把商品介绍周全。图片评价，然后，他就再去精选供应商，稳定的供应和优质的产品。 6.3 思考题 你的学习增长引擎是什么？ 你的人生增长引擎是什么？ 7. 费曼超级阅读法两个基本问题 掌握专业知识的最大障碍是什么？ 克服障碍的方法是什么？ 专业知识难，难学、难以掌握为什么？ 因为它的知识密度大，信息密度大； 随便看一篇小说，特别顺畅，特别享受，就是因为里面的知识密度、信息密度小； 专业知识，那里面包含着大量位置的知识； 杨振宁说数学包含两类，一类是你读不过第一页的，另外一类是你读不过第一行字的； 读不过第一行就是因为知识密度太大，很难理解； 而解决这个问题，就需要 费曼阅读法 “你从头读，尽量往下读。直到你一窍不通时，再从头开始。这样坚持往下读，直到你完全读懂为止。” 这个方法有很多值得挖掘的地方 它能保证你持续的推进；（即使第一句就卡住，你就第一句多读几遍直到完全理解。甚至还要把它记住。概念定义这种东西，定下来的意义 就是这么定的。 大家约定俗成的 是约定下来的这么一个东西。也是经过很多检验的。） 不断产生成就感，（一旦第一句理解了，后面第二句依据第一句的含义多重复几遍也能懂。 懂就是一种成就） 人咸谓板桥读书善记，不只非善记，乃善诵耳。 板桥每读一书，必千万遍； —— 郑板桥 读经有一 “耐”字决，一句不通不看下句，今天不通，明日再读，今年不精，明年再读，此所谓耐也； 7.1 为学 的品质“为学” 的品质是什么呢？ “初有决定不移之志”就一开始就要有决定不移之志，我不拿下它决不罢休就这种。 “眼前就这本书，就一本专业的教科书。你能不能把它拿下来，彻底拿下；拿下的标志的话就是你能够从头到尾跟人家讲明白。然后题目拿到了90%以上 接近100%的正确率你能不能做到” ok 下决心做到的那就是“初有决定不移之志” 中有勇猛精进之心 就是因为你这么折腾 这么做的话，做着做着你会烦。你会觉得有点慢。尤其初期的时候这么做好慢啊。人家都读完一遍了，我10/1还没读完，你就开始焦虑了，开始着急了。开始想入非非，胡思乱想了。所以要勇猛精进。这一套方法 一套思维程序你把它贯彻下去；到了一定阶段一定的深度，才会有豁然开朗 如果你不是勇猛精进，那再好的方法，你每天就10分钟这么弄一弄 10分钟弄一弄。那你一年也拿不下这一门专业课。勇猛精进就是不但要贯彻这个方法。而且还要去推进它 不断地推进更多一点；既要巩固又要往前推进 末有坚贞永固之力 一门课，80%这么干了。但留了20%的尾巴。无论什么原因，你没做到底，你就浪费了。 “记住知识就是力量，别人不学，你要学，不要随大流。以后有能力要帮助弟妹” 背负这种重托，我在当时的环境下，将樊映川的高等数学学习题集从头到尾做了两遍，学习了逻辑、哲学。还自学了三门外语，当时已经可以阅读大学课本的程度； —— 任正非 7.2 思考题 你是怎么读书的？ 你读书的榜样是谁？ 8. 记忆任何知识记忆任何知识，打造超强度记忆力 前5分钟看的知识点，后5分钟开始模糊。 欣然接受这个事实，然后采取果断的措施，去对抗住那个遗忘； 8.1 记忆困难的根本原因 记忆困难的根本原因是什么？ 如何记住一堂课的内容？ 8.1.1 艾宾浩斯遗忘曲线“学一个新东西 一个完全陌生的东西。20分钟之后还记得多少；” 大家都知道艾宾浩斯遗忘曲线，可是没有几个人记得住艾宾浩斯遗忘曲线的具体数据； 这就是问题所在，大家都在学习模糊的东西。谈起艾宾浩斯遗忘曲线，都说知道这个概念。但真正有用的知识就是一些细节，比如艾宾浩斯遗忘曲线的那些重要参数； 学霸 他知道这个原理知识遗忘是如此残酷，20分钟接近一半都已经忘掉，那怎么办？赶紧复习，随时随地复习。 没等忘了很多了就赶紧把它捡回来了，一次一次这么去做。那么他对遗忘的知识都保持着90%到100%的这种准确性 精确性，对于理解后面的知识 那就容易多了 随时随地，高频回顾 记住任何东西，我们的神经结构都会发生改变， 想要达成这样的变化只有两个办法 一个是高频的刺激， 另外一个是增加刺激的强度 那么最简单的容易操作每个人都可以做到的就是增加刺激的频率；只要一模糊就开始复习； 当你一天之内要把一个东西记住的话，就是相关的这个内容会存储在同一个神经元区里面。但你如果是超过24个小时的话它放在不同的神经元区里，那样调取一定很艰难。所以结论就是如果你真的想要记住什么请在一天之内完成。复习周期绝对不要超过24小时，否则你的这个记忆的生理的效果都不一样。 原则上我们可以用无穷无尽的能量和时间都烧不开一壶水， 烧个四五十度你拔掉 凉了再烧，烧了再凉。永远烧不开。 不断拔掉电源= 无穷时间和能源烧不开一壶水 8.2 如何记住一堂课的内容 随时随地，高频回顾 丰富联想，从上下文到相关知识 8.3 思考题 你有没有测试过你自己的遗忘速度？ 你用过什么方法有效巩固自己的记忆？ 你要亲自发现遗忘的残酷性，光知道艾宾浩斯遗忘曲线那还是二手知识，它是第1手的科研资料对吧。可是对于你来说你真正想要把学习这件事情拿下来，真的要成为学霸、学神你必须要建立你第一手的这个切身体验。自己发现出这个事实来。而且这个很容易嘛并没有多大的障碍。 9. 高效提升分数经历者分享 “我必须三天内准备好个人材料和笔试考试，一天时间准备好综合面试”。 首先，拿到了近5年的真题了。她要百分之百掌握。她是这样操作的。 一些看不懂的真题，短时间内无法理解。就死记硬背下来在纸上默写答案。凡是重要的，确保100%的掌握。 把这个量拿下来，她说“她曾经刻意练习过的认知能力又回来了（之前练过，怎么去100%把握一个东西，然后坚持下去）”。 2天时间掌握了整整5道题，都牢牢把握了。然后怀着淡淡的期待和自信去考试。 这两天究竟发生了，为什么可以从非常焦躁转变到得心应手。 终极学习法：核心算法 学会（下）一个 知道如何学会 回顾不忘、类推 进步本 进步本要复杂一些，稍微复杂一些把这个圈画大了一些。它的原理是一摸一样的。 总之 你学到了什么东西，学的过程是怎么学到的。你要搞清楚了。无论是题目 还是知识点、文章等等。还是什么思维框架、知识回路、知识地图等等这些。弄清楚之后你就可以以此类推了。只要是能把之前学到的都巩固住，那么越推越快，触类旁通。 9.1 思考题 你的学习思维程序是什么？ 如何检验自己的学习思维程序？（参考上面的23天历程，他就是在检验自己的学习思维程序。这么做究竟行不行，能不能拿下来。你最终拿下来之后思维程序究竟是什么。ok，他一旦发现那个东西是有效的。那就可以一直用，他的其他的科目也可以这么去做。按同样的套路去做，然后你心里面就踏实了。只要这么去做就能把它拿下来而且是彻底拿下来） 10 如何提出好问题惠勒提问法 提出一个好问题，就是高效学习法的一个重要环节； 那么，如何提出一个好问题来促进自己的学习效能的跨越式提升呢？ 10.1 为什提问是高效学习的利器提出一个问题往往比解决一个问题更为重要，解决一个问题也许是一个数学上或实验上的技巧问题。而提出新的问题、新的可能性，从新的角度看旧问题，却需要创造性的想象力，而且标志着科学的真正进步。 —— 爱因斯坦《物理学的进化》 问题会让人思维集中、欲罢不能； 解决问题，比如对抗艾宾浩斯遗忘曲线，意味着去巩固这一块的知识点需要不断重复记忆。而重复记忆相当于一个技巧； 而提出问题，比如为什么会存在艾宾浩斯遗忘曲线这种东西。那解决这个问题，可能涉及生物学，人体，神经学等等学科。再解决这个问题的话，所需要的知识维度就远远超过艾宾浩斯遗忘曲线本身了。而此种问题的解决，可能真正的会改变现有的科学认知。 10.2 什么是好问题 能找到答案的问题 一旦得到解答就能扭转局面； 别人不曾提出，或者不曾给出好答案； 学习是为了什么？ 进步，否则都是幻想，而且不断受挫，陷入思维混乱和负面情绪； 今天进步了多少 测量，（进步本里记下了多少知识、改错和弄错的题目），否则是糊涂 今天哪里有进步 新学的知识点，改错，原本不会弄懂的，否则就是糊涂 今天的进步能不能保持住 随时随地复习进步本，周期性的重做，检测性质的重做，再标注。每题完毕回顾检测，每科完毕回顾检测，每天完毕回顾检测 如何加速进步 更多的进步本内容，挑战更难的题目 如何检验进步？ 回顾，做题，大量的测试，模拟考试，查缺补漏，寻找新的进步空间； 进步的本质是什么 一步一步的，把不可能变成可能； 学习的本质是什么 基于模仿的大量练习； 有没有彻底掌握 有，否则，重复上述过程 （随时随地问自己）有没有自我欺骗？ 没有，否则，一切都是徒劳 “等你真正理解了问题，你会想出很多复杂的解决方案，因为它的确错综复杂，大多数人止步于此。但有少数人会继续在午夜冥思苦想，最终理解问题背后的深层规律，找出简洁优雅的解决方案，但是，能走到这一步的人太过罕见；” —— 乔布斯 10.3 如何提出好问题 不断提问 把你寻找到的答案记录下来 与别人的答案做比较，迭代改进 10.3 高效学习的“天问”你究竟学到了什么？ ​ 如果不如意，那么学习方法一定有问题，寻找方法 在刚刚过去的5分钟里，你究竟学到了什么？ ​ 如果不如意，赶紧回顾； 11 .费曼终极学习法读一本书，尤其是专业书籍。从头开始读，哪儿卡住了就从头看。再回顾从头复习，一步步向前推进。 11.1 费曼技巧他怎么能够对一件事物产生深度理解的 分为四步 凡是你想学什么，那你选定一个主题。把相关材料收集下来。 基于这个主题和这些材料，学会了。尝试要讲给外行听。严苛条件下，是要给一个孩子都讲懂 你会发现鸿沟，就是你跟别人说不清楚。你自己以为理解了一个东西。但是别人听不懂。原因是什么，原因就是你自己并没有真的掌握它。或者说理解的深度还不够。 回过头来深入研读那个材料，当你研读完毕之后，再讲给外行听。还可能 讲的过程中你又发现 做不到。你自以为这次可以给，外行讲明白了。结果发现还没想明白。那继续再研读。因为自己还是没掌握嘛。 这个不仅是个学习的过程，更是一个创造性的过程。 讲过外行听，有几种方式， 最常见的方式，就是通过语言来说，给别人说通了，说明有超强的沟通能力，演讲能力。演讲能力这个东西， 一篇演说就是一个作品，比如乔布斯要把复杂的手机给普通消费者讲的很清楚明白，尤其是当时那个塞班主宰智能机的年代，他需要多少遍的演练呢。 另外一种方式，是写成文章，写成书，写成教科书。写成一篇说明性的文字。 11.2 学习金字塔 主动学习优于被动学习 教是最好的学 教给他人，学习效率90% 创造作品，效率超过100% 12. 在大脑中形成知识框架它的核心操作就是在大脑中复现所学的内容， 所谓复现，就是当你第1次看到一个知识或者一幅图，一段文字的时候。你在大脑中立即是有印象的。 在大脑中呈现知识为什么重要？ 如何在大脑中呈现知识？ 如何在大脑中实现知识进步？ 把高效学习者分为七个阶段 如何面对“不知道” “做”中学 意识到很多问题没有答案； 勇猛精进的行动； 知识和技能的视觉化 把知识解释给孩子听 能用一句话归纳 在大脑中复现知识，那是一种极其高级的学习能力、学习方法、学习技巧。也是一个极其高级的学习阶段。 核潜艇之父 第一艘核潜艇是如何造出来的； “从一无所知，到模型，到实战武器” 一个关键的转折点是什么？ 就是这些老一代的科学家从六七十年代拿到了一个模型（外国的核潜艇模型），是作为玩具模型买回来的。如获至宝 为什么？因为这个玩具模型它是可视化的。可视化，它就包含着大量的信息在里头。形态啊，这些都是非常细节的信息的。 《刻意练习，如何从新手到大师》 心理表征是专家和高手的特质 当我们说心理表征是指当我们谈论XX时你心里面浮现的那副画面时，请记住： 画面完全等于心理表征，这个谈论XX，然后浮现出一副画面，以及画面的具体细节这整个呈现方式才是心理表征； 表征是知识在个体心理的反映和存在方式。按知识的种类及其提取方式，心理学家认为人类至少有四种类型的心理表征：认知地图、心像、图式和心理语言。 12.1 心理语言心理语言就是你怎么把这个图像呈现出来的这个过程，你自己的一个描述方式，那叫心理语言。 比如说，我先从哪儿想起。我想起这个东西的时候，它怎么一步一步得变清晰的。每个人都有自己的表达方式，那是心理语言。 我们说到咱们具体如果是应对一场考试，或者在学一个很复杂的知识。任何复杂的知识，它本身都自成体系，它是高度有序化的。我们觉得混乱，那是我们尚未把知识明晰化的一个过程。 比如，数学。它有很多分支，有几何，代数还有什么方程，微积分，三角学，函数学等等。每个分支都有很多细节。 那么 你优先做的是什么呢？ 优先做的是从那个分支的核心概念出发，那个核心概念是怎么引出来一系列的子概念。一个核心命题怎么引出来的一系列的子命题。把这个一条线一条线的走清楚，一个局部，比如三角学这个局部。走清楚，那几条主线。（12345 五条主线就出来了）每条主线后面又增加了几个分支啊。这个细节 知识的细节 都悬挂在这个分支上。然后你就一步步形成了所谓的知识框架。 12.2 知识框架知识框架用一个形象的类比来讲，就相当于我们家庭里面的衣架一样。它可以悬挂很多东西，（帽子，围巾，大衣等等）如果没有这个架子，那东西只能乱堆乱放了。 知识框架所发挥的作用就是让你的知识高度有序化，使得你那些零散的知识能够被分门别类的放到大脑里面去，放进去的话。你当时就会觉得没那么混乱，不那么乱，提取的时候呢，就提取性能高 效率高。 12.2.1 知识框架的做法是什么第一步，优先参考已经有很好的知识框架。现在我们参考书里面很多。参考数据都已经梳理好了，树状图，概念图等等；那你就照抄。一个部分一个部分捋清楚。哪怕是默写的，也要把它记住 然后在大脑里面，一部分一部分地清晰地去成像。 然后排列组合，最终是形成一个完整的知识结构。如果不去做，那么知识会一直处于一种混乱的状态。 实例：一张很庞大的知识地图呈现在眼前的时候。第一眼看漂亮，很庞大。 第二眼就晕了，这么多细节 是吧？心烦意乱 心理得有一个信念，一个大概的估算。对自己能力的一个判断。一次画不出来，那就分100次去画。可能在第49次 就已经能完全能够复现了。重复直到知识在心中清晰化。 在学习一个知识的每个章节的时候，都要去这么梳理。梳理的最终的结果是在大脑中。呈现出这个清晰的知识框架。而不仅仅是在笔记本里面捋清楚了。那等于说是没有把水烧开。不做到百分之百的精准在脑中成相，那几乎都算是半途而废的。等到每个章节都如此做了，后面系统学习就是拼接积木了。 最核心的那个几块板，是积木状的拼在一块。拼图装的拼一块的，它要求最简洁最高效的做法就是你每学一个知识章节的时候，就把它做精准了。呈现的清晰，然后不断的去复习巩固它。一个模块一个模块累加下去，后面就呈现出一个极为壮观的知识框架图。它不光光是提高成绩这么简单。你的享受远远超过了你分数成绩的提升。 12.3 思考题 你的大脑中有哪些清晰的知识？ 如何让你的知识清晰化？ 你的学习路径清晰吗？ 13. 案例加强理解用案例说明一个知识 13.1 如何理解一个知识？13.2 什么是真知识/假知识？普朗克的司机演讲普朗克最新量子物理理论研究的故事；（故事省略） 世界的知识分为两种： 一种是“普朗克”知识，它属于那种真正懂的人，他们付出了努力，他们拥有那种能力。 另外一种是司机知识，他们掌握了鹦鹉学舌的技巧；他们可能有漂亮的头发；他们的声音通常很动听；他们给人留下深刻的印象。但其他他们拥有的是伪装成真实知识的司机知识； —— 芒格（南加州大学演讲） 关于这个故事，还会不会有一些其他的启发； 司机为何如此有自信敢上台讲演高深的量子物理知识；他是如何做到的。这其实也是一个顶级的学习技巧； 第一次，可能只记住了其中的某些小片段，某些关键词 题目；其他的内容都模糊不清了。 第二次，再有机会陪普朗克去演讲的时候他听的更仔细了；把遗漏的，不太明白的。不断重复 中间重复多少遍我们不知道。 一个精深的、刻意的练习才能达到这种鹦鹉学舌的水准。然后我们就不会轻视这个司机知识了，很多人都不具备这个能力。 我们具备哪些司机知识，你具备什么司机知识；往往一反问就把对方问住了。我们也会对这个司机刮目相看，肃然起敬。 哪怕是具备的所谓“司机”知识，已经很难； 一万次练习定律 然后具备真知识 反复运用一万次练习定律 另外，这个司机掌握着学习的巨大潜力。觉得这个（演讲）挺好。演讲受大家欢迎，受大家尊重就感觉不错。这满足了极难获得的高度成就感，对于此刻的这位司机学物理学理论就变得非常简单。为什么？ 他可以把鹦鹉学舌的演讲这个过程，原封不动照搬从头开始学起（物理学） 诀窍：1万次练习定律 所谓1万次练习定律不是精准非要练1万次，就是练很多次数 刻意练习。 有意识的以提高自己的水平为目的的，练习、模仿、校对、标注、标记。在大脑里面复现这个过程。次数达到一定阈值的时候，根据个人的基础不一样，突然某一个点你对那个知识的印象，豁然开朗。所以知识是什么呢？ 就是包含了案例和里面的基本概念和基本的命题、基本的结论。 从一个知识点可以衍生出很多知识点，从一个案例可以衍生出很多案例，很多知识出来。 所以，从普朗克司机这个故事里面能读出很多东西。真知识和假知识，联系到一个人奋斗的一个阶段。怎么去步入更高的极端。 所以用一个案例精准的去理解一个知识，这个过程可以把它扩展。如果就这个案例你记忆清楚的话，多问几个问题并设身处地的从故事的形象 这个故事在大脑里面呈现的这个清晰的形象。从形象里面一个一个的提问题。然后就引出了各种各样的可能性的解答。而这些解答就会携带出各种各样的知识出来。 13.3 思考题（作业） 你能清晰描述的案例有哪些？ 根据这些案例，你还能挖掘出哪些知识？ 14. 用题目增进理解从越少越好到多多益善 任何领域的高手，他的训练 一定经过两个阶段 第1个阶段是 越少越好 第2个阶段是 多多益善 好多年以来的一个核心话题 题海战术到底是好还是坏？ 为什么有人注重少而精 为什么有人注重多多益善 二者矛盾嘛？ 对于顶级高手而言，两者毫无矛盾。而是分不同阶段的； 马太效应造就的天才——费曼 “我记得那是在中学，在第一节课的时候，有个家伙拿着一个几何难题，或者他的高等数学作业里面的什么玩意儿凑过去。我不把这个该死的东西弄出来，我是不会作罢的——这要花费我15到20分钟， 但是在一天当中，另外这些家伙拿着同样的问题来找我，那我一眨眼就给他做好。而另外五个家伙认为我是个超级天才” 因此，我得到一个虚名，在上中学的时候，人能知道的每一个难题，都一定会弄到我这儿来。人所发明的每一个该死的、疯狂的难题，我都知道； “一开始是他也要 很费劲的把一道难题给解出来，可是后面的你，大家老问他同样的难题” 所以，天才的背后。意味着同样一道难题，他实际上已经做了6遍了。 费曼学习法精髓 凡我不能创造的，我就不能理解； 解决每一个被解决了的问题； 他对自己的理解，定了一个极高的标准。一个知识他要重新把它创造出来，这才能说明自己理解了。一个知识从底层逻辑到上层原理都了如指掌，甚至知识产生的逻辑都很清晰。 解决每一个被解决了的问题，你就把你要学哪个领域？他把哪个阶段所有问题穷尽了。每个问题都解决了，那这显然就是多多益善。但多多益善不是盲目，“每天都在刷题，从头到尾刷。” 不是这样的，他是经过了精益求精把一个知识通透了。然后自然过渡到多多益善。 多多益善为什么是自然过渡呢？ 因为那已经成了乐趣了，刷题的乐趣刷出来了。所以呢，就是好多人那种矛盾的纠结就自然而然解决了是吧？ 少而精呢？ 所以说少而精和多多益善根本就不是一个选择题。 如果说你想要精通一门知识 考试要拿极高的分数，那必须经历两个阶段 第一阶段是精做，题目要精做；题目本身你要能背下来。都能记得，就是你可以 在黑板上。不用看草稿，不用看自己的笔记，就展示一道题目。然后这个题目的解法是什么。就能通透到这种程度。 第二阶段就变成了乐趣了，在猎奇。看看还有什么样的题目自己没见过的。 14.1 总结首先是精做，熟悉它背后的套路。题目的套路，知识的基本逻辑。基本构造，精通了之后那后面就是玩耍。否则呢，绝大多数的情况呢，题海战术，做很多题目。你外表看起来跟那些高手一样是吧。但脑子一塌糊涂，浆糊。心乱如麻。 达不到那个效果，就为了做了很多题目要做很多题目那是不行的。 他们是为了 更加丰富的去理解，更加深刻的去认知那些数学原理。 第一，质永远比量根本 用了11个小时，才完全掌握了一套数学卷子。 第一遍，3小时模拟考试 第二遍，对答案然后改错 第三遍，从头到尾分析考点，自己解题的障碍，把没有记住的公式或定理，完全弄懂后整理在进步本上。 第四遍，在A4纸上重做试卷，选择和填空也写出详细解题步骤，并在要求自己的解题步骤和标准答案完全一致，书写工整干净 全身心投入11小时，才完全掌握一套卷子，但是真正学到知识的满足感和踏实感让我睡了有史以来最踏实的觉 第二，保住质的前提下，多多益善。 14.2 思考题 你的题海里有没有透彻掌握的题目？ 你梳理那掌握的题目有多少？ 15. 从知识点到思维之面 大脑中的知识点零散怎么办？终极原因是你的大脑里并没有清晰的知识点 15.1 解决办法办法一： 深入挖掘一个点，挖出整个网络； 勾股定理现约有500种证明方法，是数学定理中证明方法最多的定理之一。当了解这些定理之后才发现。整个高等数学的知识几乎都被用上啦； 让知识点在大脑里面高度清晰 费曼爹教费曼读大英百科全书，有一次念到恐龙。书上说“恐龙身高有25英尺，头有6尺宽”父亲停顿了一下说 让我理解一下这是什么意思/ 这也就是说 要是恐龙展在门前 的院子里，那么它的身高足以使它的脑袋凑着咱们这两层楼的窗户，可它的脑袋却伸不进窗户，因为它比窗户还宽呢。 他总是把所教的概念变成可触可摸，有实际意义的东西 费曼从父亲那儿学会了“翻译”——学到的任何东西，我都要琢磨出它们究竟在讲什么，实际意义是什么。 费曼与欧拉公式 费曼在笔记上，把欧拉公式从各种角度，各种方法证明了一遍。后面再列举欧拉公式的运用。至此 欧拉公式在费曼眼中再无秘密；他是按写一本书的态度去做笔记的。 翻来覆去的看，对于二重积分，联合分布，联合概率分布，卷积公式等此类题型会涉及到积分上下限。下限是什么，上限是什么。总是迷糊，老师给的口诀也不是长久之道。 后来不断琢磨，从他最原始的定义出发，一遍一遍的演绎，在我重复了5遍的时候。终于有那么一刻，一切变得如此之清晰。终于不会再出错了； 以上得到的结论，他的做法分为两个阶段 第一阶段要去默写基本概念 基本定义，默写的目的是要牢记，100%精准的把它记住；这样子才能有后面的有效的应用；在默写的过程中增强记忆； 第二阶段是推导，推导的话就不是机械性的了。而是理解的过程，掌握数学思维的过程。推导多少遍呢，推导过程中反反复复琢磨了5遍以上； 如果想要在某个学科上，能快速的去学习，快速的推进。取得高分的话。没有第二条路；只能这么去做 办法二： 抓住核心概念主导的核心架构 文科学科的例子，但是对理科学科也是相通的； 《历史研究》一书提到文明兴衰的规律是 “对内外部威胁的这种应战的成败决定的”； 还有对有限之物的崇拜！ 你通过一个有限的东西想要去解决那么多错综复杂的问题，还有那么多各种类型的层出不穷的危机、明显做不到嘛。你固守着一个东西做不到的话，那后面就死掉了，所以这个结论非常深刻。 因此，整本书 虽然很庞大， 但核心架构 如此之简单。你只要把握住了这个核心概念； 办法三： 通过模版，构建自己的思维 《连城诀》，《肖申克的救赎》 与《基督山伯爵 》 底层逻辑几乎一样； 越狱，财富，获得财富，获得自由 是因为有基督山伯爵这个模版的存在。这个 经典著作就成为他们写作的一个思维模版； 如果我们想让思维清晰，就必须要有这样一个模版。这个模版是什么呢？ 这个模版就是课本里面的这个公式定理的推导过程，还有例题，它就给你提供了思维模版。对于文科生而言的话就是它这种叙事的结构，一个概念提出的过程。以及概念应用的过程。 怎么通过事件去说明；所以把一章一节的内容通透了，后面每个章节都在用同样的思维方式在演绎。 15.2 思考题 哪些知识点是你明确掌握的 这些点之间有什么关联？ 你有自己的思维模版吗？ 16. 融会贯通，回顾为什么你的知识零散，而专家可以滔滔不绝 为什么你学到的知识用不上？而专家可以学以致用 一个例子： 他问牛顿，你取得这么大的科学成就，做出了这么多的发现。有何 秘诀 牛顿曰： 秘诀就是我把问题呈现在大脑里面，持续反复的思考。反反复复的在大脑里面知行合一。 首先在大脑里面折腾那些知识，那些问题。把知识和问题之间建立链接，深度链接。这些问题有些时抽象的，有些是实用的。 秘诀很简单，但是做不到，但牛顿能做到，不但是有效果 而且奇效； 另外一个例子： 关于考试，从惧怕到期待 学习的本质就为了进步，为了变强。 踏踏实实的稳扎稳打地掌握住所学的知识，不断复习它，不断巩固它。把握住他 然后融会贯通。这个过程中对考试就会有所期待了。因为考试是一次检验的机会。它可以帮助自己知道 到底还有哪些地方是薄弱的，然后发现考试是一种非常重要的学习方法。那么甚至后来对考试居然会上瘾。 16.1 测试效应考试测试不仅仅是检测手段，而且是正确的学习方法； 测试有助于提高参与者的长期记忆力 一旦想要形成长期的良好效果，光看算法的解题分析是没用的。反复看，就这种动作的效果就比较低了。更好的做法是你读一次之后立即就要做记忆默写这个测试，赶紧考试自己。学习，考证等等 只要你想取得长期的更有效的效果。那么你做完之后，立即要考自己测试自己。看自己能不能独立的推导出来，往往这个时候就卡住了。然后发现不是这里错了，就是那里漏掉了。 所以，测试不仅起到巩固效应，它对形成长期的记忆也是有帮助的。而且它可以避免假学习。 如何高效运用测试效应 随时随地复习，随时随地考自己 考试不紧张 高频、高强度的刺激神经系统，加速神经系统重塑，巩固记忆，加深理解； 测试效应的深层次原因， 我们说提升记忆，有两个点。第一 提升刺激强度，第二 提升刺激频率。这个测试对应的是 刺激强度； 学习 = 重塑神经系统 = 重塑生命 学习等于重塑神经系统，等于重塑生命； 巴菲特的投资秘诀 法则一，别亏钱 永远不要忘了法则一 16.2 漏斗效应失败发生在每个瞬间，而非结局 为什么执行0%，因为记住的只能20%，他理解不了为什么要去那么做。因为80%的东西都已经忘掉了。 这个问题结合自己来看，有的时候觉得我自己看这一页书看懂了，其实不然。默写看看，可能最终知道的只有很少一部分。我们不断的背视觉欺骗； 那么如何遏制漏斗效应？ 答案是“测试效应” 16.3 说不清学了什么说不清学到了什么（而非学了什么） = 慢性自杀 我究竟学了什么（学习的终极问题 高频回顾+高频回测） 挫败，思维混乱，发现真相 ——》 把握住能把握住的点滴，循序渐进，融会贯通 平时用习惯了，看书听讲座听课等等。我一天学了多少个小时。但是不能对学到了什么能够123456这么说，说不清楚自己究竟学到了什么。那就是在慢性自杀。看了一天的书，没学到任何东西。可不就是荒废了时间。 如何遏制？ 那就是把握住自己能把握住的点滴，循序渐进就能融会贯通。 把握点滴之间，你还要反反复复去想。把这些点滴凝聚在一起。再去把握新的点滴。聚点滴成江海。 那么它的导向的实际操作是一个严酷的操作一定是高频的回顾。高频的运用测试效应。荀子的《劝学篇》就是在讲述这个道理。他背后包含一个非常绝的学习秘诀。 还有一个结论是 平庸的人追求奇思妙想，至人只是常。（重剑无锋，大巧不工，通盘无妙手）把握命运= 把握一个个能把握住的瞬间 16.4 思考题你在学习过程中领悟到哪些方法、原则可以用来解决人生问题？ 17. 触类旁通，完整复现知识触类旁通的办法，这个办法也很简单。就是完整的复现所学的知识 触类旁通是有层次的，从举一反一，举一反三，举一反十。。。 触类旁通是可以训练的， 最好的办法就是一遍又一遍地，试图完整复现所学的知识； 触类旁通究竟要解决什么问题呢？ 就是大家日常学习中每个人，都会遇到的非常令人反感的一种情况。 “感觉知识太多太庞杂怎么办？” “反复呈现所学” “想清楚的每个点滴都算数” 那你要一遍一遍的呈现所学的东西，你学了一章，就要呈现一章的东西。学两章，就要反复呈现这两章所学的东西。 所谓呈现，是指在大脑中能够清晰的回忆起那一章的知识内容。点点滴滴能通过逻辑串起来。为什么这个排序排下来。 那这个这反复呈现也可以简称为复现。一个是重复地在大脑中显现。哪怕不能完整把一章内容复现出来，但是点滴能复现出来也很重要的。因为一切知识都是具有高度的可压缩性的，你掌握了一个知识就等于掌握了成千上万的知识。因为它会在你以后的学习过程中一次又一次地遇到。当然反之，如果你忘掉了一个知识点。那就很残酷了，那就意味着你以后成千上万次地会在那个知识点上面卡壳。这就是说这个知识的高度压缩性。另外一个就是学习的这个套路 可以复制的 拿数学举例： 把握核心逻辑 反复运用 反复呈现 在大脑中运算 自然数的四则运算 复数的四则运算 向量的四则运算 导数的四则运算 定义 推导 证明 算法 例题 数学从小学到大学都要说，知识体系很庞杂。但当从大脑中一遍遍复现时，但是它有一些内容是高度相似的，比如上面各种运算。 然后你还会发现，数学无论是什么章节，它的结构总是要先定义，先提出一个概念。通过一个具体的问题引入。或者通过特定的问题来引入。然后开始推导 证明一系列的命题， 定理。还包括这个算法。然后例题，解题。 它总是这个结构，一摸一样的结构。这是在一遍遍复现数学知识的时候，发现的。同时，这也是把一本书读薄的道理。 可惜很多人学了好久的数学，都没有发现数学的这种结构的高度的一致 性； 汤恩比《历史研究》，书虽然很厚。但通盘其实都在阐述两个道理 应战和对客观事物的盲目崇拜 1.7S就是一个世界 1.7s是不是人一跳出去之后，就已经决定当时的心态也好。状态也好。就决定了这个动作的质量，还是说1.7S之内，我还来得及调整自己，在前一个翻腾之后不行，我赶紧调整，来的及吗？ 胡佳： 来得及 主持人： 来得及？ 胡佳： 来得及，假如说我起跳往前顶了，或者往后倒了，那么往前顶了，可能我们就翻得速度就会慢，就是你翻腾的角度就会掉在上面。 对于运动员来说，1.7s就是一个世界。 时间仿佛凝固了。以至于他可以从容不迫的进行这个调节； 运动员赛前准备 他要对这场比赛的所有的情节进行想象，事先要想清楚，想清楚倒什么程度呢？ 他闭着眼睛拿着秒表去掐时间，然后想象，从起点出发，起点的计时器，然后想象划行第一浆 第二浆，遇到水流等等，一直到他感觉到终点了。 这种虚拟的想象最终和实地的比赛，时间误差能控制在一秒以内。在他大脑里面究竟发生了什么。 当然这不是说他一下子就能达到的，他平时就在这么训练。而且到比赛的时候对于那个特殊的比赛的赛道。他要进行专门的训练。就一组一组的进行这样的模拟训练。比如第一组，他差很多，可能会差四五秒，三四秒。连续一次两次做了这三次这种模拟。平均会差三四秒。然后休息一段时间之后他再来一组。 然后我再去想象划行。1234. 到后面他想象的越来越熟练。各种细节想象的越来越逼真。到后面就想差1秒以内 这种能力和我们平时学习知识的能力，他有高度的相似性，其实统一都是一个能力。只不过是有些人刻意去训练过。而好多人没有这么去练过自己而已。甚至不知道，世界上居然存在这种训练 这种能力，就是呈现，在大脑中复现所学知识的这种能力。 心智之眼，我们能够在大脑中复现一个场景或者一个知识，一个技能以至于这个生活中的场景的这种能力。这种能力是个人变革的一个关键。这种概念，它是经过严格的科学研究的。 需要刻意练习 你也可以把第七感想象成一种非常特殊的镜头，透过它，我们能够比以前更清楚地感知自己的心理。 这是每个人都能拥有的镜头，一旦拥有，我们便能深深地潜入内心的那片海，探索自己以及他人的内心世界。 作为人类特有的能力，第七感使我们能够密切的、细致的、深入地捡视自己思考、感受和行为的过程，重新塑造、重新定向内在的经验，从而使我们对日常行为拥有更多的选择自由，对未来拥有更大的创造力量，使我们成为自己人生故事的创作者。 基于神经科学的研究，我们现在已经知道，通过培养第七感的技能，我们能创造心理与情绪的改变，这些改变涉及大脑的物质层面，通过发展将注意力集中在内心世界的能力，我们便拥有了重新塑造神经通路。 就是说 比如说我们学一个知识，你一闭眼的时候。你不用刻意去想象 复现。它自然地 你的大脑里就会呈现出那个图形或者那个文字的场景。 只不过有些人把这个能力他往深处用了一下。比如他读完一页的时候，而不是着急去看下一页，而是在发呆，在回忆那一页，究竟学了什么。当他自己在问自己的过程中。他不自觉的就在大脑里面回顾了那一节的内容。甚至有意识的去复现它，那么如果这样子累计下来的话。他那个复现知识的能力就越强，甚至都变成了一系列的画面。 每个人对这项训练的深度不同，差别就体现出来了。 17.1 第七感什么是第七感 第七感是发展情商和社交商的重要基础，它是一种专注的注意力。使我们能看到自己的心理活动，它有助于我们感知自己的心理过程，而不会被这些过程侵袭；它使我们能够摆脱深根蒂固的行为以及习惯性的反应，远离可能会陷入其中的被动的情绪循环。它使我们能够正确理解并驯服自己的情绪，不被这些情绪压垮； 当我们心烦意乱的时候，就去用indsight问问自己，那个画面你给呈现出来，你就发现这个发怒是不必要，这中间存在一个误会。 你和一个人交往不愉快，这个不愉快的原因是什么。好多人不知道原因是什么。就被困在里面了，那如果说你跟这个人的交往过程中，你像一部电影一样在大脑里播放各种情节播放出来之后你就会发现什么原因导致你们之间相处不愉快的。很可能就因为一个小误会，如果你发现了，那么心结不就打开了吗。 17.2 思考题 你能从一章的目录想出一章的所有知识点吗？ 你能从一张白纸上，默写出一章的所有知识点吗？ 你重复多少次能做到？ 18 五分钟行动战胜拖延症人类就是一个复读机，你只要战胜拖延，5分钟战胜成功了。你就复制这5分钟的过程就可以了。 拖延的本质是什么？ 恐惧 恐惧的本质是什么？ 无知 18.1 微精通轻松到不可能放弃的技能学习手册 我要把它全做了，压力很大。一拖延，半小时过去了。你不要想着这些东西全部做完，12点之前全做完不要想这个事。先去做，先把一道题做完再说。 学习知识，要将知识打成粉末。 总想一口吃成个胖子，面对一整本书，一整个知识量巨大技术栈。人当然会觉得恐惧，难以完成目标而很难立即行动。当把知识打成粉末之后，很容易去完成某个细节。行动力就没有那么难。另外粉末状的技术栈在后期还能够随意组合。架构成新的技术栈。 18.2 实战战胜拖延的方法 只做5分钟； 再坚持5分钟； 以此类推 休息，下一组 学英语 只背一个句子 再背一个句子 回还往复 休息，下一组 做题 弄懂一道题 再弄懂一道题 回还往复 休息，下一组 那如果说一件事情做的方法正确的话，做的质量最终的效果就取决于你究竟投入了多长时间。 你能多5分钟就多5分钟的胜算，就是这么简单。 相比而言对社会竞争的残酷性、选拔性的考试的残酷性。如果方法正确的话你比其他人多了5分钟。真坚持不了就休息一下，尤其学习知识，那么熬时间就没意义了是吧。休息完毕，再来一组。或者休息期间做回顾，能想起来多少想多少。 这就是战胜拖延的方法，极简的方法就是这个。 18.3 思考题 你有过战胜拖延的经历吗 你能清晰的描述自己战胜拖延的过程吗？ 19. 把握住能掌控的点滴应对急躁和焦虑的方法 就是把握住自己能把握住的点滴； 焦虑的本质是什么？ “高三的时候，手上正在做的是每天的知识点。而舆论 大环境给学生带去的是 成绩，好大学，好专业上。这些具体的东西，知识本身思维本身被忽略掉了。然后就造成这种急躁焦虑了。” 急切得到某种抽象而难以得到的东西而不可得，根源是社会文化造就的贪婪（心理歧变） 利用焦虑和紧张 当你紧张和焦虑的时候，去做一些可控的事情。不要去想那些什么好大学，好的成绩，排名等。这些是当下控制不了的。 能积微者，速成。 不能积微者，不成 ——荀子《强国》 皮划艇奥运冠军 “将比赛全都拆分成很小很小的细节，看自己究竟可以把握住哪些东西，一个个去把握就好了。” 19.1 思考题 面对复杂艰难的考试，究竟能把握什么 如何区分可以把握的和把握不了的 20. 不断复现知识整体宁静心态： 不断复现知识整体 烦躁不安怎么办？宁静从哪里来？ 极致= 宁静 10.31是我打卡的第一天，我到现在都能够清楚的回忆那一天的状态，特别专注。 专注到感知不到外部环境，也感受不到身体饥饿·疲惫和困倦，我完全沉浸在手中那份数学卷子里，学到停不下来； 但是如此专注的条件下，我用了11个小时，别人时间饿三倍，才完全掌握一套数学卷子 但我还是发了动态，因为只有对自己坦诚，才能真的进步 也是从这天起，我发现极度专注可以忘记饥饿，另外，饥饿感不会很久，一会儿就过去了，为了节省时间，我每天吃两顿饭，七点吃早饭，下午三四点去吃午饭。 背后的本质就是一遍又一便地去复现知识的整体，然后后面就达到极致的宁静状态。因为进入到学习本身的思维中去了，而非停留在表面上。 其实一遍一遍复现知识的过程，大家对一个知识和技能的掌握 已经上了好多个台阶了 具体方法，读完第一章第一节，然后把书合上，来复述一下。复述的过程，你自己给自己录音。 发现大片的文字没对上。 所以学习的难处在于第一步就是读不懂，读不懂书。不懂的深层那是因为你根本就没看清楚，图表，图形，示意图，流程图没看清楚。文字，定义，概念，基本的定理，命题没看清楚。所以，优先过读懂这一关。 数学的思维模式： 反反复复的去把课本上已有的公式和定理的推导过程和证明过程一遍一遍的去独立推导，去参照 去模仿 去练习。熟练着掌握它的推导和证明过程，你会发现它的典型的逻辑思维的环节很少的。并不那么多也就10个20个。 你会发现它们无处不在，反反复复在用。解题过程中反反复复的在用，各个章节的过程中 知识之间都是这些逻辑环节。数学突然对你而言就变得亲切了，不再陌生了。原因就在于你把握住了它的思维模式。 英语的思维模式： 背文章，等到背5篇文章之后，你看了一片文章你都想读出声来。因为觉得熟悉，这里面的句式·句法·篇章和语法 好多语法都在里头了。 限时训练 王阳明 龙场悟道 致良知，知行合一，此心光明。那他这个龙场悟道从外在而言的话，就是到了极苦的一个境界。人生极苦的一个境界。什么事情都不顺 命都快没了，吃穿住什么的都很苦。 那究竟我这么一个人我怎么在这个世界上安身立命呢？我凭借的是什么呢？ 外在和内在都达到了极致，最后是一个宁静了。 宁静的标志是他所谓龙场悟道时悟到的这些感悟，此心光明，致良知，知行合一 学习这个事儿一摸一样的道理， 致良知，就是我们怎么学到一个东西，这个复杂吗？ 记一个单词，学会一个公式，弄懂一道题目复杂吗？不复杂 只要我们问自己 就能问得出来我们是怎么做到的。然后再致良知我们是不是真的想把这个知识学到手。如果是真的，那就一道题一道题，一个知识点一个知识点依次去重复操作，就好了吗。哪有什么复杂的对吧。致良知，知行合一，你就把学习的问题就解决了。如果这些想通了之后，你就知道了。此心光明。那还有什么可烦躁的，有什么可焦虑的。对吧。 致虚极，守静笃 万物并作 吾以观其复 —— 《道德经》 如何宁静，就是虚极，致虚极。就是胡思乱想你把它去掉了就好了。 一个单词，一个句子能不能学会。那你就不要管那些什么名次。什么计划啊，什么时间啊都可以抛到脑后了。你就依次去执行这个程序就可以了。这最简单了，乱七八糟的想法你都可以不要了。 20.1 思考题 你在什么时候感到宁静？ 宁静的过程为什么值得回味？ 21. 在现有的条件下做到极致做成一件事改写人生： 在现有的条件下做到极致 记者： 您的写作秘诀是什么？ 史蒂芬.金： 一个字一个字写 威尔史密斯与墙 小时候，10多岁的时候，他爸爸 让他和弟弟在自家商店门前建一堵墙。他跟他弟弟说我们这么小的年纪，我们怎么可能造好一堵墙呢。 然后他爸爸说：他爸爸说 你不要想着要去建造世界上最大、最厉害、最宏伟壮观的墙。你不要抱着这种态度开始，你要说我要砌好这块砖，砌得尽可能完美无缺。 先不管墙， 砖是可以做到的。只要一块一块努力把砖砌的整整齐齐，那么最终会砌好一堵墙的。威尔史密斯就认为这是他一辈子最受用的一个人生经历。 学习中最大的障碍就是我们的急躁。千百种的悲剧，之源都是因为我们的思维跳跃。我们现在的能力就这些，总想要去做一些很难的题目。总要拿个 好的名字很高的分数。想入非非是吧。而应该做的是什么呢？ 就是在你现有的能力范围内 再往前扩展一点，往前推进。所谓的你在学习的舒适区里面 拉伸。拉伸到学习去 变成把自己的舒适区扩大。一步一步把原来的恐慌区，很难处理的那些题目。那些知识给包进来，变成你的舒适区。一步一步地、步步为营地这么去做。那么那些困扰，那些困惑，那些负面的情绪，抑郁，焦虑 。紧张啊，什么烦躁都迎刃而解了。 整个人生就是一个数学归纳法或者说人生就是加法，就是很简单的加法。比如拿学习这件事而言的话，你知道 怎么学会一个东西的。 你先学会一个东西这是每个人都实现了这个过程啊。 然后第2步 你弄明白你究竟怎么学会的； 第3步你不要把以前学到的东西忘掉了，不要忘记 你频繁回顾他别忘了。然后以此类推 从0-1，从1 到无穷；人生就是这个加法，你考试拿100分就是这个加法。 努力——&gt;焦虑 ——&gt;抑郁 ——&gt;沉思 ——&gt;认知 ——&gt;幻灭 ——&gt;觉醒 ——&gt;方法 ——&gt;进步 ——&gt;跃迁 21.1 思考题 有哪件事情是你做到极致的？ 人生中哪件事让你感到自豪？","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"linux command","slug":"linux-command","date":"2021-03-30T13:11:41.000Z","updated":"2021-06-23T13:08:40.188Z","comments":true,"path":"2021/03/30/linux-command/","link":"","permalink":"http://yoursite.com/2021/03/30/linux-command/","excerpt":"","text":"1. 目录绝对路径： 从根目录开始，指定一个位置、文件 相对路径： 从当前进程工作目录位置开始，指定一个位置、文件 shell： 命令解析器，默认运行在终端当中的进程 bash： born again shell， Linux版的shell 1.1 Linux目录结构/ 跟目录，一般根目录下只存放目录； /home: 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下， 表示当前用户的家目录，edu表示用户edu的家目录 /bin: /usr/bin: 可执行的二进制文件的目录，如ls，tar，cat等 /boot： 放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器： /boot/grub /dev/： 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom/mnt /etc： 系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab, /etc/fstab, /etc/init.d, /etc/X11, /etc/sysconfig, /etc/xinetd.d /root 系统管理员root的家目录（宿主目录） /lib： /usr/lib: /usr/local/lib: 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /home/username 普通用户的家 /etc 配置文件目录 /sbin 管理命令目录 /usr 应用程序存放目录，/usr/bin： 存放应用程序， /usr/share： 存放共享函数库文件。/usr/local：存放软件升级包。/usr/share/doc：系统说明文件存放目录，/usr/share/man：程序说明文件存放目录。/usr/include： 存放头文件 /tmp: 一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下； 1.2 用户Linux是一款多用户多任务的分时复用操作系统 家目录：宿主目录。 ​ 每个用户不同，cd回车所到的目录。 普通用户切换至root用户 1su - root 2. 终端的使用 图形终端 命令行终端 远程终端 （SSH、VNC） // 工作中实际使用最多的， 通过互联网连接远程 切换至字符终端 1init 3 万能的帮助命令 为什么要学习帮助命令 man帮助 man是manual的缩写， 用法 man ls man 也是一条命令,分为9章，可以使用man命令获得man的帮助 man 7 man man [number] man 第几章 help帮助 shell（命令解释器） 自带的命令称为内部命令，其他的是外部命令 内部命令使用help帮助 help cd 外部命令使用help帮助 ls –help info帮助 info帮助比help更详细，作为help的补充 info ls 使用网络资源（搜索引擎和官方文档） Linux 的基本操作方式是命令行 海量的命令不适合“死记硬背” 分屏读取：more， less， cat， tac 3. 文件管理linux - 一切皆文件 文件查看 目录文件的创建与删除 通配符 文件操作 文本内容查看 pwd 显示当前的目录名称 cd 更改当前的操作目录 cd /path/to/… 绝对路径 cd ./path/to/… 相对路径 cd ../path/to/… 相对路径 ls 查看当前目录下的文件 1ls [选项，选项... ] 参数... 常用参数： -l 长格式显示文件 -a 显示隐藏文件 -r 逆序显示 -t 按照时间顺序显示 -R 递归显示 3.0 chmod修改用户访问权限chmod 修改文件权限有两种使用格式： 字母法和数字法 常用的是数字法 3.1 文件的增删创建 mkdir 创建文件 touch mkdir -p app/a/b/c 创建递归目录 ls -R 查看目录层级 *删除 * 1rm -r [文件名1] [文件名2] rm 删除文件无法恢复； *复制 * cp -r /root/a /tmp tmp在系统中是临时目录的意思 cp -v cp -p cp -a 移动 mv /file/a /file/b 改名 1mv &#x2F;file&#x2F;a &#x2F;tmp 通配符 * ： 表示该文件夹下所有文件 复制文本/粘贴文本 12ctrl+shift+cctrl+shift+v 复制文件夹 1cp -r dir1 dir2 看函数源码 123451. 光标停在函数名上，2. esc退出编辑模式；3. shift+k 可以直接跳转到 man 手册 3.2 文本查看cat 文本内容显示到终端 head 查看文件开头 tail 查看文件结尾 常用参数 -f 文件内容更新后，显示信息同步更新 wc 统计文件内容信息 3.3 重定向12&gt; 重定向到指定文件，文件不存在自动创建&gt;&gt; 将内容追加到指定文件，文件不存在自动创建，存在不覆盖 3.4 建立链接文件ln linux链接文件类似于Windows下的快捷方式 链接文件分为软链接和硬链接 软链接： ln 源文件 连接文件软链接不占用磁盘空间，源文件删除则软链接链接失效 (等同于windows下的快捷方式，建议使用 绝对路径创建软链接) 123$&gt; ls -s /home/xxx/file1 file.soft$&gt; lsfile.soft -&gt; /home/xxx/file1 硬链接： ln -s 源文件 链接文件硬链接只能链接普通文件，不能链接目录 如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的磁盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。 注意：如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径 3.5 管道left|right 管道的作用： 将管道符｜左边命令的输出传给后边的命令做为输入 123ps -aux | grep init# ps 列出所有进程# grep 过滤init进程 linux 备份压缩 最早的linux介质是磁带，使用的命令是 tar 可以打包后的磁带文件进行压缩缓存，压缩的命令是gzip 和 bzip2 经常使用的拓展名 .tar.gz .tar.bz2 .tgz 1tar cf &#x2F;tmp&#x2F;etc-backup.tar &#x2F;etc 4. 进程管理 运行中的程序程序正在运行的过程，管理程序什么时候启动，整个生命周期需要多少资源。内存资源， 运行时需要多少cpu资源，程序运行完之后把程序结束掉。还有进程之间的通讯。 进程终止的方式并不唯一，分为正常终止和异常终止 正常终止也分为main返回、调用exit等方式 异常终止分为调用abort、接受信号等 进程的概念与进程查看 查看命令 ps ps PID TTY TIME CMD 11931 pts/1 00:11.02 su PID: 进程ID，唯一标识符 CMD： 进程名称 TTY： 当前执行程序的终端 （pts/1 虚拟终端） TIME： 不具备参考价值的进程时间 pstree top 结论： ​ - 进程也是树形结构 ​ - 进程和权限有着密不可分的关系 进程的控制命令 进程的通信方式 - 信号 守护进程和系统日志 服务管理工具 systemctl SELinux简介 12345ps axj *# 查看精确到进程信息*ps axm *# 能查看精确到线程信息*ps ax -L *# 以linux的方式来查看进程和线程的关系* 查看机器 TCP， udp链接 1netstat -anu 1netstat -ant 使用本机的 提供的客户端 1nc ip port 打开一张图片 eog xy.png # 打开一张图片 5 os123free -m #内存df -h cat /proc/cpuinfo #cpu","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"net","slug":"net","date":"2021-03-28T15:27:34.000Z","updated":"2021-03-30T13:24:44.298Z","comments":true,"path":"2021/03/28/net/","link":"","permalink":"http://yoursite.com/2021/03/28/net/","excerpt":"","text":"网关 对于局域网来说，上网需要路由器，路由器可以被称为网关。 网关还能承载DNS服务器的作用。 1. OSI七层模型 **Open System Interconnection****适用于所有的网络 分工带来效能 将复杂的流程分解为几个功能相对单一的子进程 整个流程更加清晰，复杂问题简单化 更容易发现问题并针对性的解决问题 应用层(Application) 提供业务处理的，比如网络与用户应用软件之间的接口服务(HTTP) 表示层(Presentation) 内容是什么格式（英文还是中文，还是二进制等等）表示的，这一层提供格式化的表示和转换数据服务，如加密和压缩() 会话层(Session)保持会话， 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制() 传输层(Transimission) 提供建立、维护和取消传输连接功能，负责可靠地传输数据(TCP) 网络层(Network) 处理网络间路由，确保数据及时传送(路由器) 数据链路层(DataLink) 负责无错传输数据，确认帧、发错重传等(交换机) 物理层(Physics) 提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器) 解析： 拿张稿纸写封信 （应用层，表示层，会话层先合并为一层， 写信整体对应的是应用层，里面放的业务数据） 把信装到信封里面，写上收件人，收件人地址（地址分为两部分，第一部分，省市区地址和楼盘门牌号。第二部分是房间号） 然后给邮局，一般邮局不会只打包一封信，而是把一些相同目的地的信封打包成包裹，然后写上目标地址（这个打包的过程对应的是传输层） 邮局送信，先找到具体楼盘以及门牌号。邮局（寻址，这里对应的是网络层）知道目的地了，开始选择道路（铁路或者公路或者飞行）。 确定位置和运输方式之后，开始传输，到达目的地之后。把数据包给到收件人，收件人拆开数据包。拿到信（数据）（这个层是数据链路层和物理层负责，物理层负责实际的物理传输，就010101的传信号），万一途中把包裹丢失了怎么办，以及其他意外的处理，比如包裹的包装是否被拆过。都需要校验。（这个是数据链路层负责的事情 ） 1下层是为上层提供服务的 物理层 建立，维护，断开物理连接 数据最终还是需要物理层的硬件传输，这些硬件只能传输010101.这些01010 在网络中怎么去表示呢。不同的介质表现方式是不一样的。 高电频和低电频表示，5V 和 0V分别表示 1 和 0； 1.1 数据链路层 建立逻辑连接，进行硬件地址寻址·差错校验等功能。 比如两个网卡，这两张网卡如何建立连接，如何通信。通信过程中出问题了如何解决。发送过程中丢包要重新传。链路层依赖物理层，（下层是为上层提供服务的，上层会把数据传给下层，让下层帮忙提供服务） 1.2 网络层 进行逻辑地址寻址，实现不同网络之间的路径选择 从一个端到另一个端，肯定不止一条路。而是有无数条路。那要如何找到最快的路呢。这个是网络层负责的 1.3 传输层 定义传输数据的协议端口号，以及流控和差错校验（在不可靠的路线上做可靠的事情） 从一个端向另外一个端发送数据包的时候，如何做到中间丢包了，发送端能够感知到。一般操作方式是，当发送端发送包之后，开一个定时器。一般发送一个数据包，会有一个经验的时间。比如A到B之间传数据包要2秒，那么这个定时器2秒之后还没回来，我就默认这个包丢了。那就重新传一份。直到接受端返回正确的回馈。 1.4 应用层表示层会话层 应用层，表示层，会话层一般会打包到一层，就是实际的数据，比如发送的是文本，图片还是网页等这些东西。下层帮上层提供服务，上层给下层下发命令。下层帮忙处理。 1.5 分层模型 1.6 封装过程 数据在不同层的称谓 数据帧（Frame） 是一种信息单位，它的起点和目的点都是数据链路层 数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层 段（Segment）： 通常是指起始点和目的地都是传输层的信息单元 消息（message）： 是指起始点和目的地都在网络层以上（经常在应用层）的信息单元 不同的层解自己的封装的数据（段，数据包，数据帧等等） 2. TCP/IP参考模型TCP/IP是传输控制协议/网络互联协议的简称 早期的TCP/IP模型是一个四层结构，从下往上依次是网络接口层、互联网层、传输层和应用层 后来在使用过程中，借鉴OSI七层参考模型，将网络接口层划分为了物理层和数据链路层，形成五层结构 5层对应7层 应用层对应 （应用层，表示层和会话层） 传输层对应传输层 网络层对应网络层 数据链路层对应数据链路层 物理层对应物理层 2.1 协议的概念和作用 协议的目的为了让计算机能够通信，计算机需要定义通信规则，这些规则就是协议，信息双方都要理解，而且信息能够传输。 规则是多种，协议也有多种 协议就是数据封装格式+传输 的结合 2.2 常用协议TCP/IP协议被称为传输控制协议/互联网协议，又称网络通讯协议 是由网络层的IP协议和传输层的TCP协议组成，是一个很大的协议集合 物理层和数据链路层没有定义任何特定协议，支持所有的标准和专用的协议 层级 名称 含义 应用层 HTTP 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议 应用层 FTP 文件传输协议（英文：File Transfer Protocol，缩写：FTP）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式 应用层 TFTP (Trivial File Transfer Protocol,简单文件传输协议)是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议 应用层 SMTP 简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP) 是在Internet传输Email的事实标准 应用层 SNMP 简单网络管理协议（SNMP，Simple Network Management Protocol），由一组网络管理的标准组成，包含一个应用层协议（application layer protocol）、数据库模型（database schema）和一组资源对象,该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。 应用层 DNS 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。 TCP TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议 传输层 UDP UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 传输层 ICMP ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息 网络层 IGMP Internet 组管理协议称为IGMP协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间 网络层 IP 互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为IP地址（英语：IP Address），是分配给用户上网使用的网际协议（英语：Internet Protocol, IP）的设备的数字标签 网络层 ARP 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议 网络层 RARP 反向地址转换协议（RARP：Reverse Address Resolution Protocol） 反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址 以下具体讲5层协议3. 网络接口层网络接口层是TCP/IP模型的最底层，负责接收从上一层交来的数据报并将数据报通过底层的物理网络发送出去，比较常见的就是设备的驱动程序，此层没有特定的协议 网络接口层又分为物理层和数据链路层 3.1 物理层计算机在传递数据的时候传递的都是0和1的数字，而物理层关心的是用什么信号来表示0和1，是否可以双向通信，最初的连接如何建立以及完成连接如何终止,物理层是为数据传输提供可靠的环境 尽可能的屏蔽掉物理设备和传输媒介，使数据链路层不考虑这些差异，只考虑本层的协议和服务 为用户提供在一条物理传输媒体上提供传送和接收比特流的能力 需要解决物理连接、维护和释放的问题 3.1.1 数字信号的编码数字信号的编码：用何种物理信号来表示0和1 3.1.1.1 非归零编码 缺点就是连音没法处理，是多个1 还是一个1的问题；所以需要告诉多长时间是个间隔呢。不然没法判断是几个1 优点： 编/译码简单。 缺点： 内部不含时钟信号， 收/发端同步困难。 用途： 计算机内部， 或低速数据通信。 3.1.1.2 曼彻斯特编码 附加一个从低到高或者从高到低的频率 优点： 内部自含时钟， 收/发端同步容易。 抗干扰能力强。 缺点： 编/译码较复杂。 占用更多的信道带宽， 在同样的波特率的情况下， 要比非归零编码多占用一倍信道带宽。 用途： 802.3局域网（以太网）使用场景更多 3.2 数据链路层数据链路层是OSI参考模型中的第二层，介乎于物理层和网络层之间 数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层 如何将数据组合成数据块，在数据链路层中称这种数据块为帧frame，帧是数据链路层的传送单位 如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配 以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理 3.2.1 以太网以太网（Ethernet）是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容 以太网的标准拓扑结构为总线型拓扑 以太网仍然使用总线型拓扑和CSMA/CD（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术 以太网实现了网络上无线电系统多个节点发送信息的想法，每个节点必须获取电缆或者信道的才能传送信息 每一个节点有全球唯一的48位地址也就是制造商分配给网卡的MAC地址，以保证以太网上所有节点能互相鉴别 3.2.2 总线型拓扑（只用到了物理层和数据链路层） 网络总线，每个电脑都可以接受消息，发送消息。 总线型拓扑是采用单根传输作为共用的传输介质,将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上 使用总线型拓扑结构需解决的是确保端用户使用媒体发送数据时不能出现冲突。 总线型网络采用载波监听多路访问/冲突检测协议（CSMA/CD)作为控制策略 （CSMA/CD指的是，每个电脑得监听其他电脑的状态，大家不能同时往网络总线上发消息） 3.2.2.1 载波监听多路访问全称Carrier Sense Multiple Access (CSMA)，是一种允许多个设备在同一信道发送信号的协议，其中的设备监听其它设备是否忙碌，只有在线路空闲时才发送 在此种访问方式下，网络中的所有用户共享传输介质，信息通过广播传送到所有端口，网络中的工作站对接收到的信息进行确认，若是发给自己的便接收否则不理 从发送端情况看，当一个工作站有数据要发送时，他首先监听信道并检测网络上是否有其他的工作站正在发送DATA，如果检测到信道忙，工作站将继续WAIT若发现信道空闲，则开始发送数据，信息发送出去后，发送端还要继续对发送出去的信息进行确认，以了解接收端是否已经正确接收到数据，如果收到则发送结束，否则再次发送 核心思想 先听后讲 信道空闲则发送，信道忙则等待。 边听边讲 发送信号时不断检测信道是否碰撞。（发信号时即时检测） 碰撞即停 （因为网线是单向的，传输过程中发现别人也在往反方向发，那么赶紧停止发送） 退避重传 二进制指数退避重传 多次碰撞，放弃发送,最多16次 （下面这个计算退避等待时间的算法，1，2，4，8.。。64） 如果64秒还没发出去，那么就不发了。 3.2.2.2 冲突检测冲突检测即发送站点在发送数据时要边发送边监听信道，若监听到信道有干扰信号，则表示产生了冲突，于是就要停止发送数据，计算出退避等待时间，然后使用CSMA方法继续尝试发送 计算退避等待时间采用的是二进制指数退避算法 （发消息的时候，检测别的电脑是否也在发，如果有就等1秒，1秒后继续校验，如果阻塞继续等2秒，后面依次类推 等 2的次方倍） 3.2.2.3 总线拓扑的缺点 不安全，发送出去的包连接总线的所有电脑都能劫持到。本来不该他收的信息他也可以收。 3.2.2.4 交换机 后来出现了交换机，交换机是一个二层的设备，在物理链路层上工作。比如A电脑发送消息给B电脑，直接连接交换机即可。就不同通知同样连接交换机的C电脑 交换机和路由器的区别 首先交换机是一个数据链路层的设备，只是传输数据包。数据包里面肯定有原地址和目标地址（比如A电脑 -&gt; B电脑）这个地址就是 MAC地址。 路由处理ip地址，主要作用是网络层的寻址 3.2.3 MAC地址 在通信过程中是用内置在网卡内的地址来标识计算机身份的 每个网卡都有一个全球唯一的地址来标识自己，不会重复(保证局域网之内不重复就行了)。MAC地址48位的二进制组成，通常分为6段，用16进制表示 3.2.4 以太网帧格式 在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。 后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址 帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议) 以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏 字段 说明 前导符(Preamble) 由1和0交互构成(10101010…..)，共占7个字节，用于使PLS子层电路与收到的帧达成时钟同步 帧起始(Start-of-Frame Delimiter, SFD) 为10101011，共占1个字节，表示一个帧的开始。它和前导符共同使接收方能根据1、0交替来迅速实现比特同步，当检测到连续的两位1时，将后续信息交给MAC子层。通常来说，Pre和SFD这两个字段只用于提醒接收端新帧到达，并不计入MAC帧大小，也不算作是MAC帧头的组成部分 目的MAC(Destination Address, DA)/源MAC(Source Address, SA) 分别用于标识目的MAC地址和源MAC地址，两个字段各占6个字节。它们可以是单播地址也可以是广播地址。当地址的最高位为0时表示单播，最高位为1时为组播，全为1时为广播 长度(Length)/类型(Type) 这是一个二选一的字段，共占2个字节，对于不同的网络协议，它有不同的含义。但是，作为类型使用时，如上表所示，最小值也总是大于1536（十六进制0x600）；所以不会产生冲突。另外，在IEEE 802.3中，数据字段的长度为38~1500个字节 数据(Data) 该字段对于不同的以太网帧包含的内容不一，对于较老的以太网标准，它是网络层来的数据报；而较新的标准，则是一个LLC帧的全部内容 帧校验序列(FCS) 它是一个包含32位CRC校验值的字段，一共占4个字节。由发送端对MAC帧的DA字段到Data字段间（不包含前导符和帧起始）的二进制序列进行计算 3.2.5 ARP协议 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址(MAC地址)的一个TCP/IP协议 主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源 地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存 由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗 3.2.5.1 ARP协议报文 字段 说明 硬件类型 表示硬件地址的类型，值为1表示以太网地址 协议类型 表示要映射的协议地址类型。它的值为0x0800表示IP地址类型 硬件地址长度和协议长度 以字节为单位，对于以太网上的IP地址的ARP请求或应答来说，他们的值分别为6和4 操作类型 用来表示这个报文的类型，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4 发送端MAC地址 发送方设备的硬件地址 发送端IP地址 发送方设备的IP地址 目标MAC地址 接收方设备的硬件地址 目标IP地址 接收方设备的IP地址 3.2.5.2 ARP地址解析过程 主机A和B在同一个网段，主机A要向主机B发送信息 主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。 4. 互联网层(网络层)位于传输层和网络接口层之间,用于把数据从源主机经过若干个中间节点传送到目标主机,并向传输层提供最基础的数据传输服务,它要提供路由和选址的工作 4.1 选址交换机是靠MAC来寻址的，而因为MAC地址是无层次的,所以要靠IP地址来确认计算机的位置,这就是选址 4.2 路由 寻址 在能够选择的多条道路之间选择一条最短的路径就是路由的工作 4.3 IP在网络中，每台计算机都有一个唯一的地址，方便别人找到它，这个地址称为IP地址。 4.3.1 IP头部 字段 说明 版本 Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100 首部长部 报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节 优先级与服务类型 占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0 总长度 占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节 标识符 占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1 标志 分为3个字段，依次为保留位、不分片位和更多片位 标志 保留位：一般被置为0 标志 不分片位：表示该数据报是否被分片，如果被置为1，则不能对数据报进行分片，如果要对其进行分片处理，就应将其置为0 标志 更多片位：除了最后一个分片，其他每个组成数据报的片都要将该位置设置为1. 段偏移量 占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置 TTL(Time to Live生存时间) 该字段用于表示IP数据包的生命周期，可以防止一个数据包在网络中无限循环地发下去。TTL的意思是一个数据包在被丢弃之前在网络中的最大周转时间。该数据包经过的每一个路由器都会检查该字段中的值，当TTL的值为0时此数据包会被丢弃。TTL对应于一个数据包通过路由器的数目，一个数据包每经过一个路由器，TTL将减去1 协议号 占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等 首部校验和 检验和是16位的错误检测字段。目的主机和网络中的每个网关都要重新计算报头的校验和，一样表示没有改动过,计算方法是：对头部中每个16比特进行二进制反码求和 源IP地址 该字段用于表示数据包的源地址，指的是发送该数据包的设备的网络地址 目标IP地址 该字段用于表示数据包的目标的地址，指的是接收节点的网络地址 4.3.2 IP地址格式IP地址是一个网络编码，用来确定网络中的一个节点。 IP地址是由32位二进制(32bit)组成 4.3.3 IP地址组成网络部分(NETWORK), 网络部分表示不同的网络 主机部分(HOST) ，主机部分标示在一个网络中特定的主机 4.3.4 IP地址表示 4.3.5 IP地址的分类 IP地址的网络部分是由Internet地址分配机构来统一分配的，这样可以保证IP的唯一性。 ip地址中全为1的ip即255.255.255.255，它称为限制广播地址，如果将其作为数据包的目标地址可以理解为发送到所有网络的所有主机 ip地址中全为0的ip即0.0.0.0，它表示启动时的ip地址，其含义就是尚未未分配时的ip地址 127是用来进行本机测试的，除了127.255.255.255外，其它的127开头的地址都代表本机 ip地址有5种 A类：1.0.0.0~126.255.255.255 B类：128.0.0.0~191.255.255.255 C类：192.0.0.0~223.255.255.255 D类：224.0.0.0~239.255.255.255 （用于组播） E类：240.0.0.0~254.255.255.255 （用于科研） 其中127.0.0.0~127.255.255.255用于环回测试 A类网络，第一个字节是网络，另外三个字节是host地址， B类网络，网络有两个字节，另外两个字节是host地址 C类网络，网络有三个字节，另外1个字节是host地址 问题 如上图所示，保留地址中第二行 172.12.0.0/12描述为16个连续的B段， 192.168.0.0/16描述为256个连续的C段，如何理解 172.16.0.0~172.31.255.255, 因为B类网络的host只占最后两个字节，172.16～172.31 就代表了16个连续的B类网络可用 192.168.0.0~192.168.255.255，因为C类网络的host只占最后一个字节，所以从192.168.0 到 192.168.255， 就有256个连续的C类网络可用 服务器可以监听的端口从0到65535，理论上这台服务器的这个端口只要没被占用，你都可以给服务器绑定。如果是一些默认的服务，服务器绑的也是默认的端口，那么客户端是可以知道的。比如：80是给http服务，443是给htts服务，21是给ftp服务等，否则的话，就需要服务器开发者告诉客户端应该连接哪个端口。 192.168.0.1/27表示什么 （理解子网，网段 和子网掩码）首先 192.168.0.1 是个IP地址，更细一点的话，属于C类型的，后面的/27 则表示网络号的长度，也叫VLSM（Variable Length Subnet Mask，可变长子网掩码），192.168.0.1/27 属于CIDR（无类别域间路由，Classless Inter-Domain Routing）表述形式 1IP&#96; 地址是以点分割为四部分，每部分 &#96;8bit&#96; （位）也就是一个 &#96;byte&#96;（字节）。在C类地址中，网络号占 &#96;24bit&#96;，主机号占 &#96;8bit 网络号 主机号 11111111 11111111 11111111 00000000 1192.168.0.1&#x2F;27 说明网络号占了27bit， 27个1表示网络号， 后面5个0表示主机号 网络号 主机号 11111111 11111111 11111111 11100000 网络号向主机借了3bit,说明有2^3=8个子网，每个子网可用主机数为 2^5-2=30, 这里 -2 是因为头尾的网络地址（全0的部分）和广播地址（全1的部分）是不可用的。 11111111 11111111 11111111 11100000 11100000 转为十进制即 2**7+2**6+2**5 即224。所以子网掩码为255.255.255.224。 IP 地址 11000000 10101000 00000000 00000001 子网掩码 11111111 11111111 11111111 11100000 网络地址 11000000 10101000 00000000 00000000 广播地址 11000000 10101000 00000000 00011111 网络地址是IP地址192.168.0.1 和 子网掩码 255.255.255.224的二进制 做 与运算，结果为 192.168.0.0, 广播地址则是在 网络地址的基础上把主机号从右往左数5位置为1而得到 192.168.0.31。 有效的主机IP地址为 192.168.0.1 到 192.168.0.30。 结合上面计算出有8个子网，那么192.168.0.1则落在第一个可用子网内 192.168.0.1~192.168.0.30，子网分布如下 子网 IP 网段 可用主机 一 192.168.0.0 ~ 192.168.0.31 192.168.0.1 ~ 192.168.0.30 二 192.168.0.32 ~ 192.168.0.63 192.168.0.33 ~ 192.168.0.62 三 192.168.0.64 ~ 192.168.0.95 192.168.0.65 ~ 192.168.0.94 四 192.168.0.96 ~ 192.168.0.127 192.168.0.97 ~ 192.168.0.126 五 192.168.0.128 ~ 192.168.0.159 192.168.0.129 ~ 192.168.0.158 六 192.168.0.160 ~ 192.168.0.191 192.168.0.161 ~ 192.168.0.190 七 192.168.0.192 ~ 192.168.0.223 192.168.0.193 ~ 192.168.0.222 八 192.168.0.224 ~ 192.168.0.255 192.168.0.225 ~ 192.168.0.254 每个子网中全0网络地址和全1广播地址不能作为主机ip来使用（这里的全0和全1，指的是二进制的全0 全1） 4.3.6 公有地址和私有地址 从上面所示，ip地址共有2的32次方减2个，总共不到43亿个ip地址。，上面提到过全球的网卡300多亿张，所以必然没办法每张网卡都能对应一个ip地址。然后有一些ip出于某种原因，还被保留下来了。所以可以提供使用的ip很少很少。那为啥这么多年过去了，IP还没用完呢。原因就是 **子网** 的存在； 保留网段（私有IP） 一个常见的现象，我们所在的单位或者组织，普遍会使用诸如10.0.x.x 或者192.168.x.x这样的ip地址，这样的ip到底代表了什么？ 不同的组织使用同样的ip会不会导致冲突呢？ 背后的原因是，国际标准组织在IPV4 地址空间里面，专门划分出了一些网段，这些网段不会用做公网上的IP，而是仅仅保留作内部使用。这些地址称作保留网段； | 分类 | IP地址范围 | 私有IP地址范围 | 最大主机个数 || —– | ————————- | —————————– || A类IP | 1.0.0.0126.255.255.255 | 10.0.0.0 ~ 10.255.255.255 | 2**24-2 || B类IP | 128.0.0.0191.255.255.255 | 172.16.0.0 ~ 172.31.255.255 | 216-2 || C类IP | 192.0.0.0~223.255.255.255 | 192.168.0.0 ~ 192.168.255.255 | 28-2 | 1其他范围的IP均为公有IP地址 网段与子网掩码在网络IP划分的时候，需要区分两个概念 第一是网络（network）的概念，直观点说，它表示的是这组IP共用的部分，比如在192.168.1.1～192.168.1.255这个区间里，它们共同的部分是192.168.1.0 第二是主机（host）的概念，它表示的是这组IP不同的部分，上面的例子中1～255就是不同的那些部分，表示有255个可用的不同IP 例如IPv4 地址，192.0.2.12，我们可以说前面三个字节是子网， 即（192.0.2.12），最后一个字节是host，或者换个方式，我们能说host为8位，子网掩码为192.0.2.0/24 （即24个1，8个0 255.255.255.0） 网络地址位数由子网掩码决定，你可以将IP地址与子网掩码进行“位与”操作，就能得到网络的值。子网掩码一般看起来像是255.255.255.0（二进制为 11111111.11111111.11111111.00000000），这里需要强调的是，A，B，C三类地址都有自己默认的子网掩码，A类为255.0.0.0, B类为255.255.0.0, C类为255.255.255.0 比如你的ip地址是192.0.2.12， 使用这个子网掩码时，你的网络地址就会是192.0.2.12与255.255.255.0 所得到的值： 192.0.2.0, 192.0.2.0就是这个网络的值； 子网掩码能接受任意个位，而不单纯是上面讨论的8，16或24个比特而已，所以你可以有一个子网掩码255.255.255.252(二进制位 11111111.11111111.11111100),这个子网掩码能切出一个30个位的网络以及2个位的主机，这个网络最多有四台host，因为最后一个位有两个0，（11111111，11111110，11111101，11111100）四种情况。 子网掩码只有一个作用，就是将某个IP地址划分为网络地址和主机地址两个部分。 子网掩码的格式永远都是二进制格式：前面一连串1，后面一连串的0 不过一大串的数字会有点不好用，比如像255.192.0.0这样的子网掩码，无法直观看到多少个，多个0，后来发明了新的办法，只需要将一个斜线放在ip地址后面，接着用一个十进制的数组用以表示网络的位数，类似这样：192.0.2.12/30,这样就很容易知道有30个1，2个0， 所以主机个数为4； 4.3.7 子网掩码 为什么一个职场1000多人只靠着一个ip就能满足，靠的就是子网掩码 子网掩码(subnet mask)又叫子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位的掩码。 子网掩码不能单独存在，它必须结合IP地址一起使用。 子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 子网掩码也是32个二进制位 对应IP的网络部分用1表示 对应IP地址的主机部分用0表示 IP地址和子网掩码做逻辑与运算得到网络地址 0和任何数相与都是0 1和任何数相与都等于任何数本身 A B C 三类地址都有自己默认的子网掩码 A类 255.0.0.0 B类 255.255.0.0 C类 255.255.255.0 子网掩码可以自己设置也可以自动获取 子网的第一个ip 是 192.168.5.129 最后一台主机ip是 192.168.5.158 定向广播 192.168.5.159 下一个子网 192.168.5.160 判断两个ip地址在不在一个子网之内 IP地址和子网掩码的二进制 做与运算之后得到子网的二进制网络地址，判断两个网络地址在不在一个子网之内，把它们根子网掩码做与运算。如果与的结果是一致的，那说明在一个子网之内。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354*// 判断两个ip地址在不在一个子网之内*let ip1 = \"192.168.0.1\";let ip2 = \"192.168.0.4\";let mask = \"255.255.255.0\";function same(ip1, ip2, mask) &#123; let ip1s = ip1​ .split(\".\")​ .map((item) =&gt; (+item).toString(2).padStart(8, \"0\"))​ .join(\"\"); let ip2s = ip2​ .split(\".\")​ .map((item) =&gt; (+item).toString(2).padStart(8, \"0\"))​ .join(\"\"); let masks = mask​ .split(\".\")​ .map((item) =&gt; (+item).toString(2).padStart(8, \"0\"))​ .join(\"\"); return (​ (parseInt(ip1s, 2) &amp; parseInt(masks, 2)) ===​ (parseInt(ip2s, 2) &amp; parseInt(masks, 2)) );&#125;let result = same(ip1, ip2, mask);console.log(result); 子网掩码解决什么问题子网掩码所做的是将网络划分出子网，解决网段的问题。私有ip才是解决ip不够用的问题 子网掩码划分子网 一个实际的场景， 比如一个公司有两个部门，财务部和hr部，每个部分都有四台电脑，网络要部署到两个部门，但是两个部门需要独立的局域网。我们知道一个C类ip地址可以有254个主机地址。所以，需要通过子网掩码的方式来把一个ip地址拆分给连个部门使用。 比如ip为 10011111 11111111 11111111 11000000 子网掩码1 为 10011111 11111111 11111111 11100000 子网掩码2 为 10011111 11111111 11111111 11110000 子网掩码可以是多个 子网掩码将不在一个子网之内的网络调整到一个子网内，即往左边移位 比如 255.255.255.0 =&gt; 255.255.0.0 =&gt; 255.0.0.0 划分局域网需要物理划分的同时还要通过子网掩码划分吗？ 是的，首先把一些电脑划分到一个子网之内。它们需要在一个物理网络内。它们必须连上路由器，交换机等等。另外还得看子网掩码，看看ip地址在不在一个局域网之内。 5. 传输层 位于应用层和网络接口层之间 是面向连接的、可靠的的进程到进程通信的协议 TCP提供全双工服务，即数据可在同一时间双向传播 TCP将若干个字节构成一个分组，此分组称为报文段(Segment) 对可靠性要求高的上层协议，实现可靠性的保证,如果数据丢失、损坏的情况下如何保证可靠性,网络层只管传递数据，成功与否并不关心 5.1 传输层的功能提供了一种端到端的连接 5.2 协议分类TCP(Transimision Control Protocal) 传输控制协议 可靠的、面向连接的协议 传输效率低 UDP(User Datagram Protocal) 用户数据报协议 不可靠的、无连接的服务 传输效率高 5.3 TCP协议 将数据进行分段打包传输 对每个数据包编号控制顺序 运输中丢失、重发和丢弃处理 流量控制避免拥塞 5.3.1 TCP数据包封装5.3.1.1 格式 源端口号和目标端口号，计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 5.3.1.2 32位序列号 32位序列号 TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值 5.3.1.3 确认应答号 确认应答号 它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。 1,2,3,4 包到达目的地的时机不一样；当3先到。接收端并不会立即通知发送端已经收到3. 而是会等待一段时间之后，如果依然没有响应。则告知发送端，已经收到了3. 请把1，2重新发一下。因为已经收到了3.所以必然有1，2.等到最终1和2都到了。那再告知发送端，已经收到1，2，3 5.3.1.4 首部长度 首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。 5.3.1.5 控制位 控制位 TCP的连接、传输和断开都受这六个控制位的指挥 URG(urgent紧急位) 紧急信号 ACK（响应位） PSH(push急迫位) 缓存区将满，立刻传输速度 RST(reset重置位) 连接断了重新连接 SYN（sync同步）TCP基于链接的，想根对方建立链接，勇敢伸出一只手。发送SYN标识位 FIN（finish完成）发送端完成位，提出断开链接的一方把FIN置为1表示要断开连接 紧急指针：仅在 URG(urgent紧急) 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。 5.3.1.5.1 SYNSYN(synchronous建立联机) 同步序号位 TCP建立连接时要将这个值设为1 5.3.1.5.2 ACKACK(acknowledgement 确认)为1表示确认号 5.3.1.5.3 FINFIN发送端完成位，提出断开连接的一方把FIN置为1表示要断开连接 5.3.1.6 窗口值 窗口值 说明接收端可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。它是来在TCP传输中进行流量控制的 窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测（每隔一段时间，发送端主动发送一个问询，窗口大小有没有改变） 5.3.1.7 差错控制校验和用来做差错控制，TCP校验和的计算包括TCP首部、数据和其它填充字节。在发送TCP数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验 和一致说明数据是正确的，否则 将认为数据被破坏，接收端将丢弃该数据 5.3.2 握手和断开（三次握手，四次挥手） TCP是面向连接的协议，它在源点和终点之间建立虚拟连接，而不是物理连接 在数据通信之前，发送端与接收端要先建立连接，等数据发送结束后，双方再断开连接 TCP连接的每一方都是由一个IP地址和一个端口组成 5.3.2.1 tcp服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051*// tcp_server.js*var net = require(\"net\");var server = new net.Server();server.on(\"connection\", function (socket) &#123; console.log(\"connected\"); socket.on('data',function(data)&#123; console.log(data.toString()); socket.write(\"server:\"+data); &#125;) socket.on('end',function(data)&#123; console.log('end'); &#125;) socket.on('error',function(error)&#123; console.log(error); &#125;)&#125;);server.listen(8000);server.on(\"listening\", function () &#123; console.log(\"Created server on http://127.0.0.1:8000/\");&#125;)server.on(\"close\", function () &#123; console.log(\"server closed!\");&#125;)server.on(\"error\", function (err) &#123; console.log(err);&#125;) 12345678910111213141516171819202122232425262728293031323334*//tcp_client.js*var net = require(\"net\");var socket = net.Socket();socket.connect(8000, '127.0.0.1', function () &#123; console.log(\"connect the server\"); socket.write(\"hello\");&#125;)socket.on(\"data\", function (data) &#123; console.log(data.toString()); socket.destroy();&#125;)socket.on(\"error\", function (err) &#123; console.log(err);&#125;)socket.on(\"end\", function () &#123; console.log(\"data end\");&#125;) 5.3.2.1 三次握手 第一次握手主机A通过一个标识为SYN标识位的数据段发送给主机B请求连接，通过该数据段告诉主机B希望建立连接，需要B应答，并告诉主机B传输的起始序列号 第二次握手是主机B用一个确认应答ACK和同步序列号SYNC标志位的数据段来响应主机A，一是发送ACK告诉主机A收到了数据段，二是通知主机A从哪个序列号做标记。 第三次握手是主机A确认收到了主机B的数据段并可以开始传输实际数据。 SYN_SENT(connect()) 握手请求 SYN seq=x (x为一个32位的随机数) LISTEN(listen()) SYN_RCVD 发送 SYN seq=y, ACK = x+1 (此时客户端宣布 established) 客户端发送 ACK=y+1 (此时服务端感知 established) sep的作用是给数据包标住序号，用于后面确认，重传等。seq是一个2**32的数字seq如果越界，会重置为0. 5.3.2.2 收发数据 5.3.2.3 四次断开 主机A发送FIN控制位发出断开连接的请求 主机B进行响应，确认收到断开连接请求 主机B提出反方向的关闭要求 主机A确认收到的主机B的关闭连接请求 为什么挥手会有四次，在客户端发送断开链接指令的时候， 服务端发送了一次 ACK 和一次ACK/FIN指令。为何这两次指令不能合并在一起呢？ 因为收到关闭请求和真正关闭只有一段时间差的，这段时间差当中可能还有传输的数据包。所以服务端没办法第一时间返回finsh。只有等数据包情况处理好之后，才能返回finsh请求； 5.3.3 滑动窗口 滑动窗口（Sliding window）是一种流量控制技术 早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题 TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据 当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小 发送方和接收方各维护一个窗口长度，接收方会把窗口大小发给发送方。发送方设置一个小于或者等于接收窗口大小的值。 窗口大小 = 缓存区大小 - 缓存字节数 5.3.3.1 窗口机制 滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口 发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同 不同的滑动窗口协议窗口大小一般不同 发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧 5.3.3.2 拥塞控制 TCP拥塞控制是传输控制协议（英语：Transmission Control Protocol，缩写TCP）避免网络拥塞的算法，是互联网上主要的一个拥塞控制措施 TCP使用多种拥塞控制策略来避免雪崩式拥塞。TCP会为每条连接维护一个“拥塞窗口”来限制可能在端对端间传输的未确认分组总数量 这类似TCP流量控制机制中使用的滑动窗口，是由发送方控制的 TCP在一个连接初始化或超时后使用一种“慢启动”机制来增加拥塞窗口的大小。它的起始值一般为最大分段大小（Maximum segment size，MSS）的两倍，虽然名为“慢启动”，初始值也相当低，但其增长极快：当每个分段得到确认时，拥塞窗口会增加一个MSS，使得在每次往返时间（round-trip time，RTT）内拥塞窗口能高效地双倍增长 在流量控制中，接收方通过TCP的“窗口”值（Window Size）来告知发送方，由发送方通过对拥塞窗口和接收窗口的大小比较，来确定任何时刻内需要传输的数据量 和式增加，积式减少（additive-increase/multiplicative-decrease，AIMD，这里简称“线增积减”）是一种反馈控制算法，其包含了对拥塞窗口线性增加，和当发生拥塞时对窗口积式减少。多个使用AIMD控制的TCP流最终会收敛到对线路的等量竞争使用。 未确认的数据包刚好等于带宽等于延迟 当发现丢包的时候立刻减半 5.4 UDP UDP是一个无连接、不保证可靠性的传输层协议，也就是说发送端不关心发送的数据是否到达目标主机、数据是否出错等，收到数据的主机也不会告诉 发送方是否收到了数据，它的可靠性由上层协议来保障 首部结构简单，在数据传输时能实现最小的开销，如果进程想发送很短的报文而对可靠性要求不高可以使用 没有握手，也没有挥手 5.4.1 UDP的封装格式5.4.1.1 数据包 5.4.1.2 数据长度 5.4.1.3 差错控制 5.4.2 UDP的应用 QQ 视频软件 TFTP 简单文件传输协议(短信) 5.4.3 UDP服务器5.4.3.1 点对点123456789101112131415161718*// udp_server.js*var dgram = require('dgram');var socket = dgram.createSocket('udp4');socket.on('message',function(msg,rinfo)&#123; console.log(msg.toString()); console.log(rinfo); socket.send(msg,0,msg.length,rinfo.port,rinfo.address);&#125;);socket.bind(41234,'localhost'); 1234567891011121314151617181920212223242526*// udp_client.js*var dgram = require('dgram');var socket = dgram.createSocket('udp4');socket.on('message',function(msg,rinfo)&#123; console.log(msg.toString()); console.log(rinfo);&#125;);socket.send(new Buffer('helloworld'),0,5,41234,'localhost',function(err,bytes)&#123; console.log('发送了个%d字节',bytes);&#125;);socket.on('error',function(err)&#123; console.error(err);&#125;); 5.4.3.2 广播 创建一个UDP服务器并通过该服务器进行数据的广播 123456789101112131415161718*// udp_server.js*let dgram = require('dgram');let server = dgram.createSocket('udp4);server.on('message',function(msg)&#123;let buf = new Bufffer('已经接收客户端发送的数据'+msg);server.setBroadcast(true);server.send(buf,0,buf.length,41235,\"192.168.1.255\");&#125;);server.bind(41234,'192.168.1.100'); 123456789101112131415161718*//udp_client.js*let dgram = require('dgram');let client = dgram.createSocket('udp4);client.bind(41235,'192.168.1.102);let buf = new Buffer('hello');client.send(buf,0,buf.length,41234,'192.168.1.100');client.on('message',function(msg,rinfo)&#123;console.log('received : ',msg);&#125;); 5.4.3.3 组播 所谓的组播，就是将网络中同一业务类型进行逻辑上的分组，从某个socket端口上发送的数据只能被该组中的其他主机所接收，不被组外的任何主机接收。 实现组播时，并不直接把数据发送给目标地址，而是将数据发送到组播主机，操作系统将把该数据组播给组内的其他所有成员。 在网络中，使用D类地址作为组播地址。范围是指 224.0.0.0 ~ 239.255.255.255,分为三类 局部组播地址: 224.0.0.0 ~ 224.0.0.255 为路由协议和其他用途保留 预留组播地址: 224.0.1.0 ~ 238.255.255.255 可用于全球范围或网络协议 管理权限组播地址 ： 239.0.0.0 ～ 239.255.255.255 组织内部使用，不可用于Internet 1234567891011121314151617181920212223242526*//udp_server.js*let dgram = require('dgram');let server = dgram.createSocket('udp4');server.on('listening',function()&#123;server.MulticastTTL(128);server.setMulticastLoopback(true);server.addMembership('230.185.192.108');&#125;);setInterval(broadcast,1000);function broadcast()&#123;let buffer = Buffer.from(new Date().toLocaleString());server.send(buffer,0,buffer.length,8080,\"230.185.192.108\");&#125; 1234567891011121314151617181920*//udp_client.js*let dgram = require('dgram');let client = dgram.createSocket('udp4');client.on('listening',function()&#123;client.addMembership('230.185.192.108');&#125;);client.on('message',function(message,remote)&#123;console.log(message.toString());&#125;);client.bind(8080,'192.168.1.103'); 5.4.3 DNS服务器3.4.3.1 域名 域名空间结构 根域 顶级域 组织域 国家/地区域名 二级域名 3.4.3.2 DNS服务器 DNS是Domain Name Service的缩写，DNS服务器进行域名和与之对应的IP地址转换的服务器 IP地址不易记忆 早期使用Hosts文件解析域名 主要名称重复 主机维护困难 DNS(Domain Name System 域名系统) 分布式 层次性 3.4.3.3 查找过程 客户端向本地域名服务器发出请求，我要访问www.163.com，请告诉我它的IP地址 本地DNS服务器向DNS根服务器发出请求，根DNS服务器会告诉本地服务器(.com)的服务器地址 本地DNS服务器会向(.com域)发请求，会得到(163.com)的服务器地址 本地DNS服务器会向(163.com)发请求,会得到(www.163.com)的IP地址1.1.1.1 本地DNS服务器向客户端回复域名(www.163.com)对应的IP地址是1.1.1.1 5.4.4 DHCP服务器（Dynamic Host Configuration Protocol） 保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。 DHCP应当可以给用户分配永久固定的IP地址。 DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机） DHCP服务器应当向现有的BOOTP客户端提供服务。 5.4.4.1 工作流程 主机发送DHCPDISCOVER广播包在网络上寻找DHCP服务器； DHCP服务器向主机发送DHCPOFFER单播数据包，包含IP地址、MAC地址、域名信息以及地址租期； 主机发送DHCPREQUEST广播包，正式向服务器请求分配已提供的IP地址； DHCP服务器向主机发送DHCPACK单播包，确认主机的请求 5.4.4.2 抓包 6. 应用层6.1 协议 6.2 应用层常见协议 HTTP 超文件传输协议 FTP 文件传输协议 SMTP(发送邮件)和POP3(接收邮件) 6.3 案例数据-&gt;传输层(包)-&gt;网络层(段Segment)-&gt;数据链路层(帧) 6.3.1 发送方是从高层到低层封装数据 在应用层要把各式各样的数据如字母、数字、汉字、图片等转换成二进制 在TCP传输层中，上层的数据被分割成小的数据段，并为每个分段后的数据封装TCP报文头部 在TCP头部有一个关键的字段信息端口号，它用于标识上层的协议或应用程序，确保上层数据的正常通信 计算机可以多进程并发运行，例如在发邮件的同时也可以通过浏览器浏览网页，这两种应用通过端口号进行区分 在网络层，上层数据被封装上亲的报文头部(IP头部)，上层的数据是包括TCP头部的。IP地址包括的最关键字段信息就是IP地址，用于标识网络的逻辑地址。 数据链路径层，上层数据成一个MAC头部，内部有最关键的是MAC地址。MAC地址就是固化在硬件设备内部的全球唯一的物理地址。 在物理层，无论在之前哪一层封装的报文头和还是上层数据都是由二进制组成的，物理将这些二进制数字比特流转换成电信号在网络中传输 6.3.2 接收方是从低层到高层解封装 数据封装完毕传输到接收方后，将数据要进行解封装 在物理层，先把电信号转成二进制数据，并将数据传送至数据链路层 在数据链路层，把MAC头部拆掉，并将剩余的数据传送至上一层 在网络层，数据的IP头部被拆掉，并将剩余的数据送至上一层 在传输层，把TCP头部拆掉，将真实的数据传送至应用层 6.3.3 真实网络环境 发送方和接收方中间可能会有多个硬件中转设备 中间可能会增加交换机和路由器 数据在传输过程中不断地进行封装和解封装的过程，每层设备只能处理哪一层的数据 交换机属于数据链路层 路由器属于网络层 A电脑 -&gt; A交换机 -&gt; A路由器 -&gt; B路由器 -&gt; B交换机 -&gt; B电脑 7. 附录7.1 不同层中的称谓 数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。 数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。 段（Segment）：通常是指起始点和目的地都是传输层的信息单元。 消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 7.2 IP头服务类型 IP首部中的服务类型（TOS） TOS包括共8位，包括3 bit的优先权字段（取值可以从000-111所有值），4 bit的TOS子字段和1 bit未用位但必须置0。 3bit的8个优先级的定义如下： 111–Network Control(网络控制）一般保留给网络控制数据使用，如路由。 110–Internetwork Control(网间控制) 101–Critic(关键)语音数据使用。 100–Flash Override(疾速)视频会议和视频流使用。 011–Flash(闪速)语音控制数据使用。 010–Immediate(快速)数据业务使用 001–Priority(优先)数据业务使用 000–Routine(普通)默认标记值。 4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是一般服务。 Telnet、Rlogin这两个交互应用要求最小的传输时延，FTP文件传输要求最大吞吐量，最高可靠性是指网络管理（SNMP）和路由选择协议。用户网络新闻要求最小费用","categories":[{"name":"net","slug":"net","permalink":"http://yoursite.com/categories/net/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"go2","slug":"go2","date":"2021-03-24T13:10:34.000Z","updated":"2021-06-01T03:58:49.384Z","comments":true,"path":"2021/03/24/go2/","link":"","permalink":"http://yoursite.com/2021/03/24/go2/","excerpt":"","text":"1. io1.1 写文件按字符串写 WriteString 12345678910func main()&#123; f, err:= os.OpenFile(\"./a.txt\", os.O_RDWR, 6) if err != nil &#123; fmt.Println(\"openFile err:\", err) return &#125; defer f.Close() n, err := fmt.Println(\"success\") // n 写入字符个数 f.WriteString(\"123\") // 按字符串写&#125; 按位置写 writeAt 1234// Seek() // 文件位置指针off, _ := f.Seek(-5, io.SeekEnd)fmt.Println(\"off\", off) // off 表示从文件起始位置往后偏的值n, err = f.WriteAt([]byte(\"1111\"), off) 1.2 读文件按行读 12345678910111213141516func main()&#123; f, err:= os.OpenFile(\"./a.txt\", os.O_RDWR, 6) if err != nil &#123; fmt.Println(\"openFile err:\", err) return &#125; defer f.Close() fmt.Println(\"success\") // 创建一个带有缓冲区的reader reader := bufio.NewReader(f) buf, err := reader.ReadBytes('\\n') // 读一行数据 if err != nil &#123; fmt.Println(\"ReadBytes err\", err) &#125; fmt.Println(string(buf)) // hellowo1111&#125; 12345678910// 全部读取reader := bufio.NewReader(f)for &#123; buf, err := reader.ReadBytes('\\n') // 读一行数据 if err != nil &amp;&amp; err == io.EOF &#123; fmt.Println(\"ReadBytes err\", err) return &#125; fmt.Println(string(buf)) // hellowo1111&#125; 1.3 缓冲区磁盘构成 振臂 磁头 磁道 扇区 一个扇区512B，数据在磁盘存储时至少要占据一个扇区。 磁盘读取是物理操作，物理操作取决于硬件的性能。考虑到物理操作性能开销明显，所以需要进行性能优化。便有了缓冲区。 一次性尽可能多的奖磁盘上的内容读取到当前内存中，比如需要一行文件。但是缓冲区真正从磁盘上读取的时候。它不止拿了一行。而是尽可能的奖当前扇区里面的数据都读取过来。因为读一行和把当前扇区读完，对于磁头来说，都是一次物理操作。 一个场景，当读取一行之后，还需要继续读。那么这个时候，就可以直接从缓冲区中读取了，而不需要再次让磁盘执行物理操作读取。而从内存中读取数据是电子操作（电子操作访问速度接近光速，比物理操作快得多） 缓冲区 “预读入，缓输出” 往磁盘上写数据的时候，大多情况下是先写到缓冲区中了。等待缓冲区满，由操作系统批量一次性刷到磁盘当中。 1.4 32位与64位内存地址32位 最大内存地址 2^32 4GB（进程空间） 64位 最大内存地址 2^64 比较大 2. 协议2.1 概述协议，就是双方约定好的一份的合同，在数据传输层面来说。如果要传输一个文件。我们必然需要来分析一下文件的特征。 对于发送端来说，我要怎么确保我发出去的东西，接收端能拿到并且拿到的东西是对的；一 文件不能串台，二，文件不能有丢失； 那最早的传输协议雏形，首先发过去文件名，其次发过去这个文件有多大，最后将文件内容拆包分发。 对应的在接收端，就知道这个文件的名称和容量的，当接收完毕之后。要校验一下文件名是否对的上的，文件大小是否对的上啊。这就是最早的FTP协议雏形 后续，随着需要越来越复杂，文件的类型也越来越多，文件体积越来越大。到这个时候，聪明的人类不断地升华这份合同，如果尽可能简单的去把问题高效解决了一直促进着计算机网络的发展； 2.2 典型协议传输层 TCP/UDP 应用层 HTTP/FTP 网络层 IP ICMP IGMP 网络接口层 ARP RARP TCP 传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议 UDP 用户数据报协议 是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送信息 HTTP超文本传输协议 FTP 文件传输协议 IP协议 ICMP internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制器之间 IGMP internet组管理协议，是internet协议族中的一个组播协议，该协议运行在主机和组播路由器之间 ARP 协议是正向地址解析协议，通知已知IP，寻找对应主机的MAC地址。 RARP 是反向地址转换协议，通过MAC地址确定IP地址 2.3 分层模型每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽 OSI/RM(理论上的标准) TCP/IP（事实上的标准） 应用层 应用层 表示层 应用层 会话层 应用层 传输层 传输层 网络层 网络层 数据链路层 链路层 物理层 链路层 2.4 层与协议 各层功能 网络层 -&gt; ip 传输层 -&gt; port 2.5 传输过程， 将一条字符串从一台主机发往另外一台主机 2.5.1 链路层两台主机传输数据，需要硬件支持，主机上得有网卡，软件得有网卡驱动。网卡对应的就是ARP协议 网卡身份证（全球唯一）：MAC地址；数据包的物理发送地址和物理接收地址 ARP协议：借助IP地址获得MAC地址； RARP协议： 借助MAC地址获得IP地址； 2.5.2 网络层网络层的作用是引进一套新地址，能够区分不同计算机是否属于同一个子网络。这套地址就叫做“网络地址”，就是平时说的IP地址； 网络地址帮助确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。 IP协议： 在网络环境中唯一标识一台主机； IP地址本质： 2进制数——点分十进制 IP地址 2.5.3 传输层TCP/UDP协议 封装port——在一台主机上唯一标识的进程； 2.5.4 应用层截止到应用层，通过链路层确定MAC地址，通过网络层确定IP地址，通过传输层由PORT定位到进程。至此目标主机确定下来了； 接下来开始传输实际的数据了，当然不会赤裸裸的将 字符串 丢网上，前面说了，发送端得确保接收端确实拿对并拿全了这个数据包才行；就便有了应用层的协议； 比如http协议，有文件名，文件MIME，请求体，请求状态等等等等； 2.5.5 数据包封装的过程自上向下 待发送的原理数据 应用层 传输层 ——TCP/UDP， 确定PORT 标识主机上一个进程 网络层——IP 网络地址—— 唯一标识网络的一台主机 链路层——ARP 获取MAC地址 用户层 应用层 kernel层 传输层 网络层 链路层 封装：应用层——传输层——网络层——链路层 解封装： 链路层——网络层——传输层——应用层 2.5.6 总结 mac地址 IP地址（需指定） port（需指定） 不能使用系统占用默认端口（80:万维网要用端口，8080：浏览器，5000+用户使用） 5000-65535（port范围） 3. socket编程网络通信过程中，socket一定是成对出现的； 双向半双工 -&gt; 对讲机 （从右往左，从左往后都可以。一旦其中一端指定了，另一端就也确定了） 双向全双工 -&gt; 电话 单工通信 -&gt; 遥控器 socket是一种典型的双向全双工通信，它的实现是通信的一端封装了两个channel，对外只提供一个访问接口。 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程，“IP地址+端口号”就对应一个socket，欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用socket来描述网络连接的一对一关系。 常用的socket类型有两种： 流式socket（SOCK_STREAM）和数据包式socket (SOCK_DGRAM)。 流式是一种面向连接的socket，针对于面向连接的TCP服务应用： 数据报式socket是一种无连接的socket，对应于无连接的UDP服务应用； 3.1 网络应用程序设计模式C/S模式 传统的网络应用设计模式，客户机（client）和服务器（server）模式，需要在通讯两端各自部署客户机和服务器来完成数据通信 B/S模式 浏览器（browser）/服务器（server）模式，只需要在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输 优缺点 对于C/S模式来说，其优点明显，客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活，可以在标准协议的基础上根据需求裁剪及定制。比如ftp协议的修改裁剪版； C/S模式的缺点突出，客户端和服务器都需要有一个开发团队来完成开发，工作量成倍提升，开发周期较长，从用户角度出发， 需要将客户端安插至用户主机上，对用户主机的安全性构成威胁，这也是很多用户不愿使用C/S模式应用程序的重要原因； B/S模式相比C/S模式而言，由于它没有独立客户端，使用标准浏览器作为客户端，只需要开发服务器端即可（服务端渲染页面可以理解为只开发服务器）。浏览器跨平台兼容，所以不受平台限制。 B/S的缺点就是网络应用支持受限，其他主要是浏览器本身的性能和os对比的性能差异； 3.2 TCP的C/S架构c/s架构的协议选择，TCP和UDP，TCP和UDP的差别就是在数据传输之前是否先建立好连接。TCP是先建立好连接，UDP是不建立好连接，直接传输数据。 socket 通信架构 起一个server服务器，Listen方法，该方法不是监听客户端链接。而是指定IP+port，Listen函数也创建了一个socket，但是此socket不用于通信，它只用于创建通信的socket，它保存IP和port。所以后续有客户端请求的socket进来，这个socket就copy一份出去接客； 使用Listen() 返回值创建一个 Accept，阻塞监听客户端链接 当有客户端链接进来，Accept会返回一个socket，这个socket用于通信。 此刻在client调用Dial函数，也返回一个socket，用于通信。socket在通信中成对出现 服务器判断关闭 Read读客户端，返回0， —— 对端关闭！ nc命令发送数据时，默认在结尾自带’\\n’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"fmt\" \"net\")func main() &#123; listener, err := net.Listen(\"tcp\", \"127.0.0.1:8000\") if err != nil &#123; fmt.Println(\"err=\", err) return &#125; defer listener.Close() fmt.Println(\"wait client\") for &#123; conn, err := listener.Accept() // 阻塞监听客户端连接请求 if err != nil &#123; fmt.Println(\"Accept() err:\", err) return &#125; go handlerFunc(conn) &#125;&#125;func handlerFunc(conn net.Conn) &#123; buf := make([]byte, 4096) fmt.Println(\"conn success\") for &#123; n, err := conn.Read(buf) if \"exit\\n\" == string(buf[:n]) &#123; fmt.Println(\"client exit:\") return &#125; if n == 0 &#123; fmt.Println(\"client exit:000\") return &#125; fmt.Println(n) if err != nil &#123; fmt.Println(\"conn.Read err:\", err) return &#125; defer conn.Close() fmt.Println(\"accept client:\", string(buf[:n])) &#125;&#125; 3.3 TCP通信过程三次握手（连接过程），四次挥手（断开过程） 1.为什么建立协议是三次握手,而关闭连接却是四次握手呢？ 因为是多个半关闭状态， 某一端完全写完之后可以停止发送，但没法停止接收。须等对端发完数据，发完断开请求之后，才能关闭并通知对端； 因为服务器端的LISTEN状态下的SOCKET当收到SYN报文建连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文时发送。但是关闭连接，当收到对应FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方表示同间现在可以关闭连接了，所以这里的ACK报文和FIN报文多数情况下都是分开发送的 2.为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 因为虽然对方同间关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISHED状态）但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文人一定被双方收到，因此处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来生发可能丢失的ACK报文 三次握手 主动发起请求短，发送SYN 被动建立连接请求端，应答ACK同时发送SYN 主动发送请求端，发送应答ACK 标志TCP三次握手建立完全 —— server： Accept（）返回， —— client Dial 返回 四次挥手 主动关闭连接请求，发送FIN 被动关闭连接请求端，应答ACK （标志，半关闭完成。 —— close() 被动关闭连接请求端，发送FIN 主动关闭连接请求端，应答ACK (标志，四次挥手建立完成 —— close) 3.4 TCP状态TCP状态转换图 主动发起连接请求端：CLOSED——完成三次握手——ESTABLISEHED（数据通信状态）——Dial函数返回 被动发起连接请求端：CLOSED2——调用Accept函数——LISTEN——完成三次握手——ESTABLISEHED（数据通信状态——Accept函数返回 ​ 数据传递期间——ESTABLISEHED（数据通信状态） 主动关闭连接请求端：ESTABLISEHED——FIN_WAIT_2（半关闭） ——TIME_WAIT ——2MSL——确认最后一个ACK被对端成功接收 （半关闭，TIME_WAIT，2MSL——只会出现在“主动关闭连接请求端” ） 被动关闭连接请求端： ESTABLISEHED——CLOSE 状态说明： CLOSED:表示初始状态 LISTEN:表示服务器端的某个SOCKET处于监听状态，可以接受连接了 SYN_RCVD:表示接受到了SYN报文，在正常情况下，这个状态是服务器SOCKET建立TCP连接的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这个状态，除非写一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不发送因此这个状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态 ESTABLISHED:表示连接已经建立了 FIN_WAIT_1:1和2真正的含义是表示等待对方的FIN报文，而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHE态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WATI_1状态，而当对方回应ACK报文后则进入到FIN_WAIT_2状态，当然在实际正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态比较难见，而FIN_WAIT_2状态还有时常可以用netstat看到 FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据要传送给你稍后再关闭连接 TIME_WAIT:表示收到了对方的FIN报文，并发送出ACK报文，就等2MSL后即可回到CLOSED可用状态了，如果FIN_WAID_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态 CLOSING:这种状态比较特殊，实际情况中很少见。正常情况下，发送FIN报文后，按理来说应该先收到（或同时收到）到方的ACK报文再收到对方的FIN报文，但是CLOSING状态表示你发送FIN报文后，并没有收到的收到对方的ACK报文，反而却也收到了对方的FIN报文。发生的原因：如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接 CLOSE_WAIT:表示等待关闭，当对方close一个SOCKET后发送FIN报文给自己，系统毫无疑问也会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态，接下来，实际上真正要考虑的是看你是否还有数据发送给对方，如果没有的各话，那么你也可以close这个SOCKET，发送FIN报文给对方，也即关闭连接，所以你有CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接 LAST_ACK:表示被动关闭一方在发送FIN报文后，最后等待对方的ACK报文，当收到ACK报文后，也即可以进入到CLOSED可用状态了 3.4.1 TCP状态 - 查看程序运行状态命令123456// linuxnetstat -apn|grep 8000// mac osnetstat -a lsof -i:8000 // MAC OS 查看端口情况 3.5 UDP由于UDP是“无连接”的，所以，服务器端不需要额外创建监听套接字，只需要指定好IP和port，然后监听该地址，等待客户端与之建立连接，即可通信； 12345678// 创建监听地址func ResolveUDPAddr(network, address string)(*UDPAddr, error)// 创建用户通信的socketfunc ListenUDP(network, laddr *UDPAddr)(*UDPConn, error)// 接收udp数据func (c *UDPConn)ReadFromUDP(b []byte)(int *UDPAddr, error)// 写出数据到udpfunc (c *UDPConn)WriteToUDP(b []byte, addr *UDPAddr)(int, error) UDP通信 无连接的，不可靠的报文传递，UDP因为无连接，所以线路取决于网络，网络状况会导致UDP丢包；只不过UDP的丢包问题系统层面不会执行重传；因此弥补这一缺陷需要在应用层对数据包进行校验；（需要封装针对UDP底层传输丢包问题的协议） TCP通信： 面向连接的，可靠的数据包传输，不是说TCP不丢包，而是说TCP丢包之后会重传，这个重传指令是系统层面在做； 3.5.1 udp通信流程 创建用于通信的socket 阻塞读socket 处理读到的数据 写数据给客户端 3.5.2 udp通信1234567891011121314151617181920212223242526272829303132// serverfunc main() &#123; udpsev, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:8001\") if err != nil &#123; fmt.Println(\"ResolveUDPAddr err:\", err) return &#125; conn, err := net.ListenUDP(\"udp\", udpsev) if err != nil &#123; fmt.Println(\"ListenUDP err:\", err) return &#125; defer conn.Close() buf := make([]byte, 4096) n, cltAddr, err := conn.ReadFromUDP(buf) if err != nil &#123; fmt.Println(\"ReadFromUDP\", err) return &#125; fmt.Println(\"buf...\", string(buf[:n])) _, err = conn.WriteToUDP([]byte(\"hi udp client\"), cltAddr) fmt.Println(\"not got\") if err != nil &#123; fmt.Println(\"writeToUdp\", err) return &#125;&#125; 12345678910111213141516171819// clientfunc main() &#123; conn, err := net.Dial(\"udp\", \"127.0.0.1:8001\") if err != nil &#123; fmt.Println(\"net.Dial err:\", err) return &#125; defer conn.Close() conn.Write([]byte(\"from client\")) buf := make([]byte, 4096) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"Read err:\", err) return &#125; fmt.Println(\"server send\", string(buf[:n]))&#125; 12//client nc默认是TCP的，加上-u参数表示udp$&gt; nc -u 127.0.0.1 \"port\" UDP服务器： 创建server端地址结构 net.ResolveUDPAddr() 创建用于通信的socket，绑定地址结构 udpConn = net.ListenUDP() Defer udpConn.Close() 读取客户端发送数据 ReadFromUDP() 返回： n, cltAddr(客户端的IP+port)，err 写数据给客户端 WriteToUDP(“待写数据”，cltAddr) UDP客户端： 参考TCP客户端 Net.Dial(“udp”, server的IP+PORT) 3.6 UDP与TCP的差异 TCP UDP 面向连接 面向无连接 要求系统资源较多（系统需要一套资源维护TCP协议） 要求系统资源较少 TCP程序结构比较复杂 UDP程序结构较简单 使用流式（建立通道后源源不断的写） 使用数据包式（单次发送就完事了） 保证数据准确性（回执机制） 不保证数据准确性（数据包的路径每次都可能不一样） 保证数据顺序 不保证数据顺序 通讯速度较慢 通讯速度较快 TCP： 对不稳定网络层，做完全弥补操作 UDP： 对不稳定的网络层，不作为 使用场景： TCP：对数据传输安全性 稳定性要求较高的场合，网络文件传输，下载，上传。 UDP：对数据实时传输要求较高的场合，视频直播 在线电话会议，游戏 3.7 文件传输流程简析 借助TCP完成文件的传输， 发送方向服务端发送文件名，服务端保存该文件名 接收方（服务端）向客户端返回一个消息ok，确认文件名保存成功 发送方（客户端）收到消息后，开始向服务端发送文件数据 接收方（服务端）读取文件内容，写入到之前保存好的文件中； 首先获取文件名，借助os包中stat函数来获取文件属性信息。在函数返回的文件属性中包含文件名和文件大小、Stat参数name传入的是文件访问的绝对路径。FileInfo中的Name函数可以将文件名单提取出来； 12345678910func Stat(name string) (FileInfo, error)// A FileInfo describes a file and is returned by Stat and Lstat.type FileInfo interface &#123; Name() string // base name of the file Size() int64 // length in bytes for regular files; system-dependent for others Mode() FileMode // file mode bits ModTime() time.Time // modification time IsDir() bool // abbreviation for Mode().IsDir() Sys() interface&#123;&#125; // underlying data source (can return nil)&#125; 3.7.1 文件属性12345678910111213141516func main() &#123; list := os.Args if len(list) != 2 &#123; fmt.Println(\"\") return &#125; path := list[1] fileInfo, err := os.Stat(path) if err != nil &#123; fmt.Println(\"os.Stat err:\", err) return &#125; fmt.Println(fileInfo.Name(), fileInfo.Size()) // cl.go 285&#125; 3.7.2 send 提示用户使用命令行参数输入文件名，接收文件名filepath（含访问路径） 使用os.Stat（）获取文件属性，得到纯文件名fileName（去除访问路径） 主动发送链接服务器请求，结束时关闭连接 发送文件名到接收端conn.Write() 读取接收端回发的确认数据conn.Read() 判断是否为“ok”，如果是，封装函数SendFile()发送文件内容，传参filePath 和conn 只读Open文件，结束时Close文件 循环读本地文件，读到EPF，读取完毕 将读到的内容原封不动conn.Write给接收端（服务器） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172func sendFile(conn net.Conn, filePath string) &#123; // open file by readOnly f, err := os.Open(filePath) if err != nil &#123; fmt.Println(\"open file err:\", err) return &#125; defer f.Close() // core, use buf loop the data until EOF buf := make([]byte, 4096) for &#123; n, err := f.Read(buf) if err != nil &#123; if err == io.EOF &#123; fmt.Println(\"file send complete:\", err) return &#125; else &#123; fmt.Println(\"Read file err:\", err) return &#125; &#125; // write to net _, err = conn.Write(buf[:n]) if err != nil &#123; fmt.Println(\"is.Stat err:\", err) return &#125; &#125;&#125;func main() &#123; list := os.Args if len(list) != 2 &#123; fmt.Println(\"\") return &#125; path := list[1] fileInfo, err := os.Stat(path) if err != nil &#123; fmt.Println(\"os.Stat err:\", err) return &#125; fileName := fileInfo.Name() fileSize := fileInfo.Size() fmt.Println(\"fileName=\", fileName, \"fileSize=\", fileSize) conn, err := net.Dial(\"tcp\", \"127.0.0.1:8009\") if err != nil &#123; fmt.Println(\"dial tcp err:\", err) return &#125; defer conn.Close() // send file name to recv _, err = conn.Write([]byte(fileName)) if err != nil &#123; fmt.Println(\"conn Write err:\", err) return &#125; // read \"OK\" buf := make([]byte, 4096) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"conn read err:\", err) return &#125; if string(buf[:n]) == \"OK\" &#123; sendFile(conn, path) &#125;&#125; 3.7.3 recv 创建监听socket，程序结束时关闭 阻塞等待发送端连接Accept，程序结束时关闭conn 接收（读取）文件名，保存 回发ok 封装函数RecvFile接收客户端发送的文件内容，传参fileName和conn 按文件名creat文件，结束时close 循环read发送端网络文件内容，当读到0说明文件读取完毕 将读到的内容原封不动的Write到创建的文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func recvFile(conn net.Conn, filename string) &#123; // create file deps filename f, err := os.Create(filename) if err != nil &#123; fmt.Println(\"os.Create err:\", err) return &#125; defer f.Close() // get data from socket and write in file buf := make([]byte, 4096) for &#123; n, _ := conn.Read(buf) if n == 0 &#123; fmt.Println(\"receive file complete\") return &#125; // write into local file f.Write(buf[:n]) &#125;&#125;func main() &#123; listener, err := net.Listen(\"tcp\", \"127.0.0.1:8009\") if err != nil &#123; fmt.Println(\"listen tcp err:\", err) return &#125; defer listener.Close() conn, err := listener.Accept() if err != nil &#123; fmt.Println(\"conn err:\", err) return &#125; defer conn.Close() // require filename and save buf := make([]byte, 4096) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"conn Read:\", err) return &#125; filename := string(buf[:n]) fmt.Println(\"filename=\", filename) // send \"ok\" _, err = conn.Write([]byte(\"OK\")) if err != nil &#123; fmt.Println(\"write Ok err:\", err) &#125; // require file content recvFile(conn, filename)&#125; 4. HTTPweb工作方式： 客户端——&gt; 访问www.xxx.域名-&gt; DNS服务，返回对应IP 客户端——》 IP+port -〉 访问网页数据（TCP连接，HTTP协议） http和URL：http 规定了浏览器访问服务器进行数据通信的规则。http —— TLS、ssl——https URL： http请求包： 请求行： 请求方法（空格）请求文件URL（空格）协议版本（\\r\\n） 请求头：key:value 空行：\\r\\n —— 代表http请求头结束 4.1 HTTP服务创建流程1234// 注册处理函数，设置回调函数handlerhttp.HandleFunc()// 绑定服务器监听地址 http.ListenAndServe() Do: 静态文件服务器： 选定一个目录，存放jpg，png，txt，gif,m4a等类型文件，编写一饿服务器程序，可以给浏览器提供该目录下文件的访问服务； 1234func main()&#123; resp, err := http.Get(\"http://xxx\") defer resp.Body.Close() // 关闭resp.Body 而不是 resp&#125; 123456789101112for &#123; n,err:=resp.Body.Read(buf) if n==0 &#123; // 网络环境，通常用0去判断是否结尾。因为channel的缘故 fmt.Println(\"Read finish!\") break &#125; if err!= nil &amp;&amp; err != io.EOF &#123; // 本地文件读取，通常用EOF fmt.Println(\"\") return &#125; result += string(buf[:n])&#125;","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"go_web","slug":"go-web","date":"2021-03-16T10:12:02.000Z","updated":"2021-04-19T10:40:40.019Z","comments":true,"path":"2021/03/16/go-web/","link":"","permalink":"http://yoursite.com/2021/03/16/go-web/","excerpt":"","text":"1. 概要处理请求 模版 中间件 存储数据 HTTPS，HTTP2 测试 部署 2. 处理请求2.1 Create pro创建模块 GO111MODULE=on go mod init pro name helloworld 1234567891011package mainimport \"net/http\"func main() &#123; http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"hi go web\")) &#125;) http.ListenAndServe(\"localhost:8999\", nil)&#125; 2.2 如何处理web请求http.Handle 函数 http.HandleFunc 函数 2.2.1 创建web Server两种方式 方式一 http.ListenAndServer() http.ListenAndServeTLS() https 服务 第一个参数是网络地址， 第二个参数为handler 如果为nil，那么就是DefaultServeMux DefaultServeMux 是一个multiplexer（可以看作是一个路由器） 1http.ListenAndServe(\"localhost:8989\", nil) 方式二 http.Server可配置 server.ListenAndServe() server.ListenAndServeTLS() 12345server:= http.Server &#123; Addr: \"localhost:8989\", Handler: nil&#125;server.ListenAndServe() 2.2.2 DefaultServeMux它是一个multiplexer 多路复用器 它也是一个handler 1234567891011121314151617package mainimport \"net/http\"type myHandler struct&#123;&#125;func (m *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"myHandler\"))&#125;func main() &#123; mu := myHandler&#123;&#125; server := http.Server&#123; Addr: \"localhost:8989\", Handler: &amp;mu, &#125; server.ListenAndServe()&#125; 多个handler 不指定Server struct里面的Handler字段值 可以使用http.Handle将某个Handler附加到DefaultServeMux http包有一个Handle函数 ServerMux struct也有一个Handle方法 如果你调用http.Handle，实际上调用的是DefaultServeMux上的Handle方法 1234func Handle(patten string, handler Handler) // 注册函数type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; 1234567891011121314151617181920212223242526package mainimport \"net/http\"type myHandler struct&#123;&#125;func (m *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"myHandler\"))&#125;type hiHandler struct&#123;&#125;func (m *hiHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"hello handler\"))&#125;func main() &#123; mu := myHandler&#123;&#125; hi:= hiHandler&#123;&#125; server := http.Server&#123; Addr: \"localhost:8989\", Handler: nil, &#125; http.Handle(\"/mu\", &amp;mu) http.Handle(\"/hi\", &amp;hi) server.ListenAndServe()&#125; 2.2.3 Handler 函数 - http.HandleFunchandler是一个接口（interface） 123type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; Handler函数就是那些行为与handler类似的函数： Handler函数的签名与ServeHTTP方法的签名一样，接收： 一个http.ResponseWriter 一个指向http.Request的指针 Go有一个函数类型： HandlerFunc，可以将某个具有适当签名的函数f， 适配成为一个Handler，而这个Handler具有方法 f 12345678910111213141516171819202122232425262728293031package mainimport \"net/http\"type myHandler struct&#123;&#125;func (m *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"myHandler\"))&#125;type hiHandler struct&#123;&#125;func (m *hiHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"hello handler\"))&#125;func welcome (w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"weclome\"))&#125;func main() &#123; mu := myHandler&#123;&#125; hi:= hiHandler&#123;&#125; server := http.Server&#123; Addr: \"localhost:8989\", Handler: nil, &#125; http.Handle(\"/mu\", &amp;mu) http.Handle(\"/hi\", &amp;hi) //http.HandleFunc(\"/weclome\", welcome) http.Handle(\"/wel\", http.HandlerFunc(welcome)) // handleFunc 函数内部有适配器 handlerFunc server.ListenAndServe()&#125; 适配器HandlerFunc 123456type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP calls f(w, r).func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123; f(w, r)&#125; 2.2.4 五个内置handlerNotFoundHandler 404 RedirectHandler 返回一个handler，把每个请求使用给定的状态吗跳转到指定的URl url，要跳转到的URL code，跳转的状态吗（3XX），常见的 StatusMovedPermanently， StatusFound 或 StatusSeeOther StripPrefix 返回一个handler，它从请求URL中去掉指定的前缀，然后再调用另一个handler TimeoutHandler FileServer 1func FileServer(root FileSystem) Handler 返回一个handler，使用基于root的文件系统来相应请求 123type FileSystem interface &#123; Open(name string)(File, error)&#125; 使用时需要用到操作系统的文件系统，所以还需要委托给操作系统的文件系统来获取文件； 12type Dir stringfunc (d Dir) Open(name string)(File,error) 123456789101112package mainimport \"net/http\"func main() &#123; //http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) &#123; // fmt.Printf(request.URL.Path) // http.ServeFile(writer, request, \"/webroot\"+request.URL.Path) //&#125;) //http.ListenAndServe(\":8000\", nil) http.ListenAndServe(\":8000\", http.FileServer(http.Dir(\"webroot\")))&#125; 2.2.5 RequestHTTP请求 Request URL Header Body 2.2.5.1 HTTP消息HTTP Request 和 HTTP Response 它们具有相同的结构 请求（响应）行 0个或多个Header 空行 可选的消息体（Body） net/http 包提供了用于表示HTTP消息的结构 Request（是个struct），代表了客户端发送的HTTP请求消息 Request（是个struct），代表了客户端发送的HTTP请求消息 重要字段： URL Header Body Form，PostForm，MultipartForm 也可以通过Request的方法访问请求中的Cookie、URL、User Agent等消息 Request即可代表发送到服务器的请求，又可代表客户端发出的请求； 2.2.5.2 请求URLRequest的URL字段就代表了请求行（请求信息第一行）里面的部分内容 URL字段是指向url.URL类型的一个指针，url.URL是一个struct： 123456789type URL struct &#123; Scheme string Opaque string User *Userinfo Host string Path string RawQuery string Fragment string&#125; URL通用形式 scheme://[userinfo@]host/path[?query][#fragment] 不可以斜杠开头的URL被解释为： scheme:opaque[?query][#fragment] 2.2.5.3 URL QueryRawQuery 会提供实际查询的字符串 http://www.example/com/post?id=123&amp;thread_id=456 它的RawQuery的值就是id=123&amp;thread_id=456 还有一个简便的方法可以得到Key-Value对： 通过Request的Form字段 2.2.5.4 URL Fragment如果从浏览器发出的请求， 那么你无法提取出Fragment字段的值； 浏览器在发送请求时会把fragment部分去掉 但不是所有的请求都是从浏览器发出的（例如从HTTP客户端包） 2.2.5.5 Request Header请求和响应（Request、Response）的headers是通过Header类型来描述的，它是一个map，用来表述HTTP Header里的 Key-Value对； Header map的key是string类型，value是[]string 设置key的时候会创建一个空的[]string 作为value，value里面第一个元素就是新header的值； 为指定的key添加一个新的header值，执行append操作即可 res.Header 返回map r.Header[“Accept-Encoding”] 返回：[gzip,deflate]([]string类型) r.Header.Get(“Accept-Encoding”) 返回： gzip，deflate(string类型) 2.2.5.6 Request Body请求和响应的bodies都是使用Body字段来表示的 Body是一个io.ReadCloser接口 一个是Reader接口 一个是Closer接口 Reader接口定义了一个Open方法： 参数： []byte 返回：byte的数量、可选的错误 Closer接口定义了一个Close方法： 没有参数，返回可选的错误； 想要读取请求body的内容，可以调用Body的Read方法 12345678910111213141516 server := http.Server&#123; Addr: \":8989\", &#125; http.HandleFunc(\"/header\", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, r.Header) fmt.Fprintln(w, r.Header[\"Accept-Encoding\"]) fmt.Fprintln(w, r.Header.Get(\"Accept-Encoding\")) &#125;) http.HandleFunc(\"/post\", func(w http.ResponseWriter, r *http.Request) &#123; length := r.ContentLength body := make([]byte, length) // 创建一个长度为ContentLength的 byte slice r.Body.Read(body) // 将Body里面的内容，通过Read方法读取到body中 fmt.Fprintln(w, string(body)) &#125;) server.ListenAndServe()&#125; 2.2.5.7 查询参数（Query Parameters）URL Query http://www/example.com/post?id=123&amp;thread_id=456 r.URL.RawQuery会提供实际查询的原始字符串 上例的RawQuery的值就是 id=123&amp;thread_id=456 r.URL.Query() 会提供查询字符串对应的 map[string][]string 1234url := r.URLquery := url.Query() // map[string][]stringid := query[\"id\"] // []string&#123;\"123\"&#125;threadID := query.Get(\"thread_id\") // \"456\" 2.2.6 Form2.2.6.1 通过表单发送请求12345&lt;form action=\"/process\" method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 这个HTML表单里面的数据会以name-value对的形式，通过POST请求发送出去 它的数据内容会放在POST请求的Body里面 但name-value对在Body里面的格式是什么样的？ 表单Post请求的数据格式 通过POST发送的name-value数据对的格式可以通过表单的Content Type来指定，也就是enctype属性 表单的enctype属性 默认值是：application/x-www-form-urlencoded 浏览器被要求至少要支持： application/x-www-form-urlencoded、multipart/form-data html5的话，还需要支持text/plain 如果enctype是application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。 first_name=alex&amp;last_name=chang 如果enctype是multipart/form-data，那么 每一个name-value对都会被转换为一个MIME消息部分 每一个部分都有自己的Content Type 和Content Disposition 如何选择？ 简单的文本： application/x-www-form-urlencoded 大量数据，（文件上传）： multipart-MIME 甚至可以把二进制数据通过选择Base64编码，来当作文本进行发送 表单的GET 通过表单的method属性，可以设置POST还是GET GET请求没有Body，所有的数据都通过URL的name-value对 来发送 2.2.6.2 字段Request上的函数允许我们从URL或/和Body中提取数据，通过这些字段：Form，PostForm，MultipartForm Form里面的数据是key-value对 通常的做法是： 先调用ParseForm 或 ParseMultipartForm来解析Request 然后相应的访问Form、PostForm或MultipartForm字段 Form 12345&lt;form action=\"/process\" method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() // 解析form fmt.Fprintln(w, r.Form)&#125;) PostForm 上例中，如果只想得到first_name 这个key 的value，可使用r.Form[“first_name”],它返回含有一个元素的slice: [“Dave”] 如果表单和URL里有同样的Key，那么它们都会放在一个slice里：表单里的值靠前，URL的值靠后； 如果只想要表单的key-value对，不要URL的，可以使用PostForm字段； 12345&lt;form action=\"/process?first_name=Leo\" method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234567http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() // 解析form fmt.Fprintln(w, r.Form) // map[first_name:[alex Leo] last_name:[ruan]] fmt.Fprintln(w, r.PostForm) // map[first_name:[alex] last_name:[ruan]]&#125;) PostForm只支持application/x-www-form-urlencoded，必须使用MultipartForm MultipartForm 想要使用MultipartForm 这个字段，首先需要调用ParseMultipartForm这个方法； 该方法会在必要时调用ParseForm方法 参数是需要读取数据的长度 MultipartForm只包含表单的key-value对 返回的类型是一个struct而不是map，这个struct里有两个map： key是string，value是[]string 空的（key是string， value是文件） 12345&lt;form action=\"/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 12345http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseMultipartForm(1024) //1024 为字节数 fmt.Fprintln(w, r.MultipartForm)&#125;)// &amp;&#123;map[first_name:[alex] last_name:[ruan]] map[]&#125; MultipartReader 1func (r *Request)MultipartReader()(*multipart.Reader,error) 如果是multipart/form-data或multipart混合的POST请求： MultipartReader 返回一个MIME multipart reader 否则返回nil和一个错误 可以使用该函数代替ParseMultipartForm来把请求的body作为stream进行处理 不是把表单作为一个对象来处理的，不是一次性获得整个map 逐个检查来自表单的值，然后每次处理一个； 2.2.6.3 FormValue &amp; PostFormValue方法FormValue方法会返回Form字段中指定key对应的第一个value 无需调用ParseForm或ParseMultipartForm 12345&lt;form action=\"http://localhost:8000/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, r.FormValue(\"first_name\"))&#125;)// Leo 来自于查询字符串，来自表单里面的值靠前，来自url的靠后，FormValue只取一个值（如果enctype为application/x-www-form-urlencoded的话）； PostFormValue方法也一样，但只能读取PostForm FormValue和PostFormValue都会调用ParseMultipartForm方法 但如果表单的enctype设为multipart/form-data，那么即使你调用ParseMultipartForm方法，也无法通过FormValue获得想要的值； 12345&lt;form action=\"http://localhost:8000/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 1234567http.HandleFunc(\"/process\", func(w http.ResponseWriter, r *http.Request) &#123; r.ParseMultipartForm(1024) //1024 为字节数 fmt.Fprintln(w, r.FormValue(\"first_name\")) fmt.Fprintln(w,r.PostFormValue(\"first_name\"))&#125;)// Leo// alex 2.2.6.4 上传文件（Files）Multipart/form-data最常见的应用场景就是上传文件（例子） 12345&lt;form action=\"http://localhost:8000/process?first_name=Leo\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"first_name\"/&gt; &lt;input type=\"text\" name=\"last_name\"/&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"io/ioutil\" \"net/http\")func process(w http.ResponseWriter, r *http.Request) &#123; r.ParseMultipartForm(1024) fileHeader:= r.MultipartForm.File[\"uploaded\"][0] file,err := fileHeader.Open() // 从File字段 获得的FileHeader，调用其Open获得文件。 if err == nil &#123; data, err := ioutil.ReadAll(file) // 读取文件内容到byte切片里 if err == nil &#123; fmt.Fprintln(w, string(data)) &#125; &#125;&#125;func main() &#123; server := http.Server&#123; Addr: \":8000\", &#125; http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) &#123; fmt.Printf(request.URL.Path) http.ServeFile(writer, request, \"webroot2\"+request.URL.Path) &#125;) http.HandleFunc(\"/process\", process) server.ListenAndServe()&#125; FormFile方法 上传文件还有一个简便方法：FormFile 123456789func process(w http.ResponseWriter, r *http.Request)&#123; file,_,err := r.FormFile(\"uploaded\") if err == nil &#123; data, err := ioutil.ReadAll(file) if err == nil &#123; fmt.Fprintln(w, string(data)) &#125; &#125;&#125; 无需调用ParseMultipartForm方法 返回指定key对应的第一个value 同时返回File和FileHeader，以及错误信息 如果只上传一个文件，那么这种方式会快一些 2.2.6.5 POST JSON不是所有的POST请求都来自Form 有很多不同的方式对POST请求编码 application/x-www-form-urlencoded application/json ParseForm方法无法处理application/json 2.2.7 ResponseWriter从服务器向客户端返回响应需要使用ResponseWriter ResponseWriter是一个接口，handler用它来返回响应 真正支撑ResponseWriter的幕后struct是非导出的http.response 问题： 为什么Handler的ServeHTTP（w ResponseWriter, r*Request）,只有一个是指针类型？而w是按值传递的吗？ ResponseWriter本身是一个interface，而它代表了一个指针，这个指针指向response这个struct的。所以它也可以看作是一个指针。所以它的传递也是按引用进行传递的； 123456789101112type ResponseWriter interface &#123; Header() Header Write([]byte)(int error) WriteHeader(statusCode int)&#125;type response struct &#123; ...&#125;func (w *response) Header()Headerfunc (w *response) Write()Writerfunc (w *response) WriteHeader()WriteHeader// 所以说 response指针就是实现了ResponseWriter接口，所以ResponseWriter接口就代表着 response指针； 2.2.7.1 写入到ResponseWriterwrite方法接收一个byte切片作为参数，然后把它写入到HTTP响应的Body里面； 如果在Write方法被调用时，header里面没有设定content type，那么数据的前512字节就会被用来检测content type 12345678910111213141516func writeExample(w http.ResponseWriter, r *http.Request) &#123; str := `&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;go web&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;`w.Write([]byte(str))&#125;func main() &#123; server := http.Server&#123; Addr: \":8000\", &#125; http.HandleFunc(\"/write\", writeExample) server.ListenAndServe()&#125; 1curl -i localhost:8000/write 2.2.7.2 WriteHeader方法WriteHeader方法接收一个整数类型（HTTP状态码）作为参数，并把它作为HTTP响应的状态码返回 如果该方法没有显式调用，那么在第一次调用Write方法前，会隐式的调用WriteHeader(http.StatusOK) 所以WriteHeader主要用来发送错误类的HTTP状态吗 调用完WriteHeader方法之后，仍然可以写入到ResponseWriter，但无法再修改header了； 123456789101112131415161718192021func writeExample(w http.ResponseWriter, r *http.Request) &#123; str := `&lt;html&gt;&lt;head&gt;&lt;title&gt;go cProgramming&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello go&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;`w.Write([]byte(str))&#125;func writeHeaderExample(w http.ResponseWriter, r *http.Request)&#123; w.WriteHeader(501) fmt.Fprintln(w, \"No such service, try next port\")&#125;func main() &#123; server := http.Server&#123; Addr: \":8000\", &#125; http.HandleFunc(\"/write\", writeExample) http.HandleFunc(\"/writeheader\", writeHeaderExample) server.ListenAndServe()&#125; 2.2.7.3 Header方法Header方法返回headers的map，可以进行修改 修改后的headers将会体现在返回给客户端的HTTP响应里； 1234func headerExample(w http.ResponseWriter, r *http.Request)&#123; w.Header().Set(\"Location\",\"https://reactnative.dev/\") w.WriteHeader(302)&#125; json 12345678910func jsonExample(w http.ResponseWriter, r *http.Request)&#123; w.Header().Set(\"Content-Type\",\"application/json\") post:= &amp;Post&#123; User: \"alex\", Threads: []string&#123;\"first\",\"second\",\"third\"&#125;, &#125; json,_ := json2.Marshal(post) w.Write(json)&#125;// &#123;\"User\":\"alex\",\"Threads\":[\"first\",\"second\",\"third\"]&#125; 2.2.7.4 内置的ResponseNotFound函数，包装一个404状态吗和一个额外的信息 ServeFile函数，从文件系统提供文件，返回请求者 ServerContent函数，它可以把实现了io.ReadSeeker接口的任何东西里面的内容返回给请求者 还可以处理Range请求（范围请求），如果只请求了资源的一部分内容，那么ServeContent就可以如此响应，而ServeFile或io.Copy则不行 Redirect函数，告诉客户端重定向到另一个URL 3.connect sql3.1 Opensql.Open() 参数1 数据库驱动名称 参数2 数据源名称 返回值 得到一个指向sql.DB这个struct的指针 sql.DB是用来操作数据库的，它代表了0个或者多个底层连接的池，这些连接由sql包来维护，sql包会自动的创建和释放这些连接； 它对于多个goroutine并发的使用是安全的； Open()函数并不会连接数据库，甚至不回验证其参数，它只是把后续连接到数据库所必需的structs给设置好了； 而真正的连接是在被需要的时候才进行懒设置的； sql.DB不需要进行关闭（当然你想关闭也是可以的） 它就是用来处理数据库的，而不是实际的连接 这个抽象包含了数据库连接的池，而且会对此进行维护 在使用sql.DB的时候，可以定义它的全局变量进行使用，也可以将它传递函数/方法里； 3.2 如何获得驱动正常的做法是使用sql.Register()函数、数据库驱动的名称和一个实现了driver.Driver接口的struct，来注册数据库的驱动。 1sql.Register(\"sqlserver\", &amp;drv&#123;&#125;) 但是之前的例子却没有写这句话，为什么？ 因为Sql Server的驱动，是在这个包被引入的时候进行了自我注册 1234import ( _ \"github.com/go-sql-driver/mysql\") 当go-sql-driver包被引入的时候，它的init函数将会运行并进行自我注册（在Go语言里，每个包的init函数都会在自动的调用） 在引入go-sql-driver 包的时候，把该包的名称设置为下划线_，这是因为我们不直接使用数据库驱动（只需要它起的“副作用”），我们只使用database/sql 这样，如果未来升级驱动，也无需改变代码 Go语言没有提供官方的数据库驱动，所有的数据库驱动都是第三方驱动，但是它们都遵循sql.driver包里面定义的接口 3.3 下载驱动go get github.com/go-sql-driver/mysql 3.4 PingContext1func (*DB) PingContext db.PingContext 函数是用来验证与数据库的连接是否仍然有效，如有必要则建立一个连接 这个函数需要一个Context（上下文）类型的参数，这种类型可以携带截止时间，取消信息和其它请求范围的值，并且可以横跨API边界和进程。 上例中，创建context使用的是context.Background()函数，该函数返回一个非nil的空Context，它不会被取消，它没有值，没有截止时间； 它通常在main函数，初始化或测试中，作为传入请求的顶级Context 123456ctx := context.Background()err = db.PingContext(ctx)if err != nil &#123; log.Fatalln(err.Error())&#125;fmt.Println(\"Connected\") 3.5 查询sql.DB类型上用于查询的方法有： Query QueryRow （返回一行） QueryContext QueryRowContext 3.5.1 Query返回的类型是 type Rows struct{} Rows的方法： 12345678910111213func (rs *Rows) Close() error// 返回结果的列的信息func (rs *Rows) ColumnTypes()([]*ColumnType, error)// 返回所有列名func (rs *Rows) Columns()([]string, error)// 查询遍历中的错误func (rs *Rows) Err() error// 遍历结果集，每次读取一行，返回true说明还有数据 false表示读到最后一行了func (rs *Rows) Next() bool// 如果查询包含多个结果集，使用NextResultSet。它会准备好下一个结果集用来读取。func (rs *Rows) NextResultSet() bool// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；func (rs *Rows) Scan(dest...interface&#123;&#125;) bool 3.5.2 QueryRow返回类型是 type Row struct{} 1234// 查询遍历中的错误func (rs *Rows) Err() error// 把当前行的数据拷贝出来，然后放置到 参数中的变量里面；func (rs *Row) Scan(dest...interface&#123;&#125;) bool 3.6 更新sql.DB类型上用于更新（执行命令）的方法有： Exec ExecContext 123func (a * app)Update()(err error) &#123; _,err := db.Exc(\"sql 语句\")&#125; 3.7 其它Ping PingContext Prepare PrepareContext Transactions Begin BeginTx 4. 路由需要给架构增加Controller层 Controller的角色 main(): 设置类工作，比如设置http server Controller: 静态资源 （比如css，js文件） 把不同的请求送到不同的controller进行处理 go语言提供一个前置的ctrl，所有进来的请求都会经过ctrl，然后由ctrl分发 5. json12345type Post struct &#123; ID int `json:\"id\"` User string `json:\"user\"` Threads []string `json:\"thread\"`&#125; 5.1 类型映射1234Go bool: JSON booleanGo float64: JSON 数值Go string; JSON stringsGo nil: JSON null 5.2 未知结构的JSON如何映射Map[string]interface{} 可以存储任意json对象 []interface{} 可以存储任意的JSON数组 5.3 读取JSON需要一个解码器： 1dec := json.NewDecoder(r.Body) 参数需要实现Reader接口 在解码器上进行编码： dec.Decode(&amp;query) 5.4 写入JSON需要一个编码器 1enc := json.NewEncoder(w) 参数需要实现Writer接口 编码 ： enc.Encode(results) 1234567891011121314151617181920212223func json(w http.ResponseWriter, r *http.Request)&#123; switch r.Method &#123; case http.MethodPost: dec := json2.NewDecoder(r.Body) company := Company&#123;&#125; err:= dec.Decode(&amp;company) if err != nil &#123; log.Println(err.Error()) w.WriteHeader(http.StatusInternalServerError) return &#125; enc := json2.NewEncoder(w) err = enc.Encode(company) if err != nil &#123; log.Println(err.Error()) w.WriteHeader(http.StatusInternalServerError) return &#125; default: w.WriteHeader(http.StatusMethodNotAllowed) &#125;&#125; Marshal 和 Unmarshal Marshal （编码）： 把go struct转化为json格式 Marshalindent, 带缩进 Unmarshal（解码）： 把json转化为go struct 1234567891011121314151617181920212223242526272829303132type Company struct &#123; ID int `json:\"id\"` User string `json:\"user\"` Threads []string `json:\"thread\"`&#125;func main()&#123; jsonStr := `&#123; \"id\": 123, \"name\": \"alex\", \"thread\": \"asia\" &#125;` c:= Company&#123;&#125; _ = json2.Unmarshal([]byte(jsonStr), &amp;c) fmt.Println(c) bytes,_ := json2.Marshal(c) fmt.Println(string(bytes)) bytes1, _ := json2.MarshalIndent(c,\"\",\" \") fmt.Println(string(bytes1))&#125;//&#123;123 alex [asia]&#125;//&#123;\"id\":123,\"user\":\"alex\",\"thread\":[\"asia\"]&#125;&#123; \"id\": 123, \"user\": \"alex\", \"thread\": [ \"asia\" ]&#125; 两种方式的区别 针对string或bytes： Marshal =&gt; string Unmarshal &lt;= string 针对stream： Encode =&gt; Stream, 把数据写入到 io.Writer Decode &lt;= Stream, 从io.Reader 读取数据 6. 中间件 12http.ListenAndServe(addr string, handler Handler)error// handler 如果是nil： DefaultServeMux 1234// 想创建handler，必须实现handler接口，需要实现ServeHTTP这个方法type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; 6.1 创建中间件12345678type MyMiddleware struct &#123; Next http.Handler&#125;func (m MyMiddleware) ServeHTTP (w http.ResponseWriter, r *http.Request) &#123; // 在next handler之前做一些事情 m.Next.ServeHTTP(w, r) // 将该请求转发到下一个handler中 // 在 next handler之后做一些其它事情（对响应进行处理，中间件中创建的资源进行处理，此时响应仍然是没有返回至客户端的）&#125; m.Next.ServeHTTP(w, r) 将该请求转发到下一个handler中。至于下一个handler是什么，这个Next设置成什么，下一个handler就是什么，有可能是nil。在web应用中，如果只有一个中间件的话。那么next就是DefaultServeMux。它就会将这个请求 进行路由。然后进程的处理。 中间件的用途 Logging 安全（请求超时，用户身份认证） 响应压缩 6.2 使用请求上下文 比如中间件设置了请求超时，而这个请求到数据库的时候，这个数据库将会花费很长时间。这个时候就需要让访问数据库的代码知道设置了查询超时时间。这就需要使用到上下文来解决； 1234func (*Request) Context() context.Context// 返回当前请求的上下文func (*Request) WithContext(ctx context.Context)context.Context// 基于Context 进行 修改，（实际上）创建一个新的Context 123456789type Context interface &#123; Deadline() (deadline time.Time, ok bool) // 返回一个channel，用来做取消操作的。一旦context取消了。它就会接收到一个信号。这个channel也就关闭了；。比如在操作截止时间就会接到这个信号 Done() &lt;-chan struct&#123;&#125; // 取消操作 // 如果 Done 这个channel没有关闭的话，error就是nil，如果它关闭了，也就是context被取消了。那么error就存放被取消的原因；以后每次调用error都会显示同一个错误； Err()error // 使用参数key从context获取一些信息，得到的这些信息可以从架构中的一个层传给另一个层； Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 这些方法都是用于读取，不能进行设置； Context API - 可以返回新Context WithCancal() ,它有一个CancelFunc WithDeadline(), 带有一个时间戳 （time.Time） WithTimeout(), 带有一个具体的时间段（time.Duration） WithValue(), 在里面可以添加一些值； 7. HTTPSHTTP请求的过程 在http里面，参数都是以明文进行传输的。在客户端和服务端之间其它的东西，比如某个中间人/中间服务器也能懂得传输的信息。所以说，这种传输是非常不安全的 ； HTTPS https会稍微给传输层做一点改变，它不是直接在TCP上面传输数据的。会添加一个TLS层，在传输数据的时候，数据首先会被加密。加密之后只有客户端和服务器能够懂得这个加密数据里面真实的内容。中间人/中间服务器即使能获得数据，但是依然无法解析出来内容；也就无法懂得它真正代表的意思了； 7.1 HTTP.ListenAndServeTLS123456// ListenAndServeTLS 四个参数addrcertFilekeyFilehandlerhttp.ListenAndServeTLS() go 提供了生成证书的方法 12345678go run /usr/local/go/src/crypto/tls/generate_cert.go -hgo run /usr/local/go/src/crypto/tls/generate_cert.go -host localhost# time wrote cert.pem# time wrote key.pemhttp.ListenAndServeTLS(\":8080\", \"cert.pem\", \"key.pem\", nil) 12345678910111213141516171819Request Headers :authority: localhost:8080 :method: GET :path: /json :scheme: https accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache cookie: pragma: no-cache sec-ch-ua: \"Google Chrome\";v=\"89\", \"Chromium\";v=\"89\", \";Not A Brand\";v=\"99\" sec-ch-ua-mobile: ?0 sec-fetch-dest: document sec-fetch-mode: navigate sec-fetch-site: none sec-fetch-user: ?1 upgrade-insecure-requests: 1 user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36 Headers 以：开头，在go web应用里面，如果从http转到https，那么此应用会自动从http1.1 升级到http2协议。 8. HTTP/2http2带来效率提升的原因 Http1.1发送请求 首先建立tcp连接 发送请求时，通常header 和 body捆绑在一起发送的。尽管有时候body比较大，会被分到不同的包中发送。 响应返回的时候，基本和请求类似，也是header和body捆绑发送； 这就导致header无法被压缩，header描述了请求或者响应里面的内容比如content-type，length等等，有些时候header比较大。 HTTP2 依旧建立TCP服务 在TCP里建立stream，stream是在TCP里面独立通信的管道。各个stream不会相互影响。但是允许在同一个链接里面让多个信息来回发送但不相互干扰。在stream里面是通过Frame来发送消息的；所以它在发送请求的时候，不是将header和body绑在一起发送；而是将消息拆成多个Frame进行发送的；而每个Frame又可以单独的进行优化； 有哪些Frame 客户端往服务端发送header的时候，服务器知道它将接收到header。这个过程就能使用到一些压缩算法。 8.1 http2的特点 请求多路复用，可以在同一个TCP连接使用stream发送多个请求； Header压缩 默认安全 HTTP， 但很多决定不支持HTTP HTTPS Server Push 没有Server push 没有Server push的时候，请求是一来一回的。 server push 节省了一个步骤，从客户端往服务端请求app.css的部分； 9. 部署Nohup 1nohup ./it &amp; 守护进程 1$&gt; vim /etc/systemd/system/go-web.service 12345678910111213[Unit]Description=Go web App running on xxx[Service]ExecStart=/home/solenovex/it/itRestart=alwaysRestartSec=10KillSignal=SINGINTSyslogIdentifier=go-web-exampleUser=solenovex[Install]WantedBy=multi-user.target 123sudo systemctl start go-web.service# 查看状态sudo systemctl status go-web.service 10 IM项目10.1 构建基础server1234# 构建go build -o server main.go server.go./server$&gt; connect success 12# 客户端nc 127.0.0.1 8888 10.2 用户上线功能12345// 需要给server补充两个属性, OnlineMap 和 channeltype Server struct &#123; Ip string Port int&#125; OnlineMap key： 当前用户名 user.Name User Name1 User1 Name2 User2 Name3 user3 记录当前有哪些用户在线，一个客户端就是一个用户； 用一个User类来表示客户端 12345type User &#123; username conn // 可以跟客户端进行通信 channel // 每个用户都绑定一个channel，专门用来向user实例对应的客户端来发消息的；&#125; channel 每个用户都绑定一个channel，专门用来向user实例对应的客户端来发送消息。比如服务器往客户端1发送消息时，服务器就应该将消息发给User1.channel。channel又该如何将消息发送给客户端呢？ 每个User实例中都会有一个goroutine，此goroutine应该阻塞监听channel，查看它当中是否有数据存在。一旦监听到数据，立即将数据通过conn写到对应的客户端中； Message message本质上是个channel，它属于server的channel。Message是用来将消息进行广播的。（如果当前有一条消息需要让所有客户端都收听到的话） 如何广播？ 将消息发送到Message的管道中，Message中除了有管道，还需要有一个goroutine。不断在监听当前管道。一旦监听到有消息时，遍历OnlineMap依次将消息发送给每个的user的channel中； 1234567891011121314# server$&gt; ./server# client1$&gt; nc 127.0.0.1 8888$&gt;[127.0.0.1:51375]127.0.0.1:51375:online #1$&gt;[127.0.0.1:51753]127.0.0.1:51753:online #2$&gt;[127.0.0.1:51979]127.0.0.1:51979:online #3# client2$&gt; nc 127.0.0.1 8888$&gt;[127.0.0.1:51753]127.0.0.1:51753:online #2$&gt;[127.0.0.1:51979]127.0.0.1:51979:online #3# client3$&gt; nc 127.0.0.1 8888$&gt; [127.0.0.1:51979]127.0.0.1:51979:online #3 10.3 用户消息广播机制12345678910111213#im1# server$&gt; ./server# client1$&gt; nc 127.0.0.1 8888$&gt; [127.0.0.1:55858]127.0.0.1:55858:online$&gt; [127.0.0.1:55894]127.0.0.1:55894:online$&gt; [127.0.0.1:55894]127.0.0.1:55894:hello# client2$&gt; nc 127.0.0.1 8888$&gt; [127.0.0.1:55894]127.0.0.1:55894:online$&gt; hello$&gt; [127.0.0.1:55894]127.0.0.1:55894:hello 10.4 用户业务层封装10.5 在线用户查询10.6 修改用户名定义一种消息格式 rename|newUsername 10.7 超时强T用户的任意消息表示用户为活跃，长时间不发消息则视为超时，可强制下线。 那如何判断当前用户是否活跃； 12# 实现原理当服务端能从客户端 Read到一条信息的，开启定时器；等定时器达到一定阈值的时候，则判定客户端失联 10.8 私聊同修改用户名一样，也是定义一种消息格式 to|username|send message 10.9 客户端123# build$&gt; go build -o server main.go server.go user.go$&gt; go build -o client client.go 11. gin11.1 创建项目12345#createEnvironment: https://goproxy.cn,direct# import \"github.com/gin-gonic/gin\"go mod tidy # 查漏补缺,类似 npm install 11.2 CLD分层 协议处理层： 支持各种协议 Controller： 服务的入口，负责处理路由、参数校验、请求转发 Logic/Service： 逻辑（服务）层，负责处理业务员逻辑 DAO/Repository：负责数据与存储相关功能 11.3 通用脚手架12345678910111213141516171819go_boilerplate├── config.yaml # 全局配置器├── dao # dao层│ ├── mysql│ │ └── mysql.go│ └── redis│ └── redis.go├── go.mod├── go.sum├── logger # 日志│ └── logger.go├── main.go├── modules # modules 备用├── pkg # pkg备用├── routes │ └── routes.go├── settings │ └── settings.go # viper 配置信息└── web_app.log 一个新的项目，从程序入口main.go 开始读取； 11.3.1 现有settings设计的问题到项目后期，新接手的同事比较难一下知道项目中用到的配置信息； 一个优化点： 现在不是把配置文件读取出，之后直接保存到viper变量里面去。而是把它存储到内部定义的结构体中去。 什么意思呢？ 就好比，刚开始项目是一个人开发的，他自然知道存在哪些配置。比如viper.GetString(&quot;mysql.user&quot;)等等；所以这里其实需要有一个类似interface的东西去提示给新开发者较好；这里选用结构体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package settingsimport ( \"fmt\" \"github.com/fsnotify/fsnotify\" \"github.com/spf13/viper\")// Conf 全局变量，用来保存程序的所有配置信息var Conf = new(AppConfig)type AppConfig struct &#123; Name string `mapstructure:\"name\"` Mode string `mapstructure:\"mode\"` Version string `mapstructure:\"version\"` Port int `mapstructure:\"port\"` *LogConfig `mapstructure:\"log\"` *MySQLConfig `mapstructure:\"mysql\"` *RedisConfig `mapstructure:\"redis\"`&#125;type LogConfig struct &#123; Level string `mapstructure:\"level\"` Filename string `mapstructure:\"filename\"` MaxSize int `mapstructure:\"max_size\"` MaxAge int `mapstructure:\"max_age\"` MaxBackups int `mapstructure:\"max_backups\"`&#125;type MySQLConfig struct &#123; Host string `mapstructure:\"host\"` User string `mapstructure:\"user\"` Password string `mapstructure:\"password\"` DbName string `mapstructure:\"db_name\"` Port int `mapstructure:\"port\"` MaxOpenConns int `mapstructure:\"max_open_conns\"` MaxIdleConns int `mapstructure:\"max_idle_conns\"`&#125;type RedisConfig struct &#123; Host string `mapstructure:\"host\"` Password string `mapstructure:\"password\"` Port int `mapstructure:\"port\"` DB int `mapstructure:\"db\"` PoolSize int `mapstructure:\"pool_size\"`&#125;func Init() (err error) &#123; viper.SetConfigFile(\"config.yaml\") //viper.SetConfigName(\"config\") // 指定配置文件名称（不需要带后缀） //viper.SetConfigType(\"yaml\") // 指定配置文件类型(专用于从远程获取配置信息时指定配置文件类型的) viper.AddConfigPath(\".\") // 指定查找配置文件的路径（这里使用相对路径） err = viper.ReadInConfig() // 读取配置信息 if err != nil &#123; // 读取配置信息失败 fmt.Printf(\"viper.ReadInConfig() failed, err:%v\\n\", err) return &#125; // 把读取到的配置信息反序列化到 Conf 变量中 if err := viper.Unmarshal(Conf); err != nil &#123; fmt.Printf(\"viper.Unmarshal failed, err:%v\\n\", err) &#125; viper.WatchConfig() viper.OnConfigChange(func(in fsnotify.Event) &#123; fmt.Println(\"配置文件修改了...\") if err := viper.Unmarshal(Conf); err != nil &#123; fmt.Printf(\"viper.Unmarshal failed, err:%v\\n\", err) &#125; &#125;) return&#125; 增加结构体之后的流程 程序启动时，还是使用viper从配置文件里面去加载信息。 加载完信息之后，反序列化结构体变量，放到结构体中去，比如AppConfig。然后在程序中使用的是这个结构体而不是配置文件； 12. Gin_pro12.1 create sql12345678910111213CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) NOT NULL, `username` varchar(64) COLLATE utf8mb4_general_ci NOT NULL, `password` varchar(64) COLLATE utf8mb4_general_ci NOT NULL, `email` varchar(64) COLLATE utf8mb4_general_ci, `gender` tinyint(4) NOT NULL DEFAULT '0', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `idx_username` (`username`) USING BTREE, UNIQUE KEY `idx_user_id` (`user_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci; 12.1.1 primary key与唯一索引1234PRIMARY KEY (`id`), \"设置primary key\"UNIQUE KEY `idx_username` (`username`) USING BTREE,UNIQUE KEY `idx_user_id` (`user_id`) USING BTREE\"分别给 username 和 user_id 添加唯一索引\" 12.1.2 user_id123`id` bigint(20) NOT NULL AUTO_INCREMENT,`user_id` bigint(20) NOT NULL, \"bigint(20) 占8个字节，对应go语言的int64\"`username` varchar(64) COLLATE utf8mb4_general_ci NOT NULL, 为何不使用 自增的 id做 user_id，反而另外设一个字段呢 原因一：那别人在你数据库里面注册一个用户，就能知道你的用户量了； 原因二： 当使用分库分表的时候，分成不同的库，那id可能有重复的。（因为每个表的id都自增） 为何不使用uuid uuid生成出来的id 就失去了使用数字来做 用户ID的特点，int可以按照时间来排序，随着时间递增。而uuid是无规律的；检索起来也不是特别的方便。 目前主流的方案 大型项目一般使用分布式的ID生成器， 分布式ID的特点 全局唯一性： 不能出现有重复的ID标识，这是基本要求 递增性： 确保生成ID对于用户或业务是递增的； 高可用性： 确保任何时候都能生成正确的ID 高性能性： 在高并发的环境下依然表现良好 不仅是用于用户ID，实际互联网中有很多场景需要能够生成类似MYSQL自增ID这样不断增大，同时又不会重复的id，以支持业务中的高并发场景。 比较典型的场景有： 电商促销时短时间内会有大量的订单涌入到系统，比如每秒10w+； 在这些业务场景下将数据插入数据库之前，我们需要给这些订单和消息先分配一个唯一ID，然后再保存到数据库中； 对这个id的要求是希望其中能带有一些时间消息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进行排序； snowflake算法 雪花算法，它是Twitter开源的由64位整数组成分布式ID，性能较高，并且在单机上递增 snowflake-64bit 第一位 占用1bit，其值始终是0，没有实际作用 时间戳 占用41bit，单位为毫秒，总共可以容纳约69年的时间，当然，我们的时间毫秒计数不会真的从1970年开始，那样我们系统跑到 2039/9/7 23:47:35 就不能用了，所以这里的时间戳只是相对于某个时间的增量，比如我们的系统上线是2020-07-01，那么我们完全可以把这个timestamp当作是从2020-07-01 00:00:00.000的偏移量 工作机器id 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，最多可以容纳1024个节点 序列号 占用12bit，用来记录同豪秒内产生的不同id，每个节点每豪秒0开始不断累加，最多可以累加到4095，同一豪秒一共可以产生4096个ID； snowFlake算法在同一毫秒内最多可以生成的ID数量为同一毫秒的ID数量=1024*4096 = 4194304 12.2 登陆注册流程中文注释的另外一个作用，提供编码思路（有的时候面对功能模块没思路的时候，通过写注释，分析要完成需求的实际步骤） 123// 1. 获取参数和参数校验// 2. 业务处理// 3. 返回响应 12.2.1 validater做参数校验","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"rust","slug":"rust","date":"2021-03-16T06:02:35.000Z","updated":"2021-03-16T06:12:42.988Z","comments":true,"path":"2021/03/16/rust/","link":"","permalink":"http://yoursite.com/2021/03/16/rust/","excerpt":"","text":"1. rust123rustc --versionrustup doc # 离线文档rustc main.rs # 编译main.rs c为compiler 2. cargo12cargo --versioncargo new hello_cargo # 创建一个 hello_cargo的项目 2.1 cargo.toml TOML (Tom’s Obvious Minimal Language) 格式，是Cargo是配置格式 123456789[package] # 区域标题，表示下方内容是用来配置包（package）的name = \"hello_cargo\" # 项目名version = \"0.1.0\"authors = [\"ruanhan1988 &lt;2856197796@qq.com&gt;\"]edition = \"2018\" # 使用的rust版本# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] # 区域标题， 另一个区域的开始，它会列出项目的依赖项 2.2 crate 在rust里面， 代码的包称为crate 2.3 非cargo创建的项目 非cargo创建的项目，转化为使用cargo 把源代码文件移动到src下 创建Cargo.html并填写相应的配置 2.4 Cargo 构建项目12cargo build # 构建# 会创建出来一个可执行文件: target/debug/hello_cargo 或 target\\debug\\hello_cargo.exe 2.4.1 cargo.lock 第一次运行 cargo build会在项目目录生成 cargo.lock文件 12345# This file is automatically @generated by Cargo.# It is not intended for manual editing.[[package]]name = \"hello_cargo\"version = \"0.1.0\" 该文件负责追踪项目以来的精确版本 不需要手动修改该文件 2.5 构建和运行cargo项目1cargo run 如果源代码没有更改，直接运行上次生成的二进制文件； 2.6 cargo check1cargo check # 检查代码，确保能通过编译，但是不产生任何可执行文件； cargo check效率较build命令高很多，编写代码时，可反复使用cargo check检查代码，提高效率； 2.7 发布123cargo build --release# 编译时会进行优化, 代码会运行更快，但是编译时间更长# 会在 target/release 而不是 target/debug 生成可执行文件 2.8 添加依赖包1234567891011# Cargo.html[package]name = \"guessing_number\"version = \"0.1.0\"authors = [\"ruanhan1988 &lt;2856197796@qq.com&gt;\"]edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]rand = \"0.3.14\" # 添加依赖包 在dependencies区域下，直接填写 rand = “0.3.14”即可； 3. guess number-pro12345678910111213fn main()&#123; println!(\"guess number\"); println!(\"guess a number\"); let mut guess = String::new(); // 创建一个可变的变量，rust中变量默认是 immutable的 // String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码 // 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数 // 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法 io::stdin().read_line(&amp;mut guess).expect(\"can not read_line\"); // rust中，引用默认也是不可变的，添加mut关键字，使其变为可变 // &amp;mut guess 即指guess的引用 .expect 如果读取发生错误，程序崩溃退出； print!(\"you guess the number is: &#123;&#125;\", guess);&#125; 3.1 read_line123pub fn read_line(&amp;self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt;// read_line 有一个叫 io::Result 类型的返回值，在rust标准库中，有很多类型都叫做Result。既有通用的result（范型的result），也有特定版本，子模块的Result，比如io::Result, Result类型实际上枚举类型，一个枚举类型有几个固定的值，这些值称做是这些枚举类型的变体。而io::Result枚举类型一共两个变体，Ok和Errio::stdin().read_line(&amp;mut guess).expect(\"can not read_line\"); 3.2 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950use std::io;use std::cmp::Ordering; // Ording 枚举类型use rand::Rng;// 默认情况下，rust会将 一个叫 prelude的模块 导入到每个程序的作用域中，// 如果需要使用的类型不在 prelude里面，就需要显式的导入 比如 use std::iofn main()&#123; println!(\"guess number\"); let secret_number = rand::thread_rng().gen_range(1, 101); // loop 添加一个无限循环 loop &#123; println!(\"guess a number\"); let mut guess = String::new(); // 创建一个可变的变量，rust中变量默认是 immutable的 // String::new() 会返回一个新的字符串实例；String由标准库所提供。内部使用utf8格式的编码 // 并且可以根据需求扩展大小，String::new(), ::表示new函数是String的关联函数 ，关联函数 // 是针对类型本身来实现的。而不是针对字符串某个特定实例来实现的。关联函数类似java中的静态方法 io::stdin().read_line(&amp;mut guess).expect(\"can not read_line\"); // rust中，引用默认也是不可变的，添加mut关键字，使其变为可变 // &amp;mut guess 即指guess的引用 .expect 如果读取发生错误，程序崩溃退出； println!(\"you guess the number is: &#123;&#125;\", guess); // 在rust中允许使用同名的新变量来 shadow原来同名的旧变量，也就是说从声明新guess之后， // 代码中出现的guess变量都将是这个 u32类型的变量；这种用法通常使用在需要有类型转换的场景 // 中，我们复用guess这个名而无需创建新的变量名； // let guess:u32 = guess.trim().parse().expect(\"plase type a number\"); // parse返回值是Result，所以可以使用expect处理未来可能存在的异常 let guess:u32 = match guess.trim().parse()&#123;// 使用match 提高程序健壮性 Ok(num) =&gt; num, Err(_) =&gt; &#123; println!(\"valid number\"); continue &#125; // 非合法数字，直接continue &#125;; // match关键字， 根据cmp返回的Ordering 这个枚举类型的值来决定下一步来做什么。 // 而match表达式 是有多个 arm /分支 组成的； match guess.cmp(&amp;secret_number) &#123; // cmp compare 返回值 Ordering Ordering::Less =&gt; println!(\"Too small!\"), // arm Ordering::Greater =&gt; println!(\"To big!\"), // arm Ordering::Equal =&gt; &#123; println!(\"you win\"); break; // 跳出 match &#125;, // arm &#125; &#125; &#125; 4. 通用编程概念4.1 变量与可变性声明变量用let 默认情况，变量是immutable 声明变量，在变量前面加上mut，就可以使变量可变； 4.1.1 变量与常量 常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别： 不可以使用mut，常量永远都是不可变的； 声明变量使用const关键字，它的类型必须被标注； 常量可以在任何作用域内进行声明，包括全局作用域 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值； 在程序运行期间，常量在其声明的作用域内一直有效 命名规范： Rust里常量使用全大写字母，每个单词之间用下划线分开； 1MAX_POINTS:u32 = 100_00; 4.1.2 Shadowing(隐藏) 可以使用相同的名字声明新的变量，新的变量就会shadow（隐藏）之前声明的同名变量 1234567fn main()&#123; let x = 5; let x = x+1; let x = x*2; // 在后续的代码中这个变量名代表的就是新的变量； println!(\"value is &#123;&#125;\", x); // 12 &#125; 4.1.3 shadow与mut Shadow和把变量标记为mut是不一样的， 如果不使用let关键字，那么重新给非mut的变量赋值会导致编译时错误 而使用let声明的同名新变量，也是不可变的； 使用let声明的同名新变量，它的类型可以与之前不同； 4.2 数据类型Rust是静态编译语言，在编译时必须知道所有变量的类型； 基于使用的值，编译器通常能够推断出它的具体类型； 但如果可能的类型比较多（例如把String转为整数的parse方法），就必须添加类型的 标注，否则编译会报错 12let num = '42'.parse(); // errorlet num:u32 = '42'.parse // ok 4.2.1 标量类型 一个标量类型代表一个单个的值； Rust有四个主要的标量类型： 4.2.1.1 整数类型整数类型没有小数部分 例如u32就是一个无符号的整数类型，占据32位的空间 无符号 以u开头 有符号 以i开头 Rust的整数类型列表如图 Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize isize 和 usize类型 isize 和 usize类型的位数由程序运行的计算机的架构所决定 如果是64位计算机，那就是64位，如果32位计算机，就是32位； 使用isize和usize 的主要场景是针对某中集合进行索引操作； 4.2.1.2 浮点类型f32 f64 4.2.1.3 布尔类型true false 4.2.1.4 字符类型char 4个字节 4.2.2 复合类型 复合类型可以将多个值放在一个类型里 Rust提供了两种基础的复合类型： 元祖（Tuple）、数组 4.2.2.1 TupleTuple可以将多个类型的多个值放在一个类型里 Tuple的长度是固定的：一旦声明就无法改变 12let tup: (i32, f64, u8) = (500, 6.4, 1);println!(\"&#123;&#125;, &#123;&#125;, &#123;&#125;\", tup.0, tup.1, tup.2); 4.2.2.2 数组数组中每个元素的类型必须相同 数组的长度也是固定的 数组的用处 如果想让你的数据存放在stack上而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处； 数组的类型 [类型; 长度] 1let a: [i32; 5] = [1,2,3,4,5]; 另一种声明数组的方法 如果数组的每个元素都相同，那么可以在： 在中括号里制定初始值； 123let a = [3;5]; // 相当于let a = [3,3,3,3,3] 访问数组的元素 数组是stack上分配的单个块的内存 可以使用索引来访问数组的元素（例子） 如果访问的索引超出了数组的范围，那么； 编译会通过 运行会报错（runtime时会panic） 123456fn main()&#123; let mouths = [1,2,3,4,5,6,7,8,9,10,11,12]; let index = [12,13,14,15]; let month = months[index[1]]; // 编译时不会报错，只有运行时才会检测 println!(\"&#123;&#125;\", month); &#125; Rust不会允许其继续访问相应的地址的内存； 4.3 函数函数名 多个单词用下划线连接； parameter 行参 arguments 实参 4.3.1 函数的返回值在-&gt; 符号后边声明函数返回值的类型，但是不可以为返回值命名； 在rust里面，返回值 4.4 注释4.5 控制流4.5.1 if elsematch 重构多重if else语句 4.5.2 循环Rust 提供了三种循环： loop， while 和 for 1234567891011fn main()&#123; loop&#123; // 无限循环； // &#125;&#125;fn main()&#123; while number !== 0 &#123; /// &#125;&#125; 4.5.2.1 使用for循环遍历集合由于for循环的安全，简洁性，所以它在Rust里用的最多； 1234567fn main() &#123; let a = [10, 20, 30, 40, 50]; for element in a.iter() &#123; println!(\"the value is: &#123;&#125;\", element); &#125;&#125; 例子： 用for循环显示倒计时的例子 载入标准库 Range 指定一个开始数字和一个结束数字，Range可以生成它们之间的数字（不含结束） rev方法可以反转Range 123456fn main() &#123; for number in (1..4).rev() &#123; println!(\"&#123;&#125;!\", number); &#125; println!(\"LIFTOFF!!!\");&#125; 5. 所有权所有权是Rust最独特的特性，它让Rust无需GC就可以保证内存安全； 所有程序在运行时都必须管理它们使用计算机内存的方式 有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存 在其他语言中，程序员必须显式地分配和释放内存； Rust采用了第三种方式 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则； 当程序运行时，所有权特性不会减慢程序的运行速度； 5.1 stack vs heap在像Rust这样的系统级编程语言里，一个值是在stack上还是在heap上对语言的行为和你为什么要做某些决定是有更大的影响的； 在你的代码运行的时候，stack 和 heap都是你可用的内存，但他们的结构很不相同； 存储数据 stack按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO） 添加数据叫做压入栈 移除数据叫做弹出栈 所有存储在Stack上的数据必须拥有已知的固定的大小； 编译时大小未知的数据或运行时大小可能发生变化的数据必须存在heap上 heap内存组织性差一点； 当你把数据放入heap时，你会请求一定数量的空间 操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址 这个过程叫做heap上进行分配，有时仅仅称为“分配” 把值压到stack上不叫分配 因为指针是已知固定大小的，可以把指针存放在stack上。 但如果想要实际数据，你必须使用指针来定位； 把数据压到stack上要比在heap上分配快得多： 因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在stack的顶端 在heap上分配空间需要做更多的工作： 操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配； 访问数据 访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据； 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack上） 如果数据之间的距离比较远，那么处理速度就会慢一些（heap上） 在heap上分配大量的空间也是需要时间的； 函数调用 调用函数时，值被传入到函数（也包括指向heap的指针），函数本地的变量被压到stack上，当函数结束后，这些值会从stack上弹出； 5.2 所有权存在的原因5.2.1 所有权解决的问题跟踪代码的哪些部分正在使用heap的哪些数据； 最小化heap上的重复数据量 情理heap上未使用的数据以避免空间不足 一旦懂得所有权，那么就不需要经常去想stack或heap了； 但是知道管理heap数据是所有权存在的原因，这有助于理解它为什么会这样工作； 5.3 所有权规则每个值都有一个变量，这个变量是该值的所有者； 每个值同时只能有一个所有者； 当所有者超出作用域（scope）时，该值将被删除； 5.3.1 变量作用域scope就是程序中一个项目的有效范围 12345fn main()&#123; // s不可用 let s = \"hello\"; // s 可用 // 可以对s进行相关操作&#125; // s作用域到此结束， s不再可用； 5.3.2 String类型Rust还有第二种字符串类型： String 在heap上分配，能够存储在编译时未知数量的文本； 5.3.2.1 创建String类型的值 可以使用from函数从字符串字面值创建出String类型 123let s = String::from(\"hello\")// :: 表示from是String类型下的函数// 这类字符串是可以被修改的； 12345fn main()&#123; let mut s = String::from(\"hi\"); s.push_str(\", world\"); println!(\"&#123;&#125;\", s); // hi, world&#125; 5.3.2.2 内存和分配为什么string类型的值可以修改，而字符串字面值不能修改 因为它们处理内存的方式不同； 字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里； 速度快、高效，是因为其不可变性； String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容： 操作系统必须在运行时来请求内存， 这步通过调用String::from来实现 当用完String之后，需要使用某种方式将内存返回给操作系统 这步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存 没有GC，就需要我们去识别内存何时不再使用，并调用代码将它返回； 如果忘了，那就浪费内存 如果提前做了，变量就会非法 如果做了两次，就是Bug，必须一次分配对应一次释放； Rust采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统； drop函数 当变量走出作用域的时候，会调用drop函数 5.4 变量和数据交互的方式5.4.1 移动（Move） 多个变量可以与同一个数据使用一种独特的方式来交互； 12345678fn main() &#123; let x = 5; let y = x; let s = String::from(\"hello\"); // borrow of moved value: `s` let s2 = s; println!(\"&#123;&#125;,&#123;&#125;\", x, y); // 5, 5 println!(\"&#123;&#125;\", s2); // hello&#125; 一个String由3部分组成： 一个指向存放字符串内容的内存的指针 ptr 一个长度 len 一个容量 capacity 上面这些东西放在stack上 存放字符串内容的部分在heap上 长度len，就是存放字符串内容所需的字节数； 12let s1 = String::from(\"hello\");let s2 = s1; 当把s1赋给s2，String的数据被复制了一份： 在stack上复制了一份指针、长度、容量 并没有复制指针所指向的heap上的数据 当变量离开作用域时，Rust会自动调用drop函数，并将变量使用的heap内存释放； 当s1、s2离开作用域时，它们都会尝试释放相同的内存 会引起二次释放（double free）的bug rust为了保证内存安全： Rust没有尝试复制被分配的内存 Rust让s1失效 当s1离开作用域的时候，rust不需要释放任何东西； 12345678fn main() &#123; let x = 5; let y = x; let s = String::from(\"hello\"); // borrow of moved value: `s` let s2 = s; println!(\"&#123;&#125;,&#123;&#125;\", x, y); // 5, 5 println!(\"&#123;&#125;\", s2); // hello&#125; 5.4.2 浅拷贝和深拷贝浅拷贝 深拷贝 你也许会将复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以我们用一个新的术语：移动（Move） 隐含的一个设计原则： Rust不会自动创建数据的深拷贝 就运行时性能而言，任何自动赋值的操作都是廉价的； 5.4.3 变量和数据交互的方式：克隆（Clone）如果真想对heap上面的String数据进行深度拷贝，而不仅仅是Stack上的数据，可以使用clone方法 123456fn main() &#123; let s &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; borrow of moved value: &#96;s&#96; let s2 &#x3D; s; let s3 &#x3D; s2.clone(); println!(&quot;&#123;&#125;, &#123;&#125;&quot;, s2, s3); &#x2F;&#x2F; hello hello&#125; Clone 相当于无论是Stack上还是heap上的数据，都统统复制一遍 5.4.4 复制12345fn main() &#123; let x = 5; let y = x; println!(\"&#123;&#125;,&#123;&#125;\", x, y); // 5, 5&#125; Clone 比较消耗资源；主要还是针对heap上的数据操作。 而针对Stack上的数据，只需要复制就好了； 5.4.4.1 Copy traitRust 提供了一个名为Copy的 trait，trait简单理解为接口 Copy trait，可以用于像整数这样完全存放在stack上面的类型； 如果一个类型实现了Copy这个trait，那么旧的变量在赋值后仍然可用； 如果一个类型或者该类型的一部分实现了Drop trait，那么Rust不允许让它再实现Copy trait了 5.4.4.2 一些拥有Copy trait的类型任何简单标量的组合类型都可以是Copy的 任何需要分配内存或某种资源的都不是Copy的 一些拥有Copy trait的类型 所有整数类型，例如 u32 bool char 所有浮点类型 例如f64 Tuple（元组），如果其所有的字段都是Copy的 (i32,i32)是 (I32, String) 不是 5.5 所有权与函数在语义上，将值传递给函数和把值赋给变量是类似的： 5.5.1 将值传递给函数将发生移动或复制123456789101112131415161718fn main() &#123; let s = String::from(\"alex\"); take_ownership(s); // 从这里之后，s的值被移动到函数里面； let x = 5; makes_copy(x); // x值是被拷贝到函数里面 println!(\"x: &#123;&#125;\", x); // x 被回收；&#125;fn take_ownership(str: String) &#123; println!(\"&#123;&#125;\", str);&#125; // rust会调用drop ，str占用的内存会被释放fn makes_copy(str: i32) &#123; println!(\"&#123;&#125;\", str);&#125; // 对于i32这种基础类型，不会有额外的事情发生 5.5.2 返回值与作用域函数在返回值的过程中同样也会发生所有权的转移 12345678910111213141516171819202122232425fn main() &#123; let s1 = gives_ownership(); // gives_ownership 将返回值 // 移给 s1 let s2 = String::from(\"hello\"); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃fn gives_ownership() -&gt; String &#123; // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(\"hello\"); // some_string 进入作用域. some_string // 返回 some_string 并移出给调用的函数&#125;// takes_and_gives_back 将传入字符串并返回该值fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数&#125; 一个变量的所有权总是遵循同样的模式： 把一个值赋给其它变量时就会发生移动 当一个包含heap数据的变量离开作用域时，它的值就会被drop函数清理，除非数据的所有权移动到另一个变量上了； 5.6 引用如果让函数使用某个值，但不获得其所有权？ 12345678910fn main() &#123; let s1 = String::from(\"alex\"); let (s2, len) = calculate_length(s1); println!(\"The length of '&#123;&#125;' is &#123;&#125;\", s2, len);&#125;fn calculate_length(str: String) -&gt; (String, usize) &#123;// usize 跟架构有关的无符号整数类型 let length = str.len(); (str, length)&#125; Rust有一个特性叫做 引用（Reference) 5.6.1 引用1234567891011fn main()&#123; let s1 = String::from('hi'); let len = calcuate_length(&amp;s1); //&amp;s1并不拥有s1，所有不会转移s1的所有权，而是将s1的引用传给了 函数， 当作用域结束之后，s1并不会被清理掉 println!(\"&#123;&#125;,&#123;&#125;\", s1, len);&#125;fn calcuate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; // 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉，// 所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权// 这种将引用作为函数参数的行为，我们就将其称为借用； 如上图，s就是s1的引用， s实际上是一个指针，它指向s1。 s1也是一个指针，它指向存在heap上的真实的内容； calcuate_length 参数的类型是 &amp; String而不是String， &amp;符号就表示引用：允许你引用某些值而不取得其所有权 5.6.2 借用123fn calcuate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; // 函数走到这里，s出了作用域，由于s并不具备指向字符串的所有权。所以它指向的那个值并不会被清理掉， 所以当一个函数使用引用作为它的参数而不是一个真实的值的时候，我们就不必为了归还所有权，而把这个值返回回去；因为也不曾获得这个参数的所有权 这种将引用作为函数参数的行为，我们就将其称为借用； 是否可以修改借用的东西？ 不行 和变量一样，引用默认也是不可变的 只要设置mut，就可以修改借用的东西 1234567fn main() &#123; let mut s = String::from(\"hello\"); // 设置为可变的 change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(\", world\");&#125; 5.6.3 可变引用可变引用有一个重要的限制： 在特定作用域内，对某一块数据，只能有一个可变的引用； 这样做的好处是可在编译时防止数据竞争； 数据竞争是如何发生的 两个或多个指针同时访问同一个数据 至少有一个指针用于写入数据 没有使用任何机制来同步对数据的访问 可以通过创建新的作用域，来允许非同时的创建多个可变引用（例子） 1234567fn main()&#123; let mut s = String::from('alex'); &#123; let s1 = &amp;mut s; &#125; let s2 = &amp;mut s;&#125; 不可以同时拥有一个可变引用和一个不变的引用 多个不变的引用是可以的 123456fn main()&#123; let mut s = String::from('alex'); let r1 = &amp;s; let r2 = &amp;s; let s1 = &amp;mut s; // error! 不可以同时拥有可变引用和不可变引用&#125; 5.6.4 悬垂引用 Dangling References 一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了； Rust里，编译器可保证引用永远都不是悬空引用； 如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域； 1234567fn main()&#123; let r = dangle();&#125;fn dangle() -&gt; &amp;String &#123; // compiler error： let s = Sring::from('alex'); &amp;s&#125;// 随着s离开作用域，会调用drop释放内存，而对它的引用 &amp;s 却继续返回了。所以这个引用指向了一个被释放掉了的内存地址；即悬空指针，但Rust在编译阶段就规避掉了； 5.6.5 引用的规则在任何给定的时刻，只能满足下列条件之一： 一个可变的引用 任意数量不可变的引用 引用必须一直有效 5.7 切片 slice Rust的另外一种不持有所有权的数据类型：切片（slice） 编写一个函数： 它接收字符串作为参数 返回它在这个字符串里找到的第一个单词 如果函数没找到任何空格，那么整个字符串就被返回； 123456789101112131415161718192021fn main() &#123; let mut s = String::from(\"hello alex\"); let name_index = first_world(&amp;s); s.clear(); println!(\"&#123;&#125;\", name_index);&#125;fn first_world(s: &amp;String) -&gt; usize &#123; let bytes = s.as_bytes(); // 转成字节数组 // iter 方法为bytes创建一个迭代器，这个方法依次返回集合中的每个元素。然后 // 调用的enumerate方法，它会将iter方法的结果进行包装，并把结果作为tuple的一部分进行返回。 // 元祖的第一个元素，就是enumerate遍历的索引 i，第二个元素就是引用 item。 // (i, &amp;item) 实际上是模式匹配之后的解构 for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return i; &#125; &#125; s.len()&#125; 然而上面的函数设计是有问题的， name_index 和 s 太过耦合了。当s被清空之后，name_index的值就不再有意义了； 那如何确保 s 和 name_index 之间的同步性呢； 解决方案： 字符串切片 5.7.1 字符串切片 字符串切片是指向字符串中一部分内容的引用 形式： [开始索引…结束索引] 12let a = [1, 2, 3, 4, 5];let slice = &amp;a[1..3]; 几个语法糖 注意： 字符串切片的范围索引必须发生在有效的UTF-8字符边界内； 如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出 1234567891011121314151617fn main() &#123; let s = String::from(\"hello alex\"); let name_index = first_world(&amp;s); println!(\"&#123;&#125;\", name_index);&#125;fn first_world(s: &amp;String) -&gt; &amp;str &#123; // &amp;str 字符串切片 let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return &amp;s[..i]; &#125; &#125; &amp;s[..]&#125; 5.7.2 字符串字面值是切片字符串字面值被直接存储在二进制程序中； 12let s = \"he\" // s 为 &amp;str类型，即字符串切片// s就是一个指向二进制程序 特定位置的切片，而&amp;str是不可变的引用； 变量s的类型是&amp;str， 它是一个指向二进制程序特定位置的切片 &amp;str是不可变引用，所以字符串字面值也是不可变的； 5.7.3 将字符串切片作为参数传递12345678910111213141516171819202122232425fn main() &#123; let my_string = String::from(\"hello world\"); // first_word 中传入 `String` 的 slice let word = first_word(&amp;my_string[..]); let my_string_literal = \"hello world\"; // first_word 中传入字符串字面值的 slice let word = first_word(&amp;my_string_literal[..]); // 因为字符串字面值 **就是** 字符串 slice， // 这样写也可以，即不使用 slice 语法！ let word = first_word(my_string_literal);&#125;fn first_world(s: &amp;String) -&gt; &amp;str &#123; // &amp;str 字符串切片 let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return &amp;s[..i]; &#125; &#125; &amp;s[..]&#125; 定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能； 6. struct6.1 定义并实例化struct12345678910111213141516struct User &#123; username: String, emila: String, sign_in_count: u64, active: bool,&#125;fn main() &#123; println!(\"Hello, world!\"); let user1 = User &#123; username: String::from(\"alex\"), emila: String::from(\"123@qq.com\"), sign_in_count: 12, active: true, &#125;;&#125; 一旦struct的实例是可变的，那么实例中所有的字段都是可变的。不允许部分可变，部分不可变 6.1.1 tuple struct1234struct Color(i32,i32,i32);struct Point(i32,i32,i32);let black = Color(0,0,0);let origin = Point(0,0,0); black和origin是不同的类型，是不同tuple struct的实例 6.1.2 Unit-Like Struct（没有任何字段） 可以定义没有任何字段的struct，叫做Unit-Like Struct（因为与（），单元类型类似） 适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据 6.1.3 struct 数据的所有权123456struct User &#123; username: String, emila: String, sign_in_count: u64, active: bool,&#125; 这里的字段使用了String 而不是 &amp;str 该struct实例拥有其所有的数据 只要struct实例是有效的，那么里面的字段数据也是有效的 struct里也可以存放引用，但这需要使用生命周期； 声明周期保证只要struct实例是有效的，那么里面的引用也是有效的； 如果struct里面存储引用，而不使用生命周期，就会报错 6.1.4 计算面积的例子123456789101112131415// 例子1struct Rectangle &#123; width: u32, height: u32,&#125;fn area(rect: &amp;Rectangle) -&gt; u32 &#123; rect.height * rect.width&#125;fn main() &#123; let rect = Rectangle &#123; width: 30, height: 50, &#125;; println!(\"&#123;&#125;\", area(&amp;rect));&#125; 6.1.5 几种模式12345std::fmt::Displaystd::fmt::Debug#[derive(Debug)]&#123;:?&#125;&#123;:#?&#125; 6.2 struct的方法方法和函数类似： fn关键字、名称、参数、返回值 方法与函数不同之处： 方法是在struct（或enum、trait对象）的上下文中定义 第一个参数是self，表示方法被调用的struct实例 123456789101112131415161718struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // impl块中定义方法 fn area(&amp;self) -&gt; u32 &#123; // 方法第一个参数可以是 &amp;self self.height * self.width &#125;&#125;fn main() &#123; let rect = Rectangle &#123; width: 30, height: 50, &#125;; println!(\"&#123;&#125;\", rect.area());&#125; 6.2.1 方法调用的运算符在调用方法时， Rust根据情况自动添加 &amp;、 &amp;mut 或 *， 以便object可以匹配方法的签名； 123// 两行代码效果相同：p1.dis(&amp;p2);(&amp;p1).dis(&amp;p2); 6.2.2 方法参数方法可以有多个参数 1234567891011121314151617181920212223242526struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.height * self.width &#125; fn can_hole(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.height &gt; other.height &amp;&amp; self.width &gt; other.width &#125;&#125;fn main() &#123; let rect = Rectangle &#123; width: 30, height: 50, &#125;; let rect1 = Rectangle &#123; width: 20, height: 30, &#125;; println!(\"&#123;&#125;\", rect.area()); println!(\"&#123;&#125;\", rect1.can_hole(&amp;rect1));&#125; 6.3 关联函数可以在impl块里定义不把self作为第一个参数的函数，它们叫关联函数（不是方法） 例如： String::from() 关联函数通常用于构造器 ::符号 关联函数 模块创建的命名空间 1234567891011121314151617struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn square(size: u32) -&gt; Rectangle &#123; Rectangle &#123; width: size, height: size, &#125; &#125;&#125;fn main() &#123; let s = Rectangle::square(12);&#125; 7. 枚举与模式匹配7.1 定义12345enum Ip &#123; V4,V6&#125;let a = Ip::V4;let b = Ip::V6; 12345678910111213141516171819enum IpAddrKind &#123; V4, V6,&#125;struct IpAddr &#123; kind: IpAddrKind, address: String,&#125;let home = IpAddr &#123; kind: IpAddrKind::V4, address: String::from(\"127.0.0.1\"),&#125;;let loopback = IpAddr &#123; kind: IpAddrKind::V6, address: String::from(\"::1\"),&#125;; 7.1.1 将数据附加到枚举的变体中1234567enum IpAddr &#123; V4(String), V6(String),&#125;let home = IpAddr::V4(String::from(\"127.0.0.1\"));let loopback = IpAddr::V6(String::from(\"::1\")); 我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。 优点： 不需要额外使用struct 每个变体可以拥有不同的类型以及关联的数据量 1234enum Ip &#123; V4(u8,u8,u8,u8), V6(String)&#125; 7.2 option枚举定义于标准库中 在Prelude中 描述了： 某个值可能存在（某种类型）或不存在的情况 7.2.1 OptionRust中类似Null概念的枚举 - Option Rust没有Null 其它语言中： Null是一个值，它表示“没有值” 一个变量可以处于两种状态： 空值（null）、非空 Null引用： Billion Dollar Mistake Null的问题在于： 当你尝试像使用非Null值那样使用Null值的时候，就会引起某种错误 Null的概念还是有用的：因某种原因而变为无效或缺失的值； 12345// 标准库中的定义：enum Option&lt;T&gt; &#123; Some(T), None&#125; 它包含在Prelude（预导入模块）中，可直接使用； Option Some None 1234let some_number = Some(5);let some_string = Some(\"a string\");let absent_number: Option&lt;i32&gt; = None; Option比Null好在哪？ Option和T是不同的类型，不可以把Option直接当成T 12345fn main()&#123; let x:i8 = 5; let y: Option&lt;i8&gt; = Some(5); let sum = x + y; // error: cannot add Option&lt;i8&gt; to i8;&#125; 若想使用Option中的 T，必须将它转换为 T； 这就避免了其它语言中最常见的那个错误；那就是假设某个值存在，但它实际上为Null 123&#x2F;&#x2F; 比如在C#string a &#x3D; null;string b &#x3D; a + &quot;12345&quot;; &#x2F;&#x2F; error 7.3 match控制流运算符 - match match允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码； 模式可以是字面量、变量名、通配符 123456789101112131415enum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125; 7.3.1 绑定值的模式匹配的分支可以绑定到被匹配对象的部分值 因此，可以从enum变体中提取值 1234567891011121314151617181920212223242526272829#[derive(Debug)]enum UsState &#123; Alabama, Alaska,&#125;enum Coin &#123; Penny, Nickel, Dime, Quarter(UsState),&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; &#123; println!(\"penny\"); 1 &#125; Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; &#123; println!(\"State quarter from &#123;:?&#125;!\", state); 25 &#125; &#125;&#125;fn main() &#123; let c = Coin::Quarter(UsState::Alabama); println!(\"&#123;&#125;\", value_in_cents(c));&#125; 7.3.2 匹配Option123456789101112fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None);&#125;fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125; 7.3.3 match必须穷举所有可能_ 通配符： 替代其余没有列出的值； 12345678let some_u8_value = 0u8;match some_u8_value &#123; 1 =&gt; println!(\"one\"), 3 =&gt; println!(\"three\"), 5 =&gt; println!(\"five\"), 7 =&gt; println!(\"seven\"), _ =&gt; (),&#125; 7.4 if let处理只关心一种匹配而忽略其它匹配的情况 123456789101112let some_u8_value = Some(0u8);// match 方法match some_u8_value &#123; Some(3) =&gt; println!(\"three\"), _ =&gt; (),&#125;// if let 相当于只处理一种匹配的情况，其它的分支就不关心了if let Some(3) = some_u8_value &#123; println!(\"three\");&#125; if let 优缺点 更少的代码，更少的锁紧，更少的模版代码 放弃了穷举的可能 可以把 if let 看作是 match的语法糖 123456789// if let 搭配 elsefn main()&#123; let v = Some(0u8); if let Some(3) = v &#123; println!(\"three\"); &#125; else &#123; println!(\"others\"); &#125;&#125; 8. Package, Crate 和 Module模块系统： Package（包）， Cargo的特性，让你构建、测试、共享crate； Crate（单元包）， 一个模块树，它可产生一个library或执行文件； Module（模块）， use： 让你控制代码的组织、作用域、私有路径； path（路径）： 为struct、function 或module 等项命名的方式； 8.1 Package 和 Cratecrate上面是package， Crate的类型 binary library Crate Root 是源代码文件 Rust编译器从这里开始，组成你的Crate的根Module 一个Package 包含1个Cargo.toml, 它描述了如何构建这些Crates； 只能包含0-1个library crate； 可以包含任意数量的binary crate； 必须至少包含一个crate（library或binary） 12$&gt; cargo new my-pro# create binary (application) `my-pro` package 8.1.1 Cargo的惯例src/main.rs src/main.rs // package 的入口文件 Binary crate 的 crate root （cargo会默认让 main.rs做为crate的根） crate名与package名相同 （也是指这个binary crate的名和包名相同，都是my-pro） src/lib.rs Package 包含一个library crate library crate 的 crate root crate名与package名相同 （也都是my-pro） 复习： 如果有main.rs,就说明有一个 binary crate。 如果有lib.rs , 就说明有一个library crate。 两个都是入口文件，都是crate的根。而crate名都与package名相同。 cargo会把crate root文件交给rustc 来构建library 或 binary 一个Package可以同时包含main.rs 和 lib.rs, 表明，这个package含有一个 binary crate，一个library crate。名称都与package名相同 一个package可以有多个binary crate 文件都放在src/bin 每个文件是单独的binary crate 8.2 Crate的作用 将相关功能组合到一个作用域内，便于在项目间进行共享，也能防止命名冲突 例如： rand crate，访问它的功能需要通过它的名字： rand 8.3 定义module来控制作用域和私有性Module 在一个crate内，将代码进行分组； 增加可读性，易于复用； 控制项目（item）的私有性，public、private 8.3.1 建立module mod 关键字{} 可嵌套 可包含其它项（struct、enum、常量、trait、函数等）的定义 12345678910#cargo new my-pro|- crate |- front_of_house |- hosting |- add_to_waitlist |- seat_at_table |- serving |- take_over |- serve_order |- take_payment main.rs lib.rs 都叫crate roots； 这两个文件（任意一个）的内容形成了名为crate的模块，位于整个模块树的根部； 整个模块树在隐式的crate模块下 8.4 path根其它语言里面的命名空间有点类似 为了在Rust的模块中找到某个条目，需要使用路径 路径的两种形式 绝对路径： 从crate root开始，使用crate名或字面值crate 相对路径： 从当前模块开始，使用self，super或当前模块的标识符； 路径至少由一个标识符组成，标识符之间使用:: 123456789101112131415// 跟级别可以不加 pub 互相调用mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;// pub 关键字 设置该module为公共的pub fn eat_at_restaurant() &#123; // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // Relative path front_of_house::hosting::add_to_waitlist();&#125; 8.4.1 私有边界（private boundary）模块不仅可以组织代码，还可以定义私有边界 如果想把 函数 或 struct 等设为私有，可以将它放到某个模块中； Rust中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的； 父级模块无法访问子模块中的私有条目 私有条目都是隐藏实现细节，不允许其它模块进行访问。 子模块里可以使用所有祖先模块中的条目 8.4.2 super关键字123$&gt; ls..$&gt; hello hello.c$&gt; ../hello # hello super关键字 在Rust中，用来访问父级模块路径中的内容，类似文件系统中的.. 12345678910fn serve_order()&#123;&#125;mod back_of_house&#123; fn fix_incorrect_order()&#123; cook_order(); super::serve_order(); // 上一级模块的 serve_order 方法 crate::serve_order(); // 绝对路径的写法 &#125; fn cook_order()&#123;&#125;&#125; 8.4.3 use关键字可以使用use关键字将路径导入到作用域内 仍遵循私有性规则 1234567891011121314151617mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;// 使用use来指定相对路径use crate::front_of_house::hosting;// 函数 指定到父级模块； hostingpub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125;// 使用use来指定绝对路径use front_of_house::hosting; struct, enum 其它： 指定完整路径（指定到本身） 12345use std::collections::HashMap;fn main()&#123; let mut map = HashMap::new(); map.insert(1,2);&#125; 同名条目： 指定到父级 8.4.3.1 使用pub use重新导出名称使用use将路径（名称）导入到作用域内后，该名称在此作用域内是私有的； 12345678910111213mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; &#125;&#125;pub use crate::front_of_house::hosting; // 从此，外部模块也能访问 hosting了// 函数 指定到父级模块； hostingpub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();&#125; 8.4.3.2 使用嵌套路径清理大量的use语句如果使用同一个包或模块下的多个条目（例子） 可使用嵌套路径在同一行内将上述条目进行引入： 路径相同的部分::{路径差异的部分} 1234567// use std::cmp::Ordering;// use std::io;use std::&#123;cmp::Ordering, io&#125;;// use std::io;// use std::io::Writeuse std::io::&#123;self, Write&#125;; 8.4.4 通配符 *使用 * 可以把路径中所有的公共条目都引入到作用域 1use std::collections::* 谨慎使用 应用场景： 测试，将所有被测试代码引入到tests模块 有时被用于预导入（prelude）模块 8.4.5 as关键字as关键字可以为引入的路径指定本地的别名 12use std::io::Result as IoResult;fn f2() -&gt; IoResult&#123;&#125;; 8.4.6 使用外部包（package） cargo.toml 添加依赖的包（package） use将特定条目引入作用域； 8.4.6.1 切换国内镜像1234$&gt; where cargo$&gt; cd /Users/xx/.cargo/$&gt; ls -a$&gt; vim config 123456789[source.crates-io]registry = \"https://github.com/rust-lang/crates.io-index\"replace-with = 'tuna'[source.tuna]registry = \"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git\"[net]git-fetch-with-cli = true 8.5 将模块拆分为不同文件将模块内容移动到其它文件 模块定义时，如果模块名后边是； ，而不是代码块 Rust 会从与模块同名的文件中加载内容 模块树的结构不会变化 12345|- src |- /front_of_house |- hosting.rs |- front_of_houre.rs |- lib.rs 123456// front_of_house.rspub mod hosting;// lib.rsmod front_of_house;// hosting.rspub fn add_to_waitlist()&#123;&#125; 随着模块逐渐变大，该技术让你可以把模块的内容移动到其它文件中； 9. 集合9.1 Vector Vec,叫作vector 由标准库提供 可存储多个值 只能存储相同类型的数据 值在内存中连续存放 9.1.1 创建Vec 使用 vec! 宏 9.1.2 所有权和借用规则不能在同一作用域内同时拥有可变和不可变引用 12345fn main()&#123; let mut v = vec![1,2,3,4,5]; let first = &amp;v[0]; // 不可变借用 v.push(6); // 可变的借用&#125; vector的工作原理： vec里面的元素在内存中的摆放是连续的，所以再往vec中添加一个元素的时候，在内存中就没有这么大的连续内存块。就可能将内存重新分配一下了，再找一个足够大的内存来放置这些添加了元素之后的vector，原来那块内存可能被释放掉或者重新分配，而first变量仍然指向原来的内存地址，这样的话，程序必然出现问题了；所以，借用规则防止类似的情况发生 9.1.3 遍历123456789let v = vec![100, 32, 57];for i in &amp;v &#123; println!(\"&#123;&#125;\", i);&#125;let mut v = vec![100, 32, 57];for i in &amp;mut v &#123; *i += 50;&#125; 9.1.4 vector+enum使用enum来存储多种数据类型 enum的变体可以附加不同类型的数据 enum的变体定义在同一个enum类型下 1234567891011enum SpreadsheetCell &#123; Int(i32), Float(f64), Text(String),&#125;let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\"blue\")), SpreadsheetCell::Float(10.12),]; 9.2 String字符串困扰 Rust倾向于暴露可能的错误 字符串数据结构复杂 UTF-8 9.2.1 定义Rust的核心语言层面，只有字符串类型：字符串切片 str （&amp;str） 字符串切片： 对存储在其它地方、utf-8编码的字符串引用 字符串字面值： 存储在二进制文件中，也是字符串切片 9.2.2 String类型来自标准库 而不是核心语言 可增长，可修改，可拥有 UTF-8 编码 9.2.3 其它类型的字符串Rust标准库还包含了很多其它的字符串类型， OsString、OsStr、CString、CStr String vs Str后缀： 拥有或借用的变体 可存储不同编码的文本或在内存中以不同的形式展现 9.2.4 使用初始值创建String12345678let data = \"initial contents\";let s = data.to_string();// 该方法也可直接用于字符串字面值：let s = \"initial contents\".to_string();// 字符串字面值创建Stringlet s = String::from(\"initial contents\"); 9.2.5 更新1234567891011121314fn main()&#123; let mut s = String::from(\"foo\"); let s1 = String::from(\"bar\"); s.push_str(&amp;s1); println!(\"&#123;&#125;\",s);&#125;fn main()&#123; let s1 = String::from(\"bar\"); let s2 = String::from(\"foo\"); let s3 = s1 + &amp;s2; // // 注意 s1 被移动了，不能继续使用&#125;// 因为在使用了 +，实际上使用了类似 下面 add这样的方法,当然标准库里面是泛型方法，这里为了理解，给替换成string类型先fn add(self, s:&amp;str) -&gt; String&#123;...&#125; // 参数1是 String，而不是切片，所以s1失去了所有权； 标准库中的add使用了泛型 只能把&amp;str添加到String 解引用强制转换（deref coercion） 9.2.6 format! 连接多个字符串123456789fn main()&#123; let s1 = String::from('tic'); let s2 = String::from('tac'); let s3 = String::from('toe'); let s3 = s1 + \"-\" + &amp;s2 + \"-\" + &amp;s3; // 类似于 format!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;\", s1, s2, s3); // format! 宏不会取得后续所有参数的所有权 println!(\"&#123;&#125;\", s3);&#125; format! 宏不会取得后续所有参数的所有权 9.2.7 索引字符串Rust字符串不支持索引； 9.2.8 bytes，scalar Values， Grapheme Clusters 字节、标量值、字形簇123456789101112fn main()&#123; let w = \"नमस्ते\"; for b in w.bytes()&#123; println!(\"&#123;&#125;\", b); // [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135] &#125; for b in w.chars() &#123; println!(\"&#123;&#125;\", b); // ['न', 'म', 'स', '्', 'त', 'े'] &#125;&#125; 9.2.9 Rust不允许对String进行索引最后一个原因 索引操作应消耗一个常量时间（O（1）） 而String无法保证，需要遍历所有内容，来确定有多少个合法的字符 9.2.10 字符串切割12let hello = \"Здравствуйте\";let s = &amp;hello[0..4]; 9.3 HashMap对于实现Copy trait的类型（i32），值会被复制到HashMap中 对于拥有所有权的值（String），值会被移动，所有权会转移给HashMap 如果将值的引用插入到HashMap，值本身就不会移动 在hashMap有效的期间，被引用的值必须保持有效 9.3.1 get可以通过get方法并提供对应的键来从哈希map中获取值 123456789101112131415use std::collections::HashMap;fn main()&#123; let mut scores = HashMap::new(); scores.insert(String::from(\"blue\"), 10); scores.insert(String::from(\"yellow\"), 50); let team_name = String::from(\"blue\"); let score = scores.get(&amp;team_name); match score &#123; Some(s) =&gt; println!(\"&#123;&#125;\", s), // 10 None =&gt; println!(\"team not exist\") &#125;;&#125; 9.3.2 更新HashMap K已经存在，对应一个V 替换现有的V 保留现有的V，忽略新的V 合并现有的V和新的V K不存在 添加一对K，V 123456789// 替换use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.insert(String::from(\"Blue\"), 25);println!(\"&#123;:?&#125;\", scores); 9.3.2.1 entryentry方法： 检查指定的K是否对应一个V 参数为K 返回enum Entry：代表值是否存在 123456789use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.entry(String::from(\"Yellow\")).or_insert(50);scores.entry(String::from(\"Blue\")).or_insert(50);println!(\"&#123;:?&#125;\", scores); Entry的 or_insert 方法 返回 如果K存在，返回到对应的V的一个可变引用 如果K不存在，将方法参数作为K的新值插进去，返回到这个值的可变引用； 12345678910111213// 根据旧值更新一个值use std::collections::HashMap;let text = \"hello world wonderful world\";let mut map = HashMap::new();for word in text.split_whitespace() &#123; let count = map.entry(word).or_insert(0); *count += 1;&#125;println!(\"&#123;:?&#125;\", map); 10. panic Rust错误分类 可恢复 例如文件未找到，可再次尝试 不可恢复 bug，例如访问的索引超出范围 Rust没有类似异常的机制 可恢复错误： Result&lt;T,E&gt; 不可恢复： painc！ 当执行painc！时，程序立即结束执行 不可恢复的错误与panic！ 当panic！宏执行： 你的程序会打印一个错误信息 展开（unwind）、清理调用栈（Stack） 退出程序 为应对panic，展开或中止（abort）调用栈 默认情况下，当panic发生： -程序展开调用栈（工作量大） rust沿着调用栈往回走 清理每个遇到的函数中的数据 或立即中止调用栈： 不进行清理，直接停止程序 内存需要OS进行清理 想让二进制文件更小，把设置从“展开”改为“中止”： 在Cargo.toml中适当的profile部分设置： 12[profile.release]panic = 'abort' 1234// 不可恢复的错误与panic！fn main()&#123; panic!(\"crash and burn\");&#125; 10.1 Result 与可恢复的错误1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E)&#125; T: 操作成功情况下，Ok变体里返回的数据的类型 E： 操作失败情况下，Err变体里返回的错误的类型 处理Result的一种方式： match表达式 和Option枚举一样，Result及其变体也是有prelude带入作用域 123456789101112use std::fs::File;fn main() &#123; let f = File::open(\"./0.txt\"); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; &#123; panic!(\"Error opening file &#123;:?&#125;\", error) &#125; &#125;; println!(\"&#123;:?&#125;\", f);&#125; 10.2 匹配不同的错误12345678910111213141516use std::fs::File;use std::io::ErrorKind;fn main() &#123; let f = File::open(\"hello.txt\"); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; match error.kind() &#123; ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") &#123; Ok(fc) =&gt; fc, Err(e) =&gt; panic!(\"Problem creating the file: &#123;:?&#125;\", e), &#125;, other_error =&gt; panic!(\"Problem opening the file: &#123;:?&#125;\", other_error), &#125;, &#125;;&#125; 上例使用了很多match match很有用，但是很原始 闭包（closure）。Result&lt;T,E&gt;有很多方法 它们接收闭包作为参数 使用match实现 1234567891011121314use std::fs::File;use std::io::ErrorKind;fn main() &#123; let f = File::open(\"hello.txt\").unwrap_or_else(|error| &#123; if error.kind() == ErrorKind::NotFound &#123; File::create(\"hello.txt\").unwrap_or_else(|error| &#123; panic!(\"Problem creating the file: &#123;:?&#125;\", error); &#125;) &#125; else &#123; panic!(\"Problem opening the file: &#123;:?&#125;\", error); &#125; &#125;);&#125; 10.2.1 unwrapunwrap： match表达式的一个快捷方法； 如果Result结果是Ok，返回Ok里面的值 如果Result结果是Err，调用panic！宏 12345678910111213141516use std::fs::File;fn main() &#123; let f = File::open(\"0.txt\"); let f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; &#123; panic!(\"Error opening file &#123;:?&#125;\", error) &#125; &#125;; let f = File::open(\"0.txt\").unwrap(); // 相当于上面的match表达式 println!(\"&#123;:?&#125;\", f);&#125; 10.2.2 expectexpect： 和unwrap类似，但可指定错误信息 12345use std::fs::File;fn main() &#123; let f = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");&#125; 10.3 传播错误当编写一个其实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误， 1234567891011121314151617181920use std::io;use std::io::Read;use std::fs::File;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(\"hello.txt\"); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); // 返回值 match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125; ?运算符 ?运算符： 传播错误的一种快捷方式 ？与from函数 Trait std::convert::From 上的from函数： 用于错误之间的转换 被？所应用的错误，会隐士的被from函数处理 当？调用from函数时： 它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型 用于： 针对不同错误的原因，返回同一种错误类型 只要每个错误类型实现了转换为所返回的错误类型的from函数 链式操作 12345fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); File::open(\"hello.txt\")?.read_to_string(&amp;mut s)?; Ok(s)&#125; ?运算符只能用于返回Result的函数 ?运算符与main函数 12345// 在main中使用？fn main()-&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;&#123; let f = File::open(\"hello.txt\")?; Ok(())&#125; main函数返回类型是：() main函数的返回类型也可以是： Result&lt;T,E&gt; Box是trait对象 简单理解： “任何可能的错误类型” 10.4 什么时候应该用panic!见示例 11. 泛型，Trait 生命周期11.1 泛型你编些的代码不是最终的代码，而是一种模版，里面有一些“占位符”； 编译器在编译时将“占位符”替换为具体的类型； 在编译的时候，会将泛型的类型参数编译成具体的类型。这个过程叫单态化； 1234567891011121314151617181920212223fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list.iter() &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125;fn main() &#123; let number_list = vec![34, 50, 25, 100, 65]; let result = largest(&amp;number_list); println!(\"The largest number is &#123;&#125;\", result); let char_list = vec!['y', 'm', 'a', 'q']; let result = largest(&amp;char_list); println!(\"The largest char is &#123;&#125;\", result);&#125; 11.2 Trait Trait告诉rust编译器： 某种类型具有哪些并且可以与其它类型共享的功能 Trait：抽象的定义共享行为 Trait bounds（约束）泛型类型参数指定为实现了特定行为的类型； Trait 与其它语言的接口（interface）类似，但有些区别； 11.2.1 如何定义一个trait类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。 trait 定义： 是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。 关键字： trait 只有方法签名，没有具体实现 trait可以有多个方法： 每个方法签名占一行，以；结尾 实现该trait的类型必须提供具体的方法实现； 123pub trait Sunmmary &#123; // 一个trait， 可以有多个方法的签名 fn sunmmary(&amp;self) -&gt; String;&#125; 11.2.2 在类型上实现trait与为类型实现方法类似 不同之处： impl 类型 for trait名{} // 为类型实现方法则是 impl 类型 {...} 在impl的块里，需要对Trait里的方法签名进行具体的实现 1234567891011121314151617181920212223242526272829pub trait Summary &#123; // 一个trait， 可以有多个方法的签名 fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;impl Summary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;, by &#123;&#125; (&#123;&#125;)\", self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;: &#123;&#125;\", self.username, self.content) &#125;&#125; 11.2.3 实现trait的约束可以在某个类型上实现某个trait的前提条件是： 这个类型或这个trait是在本地crate里定义的 无法为外部类型来实现外部的trait； 这个限制是程序属性的一部分（也就是一致性） 更具体地说是孤儿规则： 之所以这样命名是因为父类型不存在； 此规则确保其它人的代码不能破坏您的代码，反之亦然； 如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了； 11.2.4 默认实现有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。 123456789101112131415161718192021222324252627282930313233pub trait Sunmmary &#123; // 一个trait， 可以有多个方法的签名 // fn summarize(&amp;self) -&gt; String; fn summarize1(&amp;self)-&gt;String &#123; String::from(\"(...)\") &#125;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String,&#125;impl Sunmmary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;, by &#123;&#125; (&#123;&#125;)\", self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool,&#125;impl Sunmmary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(\"&#123;&#125;: &#123;&#125;\", self.username, self.content) &#125;&#125; 默认实现的方法可以调用trait中其它的方法，即使这些方法没有默认实现 注意： 无法从方法的重写实现里面调用默认的实现 11.2.5 Trait作为参数impl Trait语法 适用于简单情况 12345678910pub trait Sunmmary &#123; // 一个trait， 可以有多个方法的签名 // fn summarize(&amp;self) -&gt; String; fn summarize1(&amp;self)-&gt;String &#123; String::from(\"(...)\") &#125;&#125;pub fn notify(item: impl Summary) &#123; // 类型区域 添加 impl Summary println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125; Trait bound语法 可用于复杂情况 impl Trait 语法是 Trait bound的语法糖 123pub fn notify&lt;T: Summary&gt;(item: T) &#123; println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125; 使用 + ，指定多个 Trait bound 123456pub fn notify(item: impl Summary + Display) &#123; // 类型区域 添加 impl Summary println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125;pub fn notify&lt;T: Summary + Display&gt;(item1: T, item2: T) &#123; println!(\"Breaking news! &#123;&#125;\", item.summarize1());&#125; Trait bound 使用where子句 1234567pub fn notify&lt;T, U&gt;(a: T, b: U) -&gt; Stringwhere T: Summary + Display, U: Clone + Debug,&#123; format!(\"Breaking news! &#123;&#125;\", a.summarize());&#125; 实现Trait作为返回类型 impl Trait 语法 123456pub fn notify1(s: &amp;str) -&gt; impl Summary &#123; NewsArticle &#123; headline: String::from(\"\"), ... &#125;&#125; 注意： impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错 使用Trait Bound的例子 例子： 使用Trait Bound修复largest函数 使用Trait Bound有条件的实现方法 在使用泛型类型参数的impl块上使用 Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法 12345678910111213141516171819202122232425use std::fmt::Display;struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(\"The largest member is x = &#123;&#125;\", self.x); &#125; else &#123; println!(\"The largest member is y = &#123;&#125;\", self.y); &#125; &#125;&#125; 可以为实现了其它Trait的任意类型有条件的实现某个Trait 为满足Trait Bound 的所有类型上实现Trait叫做覆盖实现； 11.3 生命周期Rust的每个引用都有自己的生命周期 声明周期： 引用保持有效的作用域 大多数情况： 声明周期是隐式的、可被推断的 当引用的声明周期可能以不同的方式互相关联时： 手动标注声明周期 11.3.1 生命周期——避免悬垂引用生命周期的主要目标： 避免悬垂引用（dangling reference） 12345678fn main()&#123; let r; &#123; let x = 5; r = &amp;x; // error , x走出作用域之后被释放掉了； &#125; println!(\"r: &#123;&#125;\",r);&#125; rust如何识别上面代码不合法呢？答案是 借用检查器 11.3.2 借用检查器Rust编译器的借用检查器： 比较作用域来判断所有的借用是否合法 12345678910&#123; let r; // ---------+-- 'a // | &#123; // | let x = 5; // -+-- 'b | r = &amp;x; // | | &#125; // -+ | // | println!(\"r: &#123;&#125;\", r); // ---------+ &#125; 11.3.3 函数中的泛型生命周期11.3.3.1 生命周期标注123456789101112131415fn main() &#123; let string1 = String::from(\"abcd\"); let string2 = \"abc\"; // 字符串字面量，也就是字符串切片类型 let result = longest(&amp;string1, string2); println!(\"longest -&gt; &#123;&#125;\", result);&#125;// 需要让参数 x，y 和 返回值 做生命周期的关联fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 11.3.3.2 生命周期标注生命周期标注语法 生命周期的标注不会改变引用的生命周期长度 当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用 生命周期的标注： 描述了多个引用的生命周期间的关系，但不影响生命周期 1234567891011121314151617fn main() &#123; let string1 = String::from(\"abcd\"); let string2 = \"abc\"; // 字符串字面量，也就是字符串切片类型 let result = longest(&amp;string1, string2); println!(\"longest -&gt; &#123;&#125;\", result);&#125;// 需要让参数 x，y 和 返回值 做生命周期的关联// 'a 为生命周期的标注： 描述了多个引用的生命周期的关系// 不影响生命周期fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 生命周期参数名： 以 单引号 开头 通常全小写非常短 很多使用’a 生命周期标注的位置 在引用的 &amp; 符号后 使用空格将标注 和 引用类型 分开 生命周期的标注 123&amp;i32 // 一个引用&amp; 'a i32 // 带有显式生命周期的引用&amp; 'a mut i32 // 带有显式生命周期的可变引用 单个生命周期标注本身没有意义 标注之所以存在，是为了向rust描述多个泛型生命周期参数之间的关系 12// 'a 生命周期取决于 x 和 y中 存活时间较短的那个fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str; 11.3.4 深入理解生命周期指定生命周期参数的方式依赖于函数所做的事情 从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配； 如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值： 这就是悬垂引用，该值在函数结束时就走出了作用域 1234567891011fn main()&#123; let string1 = String::from(\"abcd\"); let string2 = \"xyz\"; let result = longest(string1.as_str(), string2); println!(\"the longest string is&#123;&#125;\", result);&#125;fn longest&lt;'a&gt;(x: &amp; 'a str, y: &amp;str) -&gt; &amp;'a str &#123; let result = String::from(\"abc\"); // result.as_str() // 报错，字符串切片引用会随着函数执行完毕被释放，所以会导致 悬垂引用&#125; 解决方法一： 1234fn longest&lt;'a&gt;(x: &amp; 'a str, y: &amp;str) -&gt; String &#123; let result = String::from(\"abc\"); result // 把函数所有权移交给调用者；然后这块内存清理就交由调用者来清理&#125; 通过这个例子看出，生命周期语法就是用来关联函数的不同参数以及返回值之间生命周期的。一旦它们取得某种联系，rust就获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其它违反内存安全的行为； 11.3.4.1 Struct定义中的生命周期标注Struct里可包括： 自持有的类型 引用： 需要在每个引用上添加生命周期标注 12345678910111213struct ImportantExcerpt&lt;'a&gt; &#123; part: &amp;'a str,&#125;fn main()&#123; let novel = String::from(\"call me inhmael, Some years age...\"); // first_sentence 的生命周期反问大于 结构体内的 first_sentence；所以此段代码可以编译通过 let first_sentence = novel.split('.').next().expect(\"Could not found a '.'\"); let i = ImportantExcerpt&#123; part: first_sentence &#125;&#125; 11.3.4.2 生命周期的省略每个引用都有生命周期 需要为使用生命周期的函数或struct指定生命周期参数 123456789101112// 没有指定生命周期参数却通过编译fn first_word(s: &amp;str) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for(i, &amp;item) in bytes.iter().enumerate() &#123; if item == b' ' &#123; return &amp;s[0..i]; &#125; &#125; &amp;s[..]&#125;// 而之前的例子告诫我们应该写成下面这种才能编译通过fn first_word&lt;'a&gt;(s : &amp;'a str) -&gt; &amp; 'a str Rust发现，在某些特定情况下。程序员总是一遍又一遍编写同样的生命周期标注。而且这种场景是可预测的。它有一些明确的模式 于是，rust团队就将这些模式写入了编译器代码。就使得借用检查器在这些情况下可以自动的对生命周期进行推导，而无需显式的标注。 了解这段历史是有必要的，因为在未来可能会有更多的特定模式被直接添加到编译器当中；也就是说在未来需要手动标注生命周期的地方可能会越来越少； 11.3.4.3 生命周期省略规则这个在Rust引用分析中所编入的模式就称为生命周期省略规则； 这些规则无需开发者来遵守 它们是一些特殊情况，由编译器来考虑 如果你的代码复合这些情况，那么久无需显式标注生命周期 生命周期省略规则不会提供完整的推断： 如果应用规则后，引用的生命周期仍然模糊不清-&gt; 编译错误 解决方法： 添加生命周期标注，表明引用间的相互关系 11.3.4.4 输入、输出生命周期生命周期在 函数/方法的参数： 输入生命周期 函数/方法的返回值： 输出生命周期 11.3.4.5 生命周期省略的三个规则编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期； 规则1 应用于输入生命周期 规则2、3 应用于输出生命周期 如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用 -&gt; 报错 这些规则适用于fn定义 和 impl块 规则1: 每个引用类型的参数都有自己的生命周期 换句话说，单参数的函数它就拥有一个生命周期参数，而拥有两个参数的函数就拥有两个不同的生命周期参数。 规则2: 如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数 规则3： 如果有多个输入生命周期参数，但其中一个是 &amp;self 或者 &amp; mut self（是方法），那么self的生命周期会被赋给所有的输出生命周期参数 demo1 12345fn first_word(s: &amp;str) -&gt; &amp;str;// 首先适用第一条规则，单参数函数它拥有一个生命周期参数fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str;// 第二条规则，如果只有1个输入生命周期参数，该生命周期被赋给所有输出生命周期参数fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp; 'a str; demo2 1234567fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str;//首先应用规则1，两个参数都有自己的生命周期fn longest&lt;'a,'b&gt;(x: &amp;'a str, y: &amp;'b str)-&gt; &amp;str;// 因为有两个参数，所以第二条规则已经不适用了// 没有self，所有第三条也不适用//在应用完三条规则之后，依然无法计算出返回类型的生命周期。所以编译器报错。 11.3.5 方法定义中的生命周期标注在struct上使用生命周期实现方法，语法和泛型参数的语法一样 在哪儿声明和使用生命周期参数 依赖于 生命周期参数是否和字段、方法的参数或返回值有关 struct字段的生命周期名： 在impl后声明 在struct名后使用 这些生命周期是struct类型的一部分 impl块内的方法签名中： 引用必须绑定于struct字段引用的生命周期，或者引用是独立的也可以 生命周期省略规则经常使用方法中的生命周期标注不是必须的； 12345678910111213141516struct ImportantExcerpt&lt;'a&gt; &#123; part: &amp;'a str,&#125;// impl 后面 和结构体后面 的生命周期参数不能省略impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; &#123; fn level(&amp;self) -&gt; i32 &#123; 3 &#125;&#125;fn main()&#123; let novel = String::from(\"Call me Ishmael,Some...\"); let first_sentence = novel.split('.').next().expect(\"Could not found a '.'\"); let i = ImportantExcerpt &#123; part: first_sentence &#125;&#125; 11.3.6 静态生命周期‘static 是一个特殊的生命周期： 整个程序的持续时间； 例如： 所有的字符串字面值都拥有 ‘static 生命周期 12let s: &amp;'static str = \"i have a static lifetime\"// 这个字符串字面值，它是被直接存储在二进制程序里面。所以它总是可用的。所以所有字符串字面值的生命周期都是 'static 为引用指定 ‘static 生命周期前要三思 是否需要引用在程序整个生命周期内都存活 因为在大部分情况下，错误的原因都在于尝试创建一个悬垂引用或者是可用生命周期不匹配。这个时候应该去尝试解决这些问题，而不是指定一个 ‘static 一个涉及泛型参数类型、Trait Bound、生命周期的例子 12345678910111213use std::fmt::Display;fn longest_with_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a strwhere T: Display,&#123; println!(\"Announcement! &#123;&#125;\", ann); if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main()&#123;&#125; 12 编写自动化测试12.1 编写和运行测试测试 函数 验证非测试代码的功能是否和预期一致 测试函数体（通常）执行的3个操作 （3A操作） 准备数据/状态 Arrange 运行被测试的代码 Act 断言（Assert）结果 Assert 解剖测试函数 测试函数需要使用test属性（attribute）进行标注 Attribute 就是一段Rust代码的元数据，它不会被改变被它修饰代码的逻辑，它只是被代码进行修饰或标注 在函数上面一行加上 #[test]，可以函数变为测试函数 运行测试 使用cargo test命令运行所有测试函数 Rust会构建一个Test Runner可执行文件 它会运行标注了test的函数，并报错其运行是否成功 当使用cargo 创建library项目的时候，会生成一个test module，里面有一个test函数； 你可以添加任意数量的test module或函数 123456789101112131415161718192021$&gt; cargo new adder --lib # 创建一个库项目 adder$&gt; cd adder &amp;&amp; cargo test # 运行测试$&gt; Compiling adder v0.1.0 (/Users/ruanhan/rust_pro/adder)Finished test [unoptimized + debuginfo] target(s) in 1.25sRunning target/debug/deps/adder-710a662a5bf33e5erunning 1 test# 测试 tests::it_works test tests::it_works ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered outDoc-tests adderrunning 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out 测试失败 测试函数panic就表示失败 每个测试运行在一个新线程 当主线程看见某个测试线程挂掉了，那个测试标记为失败了； 12.2 断言宏（Assert）使用assert! 宏检查测试结果 assert！ 宏，来自标准库，用来确定某个状态是否为true true 测试通过 false 调用panic！，测试失败 1234567891011121314151617181920212223242526272829#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] fn larger_can_hold_smaller() &#123; let larger = Rectangle &#123; width: 8, height: 7, &#125;; let smaller = Rectangle &#123; width: 5, height: 1, &#125;; assert!(larger.can_hold(&amp;smaller)); &#125;&#125; 使用assert_eq! 和 assert_ne! 测试相等性 都来自标准库 判断两个参数是否 相等或不等； 实际上，它们使用的就是 == 和 != 运算符 断言失败： 自动打印出两个参数的值； 使用debug格式打印参数 要求参数实现了 PartiaEq 和 Debug Traits（所有的基本类型和标准库里大部分类型都实现了） 123456789101112pub fn add_two(a: i32) -&gt; i32 &#123; a + 2&#125;#[cfg(test)]mod tests1 &#123; use super::*; #[test] fn it_adds_two() &#123; assert_eq!(4, add_two(2)); &#125;&#125; 12.3 自定义错误信息可以向 assert! assert_eq! assert_ne! 添加可选的自定义信息 这些自定义消息和失败消息都会打印出来 assert!: 第1参数必填，自定义消息作为第2个参数 assert_eq! assert_ne! ： 前2个参数必填，自定义消息作为第3个参数； 自定义消息参数会被传递给 format! 宏，可以使用{} 占位符 12345678910111213pub fn greeting(name: &amp;str) -&gt; String &#123; format!(\"Hello &#123;&#125;!\", name)&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] fn greeting_contain_name() &#123; let result = greeting(\"Carol\"); assert!(result.contains(\"Caro1l\"), \"错误信息是 '&#123;&#125;'\", result); &#125;&#125; 12.4 用should_panic检查恐慌验证错误处理的情况 测试除了验证代码的返回值是否正确，还需验证代码是否如预期的处理了发生错误的情况； 可验证代码在特定情况下是否发生了panic 这种测试需要添加 should_panic 属性 1234567891011121314151617181920212223242526pub struct Guess &#123; value: i32,&#125;impl Guess &#123; pub fn new(value: i32) -&gt; Guess &#123; if value &lt; 1 || value &gt; 100 &#123; panic!(\"Guess value must be between 1 and 100, got &#123;&#125;.\", value); &#125; Guess &#123; value &#125; &#125;&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] #[should_panic] fn greater_than_100() &#123; Guess::new(200); &#125;&#125; 为should_panic 属性添加一个可选的expected参数，让should_panic更精确；将检查失败信息中是否包含所指定文字； 1#[should_panic(expected=\"guess value must be less than ...\")] 12.5 在测试中使用Result&lt;T,E&gt;无需panic，可使用Result&lt;T,E&gt; 作为返回类型编写测试： 返回Ok： 测试通过 返回Err： 测试失败 1234567891011#[cfg(test)]mode test &#123; #[test] fn it_works -&gt; Result&lt;(), String&gt; &#123; if 2+2 ==4 &#123; Ok(()) &#125; else &#123; Err(String::from(\"not equal\")) &#125; &#125;&#125; 注意： 不要在使用Result&lt;T,E&gt; 编写的测试上标注 #[should_panic] 12.6 控制测试如何运行改变cargo test的行为： 添加命令行参数 不添加任何参数就是默认行为 并行运行 所有测试 捕获（不显示）所有输出，使读取与测试结果相关的输出更容易 1234# 显示cargo test命令 所用的参数有哪些cargo test --help # 显示出所有可以用在-- 后的参数，给二进制程序添加的参数cargo test -- --help 12.7 并行/连续运行测试运行多个测试： 默认使用多个线程并行运行； 运行快 确保测试之间 不会互相依赖 不依赖于某个共享状态（环境、工作目录、环境变量等） 显式函数输出 默认，如测试通过，rust的test库会捕获所有打印到标准输出的内容 例如： 如果被测试代码中用到了println! 如果测试通过： 不会在终端看到println! 打印的内容 如果测试失败： 会看到println! 打印的内容和失败信息 如果想在成功的测试中看到打印的内容： –show-output 12.8 按名称运行测试运行单个测试： 指定测试名 运行多个测试： 指定测试名的一部分（模块名也可以） 12.9 忽略测试忽略某些测试，运行剩余测试 ignore属性（attribute） 12345678910111213#[cfg(test)]mod tests &#123; #[test] fn it_works()&#123; assert_eq!(4, 2+2); &#125; #[test] #[ignore] // 忽略 expensive_test这个测试 fn expensive_test()&#123; assert_eq!(5, 1+1+1+1+1); &#125;&#125; cargo test – –ignore 单独执行此忽略的测试 12.10 测试的分类Rust对测试的分类 单元测试 集成测试 单元测试 小、专注 一次对一个模块进行隔离的测试 可测试private接口 集成测试： 在库外部，和其它外部代码一样使用你的代码 只能使用public接口 可能在每个测试中使用多个模块 #[cfg(test)] 标注 test 模块上的 #[cfg(test)]标注 只有运行 cargo test 才编译和运行代码 运行cargo build则不会 集成测试在不同的目录，它不需要 #[cfg(test)] 标注 cfg：configuration 告诉rust下面的条目只有在特定的配置选项下才被包含 配置选项test： 由Rust提供，用来编译和运行测试 只有cargo test才会编译代码，包括模块中的helper函数和 #[test]标注的函数 测试私有函数 rust允许测试私有函数 12.11 集成测试在Rust里，集成测试完全位于被测试库的外部 目的：是测试被测试库的多个部分是否能正确在一起工作 集成测试的覆盖率很重要； 13 rustlingsThanks for installing Rustlings! Is this your first time? Don’t worry, Rustlings was made for beginners! We aregoing to teach you a lot of things about Rust, but before we can getstarted, here’s a couple of notes about how Rustlings operates: The central concept behind Rustlings is that you solve exercises. Theseexercises usually have some sort of syntax error in them, which will causethem to fail compliation or testing. Sometimes there’s a logic error insteadof a syntax error. No matter what error, it’s your job to find it and fix it!You’ll know when you fixed it because then, the exercise will compile andRustlings will be able to move on to the next exercise. If you run Rustlings in watch mode (which we recommend), it’ll automaticallystart with the first exercise. Don’t get confused by an error message poppingup as soon as you run Rustlings! This is part of the exercise that you’resupposed to solve, so open the exercise file in an editor and start yourdetective work! If you’re stuck on an exercise, there is a helpful hint you can view by typing‘hint’ (in watch mode), or running rustlings hint myexercise. If an exercise doesn’t make sense to you, feel free to open an issue on GitHub!(https://github.com/rust-lang/rustlings/issues/new). We look at every issue,and sometimes, other learners do too so you can help each other out! Got all that? Great! To get started, run rustlings watch in order to get the firstexercise. Make sure to have your editor open!","categories":[{"name":"rust","slug":"rust","permalink":"http://yoursite.com/categories/rust/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"go1","slug":"go1","date":"2021-03-09T12:15:16.000Z","updated":"2021-06-17T06:19:57.964Z","comments":true,"path":"2021/03/09/go1/","link":"","permalink":"http://yoursite.com/2021/03/09/go1/","excerpt":"","text":"1. 编译型语言Go 语言是一门编译语言 在运行程序之前，GO首先使用编译器把代码编译成机器可以识别的1和0 它会把代码编译成一个可执行文件，在编译的过程中，编译器能捕获一些错误； 解释型语言 python，js等都是使用解释器，随着程序运行，一个语句一个语句进行翻译，但也这意味着bug可能就潜伏在你还没测试过的路径上。这些就是解释型语言； 2. install gogo 代理 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 1234567/usr/local/go # go环境 编译器路径$&gt; cd go/bin &amp;&amp; ls$&gt; go # go语言编译环境 # 需要将这个路径配置到环境变量中 /usr/local/go/bin/go$&gt; gofmt$&gt; vim ~/.bashrc#编辑之后$&gt; source ~/.bashrc 1234# 设置go语言路径export GOROOT=/usr/local/go # 源码包所在路径export GOPATH=$HOME/go # go开发者 go的项目默认路径export PATH=$PATH:$GOROOT/bin:$GOPATH/bin 12$&gt; go env # 查看配置export GO111MODULE=on # 修改go env 3. const var常量与变量 1234567var ( a = 1 b = 2)var distance, speed = 56, 108const hours, minutes = 24, 60 3.1 短声明12345678910111213141516171819202122232425262728// 以下两种声明效果一样var count = 10count:= 10// 短声明可以在无法使用var的地方使用var count = 0for count= 10; count&gt;0; count-- &#123; fmt.Println(count)&#125;for count:=10; count&gt;0; count-- &#123; fmt.Println(count)&#125;if num:=rand.Intn(3);num==0 &#123; &#125; else &#123; &#125;switch num:=rand.Intn(10); num&#123; case 1: fmt.Printls(\"1\") case 2,3: fmt.Printls(\"2\") default: ..&#125; 短声明不能用来声明 package作用域的变量 era变量在main函数外声明的 它拥有package作用域 如果main package有多个函数，那么era对它们都可见 package作用域的变量不能用短声明 12345678package mainimport ( \"math/rand\")var era = \"AD\"func main()&#123; year := 2018&#125; 4. 运算符12345// 以下3个等价age = age + 1age += 1age++++age // error 4.1 逻辑运算符|| 或 &amp;&amp; 与 ！ 可以把true 变为 false，反之亦然 5. 包引用多个包 1234567891011121314package mainimport ( \"fmt\" \"math/rand\")func main() &#123; var number = rand.Intn(10) + 1 fmt.Println(number) number = rand.Intn(10) + 1 fmt.Println(number)&#125; 5.1 包路径管理把项目建在 GOPATH的src目录下； 1234567891011package mainimport ( \"golangStudy/00module/lib1\" // 路径需要写全 ，此路径针基于 gopath下的src 往下查找的 \"golangStudy/00module/lib2\")func main() &#123; lib1.Lib1Test1() lib2.Lib2Test2()&#125; 5.2 匿名导包1import \"_lib1\" // 添加下划线，某个场景只需要执行该包 init方法的时候 5.3 取别名1import mylib2 \"lib2\" 5.4 Go modulesGo modules 是go语言的依赖解决方案，发布于Go1.11， 成长于Go1.12，正式于Go1.14 推荐在生产上使用 Go modules解决Go1.11 前的几个常见争议问题 GO语言长久以来的依赖管理问题 淘汰 现有的GOPATH的使用模式 统一社区中的其它的依赖管理工具（提供迁移功能） GOPATH的工作模式 Go modules的目的之一就是淘汰GOPATH； 123$&gt; go env$&gt; GOPATH=Users/xxx/go$&gt; cd $GOPATH GOPATH的弊端 无版本控制概念， go get -u github.com/xxx/xxx 无法指定版本 无法同步一致第三方版本号 无法指定当前项目引用的第三方版本号 5.4.1 Go mod 命令12345678go mode init # 生成 go.modgo mode download # 下载go.mod 文件中指明的所有依赖go mode tidy # 整理现有的依赖go mode graph # 查看现有的依赖结构go mode edit # 编辑 go.mod 文件go mode vendor # 导出项目所有的依赖到vendorgo mode verify # 校验一个模块是否被篡改过go mode why # 查看为什么需要依赖某模块 5.4.2 Go mod环境变量GO111MODULE go提供 GO111MODULE 作为go modules的开关；其允许设置以下参数 auto 只要项目包含了go.mod文件的话启用Go modules， on 启用Go modules，推荐设置 off 禁用Go modules，不推荐设置 12# 设置 GO111MODULEgo env -w GO111MODULE=\"on\" GOPROXY 这个环境变量主要是用于设置Go模块代理（Go module proxy），其作用是用于使Go在后续拉取模块版本时直接通过镜像站点来快速拉取 代理 阿里云 https://mirrors.aliyun.com/goproxy 七牛云 https://goproxy.io,direct GOSUMDB 它的值是一个Go checksum database， 用于在拉取模块版本时，保证拉去的模块版本数据未经过篡改，若发现不一致，将会立即中止； GOPARVATE 私有仓库，设置了GOPARVATE的话，就不再需要去GOPROXY上去下载，也不需要从GOSUMDB上去校验了 go env -w GOPRIVATE=&quot;*.example.com&quot; 5.4.3 go mod 初始化项任意文件夹创建一个项目（不要求在 $GOPATH/src） 123$&gt; mkdir modules_test$&gt; cd modules_test &amp;&amp; go mod init github.com/orgs/TenonMortise/modules_test$&gt; go get github.com/go-sql-driver/mysql 1234567package mainimport ( _github.com/go-sql-driver/mysql)func main()&#123; &#125; Go mod模式中 包都下载到了 $GOPATH/pkg 中 在该项目编写源代码 123import ( \"github.com/go-sql-driver/mysql\") 12# 手动下载go get github.com/go-sql-driver/mysql go.sum 作用： 罗列当前项目直接或间接的依赖所有模块版本，保证今后项目以来的版本不会被覆盖 h1:hash 表示整体项目的zip文件打开之后的全部文件的校验和生成的hash， 如果不存在，可能表示依赖的库可能用不上； xxx/go.mod h1:hash. Go.mod文件做的hash 5.4.4 修改项目模块的版本依赖关系1$&gt; go mod edit -replace=zinx@v0.0.0-xxx=zin@v1.0.0-xxx 12# go.mod 会多一行replace语句replace zin -replace=zinx@v0.0.0-xxx=&gt;zin@v1.0.0-xxx 6 循环 分支6.1 Boolean类型true 和false go中，” “ 空串不会自动转为false 6.2 strings.Contains来自strings包的Contains函数可以判断某个字符串是否包含另外要给字符串 12345678910111213package mainimport ( \"fmt\" \"strings\")func main() &#123; fmt.Println(\"you find yourself in a dimlu lit cavern\") var command = \"walk outside\" var exit = strings.Contains(command, \"outside\") fmt.Println(\"you leave the cave: \", exit)&#125; 6.3 compare如果比较两个值，得到的结果也是 true 或false 比较运算符： == &lt;= &lt; != &gt;= &gt; 6.4 if判断条件不加括号 1234567if command == \"alex\" &#123; &#125; else if command == \"let\" &#123; &#125; else &#123; &#125; 6.6 swtch条件不加括号，不需要break关键字 还有一个fallthrough关键字，它用来执行下一个case的body部分。 123456789101112131415161718192021var command = \"alex\"switch command &#123; case \"gi\": .. case \"go\",\"run\": .. default: ..&#125;var room = \"cave\"switch room &#123; case \"cave\": fmt.Printls(\"1\") fallthrough case \"go\",\"run\": fmt.Printls(\"2\") default: ..&#125;// 输出 1，2 6.7 循环for关键字让代码重复执行 for后边没有根条件，那就是无限循环 可以使用break跳出循环 遍历数组 123456func main() &#123; numbers := [5]int&#123;1, 2, 3, 4, 5&#125; for i, num := range numbers &#123; fmt.Println(i, num) &#125;&#125; 6.8 变量的作用域当变量被声明以后，它就进入了作用域 只要变量在作用域内，你就可以访问它 否则，访问它会报错的 变量声明的位置，决定了它的作用域 作用域的好处？ 可以在不通的作用域内使用相同的变量名 在Go里面， 作用域的范围就是{}之间的部分 7. 数据类型7.1 声明浮点型变量下面这三个语句的效果是一样的 123days := 365.2425var days = 365.2425var days float64 = 365.2425 只要数字含有小数部分，那么它的类型就是float64 如果你使用一个整数来初始化某个变量，那么你必须指定它的类型为float64，否则它就是一个整数类型 7.2 单精度浮点数类型Go语言有两种浮点数类型 默认是float64 64位的浮点类型 占用8字节内存 某些编程语言把这种类型叫做double（双精度） float32 占用4字节内存 精度比float64低 有时叫做单精度类型 12345var pi64 = math.Pivar pi32 float32 = math.Pifmt.Println(pi64)fmt.Println(pi32) 7.3 单双精度的使用场景 当处理大量数据时，例如3D游戏中的数千个顶点，使用float32牺牲精度来节省内存是很有意义的； math包里面的函数操作的都是float64类型，所以应该首选使用float64，除非你有足够的理由不去使用它； 7.4 零值Go里面每个类型都有一个默认值，称作零值 当你声明却不对它进行初始化的时候，它的值就是零值 1234var price float64fmt.Println(price)price := 0.0 7.5 显示浮点类型 使用Print或Println打印浮点类型的时候，默认的行为是尽可能的多显示几位小数 结合%f格式显示小数的位置 12345third := 1.0/3fmt.Printf(\"%v\\n\", third)fmt.Printf(\"%f\\n\", third)fmt.Printf(\"%.3f\\n\", third)fmt.Printf(\"%4.2f\\n\", third) %4.2f %4 标识宽度 2f 表示precision 宽度： 会显示出的最少字符个数（包括小数点和小数） 如果宽度大于数字的个数，那么左边会填充空格 如果没指定宽度，那么就按实际的位数进行显示 精度： 小数点后边显示的位数 7.6 整数类型12var year int = 2018 // 常用整型var month uint = 2 // 无符号整数类型 7.6.1 int 和 uintint和uint是针对目标设备优化的类型 在old 的移动设备上，int 和 uint都是32位的 比较新的计算机上，int 和 uint都是64位的 虽然在某些设备上int可以看作int32，在某些设备上可以看作是int64，但他们其实是3种不同的类型 int并不是其它类型的别名 tip 如果你在较老的32位设备上，使用了超过20亿的整数，而且代码还能运行，那么最好使用int64 和 uint64 来代替 int和uint 7.6.2 uint8uint8 可以表示8位的颜色（红绿蓝： 0-255） 1var red, green, blue uint8 = 0,141,213 为什么不使用int uint8取值范围正好合适，而int则多出来几十亿不合理的数字 如果很多颜色数据连续存储，例如未被压缩的图片，那么使用uint8可以节省很多内存 7.7 输出数据类型12a:= 1.0fmt.Println(\"%T\", a) 7.8 文本7.8.1 声明字符串123peace := \"peace\"var peace = \"peace\"var peace string = \"peace\" 字符串的零值： 1var blank string 7.9 类型转换连接两个字符串，使用+运算符 1cout:= \"alex\" + \"leo\" // compiler success 如果想连接字符串和数值，是会报错的 1cout:= \"alex\" + 10 + \"leo\" // compiler error 整数和浮点数也不能直接连接 123// 如果想把age转化成浮点类型，需要使用目标类型将其“包裹”起来age := 41marsAge := float(age) 从浮点类型转为整数类型 可以从浮点类型转化为整数类型，小数点后面的部分会被截断，而不是舍入 12earthDays := 365.2425int(earthDays) 8. 函数8.1 函数声明在go里，大写字母开头的函数、变量或其它标识符都会被导出，对其它包可用； 小写字母开头的就不行； 8.2 方法也是一个函数，但是它根某一个类型相关联的； 声明新类型 关键字type可以用来声明新类型： 12type celsius float64var temperature celsius = 20 虽然celsius 是一种全新的类型，但是由于它和float64具有相同的行为和表示，所以赋值操作能顺利执行； 例如加法等运算，也可以像float64那样使用； 8.2.1 通过方法添加行为在C#、java里，方法属于类 在Go里，它提供了方法，但是没提供类和对象 go比其它语言的方法要灵活 可以将方法与同包中声明的任何类型相关联、但不可以是int、float64等预声明的类型进行关联； 12345678910111213141516171819202122232425262728func main()&#123; // 两种类型不能混用，哪怕底层指向的是同一类型 type celsius float64 type kelvin float64 var w float64 = 10 var k kelvin = 20 k+=w // compiler error&#125;type Point struct &#123; X float64 y float64&#125;// p为接收者， 类似this 的作用func (p Point) distance(q Point) bool &#123; return q.y &gt; p.y &amp;&amp; q.X &gt; p.X&#125;func main() &#123; var point = Point&#123;3.12, 3.14&#125; var point1 = Point&#123;4.10, 3.12&#125; fmt.Println(point.y) fmt.Println(point.distance(point1))&#125; 在每个方法可以有多个参数，但只能有一个接收者 在方法体中，接收者的行为和其它参数一样； 8.2.2 方法调用变量.方法() 123456789101112131415type Point struct &#123; X float64 y float64&#125;// p为接收者， 类似this 的作用func (p Point) distance(q Point) bool &#123; return q.y &gt; p.y &amp;&amp; q.X &gt; p.X&#125;func main() &#123; var point = Point&#123;3.12, 3.14&#125; var point1 = Point&#123;4.10, 3.12&#125; fmt.Println(point.distance(point1)) // 变量.方法()&#125; 8.3 一等函数在go里，函数是头等的，它可以用在整数、字符串或其它类型能用的地方； 将函数赋给变量 将函数作为函数的返回类型 1234567891011121314type kelvin float64func fakeSensor () kelvin &#123; ...&#125;func realSensor () kelvin &#123; ...&#125;func main()&#123; sensor:= fakeSensor sensor() sensor:= realSensor sensor()&#125; 将函数作为参数传递给函数 1234567891011type kelvin float64func measureTemperature (samples int, sensor func() kelvin) &#123; ...&#125;func fakeSensor () kelvin &#123; ...&#125;func main()&#123; measureTemperature(3, fakeSensor)&#125; 声明函数类型 为函数声明类型有助于精简和明确调用者的代码 12345type sensor func() kelvinfunc measureTemperature (samples int, s func() kelvin)// 可以优化为func measureTemperature (samples int, s sensor ) 闭包和匿名函数 匿名函数就是没有名字的函数，在Go里也称作函数字面值； 1234567891011121314package mainimport \"fmt\"func main()&#123; f := func()&#123; fmt.Println(\"&gt;&gt;.\") &#125; f() &#125;fn main()&#123; func()&#123; fmt.Println(\"&gt;&gt;.\") &#125;()&#125; 因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的； 123456789101112type k float64type sensor func() kfunc realSensor() k &#123;return 0&#125;func calibrate(s sensor, offset k) sensor &#123; return func() kelvin &#123; return s() + offset &#125;&#125;func main()&#123; sensor := calibrate(realSensor, 5) sensor()&#125; 闭包就是由于怒名函数封闭并包围作用域中的变量而得名的； 123456789101112func main() &#123; type k int64 type sersor func() k var f k = 3 ser := func() k &#123; return f &#125; fmt.Println(ser()) // 3 f++ fmt.Println(ser()) // 4&#125; 8.4 多返回值123456789101112131415161718192021func foo2()(int ,int) &#123; return 666, 777&#125;func foo3()(r1 int ,r2 int) &#123; // 有名称的返回值 r1= 666 r2 =777 return&#125;func foo4()(r1 ,r2 int) &#123; // 有名称的返回值 r1= 666 r2 =777 return&#125;func main()&#123; ret1, ret2 := foo2() r1, r2 := foo3() &#125; 9 数组9.1 数组的复制无论数组赋值给新的变量还是将它传递给函数，都会产生一个完整的数组副本 123456789func main() &#123; plants := [...]string&#123;\"a\", \"b\", \"c\"&#125; clones := plants plants[0] = \"alex\" fmt.Println(plants) fmt.Println(clones) // [alex b c] // [a b c]&#125; 数组也是一种值，函数通过值传递来接收参数，所以数组作为函数的参数就非常低效 123456789101112131415func clonefunc(p [3]string) [3]string &#123; for i := range p &#123; p[i] = \"pruffix\" + p[i] &#125; return p&#125;func main() &#123; plants := [...]string&#123;\"a\", \"b\", \"c\"&#125; fmt.Println(clonefunc(plants)) fmt.Println(plants) // [pruffixa pruffixb pruffixc] // [a b c]&#125; 数组的长度也是数组类型的一部分 尝试将长度不符的数组作为参数传递，将会报错 函数一般使用slice而不是数组作为参数 10 slice指向数组的窗口 假如p 是一个数组，那么 p[0:4] 就是一个切片，它切分出数组里面前4个元素 切分数组不会导致数组被修改，它只是创建了指向数组的一个窗口或视图，这种视图就是slice类型； 默认索引 [:10] [1:] [:] 切分数组的语法也可以用于切分字符串 切分字符串时，索引代表的是字节数而非 字符串的数； 12que := \"汉字^&amp;COMasf\"fmt.Println(que[:3]) // 汉 10.1 slice的字面值Go里面很多函数都倾向于使用slice而不是数组作为参数 想要获得与底层数组相同元素的slice，那么可以使用[:]进行切分 10.2 声明slice1234// 声明sliced := []string &#123;\"a\",\"b\",\"c\"&#125;// 声明arrayf := [...]string &#123;\"a\", \"c\"&#125; 1234567891011func hyper(worlds []string) &#123; for i := range worlds &#123; worlds[i] = strings.TrimSpace(worlds[i]) &#125;&#125;func main() &#123; planets := []string&#123;\"a \", \" b\", \" c \"&#125; hyper(planets) fmt.Println(planets) // a b c&#125; 10.3 带有方法的切片在go里，可以将slice或数组作为底层类型，然后绑定其它方法 1234567891011type StringSlice []stringfunc (p StringSlice) Sort() &#123;&#125;func main() &#123; planets := []string&#123; \"Mer\", \"Ven\", \"Ear\", &#125; sort.StringSlice(planets).Sort() fmt.Println(planets) // [Ear Mer Ven]&#125; 10.4 append函数append函数也是内置函数，它可以将元素添加到slice里面 123456planets := []string&#123; \"Mer\", \"Ven\", \"Ear\",&#125;sort.StringSlice(planets).Sort()planets = append(planets, \"Xyy\")fmt.Println(planets) // [Ear Mer Ven Xyy] 思考一个问题 当直接声明planets := []string{&quot;Mer&quot;, &quot;Ven&quot;, &quot;Ear&quot;,}的时候，会创建一个数组。该数组有3个元素。后面append又给 planets添加了1个元素。因为声明的数组是定长，那么append的这个元素被添加到哪里了呢？ 10.5 长度和容量 长度就是切片里有多少个元素， 容量就是指切片对应的底层数组，底层数组的容量是多少，那么切片的容量就是多少 slice中元素的个数决定slice的长度 如果slice底层数组比slice还大，那么就说该slice还有容量可供增长 获取切片的长度 len(slice) 获取切片的容量 cap(slice) 12345678910111213func dump(label string, slice []string) &#123; fmt.Printf(\"%v: length %v, cap %v \\n\", label, len(slice), cap(slice))&#125;func main() &#123; planets := []string&#123; \"Mer\", \"Ven\", \"Ear\", \"Xyy\", \"Z@@\", &#125; dump(\"planets\", planets) dump(\"planets[1:2]\", planets[1:2])&#125;// planets: length 5, cap 5 // planets[1:2]: length 1, cap 4 当往一个切片append元素的时候，要看一下底层数组的长度够不够，如果不够的话，新声明一个长度为当前数组长度两倍长度的数组，然后将老数组的值依次复制到新数组里面，再追加append的元素。如果够的话，直接追加不创建新数组； planets[1:2] cap为何是 4 ？ 10.6 三个索引的切分操作Go1.2 引入了能够限制新建切片容量的三索引切分操作 123456func main() &#123; planets := []string&#123; \"Mer\", \"Ven\", \"Ear\", \"Xyy\", \"Z@@\", &#125; ter := planets[0:4:4] // 第三个指定切片容量为4&#125; 10.7 使用make函数对slice进行预分配当slice的容量不足以执行append操作时，Go必须创建新数组并复制旧数组中的内容 但通过内置的make函数，可以对slice进行预分配策略 尽量避免额外的内存分配和数组复制操作 123456789101112func dump(label string, slice []string) &#123; fmt.Printf(\"%v: length %v, cap %v \\n\", label, len(slice), cap(slice))&#125;func main() &#123; planets := make([]string, 0, 10) // 设置 长度 容量 dump(\"aa\", planets) // aa: length 0, cap 10 planets = append(planets, \"Mer\", \"Ven\", \"Ear\", \"Xyy\", \"Z@@\", ) dump(\"bb\", planets) // bb: length 5, cap 10&#125; 10.8 声明可变参数的函数声明Printf append 这样的可变参数函数，需要在函数的最后一个参数前面加上 … 符号； 123456789101112131415161718192021// ...string 行参// planets... 实参func terraform(prefix string, worlds ...string) []string &#123; newWorlds := make([]string, len(worlds)) for i := range worlds &#123; newWorlds[i] = prefix + \" \" + worlds[i] &#125; return newWorlds&#125;func main() &#123; twoWorlds := terraform(\"New\", \"Venus\", \"Mars\") fmt.Println(twoWorlds) // [New Venus New Mars] planets := []string&#123;\"Venus\", \"Mars\", \"Jupiter\"&#125; newPlanets := terraform(\"New\", planets...) fmt.Println(newPlanets) // [New Venus New Mars New Jupiter]&#125; 11. map11.1 声明map[string]int 1234temperature := map[string]int &#123; \"E\": 15, \"M\": -65&#125; 11.2 map不会被复制数组，int 等类型在赋值给新变量或传递至函数/方法的时候会创建相应的副本 map不会, 123456789101112131415func main() &#123; planets := map[string]string&#123; \"E\": \"Sector zz9\", \"Mars\": \"Sector zz9\", &#125; planetsMark := planets planets[\"Earth\"] = \"whoops\" fmt.Println(planets) // map[E:Sector zz9 Earth:whoops Mars:Sector zz9] fmt.Println(planetsMark) // map[E:Sector zz9 Earth:whoops Mars:Sector zz9] delete(planets, \"Earth\") fmt.Println(planetsMark) // map[E:Sector zz9 Mars:Sector zz9]&#125; 11.3 使用make对map进行预分配1temperature := make(map[float64]int, 8) 创建map时，make函数可以接受一个或者两个参数 第二个参数用于为指定数量的key预先分配空间 使用make函数创建的map初始长度为0 123456789101112131415func main() &#123; temperatures := []float64&#123; -28.0, 32.0, -31.0, -29.0, -23.0, -29.0, -28.0, -33.0, &#125; frequency := make(map[float64]int) // key 为float64 value为int for _, t := range temperatures &#123; frequency[t]++ &#125; for t, num := range frequency &#123; fmt.Printf(\"%+.2f occurs %d times\\n\", t, num) &#125;&#125; 12. structstruct允许将不同的类型的东西组合在一起 12.1 声明123type location struct &#123; lat, long float64&#125; 12.2 将struct编码为JSONjson包的Marshal函数可以将struct中的数据转化为JSON格式 1234567891011121314151617func main() &#123; type location struct &#123; Lat, Long float64 &#125; curiosity := location&#123;-4.12, 123.23&#125; bytes, err := json.Marshal(curiosity) exitOnError(err) fmt.Println(string(bytes)) // &#123;\"Lat\":-4.12,\"Long\":123.23&#125;&#125;func exitOnError(err error) &#123; if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 12.3 使用struct标签来自定义JSONgo语言中的json包要求struct中的字段必须以大写字母开头，类似驼峰命名； 但有时候需要snake_case蛇形命名规范，那么该怎么办？ 可以为字段标注标签，使得json包在进行编码的时候能够按照标签里的样式修改字段名 123456789101112131415161718func main() &#123; type location struct &#123; Lat float64 `json:\"latitude\"xml:\"latitude\"` Long float64 `json:\"longitude\"` &#125; curiosity := location&#123;-4.12, 123.23&#125; bytes, err := json.Marshal(curiosity) exitOnError(err) fmt.Println(string(bytes)) // &#123;\"latitude\":-4.12,\"longitude\":123.23&#125;&#125;func exitOnError(err error) &#123; if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 12.3.1 结构体标签在json中的应用123456789101112131415161718192021222324252627282930313233package mainimport ( \"encoding/json\" \"fmt\")type Movie struct &#123; Title string `json:\"title\"` // 当前的字段在json中显示的名称是什么 Year int `json:\"year\"` Actors []string `json:\"actors\"`&#125;func main() &#123; movie := Movie&#123;\"alex\", 2000, []string&#123;\"xing\"&#125;&#125; // struct -&gt; json jsonStr, err := json.Marshal(movie) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(\"jsonStr = %s\\n\", jsonStr) // json -&gt; struct movie2 := Movie&#123;&#125; err = json.Unmarshal(jsonStr, &amp;movie2) if err != nil &#123; fmt.Println(err) return &#125;&#125;// jsonStr = &#123;\"title\":\"alex\",\"year\":2000,\"actors\":[\"xing\"]&#125;// struct=&#123;alex 2000 [xing]&#125; 12.4 将方法关联到struct方法可以关联到声明的类型上 1234567type coordinate struct &#123; d,m,s float64 h rune&#125;func (c coordinate) decimal() float64&#123; &#125; 12.4.1 构造函数可以使用struct复合字面值来初始化你所要的数据 但如struct初始化的时候还要做很多事情，那就可以考虑写一个构造用的函数 Go语言没有专用的构造函数，但以new或者New开头的函数，通常是用来构造数据的，例如 newPerson NewPerson 1234567891011121314151617181920212223242526type coordinate struct &#123; d,m,s float64 h rune&#125;func (c coordinate) decimal() float64&#123; sign := 1.0 switch c.h &#123; case 'S', 'W','s','w': sign = -1 &#125; return sign * (c.d + c.m/60 + c.s/3600)&#125;// 构造用的函数,在go中没有专业的构造函数func newLocation(lat, long coordinate) location &#123; return location&#123;lat.decimal(), long.decimal()&#125;&#125;type location struct &#123; lat, long float64&#125;func main()&#123; lat := coordinate&#123;...&#125; long := coordinate&#123;...&#125; curiosity := newLocation(lat, long)&#125; 12.4.2 New函数有一些用于构造的函数的名称就是New （例如errors包里面的New函数） 这是因为函数调用时使用 包名.函数名 的形式 如果该函数叫NewError，那么调用的时候就是errors.NewError()， 这就不如errors.New() 简洁 12.5 class的替代方案Go语言没有class，但使用struct并配备几个方法也可以达到同样的效果 12.6 反射对一个已经的变量作为输入，得出该变量的type 和 value 1234func Valueof(i interface&#123;&#125;) Value// valueof 用来获取输入参数接口中的数据的值，如果接口为空则返回0func Typeof(i interface&#123;&#125;) Type&#123;...&#125;// Typeof 用来动态获取输入参数接口的值的类型，如果接口为空则返回nil 123456func reflectName(num interface&#123;&#125;) &#123; fmt.Println(reflect.TypeOf(num)) fmt.Println(reflect.ValueOf(num)) // float64 // 1.23&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"reflect\")type User struct &#123; id int name string age int&#125;func (this User) Call() int &#123; return 0 &#125;func DoFileAndMethod(input interface&#123;&#125;) &#123; inputType := reflect.TypeOf(input) fmt.Println(\"inputType is:\", inputType.Name()) inputValue := reflect.ValueOf(input) fmt.Println(\"inputValue is:\", inputValue) // 通过type 获取里面的字段 for i := 0; i &lt; inputType.NumField(); i++ &#123; field := inputType.Field(i) value := inputValue.Field(i) fmt.Printf(\"%s: %v = %v\\n\", field.Name, field.Type, value) &#125; // 通过type获取里面的方法 for i := 0; i &lt; inputType.NumMethod(); i++ &#123; m := inputType.Method(i) fmt.Printf(\"%s: %v\\n\", m.Name, m.Type) &#125;&#125;func main() &#123; user := User&#123;1, \"alex\", 18&#125; DoFileAndMethod(user)&#125;// inputType is: User// inputValue is: &#123;1 alex 18&#125;// id: int = 1// name: string = alex// age: int = 18// Call: func(main.User) int 反射结构体标签 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"reflect\")type resume struct &#123; Name string `info:\"name\" doc:\"名字\"` Sex string `info:\"sex\"`&#125;func findTag(str interface&#123;&#125;) &#123; t := reflect.TypeOf(str).Elem() for i := 0; i &lt; t.NumField(); i++ &#123; tagstring := t.Field(i).Tag.Get(\"info\") tagdoc := t.Field(i).Tag.Get(\"doc\") fmt.Println(\"info:\", tagstring, \"doc:\", tagdoc) &#125;&#125;func main() &#123; var re resume findTag(&amp;re) // info: name doc: 名字 // info: sex doc:&#125; 13. 组合和转发13.1 组合在面向对象的世界中，对象由更小的对象组合而成 术语： 对象组合或组合 Go通过结构体视线组合（composition） Go提供了“嵌入”（embedding） 特性，他可以实现方法的转发（forwarding） 组合是一种更简单，灵活的方式 拆分类型 1234567891011121314151617181920212223type report struct &#123; sol int high, low float64 lat, long float64&#125;// 拆分类型type reportNew struct &#123; sol int temperature temperature location location&#125;type temperature struct &#123; high, low celsius&#125;type location struct &#123; lat, long celsius&#125;type celsius float64 duck type 12345678910111213141516171819202122232425262728293031323334package maintype reportNew struct &#123; sol int temperature temperature location location&#125;type temperature struct &#123; high, low celsius&#125;type location struct &#123; lat, long celsius&#125;type celsius float64func (t temperature) averae() celsius &#123; return (t.high + t.low) / 2&#125;// 或者func (r reportNew) averae() celsius &#123; return r.temperature.averae()&#125;func main() &#123; t := temperature&#123;high: 12.4, low: 134.5&#125; loc := location&#123;lat: 22.3, long: 34.9&#125; report := reportNew&#123; sol: 12, temperature: t, location: loc, &#125; t.averae() report.temperature.averae() // duck type&#125; 13.2 转发方法Go可以通过struct嵌入 来实现方法的转发 在struct中只给定字段类型，不给定字段名即可 1234567891011type reportNew struct &#123; sol int temperature temperature // 字段名 类型 location location&#125;type reportNew struct &#123; sol int temperature // struct 嵌入 location // 只有类型，没有字段名&#125; struct的嵌入之后，被嵌入的类型可以直接使用 嵌入类型上的方法了 在struct中，可以转发任意类型 13.3 命名冲突12345678910111213141516171819202122232425262728293031type report struct &#123; sol temperature location&#125;type temperature struct &#123; high, low celsius&#125;type location struct &#123; lat, long celsius&#125;type celsius float64type sol intfunc (s sol) days(s2 sol) int &#123; days := int(s2 - s) if days &lt; 0 &#123; days = -days &#125; return days&#125;func (l location) days(l2 location) int &#123; return 5&#125;func main() &#123; report := report&#123;sol: 15&#125; fmt.Println(report.sol.days(1446)) fmt.Println(report.days(1446)) // error 发生歧义， 编译器不知道该调 location类型还是sol类型下面的days方法&#125; 12345678910111213141516171819func (s sol) days(s2 sol) int &#123; days := int(s2 - s) if days &lt; 0 &#123; days = -days &#125; return days&#125;func (l location) days(l2 location) int &#123; return 5&#125;func (r report) days(s2 sol) int &#123; // 顶级类型，可以调用report.days直接访问 return r.sol.days(s2)&#125;func main() &#123; report := report&#123;sol: 15&#125; fmt.Println(report.sol.days(1446)) fmt.Println(report.days(1446)) // compiler success&#125; 13.4 继承还是组合优先使用对象组合而不是类的继承 对传统的继承不是必须额，所有使用继承解决的问题都可以通过其它方法解决； 14. 接口接口关注于类型可以做什么，而不是存储了什么 接口通过列举类型必须满足的一组方法来进行声明 在Go语言中，不需要显式声明接口； 1234567891011121314151617181920212223// 声明接口变量var t interface &#123; talk() string&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l laser) talk() string &#123; return strings.Repeat(\"pew\", int(l))&#125;func main() &#123; // 多态 t = martian&#123;&#125; // martian 类型实现了talk方法，所以可以直接赋值 fmt.Println(t.talk()) t = laser(3) // laser 类型实现了talk方法，所以可以直接赋值 fmt.Println(t.talk())&#125; 14.1 接口类型为了复用，通常会把接口声明为类型 按约定，接口名称通常以er结尾 123456789101112131415161718192021222324// 声明接口变量type talker interface &#123; talk() string&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l laser) talk() string &#123; return strings.Repeat(\"pew\", int(l))&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;func main() &#123; shout(martian&#123;&#125;) // martian 实现了 talker 类型，可以直接调用 shout(laser(2)) // laser实现了 talker类型，可以直接调用&#125; 接口可以和struct嵌入特性一同使用 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"strings\")// 声明接口变量type talker interface &#123; talk() string&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l laser) talk() string &#123; return strings.Repeat(\"pew\", int(l))&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;type starship struct &#123; laser&#125;func main() &#123; s := starship&#123;laser(3)&#125; // starship 类型包含了laser fmt.Println(s.talk()) // 因为laser实现talk方法，所以 starship可以调用talk方法 shout(s) // starship有talk方法，满足了 talker类型，而talker类型又能作为 shout函数的参数，所以可以将 starship 传入shout方法&#125; 同时使用组合和接口将构成非常强大的设计工具； 14.2 探索接口Go语言的接口都是隐式满足的 Go允许在实现代码的过程中，随时创建新的接口。任何代码都能实现接口。包括已经存在的代码 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"time\")type stardater interface &#123; YearDay() int Hour() int&#125;type sol intfunc (s sol) YearDay() int &#123; return int(s % 668)&#125;func (s sol) Hour() int &#123; return 0&#125;// func stardate(t time.Time) float64 &#123;func stardate(t stardater) float64 &#123; // 既然 stardater实现了 YearDay和Hour，可以更改此类型 doy := float64(t.YearDay()) h := float64(t.Hour()) / 24.0 return 1000 + doy + h&#125;func main() &#123; day := time.Date(2012, 8, 6, 5, 17, 0, 0, time.UTC) fmt.Printf(\"%.1f Has\\n\", stardate(day)) s := sol(1422) fmt.Printf(\"%.1f Happy\\n\", stardate(s)) // 因为sol类型也实现了stardater接口，所以可以传入stardate方法&#125; 14.3 满足接口Go标准库导出了很多只有单个方法的接口； Go通过简单的、通常只有单个方法的接口… 来鼓励组合而不是继承，这些接口在各个组件之间形成了简明易懂的界限 例如在fmt包 声明的Stringer接口 12345678910111213141516type Stringer interface &#123; String() string&#125;type location struct &#123; lat, long float64&#125;func (l location) String() string &#123; return fmt.Sprintf(\"%v, %v\", l.lat, l.long)&#125;func main() &#123; curiosity := location&#123;-4.5895, 137.4417&#125; fmt.Println(curiosity) // location实现了String方法，满足了 Stringer接口。 所以就能被fmt.Println 调用了&#125; 标准库中常用的接口还包括: io.Reader, io.Write, json.Marshaler 15 指针指针是指向另一个变量地址的变量 Go语言的指针同时也强调安全性，不会出现迷途指针（dangling pointers） 15.1 &amp; 和 *变量会将它们的值存储在计算机的RAM里，存储位置就是该变量的内存地址； &amp; ： 获得变量的内存地址 1234func main() &#123; answer := 42 fmt.Println(&amp;answer) // 0xc000014090&#125; &amp; 操作符无法获得字符串/数值/布尔字面值的地址； &amp;42， &amp;”hello” 这些都会导致编译器报错 *操作符与&amp;的作用相反，它用来解引用，提供内存地址指向的值； C语言中的内存地址可以通过 address++ 这样的指针运算进行操作，在Go里面不允许这种不安全的操作 15.2 指针类型指针存储的是内存地址 1234func main() &#123; answer := 42 address := &amp;answer // *int address就是一个指向int类型的指针&#125; 指针类型和其它普通类型一样，出现在所有需要用到类型的地方，如变量声明、函数行参、返回值类型、结构体字段等 将*放在类型前面表示声明指针类型 将*放在变量前面表示解引用操作 15.3 指针就是用来指向的两个指针变量持有相同的内存地址，那么它们就是相等的； 123// 说明下面语句的作用a = *b; // 将b指针解引用，赋值给a，这个是值拷贝*b = 'alex' // b地址解引用，重复赋值 15.4 指向结构的指针与字符串和数值不一样，复合字面量的前面可以放置&amp; 12345678910111213func main() &#123; type person struct &#123; name, superpower string age int &#125; timmy := &amp;person&#123; name: \"alex\", age: 10, &#125; // (*timmy).superpower = \"flying\" // 访问字段时， 解引用不是必须要做的 timmy.superpower = \"flying\" fmt.Printf(\"%+v\\n\", timmy) // &amp;&#123;name:alex superpower:flying age:10&#125;&#125; 访问字段时，对结构体进行解引用并不是必须的； 15.5 指向数组的指针和结构体一样，可以把&amp; 放在数组的复合字面值前面来创建指向数组的指针 数组在执行索引或切片操作时会自动解引用。没有必要写(*array)[0]这种形式 12345func main()&#123; arr := &amp;[3]string&#123;'a','b','c'&#125; arr[0] arr[1:2]&#125; 与C语言不一样，Go里面数组和指针是两种完全独立的类型 slice和map的复合字面值前面也可以放置 &amp;操作符，但是Go并没有为它们提供自动解引用的功能； 15.5.1 修改数组函数通过指针对数组的元素进行修改 12345678910// rune指的是？func reset(board *[8][8]rune) &#123; board[0][0] = 'r'&#125;func main() &#123; var board [8][8]rune reset(&amp;board) fmt.Printf(\"%c\", board[0][0]) // r&#125; 15.5.2 什么情况下应该使用指向数组的指针隐式的指针 Go语言里一些内置的集合类型就在暗中使用指针 map在被赋值或者被作为参数传递的时候不会被复制 map就是一种隐式指针 这种写法就是多此一举： func demo(planets *map[string]string) 应该去掉🌟 map的键值都可以是指针类型 需要将指针指向map的情况并不多见 15.5.3 slice指向数组之前说过slice是指向数组的窗口，实际上slice在指向数组元素的时候也使用了指针； 每个slice内部都会被表示为一个包含3个元素的结构，它们分别指向： 数组的指针 slice的容量 slice的长度 当slice被直接传递至函数或方法时，slice的内部指针就可以对底层数据进行修改 指向slice的显式指针的唯一作用就是修改slice本身： slice的长度、容量以及起始偏移量 123456789101112func reclassify(p *[]string) &#123; *p = (*p)[0:8] // 修改切片本身&#125;func main() &#123; planets := []string&#123; \"m\", \"v\", \"E\", \"MA\", \"ju\", \"sa\", \"ur\", \"ne\", \"pl\", &#125; reclassify(&amp;planets) fmt.Println(planets) // [m v E MA ju sa ur ne]&#125; 15.5.4 指针和接口1234567891011121314151617181920type talker interface &#123; talk() string&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;func main() &#123; shout(martian&#123;&#125;) shout(&amp;martian&#123;&#125;) // NACK NACK // NACK NACK&#125; 无论是martian 还是指向martian的指针，都可以满足talker接口 如果方法使用的指针接收者，那么情况会有所不同； 12345678910111213141516171819202122232425type talker interface &#123; talk() string&#125;func shout(t talker) &#123; louder := strings.ToUpper(t.talk()) fmt.Println(louder)&#125;type martian struct&#123;&#125;func (m martian) talk() string &#123; return \"nack nack\"&#125;type laser intfunc (l *laser) talk() string &#123; return strings.Repeat(\"pew\", int(*l))&#125;func main() &#123; pew := laser(2) shout(&amp;pew) // PEWPEW shout(pew) // compiler error&#125; 15.6 实现修改Go语言的函数和方法都是按值传递参数的，这意味着函数总是操作于被传递参数的副本； 当指针被传递到函数时，函数将接收传入的内存地址的副本，之后函数可以通过解引用内存地址来修改指针指向的值； 1234567891011121314151617181920type person struct &#123; name, superpower string age int&#125;func birthday(p *person) &#123; p.age++&#125;func main() &#123; rebecca := person&#123; name: \"alex\", age: 10, superpower: \"imagination\", &#125; birthday(&amp;rebecca) // 传入的虽然是指针副本，但是指向同一地址 // birthday(rebecca) // 传入的是引用类型副本，等于复制了一个引用类型，性能差 fmt.Printf(\"%+v\\n\", rebecca) // &#123;name:alex superpower:imagination age:11&#125;&#125; 15.7 指针接收者方法的接收者和方法的参数在处理指针方面是很相似的 Go语言在变量通过点标记法进行调用的时候，自动使用&amp;取得变量的内存地址 所以不用写 (&amp;nathan).birthday() 这种形式也可以正常运行 12345678910111213141516171819202122232425type person struct &#123; name, superpower string age int&#125;func (p *person) birthday() &#123; p.age++&#125;func main() &#123; terry := &amp;person&#123; name: \"alex\", age: 15, &#125; terry.birthday() fmt.Printf(\"%+v\\n\", terry) // &amp;&#123;name:alex age:16&#125; nathan := person&#123; name: \"leo\", age: 17, &#125; nathan.birthday() fmt.Printf(\"%+v\\n\", nathan) // &#123;name:leo age:18&#125;&#125; 使用指针作为接收者的策略应该始终如一： 如果一种类型的某些方法需要用到指针作为接收者，就应该为这种类型的所有方法都是用指针作为接收者； 15.8 内部指针Go语言提供了内部指针这种特性 它用于确定结构体中指定字段的内存地址 123456789101112131415161718192021type stats struct &#123; level int endurance, health int&#125;func levelUp(s *stats) &#123; s.level++ s.endurance = 42 + (15 * s.level) s.health = 5 * s.endurance&#125;type character struct &#123; name string stats stats&#125;func main() &#123; player := character&#123;name: \"alex\"&#125; levelUp(&amp;player.stats) // 结构体某个字段的地址 fmt.Printf(\"%+v\\n\", player.stats) // &#123;level:1 endurance:57 health:285&#125;&#125; &amp;操作符不仅可以获得结构体的内存地址，还可以获得结构体中指定字段的内存地址； 15.9 小结应合理使用指针，不要过度使用指针 16. nilnil是一个名字，表示“无” 或“零” Go里面，nil是一个零值 如果一个指针没有明确的指向，那么它的值就是nil 除了指针，nil还是slice、map和接口的零值 Go语言的nil，比以往语言中的null更为友好，并且用的没那么频繁，但是仍需谨慎使用 16.1 nil会导致panic如果指针没有明确的指向，那么程序将无法对其实施的解引用。 尝试解引用一个nil指针将导致程序崩溃 123456789func main() &#123; var nowhere *int fmt.Println(nowhere) // &lt;nil&gt; fmt.Println(*nowhere) // compiler error // 防范代码 if nowhere != nil &#123; fmt.Println(*nowhere) &#125;&#125; 保护方法 123456func (p *person) days ()&#123; if p != nil &#123; return &#125; p.age++&#125; 因为值为nil的接收者和值为nil的参数在行为上并没有区别，所以go语言即使在接收者为nil的情况下，也会继续调用方法； 16.2 nil函数值当变量被声明为函数类型时，它的默认值是nil 1234func main() &#123; var fn func(a, b int) int fmt.Println(fn == nil) // true&#125; 检查函数值是否为nil，并在有需要时提供默认行为 123456789101112func sortStrings(s []string, less func(i, j int) bool) &#123; if less == nil &#123; less = func(i, j int) bool &#123; return s[i] &lt; s[j] &#125; &#125; sort.Slice(s, less)&#125;func main() &#123; food := []string&#123;\"onion\", \"carrot\", \"celery\"&#125; sortStrings(food, nil) fmt.Println(food) // [carrot celery onion]&#125; 16.3 nil slice如果slice 在声明之后没有使用复合字面值或内置的make 函数进行初始化，那么它的值就是nil 幸运的是，range、len、append等内置数都可以正常处理值为nil的slice 12345678910func main() &#123; var soup []string fmt.Println(soup == nil) // true for _, ingredient := range soup &#123; fmt.Println(ingredient) &#125; fmt.Println(len(soup)) // 0 soup = append(soup, \"onion\", \"carrort\", \"celery\") fmt.Println(soup) // [onion carrort celery]&#125; 虽然空slice和值为nil的slice并不相等，但它们通常可以替换使用； 1234567func mirepoix(ingredients []string) []string &#123; return append(ingredients, \"onion\", \"carrot\", \"celery\")&#125;func main() &#123; soup := mirepoix(nil) fmt.Println(soup) // [onion carrort celery]&#125; 16.4 nil map和slice一样，如果map在声明后没有使用复合字面值或内置的make函数进行初始化，那么它的值将会是默认的nil 1234567891011func main() &#123; var soup map[string]int fmt.Println(soup == nil) // true measurement, ok := soup[\"onion\"] // 对值为nil的map读取不会报错 if ok &#123; fmt.Println(measurement) &#125; for ingredient, measurement := range soup &#123; // 对值为nil的 map进行 range操作依然不会报错 fmt.Println(ingredient, measurement) &#125;&#125; 16.5 nil接口声明为接口类型的变量在未被赋值时，它的零值是nil 对于一个未被赋值的接口变量来说，它的接口类型和值都是nil，并且变量本身也等于nil 123456func main() &#123; var v interface&#123;&#125; fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // &lt;nil&gt; &lt;nil&gt; true&#125;// %T 接口类型// %v 值 当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。 1234567func main() &#123; var v interface&#123;&#125; fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // &lt;nil&gt; &lt;nil&gt; true var p *int v = p fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // *int &lt;nil&gt; false&#125; 当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。 在Go中，接口类型的变量只有在类型和值都为nil时才等于nil 即使接口变量的值仍为nil，但只要它的类型不是nil，那么该变量就不等于nil； 1234567func main() &#123; var v interface&#123;&#125; fmt.Printf(\"%T %v %v\\n\", v, v, v == nil) // &lt;nil&gt; &lt;nil&gt; true var p *int v = p fmt.Printf(\"%#v\\n\", v) //(*int)(nil)&#125; 16.6 nil之外的另一个选择123456789101112131415161718192021type number struct &#123; value int valid bool&#125;func newNumber(v int) number &#123; return number&#123;value: v, valid: true&#125;&#125;func (n number) String() string &#123; if !n.valid &#123; return \"not set\" &#125; return fmt.Sprintf(\"%d\", n.value)&#125;func main() &#123; n := newNumber(42) fmt.Println(n) // 42 e := number&#123;&#125; fmt.Println(e) // not set&#125;s 17 处理错误Go语言允许函数和方法同时返回多个值 按照惯例，函数在返回错误时，最后边的返回值应用来表示错误 调用函数后，应立即检查是否发生错误； 如果没有错误发生，那么返回的错误值为nil 1234567891011121314151617import ( \"fmt\" \"io/ioutil\" \"os\")func main() &#123; files, err := ioutil.ReadDir(\".\") // . 表示当前目录 if err != nil &#123; fmt.Println(err) os.Exit(1) &#125; for _, file := range files &#123; fmt.Println(file.Name()) // 00.go &#125;&#125; 注意 当错误发生时候，函数返回的其它值通常就不再可信 17.1 优雅的错误处理减少错误处理代码是一种策略是： 将程序中不会出错的部分和包含潜在错误隐患的部分隔离开来 对于不得不返回错误的代码，应尽力简化相应的错误处理代码 17.2 go的谚语123456789101112131415161718192021222324252627Errors are value， Do not just check erros， handle them gracefully # 除了检查错误，还要优雅的处理它们Do not panicMake the zero value usefulthe bigger the interface, the weaker the abstraction # interface越大，抽象度越差interface &#123;&#125; says nothing # interface&#123;&#125; 相当于什么都没定义，可以表示任意类型Gofmt is style is no one is favorite, yet gofmt is everyone is favorite # gofmt的样式所有人都不喜欢，但gofmt 所有人都喜欢Doc is for usersa litter copying is better than a little dependency # 少许的拷贝要比少许的依赖要好clear is better than clever# 清晰比聪明更好concurrency is not parallelism# 并发并不是并行do not communicate by sharing memory, share memory by communicating# 不要通过共享内存来进行通信,通过通信来共享内存channels orchestrate； mutexes serialize# channels 应该进行编排，mutexes（互斥量）按序列化执行 17.3 文件写入写入文件的时候可能出错： 路径不正确 权限不够 磁盘空间不足 文件写入完毕后，必须被关闭，确保文件被刷到磁盘上，避免资源的泄漏； 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"os\")func proverbs(name string) error &#123; f, err := os.Create(name) if err != nil &#123; return err &#125; // 写入到 f文件内 _, err = fmt.Fprintln(f, \"Errors are values.\") if err != nil &#123; // write error f.Close() return err &#125; _, err = fmt.Fprintln(f, \"Do not just check erros, handle them gracefully\") f.Close() return err&#125;func main() &#123; err := proverbs(\"proverbs.txt\") if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 17.4 内置类型 error内置类型error用来表示错误 18 defer关键字使用defer关键字，Go可以确保所有deferred的动作可以在函数返回前执行； 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"os\")func proverbs(name string) error &#123; f, err := os.Create(name) if err != nil &#123; return err &#125; defer f.Close() // 写入到 f文件内 _, err = fmt.Fprintln(f, \"Errors are values.\") if err != nil &#123; // write error return err &#125; _, err = fmt.Fprintln(f, \"Do not just check erros, handle them gracefully\") return err&#125;func main() &#123; err := proverbs(\"proverbs.txt\") if err != nil &#123; fmt.Println(err) os.Exit(1) &#125;&#125; 可以defer任意的函数和方法 defer并不是专门做错误处理的； defer可以消除必须时刻惦记执行资源释放的负担 18.1 defer的动作什么时候会被执行有创意的错误处理 12345678910111213141516171819202122232425type safeWriter struct &#123; w io.Writer err error&#125;func (sw *safeWriter) writeln(s string) &#123; if sw.err != nil &#123; return &#125; _, sw.err = fmt.Fprintln(sw.w, s)&#125;func proverbs(name string) error &#123; f, err := os.Create(name) if err != nil &#123; return err &#125; defer f.Close() sw := safeWriter&#123;w: f&#125; sw.writeln(\"Errors are values\") sw.writeln(\"Do not juse check errors, handle them gracefully\") sw.writeln(\"do not panic\") return sw.err&#125; 18.2 New errorerros包里有一个构造用New函数，它接收string作为参数用来表示错误信息。该函数返回error类型 123456789101112131415161718192021222324252627282930313233343536373839import ( \"errors\" \"fmt\" \"os\")const rows, columns = 9, 9type Grid [rows][columns]int8func (g *Grid) Set(row, column int, digit int8) error &#123; if !inBounds(row, column) &#123; return errors.New(\"out of bounds\") &#125; g[row][column] = digit return nil&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(10, 0, 5) if err != nil &#123; fmt.Printf(\"An error occurred: %v, \\n\", err) os.Exit(1) // An error occurred: out of bounds, // exit status 1 &#125;&#125; 提示 错误信息应具有信息性 可以把错误信息当作用户界面的一部分，无论对最终用户还是开发者； 18.3 按需返回错误按照惯例，包含错误信息的变量名应以Err开头 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"errors\" \"fmt\" \"os\")const rows, columns = 9, 9type Grid [rows][columns]int8var ( // 按惯例，包含错误信息的变量名应以Err开头 ErrBounds = errors.New(\"out of bounds\") ErrDigit = errors.New(\"invalid digit\"))func (g *Grid) Set(row, column int, digit int8) error &#123; if !inBounds(row, column) &#123; return ErrBounds &#125; g[row][column] = digit return nil&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(0, 0, 15) if err != nil &#123; switch err &#123; case ErrBounds, ErrDigit: fmt.Println(\"Les erreurs de parametres hors limites.\") default: fmt.Println(err) &#125; os.Exit(1) &#125;&#125; errors.New 这个构造函数是使用指针实现的，所以上例中的switch语句比较的是内存地址，而不是错误包含的文字信息 18.4 自定义错误类型error类型是一个内置的接口：任何类型只要实现了返回string的Error()方法就满足了该接口； 可以创建新的错误类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( \"errors\" \"fmt\" \"os\" \"strings\")const rows, columns = 9, 9type Grid [rows][columns]int8var ( ErrBounds = errors.New(\"out of bounds\") ErrDigit = errors.New(\"invalid digit\"))type SudokuError []errorfunc (se SudokuError) Error() string &#123; var s []string for _, err := range se &#123; s = append(s, err.Error()) &#125; return strings.Join(s, \", \")&#125;func (g *Grid) Set(row, column int, digit int8) error &#123; var errs SudokuError if !inBounds(row, column) &#123; errs = append(errs, ErrBounds) &#125; if !validDigit(digit) &#123; errs = append(errs, ErrDigit) &#125; if len(errs) &gt; 0 &#123; return errs &#125; g[row][column] = digit return nil&#125;func validDigit(digit int8) bool &#123; return digit &gt;= 1 &amp;&amp; digit &lt;= 9&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(12, 0, 15) if err != nil &#123; switch err &#123; case ErrBounds, ErrDigit: fmt.Println(\"Les erreurs de parametres hors limites.\") default: fmt.Println(err) &#125; os.Exit(1) &#125;&#125;// out of bounds, invalid digit// exit status 1 按照惯例， 自定义错误类型的名字应以Error结尾 有时候名字就是Error，例如 url.Error 18.5 类型断言上例中，我们可以使用类型断言来访问每一种错误； 使用类型断言，你可以把接口类型转化成底层的具体类型 例如： err.(SudokuError) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( \"errors\" \"fmt\" \"os\" \"strings\")const rows, columns = 9, 9type Grid [rows][columns]int8var ( ErrBounds = errors.New(\"out of bounds\") ErrDigit = errors.New(\"invalid digit\"))type SudokuError []errorfunc (se SudokuError) Error() string &#123; var s []string for _, err := range se &#123; s = append(s, err.Error()) &#125; return strings.Join(s, \", \")&#125;func (g *Grid) Set(row, column int, digit int8) error &#123; var errs SudokuError if !inBounds(row, column) &#123; errs = append(errs, ErrBounds) &#125; if !validDigit(digit) &#123; errs = append(errs, ErrDigit) &#125; if len(errs) &gt; 0 &#123; return errs &#125; g[row][column] = digit return nil&#125;func validDigit(digit int8) bool &#123; return digit &gt;= 1 &amp;&amp; digit &lt;= 9&#125;func inBounds(row, column int) bool &#123; if row &lt; 0 || row &gt;= rows &#123; return false &#125; if column &lt; 0 || column &gt;= columns &#123; return false &#125; return true&#125;func main() &#123; var g Grid err := g.Set(10, 0, 15) if err != nil &#123; // 使用类型错误断言， if errs, ok := err.(SudokuError); ok &#123; fmt.Printf(\"%d error(s) occurred: \\n\", len(errs)) for _, e := range errs &#123; fmt.Printf(\"- %v\\n\", e) &#125; &#125; os.Exit(1) &#125;&#125;// - out of bounds// - invalid digit// exit status 1 如果类型满足多个接口，那么类型断言使它从一个接口类型转化为另一个接口类型 18.6 do not panic（不要恐慌）Go没有异常，它有个类似机制panic 当panic发生，那么程序就会崩溃 18.7 其它语言的异常 vs Go的错误值其它语言的异常在行为和实现上与Go语言的错误值有很大的不同 如果函数抛出异常，并且附近没人捕获它，那么它就会 冒泡 到函数的调用者那里，如果还没有人进行捕获，那么就继续“冒泡”到更上层的调用者。。。直到达到栈（Stack）的顶部（例如main函数） 异常这种错误处理方式可被看作是可选的； 不处理异常，就不需要加入其它代码； 想要处理异常，就需要加入相当数量的专用代码 Go语言中错误值更简单灵活； 忽略错误是有意识的决定，从代码上看也是显而易见的； 18.8 如何panicGo里有一个和其它语言异常类似的机制： panic 实际上，panic很少出现 创建panic 1panic(\"i forgot my towel\") panic的参数可以是任意类型 18.9 错误值、panic、os.Exit通常，更推荐使用错误值，其次才是panic panic比Os.Exit更好： panic后会执行所有defer的动作，而Os.Exit则不会 有时候Go程序会panic而不是返回错误值 12345678package mainfunc main() &#123; var zero int _ = 42 / zero // panic: runtime error: integer divide by zero // exit status 2&#125; 为了防止panic导致程序崩溃，Go提供了recover函数(恢复) defer的动作会在函数返回前执行，即使发生了panic 但如果defer的函数调用了recover，panic就会停止，程序将继续运行； 1234567891011import \"fmt\"func main() &#123; defer func() &#123; // defer会在函数返回前执行，即使发生panic if e := recover(); e != nil &#123;// defer调用recover，panic就会停止，程序将继续执行 fmt.Println(e) &#125; &#125;() panic(\"i forgot my towel\") // i forgot my towel&#125; 19. docHttps://pkg.go.dev https://golang.org Effective go 20 Error20.1 Error vs exception1234567891011121314151617package errors// New returns an error that formats as the given text.// Each call to New returns a distinct error value even if the text is identical.func New(text string) error &#123; // New 返回的是 内部 errorString对象的指针； return &amp;errorString&#123;text&#125;&#125;// errorString is a trivial implementation of error.type errorString struct &#123; s string&#125;func (e *errorString) Error() string &#123; return e.s&#125; Go error就是一个普通的接口，普通的值 基础库中大量自定义的error 1var ErrInvalidUnreadByte = errors.New(\"bufio:invalid use UnreadByte\") New函数为什么返回 &amp;errorString 返回地址的好处就是，假如两个error的文本内容完全一致，它也不会相等； 12345678910111213141516171819202122type errorString stringfunc (e errorString) Error() string&#123; return string(e)&#125;func New(text string)error&#123; return errorString(text)&#125;var ErrNamedType = New(\"EOF\")var ErrStructType = errors.New(\"EOF\")func main() &#123; if ErrNamedType == New(\"EOF\") &#123; fmt.Println(\"Named Type Error\") // 输出了这里，因为底层都是string &#125; if ErrStructType == errors.New(\"EOF\") &#123; fmt.Println(\"struct type Error\") // 不输出，因为底层是true &#125;&#125; 20.1.1 exceptionGo的处理异常逻辑是不引入exception，支持多参数返回，所以很容易在函数签名中带上实现了error interface的对象，交由调用者来判定； 如果一个函数返回了(value error)，不能对这个value做任何假设，必须先判定error，唯一可以忽略error的是，如果你连value也不关心 当我们抛出异常的时候，相当于你把exception扔给了调用者来处理。比如C++中，把string转为int，如果转换失败，会抛出异常； Go panic 意味着fatal error （“就是挂了”），不能假设调用者来解决 panic，意味着代码不能继续运行； 使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了panic； 如果出现了panic，不能假定调用者来解决这个panic，或者recover这个错误，然后让这个代码的逻辑继续进行，因为可能逻辑不完整。 Request-Driven 123456789101112func Recovery() HandlerFunc()&#123; return func(c *Context) &#123; defer func()&#123; var rawReq []byte if err := recover(); err != nil &#123; ... c.AbortWithStatus(500) //直接服务端异常，不做现场恢复； &#125; &#125;() c.Next() &#125;&#125; 在请求中的野生的goroutine是 recover不住的； 12345678910111213141516171819func main()&#123; fmt.Println(\"goland go\") Go(func()&#123; fmt.Println(\"hello\") panic(\"一路向西\") &#125;) time.Sleep(5*time.Second)&#125;func Go(x func()) &#123; go func() &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(err) &#125; &#125;() x() &#125;()&#125; goland gohello一路向西 20.1.2 什么panic不处理 main函数里面有些代码是强依赖的,如果初始化不成功 只能panic 配置文件写的值不对； 什么是强依赖，什么是弱依赖 代码做DAO的初始化，如果DAO的数据库能连不上，redis cache能连上。这个时候代码该不该启动呢？ 这个示例就相当如果缓存击穿，读库的话 一定会报错； 读多写少的话，是不是先提供读请求出去呢？ DAO层查一个记录查不到，请问是返回一个空指针，还是返回一个error比较好 1234567891011121314151617181920212223242526func Positive(n int)(bool, error) &#123; if n == 0 &#123; return false, errors.New(\"undefined\") // 返回一个error类型更优雅 &#125; return n &gt; -1, nil&#125;func Check(n int)&#123; pos, err := Positive(n) if err != nil &#123; fmt.Println(n,err) return &#125; if pos &#123; fmt.Println(n,\"is positive\") &#125; else &#123; fmt.Println(n,\"is negative\") &#125;&#125;func main()&#123; Check(1) Check(0) Check(-1)&#125; 对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界，不可恢复的问题，栈溢出，我们才使用panic，对于其他的错误情况，我们应该是期望使用 errors来进行判断 error模型的好处； 简单 go的编程模型是考虑失败，而不是成功（plan for failure， not success） 没有隐藏的控制流（哪层的异常，哪里catch） 完全交给你来控制error Error are values（不会像exception那样固定死类型，给予开发者更多可以diy的） 20.2 Error Type20.2.1 Sentinel Error预定义的特定错误， 1var EOF = errors.New(\"EOF\") // 包级别的变量 虽然标准库中有大量EOF这种包变量的写法，但并不建议在项目中大量使用； 但是，在定义业务的错误码的时候，使用这种方式也不失为一种方案； 20.2.2 Error types不推荐使用 20.2.3 Opaque errors 非透明的。 （推荐使用） 123456789import \"github.com/quux/bar\"func fn() error&#123; x,err:= bar.Foo() if err != nil &#123; return err &#125; // use x&#125; 不透明错误处理的全部功能——只需返回错误而不假设其内容； 断言错误实现了特定的行为，而不是断言错误是特定的类型或值； 12345678type temporary interface &#123; Temporary() bool&#125;func IsTemporary(err error) bool &#123; te, ok := err.(temporary) // 在内部断言； return ok &amp;&amp; te.Temporary()&#125; 20.3 Handling Error 如何优雅的写error代码 缩进，无错误的正常流程代码，将成为一条直线，而不是缩进的代码 12345678910111213f, err := os.Open(path)if err != nil &#123; // handle error&#125;// do stuff// 正常逻辑在非缩进里面写；f, err := os.Open(path)if err == nil &#123; // do stuff // 会陷入无限缩进的坑&#125;// handle error 123456789101112// 不推荐的写法func AuthenticateRequest(r *Request) error &#123; err := authenticate(r.User) if err != nil &#123; return err &#125; return nil&#125;// 推荐的写法func AuthenticateRequest(r *Request) error &#123; return authenticate(r.User) // 返回的类型和 函数签名的返回值是match的，直接返回即可&#125; 1234567891011121314151617181920212223242526272829303132// 坏的实践func CountLines(r io.Reader)(int, error) &#123; var ( br = bufio.NewReader(r) lines int err error ) for &#123; _, err = br.ReadString('\\n') lines++ if err != nil &#123; break &#125; &#125; if err != io.EOF &#123; return 0, nil &#125; return lines, nil&#125;// 改进版本func CountLines1(r io.Reader)(int, error) &#123; sc:= bufio.NewScanner(r) // 扫描器 lines := 0 for sc.Scan() &#123; lines++ &#125; return lines, sc.Err() // 将错误信息直接写入src.Err中&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 啰嗦的 err处理package mainimport ( \"fmt\" \"io\")type Header struct &#123; Key, Value string&#125;type Status struct &#123; Code int Reason string&#125;func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123; _, err := fmt.Fprintf(w, \"HTTP/11 %d %s\\r\\n\", st.Code, st.Reason) if err != nil &#123; return err &#125; for _, h:= range headers &#123; _,err := fmt.Fprintf(w, \"%s: %s\\r\\n\", h.Key, h.Value) if err != nil &#123; return err &#125; &#125; if _, err := fmt.Fprintf(w, \"\\r\\n\"); err != nil &#123; return err &#125; if _,err := fmt.Fprintf(w, \"\\r\\n\"); err != nil &#123; return err &#125; _,err = io.Copy(w, body) return err&#125; 1234567891011121314151617181920212223242526// 好的实现type errWriter struct &#123; io.Writer err error&#125;func (e *errWriter) Write (buf []byte) (int, error) &#123; if e.err != nil &#123; // 等下次调用的时候，如果e.err有报错，直接返回 return 0, e.err &#125; var n int n, e.err = e.Writer.Write(buf) // 先将报错信息 保存在e.err中 return n, nil&#125;func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123; ew := &amp;errWriter&#123;Writer:w&#125; fmt.Fprintf(ew, \"HTTP/11 %d %s\\r\\n\", st.Code, st.Reason) for _,h:= range headers&#123; fmt.Fprintf(ew, \"%s:%s\\r\\n\", h.Key, h.Value) &#125; fmt.Fprintf(ew, \"\\r\\n\") io.Copy(ew,body) return ew.err // 最终返回 累计写入到 err的错误；&#125; 20.3.1 Wrap erros123func AuthenticateRequest(r *Request) error &#123; return authenticate(r.User) &#125; 如果authenticate返回错误，则AuthenticateRequest 会将错误返回给调用方，调用者可能也会这样做。依此类推，在程序的顶部，输出的错误会是“没有这样的文件或目录” 第一次改进 1234567func AuthenticateRequest(r *Request) error &#123; err := authenticate(r.User) if err != nil &#123; return fmt.Errorf(\"authenticate failed: %v\", err) &#125; return nil&#125; 这种解决的问题在于，没有生成错误的file:line 信息，没有导致错误的调用堆栈的堆栈跟踪。 还有一个坑就是，这种模式与sentinel erros或type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始错误，导致等值判定失败； 处理error的依据 You should only handle errors once, Handling an error means. Inspecting the error value, and making a single decision; 123456789101112131415161718192021222324252627func WriteAll(w io.Writer, buf []byte)error &#123; _, err := w.Write(buf) if err != nil &#123; log.Println(\"unable to write:\", err) // 因此在此return了 err return err // 如果这里不err会发生什么呢？ // Go的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做任何假设； // 由于JSON序列化失败，buf内容是未知的，可能它不包含任何内容，也可能包含一个半写的JSON片段； &#125; return nil&#125;func WriteConfig(w io.Writer, conf *Config) error &#123; buf, err := json.Marshal(conf) if err != nil &#123; log.Printf(\"could not marshal config: %v\", err) return err &#125; if err := WriteAll(w, buf); err != nil &#123; // 因为WriteAll函数内部已经log了错误，这里属于重复log log.Printf(\"could not write config: %v\", err) return err &#125; return nil&#125; 那日志到底怎么打？ 日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应该予以质疑，记录的原因是因为某些东西失败了，而日志包含了答案； 错误要被日志记录 应用程序处理错误，保证100%完整性 之后不再报告当前错误 建议使用github.com/pkg/errors 第二次改进 12345678910111213141516171819202122232425262728293031func ReadFile(path string)([]byte, error) &#123; f, err := os.Open(path) if err != nil &#123; return nil, errors.Wrap(err, \"open failed\") // wrap方法会把堆栈信息保存起来； &#125; defer f.Close() buf, err := ioutil.ReadAll(f) if err != nil &#123; return nil, errors.Wrap(err, \"read failed\") &#125; return buf, nil&#125;func ReadConfig()([]byte, error) &#123; home:= os.Getenv(\"HOME\") config, err:= ReadFile(filepath.Join(home, \".settings.xml\")) return config, errors.WithMessage(err, \"could not read config\") //withMessage： 不保存堆栈信息，只附带一些上下文信息；&#125;func main()&#123; _,err:= ReadConfig() if err != nil &#123; // 在最上层打日志； fmt.Printf(\"orginal error: %T %v\\n\", errors.Cause(err), errors.Cause(err)) fmt.Printf(\"stack trace: \\n%+v\\n\", err) os.Exit(1) &#125;&#125; 123456789101112131415orginal error: *fs.PathError open /Users/ruanhan/.settings.xml: no such file or directorystack trace: open /Users/ruanhan/.settings.xml: no such file or directoryopen failedmain.ReadFile /Users/ruanhan/2020/go/error/06.go:14main.ReadConfig /Users/ruanhan/2020/go/error/06.go:28main.main /Users/ruanhan/2020/go/error/06.go:34runtime.main /usr/local/go/src/runtime/proc.go:225runtime.goexit /usr/local/go/src/runtime/asm_amd64.s:1371could not read config github.com/pkg/errorspkg errors的心智负担 在你的应用代码中，使用errors.New或者errors。Errorf返回错误 注意下面的errors都是指的 github.com/pkg/errors这个包 errors.New 和 errors.Errorf 都会将堆栈信息保存了； 12345func parseArgs(args []string)error &#123; if len(args)&lt;3 &#123; return errors.Errorf(\"not enough arguments,expected at lease\") &#125;&#125; 如果调用其他包内的函数（项目中的其他函数，错误来自别人），通常简单的直接返回 123if err != nil &#123; return err // 如果不直接返回，会造成堆栈双倍信息； &#125; 如果和其他库(其他库就是github这种第三方库，或者是公司的基础库，或者是标准库)进行协作，考虑使用errors.Wrap 或者 errors.Wrapf保存堆栈信息。同样适用于和标准库协作的时候。（所以这也解释了第二种情况为何不warp而直接返回的原因，说白就是最底层的这个函数需要warp，底层这个函数一般都是跟数据库，rpc等，只有那个函数返回的需要warp） 1234f, err := os.Open(path)if err != nil &#123; return errors.Wrapf(err, \"failed to open %q\", path)&#125; 直接返回错误，而不是每个错误产生的地方到处到日志 在程序的顶部或者是工作的goroutine顶部（请求入口），使用%+v把堆栈详情记录 1234567func main()&#123; err := app.Run() if err != nil &#123; fmt.Printf(\"FATAL: %+v\\n\",err) os.Exit(1) &#125;&#125; 使用errors.Cause获取root error，再进行和sentinel error判定； 总结 选择wrap error是只有 application 可以选择应用的策略，具有最高可重用性的包只能返回根错误，此机制与Go标准库中使用的相同（kit库的sql.ErrNoRows）(基础库不应该去wrap error) 这是关于函数/方法调用返回每个错误的基本问题，如果函数/方法不打算处理错误，那么用足够的上下文wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句，确定您记录的上下文是足够多还是太多的一个好方法是检查日志并验证它们在开发期间是否为您工作 一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零（比如降级处理中，你返回了降级数据，然后需要return nil) 20.4 Go 1.13 errors20.5 Go 2 Error Inspection20.6 References","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"webpack5_1","slug":"webpack5-1","date":"2021-02-23T06:50:45.000Z","updated":"2021-03-11T04:40:37.230Z","comments":true,"path":"2021/02/23/webpack5-1/","link":"","permalink":"http://yoursite.com/2021/02/23/webpack5-1/","excerpt":"","text":"Webpack5 boilerplate1. Common2.1 initinstall webpack5 1npm install webpack webpack-cli --save-dev --save-exact 2.2 添加changelog2.3 添加CI/CD2.4 项目结构设计12345678|- &#x2F;config 一些配置文件，比如webpack config等|- &#x2F;internals 一些内部脚本，生成模版文件， 执行cleanAndSetup操作等；|- &#x2F;scripts 必要的npm scripts|- package.json|- index.html|- &#x2F;src |- index.ts 2.5 添加 prettier 格式化代码利器，配合vscode全局使用； install 1npm install --save-dev --save-exact prettier init 12echo &#123;&#125;&gt; .prettierrc.jsontouch .prettierignore 12345# .prettierignore # Ignore artifacts:buildcoverage 2.6 babelbabel简述 babel是一个js编译器，主要是将es6+转换为向后兼容的js语法；这样就能运行在旧版本浏览器或者其他低版本的环境中； 利用@Babel/polyfill可以通过Polyfill方式在目标环境中添加缺失的特性； babel能够转换jsx语法；主要用到@babel/preset-react; babel还可以删除类型注释，主要用到@babel/preset-typescript，但是无法做类型检查，类型检查需要Flow/Typescript这类的工具; babel是构建在插件之上的，使用现有的插件可以组成一个转换管道；通过使用或创建一个preset 即可轻松使用一组插件；使用generator-babel-plugin生成一个插件模版； 2.6.1 概念1npm install --save-dev --save-exact @babel/core @babel/cli @babel/preset-env 2.6.1.1 @babel/corebabel 核心功能包含在该模块中； 2.6.1.2 @babel/cli@babel/cli 是一个能够从终端（命令行）使用的工具； babelrc 1234&#123; \"presets\": [], \"plugins\": []&#125; 2.6.1.3 plugins 插件是小型的js程序，用于指导babel如何代码进行转换 现在，babel虽然开箱即用，但是什么动作都不做。类似于const babel = code =&gt; code，将代码解析之后再输出同样的代码，如果想要babel做一些实际的工作，就需要为其添加插件； 例如@babel/plugin-transform-arrow-functions之类的插件能将es6的箭头函数转换成es5的function；但是代码中依然有其他es6属性，比如class。 我们希望对它们也进行转换，不需要一个接一个添加所需要的插件。可以使用一个preset（即一组预先设定的插件） 就像插件一样，可以根据自己所需要的插件组合创建一个 自己的preset并将其分享出去； 插件参数 12345678910111213141516// 不加参数的时候,下面这几种是一致的；&#123; \"plugins\": [\"pluginA\", [\"pluginA\"], [\"pluginA\",&#123;&#125;]]&#125;// 添加参数，请传递一个以参数名作为（key）的对象&#123; \"plugins\": [ [ \"transform-async-to-module-method\", &#123; \"module\": \"bluebird\", \"method\": \"coroutine\" &#125; ] ]&#125; 2.6.1.4 preset （@babel/env） 除了一个一个添加插件，还可以以 preset 的形式启用一组插件，对比plugin来说，preset就是为了让不想自动手动组合插件的开发者提供的，preset可以作为Babel插件的组合； 可以简单把Babel Preset视为Babel Plugin的集合，比如babel-preset-es2015 就包含了所有跟es6转换有关的插件； 1./node_modules/.bin/babel src --out-dir lib --presets=@babel/env preset参数 格式与plugin一致； 官方Preset 1234@babel/preset-env@babel/preset-flow@babel/preset-react@babel/preset-typescript 2.6.1.5 Plugin与Preset执行顺序可以同时使用多个Plugin 和Preset，此时，它们执行顺序非常重要 先执行完所有Plugin，再执行Preset 多个Plugin，按声明次序顺序执行 多个Preset，按照声明次序逆序执行 12345678910&#123; \"plugins\": [ \"transform-react-jsx\", \"transform-async-to-generator\" ], \"presets\": [ \"es2015\", \"es2016\" ]&#125; 执行顺序 transform-react-jsx，transform-async-to-generator，es2016，es2015 2.6.1.6 babel-polyfillbabel默认只转换新的js句法（syntax），不转新的API，类似Proxy，Promise这些。举例来说，ES6在Array对象上新增了Array.from方法，babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill； 从babel7.4.0版本开始，这个软件包已经不推荐使用了，建议使用core-js/stable 和regenerator-runtime/runtime 12import 'core-js/stable'import 'regenerator-runtime/runtime' useBuiltIns 12345678910111213141516&#123; \"presets\": [ [ \"@babel/env\", &#123; \"targets\": &#123; \"edge\": \"17\", \"firefox\": \"60\", \"chrome\": \"67\", \"safari\": \"11.1\" &#125;, \"useBuiltIns\": \"usage\" // 当此参数设置为 \"usage\" 时，就会加载上面所提到的最后一个优化措施，也就是只包含你所需要的 polyfill. &#125; ] ]&#125; 1234Promise.resolve().finally();// 加了 \"useBuiltIns\": \"usage\" 之类转化为require('core-js/modules/es.promise.finally');Promise.resolve().finaly(); Babel将检查你的所有代码，以便查找目标环境中缺失的功能，然后只把必须的polyfill包含进来；如果没加useage，那必须在所有代码之前通过require加载一次完成的polyfill 2.6.1.7 小结使用@babel-cli从终端运行Babel； 利用 @babel/polyfill模拟所有新的js功能，比如Array.from, Promise等； 而@babel-envpreset 只对目标环境（如浏览器）中缺失的功能进行代码转换和加载polyfill； 2.6.2 配置1echo &#123;&#125;&gt;babel.config.json 2.6.2.1 typescript1npm install --save-dev --save-exact @babel/preset-typescript 2.6.2.2 react1npm install --save-dev --save-exact @babel/preset-react 2.7 引入typescriptinstall 1npm install --save-dev --save-exact typescript ts-loader tsconfig.json 1echo &#123;&#125; &gt;tsconfig.json 2.8 引入reactinstall 1npm install react react-dom react-router react-router-dom redux react-saga reselect react-redux immer connected-react-router history --save --save-exact 记得加入@types 1npm install @types/react @types/react-dom --save-dev --save-exact 2.9 载入css相关资源install 1npm install style-loader css-loader less less-loader --save-dev --save-exact 安装PostCSS Preset Env 1npm install --save-dev --save-exact postcss-preset-env postcss postcss-loader MiniCssExtractPlugin 生产模式下运行时使用来提取CSS 1npm install --save-dev --save-exact mini-css-extract-plugin 2.10 解析图片，字体之类的1npm install file-loader --save-dev --save-exact 2.11 HtmlWebpackPlugin1npm install --save-dev --save-exact html-webpack-plugin 2. Devinstall 1npm install --save-dev --save-exact webpack-hot-middleware express webpack-dev-middleware 3. Pro","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"graphics1","slug":"graphics1","date":"2021-02-09T10:24:13.000Z","updated":"2021-02-11T00:00:59.294Z","comments":true,"path":"2021/02/09/graphics1/","link":"","permalink":"http://yoursite.com/2021/02/09/graphics1/","excerpt":"","text":"前置 1. Course Topis（mainly 4 parts） Rasterization （光栅化） Curves and Meshes Ray Tracing （光线追踪） Animation/Simulation （动画/模拟） 1.1 Rasterization光栅化， 把三维空间的几何形体显示在屏幕上。这就是光栅化。 实时的计算机图形学的主要应用，在计算机图形学的范畴内，实时的定义我们认为是每秒钟生成30幅画面或者叫30帧，能达到这个级别就叫实时，否则叫离线； 1.2 Curves and Meshes在图形学中，如何表示一条光滑的曲线。如何表示曲面。 1.3 Ray Tracing （光线追踪）生成真实美观的画面； trade off 取舍","categories":[{"name":"graphics","slug":"graphics","permalink":"http://yoursite.com/categories/graphics/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"liner_Algebra","slug":"liner-Algebra","date":"2021-02-08T13:59:25.000Z","updated":"2021-02-21T10:25:54.752Z","comments":true,"path":"2021/02/08/liner-Algebra/","link":"","permalink":"http://yoursite.com/2021/02/08/liner-Algebra/","excerpt":"","text":"一系列简短可刷的视频，将线性代数中的几何直觉动画化； 即使你能跟上视频的速度，你也需要留点时间给自己思考，学习往往发生在此刻； 1. 向量1.1 含义线性代数中最基础、最根源的组成部分就是向量； 一般来说，有三种看待向量的观点，看似不同却有所关联； 1.1.1 物理专业视角向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向；但是只要以上两个特征相同，你可以自由移动一个向量而保持它不变； 二维向量 处在平面中的巷里那个是二维的； 三维向量 而处在我们所生活的空间中的向量是三维的； 1.1.2 计算机专业视角从计算机专业学生的视角看，向量是有序的数字列表；比如你正在做一些有关房价的分析；而你只关心两个特征： ``房屋面积和价格`。 你可能会用一对数字对每个房屋进行建模；第一个数代表房屋面积，第二个数代表价格； 注意，这里的数字顺序不可颠倒；用行话来讲，你会用二维向量对房屋进行建模；在这里，“向量”只不过是“列表”的一个花哨的说法；之所以这个向量是二维的，是因为这个列表的长度是2； 1.1.3 数学专业视角另一方面，数学家试图去概括这两种观点，大致地说，向量可以是任何东西。只要保证两个向量相加以及数字与向量相乘是有意义的即可； 向量加法和向量数乘贯穿线性代数始终，二者起着很重要的作用 一种思考“向量”的特定方式 现在关注的是它的几何方面，首先需要考虑一个箭头，考虑这个箭头在某个坐标系中，比如x-y平面。并且箭头起点位于原点；这与物理专业学生的看法略有不同。因为在他们眼中，向量可以在空间中自由落脚；但是在线性代数中，向量经常以原点作为起点； 一旦你理解了“向量是空间中的箭头”这种观点，就来看看“向量是有序的数字列表”这种观点； 在直角坐标系中，一个向量的坐标由一对数构成；（-2，3），这对数指导你如何从原点（向量起点）出发到达它的尖端（向量终点） 第一个数告诉你沿着X轴走多远，正数代表向右移动，负数代表向左移动； 第二个数告诉你沿着Y轴走多远；正数代表向上移动，负数代表向下移动； 为了把向量和点区别开，惯用方法是把这对数竖着写，然后用方括号括起来；每一对数给出唯一一个向量； 1.2 向量的和 平移第二个向量，使它的起点与第一个向量的终点重合。然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是它们的和； 顺便一提，这个向量加法的定义差不多是线性代数中唯一允许向量离开原点的情形； 1.2.1 数学角度看向量加法 我们重新编排它们的吮吸，使得我们先完成所有水平运送，再完成所有竖直运动； 所以新向量的坐标就是 (1+3, 2+(-1)); 即(x1+x2,y1+y2),总体来说，在“向量是有序的数字列表”观点里，向量加法就是把对应项相加； 1.3 向量数乘另一个向量基础运算就是向量数乘 1.3.1 缩放比如说你选择数字2，把它与一个给定向量相乘。意味着你把这个向量拉长为原向量的2倍。 如果将向量乘以1/3，就意味着这个向量长度缩短为原来的1/3.如果乘以-1.8，相当于往反方向拉长1.8倍；2,1/3,-1.8,它们用于缩放向量，被称为“标量”实际上自始至终，数字在线性代数中起到的主要作用就是缩放向量；所以，“标量”和“数字”两个词通常在这里可以相互替换； 这种拉伸或压缩，有时又使向量反向的过程被称为“缩放”； 1.3.2 数学角度看向量数乘从数字的角度来看，将一个向量伸长为原来的2倍；对应于将每一个分量分别乘以2； 所以将向量看作一个数字列表时，向量与标量相乘就是将向量中的每个分量与标量相乘； 1.4 向量点乘与叉乘1.5 总结线性代数围绕两种基本运算： 向量加法与向量乘法“究竟是什么意思了”； 为什么数学家只考虑这两种运算，并且又是如何将它们抽象独立出来，不管你选什么代表向量都与之无关； 实际上无论你怎么看待向量都无所谓，或把向量看作空间中的箭头；或者把向量看作数字列表；这种观点又恰好有漂亮的几何意义与之对应。线性代数的效用很少提现在这些观点的其中一个上，而是更多地体现在它能够在这些观点中相互转化； 线性代数为数据分析提供了一条将大量数据列表概念化、可视化的渠道；它让数据样式变得非常明晰，并让你大致了解特定运算的意义； 另一方面，线性代数给物理学家和计算机图形程序员提供了一种语言；让他们通过计算机能处理数字来描述并操纵空间； 2. 线性组合、张成的空间与基2.1 基向量关于向量坐标，还有一种有趣的方式来看待这些坐标，它对线性代数很重要。当你看到一对描述向量的数时，比如（3，-2），可以把它的每个坐标看作一个标量； 在xy坐标系中，有两个非常特别的向量。一个指向正右方，长度为1，通常被称为i 帽或者x方向的单位向量；另一个指向正上方，长度为1。通常被称为j帽 或者y方向的单位向量； 现在想象向量(3,-2)的x坐标是一个标量，它将i帽拉伸为原来的3倍；它将j帽拉伸为原来的2倍；从这个角度去看，这个向量实际上是两个经过缩放的向量的和； “缩放向量并且相加” 这一概念至关重要，i 与 j 是xy坐标系的“基向量”；它们合起来被称为坐标系的基； 这是在说，当你把坐标看作标量时；基向量实际上就是这些标量缩放的对象； 我们根据这两个特殊的基向量构建坐标系时，也浮现了一些有趣而微妙的问题，如果我们选择不同的基向量会怎么样？我们完全可以选择不同的基向量，获得一个合理的新坐标系； 比如说，随便选一个指向右上方的向量（红色），再随便选一个指向右下方的向量（蓝色）。想象一下，通过选择两个标量，分别用于缩放二者的其中一个；然后把它们相加，你能得到不同的结果； 通过改变所选择的标量，你可以得到哪些二维向量？ 答案是，你可以得到所有的二维向量。为什么呢？ 这样一对新的基向量，同样允许我们在一对数和二维向量之间自由转化； 但是这种变换关系与之前用i帽 和 j帽的变换关系完全不同； 每当我们用数字描述向量时，它都依赖于我们正在使用的基两个数乘向量和被称为这两个向量的线性组合。 2.2 向量张成的空间（span）“线性”这个词从哪儿来？这根直线又又什么关系？ 如果固定其中一个标量，让另一个标量自由变化。所产生的向量的终点会描出一条直线；(下面两张图分别为固定向量W缩放V 和 固定V缩放W) 如果你让两个标量同时自由变化，考虑所有可能得到的向量；可能有两种情况； 大部分情况下，对于一对初始向量，你能到达平面中的每一个点；所有二维向量都尽在掌握； 但是也有糟糕的情况，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上； 实际上还有第三种情况： 两个向量都是零向量。那就只能乖乖呆在原点了； 所有可以表示为给定向量线性组合的向量的集合；被称为给定向量张成的空间（span）; 现在用行话重新叙述刚才的内容；对大部分二维向量对来说，它们张成的空间是所有二维向量的集合。 但当共线的时，它们张成的空间就是终点落在一条直线上的向量的集合； 线性代数紧紧围绕向量加法与数乘 两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么？ 现在是时候讨论一下通常我们是如何将向量看作点的； 想象落在一条直接上的一些向量时，你会觉得拥挤。而同时想象所有二维向量填满平面时，你会觉得非常拥挤； 所以为了对抗这种情况，通常我们就用向量的终点代表改向量。而像以往一样，它的起点仍旧位于原点；用这种方法来看，如果你要考虑落在一条直线上的所有向量时，你需要考虑直线本身就行了；类似地，同时考虑所有二维向量时，将每个向量抽象为它的终点；实际上，你就不必考虑所有的箭头了，只需要考虑无限大的二维平面本身即可； 当你只考虑一个向量时，就把它看作箭头。当你考虑多个向量时，就把它们都看作点；前面有提到对大部分二维向量来说，它们张成的空间是整个无限大的二维平面；如果共线，它们张成的空间就是一条直线； 2.2.1 两个三维向量张成的空间是什么样的？如果我们再去考虑三维空间，张成空间这个概念就开始变得有趣了。这两个向量张成的空间就是它们所有可能的线性组合。 这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量张成的空间；或者说，所有终点落在这个平面上的向量的集合是这两个向量张成的空间； 如果再加上第三个向量，那么它们张成的空间又是什么样的呢？ 会有两种情况，如果第三个向量恰好落在前两个向量所张成的平面上。那么它们张成的空间并不会改变，还是被困在这个平面上； 另外一种情况，如果你随机选一个向量，它几乎不可能落在前面两个向量所张成的平面中。这种情况下，由于第三个向量指向不同的方向。当你缩放第三个向量时，它将前两个向量张成的平面沿它的方向来回移动，从而扫过整个空间； 2.3 线性无关与线性相关当有多个向量，并且可以移除其中一个而不减少张成的空间。当这种情况发生时，我们称它们是“线性相关”的；另一种表述方法是其中一个向量，可以表示为其它向量的线性组合，因为这个向量已经落在其它向量张成的空间之中； 另一方面，如果所有向量都给张成的空间增添了新的维度；它们就被称为是“线性无关”的。 2.4 小结“向量空间的一组基是张成该空间的一个线性无关的向量集；” 空间的一组基的严格定义是这样的： 张成该空间的一个线性无关向量的集合，基于目前对“张成” 和 “线性无关” 这两个词的理解。思考一下为什么这个定义合乎情理； 3. 矩阵与线性变换3.1 线性变换 很遗憾， Matrix（矩阵）是什么是说不清的，你必须得自己亲眼看看； “如果要我选出一个主题，它不仅让线性代数的其它内容一目了然，又经常被初次学习线性代数的人忽视，我会选择这个——线性变换的概念以及它和矩阵的关系” 在这期视频中，只会集中讨论这些变换在二维空间中长什么样。以及它们如何与矩阵向量乘法关联。尤其展示一种不用死记硬背的考虑矩阵向量乘法的方法； 首先，先来解析“线性变换”这个术语。“变换”本质上是“函数”的一种花哨的说法，它接收输入内容，并输出对应结果； 特别地，在线性代数的情况下。我么考虑的是接收一个向量并且输出一个向量的变换； 特别的，在线性代数的情况下。我们考虑的是接收一个向量并且输出一个向量的变换； 既然“变换”和“函数”意义相同，为什么还要使用前者而不是后者？因为使用“变换”是在暗示以特定方式来可视化这一输入-输出关系； 一种理解“向量的函数”的方法是使用运动。 如果一个变换接收一个向量并输出一个向量；我们想象这个输入向量移动到输出向量的位置； 接下来，要理解整个变换。我们可以想象每一个输入向量都移动到对应输出向量的位置；同样多个箭头显得很拥挤，只用终点表示该向量，用这种方法考虑所有输入向量都移动到对应输出向量的位置时。我们只用看空间中的所有点移动到其它点的位置； 各种个样对空间的变换所产生的效果是美妙的，任意一个变换可以非常复杂。幸运的是，线性代数限制在一种特殊类型的变换上；这种变换更容易理解，称为线性变换 直观地说，如果一个变换具有以下两条性质，我们就称它是线性的； 一是直线在变换后仍然保持为直线，不能有所弯曲； 二是原点必须保持固定； 举例： 上图变换保持原点不动，乍一看它好像保持直线平直；但实际并非如此，因为只展示了水平和竖直的网格线； 当你看看它对一条对角线的作用时，很明显它不是一个线性变换； 总体来说，你应该把线性变换看作是“保持网格线平行且等距分布”的变换； 3.1.1 如何用数值描述线性变换 当你在通过编程制作动画和视频来教授这一主题，你应该给计算机什么样的计算公式；使得你给它一个向量的坐标，它能给你变换后向量的坐标呢？ 实际结果是，你只需要记录两个基向量i帽和j帽变换后的位置； 比如说，考虑坐标为（-1，2）的向量V。 这个向量就是 -1 与 i帽之积与2与j帽之积的和； 如果运用一些变换，并且跟随这三个向量的运动。网格线保持平行且等距分布的性质有一个重要的推论； 变换后的向量V的位置，是-1与变换后的i帽之积，加上2与变换后的j帽之积； 换句话说，向量V是i帽和j帽的一个特定线性组合，那么变换后的向量V也是变换后i帽和j帽的同样的线性组合；这意味着，你可以只根据变换后的i帽和j帽，就推断出变换后的V； 如上图所示的变换，可以看出i帽落在坐标（1，-2）上。j帽落在x轴上，坐标为（3，0）；也就是说，-1乘以i帽加上2乘以j帽所代表的向量；会落在-1 乘以向量（1，-2）加上2乘以向量（3，0）的位置上；简单运算之后，你就能推断出向量V一定落在向量（5，2）上； 1Transformed V = -1(Transformed i) + 2(Transformed j) 实际上，因为展示出整个变换的样子。完全可以直接读出向量V在变换后落在坐标（5，2）上；但是更炫酷的是，只要记录了变换后的i帽和j帽。我们就可以推断出任意向量在变换之后的位置；完全必须观察变换本身是什么样。 一般情况下，一个向量的坐标是（x，y），变换后这个向量就是x乘以变换后的i帽（1，-2）；加上y乘以变换后的j帽（3，0）。简单运算之后你就知道它落在坐标（1x+3y, -2x+0y）上。运用这个公式，我给你任意一个向量，你都能告诉它在变换后的位置； 以上这些内容是在说，一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标。通常我们将这些坐标包装在一个2*2的格子中，称它为2*2矩阵； 你可以把它的列理解为两个特殊的向量，即变换后的i帽和j帽。如果你有一个描述线性变换的2*2矩阵，以及一个给定向量；你想了解线性变换对这个向量的作用；你只需要取出向量的坐标；将它们分别与矩阵的特定列相乘，然后将结果相加即可；这与“缩放基向量再相加”的思想一致 4. 矩阵乘法与线性变换复合5. 三维空间中的线性变换6. 行列式7. 逆矩阵、列空间与零空间8. 非方阵9. 点积与对偶性10. 叉积的标准介绍11. 以线性变换的眼光看叉积12. 基变换13. 特征向量与特征值14. 抽象向量空间15. 克莱姆法则，几何解释","categories":[{"name":"algebra","slug":"algebra","permalink":"http://yoursite.com/categories/algebra/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"}]},{"title":"cli","slug":"cli","date":"2021-02-07T07:50:09.000Z","updated":"2021-02-20T07:31:56.962Z","comments":true,"path":"2021/02/07/cli/","link":"","permalink":"http://yoursite.com/2021/02/07/cli/","excerpt":"","text":"1. Quick start1.1 创建文件夹12$&gt; mkdir sunmao &amp;&amp; cd sunmao &amp;&amp; npm init -y$&gt; touch sm.js 1.2 设置package.json12345678910111213141516171819202122&#123; \"name\": \"sunmao\", \"bin\": &#123; \"sunmao\": \"sm.js\" // 添加 bin 配置，sumao 命令即 指向 sm.js &#125;, \"version\": \"0.0.1\", \"description\": \"A Iterating scaffolding for react, redux-saga and Typescript\", \"main\": \"main.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/TenonMortise/sunmao\" &#125;, \"author\": \"ruanhan\", \"license\": \"MIT\", \"bugs\": &#123; \"url\": \"https://github.com/TenonMortise/sunmao/issues\" &#125;, \"homepage\": \"https://github.com/TenonMortise/sunmao#readme\"&#125; 1.3 npm link1234// sm.js#!/usr/bin/env nodeconsole.log('hello, sunmao') 123456789$&gt; chmod 755 sm.js$&gt; sudo npm linkup to date in 10.078s/usr/local/bin/sunmao -&gt; /usr/local/lib/node_modules/sunmao/sm.js/usr/local/lib/node_modules/sunmao -&gt; /Users/ruanhan/sunmao$&gt; sunmao$&gt; hello, sunmao 参考文档： npm link 1.4 npm unlink如果你的项目不再需要该模块，可以在项目目录内使用npm unlink命令，删除符号链接。 2. 第三方工具介绍2.1 commander.js可以自动的解析命令和参数，用于处理用户输入的命令。 2.2 download-git-repo,下载并提取 git 仓库，用于下载项目模板。 2.3 inrequire.js通用的命令行用户界面集合，用于和用户进行交互。 2.4 ora下载过程久的话，可以用于显示下载中的动画效果。 2.5 chalk可以给终端的字体加上颜色。 2.6 log-symbols可以在终端上显示出 √ 或 × 等的图标。 2.7 install1npm install commander download-git-repo inquirer ora chalk log-symbols","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"dp","slug":"dp","date":"2021-02-02T02:16:56.000Z","updated":"2021-02-09T10:27:09.525Z","comments":true,"path":"2021/02/02/dp/","link":"","permalink":"http://yoursite.com/2021/02/02/dp/","excerpt":"","text":"1 动态规划题目特点 计数类 有多少种方式走到右下角 有多少种方法选出K个数使得和是sum 求最大最小值（DP最大的一类） 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出K个数使得和是sum 2 dp解题步骤以 Coin Change 为例； 三种硬币，分别面值2元，5元和7元， 没种硬不都有足够多，去书店买本书需要27元。如何用最少的硬币组合正好付清，不需要对方找钱 分析： 这题出现求最少，显然可以使用DP方法来解决 2.1 动态规划组成部分一： 确定状态2.1.1 状态在动态规划中的作用属于定海神针2.1.2 简单来说，解动态规划的时候需要开一个数组，数组的每个元素f[i] 或者 f[i][j]代表什么； 类似于解数学题中，X， Y，Z代表什么；2.1.3 确定状态需要两个意识：2.1.3.1 最后一步 虽然我们不知道最优策略是什么，但是最优策略肯定是K梅硬币a1,a2,…,ak 面值加起来是27； 最后一步指的就是最优策略中的最后一个决策，对应到这一题就是一定会有一枚最后的硬币决策： ak， 那么除了这枚硬币，前面硬币的面值加起来是27-ak； 关键点1： 我们不关心前面的 k-1 枚硬币是怎么拼出27-ak的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道ak 和k， 但是我们确定前面的硬币拼出了 27-ak； 关键点2: 因为是最优策略，所以拼出27-ak的硬币数一定要最少，否则这就不是最优策略了； 解析关键点2： 比如最优策略要用5枚硬币，假设最后一枚是5元面额，那么4枚硬币组成了22元。你不可能用3枚，2枚甚至1枚拼成22元； 浅显的道理，如果用3枚可以拼出来22元的话，那么最优策略要用5枚的假设就不成立； 2.1.3.2 子问题我现在当然想求K，但是想求K的话，需要知道前面k-1等于几。（即最少需要多少枚硬币可以拼出27-ak） 所以，我们的要求就变成了：最少要用多少枚硬币可以拼出27-ak枚硬币； 原问题是最少用多少枚硬币拼出27； 我们将原问题转化成了一个子问题，而且规模更小： 27-ak 那该如何定义状态呢，一旦子问题出来了，状态就直接把相同的汉字copy下来。即最少用多少枚硬币拼出X 为了简化定义，我们设状态 f(x)=最少用多少枚硬币拼出x结合这一题就是f(x)=最少用多少枚硬币拼出27.整个问题就变成，以前求f(27),现在求f(27-ak); 等等，我们还不知道最后那枚硬币ak是多少， 当然最后那枚硬币ak只可能是2，5或者7 如果ak是2的话，f(27)应该是f(27-2)+1（加上最后这一枚硬币2） 如果ak是5的话，f(27)应该是f(27-5)+1（加上最后这一枚硬币5） 如果ak是7的话，f(27)应该是f(27-7)+1（加上最后这一枚硬币7） 除此之外，没有其他的可能了； 因为我们需求最少的硬币数，所以： 1f(27) = min&#123;f(27-2)+1, f(27-5)+1, f(27-7)+1&#125; 2.1.4 递归解法的问题递归做了很多重复计算，效率低下 如何避免？ DP是将计算结果保存下来，并改变计算顺序； 2.2 动态规划组成部分二： 转移方程设状态f[x] = 最少用多少枚硬币拼出X； 对于任意X 2.2.1 f[x] 与 f(x)的区别f[x] ，[] 代表数组下标 f(x) ，（）代表函数调用 2.3 动态规划组成部分三： 初始条件和边界条件f[x]=min{f[x-2]+1, f[x-5]+1, f[x-7]+1} 两个问题 x-2, x-5或者x-7 小于0怎么办？什么时候停下来？ 如果不能拼出Y，就定义f[Y] = 正无穷，例如 f[-1] = f[-2] = … = 正无穷 所以f[1] = min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1； 初始条件： f[0] = 0; 因为初始条件用转移方程是算不出来的。但我又需要它的定义。 根据 f[0] = min{f[-2]+1, f[-5]+1, f[-7]+1} 算，f[0]是正无穷的。而我们明明知道，f[0] 不等于正无穷，而是等于0，所以需要手动制定。有的时候初始条件不需要给很多个，比如f[0], f[1], f[2] 等等是不需要额外多个去定义，定不定义该值取决于能否根据其他预设的值;比如f[1] 是正无穷，f[2] = {f[0]+1, f[-3]+1, f[-5]+1} 是 1， 然后后面的值都能基于此算出来了； 初始条件的实质就是把那些最小的值定义下来，边界情况的实质就是不要数组越界；不管数组往下越界到负数，还是数组往上越界超过了都不行； 2.4 动态规划组成部分四：计算顺序拼出X所需要的最少硬币数： f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1} 初始条件： f[0] = 0 然后计算 f[1], f[2],… , f[27] （对于此题来说，是从小到大来计算，DP大多数情况下都是从小到大，二维的话就是从上到下，从左到右） 计算顺序只有一个原则，那就是当我们计算到f[X]时，f[X-2], f[X-5], f[X-7] 都已经出结果了； 2.5 动态规划计算步骤f[X] = 最少用多少枚硬币拼出X f[X] = 正无穷 表示无法用硬币拼出X 每一步尝试三种硬币，一共27步； 与递归算法相比，没有任何重复计算； 算法时间复杂度（即需要进行的步数）： 27*3 (总面额*多少种硬币) 1234567891011121314151617181920212223242526272829303132333435363738/** * * @param &#123;*&#125; A [2, 5, 7] * @param &#123;*&#125; M 27 */function coinChange(A, M) &#123; // 0 ... n: [n+1] // 0 ... n-1: [n] const f = new Array(M + 1); // number of kind of coins let n = A.length; // initialization f[0] = 0; let i, j; //最少用多少枚硬币 依次拼出 f[1], f[2], ... f[27]，从小到大的顺序 for (i = 1; i &lt;= M; ++i) &#123; // 初始设置为无穷大 f[i] = Number.MAX_VALUE; // last coin A[j] 要拼出i块钱，最后一枚硬币应该是谁（这枚硬币不应该跳出A的范围） // f[i] = min&#123;f[i-A[0]] + 1,..., f[i-A[n-1]]+1&#125;; for (j = 0; j &lt; n; ++j) &#123; if (i &gt;= A[j] &amp;&amp; f[i - A[j]] != Number.MAX_VALUE) &#123; // i - A[j] 可能是负数，所以需要添加判断 // 无穷大不能+1，会越界。所以需要添加校验； f[i] = Math.min(f[i - A[j]] + 1, f[i]); &#125; &#125; &#125; if (f[M] == Number.MAX_VALUE) &#123; // 如果拼不出来，要求返回-1； f[M] = -1; &#125; return f[M];&#125;console.log(coinChange([1, 5, 6], 27)); 2.6 小结求最值型动态规划 动态规划组成部分： 确定状态 最后一步 (最优策略中使用的最后一枚硬币ak) 化成子问题 （最少的硬币拼出更小的面值27-ak） 转移方程 f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1} 初始条件和边界条件 f[0] = 0, 如果不能拼出Y，f[Y]= 正无穷 计算顺序 f[0], f[1], f[2], … 消除冗余，加速计算；","categories":[{"name":"algo","slug":"algo","permalink":"http://yoursite.com/categories/algo/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"webgl01","slug":"webgl01","date":"2021-01-28T02:30:44.000Z","updated":"2021-02-17T08:29:26.395Z","comments":true,"path":"2021/01/28/webgl01/","link":"","permalink":"http://yoursite.com/2021/01/28/webgl01/","excerpt":"","text":"1. 图形系统绘图原理webgl绘图，要深入细节里，根内存、cpu交互，真正控制图形输出的每一个细节； webgl基础概念，GPU， 渲染管线，着色器； 1.1 计算机图形系统一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。 光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。 像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。 帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。 CPU（Central Processing Unit）：中央处理单元，负责逻辑计算。 GPU（Graphics Processing Unit）：图形处理单元，负责图形计算。 1.1.1 绘图通用过程首先，经过CPU处理，成为具有特定结构的几何信息，然后，这些信息会被送到GPU中进行处理。在GPU中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上； 这个过程主要分为两个步骤， 一是对 给定的数据结合绘图的场景进行计算（例如相机，光源，遮挡物体等等）进行计算，最终将图形变为屏幕空间的2D坐标。 二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上，这整个过程是一步一步进行的，前一步的输出就是最后一步的输入，这个过程叫做渲染管线（RenderPipelines） 1.1.2 GPUCPU 和 GPU 都属于处理单元，但是结构不同。 CPU像个大的工业管道，等待处理的任务就像是依次通过这个管道的货物，一条CPU流水线串行处理这些任务的速度，取决于CPU（管道）的处理能力；一个计算机系统会有很多条CPU流水线，任何一个任务 都可以随机通过任意一个流水线，这样计算机就能够并行处理多个任务了，这样一条流水线对应的就是 thread； CPU处理大型任务是足够的，但是处理图像应用就不合适了。处理图像，实际上是处理计算图片上每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成一个简单的任务，而每一个图片应用又是由无数个个像素点组成的，所以，需要在同一时间处理无数个小任务。要处理这么多的小任务，使用更小，更多的处理单元，是一种更好的处理方式，GPU就是这样的处理单元； GPU由大量的小型处理单元构成，它没有CPU那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张800*600大小的图片，GPU也可以保证这48万个像素点分别对应一个小单元，这样就可以同时对每个像素点进行计算了； 2 .helloWorld浏览器提供的webgl API是 OpenGL ES的js绑定版本，它赋予了开发者操作GPU的能力。这一特点也让webGL的绘图方式略微复杂，无法直接调用API控制画笔。大致需要以下几个步骤 2.1 webGL绘图步骤 创建webgl上下文 创建webgl程序 将数据存入缓冲区 将缓冲区数据读取到GPU GPU执行webgl程序，输出结果 2.1.1 创建webgl上下文1const gl = canvas.getContext('webgl'); 2.2.2 创建webgl程序webgl程序是一个webGL Program对象，它是给GPU 最终运行着色器的程序； 首先编写两个着色器；两个着色器分别对应的是 顶点 和图元， webgl是以顶点和图元来描述图形几何信息的；所以顶点和图元是绘图过程中必不可少的。webgl绘制一个图形的过程，一般需要两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，一段叫片元着色器（Fragment Shader）负责处理图形的像素信息； 2.2.2.1 顶点顶点就是几何图形的顶点，三角形有三个顶点，四边形有四个顶点。 2.2.2.2 图元图元是webgl可直接处理的图形单元，由webgl绘图模式决定，有点、线、三角形等；webgl中最小的图元是三角形； webgl支持的图元类型有七种； gl.POINTS(点), gl.LINES(线段), gl.LINE_STRIP(线条), gl.LINE_LOOP(回路), gl.TRIANGLES(三角形), gl.TRIANGLE_STRIP(三角带), gl.TRIANGLE_FAN(三角扇)。 要绘制空心三角形，gl.LINE_STRIP(线条)、gl.LINES(线段)、 gl.LINE_LOOP(回路)都可以实现。 但是gl.LINES(线段)需要写入六个顶点([-1, -1, 0, 1, 0, 1, 1, -1, 1, -1,-1, -1]), gl.LINE_STRIP(线条)也需要写入四个顶点([-1, -1, 0, 1, 1, -1,-1, -1]), 而gl.LINE_LOOP(回路)，只需要是三个顶点([-1, -1, 0, 1, 1, -1])； 2.2.2.3 顶点着色器和片元着色器顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息（如顶点的坐标、法线方向、材质等等，从而改变我们绘制出来的图形的形状或者大小等等； 顶点处理完成之后，webgl就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单讲，就是对指定图元中的像素点着色； webgl从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是生成光栅信息的过程，也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化后的像素信息； 举例 将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。 将图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的； 因为图元是webGL可以直接处理的图形单元，所以其他非图元的圆形最终必须要转换为图元才可以被webGL处理。比如绘制实心四边形，就需要将四边形拆分成两个三角形，再交给webGL分别绘制出来； 1234567891011121314151617181920212223// 顶点着色器// attribute 相当于var const，声明变量的关键字// vec2 变量类型，vec2表示二维向量// position 变量名const vertex = `attribute vec2 position;void main()&#123; gl_PointSize = 1.0; gl_Position = vec4(position, 1.0, 1.0);&#125;`;// 通过gl_Position 设置顶点；// 片元着色器const fragment = `precision mediump float;void main()&#123; gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);&#125;`;// gl_FragColor 是webGL片元着色器内置变量，表示当前像素点颜色。 它是一个用RGBA色值表示的四维向量数据；// 变量类型 vec4 表示四维向量// webGL可以并行地对整个三角形的所有像素点同时运行片元着色器，并行处理是WebGL程序非常重要的概念；不论这个三角形是大是小，有几十个像素点还是上百万个像素点，GPU都是同时处理每个像素点的；也就是说，图形中有多少个像素点，着色器程序在GPU中就会被同时执行多少次； 123456789101112131415161718// 创建顶点着色器对象const vertexShader = gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vertexShader, vertex);gl.compileShader(vertexShader);// 创建片元着色器对象const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fragmentShader, fragment);gl.compileShader(fragmentShader);// 创建webGLProgram 对象const program = gl.createProgram();gl.attachShader(program, vertexShader);gl.attachShader(program, fragmentShader);gl.linkProgram(program);// 启用webGLProgram对象gl.useProgram(program); 2.2.2.4 向片元着色器传递数据（与绘图步骤无关）1234567891011121314151617181920// 顶点着色器attribute vec2 postion;varying vec3 color; // 顶点着色器可通过 varying变量传给片元着色器；void main()&#123; gl_PointSize = 1.0; color = vec3(0.5 + position * 0.5, 0.0); // 将顶点值映射为一个RGB颜色值； gl_Position = vec4(position*0.5, 1.0, 1.0);&#125;// 片元着色器precision mediump float;varying vec3 color;void main()&#123; gl_FragColor = vec4(color, 1.0);&#125;// 将gl_FragColor 的rgb值设为变量color的值；// 这个三角形是一个颜色均匀渐变的三角形，它的三个顶点的色值就是我们通过顶点着色器来设置的。webgl// 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值// 利用线性插值可以让像素点的颜色均匀渐变这一特点，可以绘制更多颜色丰富的图形； 2.2.3 将数据存入缓冲区123456789101112// 定义三角形的顶点const points = new Float32Array([ -1, -1, 0, 1, 1, -1,]);// 将points写入webGL缓冲区const bufferId = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW); 2.2.4 将缓冲区数据读取到GPU123456// 获取顶点着色器中的position变量的地址const vPosition = gl.getAttribLocation(program, 'position');// 给变量设置长度和类型gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);// 激活这个变量gl.enableVertexAttribArray(vPosition); 经过这样处理，在顶点着色器中，定义的points类型数组中对应的值，就能通过变量position读取到了； 2.2.5 GPU执行webgl程序，输出结果12gl.clear(gl.COLOR_BUFFER_BIT);gl.drawArrays(gl.TRIANGLES,0, points.length/2); 3. Math我们要建立一套与各个图形系统无关联的，简单基于向量和矩阵运算的数学体系，用它来描述所有的几何图形信息。 如何建立一套描述几何图形信息的数学体系，以及如何用这个体系来解决可视化图形呈现的问题； 3.1 坐标系坐标系与向量来描述基本图形的方法，从如何定义和变换图形的直角坐标系，以及如何运用向量表示点和线段； 3.1.1 HTML窗口坐标体系，以参考对象的元素盒子左上角为坐标原点，x轴向右，y轴向下，坐标值对应像素值； 3.1.2 SVG视区盒子（viewBox）坐标系，默认情况下，是以svg根元素左上角为坐标原点，x轴向右，y轴向下，svg根元素右下角坐标为它的像素宽高值。 如果设置了viewBox属性，那么svg根元素左上角为viewBox的前两个值，右下角为viewBox的后两个值； 3.1.3 Canvas画布左上角为坐标原点，右下角坐标值为canvas画布宽高值； 3.1.4 webGL三维坐标系，它默认以画布正中间为坐标原点，x轴朝右，y轴朝上，z轴朝外，x轴，y轴在画布中范围是 -1 到1； 3.1.5 坐标系转换(以canvas为例)因为html svg canvas webgl都是直角坐标系，所以它们可以方便地相互转化。html，svg，canvas提供了transform的api很方便进行坐标系转换； webgl本身不提供tranform的api，可以在shader里做矩阵运算来实现坐标转换。 在很多可视化场景下，要处理成千上万的图形，如果这个时候，在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。采用坐标变换的方式就是一个很好的优化思路，它能够简化计算量，这不仅让代码更容易理解，也可以节省CPU运算时间； 1234567891011121314151617181920const rc2 = rough.canvas(canvas2);const ctx = rc2.ctx;// 通过translate变换 ，将canvas坐标画布原点从左上角（0，0）移动至（256， 256）的位置，即画布的底边上的中心位置；ctx.translate(256, 256); // 以移动了原点后的新的坐标为参照，通过scale(1,-1) 将Y轴向下的部分，即y&gt;0的部分沿x轴翻转180度；这样就变成画布底边中点为原点，x轴向右，y轴向上的坐标系了；ctx.scale(1, -1); const hillOpts2 = &#123; roughness: 2.8, strokeWidth: 2, fill: \"blue\" &#125;;rc2.path(\"M-180 0L-80 100L20 0\", hillOpts2);rc2.path(\"M-20 0L80 100L180 0\", hillOpts2);rc2.circle(0, 150, 105, &#123; stroke: \"red\", strokeWidth: 4, fill: \"rgba(255,255, 0, 0.4)\", fillStyle: \"solid\",&#125;); 3.2 向量在直角坐标系里绘制图形，一般的几何图形都是由点，线段喝面构成，其中，点和线段是基础的图元信息，因此，如何描述它们是绘图的关键； 如何用向量来描述点和线段？一般用向量来表示一个点或者一个线段； 用二维向量来表示这个平面上的点和线段，二维向量其实就是一个包含了两个数值的数组，一个是x坐标值，一个是y坐标值； 向量V(x,y)有两个含义，一是表示该坐标系下位于（x，y）处的一个点，二是可以表示从原点（0，0）到坐标（x，y）的一根线段。 3.2.1 向量基本运算 现在有两个向量，v1和v2； v1+v2 相当于将V1的终点沿着v2向量的方向移动一段距离。这段距离等于v2向量的长度。 这样在平面上得到三个元素 一个新的点 (x1+x2, y1+y2)； 一条新的线段 [(0, 0), (x1+x2, y1+y2)]; 一段折线 [(0,0),(x1,y1),(x1+x2, y1+y2)]; 3.2.2 向量长度和方向一个向量包含长度和方向信息 它的长度可以用向量的 x、y 的平方和的平方根 （勾三股四弦五）来表示 1v.length = function()&#123;return Math.hypot(this.x, this.y)&#125;; 它的方向可以用与 x 轴的夹角来表示 12v.dir = function() &#123; return Math.atan2(this.y, this.x);&#125;// Math.atan2 的取值范围是 -π到π，负数表示在 x 轴下方，正数表示在 x 轴上方。 根据长度和方向的定义，还能推导出一组关系方式： 12v.x = v.length * Math.cos(v.dir);v.y = v.length * Math.sin(v.dir); 推导过程 12345678#角A 对边=y 邻边 = x, 斜边 = zx*x + y*y = z*zsinA = 对边/斜边 = y/zcosA = 邻边/斜边 = x/ztanA = 对边/邻边 = sinA/cosA = (y/z) / (x/z) = y/x;v.length * cosA = z * (x/z) = xv.length * sinA = z * (y/z) = y 结论： 可以很简单构造出一个绘图向量。如果以点 V（x0, y0）为起点，沿着某个方向画一段长度为length的线段，只需构造如下一个向量即可； 1v1 = length * v(cos(A), sin(A)) 推导过程 12345v1 = length * v(cos(A), sin(A))# 这里写成 v1 = length (cosA, sinA) 更容易理解一些cosA = x/z;sinA = y/z;length = z; 可视化呈现依赖于计算机图形学，而向量运算是整个计算机图形学的数学基础； 3.3 向量乘法向量的点乘Dot.product, 向量的点乘也叫向量的内积、数量积； 向量的叉乘Corss.product，也叫向量积，外积、叉积； 3.3.1 一个例子引出向量乘法的*判断：一个点是否在扫描器内 * 解答 如图所示，扫描器是60度，垂直向上，所以它的范围应该是60度到120度； 也就是 Math.PI/3 到 2*Math.PI/3 1234// 先求出目标向量与X轴的夹脚v.dir = Math.atan2(v.y, v.x); // 此方法是求解夹角的，比如 Math.atan2(1,1) === Math.PI/4 // true// 求解该 dir是否在扫描器之内isIn = v.dir &gt; Math.PI/3 &amp;&amp; v.dir &lt; 2*Math.PI/ 3 3.3.2 向量点乘两个N维向量，a和b， a = [a1,a2,a3,…an], b = [b1b2b3….bn]; 那向量的点积代码： 1a*b = a1*b1 + a2*b2 + .... an*bn a, b 向量点积的几何意义，是a向量乘以b向量在a向量上的投影分量。 它的物理含义相当于a力作用于物体，产生b位移所做的功。 1234// 当a、b向量平行时，那么它们的夹角为0a.x * b.x + a.y * b.y = a.length * b.length;// 当a、b两个向量垂直时，它们的夹角就是90度，那么a.b = 0；a.x * b.x + a.y * b.y === a*b*cos(90度) = a*b*0 = 0; 总结 向量的点乘， 对两个向量执行点乘运算，结果是一个【Scaler标量】（一个数字） （标量： scalar， 只有大小没有方向的量，例如物体移动中的平均速率·路程） 3.3.3 向量的叉乘向量的叉乘，则是针对两条向量的另一种运算方式。 向量叉乘运算的结果不是标量，而是一个新的向量；新的向量会 垂直于 原来的这两条向量； 向量A和向量B的叉积是向量C， 【向量C】同时垂直于【向量A和向量B】 【向量的叉乘】一个用途就是找到我们应该在哪一轴上施加【扭力Torque】（还有，跟踪导弹，比如合金弹头的C弹，也是可以通过叉乘的方法去实现的）； 如下示例： 【向量A】表示的是炮口【当前朝向】 【向量B】表示的是炮口将要【调整后的朝向】 【向量C】将两个向量进行叉乘后，找到炮口需要在哪一轴上进行旋转并且施加相应的扭力； 叉积几何意义 向量a和b的叉积，就相当于向量a（蓝色带箭头线段）与向量b沿垂直方向的投影（红色带箭头线段）的乘积。（如上图所示），二维向量叉积的几何意义就是向量a、b组成的平行四边形的面积； 1|a| 表示向量a的length； 思考题：求点到线段的距离 在了解向量叉积的几何意义之后， 我们通过向量叉积得到平行四边形的面积，再除以底边长；就能得到点到向量所在直线的距离 叉乘在数学上的计算方法 12// 其中，i，j，k 分别是 x，y，z 轴的单位向量，我们把行列式展开，就能得到如下公式：a X b = [y1 * z2 - y2 * z1, - (x1 * z2 - x2 * z1), x1 * y2 - x2 * y1] 更多点积差积相关知识参考https://geek-docs.com/linear-algebra/vector/vector-chaji.html 回到思考题3: 给任意一个点，判断这个点在不在扫描器内 归一化 归一化，用 v0的 x、y 分别除以它的绝对值。归一化后的向量方向不变，长度为 1。 在向量乘法里，如果 a、b 都是长度为 1 的归一化向量，那么|a X b| 的结果就是 a、b 夹角的正弦值，而|a • b|的结果就是 a、b 夹角的余弦值。 好了，再说回来，我们把归一化的向量 a 叉乘扫描器中线上的 v(0,1)，由于扫描器关于 y 轴对称，所以扫描器边缘与 y 轴的夹角是正负 30 度。那么在与单位向量求叉积的时候，就会出现 2 种情况： 点在扫描范围内，如向量 a，就一定满足： |a X v| &lt;= ||a||v|sin(30°)| = |sin(30°)| = 0.5； 点不在扫描范围内，如向量 b，就一定满足：|b X v| &gt; ||b||v|sin(30°)| = |sin(30°)| = 0.5。 因此，只要任意一点所在的向量与单位向量的叉积结果的绝对值不大于0.5（即sin30度），就说明这个点在扫描范围内，所以如下判断方法 123const isInRange = Math.abs(new Vec2(0, 1).cross(v0.normalize())) &lt;= 0.5; // v0.normalize()即将v0归一化 3.3.4 点乘与叉乘加述 Dot product 12345a向量 * b向量 = a长度 * b长度 * cos@ // @ 为a向量和b向量的夹角 // 点乘使用场景1， 快速得到两个向量的夹角 cos@ = （a向量 * b向量） / （a长度 * b长度） 点乘能快速得到两个向量的夹角， 特别是在两个向量都是单位向量的时候。它们的长度自然都是1；所以它们的点乘自然就是夹角的cos值； 点乘满足的计算规律 交换律，分配律，结合率； Cross product 3.4 向量和参数方程描述曲线用参数方程描述曲线的方法，通过此方法可以描述常见的圆，椭圆，抛物线，正余弦等曲线，还能描述更具一般性的曲线；比如贝塞尔曲线，或者Catmull-Rom曲线等等； 3.4.1 画圆 如下图所示的参数方程，圆心为（x0, y0），半径为r； 3.4.2 画圆椎曲线除了画圆，参数方程还可以描述很多其他圆椎曲线，比如椭圆的参数方程。它其实和圆的参数方程很接近。其中，a，b 分别是椭圆的长轴和短轴，当a=b=r时，这个方程就是椭圆的方程式。圆是椭圆的特例； 3.4.3 抛物线的参数方程，其中p是常数，为焦点到准线的距离 3.4.4 贝塞尔曲线3.5 三角剖分和向量操作描述并处理多边形3.6 仿射变换对几何图形进行坐标变换","categories":[{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/categories/webgl/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"}]},{"title":"canvas","slug":"canvas","date":"2021-01-26T10:08:55.000Z","updated":"2021-03-16T10:15:05.701Z","comments":true,"path":"2021/01/26/canvas/","link":"","permalink":"http://yoursite.com/2021/01/26/canvas/","excerpt":"","text":"1. canvas 基础API1.1 contextcontext对象 proto 指向CanvasRenderingContext2D，一些绘图API集中在这些地方 12const canvas = document.querySelector('canvas')const context = canvas.getContext('2d'); context对象API大体分两类 设置状态的 （颜色，线宽， 坐标变换） 绘制指令API，绘制不同形状的几何图形 1.2 绘图API1.2.1 rect绘制矩形指令 参数 四个参数，分别为要绘制矩形的x坐标，要绘制矩形y坐标, 矩形宽和矩形高； 1.2.2 缓存当前状态和恢复类似一个压栈和弹栈功能； save 保留当前的路径和颜色等状态 restore 123456789ctx.fillStyle = \"green\";ctx.save(); // 保存画笔初始坐标(0,0), 填充色为绿色ctx.fillRect(10, 10, 100, 100);// Restore the default statectx.restore();ctx.fillRect(150, 40, 100, 100); // 该图形的画笔坐标回到 初始状态，即 (0,0) ,填充色为绿色，而不是默认色； 1.3 绘制状态APIfillStyle 1context.fillStyle = color; 1.4 坐标系统 左上角为 (0, 0) 右下角为 (canvas.width, canvas.height) 1.5 绘图过程 获取canvas对象，getContext(‘2d’) 绘制状态， fillStyle， translate等； beginPath开始绘制 调绘图指令，rect等 调fill指令，将绘制内容输出到画布中； 1.6 图形信息有的时候，类似一份层级数据（城市 &gt; 省份 &gt; 中国）这样层级数据，要将它与绘图指令建立联系，建立联系指的是 要把数据的层级、位置、和要绘制的圆的半径、位置一一对应起来； 换句话说就是要把数据转换成图形信息，这个步骤需要数学计算； 假设，我们要将数据展现在一个画布宽高为 1600 * 1600 的 Canvas 中，那我们可以通过 d3.pack() 将数据映射为一组 1600 宽高范围内的圆形。 具体绘制的过程比较简单，只需要遍历数据并且根据数据内容绘制圆弧","categories":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/categories/canvas/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"C","slug":"C","date":"2021-01-25T02:12:49.000Z","updated":"2021-03-24T12:34:37.646Z","comments":true,"path":"2021/01/25/C/","link":"","permalink":"http://yoursite.com/2021/01/25/C/","excerpt":"","text":"前置1.程序 写程序前，先构想好程序的结构，而不是先从定义变量开始。 没有想好解决方案，不要急于动手写程序？ 有了解决方案以后，可以按照“先粗后细，先抽象后具体”的办法，先有程序的轮廓，如有必要可以解决“建模工具”画一些图，而后再动手写程序； 写程序时，可以先写出程序轮廓，而后再补充变量定义等细节； 程序并不纠结于是否更优。而在于程序结构是不是清楚，是不是容易被人看懂 1.1 写程序的过程 按照由大到小，由粗到细，由抽象到具体的方法分析、编写程序 程序的结构 （基本思想） 程序由若干个“模块”组成 模块之内“高内聚”（高内聚， 就是这个模块只做这个事情，不干别的。功能单一） 模块之间“低耦合” （当一个模块被改动的时候，只会印象它自己，而不会影响别的） 1.2 编程语言共性 （语法）程序设计语言的构成,语言种类千差万别，但是，一般来说，基本成分不外四种： 数据， 用以描述程序中所涉及的数据 （数据类型） 运算，用以描述程序中所包含的运算；（运算符） 控制，用以表达程序中的控制构造；（三种类型的控制语句是如何写的，顺序，分支，循环） IO，用以表达程序中数据的传输； （如何输入和输出数据） 1.3 大纲 基本概念 数据类型，运算符，表达式 IO 流程控制（顺序，分支，循转） 数组 指针 函数 构造类型 动态内存管理 调试工具，（gdb，make） 常用库函数 2. 基本概念 把内存想象成一个长长的带子,带子上面有很多小方格，每个格子都是一个字节（存储单元）。每个小方格都有它对应的地址，每个字节（单元）有八位，1B（byte） = 8b（bit）每一个位存储一个二进制的数。 2.1 变量与常量2.1.1 常量 在程序执行过程中值不会发生变化的量，数组名是一个典型的常量，一旦数组定义了，gcc为当前的数组分配了一段空间了。然后数组的位置就定死了。数组名就是一个数组的起始位置。是一个常量，如果你在=左边写上一个常量，就表示企图更改一个常量的值；比如1=f ，显然不成立； 常量的分类 整型常量 实型常量 3.14, 5.26; 字符常量 由单引号印起来的单个字符或者转义字符，如’a’ 转义字符： ‘\\n’, ‘\\r’, ‘\\t’ ，’\\015’(八进制数)， ‘\\x7f’(十六进制数) 字符串常量 由双引号印起来的一个或多个字符组成的序列，如: “”(空串) 一个字符串在存储的时候，最末尾会有一个结束标记，通常称作尾0\\0.所以&quot;&quot;是占空间的，空字符占一个字节的空间； 合法的字符串 （””, “a”, “abXYZ”） 暂时不确定是否合法的字符 （”abc\\n\\021\\018”) 因为\\018不是八进制，因为出现了8，而我们知道\\0是字符串数组的末尾。所以\\0到底能否插入进字符串中间，这个需要后续字符数组专题揭秘； 字符串常量需要借助构造类型——数组来保存 &#39;a&#39;和&quot;a&quot;的区别：前者是字符常量，后者是字符串常量。 标识常量 #define， 程序中一改全改 #define PI 3.14，在程序预处理之后，宏名被宏体完整的替换；define ADD 2+3 ADD*ADD = 2+3*2+3而不是(2+3)*(2+3)。 #define，处理在程序的预处理阶段，占编译时间。不占运行时间。一改全改；缺点： 不检查语法，只是单纯的宏体与宏名之间的替换； 带参数的#define 1234567891011121314151617#define MAX(a, b) a&gt;b?a:bint main() &#123; int i, j; i = 5; j=3; printf(\"/d\\n\", MAX(i, j)); exit(0);&#125;// gcc -E define.c int main() &#123; int i, j; i = 5; j=3; printf(\"/d\\n\", (i&gt;j?i:j)); exit(0);&#125; 一个特殊问题的解决方式 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))int max(int a, int b)&#123;return a&gt;b?a:b;&#125;int main()&#123; int i = 5; int j = 3; printf(\"max = %d\\n\", MAX(i++, j++)); printf(\"i=%d\\tj=%d\\n\", i, j); exit(0);&#125;((i++) &gt; (j++) ? (i++) : (j++))// max = 6// i=7 j=4 首先，max和MAX的区别，MAX只占用预编译时间，等运行的时候，实际上已经将所有宏体替换到程序中去了。不会再需要额外的时间了。而max则不同，在函数的调用位置，对当前的一个执行现场做一个压栈保存。然后去到指定的函数去执行。（跳往另外一个入口地址）然后再回来，弹栈恢复当前现场的过程。这个过程 占用了运行的时间； 什么时候用宏，什么时候用函数？在需要极致性能的场景用宏，前提是宏能满足；比如内核。在应用层面，系统层面，多用函数。因为应用层要求更高的是稳定性，而非实时性。 解决方案，需要找一个变量来接受；而不是让其继续做加运算； 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) (&#123;typeof(a) A = a, B = b;((A) &gt; (B) ? (A) : (B)); &#125;)// typeof(a) 用a的类型定义A，就很灵性了。有点泛型的意思了；int main()&#123; int i = 5; int j = 3; printf(\"max = %d\\n\", MAX(i++, j++)); printf(\"i=%d\\tj=%d\\n\", i, j); exit(0);&#125;// max = 5// i=6 j=4 2.1.2 变量 用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量； 当计算机执行到 int max=0 这句程序时，计算机会在内存里面找到一片存储空间（几个连续的存储单元），然后给该片存储空间取个名字叫 Max， 再把 0 这个初始值放在这个存储空间中来。并记下这个名字（Max）和这片连续的存储空间的起始的地址之间的对应关系 定义： [存储类型] 数据类型 标识符 = 值 TYPE NAME = VALUE; 存储类型 可选 2.1.2.1 标识符当定义一个某种类型的标识符的时候，编译器会为当前的值分配一块内存空间；如何称呼这块空间，就是房间号。房间号就是标识符。编译器会给标识符（房间号）和内存地址标识做关联。当搜索变量名的时候，编译器知道要去到哪块内存地址去搜索；简单说，标识符就是这块空间的临时别名； 2.1.3 存储类型 auto, static register extern(说明型) 2.1.3.1 auto 默认，自动分配空间，自动回收空间 auto类型分配在栈上，堆主要是来进行动态内存分配的空间；堆栈不挨着 12345678910int main ()&#123; auto int i; // 原则上不会 对 i所在这块空间进行初始化 int j; printf(\"i = %d\\n\", i); // 随机的结果，当然有的编译器会置为0 printf(\"j= %d\\n\", j); // 0 编译器会初始化为0 exit(0);&#125; 123456789101112131415161718192021void func(void)&#123; int x =0; x = x+1; printf(\"%p-&gt;%d\\n\", &amp;x, x);&#125;int main()&#123; func(); func(); func();&#125;// 0x7ffee6b3c928-&gt;1// 0x7ffee6b3c928-&gt;1// 0x7ffee6b3c928-&gt;1/**说明： 这三个地址未必一致，但一致的原因是 auto类型的变量都存放在栈上，栈上的空间按正常理论来讲，它实际上是连续分配的。而当前x在 func函数被调用的时候，它才会被产生。然后在当前函数执行结束的时候，这块空间被释放掉了。*/ 2.1.3.2 register 建议型关键字； 寄存器类型，资源少，速度快，寄存器存放在CPU当中，寄存器的数据比较吃紧， 1register int i =1; // 除非i在程序中，超高频率被使用，才建议编译器将i分配到寄存器中；至于有没有被放到寄存器中，由gcc来决定； register的苛刻条件； 只能定义局部变量，不能定义全局变量； 大小有限制，只能定义 32 位大小的数据类型，如double 就不可以 寄存器中没有地址，所以一个寄存器类型变量无法打印出地址查看或者使用； 2.1.3.3 static 静态型，自动初始化为0值或空值，并值其变量的值有继承性（继承性指的的static在内存中只此一份，所以下次使用的时候还是基于上一次的值，而不会被初始化）。另外，常用于修饰变量或函数 1234567891011121314151617181920void func(void)&#123; static int x =0; x = x+1; printf(\"%p-&gt;%d\\n\", &amp;x, x);&#125;int main()&#123; func(); func(); func();&#125;// 0x10c4b1018-&gt;1// 0x10c4b1018-&gt;2// 0x10c4b1018-&gt;3/**说明： static类型的变量，只用一块空间。*/ static 修饰函数： 防止该函数对外扩展，（简单说就是该函数只能在当前文件下使用，在别的文件下没法使用；） 123456789static void func(void)&#123; printf(\"hello func\");&#125;void call_func() // 外界可以通过 call_func 这个桥梁函数来引用 func&#123; func()&#125; 一般来说全局变量都要修饰成static，防止跟别的.c文件中同名变量冲突。然后用static来修饰函数，为的是强调当前函数不可外扩，（该函数只能在当前文件使用，别的文件下没法使用） 2.1.3.4 extern 说明型， 意味着不能改变被说明的变量的值或类型； 12345678910111213141516171819202122// proj.hvoid func(void);// main.cint i =10;int main()&#123; printf(\"%d\\n\", i); func(); exit(0);&#125;// proj.c#include \"proj.h\"extern int i; // 我的i不是自己定义的，是引用其他文件里面的i，编译器自己去找，extern不能改变声明的类型和值；void func(void)&#123; printf(\"%d\\n\", i); exit(0);&#125; 2.1.4 变量的生命周期和作用范围（即作用域） 全局变量和局部变量 局部变量和局部变量 参考图片 3. C程序3.1 程序规范 以helleworld为例对写程序的思路提出如下要求: 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//void main(void);//void main(int argc, char **argv); // char * argv[]//int main(int argc, char **argv);//int main(void);void main()&#123; printf(\"hello c!\\n\"); exit(0);&#125; 头文件正确包含的重要性； 知道程序中的所有警告gcc file.c -Wall 如何调试段错误，先把程序中的所有警告调好； 以函数为单位来进行程序编写； 声明部分 和 实现部分（变量先定义，后使用） return 0 （exit(0) 在单进程单线程的程序中 和 return 0意义一样的，exit(0)是给它父进程看的，当前main函数的父进程是shell） 多用空格空行 添加注释 1echo $? # 上一条语句执行的状态 3.2 注释 #if #endif 注释 12345#if(0)int main()&#123; return 0;&#125;#endif 3.3 编译12#gcc hello.c.c -&gt; .out gcc过程(c源文件到可执行文件需要经过的顺序) c源文件 - 预处理 - 编译 - 汇编 - 链接 - 可执行文件 预处理 gcc -E hello.c &gt; hello.i (预处理hello.c，保存至 hello.i 文件)以#开头的语句部分都是在预处理阶段解决掉的；`include`或者 `if define` 编译阶段gcc -S hello.i (编译hello.i)默认会生成一个 .s文件，编译成汇编文件； 汇编阶段gcc -c hello.s生成一个 .o文件； 链接阶段gcc hello.o -o hello (链接.o文件 生成可执行文件 hello)生成可执行文件hello; 3.3.1 C编译123gcc -o test test.c # 把test.c 编译成一个可执行文件 testgcc hello.c -Wall # 显示编译警告，原则上编码过程当中把程序调到没有警告为止；./test # 执行 test 3.3.2 多个.c文件 main() 里的代码太长了 适合分成几个函数 一个源文件太长适合分成几个文件 两个独立的源文件不能编译形成可执行的程序 3.3.3 头文件 把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件(.c文件)中 #include 这个头文件，就能让编译器在编译的时候知道函数的原型 12# main.c max.c max.hgcc main.c max.c 4. 数据类型 不同数据类型所占字节数 存储区别 不同类型的数据间转换 特殊性： 4.1 基本类型 数值类型 整型 短整型 short （2个字节，16位） 整型 int （4个字节，32位） 长整型 long （4个字节，32位） 浮点型 单精度型 float （4个字节，32位） 双精度型 double （8个字节，64位） 字符类型 char （1个字节，8位） 4.1.1 整形存储整型的存储都是以补码的形势来存储的 补码：正数的补码是它二进制本身，负数的补码是它绝对值的那个数的二进制形式取反再加1的结果； 254 -&gt; unsigned int(无符号 int) -&gt; 32位 -254 -&gt; 254-&gt; 1111 1110 取反 +1 有无符号的区别，最高位到底代表是符号还是正常有效值；有符号的话，为0表示正数，为1表示负数； (254)10 =&gt; (11111110)2 方法： 除2取余倒序排列；（转2进制）11111110 除8取余倒序排列；（转8进制）376 除16取余倒序排列；（转16进制） FE进制表示 254 十进制 B11111110 二进制 0376 八进制 0xFE 十六进制 4.1.2 浮点型存储12343.14 * 10^00.314 * 10^10.0314 * 10^2314 * 10^-2 浮点数是以0.314 * 10^1的方式来存储3.14的 整数部分为0，只是在意精度部分是多少。然后在意指数部分是多少。 浮点数在32 个bit上是如何存放的0～22位（共23个bit）用来记录精度部分。 22位～30位（共8个bit） 用来存储的是指数部分。最高位（第31位） 表示的是符号位置，表示是正数还是负数； 举例 0.000789 -&gt; 0.789 -&gt; 10^3 精度部分存储 789的二进制形式，8个位存储3 float 32位 double 64位 ，比float多出来的32位完全放在精度的控制上 4.1.3 char存储 char 8位。 -128～127 unsigned char 8位。 0～255 4.1.4 不同类型的数据间转换4.1.4.1 精度丢失12float f = 3.9;int i = f; // 4 4.1.4.2 隐式转换编译器默认做的 12345678int i;char ch;float f;double d;ch + i --&gt; i // 默认往精度高，或者所占字节长比较高的那一种数据类型去靠拢的f -d --&gt; d // 精度高的 double(ch + i) - (float - double) --&gt; double 4.1.4.3 显式转换强制类型转换 4.1.4.4 特殊性： 布尔型bool float类型； 1.0/3*3 ！= 1 char型是否有符号，不知道，一个未定义的行为 不同形式的0值； 12340;'0';\"0\";'\\0'; 数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾） 4.2 构造类型 数组 结构体 struct 共用体 union 枚举类型 enum 4.2.1 enum*语法: * 1234enum 标识符&#123; 成员1,&#125; 123456789101112131415enum day&#123; MON, //默认从0 开始往下排 TUS, THR, WES, FRI = 1, // 如果给FRI赋值为1的话，那么接下来会从1继续排 SAT, SUN&#125;int main () &#123; enum day a = FRI; printf(\"%d\\n\", a); // 5&#125; *把enum当宏使用: * 12345678910111213141516171819202122232425262728293031323334enum &#123; STATE_RUNNING = 1, STATE_CANCELED, STATE_OVER&#125;;struct time_t &#123;&#125;;struct job_st&#123; int id; int state; char start; char end;&#125;;int main() &#123; struct job_st job1; // job1.state = STATE_CANCELED; switch (job1.state) &#123; case STATE_CANCELED: break; case STATE_OVER: break; case STATE_RUNNING: break; default: abort(); // 信号，操作系统后续会讲 &#125; return 0;&#125; *这种场景可以用 enum代替宏的使用: * 因为宏经过预编译之后被替换掉了，宏的部分会被替换。影响调试。当然enum不是万能，并不能替代宏；宏还可以传递参数 4.2.2 结构体类型 类型描述 1234struct 结构体名 &#123; 数据类型 成员1; 数据类型 成员2;&#125; 类型嵌套 1234567891011121314151617181920212223242526272829struct birthdata_st &#123; int year; int month; int day;&#125;struct student_st&#123; int id; char name[NAMESIZE]; struct birthday_st birth; // 嵌套定义 int math; int chinese;&#125;// 或者struct student_st&#123; int id; char name[NAMESIZE]; struct birthdata_st // 嵌套定义 &#123; int year; int month; int day; &#125;birth; int math; int chinese;&#125; 定义变量（变量，数组，指针），初始化及成员引用； 12345struct student &#123; // student 不是变量名而是类型 int id; char name[20] .....&#125;; 成员引用： 变量名.成员名 指针名-&gt;成员名 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct simp_st&#123; /* data */ int bigint; float mfloat; char name;&#125;;int main()&#123; struct simp_st a = &#123; 123, 456.789, 'a'&#125;; a.bigint = 333; printf(\"%d, %f, %c\\n\", a.bigint, a.mfloat, a.name); exit(0);&#125; *定义结构体变量的方式: * student tudent1,student2;(结构体类型名) (结构体变量名) 12345struct student &#123; int id; char name[20] .....&#125; lige_1, lige_2; *结构体赋值: * 123456789101112int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; struct student mike2 = mike; // 结构体赋值相当于copy一份给对方 mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike2.name[i]!='\\0'; i++) &#123; mike2.name[i] = toupper(mike2.name[i]); printf(\"%d\\n\", mike2.id_num); printf(\"%s\\n\", mike2.name); &#125; return 0;&#125; *结构体内存 * 12345678struct simp_st &#123; int i; char ch; float f; char ch1;&#125;// 看上去是10个字节，结果打印出来的是16个字节；// 地址对齐， 结构体对齐的概念； 一个公式 address（当前准备存储的变量的地址）%（你当前要存放变量的sizeOf）如果能整除的话，那么这个变量就存放在这里，如果这个表达式不成立，那么address就得 + 1； 举例子说明,首先下面是一段内存 123456789101112131415161718192021222324252627----------0----------1----------2----------3----------4----------5----------6----------7----------8----------9----------10----------11----------12---------- 1234567// 目标结构体struct simp_st &#123; int i; char ch; float f; char ch1;&#125; *解释 * 首先内存第一个地址的值是0，结构体的第一个属性是int，我们知道int占4个字节。0/4 能整除，因此第一个int占据从0-3 这个几个内存中，然后 char占1个字节，4/1能整除，因此第二个char占据了4这个内存中。接着结构体第三个属性为float，占据4个字节。内存地址5/4没法整除，当前内存++，分别到6，7，都无法整除4.到了8，8/4能整除，所以，从8打11这一段内存就存放着float这个属性，接下来又是char12/1能整除，所以char属性占据了char12这个内存地址； 值得注意的是，不同的操作系统内存对齐的方式是不同的；因此在socket编程中，我们传过去的结构体数据在末端一定不能做对齐；因为不知道不同平台到底是什么字节对齐的 *结构体对齐 * 1234struct point &#123; int x; int y;&#125;__attribute__((packed)); 这个操作在网络编程当中很常用； 总结 如果没有内存对齐，就是指定attribute((packed))的话，那么结构体内存的大小就是各个属性的sizeof累加的结果。如果没加就需要考虑内存对齐的问题，不同的机器内存对齐的方式是不同的。因为在跨机器编程比如socket编程当中，是需要指定attribute((packed))来确保数据的完整性和 安全性； 4.2.2.1 结构体作为函数参数传递给函数（值传递，地址传递）123456789101112131415161718192021void renew (struct student mike) &#123; mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike.name[i]!='\\0'; i++) &#123; mike.name[i] = toupper(mike.name[i]); &#125; printf(\"%d\\n\", mike.id_num); printf(\"%s\\n\", mike.name);&#125;int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; renew(mike); printf(\"%d\\n\", mike.id_num); printf(\"%s\\n\", mike.name); return 0;&#125;#20130123#MIKE#123#mike 结论 结构体的传入是 值拷贝，函数内部执行的是副本 4.2.2.2 当把结构体当成形参传递的时候，意味着什么1234567891011void func (struct simp_st b)&#123; // 内存总是要分配一个完整的 结构体 体积所占的空间用来接受这个形参 printf(\"%d\\n\", sizeof(b)); // 12&#125;int main() &#123; struct simp_st a; struct simp_st *p = &amp;a; func(a); // func(a.i, a.ch, a.f)&#125; 小结： 所以我们一般不会这么去用。会有非常严重的性能浪费；一般我们会传递结构体指针； 4.2.2.3 结构体作为函数返回值时 总结： 结构体作为函数返回值时，相当于copy一份给调用者 4.2.2.4 指向结构体变量的指针12345678910int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; struct student *p = &amp;mike; printf(\"%d\\n\", (*p).id_num); // 123 printf(\"%d\\n\", p-&gt;id_num); // 123 另外一种写法 -&gt; 指向运算符 printf(\"%s\\n\", p-&gt;name); // mike 另外一种写法 printf(\"%s\\n\", (*p).name); // mike return 0;&#125; 4.2.2.5 指向结构体变量的指针作为参数传入函数1234567891011121314void renew (struct student mike) &#123; mike.id_num = 20130000 + mike.id_num; for (int i = 0; mike.name[i]!='\\0'; i++) &#123; mike.name[i] = toupper(mike.name[i]); &#125;&#125;int main()&#123; struct student mike = &#123;123, &#123;'m', 'i', 'k', 'e', '\\0'&#125;&#125;; renew(&amp;mike); printf(\"%d\\n\", mike.id_num); // 20130123 值被篡改 printf(\"%s\\n\", mike.name); // MIKE 值被篡改 return 0;&#125; 4.2.2.6 结构体数组12345678910111213141516int main()&#123; struct student myclass[3] = &#123; 123, &#123;'m','k','k','e'&#125;, 133, &#123;'j','o','y'&#125;, 143, &#123;'t','o','m'&#125; &#125;; struct student * p = &amp;myclass; printf(\"%d\\n\", p-&gt;id_num); // 123 printf(\"%s\\n\", p-&gt;name); // mkke p++; // 跳一个结构体 体积的内存 printf(\"%d\\n\", p-&gt;id_num); // 133 printf(\"%s\\n\", p-&gt;name); // joy return 0;&#125; 4.2.2.7 链表 动态地 申请内存空间 123456int *pint = new int(1024); // 开辟一片内存存储空间并返回起始地址； delete pint; // 释放掉指针所指向的内存空间；int *pia = new int[4]; // 申请一个 4个整型小数组的空间；并返回起始地址；delete [] pia; // 开个方括号，指的是释放掉的是一个数组区域 动态地 建立链表节点 123456struct student &#123; int id; student *next;&#125;student *head;head = new student; 4.2.3 共用体 共用体和结构体语法很像，但截然不同的是，结构体各个成员会占用不同的内存，结构体整体内存 &gt;= sizeof（所有属性）， 因为有内存缝隙的 概念，所以有时候会大一些； 而公用体的内存体积取决于最大属性的体积；共用体所有成员占据同一段内存；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来的值覆盖掉。 共用体是硬件稀缺时代的产物；结合实际场景，比如 checkbox 男女只能同时存在一个； 语法 123union 共用体名 &#123; 成员列表&#125; 类型嵌套 硬件存储分大小端的； 大端格式： 数据的低位保存在高地址中； 小端格式： 数据的低位保存在低地址中； 定义变量（变量，数组，指针），初始化及成员引用 (变量名.成员 指针名-&gt;成员) 占用内存大小 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;union test_un&#123; /* data */ int i; float f; double d; char ch;&#125;;int main()&#123; union test_un a; a.f = 345.678; printf(\"%d\\n\", sizeof(a)); // 8 验证多个成员共用一块空间 printf(\"%f\\n\", a.f); exit(0);&#125; 123456789101112131415161718union unioz&#123; int a; double d; struct &#123; int arr[10]; float f; &#125; c;&#125;;int main()&#123; union unioz x; printf(\"%d\\n\", sizeof(double)); // 8 printf(\"%d\\n\", sizeof(x)); // 48 exit(0);&#125; 函数传参（值，地址） 位域 5. 类型转换存储涉及到2进制，8进制，10进制，16进制。这几种进制之间的转换首先要区别开，如何去获得一个二进制 5.1 十进制转二进制 除2取余，余数倒序排列 254 -&gt; unsigned int -&gt; 32位 （4个字节） 254（10进制）-&gt; 11111110 (2进制) -&gt; 376 (8进制) -&gt; FE(16进制) c语言程序当中是不识别二进制的 254 默认10进制B11111110 二进制0376 八进制0xFE 十六进制 5.2 补码 一个正数的补码形式就是 它二进制本身,负数的补码是它绝对值的二进制形式取反 + 1 254 -&gt; unsigned int -&gt; 32位-254 -&gt; 254 -&gt; 1111 1110 取反 + 1 6. 运算符和表达式表达式与语句的区别 运算符部分： 每个运算符所需要的参与运算的操作个数 结合性 优先级 运算符的特殊性 % 要求 除数，被除数都是整型 位运算的重要性 8.1 自增和自减 运算符在前，先进行计算，再取变量值使用变量在前， 先取变量值使用，再进行计算 7. 位运算3.1 &gt;&gt; &lt;&lt; 位运算（左移右移）基本等同于乘2除2运算,像汇编当中乘以多少，除以多少，几乎按这种方式来实现的 123456int i = B1100 = 12~i -&gt; B0011 // 取反// 把i往右移一位，1100 变成 110， 转化为10进制就是12i &gt;&gt; 1 --&gt; 110 = 6 // 把i往左移一位， 1100变成11000， 转化为10进制就是24i &lt;&lt; 1 --&gt; 11000 = 24 3.2 ~ （取反）12int i = B1100 = 12~i -&gt; B0011 // 取反 3.3 按位或 按位或的计算原则是，同一个位上，两者有一者为1就为真，两者都为假才为假 1234567891011int i = B1100;int j = B1001;i|j 1 1 0 0｜ 1 0 0 1---------- 1 1 0 11101 -&gt; 13 3.4 按位与 按位与的计算原则是，同一个位上，两者有都为1就为真，否则为假 1234567891011int i = B1100;int j = B1001;i&amp;j 1 1 0 0&amp; 1 0 0 1---------- 1 0 0 01000 -&gt; 8 3.5 ^ (相同为0， 不同为1) 亦或计算原则， 同一个位上，相同为0， 不同为1 1234567891011int i = B1100;int j = B1001;i^j 1 1 0 0^ 1 0 0 1---------- 0 1 0 11000 -&gt; 5 3.6 位运算的重要意义 将操作数中第N位 置1， 其他位不变； 1234567891011121314//num = num | 1 &lt;&lt; n // 把某一位 置1的话，把1左移 N个位// 比如将i 的第二位 置1int i = B1011;int j = B1001;i = i | i &lt;&lt; 2; 1 0 1 1| 0 1 0 0 // 注意是把 1 左移动 N个位。 1 -&gt; 0100 空位补0---------- 1 1 1 11000 -&gt; 5 将操作数中第N位 清0， 其他位不变； 1234567891011121314//num = num &amp; ~(1 &lt;&lt; n) // 把某一位 置1的话，把1左移 N个位// 比如将i 的第1位 置0int i = B1011;int j = B1001;i = i | i &lt;&lt; 2; 1 0 1 1| 1 1 0 1 // -&gt; 把1左移N位取反---------- 1 0 0 11000 -&gt; 5 测试第n位： if (num &amp; i 1 &lt;&lt; n) 从一个指定宽度的数中取出其中的某几位 （练习题） 8. 内核代码位置12cd /linux/include/linuxvim list.h 9. 宏 #开头的是编译预处理指令 它们不是C语言的成分，但是C语言程序离不开它们 #define 用来定义一个宏； define (定义一个宏) 12345678910#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(\"%d\\n\", 2*PI*3.0); return 0;&#125;// C语言程序在编译之前，会做一次编译预处理；// 会把程序中所有的PI都替换成 3.14159 4.1 save-temps对一个 .c 文件执行 1gcc 02.c --save-temps 生成 四个文件 02.i02.s02.oa.out 过程依次是 .c -&gt; .i -&gt; .s -&gt; .o -&gt; a.out .c是源代码，经过编译预处理之后变成 .i 这种中间结果文件，当中所有编译预处理指令都执行完，比如 define 宏需要替换掉;然后由于编译器对 .i文件进行编译 生成汇编代码 .s文件；然后汇编代码文件，进行汇编变成目标文件， 目标文件再经过链接之后形成一个可执行的东西； 查看 .i 文件 12tail 03.itail -n 50 03.i # 看03.i文件 最后 50行 123456789extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));# 943 \"/usr/include/stdio.h\" 3 4# 3 \"03.c\" 2int main()&#123; printf(\"%f\\n\", 2*3.1415927*3.0); // 这里明显把宏替换成了值； return 0;&#125; ** 同样的可以把 “%f\\n” 也替换成宏** 12345678#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(FORMATTER, 2*PI*3.0); return 0;&#125; 4.2 宏的缺点 不检查语法，在预处理或者编译阶段是不报错的； 4.3 define #define &lt;名字&gt; &lt;值&gt; 结尾没有 分号，因为不是C的语句 名字必须是一个单词，值可以是各种东西 在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值； 完全的文本替换 gcc –save-temps 如果一个宏的值中有其他的宏的名字，也是会被替换的 如果一个宏的值超过一行，最后一行之前的行末需要加\\ 宏的值后面出现的注释不会被当作宏的一部分 123456789#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏#define PI2 2*PI // PI * 2// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; prinft(FORMATTER, 2*PI*3.0); return 0;&#125; 1234567891011#include &lt;stdio.h&gt;#define PI 3.14159 // 指定义了一个宏#define FORMATTER \"%f\\n\" // 指定一个FORMATTER 宏#define PI2 2*PI // PI * 2#define PRT printf(\"%f\", PI)\\ printf(\"%f\\n\", PI2)// PI 是这个宏的名字， 3.14159是这个宏的值；int main() &#123; PRT; return 0;&#125; 4.4 没有值的宏 #define_DEBUG 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了； 4.5 预定义的宏 用来表示一些特殊的东西，可以让编译器替我们插入一些特殊的值。 12345_LINE_ //这个源代码所在当前的行号；_FILE_ // 源代码的文件名_DATE_ // 编译时候的日期_TIME_ // 编译时候的时间_STDC_ 4.6 像函数的宏#define cube(x) ((x)*(x)*(x)) 宏可以带参数 123456#define cube(x) ((x)*(x)*(x))int main(int argc, char const *argv[])&#123; printf(\"%d\\n\", cube(5)); // 125 return 0;&#125; 打开 .i 文件 12345int main()&#123;printf(\"%d\\n\", ((5)*(5)*(5))); // 被预处理成这样了； printf(\"%f\\n\", 2*3.1415927*3.0);return 0;&#125; 4.7 错误定义的宏#define RADTODEG(x) (x*57.29578)#define RADTODEG(x) (x)*57.29578 1234567#define RADTODEG(x) (x*57.29578)#define RADTODEG(x) (x)*57.29578int main() &#123; printf(\"%f\\n\", RADTODEG(5+2)); printf(\"%f\\n\", 180/RADTODEG2(1));&#125; 被预处理的结果 1234int main() &#123; printf(\"%f\\n\", (5+2 * 57.29578)); printf(\"%f\\n\", 180/1*57.29678);&#125; 我们发现 被预处理的结果是不符合我们的要求的； 4.8带参数的宏的原则 一切都要有括号 整个值要有括号，指的是整个宏的值有括号 参数出现的每个地方都要括号 #define RADTODEG(x) ((x)*57.29578) 可以带多个参数 #define MIN((a,b) ((a)&gt;(b)?(b):(a)) 也可以组合（嵌套）使用其他宏 在大型程序的代码中使用非常普遍 可以非常复杂，如“产生”函数 在# 和 ## 这两个运算符的帮助下 存在中西方文化差异 部分宏会被inline函数替代 4.9 什么时候用宏 什么时候用函数应用求稳定，用函数追求极致性能，用宏 4.10 include “” 还是 &lt;&gt;include 做了什么？ include就是把头文件里头所有的文本插入到include所在.c文件的那一行. #include有两种形式来指出要插入的文件 “”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找 &lt;&gt; 让编译器只在指定的目录去找 编译器自己知道自己的标准库的头文件在哪里 环境变量和编译器命令行参数也可以指定寻找头文件的目录 4.11 头文件 （.h文件） 在使用和定义这个函数的地方都应该 #include 这个头文件 一般的做法就是任何.c都有对应的同名的.h,把所有对外公开的函数的原型和全局变量的声明都放进去 在函数前面加上static 就使得它成为只能在所在的编译单元中被使用的函数 在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量 4.12 变量的声明123// add.hint add(int a, int b);extern int gAll; // 全局声明一个 变量 int i； 是变量的定义 extern int i； 是变量的声明 4.13声明和定义 声明是不产生的代码的东西 函数原型 变量声明 结构声明 宏声明 枚举声明 类型声明 inline函数 定义是产生代码的东西 10. typedef 为已有的数据类型改名 typedef 已有的数据类型 新名字; 1234567typedef int INT;int main () &#123; INT i; printf(D, i); exit(0);&#125; 5.1 typedef 和 define的区别12345#define IP int *typedef int *IP;IP p,q --&gt; int *p, q;IP p,q --&gt; int *p, *q; ** 更多示例** 12typedef int ARR[6]; ---&gt; int [6] -&gt; ARR;ARR a; --&gt; int a[6]; 123456789101112131415161718192021222324252627struct node_st&#123; int i; float f;&#125;;typedef struct node_st NODE;NODE a; --&gt; struct node_st a;NODE *p; --&gt; struct node_st *p;typedef struct node_st *NODEP;NODEP p --&gt; struct node_st *p;struct&#123; int i; float f;&#125;NODE, *NODEP;typedef int FUNC(int); --&gt; int(int) FUNC;FUNC f; --&gt; int f(int);typedef int *FUNCP(int);FUNCP p; ---&gt; int *p(int);typedef int *(*FUNCP)(int);FUNCP p; ---&gt; int *(*p)(int); 数组类型 数组名[常量表达式] 12float sheep[10]int a2001[1000] 11. 一唯数组1.1.1 定义 【存储类型】 数据类型 标识符 【下标】 1.1.2 初始化不初始化全部初始化部分初始化 123456int main () &#123; int a[] = &#123;1,2,3,4&#125; // 不给长度也行 int b[4] = &#123;1,2&#125; // [1,2,0,0] 部分元素初始化 int c[4] = &#123;0&#125; // [0,0,0,0] 部分元素初始化 int d[4] = &#123;1,2,3,4,5,6&#125; // compile error&#125; 1.1.3 元素引用 数组名【下标】 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3int main()&#123; int arr[M]; int i; printf(\"%d\\n\", sizeof(arr)); for(; i&lt;M; i++) printf(\"%p-&gt;%d\\n\", &amp;arr[i], arr[i]); exit(0);&#125;// 0x7ffee4394940-&gt;-466007712// 0x7ffee4394944-&gt;32766// 0x7ffee4394948-&gt;201064485 下标 查找块 1.1.4 数组名 当前数组的起始位置，数组名本身就是表示地址的一个常量。 常量： 程序执行过程当中不会发生变化的量；正因为数组名是常量，所以它不能无条件出现在数组的左边； 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3int main()&#123; int arr[M] = &#123;1,2,3&#125;; int i; arr[M] = &#123;4,5, 6&#125;; // 语法错误，数组名是常量，无法被直接赋值 printf(\"%d\\n\", sizeof(arr)); for(; i&lt;M; i++) printf(\"%p-&gt;%d\\n\", &amp;arr[i], arr[i]); exit(0);&#125; 1.1.5 数组越界 溢出数组所在内存区域 1.1.6 fb12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main() &#123; int fib[10] = &#123;1,1&#125;; int i; for (i =2; i&lt;10; i++) fib[i] = fib[i-1] + fib[i-2]; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); printf(\"\\n\"); return; &#125; 12345678910111213141516171819202122232425262728293031// fb加个排序 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int fib[10] = &#123;1,1&#125;; int i; int j; int tmp; for (i =2; i&lt;10; i++) fib[i] = fib[i-1] + fib[i-2]; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); printf(\"\\n\"); i=0; j=sizeof(fib)/sizeof(fib[0]) -1; while(i&lt;j) &#123; tmp = fib[i]; fib[i] = fib[j]; fib[j] = tmp; i++; j--; &#125; for (i=0;i&lt;10;i++) printf(\"%d\\n\",fib[i]); return; &#125; 12. 二维数组1.2.1 定义，初始化 【存储类型】 数据类型 标识符 【行下标】 【列下标】 123int a[3][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;int b[][4] = &#123;1,2,3,4,5,6,7,8,9&#125;;int c[3][4] = &#123;0&#125;; 1234int main()&#123; int a[M][N]&#125; 1.2.2 二维数组元素引用数组名[行标][列标]int a[3][4] // 定一个三行四列的二维数组 1.2.3 存储形式 顺序存储，按行存储,二维数组在内存中的存储， 是拉平的 12345678910111213141516171819202122232425----------a[0][0]----------a[0][1]----------a[0][2]----------a[0][3]----------a[1][0]----------a[1][1]----------a[1][2]----------a[1][3]----------a[2][0]----------a[2][1]----------a[2][2]----------a[2][3]---------- 深入理解二维数组 1 a[0][0] 2 a[0][1] 3 a[0][2] 4 a[0][3] 5 a[1][0] 6 a[1][1] 7 a[1][2] 8 a[1][3] 9 a[2][0] 10 a[2][1] 11 a[2][2] 12 a[2][3] 1.2.4 二维数组练习题1.2.4.1 行列互换123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 3int main()&#123; int arr[M][N] = &#123;1,2,3,4,5,6&#125;; int b[N][M]; int i,j; for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; b[j][i] = arr[i][j]; printf(\"%d\",arr[i][j]); &#125; printf(\"\\n\"); &#125;; for (i=0;i&lt;N;i++) &#123; for (j=0;j&lt;M;j++) printf(\"%d\", b[i][j]); printf(\"\\n\"); &#125; exit(0);&#125; 1.2.4.2 求最大值及其所在位置12345678910111213141516171819202122232425262728293031#define M 2#define N 3static void max(void)&#123; int a[M][N] = &#123;43,4,23,89,9,7&#125;; int i,j; int max = a[0][0], row =0, col = 0; for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; if(a[i][j]&gt;max) &#123; max= a[i][j]; row = i; col = j; &#125; &#125; &#125; printf(\"%d\\n\",max); printf(\"%d --- %d\\n\", row, col);&#125;int main()&#123; int arr[M][N] = &#123;1,2,3,4,5,6&#125;; int b[N][M]; int i,j; max(); exit(0);&#125; 1.2.4.3 求各行与各列的和 123456789101112131415161718192021222324252627282930static void sum(void)&#123; int a[5][4] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;,&#123;10,11,12&#125;&#125;; int i, j; for (i=0; i&lt;4; i++) &#123; for (j=0;j&lt;3;j++) &#123; a[4][3] += a[i][j]; a[4][j] += a[i][j]; a[i][3] += a[i][j]; &#125; &#125; for(i=0;i&lt;5;i++) &#123; for(j=0;j&lt;4;j++) &#123; printf(\"%4d\",a[i][j]); &#125; printf(\"\\n\"); &#125;&#125;int main()&#123; sum(); exit(0);&#125; 1.2.4.4 矩阵乘积123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 3#define K 2 static void mul(void) &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125; ; int b[N][K]= &#123;1,0,0,1,1,0&#125;; int c[M][K]; int i,j,k; for(i=0;i&lt;M;i++) &#123; for(j=0;j&lt;K;j++) &#123; for(k=0; k&lt;N; k++) &#123; c[i][j] += a[i][k] * b[k][j]; &#125; &#125; &#125; for(i=0;i&lt;M;i++) &#123; for(j=0;j&lt;K;j++) &#123; printf(\"%4d\",c[i][j]); &#125; printf(\"\\n\"); &#125; &#125; int main() &#123; mul(); exit(0); &#125; 1.2.5 深入理解二维数组 1.2.5.1 三维数组a[5][3][4] 数据立方体 5 -&gt; 片3 -&gt; 行4 -&gt; 列 在内存中依然是打平存放； 13. 字符数组1.3.1 定义，初始化，存储特点 【存储类型】 数据类型 标识符 【下标】。。。 1.3.1.1 单个字符初始化1char str[3] = &#123;'a','b','c'&#125; char c[] = {‘C’, ‘h’, ‘i’, ‘n’, ‘a’};// c[0] = C c[1] = h c[2]= i c[3]=n c[4]=a 1.3.1.2 用字符串常量初始化1char str1[6] = \"hello\"; // 最后一位 以 '\\0' 结尾 char c[] = “China”// c[0] = C c[1] = h c[2]= i c[3]=n c[4]=a c[5]=\\0 1.3.2 输入输出1234567891011int main()&#123; char str[N], str1[N], str2[N]; int i; scanf(\"%s%s%s\", str, str1,str2); printf(\"%s\\n%s\\n%s\\n\", str, str1,str2);&#125;// how are you// how// are// you 1.3.2.1 单词计数12345678910111213141516171819202122#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; char str[128]; int count =0, flag = 0; int i; gets(str); for(i=0;str[i]!='\\0';i++) &#123; if(str[i]==' ') flag = 0; else if(flag == 0) &#123; count++; flag=1; &#125; &#125; printf(\"count = %d\\n\", count); &#125; 1.3.3 字符数组注意事项 所有字符串都是以 \\0 来结尾的；所有以 \\0结尾 的字符数组都可以被看为字符串 123456char c[6] = \"China\"; //只可以在数组定义并初始化的时候// 不能用赋值语句将一个字符串常量或字符数组直接赋给另一个字符数组str1[] = \"China\" // 赋值，不合法str1 = \"China\" // 赋值，不合法str2 = str1 // 赋值，不合法 指针 变量与地址 指针与指针变量 直接访问与间接访问 空指针与野指针 空类型指针 定义，初始化，书写规则 指针运算 指针与数组 指针与一维数组 指针与二维数组 指针与字符数组 const与指针 指针数组和数组指针 多级指针 14. 变量与地址变量名： 变量名就是用户对某一块内存空间的抽象表示；想把这块儿内存置成100，就写int i = 100;变量名就是某个内存空间的别名； 地址： 指针就是地址，指针就是指向某个内存空间地址的地址值； 1.1 变量的三要素int a = 3 在内存中， 即产生 0x0012FF78，3，a 三个要素。 0x0012FF78即变量的地址， 把这个变量的地址称为“指向该变量的指针”； 3即变量值； a即变量的签名； 1.2 输出变量的地址地址运算符 “&amp;” int a = 3; printf(&quot;%x&quot;, &amp;a) 15. 指针与指针变量语法 TYPE NAME = VALUE； 12int i = 1; // type 为 intint * p = &amp;i; // type 为 int *, 而不是 int 2.1 非法操作（野指针）12int * p = &amp;i; // 合法操作，指针一旦定义出来，就要给一个明确指向；没有的话，下回分解int * p = 0x7fffa37eac60; // 可能这个地址已经被占用了，一般情况下，是个非法操作； 2.2 指针变量 专门用于存放指针（某个变量的地址）的变量 123456789101112int c = 76;int * pointer; //定义名字为pointer的指针变量；只能存放地址！// int *pointer;// 1) int 是指针变量的基类型 所谓基类型：指针变量指向的变量的类型// 2) * 是指针运算符，表示pointer这个变量的类型// 3) pointer 是指指针变量的名字pointer = &amp;c;// 将变量c 的地址赋值给指针变量pointer；// 赋值后，称指针变量pointer指向了变量c； 则*pointer： 为pointer所指向的存储单元的内容；是变量c。因此*pointer可以当作 变量c 来使用 2.3 指针变量的地址 指针变量也是变量，是变量就有地址 12345678910int main() &#123; int a = 13; int * p = &amp;a; *p = 100; printf(P, p); printf(P, &amp;p); // 指针变量也有地址； // 0x7ffee6a26ac8 // 0x7ffee6a26ac0 return 0;&#125; 2.4 指针变量示例12345678910111213int main()&#123; int a = 0, b=3, temp; int *p1 = NULL, *p2 = NULL; p1 = &amp;a; p2 = &amp;b; printf(\"%p\\n\", &amp;a); printf(\"%p\\n\", &amp;b); if(*p1 &lt; *p2) &#123; temp = *p1; *p1 = *p2; *p2 = temp; &#125; printf(\"%d\\n\", *p1); // 3 printf(\"%d\\n\", *p2); // 0&#125; 2.5 指针作运算 (取地址 和 取 * 和关系运算) 2.5.1 取地址 要获取某个变量在内存中的房间号 2.5.2 取* 找到现在给定房间号里面存放的内容 16. 直接访问和间接访问3.1一级间接访问和 二级间接访问1234567891011121314int main ()&#123; int i = 1; int *p = &amp;i; int **q = &amp;p; printf(P, p); // 0x7ffee92579b8 printf(P, q); // 0x7ffee92579b0 printf(P, *q); // 0x7ffee92579b8 printt(D, i); // 1 直接访问 printf(D, *p); // 1 一级间接访问 printf(D, **q);// 1 二级间接访问 exit(0);&#125; 3.2 指针关系运算 当两个指针指向的是一块连续内存空间的时候， 比如两个指针指向同一个数组。在这种情况下，两个指针可以做一个关系上的比较； ++ -- ++ – 运算实际上改变指针位置； 3.3 指针变量类型与指针变量大小12345678910111213141516171819202122int main ()&#123;int i = 1;int * p;float *q;double *d;printf(D, sizeof(i)); // 8printf(D, sizeof(p)); // 8printf(D, sizeof(q)); // 8printf(D, sizeof(d)); // 8// 结构体指针的大小也是8/** 不管指针是多少级的指针，不管指针是什么样的类型。指针在某个平台下所占的地址空间是确定的。那既然如此为何 要给指针变量加类型呢，比如 int *p, float *q. 那是因为有 *p 取* 的操作，比如*q的时候，怎么就能知道去对应地址读取 4个字节呢？ 这个时候就要靠 指针变量的 变量类型加持了。所以这个变量类型之间的意义 就不尽相同了。*/char * s;s = &amp;i;printf(D, *s); // 这个时候，不知道要去读取 4个字节，所以结果不是1；&#125; 17. 空指针与野指针12345int main ()&#123; int * p = NULL;// 指针被定义出来，还未决定指向哪里的时候，可以先指向NULL，系统上 0 号不分配给任何进程；把指针置为空是为了预防野指针； exit(0);&#125; 4.1 野指针 当前这个指针的指向是不确定的，或者压根就没有指向；但是直接使用这个指针了。 1234567int main()&#123; int *p; printf(\"%p --&gt; %d\\n\", p ,*p); // 0x7ffee67879d8---&gt;0&#125; 1234567int main()&#123; int *p; printf(\"%p --&gt; %d\\n\", p ,*p); *p = 1; // 段错误&#125; 4.1.1 如何杜绝野指针 指针一经定义，就必须有一个明确的指向，没有暂时没有指向的话，就先指向NULL； 18. 空类型1void * p = NULL; // 即 空类型 void * 是一个百搭的类型，任何类型的指针值都可以赋值给它。void * 也可以把自己的值赋值给任何类型的指针； 5.1 空类型的使用场景1void *memcpy(void *dest, const void *src, size_t n); 19. 运算符优先级 上面优先级比下面高 后置++ – 前置++ – 逻辑非 (!) * &amp; // 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高 算术运算符 关系运算符 &amp;&amp;和｜｜ 赋值运算符 同级别，优先级由右往左结合顺序， 离目标越近，优先级越高 如 12&amp;*pointer = &amp;(*pointer)*&amp;a = *(&amp;a) (*pointer)++ 不等于 *pointer++ (pointer)++ 是先 做取运算，得到的int类型自增， pointer++ 则是 指针变量移位，然后再取运算 *pointer++ 的含义 假设： pointer当前所存的地址是0x00000100 若pointer 的指针变量基类型是 指向一个 int或实型（占4个字节），则pointer++ 等于 iptr + 1*4 = 0x00000104 若pointer 指向一个 字符型（占1个字节），则pointer++ 等于 iptr + 1*1 = 0x00000101 12345678910111213int main() &#123; int a[5] = &#123;5,11,19,21,33&#125;; int *p = NULL; printf(P, a); // 0x7ffee0eeda20 p = a; printf(P, p); // 0x7ffee0eeda20 printf(D, *p); // 5 printf(D, *p++); // 5 printf(D, *p++); // 11 printf(D, *p); // 19 return 0;&#125;*p++ 是地址移动 ** 小结** 指针和指针变量是不同的。指针是地址，指针变量就是一个普通的变量。pointer指的是这个指针变量 所指向的那片内存空间里面的内容。(pointer)++ 不等于 *pointer++ 20. 指针与数组 数组名代表数组首元素的地址 （数组名相当于指向数组第一个元素的指针）；数组名不是变量，不能给a赋值；int *p = &amp;a[0]; a++是没有意义的（a只是个常量），但p++会引起p变化。p可以指向数组最后一个元素以后的元素。指针做加减运算时一定注意有效的范围；（指针理论上能够在内存中自由的漂移，很可能移除某一个数组的范围，有的时候就比较危险了） 7.1 数组名代表数组首元素的地址 数组名是指向数组第一个元素的指针； 对于数组a[10], 数组名 a代表数组 a[10]中第一个元素a[0]的地址； 即 a 与 a[0]等价 注意： a是地址常量，不是变量，不能给a赋值； 7.2 创建一个匿名数组 指针和数组的关系，其实就是一种引用方式而已。你的一维数组名和一级指针之间的关系其实除了一个是变量，一个是常量之外。完全可以等价代换。 1234567int main()&#123; int *p = (int [3])&#123;1,2,3&#125;; int i; for (i=0;i&lt;3;i++) printf(D, p[i])&#125; 7.3 利用指针变量引用数组元素 若定义 数组 int a[10]; 指针 int * pointer; 则: pointer =a; 等价于pointer = &amp;a[0]; 数组访问 pointer+ i; 等价于 a+i; 等价于 &amp;a[i]; *(pointer+i); 等价于 *(a+i); 等价于a[i]; 表示形式 pointer[i] 等价于 *(pointer+i); 1234567891011121314151617int main () &#123; int a[9] = &#123;4,5,6,7,8,9,1,2,3&#125;; int *p = NULL; p = a; // a 是 数组的地址， printf(\"%d\\n\", *p); // 4 printf(\"%d\\n\", *p++); // 4 ++的含义是先使用p，然后再++ printf(\"%d\\n\", *p); // 5 printf(\"%d\\n\", *++p); // 6 前+ 和 后+ 跟js一样 printf(\"%d\\n\", p[0]); // 因为p=a了，所以p[0] 即a[0] printf(\"%d\\n\", p[1]); printf(\"%d\\n\", p[2]); printf(\"%d\\n\", p[3]); printf(\"%d\\n\", p[4]); return 0;&#125; 7.4 抽象公式12345int * p = a;// a[i]: a[i] = *(a+i) = *(p+i) = p[i];// &amp;a[i]: &amp;a[i] = a+i = p+i = &amp;p[i];p = a; 7.5 重置指针变量1234567891011int a[3];int *p = a;int i;for (i=0; i&lt;sizeof(a)/sizeof(*a); i++) scanf(\"%d/n\", p++);p = a; // 这里需要 重置一下 p的指针；不然会数组越界；for (i=0; i&lt;sizeof(a)/sizeof(*a); i++) printf(\"%d\", *p++); 7.6 需要注意的问题 int * p = &amp;a[0]; , * a++是没有意义的（因为a是个常量），但p++会引起p变化；* p可以指向数组最后一个元素以后的元素；（因为p是内存中的一个指针），所以指针做加减运算时一定注意有效的范围。 123456int a[5],int *iPtr = &amp;a[1];iPtr--; // 指向&amp;a[0]*iPtr = 3; // a[0] = 3iPtr--; // 指向&amp;a[-1], dangerous*iPtr = 6; // (damage) 对内存造成损坏，影响内存中其他的变量 示例 123456789int main()&#123; int a[5] = &#123;6,7,8,9,0&#125;; int *p = &amp;a[3]; *p = 100; printf(\"%d\\n\", *p++); // 100 printf(\"%d\\n\", *p--); // 0 printf(\"%d\\n\", *--p); // 8 return 0;&#125; 7.7 指向二维数组的指针7.7.1 遍历数组元素1234567891011121314151617181920212223242526272829303132int main()&#123; int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int *p; for (p= &amp;a[0][0] ;p &lt; &amp;a[0][0]+12; p++) &#123; printf(\"%d\\n\", *p); &#125; return 0;&#125;// 0x7ffeefbff4f0// 1// 0x7ffeefbff4f4// 3// 0x7ffeefbff4f8// 5// 0x7ffeefbff4fc// 7// 0x7ffeefbff500// 9// 0x7ffeefbff504// 11// 0x7ffeefbff508// 13// 0x7ffeefbff50c// 15// 0x7ffeefbff510// 17// 0x7ffeefbff514// 19// 0x7ffeefbff518// 21// 0x7ffeefbff51c// 23 如上所示， 会将这个数组的内容都打印出来了，因为二维数组会被拉平存储到一段连续的内存空间当中 7.7.2 二维数组行列指针12345678910111213141516171819202122232425262728293031323334353637383940414243 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define M 3 #define N 4 #define D \"%d\\n\" #define P \"%p\\n\" int main () &#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i, j; printf(\"&amp;a = %p, &amp;a+1 = %p\\n\", &amp;a, &amp;a+1); printf(\"%&amp;a[0][0] = %p, &amp;a[1][0] = %p\\n\", &amp;a[0][0], &amp;a[1][0]); for (i=0;i&lt;M;i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%p---&gt;%d\\n\", &amp;a[i][j], a[i][j]); &#125; printf(\"\\n\"); &#125; exit(0); &#125;// &amp;a = 0x7ffefe385370, &amp;a+1 = 0x7ffefe3853a0// %&amp;a[0][0] = 0x7ffefe385370, &amp;a[1][0] = 0x7ffefe385380// 0x7ffefe385370---&gt;1// 0x7ffefe385374---&gt;2// 0x7ffefe385378---&gt;3// 0x7ffefe38537c---&gt;4// 0x7ffefe385380---&gt;5// 0x7ffefe385384---&gt;6// 0x7ffefe385388---&gt;7// 0x7ffefe38538c---&gt;8// 0x7ffefe385390---&gt;9// 0x7ffefe385394---&gt;10// 0x7ffefe385398---&gt;11// 0x7ffefe38539c---&gt;12 小结： 所以a除了是二维数组的数组名（地址常量）之外，在使用上比较偏向一个指向行指针。 7.7.3 能够接收二维数组指针的指针变量引子 1234567891011&#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i=0, j=0; int *p = NULL; p =&amp;a[i][j]; // *(a+0) , *a for (i=0; i&lt;12; i++,p++) // for (i=0; i&lt;12; i++) printf(\"%d \", *p); // printf(\"%d \", p[i]); printf(\"\\n\"); exit(0); // 1 2 3 4 5 6 7 8 9 10 11 12 &#125; 7.7.4 另一段程序123456789int main()&#123; int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int (*p)[4], i,j; p = a; cin&gt;&gt;i&gt;&gt;j; // i&lt;3 代表行号， j&lt;4 代表列号； cout &lt;&lt; setw(4) &lt;&lt; *(*(p+i)+j); // 正误判断： 访问元素 a[i][j] return 0;&#125; 程序分析 从 p = a 开始 a相当于指向a[3][4]的“第一个元素”的指针； 所谓“第一个元素”是指一个“包含4个int型元素的一维数组”； 所以，a相当于一个“包含4个int型元素的一维数组”的地址； 因此，p的基类型应该是： “包含4个int型元素的一维数组” 变量定义语句的语法为： int (*p)[4]; *p(数组) p -&gt; | (p)[0] | (p)[1] | (p)[2] | (p)[3] | 7.7.5 利用指针变量引用多维数组中的数组((p+i)+j)是什么？ p 是指向一个“包含4个int型元素的一维数组”； p+i 是第i+1个“包含4个int型元素的一维数组”的地址; p+i 等价于&amp;a[i]； *(p+i)等价于a[i]； *(p+i)+j 等价于 a[i]+j; // 这里把a[i] 当作一个指针来看 因此， a[i]+j 等价于 &amp;a[i][j]; ((p+i)+j) 等价于 a[i][j]; 7.8 指针与字符数组12345678910111213 int main () &#123; char s[] = \"i love coding!\"; // codeing char *p = s+7; printf(\"%s\\n\", s+7); puts(s); puts(p); // puts(p) 相当于把p的起始位置拿进来， 依次输出，直到碰到\\0 为止； exit(0); &#125;// coding!// i love coding!// coding! 7.8.1 字符数组拼接12345678910#include &lt;string.h&gt;int main()&#123; char str[] = \"hello\"; // str = \"world\" false strcpy(str, \"world123\"); // 覆盖原来数组空的每一项 puts(str); // world123 exit(0);&#125;// world123 7.8.2 字符串长度和字符串字节数12char str[] = \"hello\";printf(\"%d ,%d\", sizeof(str), strlen(str)); // 6, 5 7.8.3 字符指针跟字符数组的区别12345678char *str = \"hello\";sizeof(str); // 8 指针变量不分类型 ， 64位系统下长度都是8个字节， 32位系统为4个字节；strlen(str); // 5 字符串长度strcpy(str, \"world\"); // 段错误， 字符指针跟字符数组的区别就在于此。因为str 指向的是一个 字符串常量的地址， strcpy是一个覆盖写操作，显然，企图去更改一个常量是无效的。之所以是常量，是串常量，这个串在当前存储位置是特殊的。在使用上不允许被改变和覆盖。// 正确的做法str = \"world123\"; //更改指针指向；puts(str); 21. 字符串与指针 指向字符串的指针 指向字符串的指针变量： char a[10]; char *p; p=a; 数组和字符串太接近了。那怎么去定义指向字符串的指针呢？也很简单， 我首先定义一个字符数组，它就是用来存放字符串的。 我们以前讲过字符串和字符数组其实区别就在于有没有最后的反斜杠零， 本质上都是字符数组。 123456789101112int main()&#123; int a = 5; int *p = &amp;a; char c[6] = &#123;'h', 'e', 'l', 'l', 'o','\\0'&#125;; char *s = c; printf(P, s); // 0x7ffee2066aba printf(P, c); // 0x7ffee2066aba printf(S, s); // hello printf(S, c); // hello s++; printf(S, s); // ello&#125; 8.1 字符串指针举例123456789101112int main() &#123; char buffer[10] = \"ABC\"; char *pc; pc = \"hello\"; // 虽然 hello赋值给了pc，但是却不能通过pc去改变hello， 因为hello是常量，常量在内存中被放在特殊的地方了；这片区域不允许修改； cout &lt;&lt; pc &lt;&lt; endl; // hello pc++; cout &lt;&lt; pc &lt;&lt; endl; // ello cout &lt;&lt; *pc &lt;&lt; endl; // e pc = buffer; cout &lt;&lt; pc; // ABC return 0;&#125; 22. const与指针 const是把某些内容常量化 1234567891011121314const int a;const float pi = 3.14; // 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。int const a;// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思 const int *p;int const *p;// 指针常量int *const p;const int *const p; 9.1 变量值常量化123const int a;const float pi = 3.14; // 约束 pi这个变量值 一直保持是 3.14不变；这种语法实际是在定一个变量，只是把变量的值常量化了。int const a; 9.2 常量指针 指针的指向可以发生变化，但是指针所指向当前的那块内存的值是不可以发生变化的； 123// 常量指针， const int *p; 和 int const *p; 类型在前面或者后面 关系不大，表示相同的意思const int *p;int const *p; 12345678910int main ()&#123; const float pi = 3.14; // float *p = &amp;pi; // 警告： initialization discards ‘const’ qualifier from pointer target type const float *p = &amp;pi; *p = 3.14159; printf(\"%f\\n\", pi); printf(\"%f\\n\", *p); exit(0);&#125; 举例： 1int open(const chart * pathname, int flags); // 常量指针，保护pathname值不被篡改 9.3 指针常量int *const p; 指针常量指 指针的指向永远不能发生变化；但是指针指向的值可以有变化； 9.3.1 引用引用是C++语言的概念，C中并没有； 在《thinking c++》一书中有这么一句，“A reference (&amp;) is like a constant pointer that is automaticallydereferenced.” （引用（＆）就像一个常量指针，它会自动 取消引用） 这句话是什么意思呢？ 9.4 如何区分到底是 常量指针，还是指针常量1234const int *p; // 如果先碰到const关键字，就把常量先念出来int const *p; int *const p; // 如果先看到 *，就把指针先念出来 9.5 两个const修饰const int *const p; 12345678910int main ()&#123; int i = 1; int j = 100; const int * const p = &amp;i; p = &amp;j; // warning 因为p是只读的，不能更改指向； *p = 10; // warning 因为*p 也是只读的；&#125; 9.6 指向符号常量的指针const int * p; 当把p定义成一个指向符号常量的指针的时侯， 然后再让这个p指向什么东西， 它所指向的那个东西就不能被修改了。我们就不能通过p再去修改 它所指向的那个东西了。 深坑啊,要留意 1234567891011121314int main() &#123; const int a = 78; const int b = 28; int c = 18; const int * p1 = &amp;a; *p1 = 58; // (error, *p不能被赋值) p1 = &amp;b; // （可以给 p1 重新赋值） *p1 = 68; // (error, *p不能被赋值) printf(D, *p1); // 28 p1 = &amp;c; // （可以给 p1 重新赋值） *p1 = 88; // (error, *p不能被赋值) printf(D, *p1) // 18&#125; 9.7 再谈一维数组的地址数组名相当于指向数组第一个元素的指针 123456789101112131415int main() &#123; int a[4] = &#123;1,3,5,7&#125;; cout&lt;&lt;a&lt;&lt;endl; // a[1]的地址，管辖范围只有a[1] cout&lt;&lt;&amp;a&lt;&lt;endl; // a[1]的地址，管辖范围是整个a的内存空间 cout&lt;&lt;a+1&lt;&lt;endl; // a[2]的地址 cout&lt;&lt;&amp;a+1&lt;&lt;endl; // 跳出了a的内存范围，理论上是 a[5]的地址 printf(P, a); // 0x7ffee42adab0 printf(P, a+1); // 0x7ffee42adab4 跨越4个字节 printf(P, &amp;a); // 0x7ffee42adab0 printf(P, &amp;a+1); // 0x7ffee42adac0 // 跨越16个字节 printf(P, *(&amp;a)); // 0x7ffee42adab0 printf(P, *(&amp;a) + 1); // 0x7ffee42adab4&#125; 根据C语言的规范 *(&amp;a) 等同于 a; 即a数组第一个元素的内存地址*(&amp;a) + 1 等同于 a+1; 即a数组第二个元素的内存地址 &amp;a的管辖范围是整个数组a。c语言规范中，当它前面出现*时，管辖范围降级，即堕落成了 a[0]的地址； 9.8 总结 数组名相当于指向数组第一个元素的指针 &amp;运算符 - 升级 若 a 是指向数组第一个元素的指针，即a相当于 &amp;a[0]; &amp;a是“指向数组”的指针；&amp;a+1将跨越16个字节； &amp;a相当于管辖范围 “上升” 了一级; *运算符 - 降级*a是数组的第一个元素a[0]；即 *a等价于a[0]； *a 相当于管辖范围“下降”了一级； 9.9 指向二维数组的指针 二维数组的定义 二维数组a[3][4]包含三个元素： a[0] a[1] a[2] 每个元素都是一个“包含四个整型元素”的数组 | 1 a[0][0] | 2 a[0][1] | 3 a[0][2] | 4 a[0][3] || 5 a[1][0] | 6 a[1][1] | 7 a[1][2] | 8 a[1][3] || 9 a[2][0] | 10 a[2][1]| 11 a[2][2]| 12 a[2][3]| - 二维数组的第一个元素是a[0]; - a[0]是一个“包含四个整形元素”的一维数组； 推论 a 与 &amp;a[0] 等价a[0] 与 &amp;a[0][0] 等价a[0] 与 a 等价a[0][0] 与 *a 等价 9.10 总结三条规律1） 数组名相当于指向数组第一个元素的指针；2） &amp;E相当于把E的管辖范围上升了一个级别；3） *E相当于把E的管辖范围下降了一个级别； 23. 指针与函数10.1 指针用作函数参数123456789101112131415161718void Rank(int *q1, int *q2) &#123; int temp; if (*q1 &lt; *q2)&#123; temp = *q1; *q1 = *q2; *q2 = temp; &#125;&#125;int main() &#123; int a, b, *p1, *p2; scanf(a); scanf(b); p1 = &amp;a; p2 = &amp;b; Rank(p1, p2); // 指针传递，即地址传递 printf(\"%d\\n\", a); printf(\"%d\\n\", b); return 0;&#125; 10.2 将数组名作为实参123456789101112void sum(int *p, int n) &#123; int total = 0; for (int i=0; i&lt;n; i++)&#123; total += *p++; &#125; printf(\"%d\\n\", total); // 6&#125;int main() &#123; int a[3] = &#123;1,2,3&#125;; sum(a, 3); // 将数组名作为实参赋给指针型形参 return 0;&#125; 10.3 “数组名” 做形参12345678910111213// c++ 编译器将形参数组名 作为 指针变量来处理！int sum(int array[], int n)&#123; for (int i=0; i&lt;10-1; i++) &#123; *(array+1) = *array + *(array+1); // 数组从第二项开始，每一项都等于自己加上前一项的和； array++; &#125; return *array;&#125;int main() &#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; printf(\"%d\\n\", sum(a, 10)); return 0;&#125; 当程序里，把一个指针变量或者是数组的名字，传递给一个函数的时候，是挺危险的，因为这个函数拿到的，是这个变量或者是数组的地址， 它拿到了地址，它就可以直接对地址里面存放的这些值，进行肆意的修改，那有没有一种办法，可以呢 使我既能够把这个地址传递给某个函数，又能够确保不让这个函数随意的修改这片地址里面的值呢？ 如何 “限制” 指针的功能 如何“限制”指针实参的功能 10.4 即指向符号常量的指针123456789101112int sum(const int array[], int n)&#123; // 补充为const for (int i=0; i&lt;10-1; i++) &#123; *(array+1) = *array + *(array+1); // array变成常量之后，无法修改 array++; &#125; return *array;&#125;int main() &#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; printf(\"%d\\n\", sum(a, 10)); return 0;&#125; 符号常量声明语句 const 数组类型 常量名 = 常量值； 数据类型 const 常量名 = 常量值； 10.5 指针用作函数返回值函数的返回值可以是多种类型 返回整形数据的函数 int max(int x, int y); 返回指针类型数据的函数 int *min(int x, int y) 函数名字前面表示函数的类型 * 123456789101112// int arr[][4] 除了这么定义，还可以 int *(arr)[4]int *get(int arr[][4], int n, int m) &#123; int *pt; pt = *(arr+n-1) + m-1; return (pt);&#125;int main() &#123; int a[4][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16&#125;; int *p; p = get(a, 2,3); printf(\"%d\\n\", *p);&#125; 分析一下返回结果， 又一个需要注意的深坑 1234567891011int *getInt1() &#123; int value1 = 20; return &amp;value1;&#125;int main() &#123; int *p; p = getInt1(); printf(\"%d\\n\", *p); // 这里会打印未知数，也可能会打印20；为什么呢，因为随着getInt1的运行时完毕，导致它函数内部的所有引用被释放了。所以返回的地址&amp;value1 指向的内存空间被释放掉了；所以谁也不会知道这个地址现在存放的是个啥，如果该块内存没有被新写入值，那么还是20；新写入的话，那就是新的未知量了； return 0;&#125; 验证 1234567891011121314151617int *getInt1() &#123; int value1 = 20; return &amp;value1;&#125;int *getInt2() &#123; int value2 = 30; return &amp;value2;&#125;int main() &#123; int *p, *q; p = getInt1(); q = getInt2(); printf(\"%d\\n\", *p); // 这里大概率会是30 return 0;&#125; 那既然如此，有什么办法解决这个问题 静态局部变量 123456789101112131415161718int *getInt1() &#123; static int value1 = 20; return &amp;value1;&#125;int *getInt2() &#123; static int value2 = 30; return &amp;value2;&#125;int main() &#123; int *p, *q; p = getInt1(); q = getInt2(); printf(\"%d\\n\", *p); // 20 printf(\"%d\\n\", *q); // 30 return 0;&#125; 什么是静态局部变量 ** 静态局部变量 ** 函数中局部变量的值在函数调用结束后不消失而保留原值 即其占用的存储单元不释放，在下一次该函数调用时，仍可以继续使用该变量； 12345678910111213141516171819202122void function() &#123; int a = 0; static int b = 0; // 有点像 hooks，只初始化一次，后续不再重新将其赋值为0； a = a+1; b = b+1; printf(\"%d\\n\", a); printf(\"%d\\n\", b);&#125;int main() &#123; for (int i =3; i&lt;3;i--)&#123; function(); &#125; return 0;&#125;// 1// 1// 1// 2// 1// 3 小结 指针与函数 指针用做函数参数 函数拿到地址可对其所指内容进行修改； 可以使用const来“限制”指针的功能； 指针用做函数返回值 必须确保函数返回的地址是有意义的； 返回全局变量或静态局部变量；24. 指针数组和数组指针11.1 数组指针 归根结底是一个指针，是指向数组的指针。 【存储类型】 数据类型 （*指针名）【下标】 = 值； 如： int (*p)[3]; ---&gt; type name ----&gt; int[3] *p 解析： 定义一个指针变量 p, 用来指向 int[3] 类型的元素的起始位置。原来 int * p 的时候，p+1 的操作是移动一个 int 的大小。如果p的类型 变成了 int [3]的话，p+1的操作是一下移动三个 int 元素的大小。所以数组指针是在某种 大小的数组中进行移动。 12345678910111213141516171819202122232425262728293031323334353637383940int main () &#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int i=0, j=0; int *p = *a; int (*q)[N]= a; printf(\"%p %p\\n\", a, a+1); printf(\"%p %p\\n\\n\", q, q+1); for (i =0; i&lt;M; i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%p -&gt; %d\\n\", *(a+i)+j, *(*(a+i)+j)); // printf(\"%p -&gt; %d\\n\", *(q+i)+j, *(*(q+i)+j)); // a 和 q现在是等价的，区别只是一个是常量，一个是变量； &#125; printf(\"\\n\"); &#125; exit(0); &#125;// 0x7ffd6f5ad1f0 0x7ffd6f5ad200// 0x7ffd6f5ad1f0 0x7ffd6f5ad200// 0x7ffd6f5ad1f0 -&gt; 1// 0x7ffd6f5ad1f4 -&gt; 2// 0x7ffd6f5ad1f8 -&gt; 3// 0x7ffd6f5ad1fc -&gt; 4// 0x7ffd6f5ad200 -&gt; 5// 0x7ffd6f5ad204 -&gt; 6// 0x7ffd6f5ad208 -&gt; 7// 0x7ffd6f5ad20c -&gt; 8// 0x7ffd6f5ad210 -&gt; 9// 0x7ffd6f5ad214 -&gt; 10// 0x7ffd6f5ad218 -&gt; 11// 0x7ffd6f5ad21c -&gt; 12 11.2 指针数组 归根结底是一个数组 【存储类型】 数据类型 * 数组名 【长度】 如： int * arr[3]; ---&gt; TYPE NAME ---&gt; int *[3] arr; 11.3 指针数组与数组指针的区别1234567891011121314151617181920212223242526272829int main()&#123; int i, k, j; // 指针数组 char *name[5] = &#123;\"Follow me\", \"Basic\", \"Great\", \"Fortran\", \"Computer\"&#125;; char *tmp; for (i = 0; i &lt; 5 - 1; i++) &#123; k = i; for (j = i + 1; j &lt; 5; j++) &#123; if (strcmp(name[k], name[j]) &gt; 0) &#123; k = j; &#125; &#125; if (k != i) &#123; tmp = name[i]; name[i] = name[k]; name[k] = tmp; &#125; &#125;; for (i = 0; i &lt; 5; i++) &#123; puts(name[i]); &#125;; return 0;&#125; 25 .多级指针 12345Line1 int num = 1;Line2 int *p = &amp;numLine3 int *p1 = p;Line4 int **p2 = &amp;p1;Line5 int ***p3 = &amp;p2; 多级指针的本质，只是C语言的一个书写规范，事实上任何指针都可以保存任何地址； 多级指针的存储的值的推理过程 12345Line1 int num = 1;Line2 int *p = &amp;numLine3 int *p1 = p;Line4 int **p2 = &amp;p1;Line5 int ***p3 = &amp;p2; 函数 函数的定义 函数的传参 函数的调用 （嵌套和递归） 函数与数组 函数与指针 （指针函数， 函数指针， 函数指针数组） 26. 函数的定义 数据类型 函数名 （【数据类型 形参名 。。。】） 函数的类型是指 函数的返回值的数据类型 1.1.1 main函数1234567891011121314/** argc： 参数计数器，统计终端上多少个参数传进来 *argv[]： 列表，用来传递刚才命令行传递进来的参数 *argv[]是一个数组； argv 是数组名； char* 指数组中每个元素的类型为 char*；即字符指针 argv 即字符数组指针的首地址；*/int main(int argc, char *argv[]);&#123; printf(\"argc=%d\\n\", argc); exit(0);&#125; 12./main /etc/a*.conf# 4 因为shell 会自动解析通配符，把结果都解析出来。 图示：char * argv 数组模型 ** 输出argv** 12345678int main (int argc, char * argv[]) &#123; int i; // for (i=0; i&lt;argc; i++) for (i=0; argv[i] !=NULL; i++) puts(argv[i]); exit(0);&#125; 1.1.2 C语言使用函数之前也需要先声明 函数在使用前都要声明，除非被调用函数的定义部分已经出现在主调函数之前, 在C语言中，函数声明就是函数原型。 123456789101112#include &lt;stdio.h&gt;void printf_hello(void);// 需要先声明，因为main函数在 printf_hello函数上面int main ()&#123; printf_hello(); return 0;&#125;void printf_hello(void)&#123; printf(\"hello world!\\n\"); return;&#125; 27. 函数的传参1.2.1 值传递12345678910int printf_value(int i, int j) &#123; // 参数i j 随着 print_value 调用栈执行结束就释放掉了。 printf(\"%d%d\\n\", i,l); return 0;&#125;int main() &#123; int i =3; l = 5; printf_value(i,l); return 0;&#125; 1.2.2 地址传递123456789101112int swap (int * i, int * j) &#123; int tmp; tmp = *i; *i = *j; *j = tmp;&#125;int main() &#123; int i =3; l = 5; swap(&amp;i,&amp;l); return 0;&#125; 28. 函数的调用（嵌套调用 和 递归调用）1.3.1 函数的调用方式 函数调用作为独立语句，stringPrint(); 函数作为表达式的一部分,number = max(numA,numB)/2; 以实参形式出现在其他函数的调用中,number = min(sum(-5, 100), numC); 1.3.2 嵌套调用123456789101112131415161718int minus(int a, int b, int c) &#123; return max(a,b,c) - min(a, b, c);&#125;int min(int a, int b, int c) &#123; int tmp = a &lt; b? a :b; return tmp &lt; c ? tmp : c;&#125;int max(int a, int b, int c) &#123; int tmp = a &gt; b? a :b; return tmp &gt; c ? tmp : c;&#125;int main () &#123; int result; int a = 3, b = 5, c = 10; result = minus(a,b,c); printf(\"%d\\n\", result); return 0;&#125; 39. 函数与数组1.4.1 函数与一唯数组问题：封装一个printf_arr方法来遍历数组；应该如何定义 printf_arr 的行参 12345678910111213141516171819202122int printf_arr(int a[])&#123; int i = 0; printf(\"printf_arr ---&gt; %p\\n\", a); // 传入的是 数组 a的 起始地址； for (i=0; i&lt;sizeof(a)/sizeof(a[0]); i++) // 是因为 a的 sizeof为 8， 所以只能访问数组前2位 &#123; printf(\"%d \",a[i]); // 1， 2 &#125; printf(\"\\n\");&#125;int main()&#123; int a[6] = &#123;1,2,3,4,5,6&#125;; printf(\"main ---&gt; %p\\n\",a ); // a 即 &amp;a, 即 &amp;a[0]; printf_arr(a); exit(0);&#125;// main ---&gt; 0x7ffd84a62eb0// printf_arr ---&gt; 0x7ffd84a62eb0 1234567891011void print_arr(int *p)&#123; int i; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(p));// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置&#125;int main()&#123; int a[] = &#123;1,3,5,7,9&#125;; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(a)); // 20，整个数组所占内存的大小，因为每个int是 4个字节； print_arr(a);&#125; ** 解决方法** 将数组的长度，当做第二个参数传入给 子函数。 1234567891011121314void print_arr(int *p, int n)&#123; int i; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(p));// 8, 传进来的是一个地址，8个字节。 这里看不到数组的规模。只能获悉起始位置 for (i=0; i&lt;n; i++) printf(\"%d\\n\", p[i]); // p[i] 与 *(p+i) 等价 printf(\"\\n\");&#125;int main()&#123; int a[] = &#123;1,3,5,7,9&#125;; printf(\"%s:%d\\n\", __FUNCTION__, sizeof(a)); // 20，整个数组所占内存的大小，因为每个int是 4个字节； print_arr(a, sizeof(a)/sizeof(*a));&#125; 12void printf_arr(int p[], int n);// 当 p[] 作为行参时， [] 等同于 * 因此 int p[] 即为 int *p ** 示例** 12345678910111213int main() &#123; int a[N] = &#123;1,2,3,4,5,6&#125;; int *p = a; a -&gt; int * *a即*(a+0) -&gt; int a[0] -&gt; int &amp;a[3] -&gt; int * p[i] -&gt; int p -&gt; int * *p -&gt; int p+1 -&gt; int *&#125; ** 逆序** 12345678910111213141516171819202122void func(int *p, int n) &#123; int i=0, j, m, tmp; m = (n -1)/2; for (;i&lt;=m;i++) &#123; j = n -1 -i; tmp = p[i]; p[i] = p[j]; p[j] = tmp; &#125;&#125;;int main() &#123; int a[0] = &#123;1,3,5,7,9&#125;; for (i =0; i&lt; sizeof(a)/sizeof(*a); i++) printf(\"%d\\n\", a[i]); printf(\"\\n\"); func(a, sizeof(a)/sizeof(*a)); for (i =0; i&lt; sizeof(a)/sizeof(*a); i++) printf(\"%d\\n\", a[i]); printf(\"\\n\"); return 0;&#125; 1.4.2 函数与二维数组12345678910111213141516171819 int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; int i = 0; int j = 0; for (i = 0; i&lt; M; i++) &#123; for (j=0;j&lt;N;j++) &#123; printf(\"%d \", a[i][j]); &#125; printf(\"\\n\"); &#125; exit(0); &#125;// 1 2 3// 4 5 6 问题： 同样的把输出放到一个独立的函数中去，也就是考察一下 二维数组应该如何给函数传参 这个问题实际考察点在于 二维数组如何 过实参给函数，以及函数的二维数组行参应该如何定义 1234567891011121314151617181920212223// 第一种, 用一个二维数组的指针去接收int arr_traverse(int (*p) [N], int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;n;i++) &#123; printf(\"%d \",*(*p+i)); // 关键点在这里， 首先 p 指向的是 int [3] 这个类型。所以需要降级 为列指针 &#125;; printf(\"\\n\"); &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M*N); // *a === a[0] === *(a+0) exit(0); &#125; 1234567891011121314151617181920212223// 第二种，用一个普通一维数组指针去接收int arr_traverse(int *p, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;n;i++) &#123; printf(\"%d \",*(p+i)); &#125;; printf(\"\\n\"); &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(&amp;a[0][0], M*N); // 传递的是列指针 exit(0); &#125; 12345678910111213141516171819202122232425262728// 第三种 void arr_traverse(int (*p)[N],int m, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;m;i++) &#123; for (j=0; j&lt;n;j++) &#123; printf(\"%d \",*(*(p+i)+j)); &#125; &#125;; printf(\"\\n\"); return; &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M,N); exit(0); &#125; 1234567891011121314151617181920212223242526// 第四种void arr_traverse(int p[][N],int m, int n) &#123; // printf(\"%p\\n\", p); // printf(\"%d\\n\", n); int i = 0; int j = 0; for (i=0;i&lt;m;i++) &#123; for (j=0; j&lt;n;j++) &#123; printf(\"%d \", p[i][j]); &#125; &#125;; printf(\"\\n\"); return; &#125; int main() &#123; int a[M][N] = &#123;1,2,3,4,5,6&#125;; printf(\"a ---&gt; %d\\n\", sizeof(*a)); printf(\"%p\\n\", a); arr_traverse(a, M,N); exit(0); &#125; ** 小结 ** 123int a[M][N] = &#123;...&#125;;int * p = *a;int (*q)[N] = a; 二维数组 参与传参的一些基本内容 a[i][j] *(a+i)+j a[i]+j p[i] *p q[i][j] *q === *(q+0) q p+3 q+2 int int * int * int int int int * int (*)[N] int * int (*)[N] 1.4.2.1 示例： 求平均数1234567891011121314151617181920212223242526float average_score(int *p, int n)&#123; int i; float sum = 0; for (i=0; i&lt;n; i++) &#123; sum += p[i]; &#125; return sum/n;&#125;find_num(int (*p)[N], int num)&#123; int i = 0; for (i =0; i&lt;N; i++) &#123; printf(\"%d\\n\", *(*(p+num)+i)); &#125;&#125;int main ()&#123; int num = 1; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; average_score(*a, M*N); find_num(a, num);&#125; 1.4.2.2 二维数组什么时候传行指针，什么时候传列指针 当不区分行列的时候，可以把它当作一个大的一维数组。那就传递指针。 如果要区分行列来做某件事情的时候，那就需要把行指针传递过去。 1.4.3 函数与字符数组1234567int main () &#123; char str1[] = \"helloworld\"; char str2[128]; strcpy(str2, str1); //实现了拷贝 exit(0);&#125; 123456789101112131415//实现一个 mystrcpy 用于拷贝char * mystrcpy(char * dest, const char * src) &#123; char *ret = dest; if (dest != NULL &amp;&amp; src != NULL) while((*dest++ = *src++) != '\\n'); return ret;&#125;int main () &#123; char str1[] = \"helloworld\"; char str2[128]; mystrcpy(str2, str1); //实现一个 mystrcpy 用于拷贝 puts(str2); // 测试一下 exit(0);&#125; 123456789101112131415161718//实现一个 mystrncpy 用于拷贝char * mystrncpy(char *dest, const char * src, size_t n) &#123; int i=0; for (; i&lt;n &amp;&amp; (dest[i] = src[i]); i++) ; for (; i&lt;n; i++) dest[i] = '\\0'; return dest;&#125;int main () &#123; char str1[] = \"helloworld\"; char str2[128]; mystrncpy(str2, str1, 5); //实现一个 mystrcpy 用于拷贝 puts(str2); // 测试一下 exit(0);&#125; 30. 函数与指针 指针函数, 函数指针, 函数指针数组 1.5.1 指针函数 一个函数的返回值为指针，即为指针函数 返回值 * 函数名(形参);如： int * fun(int); 引子 123456789101112131415161718// 从find_num 这个函数说起，这个函数并不纯，而且没有实现它的功能；void find_num(int (*p)[N], int num)&#123; int i; for(i=0;i&lt;N;i++) &#123; printf(\"%d\", *(*(p+num)+i)); &#125; printf(\"\\n\");&#125;int main()&#123; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; float ave; int num = 0; find_num(a, num); // find_num 的设计不应该没有返回值；&#125; 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 3#define N 4int * find_num(int (*p)[N], int num) // 将find_num 设计成为一个指针函数&#123; if (num &gt; M -1) return NULL; return *(p+num);&#125;int main()&#123; int i, j; int * res; int a[M][N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; float ave; int num =0; res = find_num(a, num); if (res != NULL) &#123; for (i=0;i&lt;N;i++) printf(\"%d\",res[i]); printf(\"\\n\"); &#125; else &#123; printf(\"can not find\\n\"); &#125;&#125;; 1.5.2 函数指针 一个指针指向的是函数， 在C语言里面。你并不能用一个普通变量去接收 函数啊，或者结构体等等数据类型，必须要使用相同的类型变量去接收相同的类型。比如函数要用函数指针变量去接收； 类型 (指针名) （形参） 如： int (p)(int); 123456789101112131415int add (int a, int b)&#123; return a+b;&#125;int main()&#123; int a=3, b=5; int ret; int (*p)(int, int); // 定义一个函数指针 p = add; // 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址， 也可以写成 p = &amp;add;这里之所以省略，是因为函数名(add)本身就是一个地址。所以在指针和函数的指向关系当中，地址符可以省略。同样的 `ret = *p(a, b)`； p前面的 *也可以省略。 `ret = p(a, b)`。指向函数的指针，让这个指针指向某一个函数的入口地址。下面通过指针来传参数就如同通过函数名来传参数是一样的； ret = p(a, b); printf(\"%d\\n\",ret); exit(0);&#125; 1.5.3 函数指针数组引子 12345678910111213141516171819202122int add (int a, int b)&#123; return a+b;&#125;int sub (int a, int b)&#123; return a*b;&#125;int main()&#123; int a=3, b=5; int ret1, ret2; int (*p)(int, int); // 定义一个函数指针 int (*q)(int, int); // 这里面定义两个相同的 函数指针有点浪费 p = add; // 这个指针 能够指向一个函数， 因为add 本身就是这个函数的地址 ret1 = p(a, b); ret2 = q(a, b); printf(\"%d\\n\",ret1); printf(\"%d\\n\",ret2; exit(0);&#125; 1.5.4 引出函数指针数组语法： 类型 （数组名[下标]）（形参）；如: int (arr[N])(int);arr是一个数组，这个数组有N个元素。这N个元素都是指向函数的指针。 1234567891011121314151617181920212223242526int main()&#123; int a=3, b=5; int ret1, ret2; int i; // int (int, int) *funcp[2]; funcp这个数组有两个指针，两个指针都是指向 int (int, int) 类型的函数； 转换一种写法就是 int (*funcp[2])(int, int); // p = add; // q = sub; // ret1 = p(a, b); // ret2 = q(a, b); funcp[0] = add; funcp[1] = sub; for (i=0; i&lt;2; i++) &#123; ret1 = funcp[i](a, b); printf(\"%d\\n\",ret1); &#125; // printf(\"%d\\n\",ret1); // printf(\"%d\\n\",ret2; exit(0);&#125; 1.5.5 指向指针函数的函数指针数组 int *(*func[N])(int) 31. 函数的执行过程1.6.1 main函数 —— 函数执行的入口 遇到函数，开辟内存空间； 在内存空间再碰到函数时候， 初始化内嵌函数； 传递参数 保存外层函数执行空间 执行完毕后。。。。释放函数执行栈 接收函数的返回值 恢复现场，从断点处继续执行 1.6.2 参数的传递 实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”。即拷贝 函数调用时，系统给行参分配存储单元，并将实参对应的值传递给形参； P.S. 实参与形参的类型必须相同或可以兼容； 1.6.3 变量的作用范围局部变量与全局变量 根据变量在程序中作用范围的不同，可以将变量分为局部变量和全局变量 局部变量在函数内或块内定义，只在这个函数或块内其作用的变量； 全局变量在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。 当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量 32. 数组与函数 数组名 做函数参数 1234567891011void change(int a[]) &#123; a[0] = 30; a[1] = 50;&#125;int main() &#123; int a[2] = &#123;3, 5&#125;; change(a); // 地址传递， 数组的名字代表着数组所在的地址； printf(\"%d, %d,\", a[0], a[1]); // 30 50 return 0&#125; 33. 缓冲区1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; // __FUNCTION__ 当前所在的函数， // __LINE__ 当前所在的行数 printf(\"[%s:%d]before\", __FUNCTION__, __LINE__); while(1); printf(\"[%s:%d]after\", __FUNCTION__, __LINE__); exit(0);&#125;./printf// 发现两个printf都没打印出来东西 ** 缓冲机制 ** 由于使用了终端设备，所以原本默认是全缓冲模式变成了行缓冲模式。所以printf是遇到了 \\n 才去刷新缓冲区的。或者是当前等缓冲区满了去自动刷新。\\n 是去强制刷新缓冲区。 没有加\\n 那个“before”这句话就放到了输出缓冲区当中，什么时候刷新呢？ 要么等程序结束自动刷新IO，要么就是遇到一些强制刷新的函数iflush 这种，要么就等到缓冲区攒满了一次性去刷新。 34. 动态内存管理 在编写程序时，通常并不知道需要处理的数据量，或者难以评估所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，就需要动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存管理原理； 以下几个函数都存在标准 stdlib.h 中 1.9.1 malloc calloc （分配新的内存区域）void *malloc(size_t, size); 它会在堆上分配这块连续的内存空间，并返回起始地址； void *calloc(size_t nmemb, size_t size) 一个成员 size个大小，nmemb这么多成员的空间；连续申请多块 size大的内存 1234567891011121314int *p;p = malloc(sizeof(int));if (p == NULL)&#123; printf(\"error\");&#125;else&#123; *p = 10; printf(\"%d\\n\", *p);&#125;;free(p); // 用完记得释放掉内存， 在同一个函数中做到 malloc 和 free一一对应printf(\"%d\\n\", *p);exit(0); 12345678910111213int *p;int num = 5;p = malloc(sizeof(int) * num);for (int i= 0 ;i&lt;num; i++) &#123; scanf(\"%d\", &amp;p[i]);&#125;for (int j=0; j&lt;num; j++) &#123; printf(\"%d \", p[j]);&#125;printf(\"\\n\");free(p);exit(0); *一道面试题 (提示： 这个程序当中已经产生了内存泄漏) * 12345678910111213141516void func(int *p, int n) &#123; p = malloc(n); if (p == NULL) exit(1); // p在这个函数当中是一个局部变量，随着func执行完毕之后，这块内存空间会丢失。导致内存泄漏，只有随着操作系统中这个进程结束掉，才会释放这100个单位的内存 return;&#125;int main()&#123; int num = 100; int *p = NULL; func(p, num); free(p); exit(0);&#125; 改法一： 12345678910111213141516void func(int **p, int n) &#123; // 用一个二级指针来接受 *p = malloc(n); // 此时*p 就是main函数中的p if (*p == NULL) exit(1); return;&#125;int main()&#123; int num = 100; int *p = NULL; func(&amp;p, num); free(p); exit(0);&#125; 改法二： 123456789101112131415161718void func(int *p, int n)&#123; p = malloc(n); if (p == NULL) exit(1); return p;&#125;int main()&#123; int num = 100; int *p = NULL; p = func(p, num); // 用p 来接触返回值 free(p); exit(0);&#125; 1.9.2 realloc （调整已分配的内存区域）void *realloc(void *ptr, size_t size); 重新分配一块动态的内存空间 ,比如之前用malloc calloc分配的内存空间太大或者太小，现在把 起始地址传进去(第一个参数); 然后要size 大小的这么一段(第二个参数)；所以 realloc会在当前地址往下继续扩展，凑足size返回回来；当然，如果*ptr 开始的这个区段，没有一整块size大小的空间，那么就会去别的内存上面去寻找。直到找到之后，再返回那块空间的起始地址回来； 1.9.3 free （释放已分配的内存区域） 原则， 谁申请谁释放， （防止内存泄露）；如果不能做到在同一函数中做到谁申请谁释放 就在同一模块中做到这些； 123456789101112131415161718int *p;int num = 10;p = malloc(sizeof(int));if (p == NULL)&#123; exit(1);&#125;;*p = 10;printf(\"%d\\n\", *p); // 10// 测试地址printf(\"%p--&gt;%d\\n\", *p); // 0xa--&gt;0free(p); // 正确的做法是p = NULL; // 正确的做法是，一个指针free了之后，立即赋值 NULL// free 代表着 变量p对于那片 内存空间 没有了 控制权限；所以free之后要 p = NULL*p = 123; // 实际上这是个野指针，该块内存释放掉了，有可能被其他人用来声明变量了。这里重新赋值，相当于可能把别人的变量给覆盖了printf(\"%d\\n\", *p); // 123 // 测试地址printf(\"%p--&gt;%d\\n\", *p); // 0x7b--&gt;145574408","categories":[{"name":"language","slug":"language","permalink":"http://yoursite.com/categories/language/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"ts declaration files","slug":"ts-declaration-files","date":"2021-01-21T03:16:49.000Z","updated":"2021-02-09T10:28:11.416Z","comments":true,"path":"2021/01/21/ts-declaration-files/","link":"","permalink":"http://yoursite.com/2021/01/21/ts-declaration-files/","excerpt":"","text":"10. Declaration Files10. 1 Declaration Reference本节显示一些API的文档以及该API的示例用法，并说明如何编写相应的声明。 10.1.1 具有属性的对象12345// codelet result = myLib.makeGreeting(\"hello, world\");console.log(\"The computed greeting is:\" + result);let count = myLib.numberOfGreetings; 12345// 声明declare namespace myLib &#123; function makeGreeting(s: string): string, let numberOfGreetings: number;&#125; 10.1.2 Overloaded Functions1234567// code let x : Widget = getWidget(43);let arr: Widget[] = getWidget(\"all of them\");// 声明declare function getWidget(n: number): Widget;declare function getWidget(s: string): Widget[]; 10.1.3 Reusable Types (Interfaces)1234567891011121314// codegreet(&#123; greeting: \"hello world\", duration: 4000&#125;);// 声明interface GreetingSettings &#123; greeting: string; duration?: number; color?: string;&#125;declare function greet(setting: GreetingSettings): void; 10.1.4 Reusable Types (Type Aliases)12345678910111213// code function getGreeting() &#123; return \"howdy\";&#125;class MyGreeter extends Greeter &#123;&#125;greet(\"hello\");greet(getGreeting);greet(new MyGreeter());// 声明// 使用类型别名来简化类型：type GreetingLike = string | (()=&gt; string) | MyGreeter;declare function greet(g: GreetingLike): void; 10.1.5 组织类型1234567891011121314151617181920212223242526272829// codeconst g = new Greeter(\"Hello\");g.log(&#123; verbose: true &#125;);g.alert(&#123; modal: false, title: \"Current Greeting\" &#125;);// 声明// 使用命名空间去组织类型declare namespace GreetingLib &#123; interface LogOptions &#123; verbose?: boolean; &#125; interface AlertOptions &#123; modal: boolean; title?: string; color?: string; &#125;&#125; // 使用嵌套的命名空间来声明declare namespace GreetingLib.Options &#123; // Refer to via GreetingLib.Options.Log interface Log &#123; verbose?: boolean; &#125; interface Alert &#123; modal: boolean; title?: string; color?: string; &#125;&#125; 10.1.6 Classes1234567891011121314151617// codeconst myGreeter = new Greeter(\"hello, world\");myGreeter.greeting = \"howdy\";myGreeter.showGreeting();class SpecialGreeter extends Greeter &#123; constructor() &#123; super(\"Very special greetings\"); &#125;&#125;// 声明// 使用 declare class 来描述类或类对象。类可以具有属性和方法以及构造函数。declare class Greeter &#123; constructor(greeting: string); greeting: string; showGreeting(): void;&#125; 10.1.7 Global Variables1234// codeconsole.log(f00/2);// 声明declare var foo: number 10.1.8 Global Functions1234// codegreet(\"hello\");// 声明declare function greet(str: string):void; 10.2 Library Structures针对不同类型的库，编写对应类型的声明文件。你是通过cdn获取这些库还是通过npm获取；你是require引入还是import引入； 10.2.1 模块化的库几乎每个现代的Node.js库都属于模块家族。这些类型的库仅在带有模块加载器的JS环境中工作。例如，express仅在Node.js中有效，并且必须使用CommonJS require函数加载。 12345var fs = require(\"fs\");import * as fs from \"fs\";var someLib = require(\"someLib\");define(..., ['someLib'], function(someLib) &#123;&#125;); 从代码中识别模块库 Unconditional calls to require or define Declarations like import * as a from &#39;b&#39;; or export c; Assignments to exports or module.exports They will rarely have: Assignments to properties of window or global 10.2.1.1 Modules.d.ts 常见的Commonjs 模式 123456789101112131415const maxInterval = 12;function getArrayLength(arr) &#123; return arr.length;&#125;module.exports = &#123; getArrayLength, maxInterval,&#125;;// This can be described by the following .d.ts:export function getArrayLength(arr: any[]): number;export const maxInterval: 12; Es module 1234567export function getArrayLength(arr) &#123; return arr.length;&#125;// This would have the following .d.ts equivalent:export function getArrayLength(arr: any[]): number; Default Exports 12345// codemodule.exports = /hello( world)?/;// .d.tsdeclare const helloWorld: RegExp;export default helloWorld; CommonJS中的一种导出样式是导出函数。由于函数也是对象，因此可以在导出中添加额外的字段。 1234567891011function getArrayLength(arr) &#123; return arr.slice;&#125;getArrayLength.maxInterval = 12;module.exports = getArrayLength;// Which can be described with:export default function getArrayLength(arr: any[]): number;export const maxInterval: 12;// 需要在 tsconfig.json 中设置 esModuleInterop: true 如果没有在 tsconfig.json 中设置 esModuleInterop: true 123456declare function getArrayLength(arr: any[]): number;declare namespace getArrayLength &#123; declare const maxInterval: 12;&#125;// 使用 export= 语法export = getArrayLength; 模块中的类型 可能需要提供一种不存在的JavaScript代码类型 123456789101112131415161718192021222324252627// code function getArrayMetadata(arr) &#123; return &#123; length: getArrayLength(arr), firstObject: arr[0], &#125;;&#125;module.exports = &#123; getArrayMetadata,&#125;;// describedexport type ArrayMetadata = &#123; length: number; firstObject: any | undefined;&#125;export function getArrayMetadata(arr: any[]):ArrayMetadata;// 泛型优化版export type ArrayMetadata&lt;ArrType&gt; = &#123; length: number; firstObject: ArrType | undefined;&#125;;export function getArrayMetadata&lt;ArrType&gt;( arr: ArrType[]): ArrayMetadata&lt;ArrType&gt;; Namespaces in Module Code 试图描述JavaScript运行时的关联可能很棘手。如果类似ES模块的语法没有提供足够的工具来描述导出，则可以使用名称空间。 您可能有足够复杂的类型来描述，因此您选择在.d.ts中对它们进行命名空间： 123456789101112131415161718// 运行时可用的JavaScript类export class API &#123; constructor(baseURL: string); getInfo(opts: API.InfoRequest): API.InfoResponse;&#125;// This namespace is merged with the API class and allows for consumers, and this file// to have types which are nested away in their own sections.declare namespace API &#123; export interface InfoRequest &#123; id: string; &#125; export interface InfoResponse &#123; width: number; height: number; &#125;&#125; 您可以使用export as namespace声明模块将在UMD上下文中的全局范围内可用 1export as namespaces moduleName; Template 为了让您了解所有这些部分如何组合在一起，这里是制作新模块时的参考.d.ts。 1234567891011121314151617181920212223242526272829// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*如果此模块是在模块加载程序环境之外加载时公开全局变量“ myLib”的UMD模块，请在此处声明该全局变量。否则，删除此声明。 */export as namespace myLib;/*~ If this module exports functions, declare them like so. */export function myFunction(a: string): string;export function myOtherFunction(a: number): number;/*~ You can declare types that are available via importing the module */export interface SomeType &#123; name: string; length: number; extras?: string[];&#125;/*~ You can declare properties of the module using const, let, or var */export const myField: number; 库文件布局 123456myLib +---- index.js +---- foo.js +---- bar +---- index.js +---- baz.js 声明文件布局应为 123456@types&#x2F;myLib +---- index.d.ts +---- foo.d.ts +---- bar +---- index.d.ts +---- baz.d.ts 12345// thest could be imported asvar a = require(\"myLib\");var b = require(\"myLib/foo\");var c = require(\"myLib/bar\");var d = require(\"myLib/bar/baz\"); Testing your types If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you: Create a new folder in node_modules/@types/[libname] Create an index.d.ts in that folder, and copy the example in See where your usage of the module breaks, and start to fill out the index.d.ts When you’re happy, clone DefinitelyTyped/DefinitelyTyped and follow the instructions in the README. Otherwise Create a new file in the root of your source tree: [libname].d.ts Add declare module &quot;[libname]&quot; { } Add the template inside the braces of the declare module, and see where your usage breaks 10.2.1.2 module:function1234import greeter from \"super-greeter\";greeter(2);greeter(\"Hello world\"); 如果模块可以像一个函数一样被调用，需使用module-function 模版 要同时通过UMD和模块引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for function modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' */// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style:// import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import:// import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myFuncLib;/*~ This declaration specifies that the function *~ is the exported object from the file */export = Greeter;/*~ This example shows how to have multiple overloads for your function */declare function Greeter(name: string): Greeter.NamedReturnType;declare function Greeter(length: number): Greeter.LengthReturnType;/*~ If you want to expose types from your module as well, you can *~ place them in this block. Often you will want to describe the *~ shape of the return type of the function; that type should *~ be declared in here, as this example shows. *~ *~ Note that if you decide to include this namespace, the module can be *~ incorrectly imported as a namespace object, unless *~ --esModuleInterop is turned on: *~ import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS! */declare namespace Greeter &#123; export interface LengthReturnType &#123; width: number; height: number; &#125; export interface NamedReturnType &#123; firstName: string; lastName: string; &#125; /*~ If the module also has properties, declare them here. For example, *~ this declaration says that this code is legal: *~ import f = require('super-greeter'); *~ console.log(f.defaultName); */ export const defaultName: string; export let defaultLength: number;&#125; 10.2.1.2 module:class1234const Greeter = require(\"super-greeter\");const greeter = new Greeter();greeter.greet(); 如果导出的对象是一个类的话； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file for class modules. *~ You should rename it to index.d.ts and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' */// Note that ES6 modules cannot directly export class objects.// This file should be imported using the CommonJS-style:// import x = require('[~THE MODULE~]');//// Alternatively, if --allowSyntheticDefaultImports or// --esModuleInterop is turned on, this file can also be// imported as a default import:// import x from '[~THE MODULE~]';//// Refer to the TypeScript documentation at// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require// to understand common workarounds for this limitation of ES6 modules./*~ If this module is a UMD module that exposes a global variable 'myClassLib' when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myClassLib;/*~ This declaration specifies that the class constructor function *~ is the exported object from the file */export = MyClass;/*~ Write your module's methods and properties in this class */declare class MyClass &#123; constructor(customGreeting?: string); greet: void; myMethod(opts: MyClass.MyClassMethodOptions): number;&#125;/*~ If you want to expose types from your module as well, you can *~ place them in this block. *~ *~ Note that if you decide to include this namespace, the module can be *~ incorrectly imported as a namespace object, unless *~ --esModuleInterop is turned on: *~ import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS! */declare namespace MyClass &#123; export interface MyClassMethodOptions &#123; width?: number; height?: number; &#125;&#125; 10.2.1.3 Module: pluginIf you have a module which when imported, makes changes to other modules use template 12const jest = require('jest');require(\"jest-matchers-files\"); when you want to work with JavaScript code which extends another library. 123456789import &#123; greeter &#125; from \"super-greeter\";// Normal Greeter APIgreeter(2);greeter(\"Hello world\");// Now we extend the object with a new function at runtimeimport \"hyper-super-greeter\";greeter.hyperGreet(); The definition for “super-greeter” 12345678/*~ This example shows how to have 多个重载 for your function */export interface GreeterFunction &#123; (name: string): void (time: number): void&#125;/*~ This example shows how to export 一个接口指定的function */export const greeter: GreeterFunction; We can extend the existing module like the following: 12345678910111213141516171819202122// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module plugin template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*~ On this line, import the module which this module adds to */import &#123; greeter &#125; from \"super-greeter\";/*~ Here, declare the same module as the one you imported above *~ then we expand the existing declaration of the greeter function */export module \"super-greeter\" &#123; export interface GreeterFunction &#123; /** Greets even better! */ hyperGreet(): void; &#125;&#125; 10.2.2 Global Libraries全局库是可以从全局范围访问的库（即，无需使用任何形式的导入）。许多库只是公开一个或多个全局变量供使用。例如jquery; 123$(() =&gt; &#123; console.log(\"hello\");&#125;) 12&lt;!--一般情况，全局库的使用方式 --&gt;&lt;script src=\"http://a.great.cdn.for/someLib.js\"&gt;&lt;/script&gt; 现在，最流行的可全局库 实际上是作为 UMD标准 编写的（请参见下文）。 UMD库文档很难与全局库文档区分开。在编写全局声明文件之前，请确保该库不是UMD。 从代码中识别Global Library 查看全局库的代码时，通常会看到： Top-level var statements or function declarations One or more assignments to window.someName Assumptions that DOM primitives like document or window exist You won’t see: Checks for, or usage of, module loaders like require or define CommonJS/Node.js-style imports of the form var fs = require(&quot;fs&quot;); Calls to define(...) Documentation describing how to require or import the library 10.2.2.1 Global.d.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ If this library is callable (e.g. can be invoked as myLib(3)), *~ include those call signatures here. *~ Otherwise, delete this section. */declare function myLib(a: string): string;declare function myLib(a: number): number;/*~ If you want the name of this library to be a valid type name, *~ you can do so here. *~ *~ For example, this allows us to write 'var x: myLib'; *~ Be sure this actually makes sense! If it doesn't, just *~ delete this declaration and add types inside the namespace below. */interface myLib &#123; name: string; length: number; extras?: string[];&#125;/*~ If your library has properties exposed on a global variable, *~ place them here. *~ You should also place types (interfaces and type alias) here. */declare namespace myLib &#123; //~ We can write 'myLib.timeout = 50;' let timeout: number; //~ We can access 'myLib.version', but not change it const version: string; //~ There's some class we can create via 'let c = new myLib.Cat(42)' //~ Or reference e.g. 'function f(c: myLib.Cat) &#123; ... &#125; class Cat &#123; constructor(n: number); //~ We can read 'c.age' from a 'Cat' instance readonly age: number; //~ We can invoke 'c.purr()' from a 'Cat' instance purr(): void; &#125; //~ We can declare a variable as //~ 'var s: myLib.CatSettings = &#123; weight: 5, name: \"Maru\" &#125;;' interface CatSettings &#123; weight: number; name: string; tailLength?: number; &#125; //~ We can write 'const v: myLib.VetID = 42;' //~ or 'const v: myLib.VetID = \"bob\";' type VetID = string | number; //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);' function checkCat(c: Cat, s?: VetID);&#125; 10.2.2.2 Global: Modifying Module导入全局变量的模块会在全局范围内更改现有值。例如，可能存在一个库，该库在导入时将新成员添加到String.prototype。由于存在运行时冲突的可能性，该模式有些危险，但是我们仍然可以为其编写声明文件。 识别全局修改模块 全局修改模块通常易于从其文档中识别，它们类似全局插件，但是需要require方法的调用 才能激活它们的副作用； 123456789101112// 'require' call that doesn't use its return valuevar unused = require(\"magic-string-time\");/* or */require(\"magic-string-time\");var x = \"hello, world\";// Creates new methods on built-in typesconsole.log(x.startsWithHello());var y = [1, 2, 3];// Creates new methods on built-in typesconsole.log(y.reverseAndSort()); 123456789101112131415161718192021222324252627282930313233// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the global-modifying module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for \"super-greeter\", this *~ file should be 'super-greeter/index.d.ts' *//*~ Note: If your global-modifying module is callable or constructable, you'll *~ need to combine the patterns here with those in the module-class or module-function *~ template files */declare global &#123; /*~ Here, declare things that go in the global namespace, or augment *~ existing declarations in the global namespace */ interface String &#123; fancyFormat(opts: StringFormatOptions): string; &#125;&#125;/*~ If your module exports types or values, write them as usual */export interface StringFormatOptions &#123; fancinessLevel: number;&#125;/*~ For example, declaring a method on the module (in addition to its global side effects) */export function doSomething(): void;/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */export &#123;&#125;; 10.2.3 UMDUMD模块既可以用作模块（通过import），也可以用作全局模块（在没有模块加载器的环境中运行时）。这样编写了许多流行的库，例如Moment.js。 1234// nodejs 环境下import moment = require('moment');// 浏览器环境下console.log(mement.format()); umd模版 12345678910111213141516(function (root, factory) &#123; if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define([\"libName\"], factory); &#125; else if (typeof module === \"object\" &amp;&amp; module.exports) &#123; module.exports = factory(require(\"libName\")); &#125; else &#123; root.returnExports = factory(root.libName); &#125;&#125;(typeof self !== 'undefined' ? self : this, function (b) &#123; // Use b in some fashion. // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;)); UMD库的文档通常还会演示一个显示require的“在Node.js中使用”示例，以及一个使用script标记加载该脚本的“在浏览器中使用”示例。 10.2.4 Consuming Dependencies你的库可能具有集中依赖关系，下面会说明如何将它们导入声明文件； Dependencies on Global Libraries If your library depends on a global library, use a /// &lt;reference types=&quot;...&quot; /&gt; directive: 123/// &lt;reference types=\"someLib\" /&gt;function getThing(): someLib.thing; Dependencies on Modules If your library depends on a module, use an import statement: 123import * as moment from \"moment\";function getThing(): moment; Dependencies on UMD libraries From a Global Library If your global library depends on a UMD module, use a /// &lt;reference types directive: 123/// &lt;reference types=\"moment\" /&gt;function getThing(): moment; From a Module or UMD Library If your module or UMD library depends on a UMD library, use an import statement: 1import * as someLib from \"someLib\"; Do not use a /// &lt;reference directive 来声明对UMD库的依赖！ 10.2.5 Preventing Name Conflicts编写全局声明文件时，可以在全局范围内定义许多类型。强烈不建议这样做，因为当项目中有许多声明文件时，它可能导致无法解决的名称冲突。 库定义的任何全局变量只声明 namespaces 12345678declare namespace cats &#123; interface KittySettings &#123;&#125;&#125; // But not // at top-level interface CatsKittySettings&#123;&#125; This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users. 10.3 Do’s and Don’ts10.3.1 基本类型不要使用Number,String,Boolean, Symbol, or Object 等类型； 10.3.2 anyany类型你懂得，尽量别用。anyScript毫无意义； 10.3.3 Callback Types对于返回值被忽略的回调，别使用any, 使用void更好； 12345678/* WRONG */function fn(x: () =&gt; any) &#123; x();&#125;/* OK */function fn(x: () =&gt; void) &#123; x();&#125; 10.3.4 重载和回调函数不要编写仅在回调函数上有所不同的单独重载： 12345678910111213/* WRONG */declare function beforeAll(action: () =&gt; void, timeout?: number): void;declare function beforeAll( action: (done: DoneFn) =&gt; void, timeout?: number): void;// ok// Do write a single overload using the maximum arity:declare function beforeAll( action: (done: DoneFn) =&gt; void, timeout?: number): void; 原因：回调忽略参数始终是合法的，因此不需要较短的重载。首先提供一个较短的回调允许输入错误类型的函数，因为它们与第一个重载匹配。 10.3.5 function 重载不要在更具体的重载之前放置更一般的重载； 1234567891011121314151617/* WRONG */declare function fn(x: any): any;declare function fn(x: HTMLElement): number;declare function fn(x: HTMLDivElement): string;var myElem: HTMLDivElement;var x = fn(myElem); // x: any, wat?// 通过将更一般的签名放在更具体的签名之后来对重载进行排序/* OK */declare function fn(x: HTMLDivElement): string;declare function fn(x: HTMLElement): number;declare function fn(x: any): any;var myElem: HTMLDivElement;var x = fn(myElem); // x: string, :) 原因：TypeScript在解决函数调用时选择第一个匹配的重载。当较早的过载比较晚的过载“更普遍”时，较晚的过载实际上是隐藏的，无法调用。 10.3.6 Use Optional Parameters不要写一些仅在尾随参数上有所不同的重载 1234567891011/* WRONG */interface Example &#123; diff(one: string): number; diff(one: string, two: string): number; diff(one: string, two: string, three: boolean): number;&#125;/* OK */interface Example &#123; diff(one: string, two?: string, three?: boolean): number;&#125; 10.3.7 Union Types不要只在一个参数位置编写因类型而异的重载 1234567891011121314151617181920/* WRONG */interface Moment &#123; utcOffset(): number; utcOffset(b: number): Moment; utcOffset(b: string): Moment;&#125;/* OK */interface Moment &#123; utcOffset(): number; utcOffset(b: number | string): Moment;&#125;function fn(x: string): void;function fn(x: number): void;function fn(x: number | string) &#123; // When written with separate overloads, incorrectly an error // When written with union types, correctly OK return moment().utcOffset(x);&#125; 10.4 Deep Dive10.4.1 Namespaces类型可以存在于名称空间中。例如，如果我们有声明let x：A.B.C，则说类型C来自A.B命名空间。A， B 不一定必须是类型或者值 10.4.2 简单组合，一个名字多种含义给定名称A，我们最多可以找到A的三种不同含义：类型，值或名称空间。名称的解释方式取决于所使用的上下文。例如，在一个声明文件中 中 let m：A.A = A ;，首先将A用作namespaces，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！ 10.4.2.1 User Combinations123456789// foo.d.tsexport var SomeVar: &#123; a: SomeType &#125;;export interface SomeType &#123; count: number;&#125;// consumedimport * as foo from \"./foo\";let x: foo.SomeType = foo.SomeVar.a;console.log(x.count); 这种方法不错，但我们可能会认为 SomeType 和 SomeVar 紧密相关，因此您希望它们具有相同的名称。我们可以使用合并相同的名称Bar呈现这两个不同的对象； 123456789// foo.d.tsexport var Bar: &#123;a : Bar&#125;;export interface Bar &#123; count: number&#125;// consumedimport &#123; Bar &#125; from \"./foo\";let x: Bar = Bar.a;console.log(x.count); 我们在这里使用Bar作为类型和值。请注意，我们不必将Bar值声明为Bar类型，它们是独立的。 10.4.2.2 Advanced Combinations某些声明可以跨多个声明进行组合，比如 class C {} 和 interface C{} 可以共存，并且都给类型C贡献了属性。 只要不造成冲突，就是合法的，一般的经验法则是， 值始终会与同名的其他值发生冲突，除非将它们声明为namespaces,； s, types will conflict if they are declared with a type alias declaration (type s = string), and namespaces never conflict. Adding using an `interface 1234567891011121314151617181920212223interface Foo &#123; x: number;&#125;// ... elsewhere ...interface Foo &#123; y: number;&#125;let a: Foo = ...;console.log(a.x + a.y); // OK// this also works with classesclass Foo &#123; x: number;&#125;// ... elsewhere ...interface Foo &#123; y: number;&#125;let a: Foo = ...;console.log(a.x + a.y); // OK// Note that we cannot add to type aliases (type s = string;) using an interface. Adding using a namespace 可以使用namespace声明以任何不会造成冲突的方式添加新的类型，值和namespace。 123456// 给class添加一个静态成员class C &#123;&#125;namespace C &#123; export let x: number;&#125; let y = C.x; // OK 在此示例中，我们向C的静态侧（其构造函数）添加了一个值。这是因为我们添加了一个值，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。 We could also add a namespaced type to a class: 123456class C &#123;&#125;// ... elsewhere ...namespace C &#123; export interface D &#123;&#125;&#125;let y: C.D; // OK 在我们为其编写 namespace 声明之前，没有 namespace C。作为命名空间的C的含义与该类创建的C的值或类型的含义不冲突。 我们可以使用名称空间声明执行许多不同的合并; 12345678910111213namespace X &#123; export interface Y &#123;&#125; export class Z &#123;&#125;&#125;// ... elsewhere ...namespace X &#123; export var Y: number; export namespace Z &#123; export class C &#123;&#125; &#125;&#125;type X = string; In this example, the first block creates the following name meanings: A value X (because the namespace declaration contains a value, Z) A namespace X (because the namespace declaration contains a type, Y) A type Y in the X namespace A type Z in the X namespace (the instance shape of the class) A value Z that is a property of the X value (该class的构造函数) The second block creates the following name meanings: A value Y (of type number) that is a property of the X value A namespace Z A value Z that is a property of the X value A type C in the X.Z namespace A value C that is a property of the X.Z value A type X 10.5 Publish to npm10.5.1 两种发布方法 bundling with your npm package publishing to the @types organization on npm. 12345678/// &lt;reference path=\"...\" /&gt;// Don’t use /// &lt;reference path=\"...\" /&gt; in your declaration files./// &lt;reference path=\"../typescript/lib/typescriptServices.d.ts\" /&gt;// Do use /// &lt;reference types=\"...\" /&gt; instead./// &lt;reference types=\"typescript\" /&gt; 10.5.2 Packaging dependent declarationsIf your type definitions depend on another package: Don’t combine it with yours, keep each in their own file. Don’t copy the declarations in your package either. Do depend on the npm type declaration package if it doesn’t package its declaration files. 10.5.3 Publish to @typesPackages under the @types organization are published automatically from DefinitelyTyped using the types-publisher tool. To get your declarations published as an @types package, please submit a pull request to DefinitelyTyped. You can find more details in the contribution guidelines page. 10.6 Find and Install Declaration Files loadsh 1npm install @types/lodash 123456// 如果 npm install 了 类型声明import * as _ from \"lodash\";_.padStart(\"hi\", 20, \"\");// or if you’re not using modules, you can just use the global variable _._.padStart(\"Hello TypeScript!\", 20, \" \");","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts modules","slug":"ts-modules","date":"2021-01-20T11:42:30.000Z","updated":"2021-02-09T10:28:43.410Z","comments":true,"path":"2021/01/20/ts-modules/","link":"","permalink":"http://yoursite.com/2021/01/20/ts-modules/","excerpt":"","text":"6. Modules6.1 import/export模块是在自己的范围内执行的，而不是在全局范围内执行的；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用导出形式之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种导入形式将其导入。 模块是声明性的，模块之间的关系是根据文件级别的导入和导出指定的； 模块使用模块加载器相互导入， 在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。 6.1.1 export可以通过添加export关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。 123export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125; 重命名导出 1234567class ZipCodeValidator implements StringValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s);&#125;&#125;export &#123; ZipCodeValidator &#125;;export &#123; ZipCodeValidator as mainValidator &#125;; 重新导出不会将其导入本地，也不会引入局部变量。 12345678export class ParseIntBasedZipCodeValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; parseInt(s).toString() === s;&#125;&#125;// Export original validator but rename itexport &#123; ZipCodeValidator as RegExpBasedZipCodeValidator &#125; from \"./ZipCodeValidator\"; 导出所有 123456export * from \"./StringValidator\"; // exports 'StringValidator' interfaceexport * from \"./ZipCodeValidator\"; // exports 'ZipCodeValidator' class and 'numberRegexp' constant valueexport * from \"./ParseIntBasedZipCodeValidator\"; // exports the 'ParseIntBasedZipCodeValidator' class// and re-exports 'RegExpBasedZipCodeValidator' as alias// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'// module. 6.1.2 import12345678910// single exportimport &#123; ZipCodeValidator &#125; from \"./ZipCodeValidator\";// renamedimport &#123; ZipCodeValidator as ZCV &#125; from \"./ZipCodeValidator\";let myValidator = new ZCV();// 将整个模块导入单个变量，并使用它来访问模块导出import * as validator from \"./ZipCodeValidator\";let myValidator = new validator.ZipCodeValidator();// 某些模块会设置一些可由其他模块使用的全局状态。这些模块可能没有任何出口import \"./my-module.js\" 6.1.3 default exports 默认导出 ​ 每个模块可以选择导出默认导出。默认导出用关键字default标记；每个模块只能有一个默认导出。默认导出使用其他导入形式导入。 ​ 默认出口真的很方便。例如，像jQuery之类的库可能具有jQuery或$的默认导出，我们也可能以$或jQuery的名称导入 1234567// JQuery.d.tsdeclare let $:JQueryexport default $;// App.tsimport $ from \"jquery\";$(\"button\").html(\"xxx\") 6.1.4 Export all as x12export * as utilities from \"./utilities\";import &#123;utilities&#125; from './index'; 6.1.4 export = import = require()TypeScript supports export = to model the traditional CommonJS and AMD workflow. export =语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。 当使用export =导出模块时, 必须用 import module = require(&quot;module&quot;) 导入模块 1234567891011121314151617// z.tslet numberRegexp = /^[0-9]+$/;class ZipCodeValidator &#123;isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s);&#125;&#125;export = ZipCodeValidator;// t.tsimport zip = require(\"./ZipCodeValidator\");// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validator = new zip(); 6.2 code generation for Modulestypescript 会依据不同的模块规则，生成不同的代码 123// SimpleModule.tsimport m = require(\"mod\");export let t = m.something + 1; AMD / RequireJS SimpleModule.js 123define([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) &#123;exports.t = mod_1.something + 1;&#125;); CommonJS / Node SimpleModule.js 12var mod_1 = require(\"./mod\");exports.t = mod_1.something + 1; UMD SimpleModule.js 1234567891011(function (factory) &#123;if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") &#123; var v = factory(require, exports); if (v !== undefined) module.exports = v;&#125; else if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define([\"require\", \"exports\", \"./mod\"], factory);&#125;&#125;)(function (require, exports) &#123;var mod_1 = require(\"./mod\");exports.t = mod_1.something + 1;&#125;); System SimpleModule.js 1234567891011121314System.register([\"./mod\"], function (exports_1) &#123;var mod_1;var t;return &#123; setters: [ function (mod_1_1) &#123; mod_1 = mod_1_1; &#125;, ], execute: function () &#123; exports_1(\"t\", (t = mod_1.something + 1)); &#125;,&#125;;&#125;); Native ECMAScript 2015 modules SimpleModule.js 12import &#123; something &#125; from \"./mod\";export var t = something + 1; 6.3 可选模块加载和其他高级加载方案为了保持类型安全，我们可以使用typeof关键字。当在类型位置中使用typeof关键字时，将产生值的类型，在这种情况下为模块的类型。 6.3.1 Dynamic Module Loading in Node.js1234567891011declare function require(moduleName: string): any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123;let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");let validator = new ZipCodeValidator();if (validator.isAcceptable(\"...\")) &#123; /* ... */&#125;&#125; 6.3.2 Sample: Dynamic Module Loading in require.js123456789101112131415declare function require(moduleNames: string[],onLoad: (...args: any[]) =&gt; void): void;import * as Zip from \"./ZipCodeValidator\";if (needZipValidation) &#123;require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) =&gt; &#123; let validator = new ZipCodeValidator.ZipCodeValidator(); if (validator.isAcceptable(\"...\")) &#123; /* ... */ &#125;&#125;);&#125; 6.3.3 Sample: Dynamic Module Loading in System.js123456789101112declare const System: any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123;System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) =&gt; &#123; var x = new ZipCodeValidator(); if (x.isAcceptable(\"...\")) &#123; /* ... */ &#125;&#125;);&#125; 6.4 使用其他js库为了描述非ts编写的库，我们需要声明该库公开的API；通常将这些声明定义在.d.ts文件中，就类似c/c++程序中的 .h文件； Ts程序在开发过程中，会不可避免的引用到第三方js库，但是无法使用Typescript诸如类型检查等特性功能，为了解决这个问题，需要将这些库的函数和方法去掉后只保留导出类型声明，而产生一个描述js库和模块信息的声明文件，通过引用这个声明文件，就可以借用TS的各种特性来使用库文件； 6.4.1 声明文件的存放方式 在tsconfig include 字段包含 的范围内编写.d.ts，都能被自动识别 在x.js 相同目录创建同名声明文件x.d.ts，这样也会被自动识别； node_modules/@types/ 下存放的各个第三方模块声明文件，自己编写的声明文件不要放这里； 作为npm模块发布时，声明文件可捆绑发布，需在package.json中指明“types”：”./types/index.d.ts” 6.4.1 无配置使用js在tsconfig.json中关闭”noImplicitAny”: false时，可直接在Ts中引用js的库，所有的引入都会被默认为any类型。此方法不推荐使用； 6.4.2 Ts中引入js123456789// hello.jsexport const hello = () =&gt; console.log('hello');// index.tsimport &#123;hello&#125; from './hello'// 无法找到模块'./hello'的声明文件// 这就告诉用户，需要为hello.js编写声明文件了；// hello.d.tsexport declare const hello: () =&gt; void 上面的例子稍微简单一些，下面写一个相对复杂点的demo tsconfig.json 123456789101112&#123; \"compilerOptions\": &#123; \"outDir\": \"./dist/\", \"noImplicitAny\": true, \"allowJs\": true, \"module\": \"commonjs\", \"target\": \"es5\", \"experimentalDecorators\": true &#125;, \"exclude\": [\"node_modules\"], \"include\": [\"./src/**/*\"]&#125; dir 12345-src -swap -index.js -index.d.ts -index.ts 1234567891011121314// swap/index.jsconst NAME = \"A\";const swap = (a, b) =&gt; &#123; let temp; temp = a; a = b; b = temp; return `I am $&#123;NAME&#125;`;&#125;;export default &#123; swap,&#125;; 123456// swap/index.d.tsdeclare namespace swap &#123; // ts 编译运行时的 swap命名空间, 增加命名空间放置被全局污染。 function swap&lt;T&gt;(a: T, b: T): void;&#125;export default swap; // 注意这里要导出，有export/import 语句的文件 才是模块 12345678// index.tsimport swap from \"./swap\";let a = \"3\", b = \"4\";console.log(swap.swap&lt;string&gt;(a, b));console.log(a, b); 6.4.3 declarevar和declare的区别 ​ var表示创建一个新变量，declare用来告诉ts编译器这个变量已经在别处被创建过了， 如果你用declare，什么都不会添加到生成的js中， 它只是对编译器一个简单的提示； ​ 举例说明，如果你引入的第三方js文件中有 var externalModule，你需要定义declare var externalModule 去提示ts编译器，externalModule这个变量已经被创建了； 1export declare class Action &#123;&#125; 这个class Action的具体实现应该在其他什么地方，可以在个 .js文件里面 ​ 6.4.4 Ts中导入.png .json等导入.png .json 等文件时，同样也需要去编写声明文件； 提供一种方式，可以创建一个声明文件 src/@types/definition.d.ts 1234567891011121314// definition.d.tsdeclare module '*.png' &#123;const value: stringexport = value&#125;// index.ts// 之后在TS中导入也不会有问题import avatar from './img/avatar.png'const avatar = require('./img/avatar.png') // 可能会提示 require 未定义，有两种方式： // 1. 自行声明：declare const require: any // 2. yarn add -D @types/node 6.4.5 第三方模块没有可用的声明文件有些模块没有对应的声明文件时，需要我们自己编写声明文件，以rc-form为例子，需要在src/@types/defintion.d.ts中添加声明代码 1234567// defintion.d.tsdeclare module \"rc-form\" &#123;// 再次简单进行类型声明export const createForm: any;export const createFormField: any;export const formShape: any;&#125; 6.4.6 webpack 别名 aliases1234567891011121314151617181920212223242526// webpack.config.jsconst config = &#123;aliases: &#123; // 公共的工具类、容器和组件 utils: path.resolve('../utils'),&#125;// &#125;// index.tsimport &#123;ua&#125; from 'utils/broswer'// cannot find module 'utils/browser'// 只需要在tsconfig.json 添加baseUrl 和 paths&#123;\"compilerOptions\": &#123; // ... // 添加配置 \"baseUrl\": \".\", \"paths\": &#123; \"utils/*\": [\"../utils/*\"], \"components/*\": [\"../components/*\"] &#125;&#125;,\"include\": [\"./src/*\", \"./src/**/*\"],\"exclude\": [\"node_modules\"]&#125; 6.4.7 类型Window上不存在属性“X”需要对window进行扩展，直接在src/@types/definition.d.ts中扩展 1234567// definition.d.tsinterface Window &#123; x: any&#125;// index.tsconsole.log(Window.x) // success 注意全局声明和局部声明 1234567891011121314151617181920212223// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'interface Window &#123; X: any&#125;// index.tsconsole.log(window.X); // fail: 类型“Window\"上不存在属性“X”// 解决思路// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'declare global &#123; interface Window &#123; X: any &#125;&#125;// index.tsconsole.log(window.X) // success // 原因在于当一个 .ts文件加入import/export 语句的时候，该文件会变为一个模块；因为这个模块中的声明也会变为局部声明； 因此需要加到global的域上 6.5 Ambient Modules在nodejs中，很多任务的完成都需要引入一个或多个模块，我们可以给每个模块在他们的根目录建立一个.d.ts文件用来声明类型，但合并这些声明到一个大的.d.ts文件往往更方便一些。使用module关键字和 引号名 。这些引号名的名称将在以后的导入中使用； 1234567891011121314151617181920// node.d.tsdeclare module \"url\" &#123;export interface Url &#123; protocol?: string; hostname?: string; pathname?: string;&#125;export function parse( urlStr: string, parseQueryString?, slashesDenoteHost?): Url;&#125;declare module \"path\" &#123;export function normalize(p: string): string;export function join(...paths: any[]): string;export var sep: string;&#125; Now we can /// &lt;reference&gt; node.d.ts and then load the modules using import url = require(&quot;url&quot;); or import * as URL from &quot;url&quot;. 123/// &lt;reference path=\"node.d.ts\"/&gt;import * as URL from \"url\";let myUrl = URL.parse('...') 6.5.1 不想为第三方js写声明If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly. 123456// declarations.d.tsdeclare module \"hot-new-module\";// All imports from shorthand module will have the any type;import x, &#123;y&#125; from \"hot-new-module\";x(y); 6.5.2 通配符一些模块加载器（例如SystemJS和AMD）允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。 12345678910111213141516// declareations.d.tsdeclare module \"*!text\" &#123;const content: string;export default content;&#125;// Some do it the other way around.declare module \"json!*\" &#123;const value: any;export default value;&#125;// Now you can import things that match \"*!text\" or \"json!*\".import fileContent from \"./xyz.txt!text\";import data from \"json!http://example.com/data.json\";console.log(data, fileContent); 6.5.3 UMD modules一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为UMD模块。可以通过导入或全局变量访问这些库。 123// math-lib.d.tsexport function isPreme(x: number):boolean;export as namespace mathLib; The library can then be used as an import within modules: 123import &#123; isPrime &#125; from \"math-lib\";isPrime(2);mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports) 1mathLib.isPrime(2); 6.7 Guidance for structuring modules6.7.1 Export as close to top-level as possible如果要导入大量内容，请使用名称空间导入模式 12345678// MyLargeModule.tsexport class Dog &#123; ... &#125;export class Cat &#123; ... &#125;export class Tree &#123; ... &#125;export class Flower &#123; ... &#125;// Consumer.tsimport * as myLargeModule from \"./MyLargeModule.ts\";let x = new myLargeModule.Dog(); 6.7.2 Re-export to extend通常，您将需要扩展模块上的功能。常见的JS模式是使用扩展来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样合并。推荐的解决方案是不要变更原始对象，而是导出提供新功能的新对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081export class Calculator &#123;private current = 0;private memory = 0;private operator: string;protected processDigit(digit: string, currentValue: number) &#123; // 只能做10以内的计算； if (digit &gt;= \"0\" &amp;&amp; digit &lt;= \"9\") &#123; return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0)); &#125;&#125;protected processOperator(operator: string) &#123; if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) &gt;= 0) &#123; return operator; &#125;&#125;protected evaluateOperator( operator: string, left: number, right: number): number &#123; switch (this.operator) &#123; case \"+\": return left + right; case \"-\": return left - right; case \"*\": return left * right; case \"/\": return left / right; &#125;&#125;private evaluate() &#123; if (this.operator) &#123; this.memory = this.evaluateOperator( this.operator, this.memory, this.current ); &#125; else &#123; this.memory = this.current; &#125; this.current = 0;&#125;public handleChar(char: string) &#123; if (char === \"=\") &#123; this.evaluate(); return; &#125; else &#123; let value = this.processDigit(char, this.current); if (value !== undefined) &#123; this.current = value; return; &#125; else &#123; let value = this.processOperator(char); if (value !== undefined) &#123; this.evaluate(); this.operator = value; return; &#125; &#125; &#125; throw new Error(`Unsupported input: '$&#123;char&#125;'`);&#125;public getResult() &#123; return this.memory;&#125;&#125;export function test(c: Calculator, input: string) &#123;for (let i = 0; i &lt; input.length; i++) &#123; c.handleChar(input[i]);&#125;console.log(`result of '$&#123;input&#125;' is '$&#123;c.getResult()&#125;'`);&#125; 1234// 使用import &#123;Calculator, test&#125; from './ProgrammerCalculator';let c = new Calculator(2);test(c, \"1+2*33/11=\"); 新需求： 要求计算超过9的值 这个时候不在原类上更改，而是在继承类上做新功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ProgrammerCalculator.tsimport &#123; Calculator &#125; from \"./Calculator\";class ProgrammerCalculator extends Calculator &#123;static digits = [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\",];constructor(public base: number) &#123; super(); const maxBase = ProgrammerCalculator.digits.length; if (base &lt;= 0 || base &gt; maxBase) &#123; throw new Error(`base has to be within 0 to $&#123;maxBase&#125; inclusive.`); &#125;&#125;protected processDigit(digit: string, currentValue: number) &#123; if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) &#123; return ( currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit) ); &#125;&#125;&#125;// Export the new extended calculator as Calculatorexport &#123; ProgrammerCalculator as Calculator &#125;;// Also, export the helper functionexport &#123; test &#125; from \"./Calculator\"; 12345// TestProgrammerCalculator.tsimport &#123; Calculator, test &#125; from \"./ProgrammerCalculator\";let c = new Calculator(2);test(c, \"001+010=\"); // prints 3 6.7.3 Do not use namespaces in modules当首次转向基于模块的组织时，一种普遍的趋势是将导出包装在命名空间的附加层中。模块具有自己的作用域，并且从模块外部仅可见导出的声明。考虑到这一点，名称空间在使用模块时几乎没有价值。 7. Namespaces在TypeScript 1.5中，模块命名法则已更改。 “Internal modules”现在是“namespaces”。为了与ECMAScript 2015的术语保持一致，“External modules”现在简称为“modules”（module X {} 等同于 namespaceX {}） 在声明内部模块时，在使用module关键字的任何地方，可以并且应该改用namespace关键字。 7.1 多个相似对象添加namespaces123456789101112131415161718192021222324252627282930313233343536373839namespace Validation &#123;export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125;const lettersRegexp = /^[A-Za-z]+$/;const numberRegexp = /^[0-9]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125;&#125;export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;&#125;// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123;for (let name in validators) &#123; console.log( `\"$&#123;s&#125;\" - $&#123; validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" &#125; $&#123;name&#125;` );&#125;&#125; 7.2 Splitting Across Files​ 随着应用程序的扩展，我们希望将代码拆分为多个文件，以使其易于维护; 7.2.1 Multi-file namespaces 我们将Validation名称空间拆分为多个文件。即使文件是分开的，它们每个都可以贡献相同的名称空间，并且可以像将它们全部定义在一个位置一样使用。由于文件之间存在依赖性，因此我们将添加参考标记，以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。 Validation.ts 12345namespace Validation &#123;export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125;&#125; LettersOnlyValidator.ts 123456789/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123;const lettersRegexp = /^[A-Za-z]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125;&#125;&#125; ZipCodeValidator.ts 123456789/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123;const numberRegexp = /^[0-9]+$/;export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;&#125; Test.ts 12345678910111213141516171819202122/// &lt;reference path=\"Validation.ts\" /&gt;/// &lt;reference path=\"LettersOnlyValidator.ts\" /&gt;/// &lt;reference path=\"ZipCodeValidator.ts\" /&gt;// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123;for (let name in validators) &#123; console.log( `\"$&#123;s&#125;\" - $&#123; validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" &#125; $&#123;name&#125;` );&#125;&#125; 一旦涉及到多个文件，需要确保所有已编译的代码都已加载，有两种方法可以做到这点 7.2.1.1 级联输出使用 –outFile，将所有输入文件编译为单个js输出文件 tsc --outFile sample.js Test.ts 7.2.1.2 自动排序输出编译器将根据文件中存在的参考标记自动排序输出文件。您还可以分别指定每个文件： tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts 7.2.1.3 单个编译12tsc test.tstes Validation.ts 7.3 Aliases12345678910namespace Shapes &#123;export namespace Polygons &#123; export class Triangle &#123;&#125; export class Square &#123;&#125;&#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 7.3.1 使用第三方JavaScript库为了描述不是用TypeScript编写的库的形状，我们需要声明该库公开的API。因为大多数JavaScript库仅公开一些顶级对象，所以namespaces是表示它们的好方法。 D3在名为d3的全局对象中定义其功能。由于此库是通过script标签加载的，因此可以使用命名空间来声明它的shape。 1234567891011121314151617181920declare namspace D3 &#123;export interface Selectors &#123; select: &#123; (selector: string): Selection; (element: EventTarget): Selection; &#125;;&#125;export interface Event &#123; x: number; y: number;&#125;export interface Base extends Selectors &#123; event: Event;&#125;&#125;declare var d3: D3.Base; 8. 三斜杠指令三斜杠指令是包含单个XML标签的单行注释。注释的内容用作编译器指令。 三斜杠指令仅在其包含文件的顶部有效。三斜杠指令只能在单行或多行注释之前，包括其他三斜杠指令。如果在声明或声明之后遇到它们，则将它们视为常规的单行注释，并且没有特殊含义。 /// &lt;reference path=&quot;./lib/index.d.ts&quot; /&gt;：表示对一个文件的依赖。 /// &lt;reference types=&quot;jye&quot; /&gt;：表示对一个库的依赖。 三斜线的path &amp; types，和es6的import语义相似，同时三斜线指令必须放在文件的最顶端。例如，当我们的声明文件过于庞大，一般都会采用三斜线指令，将我们的声明文件拆分成若干个，然后由一个入口文件引入。 8.1 文件之间的依赖声明12///&lt;reference path=\"...\"/&gt;///&lt;reference path=\"...\"/&gt; 是这个group中最常见的，它用作文件之间依赖关系的声明； 三斜杠指令指示编译器在编译过程中包括其他文件； 当使用 –out 或 –outFile时，它们还可以用作对输出进行排序的方法。预处理通过后，文件以与输入相同的顺序输出到目标文件位置。 8.2 input files 预处理编译器对输入文件进行预处理，以解析所有三斜杠引用指令。在此过程中，其他文件将添加到编译过程中。 该过程从一组根文件开始；这些是在命令行或tsconfig.json文件的“files”列表中指定的文件名。这些根文件将按照指定的顺序进行预处理。在将文件添加到列表之前，必须先处理其中的所有三斜杠引用及其目标。按照在文件中出现的顺序，深度优先地解析三斜杠引用 A triple-slash reference path is resolved relative to the containing file, if unrooted. 8.3 typestypes=&quot;...&quot; 与 path=&quot;...&quot; 类似，前者声明对包的依赖，后者声明对一个文件的依赖 这些程序包名称的解析过程与import语句中的模块名称解析过程相似。考虑三重斜杠引用类型指令的一种简单方法是将其作为声明包的导入。 在一个声明文件中包括 types=&quot;node&quot; 则该声明文件使用@types/node/index.d.ts中声明的名称，因此，此包需要与声明文件一起包含在编译中; 仅当您书写d.ts文件时，才使用这些指令； 对于编译期间生成的声明文件，编译器会自动添加types=&quot;...&quot;。当且仅当reslulting file使用 referenced package中 任何声明的时候，才会在生成的声明文件中添加 types=&quot;...&quot; ； 在 .ts 文件声明对 一个@types 包的依赖， 使用命令行 –types 或者 tsconfig.json中设置； 8.4 liblib=&quot;...&quot; 此指令允许文件显式包括现有的内置lib文件。 例如，在编译中的一个文件中添加/// &lt;reference lib =“ es2017.string” /&gt;等效于使用–lib es2017.string进行编译。 123/// &lt;reference lib=\"es2017.string\" /&gt;\"foo\".padStart(4); 9. Namespaces and Modules9.1 使用modules模块可以包含代码和声明 从es6开始，模块是语言的原生机制，新的项目，模块将是推荐的代码组织机制； 9.2 使用namespaces命名空间是TypeScript特定的组织代码的方式。 命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。与模块不同，它们可以跨越多个文件，并且可以使用–outFile进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都作为script标记包含在HTML页面中。 就像所有全局命名空间污染一样，很难识别组件依赖性，尤其是在大型应用程序中。 9.3 使用namespaces 和 modules 遇到的一些坑9.3.1 不需要namespaces的时候123456789101112// `shapes.ts`export namespace Shapes &#123;export class Triangle &#123; /* ... */&#125;export class Square &#123; /* ... */&#125;&#125;// `shapeConsumer.ts`import * as shapes from \"./shapes\";let t = new shapes.Shapes.Triangle(); // shapes.Shapes? 推荐的做法，当一个文件中定义了import/export 的时候，那么它就变成了一个模块。模块中，命名空间显然多此一举了 推荐做法 12345678910// shapes.tsexport class Triangle &#123;/* ... */&#125;export class Square &#123;/* ... */&#125;// shapeConsumer.tsimport * as shapes from \"./shapes\";let t = new shapes.Triangle(); 9.3.2 reference 和import 的使用时机一个常见的错误是尝试使用/// reference ...语法来引用模块文件，而不是使用import语句； 编译器如何 基于 path of an import path(import X from &#39;xxx&#39;; import x = require(&#39;...&#39;)) 找到模块的类型信息； 编译器将尝试查找.ts，.tsx，然后找到具有适当路径的.d.ts。如果找不到特定的文件，然编译器会去找ambient module declaration 记得这些需要在 .d.ts 文件中声明 12345678// myModules.d.ts// In a .d.ts file or .ts file that is not a module:declare module \"SomeModule\" &#123; export function fn(): string;&#125;// myOtherModule.ts/// &lt;reference path=\"myModules.d.ts\" /&gt; 记得添加依赖import * as m from \"SomeModule\"; // 这里并不是导入 文件名，而是模块名，因为 myModules.d.ts 不是一个模块； /// reference path=&quot;myModules.d.ts&quot; 使我们能够找到包含环境模块声明的声明文件，This is how the node.d.ts file that several of the TypeScript samples use is consumed.","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts generics","slug":"ts-generics","date":"2021-01-20T11:42:15.000Z","updated":"2021-02-09T10:28:30.509Z","comments":true,"path":"2021/01/20/ts-generics/","link":"","permalink":"http://yoursite.com/2021/01/20/ts-generics/","excerpt":"","text":"5. Generics泛型，创建可重用组件的工具。 1234function loggingIdentity&lt;T&gt;(arg: T) &#123; console.log(arg.length); // Property 'length' does not exist on type 'T'. return arg;&#125; 5.1 泛型定义1234567891011function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;let myIdentity1: &#123; &lt;T&gt;(arg: T): T &#125; = identity;let myIdentity2: GenericIdentityFn = identity; 5.2 泛型类12345678910class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y;&#125;; 5.3 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 5.3.1 Using Type Parameters in Generic Constraints123456789function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\");getProperty(x, \"m\");// Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'. 5.3.2 泛型类使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型； 123function create&lt;T&gt;(c: &#123; new (): T &#125;): T &#123; return new c();&#125; 使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系 1234567891011121314151617181920212223242526class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"ts doc","slug":"ts-doc","date":"2021-01-19T08:12:21.000Z","updated":"2021-02-09T10:28:20.873Z","comments":true,"path":"2021/01/19/ts-doc/","link":"","permalink":"http://yoursite.com/2021/01/19/ts-doc/","excerpt":"","text":"handbookA reader who completes the walkthrough should be able to: Read and understand commonly-used TypeScript syntax and patterns Explain the effects of important compiler options Correctly predict type system behavior in most cases Write a .d.ts declaration for a simple function, object, or class 1. basic Types 在TypeScript中，我们支持与JavaScript中期望的类型相同的类型，并添加了一个额外的枚举类型以帮助处理问题。 Boolean, Number, String, Array,Tuple,Enum,Unkown,Any,Void, Null and Undefined, Never, Object, Tuple 元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对字符串和一个数字： 123456// Declare a tuple typelet x: [string, number];// Initialize itx = [\"hello\", 10]; // OK// Initialize it incorrectlyx = [10, \"hello\"]; // Error Enum 枚举是JavaScript标准数据类型集的一个有用补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。 123456789enum Color &#123; Red = 1, Green, Blue,&#125;let colorName: string = Color[2];// Displays 'Green'console.log(colorName); Unknown 我们可能需要描述编写应用程序时不知道的变量类型。这些值可能来自动态内容，例如来自用户-或者我们可能要有意接受我们API中的所有值。在这些情况下，我们希望提供一种类型，该类型告诉编译器和将来的读者此变量可以是任何变量，因此我们将其赋予未知类型。 12345let notSure: unknown = 4;notSure = \"maybe a string instead\";// OK, definitely a booleannotSure = false; 如果您有一个类型未知的变量，则可以通过进行typeof检查，比较检查或更高级的类型防护来将其范围缩小到更具体的范围; 1234567891011121314151617181920declare const maybe: unknown;// 'maybe' could be a string, object, boolean, undefined, or other typesconst aNumber: number = maybe;//Type 'unknown' is not assignable to type 'number'.if (maybe === true) &#123; // TypeScript knows that maybe is a boolean now const aBoolean: boolean = maybe; // So, it cannot be a string const aString: string = maybe;//Type 'boolean' is not assignable to type 'string'.&#125;if (typeof maybe === \"string\") &#123; // TypeScript knows that maybe is a string const aString: string = maybe; // So, it cannot be a boolean const aBoolean: boolean = maybe;//Type 'string' is not assignable to type 'boolean'.&#125; Any 在某些情况下，并非所有类型信息都可用。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况，可能要选择退出类型检查。将这些值标记为any类型： 123declare function getValue(key: string): any;// OK, return value of 'getValue' is not checkedconst str: string = getValue(\"myString\"); 与 unknown 不同，any类型的变量使您可以访问任意属性，甚至是不存在的属性。这些属性包括函数，并且TypeScript不会检查它们的存在或类型 123456789let looselyTyped: any = 4;// OK, ifItExists might exist at runtimelooselyTyped.ifItExists();// OK, toFixed exists (but the compiler doesn't check)looselyTyped.toFixed();let strictlyTyped: unknown = 4;strictlyTyped.toFixed();// Object is of type 'unknown'. Void void有点像任何其他的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型： 123function warnUser(): void &#123; console.log(\"This is my warning message\");&#125; Null and Undefined 在TypeScript中，undefined和null实际上实际上分别将其类型命名为undefined和null。就像void一样，它们本身并不是非常有用： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Never The never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never. 1234567891011121314// Function returning never must not have a reachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must not have a reachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; Object object是代表非基本类型的类型，即不是数字，字符串，布尔值，bigint，symbol，null或undefined的任何类型。 123456789101112131415// With object type, APIs like Object.create can be better represented.declare function create(o: object | null): void;// OKcreate(&#123; prop: 0 &#125;);create(null);create(42);//Argument of type '42' is not assignable to parameter of type 'object | null'.create(\"string\");//Argument of type '\"string\"' is not assignable to parameter of type 'object | null'.create(false);//Argument of type 'false' is not assignable to parameter of type 'object | null'.create(undefined);//Argument of type 'undefined' is not assignable to parameter of type 'object | null'. Type assertions 类型断言是一种告诉编译器“相信我，我知道我在做什么”的方法。类型断言就像其他语言中的类型转换一样，但是它不执行数据的特殊检查或重构。它对运行时没有影响，仅由编译器使用。 TypeScript假定您（程序员）已经执行了所需的任何特殊检查。 类型断言的两种形式 123456// 类型1: as 语句let someValue: unknown = \"this is a string\";let strLength: number = (someValue as string).length;// 类型2: 尖括号let someValue: unknown = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; jsx中无法使用 类型2； About Number, String, Boolean, Symbol and Object 可能会认为数字，字符串，布尔值，符号或对象类型与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎永远不应将其用作类型。 2. interface2.1 readonly1234interface Point &#123; readonly x: number; readonly y: number;&#125; TypeScript具有与Array 相同的ReadonlyArray 类型，并且删除了所有变异方法，因此可以确保创建后不更改数组： 1234567891011let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!//Index signature in type 'readonly number[]' only permits reading.ro.push(5); // error!//Property 'push' does not exist on type 'readonly number[]'.ro.length = 100; // error!//Cannot assign to 'length' because it is a read-only property.a = ro; // error!//The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'. 在代码片段的最后一行，您可以看到，即使将整个ReadonlyArray分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它： 1234let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;a = ro as number[]; ReadOnly or const 记住是使用只读还是const的最简单方法是询问是否在变量或属性上使用它。变量使用const，而属性使用只读。 2.2 Optional1234interface SquareConfig &#123; color?: string; width?: number;&#125; 2.3 Excess Property Checks但是，TypeScript认为此代码中可能存在错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行过多的属性检查。如果对象文字具有“目标类型”所没有的任何属性，则会出现错误： 123456789101112131415interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; return &#123; color: config.color || \"red\", area: config.width ? config.width * config.width : 20, &#125;;&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;);//Argument of type '&#123; colour: string; width: number; &#125;' is not assignable to parameter of type 'SquareConfig'. // Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 解决方案 解决这些检查实际上非常简单。最简单的方法是只使用类型断言： 1const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125; as SquareConfig); 如果对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。 12345678910interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125;);// 只要您在squareOptions和SquareConfig之间具有一个公共属性，上述变通办法就会起作用。但是，如果变量没有任何公共对象属性，它将失败。let squareOptions = &#123; colour: \"red\" &#125;;let mySquare = createSquare(squareOptions);// Type '&#123; colour: string; &#125;' has no properties in common with type 'SquareConfig'. 2.4 Function Types为了描述带有接口的函数类型，我们给接口一个调用签名。这就像只声明参数列表和返回类型的函数声明。参数列表中的每个参数都需要名称和类型。 1234567891011121314151617181920212223242526interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function (source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125;;let mySearch2: SearchFunc;// 参数不定义string，ts会自动推断mySearch2 = function (src, sub): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125;;let mySearch: SearchFunc;mySearch = function (src, sub) &#123; // 返回值需要遵守interface//Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.// Type 'string' is not assignable to type 'boolean'. let result = src.search(sub); return \"string\";&#125;; 2.5 Indexable Types可索引类型具有索引签名，该签名描述了可用于索引对象的类型以及建立索引时对应的返回类型 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为在用数字索引时，JavaScript实际上会在将其索引到对象之前将其转换为字符串。这意味着使用100（一个数字）进行索引与使用“ 100”（一个字符串）进行索引是同一回事，因此两者必须保持一致。 1234567891011121314interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;// Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay &#123; [x: number]: Animal;Numeric index type 'Animal' is not assignable to string index type 'Dog'. [x: string]: Dog;&#125; 尽管字符串索引签名是描述“字典”模式的强大方法，但它们还强制所有属性与其返回类型匹配。这是因为字符串索引声明obj.property也可以作为obj [“ property”]使用。在以下示例中，名称的类型与字符串索引的类型不匹配，并且类型检查器给出错误： 123456interface NumberDictionary &#123; [index: string]: number; length: number; // ok, length is a number name: string; // error, the type of 'name' is not a subtype of the indexer// Property 'name' of type 'string' is not assignable to string index type 'number'.&#125; 但是，如果索引签名是属性类型的并集，则可以接受不同类型的属性： 12345interface NumberOrStringDictionary &#123; [index: string]: number | string; // 属性类型 length: number; // ok, length is a number name: string; // ok, name is a string&#125; 最后，您可以将索引签名设为只读，以防止分配给它们的索引： 1234567interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];myArray[2] = \"Mallory\"; // error!// Index signature in type 'ReadonlyStringArray' only permits reading. 2.6 Class Types2.6.1 Implement123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 这是因为当类实现接口时，仅检查该类的实例侧。由于构造函数位于静态端，因此它不包含在此检查中。 123456789101112interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; // Class 'Clock' incorrectly implements interface 'ClockConstructor'. // Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'. currentTime: Date; constructor(h: number, m: number) &#123;&#125;&#125;const clock = new Clock(1, 3); 需要直接使用类的静态方面。在此示例中，我们定义了两个接口，用于构造函数的ClockConstructor和用于实例方法的ClockInterface。然后，为方便起见，我们定义了一个构造函数createClock，该函数创建传递给它的类型的实例 1234567891011121314151617181920212223242526272829303132interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;function createClock( ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"tick tock\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 另一种简单的方法是使用类表达式： 1234567891011121314151617interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;;let clock = new Clock(12, 17);clock.tick(); 2.7 Extending Interfaces12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &#123;&#125; as Square;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 2.8 Hybrid Typesan object that acts as both a function and an object, with additional properties: 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = function (start: number) &#123;&#125; as Counter; counter.interval = 123; counter.reset = function () &#123;&#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 与第三方JavaScript交互时，您可能需要使用上述模式来完全描述类型的形状 2.9 Interfaces Extending ClassesWhen an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it. This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example: 12345678910111213141516171819202122class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;class ImageControl implements SelectableControl &#123;//Class 'ImageControl' incorrectly implements interface 'SelectableControl'. // Types have separate declarations of a private property 'state'. private state: any; select() &#123;&#125;&#125; ​ In the above example, SelectableControl contains all of the members of Control, including the private state property. Since state is a private member it is only possible for descendants of Control to implement SelectableControl. This is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible. ​ Within the Control class it is possible to access the state private member through an instance of SelectableControl. Effectively, a SelectableControl acts like a Control that is known to have a select method. The Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method). The ImageControl class has it’s own state private member rather than extending Control, so it cannot implement SelectableControl. 3. Functions在TypeScript中，尽管有类，名称空间和模块，但是函数仍然在描述操作方式中起着关键作用。 TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。 3.1 thisLearning how to use this in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use this and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of this with a couple of techniques. If you need to learn how this works in JavaScript, though, first read Yehuda Katz’s Understanding JavaScript Function Invocation and “this”. Yehuda’s article explains the inner workings of this very well, so we’ll just cover the basics here. this and arrow functions In JavaScript, this is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument. Let’s look at an example: 1234567891011121314151617let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; return function () &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Notice that createCardPicker is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the this being used in the function created by createCardPicker will be set to window instead of our deck object. That’s because we call cardPicker() on its own. A top-level non-method syntax call like this will use window for this. (Note: under strict mode, this will be undefined rather than window). We can fix this by making sure the function is bound to the correct this before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original deck object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the this where the function is created rather than where it is invoked: 123456789101112131415161718let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Even better, TypeScript will warn you when you make this mistake if you pass the --noImplicitThis flag to the compiler. It will point out that this in this.suits[pickedSuit] is of type any. this parameters Unfortunately, the type of this.suits[pickedSuit] is still any. That’s because this comes from the function expression inside the object literal. To fix this, you can provide an explicit this parameter. this parameters are fake parameters that come first in the parameter list of a function: 123function f(this: void) &#123; // make sure `this` is unusable in this standalone function&#125; Let’s add a couple of interfaces to our example above, Card and Deck, to make the types clearer and easier to reuse: 1234567891011121314151617181920212223242526272829interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function (this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Now TypeScript knows that createCardPicker expects to be called on a Deck object. That means that this is of type Deck now, not any, so --noImplicitThis will not cause any errors. this parameters in callbacks You can also run into errors with this in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, this will be undefined. With some work you can use this parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with this: 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this: 123456789101112131415class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used `this` here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error!//Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. //The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'.Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. // The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'. With this annotated, you make it explicit that onClickBad must be called on an instance of Handler. Then TypeScript will detect that addClickListener requires a function that has this: void. To fix the error, change the type of this: 12345678910class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use `this` here because it's of type void! console.log(\"clicked!\"); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); Because onClickGood specifies its this type as void, it is legal to pass to addClickListener. Of course, this also means that it can’t use this.info. If you want both then you’ll have to use an arrow function: 123456class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message; &#125;;&#125; This works because arrow functions use the outer this, so you can always pass them to something that expects this: void. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler. 3.2 OverloadsJavaScript本质上是一种非常动态的语言。一个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。 1234567891011121314151617181920212223242526272829let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123; suit: string; card: number &#125;[]): number;function pickCard(x: number): &#123; suit: string; card: number &#125;;function pickCard(x) &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [ &#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;,];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 4. Classes4.1 abstract abstract关键字用于定义抽象类以及抽象类中的抽象方法。 抽象类， 是可以从中派成出其他类的基类；简单说就是只能被继承，不能new出实例；与interface不同的是，抽象类中可以有成员实现的详细信息。 12345678910111213141516171819202122232425export abstract class App &#123; public setTargetProps&lt;T&gt; (target: T, source: Partial&lt;T&gt;): T &#123; try &#123; Object.keys(target).forEach((property: keyof T) =&gt; &#123; this.setTargetPropsByProperty(target, property, source[property]) &#125;) &#125; catch (error) &#123; throw new Error(error) &#125; return target &#125;&#125;const app = new App();// Cannot create an instance of an abstract class.class B extends App&#123;&#125;;// 非抽象类“ B”未实现从类“ App”继承的抽象成员“ make”class C extends App&#123; make()&#123;&#125; // 需要实现抽象类中定义的抽象方法&#125; 抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含abstract关键字，并且可以选择包括访问修饰符。 4.2 public,private, and protected4.2.1 类型兼容12345678910111213141516171819202122232425262728class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super(\"Rhino\"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal(\"Goat\");let rhino = new Rhino();let employee = new Employee(\"Bob\");animal = rhino;animal = employee; // Type 'Employee' is not assignable to type 'Animal'. 没有继承关系的类型无法做赋值操作；// Types have separate declarations of a private property 'name' 4.2.2 protectedprotected修饰符的行为与private修饰符非常相似，除了声明为protected的成员也可以在派生类中访问之外； 123456789101112131415161718192021222324252627class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; // 派生类中可以访问到 基类中的 protected 属性； return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());// 虽然我们不能从Person外部使用name，但仍可以在Employee的实例方法中使用它，因为Employee源自Person。console.log(howard.name);// Property 'name' is protected and only accessible within class 'Person' and its subclasses. 构造函数也可能被标记为受保护的。这意味着该类不能在其包含的类之外实例化，但是可以扩展。 123456789101112131415161718192021222324class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee can extend Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\");// Constructor of class 'Person' is protected and only accessible within the class declaration. 因为 new Person的时候是需要调 Person的构造函数，由于其构造函数添加了 protected关键字。实例是无法调类的构造函数的，所以就无法被实例化了； 4.2.3 Readonly12345678910111213class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(readonly theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\";// Cannot assign to 'name' because it is a read-only property.console.log(dad.name) 4.2.4 accessorsTypeScript支持getters / setter方法，以拦截对对象成员的访问。这使您可以更好地控制如何访问每个对象上的成员的方式。 12345678910class Employee &#123; fullName: string;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 在此版本中，我们添加了一个setter来检查newName的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是这样，我们会抛出错误通知客户端代码出了点问题。 123456789101112131415161718192021222324const fullNameMaxLength = 10;class Employee &#123; private _fullName: string = \"\"; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123; throw new Error(\"fullName has a max length of \" + fullNameMaxLength); &#125; this._fullName = newName; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 注意事项 首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。 其次，带有get和no set的访问器会自动推断为只读。当代码生成.d.ts文件时很有用，因为用户通过ide可以看到这些无法进行更改。 4.2.5 Static1234567891011121314151617class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123; let xDist = point.x - Grid.origin.x; let yDist = point.y - Grid.origin.y; return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123;&#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 4.2.6 Using a class as an interface12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;; 5. Decorators随着TypeScript和ES6中类的引入，现在存在某些情况，这些情况需要附加功能来支持 annotating or modifying classes and class members。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的第2阶段提议，可作为TypeScript的实验功能使用。 JavaScript引入class之后，我们需要在不同的类之间共享或者扩展一些方法或行为的时候，代码会变得很复杂，不够优雅，这也是装饰器被提出的一个很重要原因之一； 要为装饰器启用实验性支持，必须在命令行或tsconfig.json中启用experimentalDecorators编译器选项 1tsc --target ES5 --experimentalDecorators 1234567// tsconfig.json&#123; \"compilerOptions\": &#123; \"target\": \"ES5\", \"experimentalDecorators\": true &#125;&#125; 装饰器是一种特殊的声明，可以附加到类声明，方法，访问器，属性或参数上。装饰器使用@expression形式，其中expression求值之后必须也是一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入； 5.1 class decorators12345678910111213141516171819function addAge(constructor: Function) &#123; constructor.prototype.age = 18;&#125;function addName(constructor: Function) &#123; constructor.prototype.name = \"leo\";&#125;@addAge@addNameclass Person &#123; name: string; age!: number;&#125;let person = new Person();console.log(person.age, person.name); // 18 ,'age' 12345678910111213141516171819202122232425262728293031323334353637// bundle.jsvar __decorate = function (decorators, target, key, desc) &#123; var c = arguments.length, r = c &lt; 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc; var d; if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.decorate === \"function\") &#123; r = Reflect.decorate(decorators, target, key, desc); &#125; else &#123; for (var i = decorators.length - 1; i &gt;= 0; i--) if ((d = decorators[i])) // 核心代码就是 d(r) r为构造函数Person r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; &#125; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;&#125;;function addAge(constructor) &#123; constructor.prototype.age = 18;&#125;function addName(constructor) &#123; constructor.prototype.name = \"leo\";&#125;var Person = /** @class */ (function () &#123; function Person() &#123;&#125; Person = __decorate([addAge, addName], Person); return Person;&#125;)();var person = new Person();console.log(person.age, person.name);export &#123;&#125;; 5.2 reflect-metadatainstall npm install reflect-metadata demo 1234567891011121314151617181920212223242526272829303132import \"reflect-metadata\";let target = &#123;&#125;;Reflect.defineMetadata(\"name\", \"alex\", target);Reflect.defineMetadata(\"name\", \"world\", target, \"hello\");console.log(Reflect.getOwnMetadata(\"name\", target)); // alexconsole.log(Reflect.getOwnMetadata(\"name\", target, \"hello\")); // worldfunction classMetadata(key: any, value: any) &#123; return function (target: any) &#123; Reflect.defineMetadata(key, value, target); &#125;;&#125;function methodMetadata(key: any, value: any) &#123; return function (target: any, propertyName: any) &#123; //Person.prototype.hello.name=world Reflect.defineMetadata(key, value, target, propertyName); &#125;;&#125;//给类本身增加元数据//@Reflect.metadata('name','Person')@classMetadata(\"name\", \"Person\")class Person &#123; //给类的原型增加元数据 //@Reflect.metadata('name', 'world') @methodMetadata(\"name\", \"world\") hello(): string &#123; return \"world\"; &#125;&#125;console.log(Reflect.getMetadata(\"name\", Person)); // Personconsole.log(Reflect.getMetadata(\"name\", new Person(), \"hello\")); // world","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"html5vedio","slug":"html5vedio","date":"2021-01-04T07:02:23.000Z","updated":"2021-02-09T10:27:48.301Z","comments":true,"path":"2021/01/04/html5vedio/","link":"","permalink":"http://yoursite.com/2021/01/04/html5vedio/","excerpt":"","text":"html5 播放器加速123const video = document.querySelector('video');video.playbackRate = 2 // 播放器播放速度","categories":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"}]},{"title":"browser-sync","slug":"browser-sync","date":"2020-12-21T06:07:39.000Z","updated":"2021-02-09T10:26:03.847Z","comments":true,"path":"2020/12/21/browser-sync/","link":"","permalink":"http://yoursite.com/2020/12/21/browser-sync/","excerpt":"","text":"全局安装1231312312312123sudo npm install -g browser-sync 快速使用1234# 启动服务器 监听所有的html文件$ browser-sync start --server --files \"*.html\"# 启动服务器 监听所有的文件$ browser-sync start --server --files \"**\" 启动browser-sync start --server --port 3333 --files &quot;*.css,*.html,*.js&quot; start options1234567891011121314151617181920212223242526272829--help #输出使用信息--version #输出的版本号--browser #选择哪个浏览器应该是自动打开--files #文件路径看--exclude #文件模式忽视--server #运行本地服务器（使用您的CWD作为Web根）--index #指定哪些文件应该被用作索引页--extensions #指定文件扩展名回退--startPath #指定起始路径，打开浏览器--https #启用S​​SL地方发展--directory #显示服务器的目录列表--proxy #代理现有的服务器--xip #使用xip.io域路由--tunnel #使用公共网址--open #选择哪个URL是自动打开（本地，外部或隧道）--config #指定为BS-config.js文件的路径--host #指定主机名使用--logLevel #设置记录器输出电平（沉默，信息或调试）--port #指定要使用的端口--reload-delay #以毫秒为单位的时间延迟重装事件以下文件的变化--reload-debounce #限制在浏览器中的频率：刷新事件可以被发射到连接的客户机--ui-port #指定端口的UI使用--no-notify #禁用浏览器的通知元素--no-open #不要打开一个新的浏览器窗口--no-online #强制离线使用--no-ui #不要启动用户界面--no-ghost-mode #禁用幽灵模式--no-inject-changes #刷新上的每个文件更改--no-reload-on-restart #不要自动重新加载在重新启动所有浏览器","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"gitlab3","slug":"gitlab3","date":"2020-12-17T07:30:43.000Z","updated":"2021-02-09T10:27:24.991Z","comments":true,"path":"2020/12/17/gitlab3/","link":"","permalink":"http://yoursite.com/2020/12/17/gitlab3/","excerpt":"","text":"gitlab 分支策略 考虑到gitlab一般在企业内部使用，一般不存在社区开发者，所以在管理上不会采用github的upstream/origin双仓库模式。gitlab下，开发者们面向一个仓库进行提交即可； 设置对分支的保护权限 顾名思义，分支的权限必不可少，它可以约束开发者们的提交行为和提交策略。避免失误操作将未测试过的代码强制提交到生产分支；developer可以不关心； issue与Milestones issue可以理解为一个最小原子的任务，多个任务组成一个 milestones；Milestones 可以理解为某个时间区间内的任务集；一个Milestones可包含多个issue； 当该Milestones中所有issue完成，则标志着此Milestones的结束； 创建issue和mr 创建一个issue 关联一个mr branch name branch name 会以issue的序号开始，然后抓取title中的英文和数字做连接。 可采用index-categroy-content-[username]-[time]的自定义方式，括号部分可选 category feature bugfix chore enhance content，一到三个词简述任务 username，任务认领人 time，创建分支的时间，一般 201217或者1225 source 基于什么分支创建当前分支，feature/chore/enhance选择dev-0.3, bugfix选择env-dev 提交代码流程 123456git fetch # 获取issue关联的分支名git checkout -b 6-feature-pivotDrill origin/6-feature-pivotDrill # 基于远端新建一个本地开发分支git rebase dev-0.3 # 在开发过程中，不定时rebase 宿主分支，防止版本隔断git push origin 6-feature-pivotDrill # 提交至远程映射# 通知maintainer完成代码合并，并关闭issue commits规范&#39;type(module) some desc&#39; 1234567891011121314151617181920212223242526type = [ \"build\", // 构建执行 \"chore\", // 构建工具相关 \"ci\", // CI 相关 \"docs\", // 文档更新 \"feat\", // 新功能 \"fix\", // bug 修复 \"perf\", // 性能优化 \"refactor\", // 功能重构 \"release\", \"revert\", // 回滚操作 \"style\", // 样式变动 \"test\", // 单元测试]moduele = [ // 以davinci为例,只列出前端模块 \"project\", \"dashboard\", \"display\", \"widget\", \"schdule\", \"view\", \"source\", \"user\"] review代码的参考标准 格式化后的代码，在vscode中安装prettier工具，设置ctrl+s默认对当前页进行prettier格式化； 所有commits必须要关联issue，如果没有issue要新建issue然后关联mr（merge request），基于当前mr提交代码； 原则上，不能有肉眼可见的bug，一般review代码时会进行简单的测试； 其他规则（代码规范） 代码规范 原则上，所有新提交的代码参考项目代码风格即可。简述为下面几个方面 原则上，变量名含义精准，（ps：严禁全局作用域中出现单字符命名空间；） 不要求一定要加注释或者不加注释，我们的愿景是能够书写无注释就能看懂的代码。根据业务逻辑难易程度，自行决定。 尽量英文注释； 不建议提交大量重复代码，须做好代码的抽象复用； 尽量使用被主流浏览器支持的的es规范书写代码，原则上新es规范下已有的工具类和函数，不重复造轮子； 其他涉及html/css/javascript相关的推荐规范会渐进式纳入规范集；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab2","slug":"gitlab2","date":"2020-12-16T10:41:24.000Z","updated":"2020-12-18T05:41:03.023Z","comments":true,"path":"2020/12/16/gitlab2/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab2/","excerpt":"","text":"label 标签组 标签组的意义就是定义一次，多个项目统一使用 Platform 前端还是后端，ios 还是 android angular node Problems 目前产品中存在的问题，以及该问题的优先级程度 bug： 常规bug security： 安全漏洞 production： 涉及到生产环境 Mindless 影响较小的任务，比如更改文件夹目录，适配规范 chore legal Experience 影响用户体验，或者用户对产品的理解. These can be both opportunities and “UX bugs”. copy design ux: User Experience Environment 服务器环境，开发环境，生产环境或者测试环境 staging test Feedback 待确认的问题，比如一些拍脑袋的需求；或者某个需求我们还没决定怎么实现 discussion question： 还没到需要讨论的情况 rfc Improvements 现有功能或基础架构上的迭代。 enhancement: 现有模块有更高的完成度 optimization: 现有功能代码层面的重构，或者交互流程上的梳理 Additions 新功能，新页面 feature Pending 现在不好说，未来肯定有结果，可能做成功， 可能做不成； in progress： 进行中的需求 watchlist： 先拖着的需求，有可能就拖掉了 Inactive 无需采取任何行动或可能采取任何行动。该问题已解决，可以通过其他问题更好地解决； invalid： 无效的 wontfix： 不会修复 duplicate： 重复 on hold： 等待候听","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"sysio","slug":"apue-2","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:12.903Z","comments":true,"path":"2020/12/16/apue-2/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-2/","excerpt":"","text":"sysio1.文件描述符在 SYSIO 中贯穿了一个整形数，它就是文件描述符。对内核而言，所有打开的文件都是通过文件描述符引用的。它的作用与 STDIO 中的 FILE 结构体类似，但是它们的工作原理是完全不同的。它实际上是一个由内核保存的数组下标，所以不会是负数，下面我会用一张图来表示它的作用。 图1 SYSIO 文件描述符 图是在 Ubuntu 下好不容易找到了一个画图软件画的，质量不怎么样，小伙伴们先凑合着看吧。 我解释下图上画的东西。 图片一共分为标准 IO 和系统 IO 两部分，系统 IO 部分有一个数组，这个数组中的指针指向了内核中具体描述文件信息的结构体，而通过这些结构体再引用具体的文件(inode)。而操作系统提供给我们的文件描述符就是这个数组的下标。这个数组的长度是 1024，也就表示一个进程最多可以打开 1024 个文件，当然这个上限可以通过 ulimit(1) 命令修改，具体用法这里不再赘述。 当产生一个文件描述符时，优先采用当前最小的可用数值。假设当前已经占用的文件描述符为1、2、3、5，那么再次产生的文件描述符就是 4。 还要注意一点，上面这个文件描述符数组在每个进程中都会持有一份，所以理论上是每个进程最多可以打开 1024 个文件，而不是系统中所有的进程一共只能打开 1024 个文件。 2. sysio 函数2.1 fileno(3)1234567#include &lt;stdio.h&gt;int fileno(FILE *stream); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): fileno(): _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _POSIX_SOURCE 这个函数的作用是从 STDIO 的 FILE 结构体指针中获得 SYSIO 的文件描述符。 2. 2 fdopen(3)1234567#include &lt;stdio.h&gt;FILE *fdopen(int fd, const char *mode); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): fdopen(): _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _POSIX_SOURCE 这个函数和上面的 flieno(3) 函数的功能是反过来的，作用是把 SYSIO 的文件描述符转换为 STDIO 的 FILE 结构体指针。mode 参数的作用与 fopen(3) 中的 mode 参数相同，这里不再赘述。 虽然这两个函数可以在 STDIO 与 SYSIO 之间互相转换，但是并不推荐对同一个文件同时采用两种方式操作。因为 STDIO 和 SYSIO 之间它们处理文件的私有数据是不同步的，如果同时使用两种方式操作同一个文件则可能带来不可预知的后果，具体可以参考上一篇博文中提到的那个合并系统调用的例子。 2. 3 open(2)12345678open - open and possibly create a file or device #include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode); 想要使用 SYSIO 操作文件或设备，要先通过 open(2) 函数获得一个文件描述符。注意博文中在函数上方标识出来的头文件，大家在使用这个函数的时候一定要一个不少的全部包含到源代码中。 参数列表： pathname：要打开的文件路径。 flags：指定文件的操作方式，多个选项之间用按位或( | )运算符链接。 必选项，三选一：O_RDONLY, O_WRONLY, O_RDWR 可选项：可选项有很多，这里只介绍常用的，想要查看完全的可选项，可以查阅 man 手册。 选项 说明 O_APPEND 追加到文件尾部。 O_CREAT 创建新文件。 O_DIRECT 最小化缓冲。关于缓冲区的解释：buffer 是写操作的加速机制，cache 是读操作的加速机制。 O_DIRECTORY 强调一定要打开一个目录，如果 pathname 不是目录则会打开失败。 O_LARGEFILE 打开大文件的时候要加这个，会将 off_t 定义为 64 bit，当然也可以在编译的时候使用上一篇博文提到的宏定义来指定 off_t 的长度。 O_NOFOLLOW 如果 pathname 是符号链接则不展开，也就是说打开的是符号链接文件本身，而不是符号链接指向的文件。 O_NONBLOCK 非阻塞形式。阻塞是读取不到数据时死等，非阻塞是尝试读取，无论能否读取到数据都返回。 O_TRUNC 将已存在的普通文件长度截断为0（也就是将文件内容清空）。 mode：8 进制文件权限。当 flags 包含 O_CREAT 选项时必须传这个参数，否则可以不用传这个参数。当然系统在创建文件的时候不会直接这个参数，而是通过如下的公式计算得到最终的文件权限： mode &amp; ~(umask) 具体的 umask 的值可以通过 umask(1) 命令获得。通过这样的公式进行计算可以避免程序中创建出权限过高的文件。 不知道小伙伴们注意到没有，这个函数有一个有趣的地方。C 语言中是没有函数重载这个概念的，那么为什么这两个 open(2) 函数很像重载的函数呢？实际上它们是用可变长参数列表来实现的。 顿时让我想起来一道面试题：如何确定一个函数是用重载实现的还是用变长参数实现的？答案是给它多传几个参数嘛，如果报错了那一定是函数重载，否则就是变长参数实现的呗。 2. 4 close(2)12345close - close a file descriptor #include &lt;unistd.h&gt;int close(int fd); 关闭文件描述符。 参数是要关闭的文件描述符。注意当一个文件描述符被关闭之后就不能再使用了，虽然 fd 这个变量的值没有变，但是内核已经将相关的资源释放了，这个 fd 相当于一个野指针了。 返回值： 成功为0，失败为-1。但很少对它的返回值做校验，一般都认为不会失败。 2. 5 read(2)12345read - read from a file descriptor #include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count); 这是 SYSIO 读取文件的函数，作用是从文件描述符 fd 中读取 count 个字节的数据到 buf 所指向的空间。 返回值：返回成功读取到的字节数；0 表示读取到了文件末尾；-1 表示出现错误并设置 errno。 注意 read(2) 函数与 STDIO 中的 fread(3) 函数的返回值是有区别的，fread(3) 返回的是成功读取到了多少个对象，而 read(2) 函数返回的是成功读取到的字节数量。 2. 6 write(2)123write - write to a file descriptor#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count); write(2) 是 SYSIO 向文件中写入数据的函数，作用是将 buf 中 count 字节的数据写入到文件描述符 fd 所对应的文件中。 返回值：返回成功写入的字节数；0 并不表示写入失败，仅仅表示什么都没有写入；-1 才表示出现错误并设置 errno。 注意 write(2) 函数与 STDIO 中的 fwrite(3) 函数的返回值是有区别的，fwrite(3) 返回的是成功写入了多少个对象，而 write(2) 函数返回的是成功写入的字节数量。 大家想一想，为什么会出现写入的值是 0 的情况呢？其实原因有很多，其中一个原因是当写入的时候发生了阻塞，而阻塞中的 write(2) 系统调用恰巧被一个信号打断了，那么 write(2) 可能没有写入任何数据就返回了，所以返回值会是0。至于什么是阻塞，什么是信号，LZ 会在后面的博文中讲解。 2. 7 lseek(2)1234lseek - reposition read/write file offset#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); 通过上一篇博文大家知道了文件位置指针这个概念，它是系统为了方便我们读写文件而设定的一个标记，随着我们通过函数对文件的读写，它会自动相应的向文件尾部偏移。 那么是不是说当我们读取过文件的一段内容之后，就没办法回去再次读取同一段内容了呢？ 其实不是的，通过 lseek(2) 函数就可以让我们随心所欲的控制文件位置指针了。 参数列表： fd：要操作的文件描述符； offset：相对于 whence 的偏移量； whence：相对位置；三选一：SEEK_SET、SEEK_CUR、SEEK_END SEEK_SET 表示文件的起始位置； SEEK_CUR 表示文件位置指针当前所在位置； SEEK_END 表示文件末尾； 返回值： 成功时返回文件首相对于移动结束之后的文件位置指针所在位置的偏移量；失败时返回 -1 并设置 errno； 这个函数的 offset 参数和返回值都对基本数据类型进行了封装，这一点要比标准库的 fseek(3) 更先进。 写一段伪代码来说明这个函数的使用方法。 123lseek(fd, -1024, SEEK_CUR); // 从文件位置指针当前位置向前偏移 1024 个字节lseek(fd, 1024, SEEK_SET); // 从文件起始位置向后偏移 1kblseek(fd, 1024UL*1024UL*1024UL*5UL, SEEK_SET); // 产生一个 5GB 大小的空洞文件 2. 8 time(1)之前讨论过 STDIO 与 SYSIO 的效率问题，所以在这里聊一聊 time(1) 命令。 这个命令可不是用来查看系统当前时间的，想要查看系统时间得使用 date(1) 命令，这个不是我们今天要讨论的内容，所以就不说了。 time(1) 命令的作用是监视一个程序的用户时间，从而可以粗略的帮助我们分析这个程序的执行效率。 123456789101112while ((readlen = read(srcfd, buf, BUFSIZE)) &gt; 0) &#123; pos = 0; while (readlen &gt; 0) &#123; writelen = write(destfd, buf+pos, readlen); if (writelen &lt; 0) &#123; err = errno; goto e_write; &#125; pos += writelen; readlen -= writelen; &#125;&#125; 这是一个模仿 cp(1) 命令的程序的核心部分代码，其中的 buf 是一个 char 数组，用来作为数据读写的缓存。当 buf 的容量不同时文件拷贝的效率也是不同的，因为过于频繁的执行系统调用和使用过大的缓存都会使效率下降。如果通过不停的修改 buf 的容量的方式测试 buf 为多大的时候拷贝效率最高的话，就可以使用 time(1) 命令监视程序的执行时间。 12345gcc -Wall mycp_sysio.c -o mycp_sysiotime ./mycp_sysio rhel-server-6.4-x86_64-dvd.iso tmp.isoreal 1m30.014suser 0m0.003ssys 1m29.003s sys 是程序在内核态消耗的时间，也就是执行系统调用所消耗的时间。 user 是程序在用户态消耗的时间，也就是程序本身的代码所消耗的时间。 real 是用户等待的总时间，是 sys + user + CPU 调度时间，所以 real 时间会稍微比 sys + user 时间长一点。一个程序从提高响应素的的方式提高用户体验，一般指的就是提高 real 时间。 3 文件共享 文件共享就是指多个进程共同处理同一个文件，就是 图1 中第二个文件表项和第三个文件表项共同指向同一个 inode 的图示，不过这两个文件表项来自于不同的进程表项时才叫做文件共享。 3.1 原子操作 通俗来讲，原子操作就是将多个动作一气呵成的做完，中间不会被打断，要么执行完所有的步骤，要么一步也不会执行。这里用创建临时文件来举个栗子。 123tmpnam, tmpnam_r - create a name for a temporary file#include &lt;stdio.h&gt;char *tmpnam(char *s); 如果我们需要创建一个临时文件，那么首先需要又操作系统提供一个文件名，然后再创建这个文件。 tmpnam(3) 函数就是用来获得临时文件的文件名的。为什么要通过这个函数由操作系统来为我们生成文件名呢？就是因为系统中进程比较多，临时文件也比较多，怕文件重名嘛。 但是这个函数只负责生成一个目前系统中不存在的临时文件名，并不负责创建一个文件，所以创建文件的任务要由我们自己使用 fopen(3) 或 open(2) 等手段创建。 假设在我们拿到这个文件名的时候，临时文件还没有在磁盘上真正创建，另一个进程拿到了一个与我们相同的文件名，那么这个时候再创建文件就是有问题的了。 这就是因为获得文件名与创建文件这个动作不原子造成的，如果获得唯一的文件名和创建文件这个动作一气呵成中间不会被打断，则这个问题就不会发生，我们创建好文件之后另一个进程就再也拿不到相同的文件名了。 123tmpfile - create a temporary file#include &lt;stdio.h&gt;FILE *tmpfile(void); 既然使用 tmpnam(3) 函数无法原子的创建临时文件，那么就没有原子的方式来避免上面描述的问题了吗？当然有办法，那就是使用 tmpfile(3) 函数来创建临时文件。 tmpfile(3) 函数是获得文件名和创建临时文件的动作一气呵成的，它直接会返回一个创建好的 FILE 结构体指针给我们，这样一来妈妈再也不用担心我们的文件名会被别人抢占了。:) 当然系统中有许多地方需要原子操作，不仅仅是创建临时文件，所以系统还有其它函数提供了原子操作，遇到的时候我们再讲解，这里不再详述。 3.2 dup(2)、dup2(2)12345dup, dup2 - duplicate a file descriptor#include &lt;unistd.h&gt; int dup(int oldfd);int dup2(int oldfd, int newfd); 这两个函数是用来复制文件描述符的，就是 图1 中 文件描述符 3 和 6 指向了同一个文件表项的情况。 举个栗子，用 dup(2) 实现输出的重定向。 1234567891011#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main (void)&#123; /* 要求在不改变下面的内容的情况下，使输出的内容到文件中 */ puts(\"dup test.\"); return 0; &#125; puts(3) 函数是将参数字符串写入到标准输出 stdout（文件描述符是 1） 中，而标准输出默认目标是我们的 shell。如果想要让 puts(3) 的参数输出到一个文件中，实现思路是：首先打开一个文件获得一个新的文件描述符，然后关闭标准输出文件描述符(1)，然后使用 dup(2) 函数族复制产生一个新的文件描述符，此时的 1 号文件描述符就不是标准输出的文件描述符了，而是我们自己创建的文件的描述符了。还记得我们之前提到过吗，文件描述符优先使用可用范围内最小的。进程中当前打开的文件描述符有标准输入(0)、标准输出(1)、标准错误(2)和我们自己打开的文件(3)，当我们关闭了 1 号文件描述符后，当前可用的最小文件描述符是 1，所以新复制的文件描述符就是 1。而标准库函数 puts(3) 在调用系统调用 write(2) 函数向 1 号文件描述符打印时，正好是打印到了我们所指定的文件中。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; int main (void) &#123; int fd = -1; fd = open(\"tmp\", O_WRONLY | O_CREAT | O_TRUNC, 0664); /* if error */ #if 0 close(1); // 关闭标准输出 dup(fd); #endif dup2(fd, 1); close(fd); /* 要求在不改变下面的内容的情况下，使输出的内容到文件中 */ puts(\"dup test.\"); return 0;&#125; 由于题目的要求是 puts(3) 上面注释以下的内容都不能修改，原则上 1 号文件描述符在这里使用完毕也需要 close(2)，所以这里造成了一个内存泄漏，但并不影响对 dum(2) 函数族的解释和测试。 上面的代码用 close(2) + dup(2) 的方式或者 dup2(2) 的方式都可以实现。 dup(2) 和 dup2(2) 的作用是相同的，区别是 dum2(2) 函数可以用第二个参数指定新的文件描述符的编号。 如果新的文件描述符已经被打开则先关闭它再重新打开。 如果两个参数相同，则 dup2(2) 函数会返回原来的文件描述符，而不会关闭它。 另外一点比较重要，close(2) + dup(2) 的方式不原子，而 dup2(2) 这两步动作是原子的，在并发的情况下可能会出现问题。后面的博文我们会通过信号和多线程来讨论并发。 3.3 sync(2)123456// sync, syncfs - commit buffer cache to disk#include &lt;unistd.h&gt;void sync(void);int fsync(int fd); // 有指向的一个文件描述符int fdatasync(int fd); // 只刷数据，不刷亚数据， 数据指的是文件内有效的内容，亚数据指的是描述 文件 以及文件操作内容 的信息数据； sync(2) 函数族的函数作用是全局催促，将 buffer 和 cache 刷新和同步到 disk，一般在设备即将卸载的时候使用。这个函数族的函数不是很常用，所以用到的时候再具体讨论，这里不再详述。 3.4 fcntl(2) 文件描述符 所边的魔术几乎都来源于该函数 1234567891011// fcntl - manipulate file descriptor 管理文件描述符#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ );/** * fd: 文件描述符 * cmd： 要对此文件描述符做什么样的事情 * arg： 要做的这件事情，需要传递的参数 （由于命令不同，会造成传参不同，由于命令不同，会造成返回值不同）*/ 这是一个管家级别的函数，根据不同的 cmd 和 arg 读取或修改对已经打开的文件的操作方式。具体的命令和参数请查阅 man 手册，这里不再花费大量篇幅赘述。 3.5 ioctl(2)12345// ioctl - control device#include &lt;sys/ioctl.h&gt;int ioctl(int d, int request, ...); Linux 的一切皆文件的设计原理将所有的设备都抽象为一个文件，当一个设备的某些操作不能被抽象成打开、关闭、读写、跳过等动作时，其它的动作都通过 ioctl(2) 函数控制。 例如将声卡设备抽象为一个文件，录制音频和播放音频的动作则可以被抽象为对声卡文件的读、写操作。但是像配置频率、音色等功能无法被抽象为对文件的操作形式，那么就需要通过 ioctl(2) 函数对声卡设备进行控制，具体的控制命令则由驱动程序提供。 3.6 /dev/fd/dev/fd 是一个虚拟目录，它里面是当前进程所使用的文件描述符信息。如果用 ls(1) 查看，则里面显示的是 ls(1) 这个进程所使用的文件描述符信息。而打开里面的文件则相当于复制文件描述符。","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"标准io","slug":"apue-1","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:08.387Z","comments":true,"path":"2020/12/16/apue-1/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-1/","excerpt":"","text":"APUEAPUE主要讨论了三部分内容：文件IO、并发、进程间通信。 *文件IO: * 标准IO：优点是可移植性高，缺点是性能比系统 IO 差，且功能没有系统 IO 丰富。系统IO：因为是内核直接提供的系统调用函数，所以性能比标准 IO 高，但是可移植性比标准 IO 差。 并发： 信号 + 多进程；多线程； 进程间通信： FIFO：管道； System V：又称为 XSI，支持以下三种方式： msg：消息队列； sem：信号量； shm：共享存储； Socket：套接字（网络通信）； 文件 IO 前面提到了标准 IO（STDIO）和系统 IO（SYSIO），那么这里整理一下它们的差别。 1.1 stdio 和 sysio 异同 类型 可移植性 实时性 吞吐量 功能 STDIO 高 低 高 受限 SYSIO 低 高 低 自由 表格中的每一项都是两者之间相对而言，使用哪种 IO 并没有绝对的好坏之分，要根据实际的需求来决定应该使用哪个。 1.1.1 可移植性：标准 IO 是 C89 支持的函数，所以使用了标准 IO 的程序无论在 Linux 平台还是换成了 Windows 平台，不用修改代码是可以直接编译运行的。 而系统 IO 是由内核直接提供的函数库实现的，不同的操作系统平台上提供的 IO 操作接口是不同的，所以想要移植使用了系统 IO 的程序，必须按照目标平台的 IO 库修改程序并重新调试。 所以你写的程序将来可能在不同的平台上运行，那么最好使用标准 IO 库；如果你的程序是专门针对于某个平台而开发的，那么使用系统 IO 库能够得到我们下面说的其它优势。 1.1.2 实时性和吞吐量：123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main (void)&#123; putchar('a'); write(1, \"b\", 1); putchar('a'); write(1, \"b\", 1); putchar('a'); write(1, \"b\", 1); printf(\"\\n\"); return 0;&#125; 123$ gcc -Wall 1.c$ ./a.out# bbbaaa 输出的结果为什么不是 ababab 呢，这就是因为标准 IO 具有合并系统调用的功能，putchar(3) 将本应该执行多次的 write(2) 动作合并成了一步来完成，所以 aaa 是作为一个字符串打印的，这一点我们可以通过 strace(1) 命令跟踪系统调用来得出结论(下方第7行)。另外由于 stdout 默认使用的是行缓冲模式(下面会讲缓冲)，所以对 putchar(3) 的调用并没有立即打印出来。 12345678910$ strace ./a.out# ... 此处省略n行不相关内容mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS,-1,0) = 0x7f077a35f000 write(1, \"b\", 1b) = 1 write(1, \"b\", 1b) = 1 write(1, \"b\", 1b) = 1 write(1, \"aaa\\n\", 4aaa ) = 4 exit_group(0) $ 到这里我们还是没有说明白为什么标准 IO 吞吐量高，而系统 IO 实时性高。我再举个简单的栗子：门卫老大爷负责送信到邮局，他去一次邮局要花费 10 分钟的时间，而每次最多能送 20 封信，每当信件累计到 20 封的时候他就要动身去邮局了。但是当他收到一封加急的邮件时，就会立即去一趟邮局。系统 IO 就好比每收到一封信时都要去一趟邮局，所以实时性高。而标准 IO 就好比要攒够 20 封信才去一趟邮局，所以吞吐量高，因为用户把信件交到老大爷的手上时就会立即返回，响应速度快，用户体验更好。而我们使用 fflush(3) 之类的函数强制刷新缓冲的时候，就相当于是老大爷收到了一封加急信件需要立即去一趟邮局送信。 至于这里所说的标准 IO 功能受限，是因为标准 IO 在各个平台上都是使用系统 IO 封装的，为了使它具有通用性，又要考虑底层操作系统各自平台在实现上的差异，难免在功能上就要作出让步。 1.2 文件位置指针当我们打开一个文件要对它进行读写的时候，我们怎么能知道要从哪里开始读（写）文件呢？其实标准库准备了一个工具辅助我们读写文件，它就是文件位置指针。当我们使用标准库函数操作文件的时候，它会自动根据文件位置指针找到我们要操作的位置，也会随着我们的读写操作而自动修改指向，而不用我们自己手动记录和修改文件的操作位置。它使用起来非常方便，以至于你完全感觉不到它的存在，但是为了更好的理解文件 IO，你必须知道它的作用。 1.3 stdio函数1.fopen(3)123fopen - stream open functions#include &lt;stdio.h&gt;FILE *fopen(const char *path, const char *mode); 这是今天要学习的第一个函数，在操作文件之前，我们需要通过 fopen() 函数将文件打开，通过这个函数我们可以告诉操作系统我们要操作的是哪个文件，以及用什么样的方式操作这个文件。 参数列表： path：要操作的文件路径。 mode：文件的打开方式，这个打开方式一共分为6种。 r：以只读的方式打开文件，并且文件位置指针会被定位到文件首。如果要打开的文件不存在则报错。 r+：以读写的方式打开文件，并且文件位置指针会被定位到文件首。如果要打开的文件不存在则报错。 w：以只写的方式打开文件，如果文件不存在则创建，如果文件已存在则被截断为 0 字节，并且文件位置指针会被定位到文件首。 w+：以读写的方式打开文件，如果文件不存在则创建，如果文件已存在则被截断为 0 字节，并且文件位置指针会被定位到文件首。 a：以追加的方式打开文件，如果文件不存在则创建，且文件位置指针会被定位到文件最后一个有效字符的后面（EOF，end of the file）。 a+：以读和追加的方式打开文件，如果文件不存在则创建，且读文件位置指针会被初始化到文件首，但是总是写入到最后一个有效字符的后面（EOF，end of the file）。 返回值： FILE 是一个由标准库定义的结构体，各位童鞋不要企图通过手动修改结构体里的内容来实现文件的操作，一定要通过标准库函数来操作文件。 这个函数返回一个 FILE 类型的指针，它作为我们打开文件的凭据，后面所有对这个文件的操作都需要使用这个指针，而且使用之后一定不要忘记调用 fclose(3) 函数释放资源。 如果该函数返回了一个指向 NULL 的指针，则表示文件打开失败了，可以通过 errno 获取到具体失败的原因。 error 是什么呢？它是标准 C 中定义的一个整形值，用来表示上次发生的错误。大家可以在头文件中看看 errno 都定义了哪些值： 12vim /usr/include/asm-generic/errno.hvim /usr/include/asm-generic/errno-base.h 通常系统调用会给我们我返回一个整形值来表示是否出现了错误，当出现了错误的时候会设置 errno，通过 errno 我们就可以得知出现了什么错误了。 当然，直接给我们一个数字，我们自己再从头文件中查找这个数字表示的意义，然后再打印出来给用户看，似乎态麻烦了，没有什么简便的办法吗？ 别担心，其实标准库已经为我们准备好专门的转换函数了：perror(3) 和 strerror(3) perror(3) 会自动读取 errno 帮我们转换成对应的文字描述，并且将它们输出到标准错误流中。它的参数是一个字符串，用来让我们自定义一些错误消息给用户看，它的输出格式就是 我们给传递的参数：errno 转换的描述文字。 strerror(3) 函数也会将 errno 转换为文字，不过它不会自动读取 errno 当前的值，需要我们把 errno 传递给它。它也不会帮我们输出到标准输出中，而是将转换完的字符串返回给我们。 如果大家是开发一个前台应用，一般可以使用 perror(3) 函数直接将错误输出给用户。 如果大家开发的是后台应用（如守护进程等），那么一般先使用 strerrno(3) 函数将 errno 转换为字符串，然后再把这个字符串传给日志系统记录下来。 大家在使用 errno 这个全局变量的时候要导入 errno.h 头文件： 1#include &lt;errno.h&gt; 在使用 strerror(3) 函数时不要忘记导入 string.h 头文件，否则会报段错误！ 1include &lt;string.h&gt; 其实现在的很多 *nix 系统中，errno 早已不是全局变量了，为了线程安全它已经变成了一个宏定义，这个我们在后面的博文中介绍线程的时候会讨论它。 2.fclose(3)12345fclose - close a stream#include &lt;stdio.h&gt;int fclose(FILE *fp); 这个函数是与 fopen(3) 函数对应的，当我们使用完一个文件之后，需要调用 fclose(3) 函数释放相关的资源，否则会造成内存泄漏。当一个 FILE 指针被 fclose(3) 函数成功释放后，这个指针所指向的内容将不能再次被使用，如果需要再次打开文件还需要调用 fopen(3) 函数。 参数列表： fp：fopen(3) 函数的返回值作为参数传入即可。 3.fgets(3)1234567fgets - input of strings #include &lt;stdio.h&gt; int fgetc(FILE *stream); char *fgets(char *s, int size, FILE *stream); 从输入流 stream 中读取一个字符串回填到 s 所指向的空间。 这里出现了一个 stream 的概念，这个 stream 是什么呢，它被成为“流”，其实就是操作系统对于可以像文件一样操作的东西的一种抽象。它并非像自然界的小河流水一样潺潺细流，而通常是要么没有数据，要么一下子来一坨数据。当然 stream 也未必一定就是文件，比如系统为每个进程默认打开的三个 stream：stdin、stdout、stderr，它们本身就不是文件，就是与文件有着相同的操作方式，所以同样被抽象成了“流”。 这个函数并没有解决 gets(3) 函数可能会导致的数组越界问题，而是通过牺牲了获取数据的正确性来保证程序不会出现数组越界的错误，实际上是掩盖了 gets(3) 的问题。 该函数遇到如下四种情况会返回： 1.当读入的数据量达到 size - 1 时； 2.当读取的字符遇到 \\n 时； 3.当读取的字符遇到 EOF 时； 4.当读取遇到错误时； 并且它会在读取到的数据的最后面添加一个 \\0 到 s 中。 返回值： 成功时返回 s。 返回 NULL 时表示出现了错误或者读到了 strem 的末尾(EOF)。 4.fread(3)、fwrite(3)1234567fread, fwrite - binary stream input/output#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 这两个函数使用得最频繁，用来读写 stream，通常是用来读写文件。 参数列表： ptr：fread(3) 将从 stream 中读取出来的数据回填到 ptr 所指向的位置；fwrite(3) 则将从 ptr 所只想的位置读取数据写入到 stream 中； size：要读取的每个对象所占用的字节数； nmemb：要读取出多少个对象； stream：数据来源或去向； 返回值： 注意这两个函数的返回值表示的是成功读（写）的对象的个数，而不是字节数！ 例如： 123read(buf, 1, 10, fp); // 读取 10 个对象，每个对象 1 个字节read(buf, 10, 1, fp); // 读取 1 个对象，每个对象 10 个字节 当数据量充足的时候，这两种方式是没有区别的。 但是！！当数据量少于 size 个字节的整倍数时，第二种方法的的最后一个对象会读取失败。比如数据只有 45 个字节，那么第二种方法的返回值为 4，因为它只能成功读取 4 个对象。 所以通常第一种方式读写数据使用得比较普遍。 5.atoi(3)12345678 atoi, atol, atoll, atoq - convert a string to an integer #include &lt;stdlib.h&gt;int atoi(const char *nptr);long atol(const char *nptr);long long atoll(const char *nptr);long long atoq(const char *nptr); atoi(3) 函数族在这里提一下，主要是为了下面的 printf(3) 函数族做一个铺垫。 这些函数的作用是方便的将一个字符串形式的数字转换为对应的数字类型的数字。 上面这句话可能有点坳口，给你看个例子就懂了，下面是伪代码。 123char *str = \"123abc456\";int i = 0;i = atoi(str); i 的结果会变成 123。这些函数会转换一个字符串中地一个非有效数字前面的数字。如果很不幸这个字符串中的第一个字符就不是一个有效数字时，那么它们会返回 0。 6.printf(3)12345678printf, fprintf, sprintf, snprintf - formatted output conversion #include &lt;stdio.h&gt;int printf(const char *format, ...);int fprintf(FILE *stream, const char *format, ...);int sprintf(char *str, const char *format, ...);int snprintf(char *str, size_t size, const char *format, ...); printf(3) 函数大家一定不会陌生了，应该从写 Hello World! 的时候就接触到了的吧，所以我也不多介绍了，主要介绍两个内容。 一个是面试常考的一个问题，用了这么久的 printf(3) 函数，大家有没有注意过它的返回值表示什么呢？ printf(3) 的返回值表示成功打印的有效字符数量，不包括 \\0。 另一个要说的就是刚才我们提到了 atoi(3) 函数族，它们负责将字符串转换为数字，那么有没有什么函数可以将数字转换为字符串呢，其实通过 sprintf(3) 或 snprintf(3) 就可以了。 有了这两个函数，不仅可以方便的将数字转换为字符串，还可以将多个字符串任意拼接为一个完整的字符串。 这里直接讲解一下 snprintf(3) 函数。 参数列表： str：拼接之后的结果会回填到这个指针所指向的位置； size：size - 1 为回填到 str 中的最大长度，数据超过这个长度的部分则会被舍弃，然后会在拼接的字符串的尾部追加 \\0； format：格式化字符串，用法与 printf(3) 相同，这里不再赘述； …：格式化字符串的参数，用法与 printf(3) 相同； 这个函数与 fputs(3) 一样，只是掩盖了 sprintf(3) 可能会导致的数组越界问题，通过牺牲数据的正确性来保证程序不会出现数组越界的错误。 7.scanf(3)1234567scanf, fscanf, sscanf - input format conversion #include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *stream, const char *format, ...);int sscanf(const char *str, const char *format, ...); scanf(3) 函数族相信也不用过多的介绍了，这里唯一要强调的就是：scanf(3) 函数支持多种格式化参数，唯独 %s 是不能安全使用的，可能会导致数组越界，所以当需要接收用户输入的时候可以使用 fgets(3) 等函数来替代。 8.fseek(3)123456789fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence);long ftell(FILE *stream);void rewind(FILE *stream); fseek(3) 函数族的函数用来控制和获取文件位置指针所在的位置，从而能够使我们灵活的读写文件。 介绍一下 fseek(3) 函数的参数列表： stream：这个已经不需要多介绍了吧，就是准备修改文件位置指针的文件流； offset：基于 whence 参数的偏移量； whence：相对于文件的哪里；有三个宏定义可以作为它的参数：SEEK_SET（文件首）, SEEK_CUR（当前位置）, or SEEK_END（文件尾）； 返回值： 成功返回 0；失败返回 -1，并且会设置 errno。 单独看参数列表也许你还有所疑惑，那么我写点简单的伪代码作为例子： 1 fseek(fp, -10, SEEK_CUR); // 从当前位置向前偏移10个字节。2 fseek(fp, 2GB, SEEK_SET); // 可以制造一个空洞文件，如迅雷刚开始下载时产生的文件。ftell(3) 函数以字节为单位获得文件指针的位置。 fseek(fp, 0, SEEK_END) + ftell(3) 可以计算出文件总字节大小。 还有一个值得大家注意的问题： fseek(3) 和 ftell(3) 的参数和返回值使用了 long，所以取值范围为 -2GB ~ (2GB-1)，而 ftell(3) 只能表示 2G-1 之内的文件大小，所以可以使用 fseeko(3) 和 ftello(3) 函数替代它们，但它们只是方言（SUSv2, POSIX.1-2001.）。 由于这两个函数比较古老，所以设计的时候认为 +-2GB 的取值范围已经足够用了，而没有意识到科技发展如此迅速的今天，2GB 大小的文件已经完全不能满足实际的需求了。 rewind(3) 函数将文件位置指针移动到文件起始位置，相当于： 1 (void) fseek(stream, 0L, SEEK_SET) 9.getline(3)12345678910111213getline - delimited string input #include &lt;stdio.h&gt; ssize_t getline(char **lineptr, size_t *n, FILE *stream); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): getline(): Since glibc 2.10: _POSIX_C_SOURCE &gt;= 200809L || _XOPEN_SOURCE &gt;= 700 Before glibc 2.10: _GNU_SOURCE 这个函数是一个非常好用的函数，它能帮助我们一次获取一行数据，而无论这个数据有多长。 参数列表： lineptr：一个一级指针的地址，它会将读取到的数据填写到一级指针指向的位置，并将&gt;该位置回填到该参数中。指针初始必须置为NULL，该函数会根据指针是否为 NULL 来决定是否需要分配新的内存。 n：是由该函数回填的申请的内存缓冲区的总大小，长度初始必须置为0。虽然很好用，但是各位童鞋别高兴得太早了，该函数仅支持 GNU 标准，所以是方言，大家还是自己封装一个备用吧。 另外，想要使用这个函数必须在编译的时候指定 -D_GNU_SOURCE 参数： $&gt; gcc -D_GNU_SOURCE 当然如果不想在编译的时候添加参数，也可以在引用头文件之前 #define _GNU_SOURCE，只是比较丑陋而已。 还有一个办法，是在 makefile 中配置 CFLAGS += -D_GNU_SOURCE，这样即省去了编译时手动写参数的麻烦，也避免了代码中的丑陋。 10.fflush(3)12345fflush - flush a stream #include &lt;stdio.h&gt; int fflush(FILE *stream); fflush(3) 函数的作用是刷新缓冲区，提到这个函数就要讲讲缓冲区了。 缓冲区的作用是为了合并系统调用，在上面讲 STDIO 与 SYSIO 的区别时大家已经看到什么是合并系统调用了。 Linux 系统中有三种缓冲形式：无缓冲、行缓冲和全缓冲。 无缓冲：需要立刻输出时使用，例如 stderr； 行缓冲：遇到换行符时进行刷新、缓冲区满了的时候刷新、强制刷新(fflush(3))；而标准输出(stdout)是行缓冲，因为涉及到终端设备； 全缓冲：只有缓冲区满了的时候和强制刷新(fflush(3))时才会刷新，这是 Linux 默认的缓冲模式，但终端设备除外，终端设备使用行缓冲模式； 当数据被放入缓冲区的时候是不会通过系统调用(read(3)、write(3))送到内核中的，只有缓冲区被刷新的时候数据才会通过系统调用进入内核。而刷新缓冲区就是 fflush(3) 函数的作用。 fflush(3) 的参数是具体要刷新的流，当参数为 NULL 时会刷新所有的输出流。 man手册man 手册一共有 8 章，每一章保存不一样的内容，这八章的内容分别是： 第一章：shell 命令。如：ls、vim，查询方法： man ls 第二章：系统调用。如：open、close，查询方法：man 2 open 或 man close。因为第一章也有 open，所以 man 的参数中要加章节号；因为第一章中没有 close，所以查询 close 不需要加章节号。 第三章：库函数。如：printf、fopen，查询方法：man 3 printf 或 man fopen 第四章：/dev 下的文件。如：zero。 第五章：一些配置文件的格式。如：/etc/shadow，查询方法：man shadow 第六章：预留给游戏的，由游戏自己定义。如：sol。 第七章：附件和变量。如 iso-8859-1。 第八章：只能由 root 执行的系统管理命令。如 mkfs。 因为有些函数的名字会在不同的章节出现，这种函数在查询 man 手册的时候如果不加上章节号默认会查询低编号的章节。 比如 printf，如果你输入的查询命令是 man printf，那么打开的并不是 printf 标准库函数的手册，而是 printf shell 命令的手册，想要查询 printf 函数的手册就需要在 man 命令后面加上该函数所在的章节数，正确的命令是 man 3 printf，这样就会打开 man 手册第三章的 printf 函数。 另外，如果想查看每个章节中都有哪些内容，可以使用 man -aw 命令得到 man 手册的安装路径，然后找到对应的 man 章节的目录，再用 zcat 命令查看那些 gz 文件。","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"进程间通信","slug":"apue-10","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:51.400Z","comments":true,"path":"2020/12/16/apue-10/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-10/","excerpt":"","text":"进程间通信 进程间通信（IPC） 分为 PIPE（管道）、Socket（套接字） 和 XSI（System V）。XSI 又分为 msg（消息队列）、sem（信号量数组） 和 shm（共享内存）。进程间通信又分同一台主机上 和 不同的主机上的。 管道 XSI -&gt; SYSV 网络套接字（跨网络的进程通信） 封装协议 协议就是双方约定对话的格式，实际上每一个用于传输的例子都是在封装协议。 这些手段都是用于进程间通讯的，只有进程间通讯才需要借助第三方机制，线程之间的通讯是不需要借助第三方机制的，因为线程之间的地址空间是共享的。 1.1 管道 管道分为命名管道（FIFO）和匿名管道（PIPE）；无论是哪种管道，都是由内核帮你创建和维护的； 管道的特点： 1.管道是半双工的，即同一时间数据只能从一端流向另一端。试想，如果一个管道从两边同时输入和输出数据，那么管道里的数据就乱了。 2.管道是单工，两端一端作为读端，一端作为写端。 3.管道具有自适应的特点，默认会适应速度比较慢的一方，管道被写满或读空时速度快的一方会自动阻塞。 匿名管道pipe(2) 函数 1234// pipe - create pipe#include &lt;unistd.h&gt;int pipe(int pipefd[2]); 返回值0 成功，-1失败 pipe(2) 用于创建管道，pipefd 是一个数组，表示管道的两端文件描述符，pipefd[0] 端作为读端，pipefd[1] 端作为写端。 pipe(2) 产生的是匿名管道，在磁盘的任何位置上找不到这个管道文件，而且匿名管道只能用于具有亲缘关系的进程之间通信。 一般情况有亲缘关系的进程之间使用管道进行通信时，会把自己不用的一端文件描述符关闭。 下面是创建匿名管道在父子进程之间传送了一个字符串“Hello”的小栗子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#define BUFSIZE 1024int main()&#123; int pd[2]; char buf[BUFSIZE]; pid_t pid; int len; // 创建匿名管道 if(pipe(pd) &lt; 0) &#123; perror(\"pipe()\"); exit(1); &#125; // 创建子进程 pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) &#123; // 子进程 读取管道数据 // 关闭写端 close(pd[1]); // 从管道中读取数据，如果子进程比父进程先被调度会阻塞等待数据写入 len = read(pd[0],buf,BUFSIZE); puts(buf); /* 管道是 fork(2) 之前创建的， * 父子进程里都有一份， * 所以退出之前要确保管道两端都关闭 */ close(pd[0]); exit(0); &#125; else &#123; // 父进程 向管道写入数据 close(pd[0]); write(pd[1],\"Hello!\",6); close(pd[1]); wait(NULL); exit(0); &#125;&#125; 把一个命令的标准输出做成另一个命令的标准输入 cat h.mp3 | mpg123 - 在上面的栗子中，父进程创建了一个匿名管道，在 pd[2] 数组中凑齐了读写双方，子进程同样继承了具有读写双方的数组 pd[2]。 父进程先关闭管道的读端然后向管道中写入数据，然后将用完的写端也关闭，等待子进程消亡并为其收尸。 子进程先关闭管道的写端然后读取父进程写入管道的字符串，把它打印到控制台之后再关闭用完的读端，然后退出。 这个程序在 fork(2) 之后如果是子进程先运行，那么会阻塞在 read(2) 阶段，等待父进程被调度并向管道中写入数据。 如果在 fork(2) 之后是父进程先运行，那么父进程会阻塞在 wait(2) 阶段等待子进程运行结束。 所以无论是谁先运行，只要没有出现异常运行的结果都是我们预期之内的。 命名管道mkfifo 命令 管道有一个自同步的机制，必须凑齐读写双方才能操作。 12345$&gt; mkfifo namedfifo # 创建一个命令管道$&gt; ls -l namedfifoprw-r--r--. 1 6月 7 17:47 namedfifo$&gt; date &gt; namedfifo 12# 另一个终端上$&gt; cat namedfifo # 相当于读者读管道 mkfifo(3) 函数 123456// mkfifo - make a FIFO special file (a named pipe)#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); mkfifo(3) 函数用于创建命名管道，作用与匿名管道相同，不过可以在不同的进程之间使用，相当于对一个普通文件进行读写操作就可以了。 这个管道文件是任何有权限的进程都可以使用的，两端都像操作一个普通文件一样对它进行打开、读写、关闭动作就可以了，只要一端写入数据另一端就可以都出来。 但是最好一端只读一端只写，否则在实际项目中你很难保证拿出的不是脏数据（自己写进去数据的混合着另一端写进去的数据被其中一端读了出来），除非像下面那个栗子那样结构简单清晰。 参数列表： pathname：管道文件的路径和文件名。 mode：创建管道文件的权限。还是老规矩，传入的 mode 值要与系统的 umask 值做运算：(mode &amp; ~umask) 返回值：成功返回 0，失败返回 -1 并设置 errno。 我们看下面的栗子是如何使用命名管道通讯的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define PATHNAME \"/tmp/myfifo\"int main (void)&#123; pid_t pid; int fd = -1; char buf[BUFSIZ] = \"\"; // 创建一个命名管道，大家可以用 ls -l 命令查看这个管道文件的属性 if (mkfifo(PATHNAME, 0644) &lt; 0) &#123; perror(\"mkfifo()\"); exit(1); &#125; fflush(NULL); pid = fork(); if (pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if (!pid) &#123; // parent pid = fork(); if (pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if (!pid) &#123; // parent // 两个子进程都创建完之后父进程直接退出，使两个子进程不具有亲缘关系。 exit(0); &#125; /* child 2 */ /* 像操作普通文件一样对这个管道进行 open(2)、read(2)、write(2)、close(2) */ fd = open(PATHNAME, O_RDWR); if (fd &lt; 0) &#123; perror(\"open()\"); exit(1); &#125; read(fd, buf, BUFSIZ); printf(\"%s\", buf); write(fd, \" World!\", 8); close(fd); exit(0); &#125; else &#123; // child 1 fd = open(PATHNAME, O_RDWR); if (fd &lt; 0) &#123; perror(\"open()\"); exit(1); &#125; write(fd, \"Hello\", 6); sleep(1); // 刚写完管道不要马上读，等第二个进程读取完并且写入新数据之后再读。 read(fd, buf, BUFSIZ); close(fd); puts(buf); // 肯定是这个进程最后退出，所以把管道文件删除，不然下次再创建的时候会报文件已存在的错误 remove(PATHNAME); exit(0); &#125; return 0;&#125; 这段代码很简单，父进程首先在磁盘上创建一个命名管道文件，然后创建两个子进程后退出。每个子进程都对管道文件进行一次读和一次写的动作，然后子进程退出，整个过程就结束了。 第一个子进程在写完管道之后要先休眠，等待第二个子进程从管道的另一端把数据读入并写入新的数据，第一个子进程再醒来读出管道的内容。如果第一个子进程不休眠而是在写完之后马上读管道，很可能在它写完管道之后第二个子进程还没来得及调度，它自己就又把管道里的数据读出来了，这样不仅读出来的不是第二个子进程写入的数据，还会导致第二个子进程永远阻塞在 read(2) 阶段，因为管道中不会再有数据写入。 管道大家都会用了吗？看上去不是很难是吧，赶快自己动手写写试试吧。 协同进程（双工管道）这一小节主要是说管道是半双工的，两个进程一个只能对它读，另一个只能对它写，否则会出现脏数据，也就是无法区分出读出来的数据是来自于自己的还是来自于另一个进程的。 如果想要实现双工，必须采用两个管道，一个进程对一个管道只读，对另一个管道只写。 明白了这个原理，相信大家可以利用上面的 pipe(2) 或 mkfifo(3) 函数利用两个半双工管道实现进程之间的全双工通讯。 1.2 XSI IPCIPC -&gt; Inter - Process Communication XSI IPC 分三种机制 Message Queues 消息队列 Semaphore Arrays 信号量数组 Shared Memory Segments 共享内存 XSI IPC 是 System V 规范里面的进程间通信手段，而不是 POSIX 标准的。关于 System V、POSIX 等等的前世今生可以自行 Google 一下 在学习 XSI IPC 之前，我们先来认识两条命令： ipcs(1) 命令可以查看 XSI IPC 的使用情况。 ipcrm(1) 命令可以删除指定的 XSI IPC。 为什么要先介绍这两个命令呢？如果实验的过程中需要查看 IPC 是否建立成功，可以通过 ipcs(1) 命令，如果实验出问题了，则可以使用 ipcrm(1) 命令删除错误的 IPC。 12345678910111213141516171819202122232425262728293031$ ipcs------ Shared Memory Segments --------key shmid owner perms bytes nattch status 0x00000000 32769 usera 600 393216 2 dest 0x00000000 65538 usera 600 393216 2 dest 0x00000000 98307 usera 600 393216 2 dest 0x00000000 131076 usera 600 393216 2 dest 0x00000000 163845 usera 600 393216 2 dest 0x00000000 196614 usera 600 393216 2 dest 0x00000000 229383 usera 600 393216 2 dest 0x00000000 262152 usera 600 393216 2 dest 0x00000000 294921 usera 600 393216 2 dest 0x00000000 327690 usera 600 393216 2 dest 0x00000000 360459 usera 600 393216 2 dest 0x00000000 393228 usera 600 393216 2 dest 0x00000000 425997 usera 600 393216 2 dest 0x00000000 458766 usera 600 393216 2 dest 0x00000000 491535 usera 600 393216 2 dest 0x00000000 524304 usera 600 393216 2 dest 0x00000000 557073 usera 600 393216 2 dest 0x00000000 589842 usera 600 393216 2 dest 0x00000000 655380 usera 600 393216 2 dest ------ Semaphore Arrays --------key semid owner perms nsems------ Message Queues --------key msqid owner perms used-bytes messages $ 通过 ipcs(1) 命令可以看出来，命令的输出结果分为三个部分，第一部分是系统中当前开辟的共享内存（shm），第二部分是信号量数组（sem），第三部分是消息队列（msg）。 可以看到，不论是哪一部分，都有一列叫做“key”，没错，使用 XSI IPC 通信的进程就是通过同一个 key 值操作同一个共享资源的。这个 key 是一个正整数，与文件描述符不同的是，生成一个新 key 值时它不采用当前可用数值中的最小值，而是类似生成进程 ID 的方式，key 值连续的加 1，直至达到一个整数的最大正值，然后再回转到 0 从头开始累加。 1.2.1 Message Queues 有没有亲缘关系的进程间通讯都可以使用消息队列，消息队列是双工的。 消息队列可以让通信双方传送结构体数据，这样也提高了传送数据的灵活性。 既然是通讯，那么在通信之前就要先在通信双方约定通信协议，协议就是通信双方约定的数据交换格式。 从消息队列开始一直到 Socket，我们都会看到比较类似的程序架构，因为无论是消息队列还是 Socket，它们都需要约定通信协议，而且都是按照一定的步骤才能实现通讯。 消息队列在约定协议的时候，在我们自己定义的结构体里要强制添加一个 long mtype; 成员。这个成员的作用是用于区分多种消息类型中的不同类型的数据包，当只有一种类型的包时这个成员没什么用，但是也必须得带上。 既然是通讯，那么就要区分主动端（先发包的一方）和被动端（先收包的一方，程序需要先运行起来），它们运行的时机不同，作用不同，甚至调用的函数也不同，所以我们的后面的每个栗子几乎都要编译出 2 个不同的可执行程序来测试。 前面说了，学到这里操作基本上都是按部就班的了，所以 msg、sem 和 shm 都有一系列函数遵循下面的命名规则： 123xxxget() // 创建xxxop() // 相关操作xxxctl() // 其它的控制或销毁 下面我们看看消息队列的创建函数：msgget(2) 123456// msgget - get a System V message queue identifier#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgget(key_t key, int msgflg); msgget(2) 函数的作用是创建一个消息队列，消息队列是双工的，两边都可以读写。 参数列表： key 相当于通信双方的街头暗号，拥有相同 key 的双方才可以通信。 key 值必须是唯一的，系统中有个 ftok(3) 函数可以用于获取 key，通过文件 inode 和 salt 进行 hash 运算来生成唯一的 key，只要两个进程使用相同的文件和 salt 就可以生成一样的 key 值了。 msgflg：特殊要求。无论有多少特殊要求，只要使用了 IPC_CREAT，就必须按位或一个权限，权限也不是你想指定多大就能多大的，还是老规矩，要用它 &amp;= ~umask，这个我们前面提到过。 同一个消息队列只需要创建一次，所以谁先运行起来谁有责任创建消息队列，后运行起来的就不需要创建了。 同理，对于后启动的进程来说，消息队列不是它创建的，那么它也没有必要销毁了。 1234#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok(const char *pathname, int proj_id); 1.2.1.1 msgrcv(2) 函数和 msgsnd(2) 函数1234567891011121314151617// msgrcv, msgsnd - message operations#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);/* msgp 成员的定义要类似 msgbuf 这个结构体，第一个成员必须是 long 类型的 mtype，并且必须是 &gt; 0 的值 */struct msgbuf &#123; long mtype; /* 消息类型，必须 &gt; 0 */ char mtext[1]; /* 消息数据字段 */&#125;; msgrcv(2) 函数从 msgid 这个消息队列中接收数据，并将接收到的数据放到 msgp 结构体中，这段空间有 msgz 个字节大小，msgz 的值要减掉强制的成员 mtype 的大小（sizeof(long)）。 msgtyp 是 msgp 结构体中的 mtype 成员，表示要接收哪种类型的消息。虽然 msg 是消息队列，但是它并不完全遵循队列的形式，可以让接收者挑消息接收。如果不挑消息可以填写 0，这样就按照队列中的消息顺序返回。 msfglg 是特殊要求位图，没有写0。 msgsnd(2) 函数向 msgid 这个消息队列发送 msgp 结构体数据，msgp 的大小是 msgsz，msgflg 是特殊要求，没有特殊要求可以写 0。 1.2.1.2 msgctl(2) 函数123456// msgctl - message control operations#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgctl(int msqid, int cmd, struct msqid_ds *buf); msgctl(2) 函数是不是有点眼熟呢？没错，跟 iocrtl(2)、fcntl(2) 这种函数的用法很类似。通过 cmd 指定具体的命令，然后通过 buf 为 cmd 命令设定参数，当然有些命令是需要参数的，有些命令则不需要参数。 最长用的 cmd 就是 IPC_RMID，表示删除（结束）某个 IPC 通信，并且这个命令不需要 buf 参数，直接传入 NULL 即可。 buf 结构体里面的成员很多，由于 cmd 一般只有 IPC_RMID 比较常用，所以 LZ 就不把 buf 结构体拿出来挨个成员解释了，需要用到的童鞋自行查阅一下 man 手册吧，遇到了什么问题可以在评论中讨论。 看下面的小栗子，我们把上面讲到的几个消息队列的函数使用一遍，在两个进程之间实现简单的通讯。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/* proto.h 定义双方都需要使用的数据或对象 */#ifndef PROTO_H__#define PROTO_H__#define NAMESIZE 32/* 通讯双方生成 key 值共同使用的文件 */#define KEYPATH \"/tmp/out\"/* 通讯双方生成 key 值共同使用的 salt 值 */#define KEYPROJ 'a'/* 消息类型，只要是大于 0 的合法整数即可 */#define MSGTYPE 10/* 通讯双方约定的协议 */struct msg_st&#123; long mtype; char name[NAMESIZE]; int math; int chinese;&#125;;#endif/******************** rcver.c 接收方 ********************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include \"proto.h\"int main()&#123; key_t key; int msgid; struct msg_st rbuf; // 通过 /tmp/out 文件和字符 'a' 生成唯一的 key，注意文件必须是真实存在的 key = ftok(KEYPATH,KEYPROJ); if(key &lt; 0) &#123; perror(\"ftok()\"); exit(1); &#125; // 接收端应该先启动，所以消息队列由接收端创建 msgid = msgget(key,IPC_CREAT|0600); if(msgid &lt; 0) &#123; perror(\"msgget()\"); exit(1); &#125; // 不停的接收消息 while(1) &#123; // 没有消息的时候会阻塞等待 if(msgrcv(msgid,&amp;rbuf,sizeof(rbuf)-sizeof(long),0,0) &lt; 0) &#123; perror(\"msgrcv\"); exit(1); &#125; /* 用结构体中强制添加的成员判断消息类型， * 当然在这个例子中只有一种消息类型，所以不判断也可以。 * 如果包含多种消息类型这里可以写一组 switch...case 结构 */ if(rbuf.mtype == MSGTYPE) &#123; printf(\"Name = %s\\n\",rbuf.name); printf(\"Math = %d\\n\",rbuf.math); printf(\"Chinese = %d\\n\",rbuf.chinese); &#125; &#125; /* 谁创建谁销毁。 * 当然这个程序是无法正常结束的，只能通过信号杀死。 * 使用信号杀死之后大家可以用 ipcs(1) 命令查看一下，消息队列应该是没有被销毁的， * 大家可以使用上面我们提到的 ipcrm(1) 命令把它删掉。 */ msgctl(msgid,IPC_RMID,NULL); exit(0);&#125;/******************** snder.c 发送方 ********************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include \"proto.h\"int main()&#123; key_t key; int msgid; struct msg_st sbuf; // 设置随机数种子 srand(time(NULL)); // 用与接收方相同的文件和 salt 生成一样的key，这样才可以通讯 key = ftok(KEYPATH,KEYPROJ); if(key &lt; 0) &#123; perror(\"ftok()\"); exit(1); &#125; // 取得消息队列 msgid = msgget(key,0); if(msgid &lt; 0) &#123; perror(\"msgget()\"); exit(1); &#125; // 为要发送的结构体赋值 sbuf.mtype = MSGTYPE; strcpy(sbuf.name,\"Alan\"); sbuf.math = rand()%100; sbuf.chinese = rand()%100; // 发送结构体 if(msgsnd(msgid,&amp;sbuf,sizeof(sbuf)-sizeof(long),0) &lt; 0) &#123; perror(\"msgsnd()\"); exit(1); &#125; puts(\"ok!\"); // 消息队列不是发送方创建的，所以发送方不用负责销毁 exit(0);&#125; 1234567891011# 先启动接收者，然后启动发送者./rcver./snder# 发送着控制台ok!# 接收者控制台Name = AlanMath = 97Chinese = 9 12345678./rcver./rcver./rcver# 发送者控制台ok!ok!ok! 1234567891011121314./snder# 接收者控制台Name = AlanMath = 97Chinese = 9Name = AlanMath = 97Chinese = 9Name = AlanMath = 97Chinese = 9 结论： 说明消息队列有缓存消息的能力； 123ulimit -abytes in POSIX msg queues 819200# 这个消息队列的大小 是 819200个字节数， 当消息队列大于这个数字的时候，会造成消息队列数据丢失 1234567$&gt; ipcs键 msqid 拥有者 权限 已用字节 消息0x61004069 0 hy 600 0 0# 发现依然消息队列存在，那是因为接收者那里有一个死循环。导致进程无法正常终止$&gt; ipcrm -q 0 # 杀掉 msqid为0 的消息队列 这段程序的源文件有三个：proto.h、rcver.c 和 snder.c。 proto.h 中的 KEYPROJ （salt 值）用一个字符来替代整形数，为什么不直接写数字呢？因为宏定义是没有数据类型的，没有单位的数字是不靠谱的，而字符的 ASCII 码一定是一个 0-255 之间的整形数。 接收方要先运行，所以又接收方创建消息队列。发送方要使用相同的文件和 salt 生成于接收方相同的 key 值，这样它们才能使用同一个消息队列。 发送方生成一个结构体，用随机数为结构体中的两个成员赋值，分别模拟学生的数学和语文成绩，接收方在接收到数据之后把每个成员解析出来，并打印到控制台上。 可以看出来，发送方和接收方必须使用相同的结构体才能保证数据能够正常被解析，所以这个结构体就是我们上面所说的“协议”。既然是协议，我们就要把它定义在一个共用的结构体（proto.h）中，让发送方和接收方都引用这个头文件，这样就能保证它们可以使用相同的结构体通讯了。 1.2.1.3 FTP实例(基于消息队列的版本) 双方进行数据传输，一方作为发送端 一方作为接收端 讲解： 首先c 请求 s， 把path传给 s。 s返回一个一个的数据包给c， 最后一个数据包为 EOT表示发完。c端将s返回的包内容 输出到终端上（有点类似cat 的内容），前面说了c 请求一个 path （文件的地址）。这里有点不灵活。需要在 频繁代码中 去更改path 文件地址。想办法弄到在命令行上指定path 1.3 Semaphore Arrays 信号量数组semget();semop();semctl(); 123456// semget - get a semaphore set identifier#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int semflg); semget(2) 函数用于创建信号量。 成功返回 sem ID，失败返回 -1 并设置 errno。 参数列表： key：具有亲缘关系的进程之间可以使用一个匿名的 key 值，key 使用宏 IPC_PRIVATE 即可。 nsems：表示你到底有多少个 sem。信号量实际上是一个计数器，所以如果设置为 1 可以用来模拟互斥量。 semflg：IPC_CREAT 表示创建 sem，同时需要按位或一个权限，如果是匿名 IPC 则无需指定这个宏，直接给权限就行了。 semctl(2) 1234567// semctl - semaphore control operations#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semctl(int semid, int semnum, int cmd, ...); semctl(2) 函数用来控制或销毁信号量。 参数列表： semnum：信号量素组下标； cmd：可选的宏参见《APUE》第三版 P457。常用的有 IPC_RMID，表示从系统中删除该信号量集合。SETVAL 可以为第几个成员设置值。关于这两个宏的用法，我们在下面的栗子中会见到。 …：根据不同的命令设置不同的参数，所以后面的参数是变长的。 semop(2) 1234567891011121314// semop - semaphore operations#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semop(int semid, struct sembuf *sops, unsigned nsops);struct sembuf &#123;unsigned short sem_num; /* 对第几个资源（数组下标）操作 */short sem_op; /* 取几个资源写负数几(不要写减等于)，归还几个资源就写正数几 */short sem_flg; /* 特殊要求 */&#125;; 这个函数就是让我们操作信号量的。由于多个信号量可以组成数组，所以我们又看到了熟悉的函数定义方式，一个参数作为数组的起始位置，另一个参数指定数组的长度。 参数列表： sops：结构体数组起始位置； nsops：结构体数组长度； 返回值：成功返回0，失败返回-1并设置 errno。 前面说过了，信号量实际上就是计数器，所以每次在使用资源之前，我们需要扣减信号量，当信号量被减到 0 时会阻塞等待。每次使用完成资源之后，需要归还信号量，也就是增加信号量的数值。 下面我们使用上面操作信号量的函数实现一个通过信号量实现互斥量的栗子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;errno.h&gt;#define PROCNUM 20#define FNAME \"/tmp/out\"#define BUFSIZE 1024// 多个函数都要使用这个信号量 ID，所以定义为全局变量static int semid;static void P(void)&#123; struct sembuf op; op.sem_num = 0; // 只有一个资源，所以数组下标是 0 op.sem_op = -1; // 取一个资源就减1 op.sem_flg = 0; // 没有特殊要求 while(semop(semid,&amp;op,1) &lt; 0) &#123; // 出现假错就重试 if(errno != EINTR &amp;&amp; errno != EAGAIN) &#123; perror(\"semop()\"); exit(1); &#125; &#125;&#125;static void V(void)&#123; struct sembuf op; op.sem_num = 0; op.sem_op = 1; // 归还一个资源 op.sem_flg = 0; while(semop(semid,&amp;op,1) &lt; 0) &#123; if(errno != EINTR &amp;&amp; errno != EAGAIN) &#123; perror(\"semop()\"); exit(1); &#125; &#125;&#125;static void func_add()&#123; FILE *fp; char buf[BUFSIZE]; fp = fopen(FNAME,\"r+\"); if(fp == NULL) &#123; perror(\"fopen()\"); exit(1); &#125; // 先取得信号量在操作文件，取不到就阻塞等待，避免发生竞争 P(); fgets(buf,BUFSIZE,fp); rewind(fp); sleep(1); // 调试用，为了放大竞争，更容易看出来互斥量发挥了作用 fprintf(fp,\"%d\\n\",atoi(buf)+1); fflush(fp); // 操作结束之后归还信号量，让其它进程可以取得信号量 V(); fclose(fp); return ;&#125;int main()&#123; int i; pid_t pid; // 在具有亲缘关系的进程之间使用，所以设置为 IPC_PRIVATE 即可。 // 另外想要实现互斥量的效果，所以信号量数量设置为 1 个即可。 semid = semget(IPC_PRIVATE,1,0600); if(semid &lt; 0) &#123; perror(\"semget()\"); exit(1); &#125; // 将 union semun.val 的值设置为 1 if(semctl(semid,0,SETVAL,1) &lt; 0) &#123; perror(\"semctl()\"); exit(1); &#125; // 创建 20 个子进程 for(i = 0 ; i &lt; PROCNUM ; i++) &#123; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // child &#123; func_add(); exit(0); &#125; &#125; for(i = 0 ; i &lt; PROCNUM ; i++) wait(NULL);// 销毁信号量 semctl(semid,0,IPC_RMID); exit(0);&#125; 123$&gt; echo 1 &gt; './p'./add 大家还记得以前我们写的用 20 个进程同时向一个文件中写入累加的数值吗？还是这个程序，这次我们使用信号量来实现它们之间的互斥效果。 程序的结构跟以前的实现方式差不多，只不过锁的形式不一样了而已。 1.4 Shared Memory Segments 共享内存还记得之前在《高级 IO》部分的博文中我们利用 mmap(2) 函数实现过一个共享内存吗？ 这次我们使用的是 XSI 的共享内存，比使用 mmap(2) 实现的共享内存稍微麻烦一点。不过不用担心，也一样很简单，不就是遵循上面说的那个命名规则的三个函数嘛，有了消息队列和信号量的铺垫，相信不用 LZ 讲大家也差不多能才出来 shm 是个什么套路了。 没错，第一个函数就是 shmget(2)，我们来看一下它的函数原型： 12345// shmget - allocates a shared memory segment#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg); 参数列表： key：共享内存的唯一标识，具有亲缘关系的进程之间使用共享内存可以使用 IPC_PRIVATE 宏代替。 size：是共享内存的大小。 shmflg：IPC_CREAT 表示创建 shm，同时需要按位或一个权限，如果是匿名 IPC 则无需指定这个宏，直接给权限就行了。 返回值：成功返回 shm ID；失败返回 -1，man 手册里没说是否设置 errno，这个需要大家根据自己的环境测试一下，或者查阅自己环境下的 man 手册。 1.4.1 shmat(2) 函数和 shmdt(2) 函数1234567// shmat - shared memory operations#include &lt;sys/types.h&gt;#include &lt;sys/shm.h&gt;void *shmat(int shmid, const void *shmaddr, int shmflg);int shmdt(const void *shmaddr); 虽然函数名叫做 shmat，根据上面说过的约定，用 man 手册查 shmop 也是可以查到这个命令的。 shmat(2) 函数使进程与共享内存关联起来。 shmat(2)函数中的 shmaddr 参数是共享内存的起始地址，传入 NULL 由内核帮我们寻找合适的地址，一般情况我们都是传入 NULL 值。 shmdt(2) 函数用于使进程分离共享内存，共享内存使用完毕之后需要用这个函数分离。分离不带表释放了这块空间，使用共享内存的双方依然要遵守“谁申请，谁释放”的原则，所以没有申请的一方是不需要释放的，但是双方都需要分离。 1.4.2 shmctl(2)12345// shmctl - shared memory control#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmctl(int shmid, int cmd, struct shmid_ds *buf); 与消息队列和信号量一样，这个函数用于控制或删除共享内存。 参数 LZ 就不做介绍了，只说一下如何删除共享内存吧。cmd 参数设置为 IPC_RMID 并且 buf 参数设置为 NULL 就可以删除共享内存了。 下面我们来看一个共享内存实现进程间通讯的栗子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/wait.h&gt;// 申请的共享内存大小，单位是字节#define MEMSIZE 1024int main()&#123; char *str; pid_t pid; int shmid; // 有亲缘关系的进程 key 参数可以使用 IPC_PRIVATE 宏，并且创建共享内存 shmflg 参数不需要使用 IPC_CREAT 宏 shmid = shmget(IPC_PRIVATE,MEMSIZE,0600); if(shmid &lt; 0) &#123; perror(\"shmget()\"); exit(1); &#125; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // 子进程 &#123; // 关联共享内存 str = shmat(shmid,NULL,0); if(str == (void *)-1) &#123; perror(\"shmat()\"); exit(1); &#125; // 向共享内存写入数据 strcpy(str,\"Hello!\"); // 分离共享内存 shmdt(str); // 无需释放共享内存 exit(0); &#125; else // 父进程 &#123; // 等待子进程结束再运行，因为需要读取子进程写入共享内存的数据 wait(NULL); // 关联共享内存 str = shmat(shmid,NULL,0); if(str == (void *)-1) &#123; perror(\"shmat()\"); exit(1); &#125; // 直接把共享内存中的数据打印出来 puts(str); // 分离共享内存 shmdt(str); // 释放共享内存 shmctl(shmid,IPC_RMID,NULL); exit(0); &#125; exit(0);&#125; 最后父进程要在父子进程用完共享内存之后调用 shmctl(2) 使用 IPC_RMID 宏来回收资源，参数为 NULL","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"进程环境","slug":"apue-3","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:17.586Z","comments":true,"path":"2020/12/16/apue-3/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-3/","excerpt":"","text":"进程环境本章前半部分讨论进程的开始和结束，后半部分讨论参数列表、环境变量、C 程序虚拟地址空间布局等内容。 main函数 进程的终止 命令行参数的分析 环境变量 C程序的存储空间布局 库 函数跳转 资源的获取及控制 1. main() 函数12int main (int argc, char *argv[]);int main (int argc, char **argv); 其实最早的 main 函数是三个参数的，除了 argc 和 argv 以外，还有一个环境变量。后来发现环境变量越来越好用，所以就独立出来成了单独的功能。 2. 进程终止 Linux 系统一共有 8 种进程终止方式.1-5为正常终止方式, 6-8为异常终止方式（必知必会） 从 main() 函数返回； 调用 exit(3) 函数； 调用 _exit(2) 或 _Exit(2) 函数； 最后一个线程从其启动例程返回； 从最后一个线程调用 pthread_exit(3) 函数； 调用 abort(3) 函数； 接收到一个信号并终止；（ctrl+c） 最后一个线程对取消请求作出响应； 第 1 条：在 main() 函数中执行 return 语句，可以将一个 int 值作为程序的返回值返回给调用者，一般是 shell。返回 0 表示程序正常结束，返回 非零值 表示程序异常结束。 1234int main()&#123; return 0;&#125; 1echo $? # 打印上一条语句的执行状态 第 2 条：在 main() 函数中执行 return 语句相当于调用 exit(3) 函数，exit(3) 是专门用于结束进程的，它依赖于 _exit(2) 或 _Exit(2) 系统调用。程序中任何地方调用 exit(3) 都会退出，但 return 语句只有在 main() 函数中才能结束进程，在其它函数中执行 return 语句只能退出当前函数。exit 能返回的值在-128 ～ 127之间； 1234int main()&#123; exit(0);&#125; 第 3 条：_exit(2) 和 _Exit(2) 函数都是系统调用，在程序中的任何地方调用它们程序都会立即结束。 上面三条有两点需要大家注意，我先把问题提出来大家思考一下，下面会有讲解： (1) return 、exit(3)、_exit(2) 和 _Exit(2) 的返回值取值范围是多少呢？ (2) exit(3)、_exit(2) 和 _Exit(2) 之间有什么区别呢？ 第 4、5 条 等到第 11 章我们讨论线程的时候再说，总之进程就是线程的容器，最后一个线程的退出会导致整个进程的消亡。 第 6 条：abort(3) 函数一般用在程序中出现了不可预知的错误时，为了避免异常影响范围扩大，直接调用 abort(3) 函数自杀。实际上 abort(3) 函数也是通过信号实现的。 第 7 条：信号有很多种，有些默认动作是被忽略的，有些默认动作则是杀死进程。比如程序接收到 SIGINT（Ctrl+C） 信号就会结束，Ctrl + C 是 SIGINT 的一个快捷方式，而不是 Ctrl + C 触发了 SIGINT 信号。第 10 章我们会详细的讨论信号。 第 8 条 也要等到第 11 章我们讨论线程的时候再详细说。 3.exit(2) 123// exit - cause normal process termination#include &lt;stdlib.h&gt;void exit(int status); status 参数的取值范围并非是所有 int 的取值范围，计算方法是 status &amp; 0377，也就相当于一个有符号的 char 型数据，取值范围是 -128～127，最多256种可能。 所有通过 atexit(3) 和 on_exit(3) 注册的函数会被以注册的逆序来调用。 它在执行完钩子函数之后再执行IO清理，然后才使进程结束。 atexit(3) 钩子函数 所有的函数由 atexit(3) 和 on_exit(3) 声明的，将会以他们注册的逆序来调用 123// atexit - register a function to be called at normal process termination#include &lt;stdlib.h&gt;int atexit(void (*function)(void)); 用该函数注册过的函数会在程序正常终止之前被调用，被注册的函数称为“钩子函数”。 注册的钩子函数形式必须是这样：void (*function)(void)，因为它不会接收任何参数，也没有任何机会返回什么值，所以是一个无参数无返回值的函数。 当多次调用 atexit(3) 函数注册了多个钩子函数的时候，程序结束时钩子函数是以注册的逆序被调用的。 比如按照 a()、b()、c()、d() 的形式注册了 4 个钩子函数，那么程序结束时，它们的调用顺序是：d()、c()、b()、a()。 下面举个栗子来说明这个逆序调用是怎么回事。 123456789101112131415161718192021222324252627282930 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void f1 (void) &#123; puts(\"f1\"); &#125; void f2 (void)&#123; puts(\"f2\");&#125;void f3 (void)&#123; puts(\"f3\");&#125;int main (void)&#123; puts(\"Begin!\"); atexit(f1); // 只是声明一个函数，相当于把一个函数挂在钩子上，并不调用 atexit(f2); atexit(f3); puts(\"End!\"); exit(0);&#125; 运行结果 12345Begin!End!f3f2f1 这回小伙伴们明白逆序调用是怎么回事了吧。 为什么 “End!” 先输出了，而 “f3” 后输出了呢？因为使用 atexit(3) 函数注册钩子函数的时候并不会调用钩子函数，仅仅是注册而已，只有在程序正常结束的时候钩子函数才会被调用。 还记得我们上面提到的什么情况是正常结束吧？注意是只有正常结束才会调用钩子哟，异常结束是不会调用钩子函数的。 疑问 为什么main函数 return 非int型，还是调用了注册的钩子函数呢？ 下面写几段伪代码来举栗子说明一下什么场景更适合使用钩子函数。 1234567891011121314151617181920212223242526272829303132333435363738394041 /* * 这段代码要表现的是，当我们的程序需要申请很多资源的时候， * 比如打开文件、申请堆内存等。 * 如果有一个资源申请失败时需要释放之前所有成功申请的资源并退出程序， * 那么就需要在申请每个资源之后都进行错误判断，并手工填写所有的资源释放代码。 * 假如要申请的资源数量很庞大，而恰巧加班又加得老眼昏花 * 结果手一抖，后果。。。 @...@ */ fd0 = open(\"\", \"\");if (fd0 &lt; 0) &#123; perror(\"open(0)\"); exit(1);&#125; fd1 = open(\"\", \"\");if (fd1 &lt; 0) &#123; perror(\"open(1)\"); close(fd0); exit(1);&#125;fd2 = open(\"\", \"\");if (fd2 &lt; 0) &#123; perror(\"open(1)\"); close(fd2); close(fd1); exit(1);&#125;......fd10000 = open(\"\", \"\");if (fd10000 &lt; 0) &#123; perror(\"open(10000)\"); close(fd9999); ...... close(fd3); close(fd2); close(fd1); close(fd0); exit(1);&#125; 上面这种写法是不是太恐怖了，这还只是打开文件而已，如果中间有夹杂着 malloc(3) 和 free(3) 呢？想都不敢想了。。 其实想要解决也很简单，钩子函数帮你轻松搞定！下面是改版之后的伪代码： 1234567891011121314151617181920212223242526272829 fd0 = open(\"\", \"\"); if (fd0 &lt; 0) &#123; perror(\"open(0)\"); exit(1); &#125; atexit(closefd0); // 一切都交给钩子函数来处理吧，它会以注册顺序的逆序逐一被调用。 fd1 = open(\"\", \"\"); if (fd1 &lt; 0) &#123; perror(\"open(1)\"); exit(1);&#125;atexit(closefd1);fd2 = open(\"\", \"\");if (fd2 &lt; 0) &#123; perror(\"open(1)\"); exit(1);&#125;atexit(closefd2);......fd10000 = open(\"\", \"\");if (fd10000 &lt; 0) &#123; perror(\"open(10000)\"); exit(1);&#125;atexit(closefd2); _exit(2)、_Exit(2) _exit() 和 _Exit(2) 为系统调用, exit 依赖于 _exit(2)或者_Exit(2) 123456789// _exit, _Exit - terminate the calling process #include &lt;unistd.h&gt; void _exit(int status); #include &lt;stdlib.h&gt; void _Exit(int status); _exit(2)、_Exit(2) 与 exit(3) 的区别在程序的任何地方调用 _exit(2) 或 _Exit(2) 函数程序都会立即结束，任何钩子函数都不会被调用，也不会做 IO 清理。 1234567891011121314151617181920212223242526void f1(void) &#123; puts(\"f1\"); &#125; void f2(void) &#123; puts(\"f2\"); &#125; void f3(void) &#123; puts(\"f3\"); &#125; void f4(void) &#123; puts(\"f4\"); &#125; int main() &#123; atexit(f4); atexit(f3); atexit(f2); atexit(f1); _exit(0); &#125;// 没有打印出 任何东西 什么时候用 exit(3)，什么时候用 _exit(2)、_Exit(2)下面我们写一段伪代码来查看 _exit(2) 函数的常用场景。 1234567891011121314151617181920212223242526272829303132333435 int function (.........) &#123; if () return 0; if () return 1; else return 2; &#125;int main (void)&#123; int ret = 0; ret = function(); ...... // 假定没有任何地方修改过 ret switch(ret) &#123; case 0: ... break; case 1: ... break; case 2: ... break; default: // 出现这种情况的时候一定是上面的代码出现了逻辑问题，或程序中出现了越界等问题，所以不能调用钩子函数执行清理了，而且也不能做IO清理了。为了防止故障扩散，一定要让程序立即结束。（错的不行了，不敢动了。调_exit()杀掉进程） //exit(1); _exit(1); // abort(); 发信号结束进程 &#125; exit(0);&#125; 3. 命令行参数我们在使用 shell 命令的时候经常为传递各种参数来完成不同的工作。这个参数实际上就是传递到程序 main() 函数的 argc 和 argv 两个参数中去了 我们再来看一下 main() 函数的原型： 1int main (int argc, char **argv); 参数列表： argc：argv 中字符串的数量，也就是传递给程序的命令行参数的数量。 argv：在 shell 中传递给进程的命令行参数列表，argv[0] 永远是命令本身，第一个参数从 argv[1] 开始。 这是一个二维数组，其实就是一个字符串数组而已。很多童鞋不理解它为什么是一个二维数组，说明你的 C 语言基础没有学好。 字符串本身就是一个 char 数组，而保存多个字符串的数组自然就是一个 char 型二维素组了。 常见的命令行参数分类： 1234567891011&gt;$ cmd [opt] [!opt]&gt;$ ls # 无参数&gt;$ ls -l -a -i # 仅选项&gt;$ ls /etc/ /tmp # 非选项传参&gt;$ ls -l /tmp -a /etc&gt;$ ./myplayer -H 500 -W 500 a.avi # 选项带参数&gt;$ ./myplayer -H -W a.avi # 假设 H 和 W 选项必须带参数，这样传惨会报错，因为找不到任何参数修饰 -H 和 -W&gt;$ cmd [opt opt-arg] [!opt]&gt;$ ./myplayer -H 100 px -W 500 cm a.avi # 选项带参数，参数又带参数，这种没有函数能搞定，只能自己写函数解析了。 选项分为两种形式，一种是以 - 开头的短格式选项，只能是一个字母或一个数字； 另一种是长格式选项，以 – 开头，可以由多个字母和数字组成。 短格式最多支持 26个小写字母+26个大写字母+10个数字，共 62 个选项。这些选项足够一个程序的使用了，为什么还需要长格式的选项呢？ 使用长格式选项是为了便于使用者记忆，辅助短格式参数的使用。如果有一些单词的缩写碰撞了或者不容易记忆，则可以选用长格式的参数。 这些命令行参数可以随意松散的传给命令，那么命令是如何解析这些参数的呢？别着急，其实已经有优秀的库函数供我们使用了。 getopt(3)1234// getopt, optind - Parse command-line options #include &lt;unistd.h&gt; int getopt(int argc, char * const argv[], const char *optstring); extern int optind; 该函数用于解析短格式参数。 参数列表： argc、argv：就是 main() 函数的 argc 和 argv 参数； optstring：想要从 argv 中解析的所有选项列表，不用加 - 前导符；例如程序支持 -y -m -d -h -M -s 参数，则 optstring 填写 “y:mdh:Ms” 即可。 加冒号表示某个选项后面要带参数，比如 y 和 h 后面都需要带参数，需要用到全局变量： 12extern char *optarg;extern int optind; optarg：表示选项后面的参数，也就是 -y 和 -h 后面的参数。例如：-y 4 -h 24。optind：用于记录 getopt(3) 函数目前读到了 argv 的哪个下标。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #define FMTSTRSIZE 1024 #define TIMESTRSIZE 1024 /** * -y: year * -m: month * -d: day * -H: hour * -M: minute * -S: second * */ int main(int argc, char **argv) &#123; time_t stamp; struct tm*tm; char timestr[TIMESTRSIZE]; int c; char fmtstr[FMTSTRSIZE]; stamp = time(NULL); fmtstr[0] = '\\0'; tm = localtime(&amp;stamp); // 命令行分析 while(1) &#123; c = getopt(argc,argv,\"HMSymd\"); if(c&lt;0) break; switch(c) &#123; case 'H': if(strcmp(optarg, \"12\")== 0) strncat(fmtstr, \"%I(%P)\", FMTSTRSIZE); else if(strcmp(optarg, \"24\")==0) strncat(fmtstr, \"%H\", FMTSTRSIZE); else fprintf(stderr, \"incvalid arguments\"); break; case 'M': strncat(fmtstr, \"%M \", FMTSTRSIZE); break; case 'S': strncat(fmtstr, \"%S \", FMTSTRSIZE); break; case 'y': if(strcmp(optarg,\"2\")==0) strncat(fmtstr,\"%y\",FMTSTRSIZE); else if(strcmp(optarg,\"4\")==0) strncat(fmtstr,\"%Y\",FMTSTRSIZE); else fprintf(stderr,\"invalid arguments\"); break; case 'm': strncat(fmtstr, \"%m \", FMTSTRSIZE); break; case 'd': strncat(fmtstr, \"%d \", FMTSTRSIZE); break; default: break; &#125; &#125; //根据命令行分析的结果 决定要输出什么格式的文本 strftime(timestr, TIMESTRSIZE, fmtstr, tm); // strftime(timestr, TIMESTRSIZE, \"Now:%Y-%m-%d\", tm); puts(timestr); exit(0); &#125; 1234./myDate -H 12 # 02(pm)./myDate -H 24 # 14./myDate -y 2 #20./myDate -y 4 #2020 下面伪代码演示了如何解析选项以及带参的选项： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 while (1) &#123; op = getopt(argc, argv, \"y:mdh:Ms\"); // 支持的选项是 -y &lt;2|4&gt; -m -d -h &lt;12|24&gt; -M -s if (op &lt; 0) &#123; break; &#125; switch (op) &#123; case 1: // 非选项传参，op 的值为 1 // &gt;$ ls /etc/ -a // 当进入这个 case 的时候，optind 已经 +1 了，所以想要通过 optind 在 argv 中得到对应的参数应，应该进行 -1，但是不要去修改 optind 本身的值，否则下次读取就不准确了。 fp = fopen(argv[optind-1], \"w\"); ...... break; case 'y': if (0 == strcmp(optarg, \"2\")) &#123; // y 后面的参数是 2 ...... &#125; else if (0 == strcmp(optarg, \"4\")) &#123; // y 后面的参数是 4 ...... &#125; else &#123; // y 后面的参数即不是 2 也不是 4 ...... &#125; break; case 'm': break; ...... default: // 通常传入了不支持的参数，不响应就可以了，没必要结束程序，因为没有达到那种严重的程度。 break; &#125;&#125; 参数可以连写，但带参数的选项必须和参数是挨着的，不能分开，举几个栗子： 1234567891011 # 1. -x -z -v -f 可以连写 # 2. -x -z -v 是不带参数的选项，-f 是带参数的选项，所以 -f 必须和后面的参数挨着 tar -xzvf xxx.tar.gz /home # 下面这几个是错误的用法 tar -fxzv xxx.tar.gz /home tar -xzvfxxxtar.gz /home tar fxxxtar.gzxzvf /home # 下面这种用法是可以的tar -f xxx.tar.gz -xzv /home getopt_long(3) 用于解析长格式参数，函数原型就不列出来了。关于命令行参数要再补充一点，经常拷运维人员的一道面试题大概是这样的：如何使用 touch(1) 命令在当前目录创建一个名字叫做 -a 的文件？ 通常有两个办法可以实现： 1231) touch -- -a 当命令行遇到两个 - 和空格时(-- )，会认为后面不会有任何选项，也就不会将 - 再作为参数的前导符。2) touch ./-a ./ 表示当前目录 4. 环境变量 KEY = VLAUE 环境表export(1) 命令可以查看当前所有的环境变量或设置某个环境变量。 访问环境变量可以使用 getenv(3) 和 putenv(3) 函数，下面我们会提到它们。 环境表就是将环境变量保存在了一个字符指针数组中，很多 Unix 系统都支持三个参数的 main() 函数，第三个参数就是环境表。 环境变量是为了保存常用的数据。以当前 terminal 为例，把 terminal 当作是一个大的程序来跑，就可以将环境变量看作是这个程序的全局变量。 环境变量相当于在某个位置声明 extern char **environ; 上面说了，环境表就是一个字符指针数组，所以使用环境变量就相当于environ[i] - &gt;name=value; 如何查看环境变量1export 输出环境变量12345678extern char **environ;int main()&#123; int i; for(i=0;environ[i]!= NULL; i++) puts(environ[i]); exit(0);&#125; 上面提到了环境表，在这一节我们看看操作环境变量的两个函数如何使用。 环境变量的作用到底是什么？有很多小伙伴不明白环境变量是个什么东西，一听感觉好深奥啊，惧怕得不行。 就像我们使用 ls(1) 命令的时候是在任何位置都可以使用的，而没有用 /bin/ls 的方式来使用 ls(1)，是因为有 PATH 环境变量的存在，它会保存所有常用的可执行文件的路径。 其实环境变量无非就是一个字符串而已，它由 key(变量名) 和 value 两部分组成，我们可以通过 key 来读写 value。 我们通常所说的环境变量就是环境表，也就是由多个环境变量组成的一个字符指针数组，它的存在也就是为了方便我们在程序中获得一些经常使用的变量数据，仅此而已。 getenv(3) 获取某个环境变量123// getenv - get an environment variable#include &lt;stdlib.h&gt;char *getenv(const char *name); 12345int main()&#123; puts(getenv(\"PATH\")); exit(0);&#125; 这个函数的作用是获取一个环境变量，用法很简单，就是通过 name 获得 value， value 是返回值。 在这里补充一点，在程序中获得当前工作路径有两种办法，一种是通过环境变量，一种是通过专门的函数： puts(getevn(“PWD”)); // 通过环境变量获取当前路径，也可以使用 getcwd(3) 函数获得当前路径。 setenv(3)123// setenv - change or add an environment variable#include &lt;stdlib.h&gt;int setenv(const char *name, const char *value, int overwrite); 这个函数和 getenv(3) 函数的作用正好相反，是将 value 赋给 name 环境变量。 如果 name 不存在，则添加新的环境变量。 如果 name 存在：如果 overwrite 为真，就用 value 覆盖 name 原来的值；如果 overwrite 为假则保留 name 原来的值。 putenv(3)123// putenv - change or add an environment variable #include &lt;stdlib.h&gt; int putenv(char *string); 用 “name=value” 的形式添加或修改环境变量的值。如果 name 已存在则会用新值覆盖原来的值。 小伙伴们要注意：参数不是 const 的，所以某些情况下可能会修改参数的值，所以还是使用 setenv(3) 更保险。 大家思考一个问题：如 图1 所示，环境表是存放在堆与内核空间之间的薄层中的，如果新字符串比原字符串长怎么办，会不会出现越界的情况呢？ 其实不用担心这个问题，因为无论新的值与原来的值谁长谁短，都会先将原来的空间释放，在堆上新申请一块空间来存放新的值。 5. C 程序的存储空间布局一个C程序的虚拟空间是4GB，什么是虚拟空间，它跟实实在在4gb的内存空间是不一样的。 通常 malloc(3) 失败有两种情况，一种是内存真的耗尽了；另一种是不断的申请小的内存，即使堆上全部存放指针也有放满了的情况。 在 Linux 环境中内存是延时分配的，也就是说当 malloc(3) 分配内存时并没有真正的分配物理内存给你，只是给了你一个非空指针，当你真正使用内存的时候通过引发一个缺页异常，内核才真正分配内存给你。 好比有人跟你借100块钱，你也承诺了可以借，但是他并不马上要钱，等到当他跟你要的时候你已经花掉了50块钱，这时候你有两个选择：一是把借钱的人杀掉，这样就不用借钱给他了；二是去抢钱，抢够了足够的钱再给他。 如果让你选择，你会采用哪种方式呢？ 内核采用的是第二种方式，当它发现内存不足够它承诺给你的容量时，它会结束某些不常用的后台进程，再将释放出来的内存分配给你。 图1 32位系统 C 程序典型存储空间布局 另外使用 pmap(1) 命令可以查看进程的内存分配情况，查看的必须是正在运行的进程。使用方法很简单，具体请自行查询 man 手册，这里就不再赘述了。 实验1234567// getpread.cint main()&#123; puts(getenv(\"PATH\")); getchar(); //阻塞进程 exit(0);&#125; 1ps axf #查看当前进程关系 找到 getpread 所在的进程 1pmap 64003 #查看 getpread 进程 空间布局 pmap(1) 查看进程空间分布 布局表6. 库动态库静态库手工装载库 （共享库）类似于插件，当一个模块失败时不会影响其它模块。 内核采用插件的这种形式是有好处的，比如系统启动的时候，如果某个服务（如 ftp 服务、DHCP 等服务）启动未成功，系统会继续启动其它服务而不会立即关机。 否则如果因为 ftp 服务启动失败就关机那就坏了，想要修复 ftp 服务需要先开机，而开机需要成功启动 ftp 服务，那么系统就无法启动了。 内核中任何一个模块的加载都要以插件的形式运行，也就是尝试加载，即使加载失败也不能影响其它模块。 dlopen dlclose dlerror dlsym dlopen(3)1234567// dlopen - programming interface to dynamic linking loader// 该函数就是用来手工装载共享库的。// filename：加载的共享库文件路径// flag：打开方式#include &lt;dlfcn.h&gt;void *dlopen(const char *filename, int flag); 7. 函数跳转 函数 setjmp(3) 和 longjmp(3) goto 语句想必大家都很熟悉了吧，但是它们有一个缺点，就是不能跨函数跳转。C 标准给我们提供了两个函数增强了程序跳转的能力，它们可以使程序跨函数跳转。 图2 函数栈帧 很多人都忌讳跳转这种东西，认为它会破坏程序的结构。LZ 刚也反对在程序中随意使用跳转，跳转是把利刃，好钢要用到刀刃上，所以一定要把跳转用在合适的地方，这样能让你的程序写得非常漂亮。 那么长跳转的好处是什么呢？ 见图2，如果 a() b() c() d() 是同一个函数，则是递归调用。 例如当利用递归在一个树状结构中查找一个数据时，查找到最深的层次发现没有找到想要的数据，这时候没有必要再一层一层的返回了，可以直接跳转回递归点。goto是做不到的，需要用 setjmp(3)或longjmp(3)函数安全的返回。 下面我们来看看这两个函数怎么使用。 1234567891011// setjmp - save stack context for nonlocal goto #include &lt;setjmp.h&gt; int setjmp(jmp_buf env); // longjmp, siglongjmp - nonlocal jump to a saved stack context #include &lt;setjmp.h&gt;void longjmp(jmp_buf env, int val); 首先要通过 setjmp(3) 设置一个跳转点，然后可以通过 longjmp(3) 跳转到 setjmp(3) 所在的位置。 setjmp(3) 设置跳转点时返回值为0，被跳转过来时返回值为非零，也就是 longjmp(3) 的 val 参数。所以 setjmp(3) 下面一定跟着一组分支语句来根据不同的返回值做不同的操作。 longjmp(3) 无需返回值，因为执行的时候程序已经跳转了，无法获得返回值了。 参数列表： 12env： 是指定条准到哪val：带回去的值，如果值为 0，则 setjmp(3) 收到的返回值是 1，避免跳转出现死循环。 下面来看举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;setjmp.h&gt; static jmp_buf save; void d(void) &#123; printf(\"%s():Begin.\\n\",__FUNCTION__); printf(\"%s():Jump now.\\n\",__FUNCTION__); // if longjmp() invoked with a second argument of 0, i will be returned will instead; 所以，该函数第二个函数 恶意传0 也不会造成死循环 longjmp(save,8); // 跳 printf(\"%s():End.\\n\",__FUNCTION__);&#125;void c(void)&#123; printf(\"%s():Begin.\\n\",__FUNCTION__); printf(\"%s():Call d().\\n\",__FUNCTION__); d(); printf(\"%s():d() returned.\\n\",__FUNCTION__); printf(\"%s():End.\\n\",__FUNCTION__);&#125; void b(void)&#123; printf(\"%s():Begin.\\n\",__FUNCTION__); printf(\"%s():Call c().\\n\",__FUNCTION__); c(); printf(\"%s():c() returned.\\n\",__FUNCTION__); printf(\"%s():End.\\n\",__FUNCTION__);&#125;void a(void)&#123; int ret; printf(\"%s():Begin.\\n\",__FUNCTION__); ret = setjmp(save); if(ret == 0) // 设置跳转点 &#123; printf(\"%s():Call b().\\n\",__FUNCTION__); b(); printf(\"%s():b() returned.\\n\",__FUNCTION__); &#125; else // 跳回到这 &#123; printf(\"%s():Jumped back here with code %d\\n\",__FUNCTION__,ret); &#125; printf(\"%s():End.\\n\",__FUNCTION__);&#125;int main()&#123; printf(\"%s():Begin.\\n\",__FUNCTION__); printf(\"%s():Call a().\\n\",__FUNCTION__); a(); printf(\"%s():a() returned.\\n\",__FUNCTION__); printf(\"%s():End.\\n\",__FUNCTION__); return 0;&#125; 编译运行： 1234567891011121314151617&gt;$ gcc jmp.c -Wall -o jmp&gt;$ ./jmpmain():Begin.main():Call a().a():Begin.a():Call b().b():Begin.b():Call c().c():Begin.c():Call d().d():Begin.d():Jump now.a():Jumped back here with code 8a():End.main():a() returned.main():End.&gt;$ 注意：setjmp(3) 和 longjmp(3) 函数不能从信号处理函数中跳转，具体原因我们在后面讨论信号的时候会说明。 8. 资源的获取及控制ulimit -a 关乎一个进程能使用的资源量是多少； 12345678910111213141516-t: cpu time (seconds) unlimited-f: file size (blocks) unlimited-d: data seg size (kbytes) unlimited-s: stack size (kbytes) 8192-c: core file size (blocks) 0-m: resident set size (kbytes) unlimited-u: processes 4096-n: file descriptors 1024 # 一个进程能打开文件最多个数-l: locked-in-memory size (kbytes) 64-v: address space (kbytes) unlimited-x: file locks unlimited-i: pending signals 7144-q: bytes in POSIX msg queues 819200-e: max nice 0-r: max rt priority 0-N 15: unlimited 13.函数 getrlimit(2) 和 setrlimit(2) 1234567// getrlimit, setrlimit - get/set resource limits #include &lt;sys/time.h&gt; #include &lt;sys/resource.h&gt; int getrlimit(int resource, struct rlimit *rlim); int setrlimit(int resource, const struct rlimit *rlim); 每个进程都有一组对资源使用的上限，通过这两个函数可以获取或设置这些上限。 ulimit(P) 命令就是使用这两个函数封装的。 getrlimit(2) 获取 resource 资源，并且把读取结果回填到 rlptr 中。 setrlimit(2) 设置 resource 资源，设置的值由用户填在 rlimit 中。 rlimit 结构体的内容也很简单，当然这些资源上限也不是随便可以修改的，下面的规则同样适用于 ulimit(P) 命令。 1234struct rlimit &#123; rlim_t rlim_cur; /* 软限制。普通用户能提高和降低软限制，但是不能高过硬限制。超级用户也一样。 */ rlim_t rlim_max; /* 硬限制。普通用户只能降低自己的硬限制，不能提高硬限制。超级用户能提高硬限制也能降低硬限制。 */&#125;;","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"进程","slug":"apue-4","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:22.252Z","comments":true,"path":"2020/12/16/apue-4/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-4/","excerpt":"","text":"进程脉络 进程是什么 进程是怎么产生的，怎么消亡的，父子进程是何关系 进程中的一种特殊方式 —— 守护进程 线程是什么 线程和进程的关系 多线程之间通信和多进程之间通信的区别 进程标识符 pid 进程的产生 fork vfork 进程的消亡及释放资源 exec函数族 用户权限及组权限 观摩：解释器文件 system(); (2,3,4的封装) 进程会计 进程时间 守护进程 系统日志 1. 进程标识符 pidpid 是系统中进程的唯一标志，在系统中使用 pid_t 类型表示，它是一个非负整型， 严格来说是一个有符号的16位整型数。 一台机器同时能有3万多个进程；正常情况下有3万多个进程是够用的；不够用的话，结合现在的虚拟机技术，同一台机器上 弄多个虚拟机。 1.1 ps （当前进程的情况）ps(1) 命令可以帮助我们分析本章中的一些示例，所以简单介绍一些参数的组合方式，更详细的信息请查阅 man 手册。 1ps axf #主要用于查看当前系统中进程的 PID 以及执行终端(tty)和状态等信息，更重要的是它能显示出进程的父子关系。 123456PID TTY STAT TIME COMMAND 2 ? S 0:00 [kthreadd] 4 ? S&lt; 0:00 \\_ [kworker/0:0H] 6 ? S 0:04 \\_ [ksoftirqd/0] 7 ? S 0:00 \\_ [migration/0] 8 ? S 0:00 \\_ [rcu_bh] TTY： 所占据终端 STAT： 进程状态 TIME： 消耗时间 COMMAND： 哪个命令触发的 1ps axm #显示进程的详细信息，PID 列下面的减号(-)是这个进程中的线程。 1ps ax -L #以 Linux 的形式显示当前系统中的进程列表。 1234PID LWP TTY STAT TIME COMMAND 1 1 ? Ss 0:18 /usr/lib/systemd/systemd --switched-root --system --deserialize 22 2 2 ? S 0:00 [kthreadd] 4 4 ? S&lt; 0:00 [kworker/0:0H] LWP: 轻量级进程编号，简单来说就是线程编号 1ps axj #以查看当前系统中进程的 PPID、PID、PGID、SID、TTY 等信息。 1.2 进程号是顺次向下使用 比如当前有个进程是10001，然后下一个就是 10002，再下就是10003，即使前面有进程号已经释放掉了，也不会回去去找。进程号是不断向后使用的，当进程号达到最大值的时候，再回到最小一个可用的数值重新使用。 1.3 getpid() 获取当前进程号 getppid() 获取当前进程父进程号12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t getpid(void);pid_t getppid(void); 2. 进程的产生 fork vfork今天讨论进程控制这一章，也是进程中最终要的一部分，其实主要就是围绕着 fork(2)、exec(2)、wait(2) 这三个函数来讨论 *nix 系统是如何管理进程的。 2.1 fork fork(2) 函数的作用就是创建子进程，creates a new process by duplication the calling process。 通过复制父进程来创建子进程 123// fork - create a child process #include &lt;unistd.h&gt; pid_t fork(void); 2.1.1 fork函数返回值 fork函数之后，在父进程中返回的是子进程的 pid。在子进程中返回值为0.如果失败返回值为 -1.fork语句下面一定跟分支语句。来确定父子关系是什么样的情况。 注意理解关键字 duplication， 拷贝，一摸一样。 2.1.2 init进程 1号进程， init 进程是所有进程的祖先进程（但不一定是父进程），内核启动后会启动 init 进程，然后内核就会像一个库一样守在后台等待出现异常等情况的时候再出来处理一下，其它的事情都由 init 进程创建子进程来完成。 调用 fork(2) 创建子进程的时候，刚开始父子进程是一模一样的，就连代码执行到的位置都是一模一样的。 fork(2) 执行一次，但返回两次。它在父进程中的返回值是子进程的 PID，在子进程中的返回值是 0。子进程想要获得父进程的 PID 需要调用 getppid(2) 函数。 一般来说调用fork后会执行 if(依赖fork的返回值) 分支语句，用来区分下面的哪些代码由父进程执行，哪些代码由子进程执行。 好了，既然父进程通过复制一份自己创建了子进程，难道父子进程就是一模一样的吗？只有下面这5点不一样。 2.1.3 fork后父子进程的区别(1) fork(2) 的返回值不同； (2) 父子进程的 PID 不相同； (3) 父子进程的 PPID 不相同； // PPID 就是父进程 PID (4) 在子进程中资源的利用量清零，否则如果父进程打开了很多资源，子进程能使用的资源量就很少了； (5) 未决信号和文件锁不继承。 父进程与子进程谁先运行是不确定的，这个执行顺序是由进程调度器决定的，不过 vfork(2) 会保证子进程先运行。进程调度器不是一个工具，是在内核中的一块代码。 写个简单的小栗子： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt; int main() &#123; pid_t pid; printf(\"[%d]Begin!\\n\", getpid()); pid = fork(); if (pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(0 == pid) &#123; printf(\"[%d] Child is working!\\n\", getpid()); &#125; else &#123; printf(\"[%d] parent is working!\\n\", getpid()); &#125; printf(\"[%d]End!\\n\", getpid()); exit(0); &#125; 执行结果： 12345[95852]Begin![95852] parent is working![95852]End![95853] Child is working![95853]End! 第一个结论 永远不要猜测父子进程 谁先被调度。调度器的调度策略来决定哪个进程先运行 如果非得决定两个进程得执行顺序 1234567891011121314pid = fork(); if (pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(0 == pid) &#123; printf(\"[%d] Child is working!\\n\", getpid()); &#125; else &#123; sleep(1); // 可以加sleep 来约定 printf(\"[%d] parent is working!\\n\", getpid()); &#125; 阻塞程序 来查看它们的父子进程关系 12getchar();exit(); 12345&gt;$ ps axf11220 pts/0 Ss 0:10 \\_ shell96877 pts/0 S+ 0:00 | \\_ ./fork196878 pts/0 S+ 0:00 | \\_ ./fork1 从 ps(1) 命令可以看出来，96877 进程确实产生了一个子进程 96878。 第二个结论 当前的shell 创建了 fork1这个进程，因为是在 shell环境下， ./fork1 的。在fork1 这个进程中有产生了一个进程 fork1，（名字也是自己）有 shell/fork1/fork1 这种阶梯关系的，就能看出父子进程之间的关系。 我们发现还有很多进程 都类似 shell 前面的 \\ 这种顶格写的，他们的父进程都是1，即init。所以不是 1号 init进程直接 fork出来所有进程的。有可能 init fork出来A， Afork出来B，1号进程是所有进程的祖先进程。不能认为是所有进程的父进程。 后面在讨论释放进程的时候，会涉及到 孤儿进程，僵尸进程。有些进程会父进程消亡，然后由init来接管。 重定向到文件中 123456789101112131415161718192021222324252627// fork1.c int main() &#123; pid_t pid; printf(\"[%d]Begin!\\n\", getpid()); fflush(NULL); //一定要在fork之前 刷新所有成功打开的流 pid = fork(); if (pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(0 == pid) &#123; printf(\"[%d] Child is working!\\n\", getpid()); &#125; else &#123; printf(\"[%d] parent is working!\\n\", getpid()); &#125; printf(\"[%d]End!\\n\", getpid()); exit(0); &#125; 但是这里面有一个问题，我们重新执行一遍这个程序，这次将输出重定向到文件中。 12345678 &gt;$ ./fork1 &gt; result.txt &gt;$ cat result.txt[97309]Begin![97309] parent is working![97309]End![97309]Begin![97310] Child is working![97310]End! 第三个结论 fflush 的重要性 发现有什么不同了吗？父进程竟然输出了两次 Start!，这是为什么呢？ 其实第二次 Start! 并不是父进程输出的，而是子进程输出的。但是为什么 PID 却是父进程的呢？ 其实这是因为行缓冲变成了全缓冲导致的，之前我们讲过，标准输出默认是行缓冲模式，而系统默认的是全缓冲模式。所以当我们将它输出到控制台的时候是可以得到预期结果的，但是一旦重定向到文件的时候就由行缓冲模式变成了全缓冲模式，全缓冲模式下， \\n 只起到一个 换行的作用，是不刷新缓冲区的。 也就是说在 Begin!放到了缓冲区当中，还没来得及写到文件里面的时候。马上fork了。而子进程产生的时候是会复制父进程的缓冲区的数据的，所以子进程刷新缓冲区的时候子进程也会将从父进程缓冲区中复制到的内容刷新出来。这样，父子进程的缓冲区里面各自有了这句 Begin!同时这也印证了为什么两次输出的 Begin 都带着父进程的进程号[97309]Begin!...[97309]Begin!. 正是因为这个语句在第一次执行的时候已经固定了，后面直接复制的。 因此，在使用 fork(2) 产生子进程之前一定要使用 fflush(NULL) 刷新所有缓冲区！ 那么再考虑一个问题，当程序运行的时候，为什么子进程的输出结果是在当前 shell 中，而没有打开一个新的 shell 呢？ 这是因为子进程被创建的时候会复制父进程所有打开的文件描述符，所谓的“复制”是指就像执行了 dup(2) 函数一样，父子进程每个相同的打开的文件描述符共享一个文件表项。 而父进程默认开启了 0(stdin)、1(stdout)、2(stderr) 三个文件描述符，所以子进程中也同样存在这三个文件描述符。 既然子进程会复制父进程的文件描述符，也就是说如果父进程在创建子进程之前关闭了三个标准的文件描述符，那么子进程也就没有这三个文件描述符可以使用了。 从上面的 ps(1) 命令执行结果可以看出来，我们的父进程是 bash 的子进程，所以我们父进程的三个标准文件描述符是从 bash 中复制过来的。 2.2 继续理解父子进程的关系1234567891011121314151617181920212223242526// 单机版程序 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #define LEFT 30000000 #define RIGHT 30000200 int main() &#123; int i, j, mark; for(i = LEFT; i&lt;=RIGHT; i++) &#123; mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); &#125; exit(0); &#125; 12345678910111213141516171819$ ./primer030000001 is a primer30000023 is a primer30000037 is a primer30000041 is a primer30000049 is a primer30000059 is a primer30000071 is a primer30000079 is a primer30000083 is a primer30000109 is a primer30000133 is a primer30000137 is a primer30000149 is a primer30000163 is a primer30000167 is a primer30000169 is a primer30000193 is a primer30000199 is a primer 12$ ./primer0| wc -l18 1234567$ time ./primer0 &gt; /dev/null./primer0 &gt; /dev/null 0.97s user0.00s system101% cpu0.958 total 1234567891011121314151617181920212223242526272829303132333435363738394041// 用201 个 子进程 来计算这201个等待计算的任务#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #define LEFT 30000000 #define RIGHT 30000200 int main() &#123; int i, j, mark; pid_t pid; for(i = LEFT; i&lt;=RIGHT; i++) &#123; pid = fork(); if(pid&lt;0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // child &#123; mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); exit(0); // 子进程正常结束 &#125; &#125; exit(0); &#125; 12345678910111213141516171819# 无序30000023 is a primer30000037 is a primer30000079 is a primer30000001 is a primer30000041 is a primer30000049 is a primer30000083 is a primer30000059 is a primer30000133 is a primer30000071 is a primer30000137 is a primer30000109 is a primer30000149 is a primer30000169 is a primer30000163 is a primer30000193 is a primer30000167 is a primer30000199 is a primer 12./primer1 | wc -l18 12345678910111213141516time ./primer0./primer0 0.99s user0.00s system61% cpu1.623 totaltime ./primer1./primer1 0.00s user0.01s system7% cpu0.186 total 解析： 严格来讲，primer0 是201个数，1个人在干活，要计算201个数值。它消耗合计是 1.623。primer1是201个人 干201个活。总耗时是 0.186。 要计算的话 相当于 1.623/500 才对。但事实上，0.186要远远大于 1.623/500的时长。然而事实并非如此。假设当前机器是单核处理器，尽管创建出来这么多进程。但并发还是取决于调度。那这201个任务，不知道先调度到谁，后调度到谁。但是只有一个处理器在工作。所以任务消耗的时间减少不到哪里去。 而事实上,应该减少。因为本机是双核的处理器。最多的时候是两个任务在并列运行。相当于201个人在干活，要排队用处理器。 当前的时间就应该是 单进程的时间/2，所以一个 0.7到0.8的时间是靠谱的。但为啥小到只有 0.186呢？ 暂缓回答问题，先观察一个现象 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; #define LEFT 30000000#define RIGHT 30000200 int main() &#123; int i, j, mark; pid_t pid; for(i = LEFT; i&lt;=RIGHT; i++) &#123; pid = fork(); if(pid&lt;0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // child &#123; mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); sleep(1000); // sleep 阻塞进程 exit(0); // 子进程正常结束 &#125; &#125; exit(0); &#125; 123456789101112131415161718195468 pts/0 S 0:00 ./primer25469 pts/0 S 0:00 ./primer25470 pts/0 S 0:00 ./primer25471 pts/0 S 0:00 ./primer25472 pts/0 S 0:00 ./primer25473 pts/0 S 0:00 ./primer25474 pts/0 S 0:00 ./primer25475 pts/0 S 0:00 ./primer25476 pts/0 S 0:00 ./primer25477 pts/0 S 0:00 ./primer25478 pts/0 S 0:00 ./primer25479 pts/0 S 0:00 ./primer25480 pts/0 S 0:00 ./primer25481 pts/0 S 0:00 ./primer25482 pts/0 S 0:00 ./primer2。。。# 观察到有201个 S状态的进程，它们的父进程是 init。 “man ps -&gt; process state codes”status S 代表可中断的睡眠态 killall primer2 杀掉相关进程 继续举个例子 12345678910111213141516171819202122232425262728293031323334int main()&#123; int i, j, mark; pid_t pid; for(i = LEFT; i&lt;=RIGHT; i++) &#123; pid = fork(); if(pid&lt;0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // child &#123; mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); // sleep(1000); // sleep 阻塞进程 exit(0); // 子进程正常结束， 这里如果不结束的话，子进程还会继续fork，递归fork导致资源被占满，系统卡死 &#125; &#125; sleep(1000); // sleep 阻塞父进程 exit(0);&#125; 12345678910111213141516&gt;$ ps axf 3115 pts/0 Ss 0:00 \\_ zsh 7114 pts/0 S+ 0:00 | \\_ ./primer3 7115 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7116 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7117 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7118 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7119 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7120 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7121 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7122 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7123 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; 7124 pts/0 Z+ 0:00 | \\_ [primer3] &lt;defunct&gt; . . . 当前的 primer3是 S+ ,可中断的睡眠态，从执行结果来看，子进程的状态已经变为 Z+ 了，说明子进程执行完成之后变成了“僵尸进程”。在程序中，父进程在sleep 1000之后，会exit掉。那么这些 zombie 进程会变成 孤儿进程；这些孤儿进程将全部由init来接管。 在进程关系当中出现 zombie状态是一种正常的。在这里要把子进程看做是 父进程创建出来的资源。当然用完要释放资源。 那么为什么子进程会变为僵尸进程呢？是因为子进程比父进程先结束了，它们必须得等待父进程为其“收尸”才能彻底释放。 如果父进程先结束了，那么这些子进程的父进程会变成 1 号 init 进程，当这些子进程运行结束时会变成僵尸进程，然后 1 号 init 进程就会及时为它们收尸。 很多人会认为僵尸进程不应该出现，它们会占用大量的资源。其实不然，僵尸进程不是不应该存在，而是它可以存在。但它一定要是一闪即逝的。这表示及时收尸了。 zombie大量存在其实占据不了多少内存。一个zombie进程其实连那个4GB虚拟空间都不占据。 它们在内核中仅仅保留一个结构体，也就是自身的状态信息，其它的资源都释放了。但是它占用了一个重要的系统资源：PID，因为系统中 PID 的数量是有限的，所以及时释放僵尸进程还是很有必要的。 我们的父进程没有对子进程进行收尸，所以才会出现这样的情况。其实对于这种转瞬即逝的程序而言不会有什么危害，但是假设父进程是一个要不断执行一个月的程序，而它却又不为子进程收尸，那么子进程就会占用这些 PID 一个月之久，那么就可能出现问题了。 所以在一个完善的程序中，父进程是要为子进程收尸的. 2.3 父进程为何要对子进程进行收尸 为何不让子进程自行消亡，而是让父进程等待收尸。假如进程号1000的进程fork了一个子进程1001.（父进程空间里面，父进程fork的返回值会是子进程的进程号）还是因为进程消亡之后，如果不收尸，那么1001这个进程号有可能已经被别的进程征用了，导致当前进程里面重复调用1001进程引发其他程序的血崩。 2.4 fork的成本，引出vofork父进程中从数据库导入30万条记录，我需要子进程帮我干另外一件事儿。 “打印一个helloworld 然后退出。” 这个消耗有点大， 首先子进程拷贝了这 30万条数据，然后子进程完全没用上。很显然fork的成本是很高的。 我们画幅图来辅助解释上面说的一大坨是什么意思。 图1 fork(2) 与写时拷贝 结合上图，我们来聊聊 fork(2) 的前世今生。 最初的 frok(2) 函数在创建子进程的时候会把父进程的数据空间、堆和栈的副本等数据统统给子进程拷贝一份，如果父进程携带的数据量特别大，那么这种情况创建子进程就会比较耗费资源。 这还不是最要命的，万一费了这么大劲创建了一个子进程出来，结果子进程没有使用父进程给它的数据，而只是打印了一句 “Hello World!” 就结束退出了，岂不是白白的浪费了之前的资源开销？ 于是聪明的程序猿们想出了一个办法来替代：让父子进程共享同一块数据空间，这样创建子进程的时候就不必担心复制数据耗费的资源较高的问题了，这就是传说中的 vfork(2) 函数实现的效果。 那么问题来了，如果子进程修改了数据会发生什么情况呢？Sorry，这个标准里没说，天知道会发生什么事情，所以 vfork(2) 通常被认为是过时了的函数，已经不推荐大家使用了。 既然上面两个办法都不完美，程序猿们只好再次改良 fork(2) 函数，这次虽然效率稍微比 vfork(2) 稍稍低了那么一点点，但是安全性是可以保证的，这就是写时拷贝技术。 写时复制（Copy-On-Write，COW）简单来说就是，需要改变的时候，才复制一份进行改动。就是 图1 里下面的部分，fork(2) 函数刚刚创建子进程的时候父子进程的数据指向同一块物理内存，但是内核将这些内存的访问变为只读的了，当父子进程中的任何一个想要修改数据的时候，内核会为修改区域的那块内存制作一个副本，并将自己的虚拟地址映射到物理地址的指向修改为副本的地址，从此父子进程自己玩自己的，谁也不影响谁，效率也提高了许多。新分配的副本大小通常是虚拟存储系统中的一“页”。 当然，写是复制技术中所谓制作一个副本，这个是在物理地址中制作的，并非是我们在程序中拿到的那个指针所指向的地址，我们的指针所指向的地址其实是虚拟地址，所以这些动作对用户态程序员是透明的，不需要我们自己进行管理，内核会自动为我们打点好一切。 fork别忘了写exit 子进程一定要exit， 否则会额外次数 创建 进程；甚至是阶乘次数 2.4 vfork(2) 已废弃的方法123456789101112131415161718// vfork - create a child process and block parent #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; pid_t vfork(void); // Feature Test Macro Requirements for glibc (see feature_test_macros(7)): vfork(): Since glibc 2.12: _BSD_SOURCE || (_XOPEN_SOURCE &gt;= 500 || _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED) &amp;&amp; !(_POSIX_C_SOURCE &gt;= 200809L || _XOPEN_SOURCE &gt;= 700) Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE &gt;= 500 || _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED vfork(2) 函数在上面介绍写时拷贝技术的时候我们就提到了它的工作方式，并且也说了这是一个过时的函数，不推荐大家使用了，简单了解一下就可以了。 使用 vfork(2) 函数创建的子进程除了与父进程共享数据外，vfork(2) 还保证子进程先运行，在子进程调用 exec(3) 函数族 或 exit(3)(_exit(2)、_Exit(2)) 函数前父进程处于休眠状态。 另外，使用 vfork(2) 创建的子进程是不允许使用 return 语句返回的，只能使用 exit(3) 函数族的函数结束，否则会被信号杀死，父进程则不受这个限制。 3. 进程的消亡及释放资源 主要涉及的函数是 wait 和 waitpid， 另外还有waitid，wait3，wait4 3.1 收尸模块 父进程创建完子进程，子进程干完活。在干活期间，父进程在等着。等子进程状态终止了，再把它收尸回来。收尸最主要的两件事，第一，你是否关心子进程的退出状态。如果关心的话，应该从它那个僵尸进程中把它的状态取过来。第二， 释放pid（这个资源相对重要） 3.2 wait(2) 2是系统调用1234567// wait, waitpid, waitid - wait for process to change state #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; pid_t wait(int *status); pid_t waitpid(pid_t pid, int *status, int options); wait(2) 阻塞的等待子进程资源的释放，相当于上面提到的“收尸”。 每次调用 wait(2) 函数会为一个子进程收尸，而 wait(2) 函数并没有让我们指定是哪个特定的子进程。如果想要为特定的子进程收尸，需要调用 waitpid(2) 函数。 收尸这件事只能是父进程对子进程做，而且只能对自己的子进程做。子进程是不能为父进程收尸的，父进程也不能为别人的子进程收尸。 参数列表： status：由函数回填，表示子进程的退出状态。如果填 NULL，表示仅回收资源，并不关心子进程的退出状态。 status 参数可以使用以下的宏进行解析： 宏 描述 WIFEXITED(status) 返回真表示子进程正常终止，返回假表示子进程异常终止。正常与异常终止的8种方式上面讲过。 WEXITSTATUS(status) 返回子进程的退出码。只有上一个宏返回正常终止时才能使用，异常终止是不会有返回值的。 WTERMSIG(status) 可以获得子进程具体被哪个信号杀死了。 WIFSTOPPED(status) 子进程是否被信号 stop 了。stop 和杀死是不同的，stop 的进程可以被恢复(resumed)。 WSTOPSIG(status) 如果子进程是被信号 stop 了，可以查看具体是被哪个信号 stop 了。 WIFCONTINUED(status) 如果子进程被 stop 了，可以查看它是否被 resumed 了。 表1 解析 wait(2) 函数 status 参数的宏 pid：一共分为四种情况： pid参数 解释 &lt; -1 为归属于进程组 ID 为 pid 参数的绝对值的进程组中的任何一个子进程收尸 == -1 为任意一个子进程收尸 == 0 为与父进程同一个进程组中的任意一个子进程收尸 &gt; 0 为一个 PID 等于参数 pid 的子进程收尸 表2 wait(2) 函数 pid 参数的取值说明 options：为特殊要求；这个参数是这个函数的设计精髓。可以通过 WNOHANG 宏要求 waitpid(2) 函数以非阻塞的形式为子进程收尸，这个也是最常用的特殊要求。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main (void)&#123; pid_t pid; int i = 0; for (i = 0; i &lt; 10; i++) &#123; fflush(NULL); pid = fork(); if (pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; else if (0 == pid) &#123; printf(\"pid = %d\\n\", getpid()); exit(0); &#125; &#125; // 为所有的子进程收尸 for (i = 0; i &lt; 10; i++) &#123; wait(NULL); &#125; return 0;&#125; 大家有没有想过为什么要由父进程为子进程收尸呢，为什么不让子进程结束后自动释放所有资源？试想如果没有收尸这步会发生什么。 假设父进程需要创建一个子进程并且要让它做 3 秒钟的事情，很不巧子进程刚启动就出现了一个异常然后就挂掉了，并且直接释放了自己的资源。而此时系统 PID 资源紧张，很快已死掉的子进程的 PID 被分配给了其它进程，而父进程此时并不知道手里的子进程的 PID 已经不属于它了。 如果这时候父进程后悔执行子进程了，它要 kill 掉这个子进程。。。。。后果就是系统大乱对吧。 而使用了收尸技术之后，子进程状态改变时会给父进程发送一个 SIGCHLD 信号，wait(2) 函数其实就是阻塞等待被这个信号打断，然后为子进程收尸。 系统通过收尸这种机制来保证父进程未执行收尸动作之前，手里拿到的子进程 PID 一定是有效的了（即使子进程已死掉，但是这个 PID 依然是属于父进程的子进程的，而不会归属于别人）。 3.3 进程分配 —— 交叉分配法 从30000000 至 30000200 之间有201个等待计算的数，但是我们不可能每个数都创建出一个进程。因为如果这个等待计算的数进一步扩大时，因为 系统提供的pid 规模是固定的，所以这套方案是没法通用的。 3.3.1 分块法 将被选数 等分为N份，这样的缺点在于可能某一块负载最重，是因为质数的分布是随着数值越大分布越少的 3.3.2 交叉分配 依然将被选数分为N份，但是不再是整个数据集切片，而是发牌一样，每个块分一张，循环下去。缺点是，面对连续数据时候，每一块可能是某个数的倍数集合。这样会导致有些块可能一个质数都没有的情况。尽管如此，交叉分配仍然是一个相对合理的选择 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #define LEFT 30000000 #define RIGHT 30000200 #define N 3 int main() &#123; int i, j, mark; pid_t pid; int n; for(n= 0; n&lt;N; n++) &#123; pid = fork(); if(pid&lt;0) &#123; perror(\"fork()\"); exit(1); &#125; if (pid ==0) &#123; for(i = LEFT+n; i&lt;=RIGHT; i+=N) &#123; mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"[%d]%d is a primer\\n\",n, i); &#125; exit(0); // 子进程正常结束 &#125; &#125; int st; for (n = 0; n&lt;= N; n++) wait(NULL); exit(0); &#125; 123456789101112131415161718[1]30000001 is a primer[2]30000023 is a primer[1]30000037 is a primer[2]30000041 is a primer[1]30000049 is a primer[2]30000059 is a primer[1]30000079 is a primer[2]30000071 is a primer[2]30000083 is a primer[1]30000109 is a primer[1]30000133 is a primer[2]30000137 is a primer[1]30000163 is a primer[2]30000149 is a primer[1]30000169 is a primer[2]30000167 is a primer[1]30000193 is a primer[1]30000199 is a primer 3.4 池 大致是上流的 父进程，将任何发布于池中，下流的N个进程（线程）轮番抢任务执行。具体后续再写标准进程池 和标准线程池 的标准写法 4.exec函数族终于轮到我们今天第三个主角：exec(3) 函数上场了。 123456789101112131415161718 // execl, execlp, execle, execv, execvp, execvpe - execute a file// the exec() family of functions replaces the current process image with a new process image. #include &lt;unistd.h&gt; extern char **environ; int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[], char *const envp[]); // Feature Test Macro Requirements for glibc (see feature_test_macros(7)): execvpe(): _GNU_SOURCE 我们再来看上面第一个 fork(2) 代码的栗子执行时使用 ps -axf 命令查看父子依赖关系的结果： 12345$ ps axf 3565 pts/1 Ss 0:00 \\_ bash 3713 pts/1 S+ 0:00 | \\_ ./1fork 3714 pts/1 S+ 0:00 | \\_ ./1fork $ 我们知道 fork(2) 创建出来的子进程是通过复制父进程的形式实现的，但是我们的父进程又是 bash 的子进程，为什么 bash 没有创建出来一个与自己一模一样的子进程呢？ 这就是 exec(3) 函数族的功劳了。 它可以使调用的它进程“外壳”不变，“内容物”改变为新的东西。“外壳”就是父子关系、PID 等东西，“内容物”其实是指一个新的可执行程序。也就是说 exec(3) 函数会将调用它的进程完全(整个4GB虚拟内存空间，即代码段、数据段、堆栈等等)变成另一个可执行程序，但父子关系、PID 等东西不会改变。 在执行了 exec(3) 函数族的函数之后，整个进程的地址空间会立即被替换，所以 exec(3) 下面的代码全部都不会再执行了，替代的是新程序的代码段。 12345678910111213141516 int main() &#123; puts(\"Begin!\"); fflush(NULL); // 缓冲区也会被新的程序所替换，所以在执行 exec(3) 之前要使用 fflush(NULL) 刷新所有的缓冲区。这样父进程才会让它缓冲区中的数据到达它们该去的地方，而不是在数据到达目的地之前缓冲区就被覆盖掉。注意在调 execl函数之前，调用 fflush刷新一下缓冲区 execl(\"/bin/date\",\"date\",\"+%s\", NULL); /** execl 以下的函数不会再执行了，整个进程的虚拟空间换成（replace）另一个可执行程序 */ perror(\"execl()\"); exit(1); puts(\"End!\"); exit(0); &#125;// Begin!// 1594308168 参数列表： path：要执行的二进制程序路径 arg：传递给 path 程序的 argv 参数，第一个是 argv[0]，其它参数从第二个开始。 …：argv 的后续参数，最后一个参数是 NULL，表示变长参数列表的结束。 看上去 execl(3)、execlp(3) 像是变参函数，execle(3) 像是定参函数，其实正好是反过来的，execl(3) 和 execlp(3) 是定参的，而 execle(3) 函数是变参的。 下面我们来看一个 fork(2) + exec(3) + wait(2) 最经典的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; /** * 创建子进程 date，参数是 +%s * 相当于在 shell 中执行 date +%s 命令 */int main() &#123; pid_t pid; puts(\"Begin!\"); fflush(NULL); pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // child &#123; execl(\"/bin/date\",\"date\",\"+%s\",NULL); perror(\"execl()\"); exit(1); &#125; wait(NULL); puts(\"End!\"); exit(0); &#125;// Begin!// 1594309338// End! 总结： fork(2)、exec(3)、wait(2) 函数可以让我们创建任何进程来执行任何命令了，如此看来，整个 *nix 世界都是由 fork(2)、exec(3)、wait(2) 这三个函数搭建起来的，现在大家可以尝试用这三个函数来执行一些命令了。 4.1 shell的工作模式 以ls命令具体流程为例 在当前shell下执行 ls这种二进制命令时，它是通过fork产生一个子进程。产生的这个子进程是shell本身。然后去 execl 让子进程摇身一变成 ls。然后在子进程运行的时候，父进程调用wait(NULL)等着给子进程收尸。然后父进程继续做别的任务。 所以这也解释为什么当执行 ls的时候，是 ls的结果列表先展示出来，然后才是 命令行 $展示出来。 由于你当前shell一定写的是个死循环。所以shell继续打印出来命令行等待你给终端的输入情况。这就是shell的工作模式； 4.2 为什么父子进程的输出能打印到同一个终端上实现一个sleep100的功能 123456789101112131415161718192021222324int main()&#123; pid_t pid; puts(\"Begin!\"); fflush(NULL); pid = fork(); if(pid&lt;0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid== 0) &#123; execl(\"/usr/bin/sleep\",\"sleep\",\"100\", NULL); // execl(\"/usr/bin/sleep\",\"httpd\",\"100\", NULL); // ps axf 查看进程列表的时候， 会显示重命名的 httpd。 所以 argv[0] 的基本操作； perror(\"execl()\"); exit(1); &#125; wait(NULL); puts(\"End!\"); exit(0);&#125; 1233115 pts/0 Ss 0:01 \\_ zsh30803 pts/0 S+ 0:00 | \\_ ./sleep30804 pts/0 S+ 0:00 | \\_ sleep 100 4.3 shell命令行的实现 shell 的内部命令与外部命令,一个命令的二进制可执行文件，如果是存在磁盘上的。那么这个命令就叫做外部命令。其他的就叫内部命令。比如目录的管理，比如一个进程消亡，它的子进程如何去做。包括调度等等。全部都属于shell的内部命令处理。 像 cd(1)、exit(2)、|、&gt; 牵涉到环境变量改变等动作这样的命令叫做内部命令，而使用 which(1) 命令能查询到的在磁盘上存在的命令就是外部命令。 学会了 fork(2)、exec(3)、wait(2) 函数的使用，大家已经可以尝试编写一个 shell 程序了，基本可以执行所有的外部命令了。 但是一个 shell 不仅仅支持外部命令，还支持很多内部命令，对内部命令的支持才是 shell 的难点。 关于内部命令的内容多数都在《APUE》第三版 的第九章中，感兴趣的童鞋可以自行查阅。 外部命令实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// myshell.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;glob.h&gt;#define DELIMS \" \\t\\n\"struct cmd_st&#123; glob_t globres;&#125;void prompt()&#123; printf(\"mysh-0.1$\");&#125;void parse(const char * line, struct cmd_st *res)&#123; char *tok; int i; while(1) &#123; tok = strsep(&amp;line, DELIMS); if(tok == NULL) break; if(tok[0] == '\\0') continue; glob(tok, GLOB_NOCHECK|GLOB_APPEND*i, NULL, &amp;res-&gt;globres); i=1; &#125;&#125;int main()&#123; char *linebuf = NULL; size_t linebuf_size = 0; struct cmd_st cmd; pid_t pid; while(1) &#123; prompt(); if(getline(&amp;linebuf, &amp;linebuf_size, stdin)&lt;0) &#123; break; &#125; parse(linebuf, &amp;cmd); if(0) &#123; &#125;else &#123; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) &#123; execvp(cmd.globres.gl_pathv[0], cmd.globres.gl_pathv); perror(\"execvp()\"); exit(1); &#125;else &#123; wait(NULL); &#125; &#125; &#125; exit(0);&#125; 5. 用户权限及组权限(u+s, g+s) 用户权限和组权限是分作好几组来存放的， 1234cat /etc/shadow# 权限不够， 普通用户是没有权限去读写 shadow权限的；passwd# 更改一个用户的口令， 超级用户改谁的口令都是可以的。普通用户能改自己的口令（普通用户在最早之前是不能改自己用户的口令）后来想了一系列办法把root权限开始一点点下放，当然shadow文件普通用户绝对没有权限去改变的。而更改口令是必须用改shadow文件的。 但是普通用户可以调用passwd 来更改自己的口令； 普通用户没有查看 /etc/shadow 文件，但是为什么有权限修改自己的密码呢 123456&gt;$ which passwd/usr/bin/passwd&gt;$ ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 47032 2月 17 2014 /usr/bin/passwd$ ls -l /etc/shadow---------- 1 root root 1899 Apr 1 16:25 /etc/shadow passwd这个命令是如何实现的 u+s 如果一个可执行的文件有 U+S 权限，那就意味着当别的用户在调用当前这个可执行文件的时候，它的身份会切换成当前这个二进制文件的 user的身份来执行。 g+s 不管任何用户来调用这个二进制可执行文件的时候，当前这个用户的身份就会切换成这个二进制文件的同组用户的身份来进行执行。 更改用户 ID 和更改组 ID 在bash上执行一个命令是带着身份进行的，身份从何而来呢 在 *nux 系统中，特权和访问控制是基于用户 ID 和用户组 ID 的，所以当我们需要使用特权或访问无权访问的文件时需要切换 用户 ID 或 用户组 ID。 uid（userid） r(real) 用于保存用户权限 e(effective) 鉴定用户权限时使用 s 与 real 相同，所以有些系统不支持 gid (groupid) r(real) 用于保存用户组权限 e(effective) 鉴定用户组权限时使用 s 与 real 相同，所以有些系统不支持 U+S 这是因为 passwd(1) 命令是具有 U+S 权限的，用户在使用这个程序的时候身份会切换为这个程序文件所有者的身份。 G+S G+S 与 U+S 类似，只不过执行的瞬间身份会切换为与程序归属用户组相同的组权限。 改变用户 ID 和组 ID 可以使用 setuid(2) 和 setgid(2) 函数实现。 5.1 相关函数123456789101112131415161718#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;uid_t getuid(void);uid_t geteuid(void);gid_t getgid(void);gid_t getegid(void);int setuid(uid_t uid); // sets the effective user IDint setgid(gid_t gid); // sets the effective group IDint seteuid(uid_t euid);int setegid(gid_t egid);int setreuid(uid_t ruid, uid_t euid);int setregid(gid_t rgid, gid_t egid);setregid(); 5.2 实现sudo john cat /home/john1234cat /etc/shadow# 权限不够sudo john cat /home/john 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main(int argc, char **argv)&#123; pid_t pid; if(argc&lt;3) &#123; fprintf(stderr, \"Usage...\\n\"); exit(1); &#125; pid = fork(); if(pid &lt;0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) &#123; setuid(atoi(argv[1])); execvp(argv[2], argv+2); perror(\"execvp\"); exit(1); &#125; wait(NULL); exit(0);&#125; 123456su rootchown root mysuchmod u+s mysu./mysu 0 cat /etc/shadow 6. 观摩课：解释器文件6.1 解释器文件解释器文件其实就是脚本。 做一个系统级开发工程师需要具备的素质至少精通2门语言，一门面向过程，一门面向对象，还要精通至少一门脚本语言，如 shell、python等，还要具备扎实的网络知识和一点硬件知识。 解释器是一个二进制的可执行文件。就是为了用一个可执行的二进制文件解释执行解释器文件中的命令。 6.2 脚本文件的标记#! 用于装载解释器 例如： #!/bin/shell 装载了 /bin/shell 作为解释器 #!/bin/cat 装载了 /bin/cat 作为解释器 123456#! /bin/bash 用什么解释器 执行 脚本体lswhoamicat /etc/shadow # 报错的命令不会阻塞下面命令的执行ps 123456789101112chmod u+x t.exec # 将t.exec变成可执行文件./t.execex.c fork1.chycat: /etc/shadow: 权限不够 PID TTY TIME CMD 4734 pts/1 00:00:00 zsh 27153 pts/1 00:00:00 t.exec 27157 pts/1 00:00:00 ps 那么装载解释器之后为什么不会递归执行装载解释器这行代码呢？因为根据约定，脚本中的 # 表示注释，所以解释器在解析这个脚本的时候不会看到这行装载解释器的命令。 装载解释器的步骤由内核 exec(3) 系统调用来完成，如果使用 exec(3) 函数来调用解释器文件，实际上 exec(3) 函数并没有执行解释器文件，而是执行了解释器文件中装载的解释器，由它来执行解释器文件中的指令。 7. system(); (fork,exec,wait的封装)7.1 system(3) 理解： fork,exec,wait封装 12345// system - execute a shell command #include &lt;stdlib.h&gt; int system(const char *command); 12345int main()&#123; system(\"date + %s &gt; /tmp/out\"); exit(0);&#125; 该函数可以执行一条系统命令，是通过调用 /bin/sh -c command 实现的。 其实我们可以猜测一下 system(3) 命令是如何实现的，下面是伪代码： 1234567891011121314151617181920 pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // child&#123; // system(\"date +%s\"); execl(\"/bin/sh\",\"sh\",\"-c\",\"date +%s\",NULL); perror(\"execl()\"); exit(1);&#125;wait(NULL);exit(0); 8. 进程会计连 POSIX 标准都不支持，是方言中的方言。 它是典型的事实标准，各个系统的实现都不统一，所以建议少用为妙。 123// acct - switch process accounting on or off#include &lt;unistd.h&gt;int acct(const char *filename); 作用是将进程的相关信息写入到 filename 所指定的文件中。 9. 进程时间12345678910#include &lt;sys/times.h&gt;clock_t times(struct tms *buf);struct tms &#123; clock_t tms_utime; /* user time */ clock_t tms_stime; /* system time */ clock_t tms_cutime; /* user time of children */ clock_t tms_cstime; /* system time of children */&#125;; 用户标识 123456// getlogin, getlogin_r, cuserid - get username #include &lt;unistd.h&gt; char *getlogin(void); int getlogin_r(char *buf, size_t bufsize); 能够不受任何因素影响的获取当前终端的用户名。 不受任何因素影响是指，比如我们用 su(1) 等命令切换了用户，getlogin(3) 函数获得到的仍然是原始的用户名。 进程调度 用于控制进程调度优先级，一般不会调整进程的优先级。 进程调度 12345// times - get process and waited-for child process times #include &lt;sys/times.h&gt; clock_t times(struct tms *buffer); 该函数获得的是进程的执行时间。 clock_t 是滴答数。位于秒级以下，具体的与秒的换算值需要通过 sysconf(_SC_CLK_TCK) 宏获得","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"高级IO","slug":"apue-9","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:46.469Z","comments":true,"path":"2020/12/16/apue-9/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-9/","excerpt":"","text":"高级IO非阻塞IO – 阻塞IO补充： 有限状态机编程 非阻塞io io多路转接（文件描述符的监视） 其他读写函数 存储映射io 文件锁 1.1 非阻塞 I/O 非阻塞本身非常容易，对比阻塞来讲，就是不再死等。能做就做，不能做就退出。 高级 IO 部分有个很重要的概念是：非阻塞 I/O 在14章之前，我们讨论的所有函数都是阻塞的函数，例如 read(2) 函数读取设备时，设备中如果没有充足的数据，那么 read(2) 函数就会阻塞等待，直到有数据可读再返回。 当 IO 操作时出现了错误的时候，我们之前在讨论信号的博文中提到过会出现假错的情况。 那么从学了非阻塞 I/O 为止我们一共遇到了两种假错的情况： EINTR：被信号打断，阻塞时会遇到。 EAGAIN：非阻塞形式操作失败。 遇到这两种假错的时候我们需要重新再操作一次，所以通常对假错的判断是放在循环中的。 例如 read(2) 函数使用非阻塞方式读取数据时，如果没有读取到数据，errno 为 EAGAIN，此时并不是说设备有问题或读取失败，只是表明采用的是非阻塞方式读取而已。 阻塞与非阻塞是使用的同一套函数，flags 特殊要求指定为 O_NONBLOCK 就可以了。 下面我们举个小栗子：（伪代码） 1234567891011121314fd = open(\"/etc/service\", O_RDONLY | O_NONBLOCK);/* if error */while (1) &#123; size = read(fd, buf, BUFSIZE); if (size &lt; 0) &#123; if (EAGAIN == errno) &#123; continue; &#125; perror(\"read()\"); exit(1); &#125; // do sth... &#125; 上面的小栗子， 首先在 open(2) 的时候使用特殊要求 O_NONBLOCK 指定以非阻塞形式打开文件。 当 read(2) 发生错误时要判断是否为假错，如果发生了假错就再试一次，如果是真错就做相应的异常处理。 1.2 数据中继 假设有正在打开的两个设备，两个设备之间进行数据交换。专业的叫法可以唤做 数据中继 rl-wr-rr-wl 读左写右读右写左；（单个进程，单个线程干活场景， 循环一圈的话，相当于四个工作） 那假设用阻塞来实现，会遇到什么问题呢？比如读左边的设备，但是设备上一直没有数据出现。如果用阻塞的机制，那么一定会卡在 读左的动作上， 假设右边不断有其他数据来源到来，那么先去读右再去写左，这个时候是一直没有做的。 结果你一直在读左，左边一直没有数据。就没有办法去读右写左了。所以可能导致右边的数据已经溢出了，但左边还一直是空着，而程序一直卡在左边的情况。如果是一个人或者一个任务（一个任务包括一个进程也好，一个线程也好）来干活。这个任务可以是一个线程去做，也可以是一个进程去做。总而言之，这个任务没有协同操作，就一个人来完成。 其实可以把任务拆分为两个任务，第一个任务来负责读左，并且写右。 第二个任务读右并且写左。这是两个进程在通信也好，两个线程也好。这种方式解决问题的几率就更大。那边有数据，那个分支就先走。 域名拦截 中介服务获取用户输入地址，中间插入广告页。而后拿真是请求去访问目标服务器，再返回给客户端。起到一个中介转发的服务。像这种拦截的服务都是中继模型的放大。 当同时有两万对设备在通信，作为一个server端可能会比较忙。fork子进程，每个子进程负责100对。当然要先确定自己能fork出来这么多子进程。考虑fork开销大，改成pthread，创建出来线程，每个线程负责若干对。 其实这种机制，包括前面写的很多程序.慢慢滚雪球，最终变为一个工程。比如上面这种机制就能发展成负载均衡。之所以做不出来，在于外围知识不够。比如负载均衡需要对集群的概念有了解，比如之前讲的流控，可以联系到解码器是如何实现的。比如一个mp3文件的头部如何去读取。用c来监视web上面的一些内容，做这些是需要理解web服务器是如何相应的，是需要理解http1.0 http1.1的语法。这都是周边知识的确实。apue讲的是机制，进程，线程，信号包括后面的进程间通信。 1.3 有限状态机1.3.1 复杂流程与简单流程简单流程： 自然流程是结构化的 复杂流程： 自然流程不是结构化的 什么是自然流程： 作为人类来讲，解决问题最直观的思路 大家先考虑一个问题：把大象放到冰箱里需要几步？ 1）打开冰箱门； 2）把大象放进去； 3）关闭冰箱门； 这就是解决这个问题的自然流程。 图1 简单流程与复杂流程 把一个问题的解决步骤（自然流程）摆出来发现是结构化的流程就是简单流程，如果不是结构化的流程就是复杂流程。所有的网络应用和需要与人交互的流程都是复杂流程。 结构化的流程就是作为人类的本能解决问题的思路。 在之前的博文中 LZ 提到过一个“口令随机校验”的策略大家还记得吗？就是要求用户必须连续两次输入正确的密码才认为校验通过。就算是这样小的模块也不会用一个单纯的顺序选择流程把它完成，它一定是一个非结构化的流程。 有限状态机就是程序设计的一种思路而已，大家刚开始接触觉得难以理解，那是因为还没有习惯这种设计思路。我们为什么觉得像原先那种流程化的程序设计思路好用？那是因为被虐惯了，你曾经被迫习惯用计算机的思路来考虑问题而不是用作为人解决问题的本能步骤来考虑问题。有限状态机就是让你以作为人的本能的解决问题的方式来解决问题，当你习惯了有限状态机的设计思想之后就不觉得这是什么难以理解的东西了。 有限状态机被设计出来的目的就是为了解决复杂流程的问题，所以更何况是简单流程的问题也一样能够轻松的解决。 作为程序猿最怕的是什么？ 恐怕最怕的就是需求变更了吧。 为什么要使用有限状态机的设计思路呢？因为它能帮助我们从容的应对需求变更。 使用有限状态机编程的程序在面对需求变更的时候往往仅需要修改几条 case 语句就可以了，而没有使用有限状态机编程的程序面对需求变更往往要把大段的代码推倒重来。 所以如果你掌握了有限状态机的编程思想，那么在很多情况下都可以相对轻松的解决问题，而且程序具有较好强的健壮性。 说了这么多废话，有限状态机到底是什么呢？ 使用有限状态机首先要把程序的需求分析出来（废话，用什么编程都得先分析需求），然后把程序中出现的各种状态抽象出来制作成一张状态机流程图，然后根据这个流程图把程序的框架搭建出来，接下来就是添枝加叶了。 下面我们通过一个栗子来说明有限状态机的设计思想。 假如有如下需求：从设备 tty11 读取输入并输出到 tty12 上，同样从 tyy12 读取输入并输出到 tty11 上。 首先我们把它的各种状态抽象出来画成一幅图。 图2 有限状态机 每个状态画成一个圆形节点，每个节点延伸出来有多少条线就表示有多少种可能性。 这些节点拿到我们的程序中就变成了一条条 case 语句，下面我们看看使用代码如何实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define BUFSIZE 1024#define TTY1 \"/dev/tty11\"#define TTY2 \"/dev/tty12\"/* 状态机的各种状态 */enum&#123; STATE_R=1, STATE_W, STATE_Ex, STATE_T&#125;;/* 状态机，根据不同的需求设计不同的成员 */struct fsm_st&#123; int state; // 状态机当前的状态 int sfd; // 读取的来源文件描述符 int dfd; // 写入的目标文件描述符 char buf[BUFSIZE]; // 缓冲 int len; // 一次读取到的实际数据量 int pos; // buf 的偏移量，用于记录坚持写够 n 个字节时每次循环写到了哪里 char *errstr; // 错误消息&#125;;/* 状态机驱动 */static void fsm_driver(struct fsm_st *fsm)&#123; int ret; switch(fsm-&gt;state) &#123; case STATE_R: // 读态 fsm-&gt;len = read(fsm-&gt;sfd,fsm-&gt;buf,BUFSIZE); if(fsm-&gt;len == 0) // 读到了文件末尾，将状态机推向 T态 fsm-&gt;state = STATE_T; else if(fsm-&gt;len &lt; 0) // 读取出现异常 &#123; if(errno == EAGAIN) // 如果是假错就推到 读态，重新读一次 fsm-&gt;state = STATE_R; else // 如果是真错就推到 异常态 &#123; fsm-&gt;errstr = \"read()\"; fsm-&gt;state = STATE_Ex; &#125; &#125; else // 成功读取到了数据，将状态机推到 写态 &#123; fsm-&gt;pos = 0; fsm-&gt;state = STATE_W; &#125; break; case STATE_W: // 写态 ret = write(fsm-&gt;dfd,fsm-&gt;buf+fsm-&gt;pos,fsm-&gt;len); if(ret &lt; 0) // 写入出现异常 &#123; if(errno == EAGAIN) // 如果是假错就再次推到 写态，重新再写入一次 fsm-&gt;state = STATE_W; else // 如果是真错就推到 异常态 &#123; fsm-&gt;errstr = \"write()\"; fsm-&gt;state = STATE_Ex; &#125; &#125; else // 成功写入了数据 &#123; fsm-&gt;pos += ret; fsm-&gt;len -= ret; if(fsm-&gt;len == 0) // 如果将读到的数据完全写出去了就将状态机推向 读态，开始下一轮读取 fsm-&gt;state = STATE_R; else // 如果没有将读到的数据完全写出去，那么状态机依然推到 写态，下次继续写入没写完的数据，实现“坚持写够 n 个字节” fsm-&gt;state = STATE_W; &#125; break; case STATE_Ex: // 异常态，打印异常并将状态机推到 T态 perror(fsm-&gt;errstr); fsm-&gt;state = STATE_T; break; case STATE_T: // 结束态，在这个例子中结束态没有什么需要做的事情，所以空着 /*do sth */ break; default: // 程序很可能发生了溢出等不可预料的情况，为了避免异常扩大直接自杀 abort(); &#125;&#125;/* 推动状态机 */static void relay(int fd1,int fd2)&#123; int fd1_save,fd2_save; // 因为是读 tty1 写 tty2；读 tty2 写 tty1，所以这里的两个状态机直接取名为 fsm12 和 fsm21 struct fsm_st fsm12,fsm21; fd1_save = fcntl(fd1,F_GETFL); // 使用状态机操作 IO 一般都采用非阻塞的形式，避免状态机被阻塞 fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK); fd2_save = fcntl(fd2,F_GETFL); fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK); // 在启动状态机之前将状态机推向 读态 fsm12.state = STATE_R; // 设置状态机中读写的来源和目标，这样状态机的读写接口就统一了。在状态机里面不用管到底是 读tty1 写tty2 还是 读tty2 写tty1 了，它只需要知道是 读src 写des 就可以了。 fsm12.sfd = fd1; fsm12.dfd = fd2; // 同上 fsm21.state = STATE_R; fsm21.sfd = fd2; fsm21.dfd = fd1; // 开始推状态机，只要不是 T态 就一直推 while(fsm12.state != STATE_T || fsm21.state != STATE_T) &#123; // 调用状态机驱动函数，状态机开始工作 fsm_driver(&amp;fsm12); fsm_driver(&amp;fsm21); &#125; fcntl(fd1,F_SETFL,fd1_save); fcntl(fd2,F_SETFL,fd2_save);&#125;int main()&#123; int fd1,fd2; // 假设这里忘记将设备 tty1 以非阻塞的形式打开也没关系，因为推动状态机之前会重新设定文件描述符为非阻塞形式 fd1 = open(TTY1,O_RDWR); if(fd1 &lt; 0) &#123; perror(\"open()\"); exit(1); &#125; write(fd1,\"TTY1\\n\",5); fd2 = open(TTY2,O_RDWR|O_NONBLOCK); if(fd2 &lt; 0) &#123; perror(\"open()\"); exit(1); &#125; write(fd2,\"TTY2\\n\",5); relay(fd1,fd2); close(fd1); close(fd2); exit(0);&#125; 123./relayctrl+alt+F11 大家先把这段代码读明白，下面我们还要用这段代码来修改示例。 如果只看上面的代码是很难理解程序是做什么的，因为都是一组一组的 case 语句，不容易理解。所以一般使用有限状态机开发的程序都会与图或相关的文档配套发行，看了图再结合代码就很容易看出来代码的目的了。 大家要对比着上面的图来看代码，这样思路就很清晰了。 使用状态机之前需要使两个待进行数据中继的文件描述符必须都是 O_NONBLOCK 的。 整个状态机中都没有使用循环来读写数据，因为状态机能确保每一种状态都是职责单一的，出现其它的任何状况的时候只要推动状态机问题就可以解决了。 所以这样的程序可维护性是不是高了很多？如果出现了需求变更，只需要简单的修改几条 case 语句就可以了，而不需要大段大段的修改代码了。 大家要多使用状态机的设计思想来写程序才能加深对这种设计思想的掌握程度。 1.3.2 中继引擎库1// 见 relayer 文件夹 已完成中继引擎中的 rel_addjob 方法添加进去任务，并且使用状态机来管理当前非空任务的状态。只要当前这个任务是 STATE_RUNNING 态，那就推里面的两个状态机。当前就是一个server的状态，如果该程序达到最大的负载量, 比如 REL_JOBMAX达到上限，当前有10000对，20000个文件描述符在两秒做数据中继的话，那么看单机是否能承载，如果不能，采用集群，使下面的多个主机来帮助完成这个任务。即使没有多个主机，也能创建子进程或者线程，每个进程或者线程负责多少个状态机的推动。 该程序并不是一个重负载的程序，它最多算一个IO密集型的任务。一般IO密集的程序都不是负载重的程序，负载重，io又密集的话，这程序很难控制。 为什么说这个程序是io密集，它是获取内容然后进行传输。为什么不是重负载，是ftp传输快，还是手动打字快？肯定是FTP快，即使数量多，也是io密集型任务。（这句不是很懂，先留着，以后再理解）。 而io密集型任务，其实绝大多数都在空闲，这个程序的问题是，依然没有完成行为监视的部分，还是盲推。当启动程序时，cpu一下占满一个核，cpu使用率满栈。 没有内容的时候，也是在不停的推动试探。程序大多数时间盲在 EAGAIN。 比如现在初始状态是一个读态，如果没有内容的话，是没办法读的。现在的read返回的就是一个假错。然后在一个while循环中继续 碰到假错 推动到read，以此循环。对于一个io密集型的任务就可以使用io多路转接。如下 1.4 I/O 多路转接 I/O 多路转接， 说白了就是监视文件描述符的行为。 这个技术针对io密集型模型的解决方案。当当前文件描述符发生感兴趣的行为时，我才去做后续操作。这个感兴趣的行为可以有相关的机制去订阅。 上面那个 读tty11 写tty12，读tty12 写tty11 的栗子是采用忙等的方式实现的，I/O 多路转接这个小节讨论的就是怎么把上面那个栗子修改为非忙等的模式。 有些时候就是这样的，读取多个文件（一般是设备）的时候不能使用阻塞方式，因为一个阻塞了其它的就没法读了；而非阻塞方式如果采用忙等的形式又得不偿失，CPU满栈。你想想比如 telnet 服务在接收用户的命令的时候是不是这种情况呢？ 对于处理这样的需求，Linux 系统为我们提供了 3 种方案：select(2)、poll(2) 和 epoll(7)，这些方案提供的函数可以同时监视多个文件描述符，当它们的状态没有变化时阻塞等待，当它们的状态发生变化时会给我们一个通知让我们继续处理任务，下面我们一个一个的介绍它们。 select poll epoll 共同点： 它们三个完成的任务是一致，就是io多路转接，实现文件描述符的监视。 区别 select(2) 的优点是足够老，各个平台都支持它，这也是它相对于 poll(2) 唯一的优点。劣势是本身接口设计的有缺陷，传参部位有问题。 poll跟 select 在监视文件描述符的组织思路是完全不一致的；select是以事件为单位组织文件描述符，poll以文件描述符来组织事件。这两个函数的出发点和组织形式是不太一致的。poll也是可以移植的。 很多平台依然觉得poll的效率不够高，所以以poll为基础上，在各个平台上开发的方言。epoll就是linux系统在poll的基础上做的方言，来完成文件描述符的监视。实际上poll和epoll的思路非常贴近，组织形式也一样。只不过换成poll需要用户自己维护一些内容，epoll是企图简化用户维护的这块内容。把poll在用户角度能看到的一些内容进行了封装组成了epoll的机制，所以epoll是没办法移植的。select poll是可移植的，select太古老。poll均衡三者的比较之中是相对不错的。 1.4.1 select(2)1234567891011121314151617// select, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing/* According to POSIX.1-2001 */#include &lt;sys/select.h&gt;/* According to earlier standards */#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);void FD_CLR(int fd, fd_set *set); // 删除 set 中的 fd 这个文件描述符int FD_ISSET(int fd, fd_set *set); // 测试文件描述符 fd 是否在 set 集合中。void FD_SET(int fd, fd_set *set); // 将文件描述符 fd 添加到 set 中void FD_ZERO(fd_set *set); // 清空一个文件描述符集合 select(2) 的优点是足够老，各个平台都支持它，这也是它相对于 poll(2) 唯一的优点。劣势是本身接口设计的有缺陷，传参不稳定。 select(2)的缺陷， select函数布置监视任务的位置，也就是三个集合，分别为 readfds, writefds, exceptfds。但是它所监视结果所存在的位置也是这三个集合。举个例子，比如现在往 readfds放了10个文件描述符，writefds放10个，exceptfds放10个，要监视30个文件描述符不同的行为。这个时候，假如读集readfds有一个文件描述符可读了，那select函数一下就返回了。返回值为1.然后 readfds存放的就变成了可读的文件描述符了，而 writefds，exceptfds等两个集合则被清空了。监视现场和监视结果用的是一块内存空间，没有const修饰； 第一个参数nfds，当前监视文件描述符最大文件描述符再加1，在一个进程当中，能打开的文件描述符实际上是能够更改的。(ulimit -a)。nfds是int类型的，如果更改之后的打开文件描述符的大小理论上有超过有符号整型的大小风险。 select监视的事件太单一，readfds， writefds，和 exceptfds 除了读和写 就是 异常。异常包含的层面就太多了，包括套接字相关的一些东西 全部都算是异常的结果。 返回值：成功返回，文件描述符个数，现在发生你感兴趣行为的文件描述符个数。而这些发生感兴趣行为的文件描述符依然放在 读集， 写集， 以及异常集当中。失败，返回值为-1， 参数列表： nfds：当前监视文件描述符里面最大的文件描述符 + 1； （比如当前监视的文件描述符是 3，5，7，9。那这里就写10） readfds：需要监视的输入文件描述符集合， 读集； writefds：需要监视的输出文件描述符集合， 写集； exceptfds：需要监视的会发生异常的文件描述符集合， 异常集； timeout：超时设置，等待的超时时间，如果时间超时依然没有文件描述符状态发生变化那么就返回。设置为 0 会立即返回。设置为 NULL 则一直阻塞等待，不会超时，直到发生 注册事件才会返回结果。 还记得我们之前提到过使用 select(2) 函数替代 sleep(3) 函数吗？ 我们看到参数中的文件描述符集合是 fd_set 类型的，那么怎么把我们的 int 类型的文件描述符添加到 fd_set 当中去呢？ 下面我们重构上面的栗子，通过把它修改成非忙等的形式来看看 select 是如何使用的。代码没有太大的区别，所以只贴出有差异的部分。完整版看 relay_select.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374enum&#123; STATE_R=1, STATE_W, STATE_AUTO, // 添加这个值是为了起到分水岭的作用，小于这个值的时候才需要使用 select(2) 监视 STATE_Ex, STATE_T&#125;;static int max(int a,int b)&#123; if(a &lt; b) return b; return a;&#125;static void relay(int fd1,int fd2)&#123; int fd1_save,fd2_save; struct fsm_st fsm12,fsm21; fd_set rset,wset; // 读写文件描述符集合 fd1_save = fcntl(fd1,F_GETFL); fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK); fd2_save = fcntl(fd2,F_GETFL); fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK); fsm12.state = STATE_R; fsm12.sfd = fd1; fsm12.dfd = fd2; fsm21.state = STATE_R; fsm21.sfd = fd2; fsm21.dfd = fd1; while(fsm12.state != STATE_T || fsm21.state != STATE_T) &#123; //布置监视任务 FD_ZERO(&amp;rset); FD_ZERO(&amp;wset); // 读态监视输入文件描述符；写态监视输出文件描述符 if(fsm12.state == STATE_R) FD_SET(fsm12.sfd,&amp;rset); if(fsm12.state == STATE_W) FD_SET(fsm12.dfd,&amp;wset); if(fsm21.state == STATE_R) FD_SET(fsm21.sfd,&amp;rset); if(fsm21.state == STATE_W) FD_SET(fsm21.dfd,&amp;wset); if(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO)// 异常态和T态就不需要 监听了 &#123; // 以阻塞形式监视 if(select(max(fd1,fd2)+1,&amp;rset,&amp;wset,NULL,NULL) &lt; 0) &#123; if(errno == EINTR) continue; // 这个continue 跳的是大圈。 正因为select 的三个集 的 存放现场和 反馈现场用的是同一块内存空间。所以 需要跳到外围 去重置 三个集合的内存空间 perror(\"select()\"); exit(1); &#125; &#125; //查看监视结果 if( FD_ISSET(fd1,&amp;rset) || FD_ISSET(fd2,&amp;wset) || fsm12.state &gt; STATE_AUTO) // 除了有感兴趣行为之外， 异常态和T态也需要重新推状态机 fsm_driver(&amp;fsm12); if( FD_ISSET(fd2,&amp;rset) || FD_ISSET(fd1,&amp;wset) || fsm21.state &gt; STATE_AUTO) // 除了有感兴趣行为之外， 异常态和T态也需要重新推状态机 fsm_driver(&amp;fsm21); &#125; fcntl(fd1,F_SETFL,fd1_save); fcntl(fd2,F_SETFL,fd2_save);&#125; 在上面的栗子中，无论设备中是否有数据供我们读取我们都不停的推动状态机，所以导致出现了忙等的现象。 而在这个栗子中，我们在推状态机之前使用 select(2) 函数对文件描述符进行监视，如果文件描述状态没有发生变化就阻塞等待；而哪个状态机的文件描述符发生了变化就推动哪个状态机，这样就将查询法的实现改为通知法的实现了。是不是很简单呢？ 1.4.2 pollpoll(2) 出现的时间没有 select(2) 那么悠久，所以在可移植性上来说没有 select(2) 函数那么好，但是绝大多数主流 *nix 平台都支持 poll(2) 函数，它比 select(2) 要优秀很多，下面我们来了解下它。 123456789101112// poll - wait for some event on a file descriptor// 在文件描述符的基础上 等待一些事件#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout);struct pollfd &#123; int fd; /* 需要监视的文件描述符 */ short events; /* 要监视的事件 */ short revents; /* 该文件描述符发生了的事件 */&#125;; 参数列表： fds：实际上是一个数组的首地址，因为 poll(2) 可以帮助我们监视多个文件描述符，而一个文件描述放到一个 struct pollfd 结构体中，多个文件描述符就需要一个数组来存储了。 nfds：fds 这个数组的长度。在参数列表中使用数组首地址 + 长度的做法还是比较常见的。 timeout：阻塞等待的超时时间。传入 -1 则始终阻塞，不超时。0 指非阻塞 结构体中的事件可以指定下面七种事件，同时监视多个事件可以使用按位或（|）添加： 事件 描述 POLLIN 文件描述符可读 POLLPRI 可以非阻塞的读高优先级的数据 POLLOUT 文件描述符可写 POLLRDHUP 流式套接字连接点关闭，或者关闭写半连接。 POLLERR 已出错 POLLHUP 已挂断（一般指设备） POLLNVAL 参数非法 表1 poll(2) 可以监视的 7 种事件 使用 poll(2) 的步骤也很简单： 1）首先通过 struct pollfd 结构体中的 events 成员布置监视任务； 2）然后使用 poll(2) 函数进行阻塞的监视； 3）当从 poll(2) 函数返回时就可以通过 struct polfd 结构体中的 revents 成员与上面的 7 个宏中被我们选出来监视的宏进行按位与（&amp;）操作了，只要结果不为 1 就认为触发了该事件。 好了，这 3 步就是 poll(2) 函数的使用方法，简单吧。 下面我们修改一下上面的栗子，把上面用 select(2) 实现的部分修改为用 poll(2) 来实现。没有改过的地方就不贴出来了，其实也只有 relay() 函数被修改了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static void relay(int fd1,int fd2)&#123; int fd1_save,fd2_save; struct fsm_st fsm12,fsm21; struct pollfd pfd[2]; // 一共监视两个文件描述符 fd1_save = fcntl(fd1,F_GETFL); fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK); fd2_save = fcntl(fd2,F_GETFL); fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK); fsm12.state = STATE_R; fsm12.sfd = fd1; fsm12.dfd = fd2; fsm21.state = STATE_R; fsm21.sfd = fd2; fsm21.dfd = fd1; pfd[0].fd = fd1; pfd[1].fd = fd2; while(fsm12.state != STATE_T || fsm21.state != STATE_T) &#123; // 布置监视任务 pfd[0].events = 0; if(fsm12.state == STATE_R) pfd[0].events |= POLLIN; // 第一个文件描述符可读 if(fsm21.state == STATE_W) pfd[0].events |= POLLOUT; // 第一个文件描述符可写 pfd[1].events = 0; if(fsm12.state == STATE_W) pfd[1].events |= POLLOUT; // 第二个文件描述符可读 if(fsm21.state == STATE_R) pfd[1].events |= POLLIN; // 第二个文件描述符可写 // 只要是可读写状态就进行监视 if(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO) &#123; // 阻塞监视 while(poll(pfd,2,-1) &lt; 0) &#123; if(errno == EINTR) continue; perror(\"poll()\"); exit(1); &#125; &#125; // 查看监视结果 if( pfd[0].revents &amp; POLLIN || \\ pfd[1].revents &amp; POLLOUT || \\ fsm12.state &gt; STATE_AUTO) fsm_driver(&amp;fsm12); // 推状态机 if( pfd[1].revents &amp; POLLIN || \\ pfd[0].revents &amp; POLLOUT || \\ fsm21.state &gt; STATE_AUTO) fsm_driver(&amp;fsm21); // 推状态机 &#125; fcntl(fd1,F_SETFL,fd1_save); fcntl(fd2,F_SETFL,fd2_save);&#125; 1.4.3 epollepoll(7) 不是一个函数，它在 man 手册的第 7 章里，它是 Linux 为我们提供的“加强版 poll(2)”，既然是加强版，那么一定有超越 poll(2) 的地方，下面就聊一聊 epoll(7)。 在使用 poll(2) 的时候用户需要管理一个 struct pollfd 结构体或它的结构体数组，epoll(7) 则使内核为我们管理了这个结构体数组，我们只需要通过 epoll_create(2) 返回的标识引用这个结构体即可。 1.4.3.1 使用epoll的三个步骤123// epoll_create - open an epoll file descriptor#include &lt;sys/epoll.h&gt;int epoll_create(int size); 调用epoll_create创建epoll实例 调用 epoll_create(2) 时最初 size 参数给传入多少，kernel 在建立数组的时候就是多少个元素。但是这种方式不好用，所以后来改进了，只要 size 随便传入一个正整数就可以了，内核不会再根据大家传入的 size 直接作为数组的长度了，因为内核是使用 hash 来管理要监视的文件描述符的。 返回值是 epfd，从这里也可以体现出 Linux 一切皆文件的设计思想。失败时返回 -1 并设置 errno。 得到了内核为我们管理的结构体数组标识之后，接下来就可以用 epoll_ctl(2) 函数布置监视任务了。 调用epoll_ctl函数进行 epoll实例的设置 12345678910111213141516171819 // epoll_ctl - control interface for an epoll descriptor #include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);/** * epfd epoll_create创建出来的epoll实例 * op 能做什么， EPOLL_CTL_ADD ｜ EPOLL_CTL_MOD ｜ EPOLL_CTL_DEL * fd 文件描述符 * event op这个操作，针对的是 fd文件描述符的 哪个事件 * * 对 epfd 这个实例当中的 fd文件描述符 进行 EPOLL_CTL_ADD 行为*/struct epoll_event &#123; uint32_t events; /* Epoll 监视的事件，这些事件与 poll(2) 能监视的事件差不多，只是宏名前面加了个E */ epoll_data_t data; /* 用户数据，除了能保存文件描述符以外，还能让你保存一些其它有关数据，比如你这个文件描述符是嵌在一棵树上的，你在使用它的时候不知道它是树的哪个节点，则可以在布置监视任务的时候将相关的位置都保存下来。这个联合体成员就是 epoll 设计的精髓。 */&#125;; epoll_ctl(2) 的作用是要对 fd 增加或减少（op） 什么行为的监视（event）。成功返回0，失败返回 -1 并设置 errno。 op 参数可以使用下面三个宏来指定操作： 宏 描述 EPOLL_CTL_ADD 增加要监视的文件描述符 EPOLL_CTL_MOD 更改目标文件描述符的事件 EPOLL_CTL_DEL 删除要监视的文件描述符，event 参数会被忽略，可以传入 NULL。 表2 epoll_ctl(2) 函数 op 参数的选项 与 select(2) 和 poll(2) 一样， 布置完监视任务之后需要取监视结果，epoll(7) 策略使用 epoll_wait(2) 函数进行阻塞监视并返回监视结果。 使用epoll_wait函数进行监视，并返回监视结果 123456// epoll_wait - wait for an I/O event on an epoll file descriptor#include &lt;sys/epoll.h&gt;int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 参数列表： epfd：要操作的 epoll 实例； events + maxevents：共同指定了一个结构体数组，数组的起始位置和长度。其实每次使用 epoll_ctl(2) 函数添加一个文件描述符时相当于向内核为我们管理的数组中添加了一个成员，所以当我们使用同一个 struct epoll_event 变量操作多个文件描述符时，只需传入该变量的地址和操作了多少个文件描述符即可，大家看看下面的栗子就明白了。 timeout：超时等待的时间，设置为 -1 则始终阻塞监视，不超时。0 非阻塞 跟上面的栗子一样，LZ 只贴出来被修改了的 relay() 函数，其它部分不变。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 完整代码看 io/adv/epoll/relay_epoll.cstatic void relay(int fd1,int fd2)&#123; int fd1_save,fd2_save; struct fsm_st fsm12,fsm21; int epfd; struct epoll_event ev; epfd = epoll_create(10); if(epfd &lt; 0) &#123; perror(\"epfd()\"); exit(1); &#125; fd1_save = fcntl(fd1,F_GETFL); fcntl(fd1,F_SETFL,fd1_save|O_NONBLOCK); fd2_save = fcntl(fd2,F_GETFL); fcntl(fd2,F_SETFL,fd2_save|O_NONBLOCK); fsm12.state = STATE_R; fsm12.sfd = fd1; fsm12.dfd = fd2; fsm21.state = STATE_R; fsm21.sfd = fd2; fsm21.dfd = fd1; ev.events = 0; ev.data.fd = fd1; epoll_ctl(epfd,EPOLL_CTL_ADD,fd1,&amp;ev); ev.events = 0; ev.data.fd = fd2; epoll_ctl(epfd,EPOLL_CTL_ADD,fd2,&amp;ev); while(fsm12.state != STATE_T || fsm21.state != STATE_T) &#123; // 布置监视任务 ev.events = 0; ev.data.fd = fd1; if(fsm12.state == STATE_R) ev.events |= EPOLLIN; if(fsm21.state == STATE_W) ev.events |= EPOLLOUT; epoll_ctl(epfd,EPOLL_CTL_MOD,fd1,&amp;ev); ev.events = 0; ev.data.fd = fd2; if(fsm12.state == STATE_W) ev.events |= EPOLLOUT; if(fsm21.state == STATE_R) ev.events |= EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_MOD,fd2,&amp;ev); // 监视 if(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO) &#123; while(epoll_wait(epfd,&amp;ev,1,-1) &lt; 0) &#123; if(errno == EINTR) continue; perror(\"epoll_wait()\"); exit(1); &#125; &#125; // 查看监视结果 if( ev.data.fd == fd1 &amp;&amp; ev.events &amp; EPOLLIN || \\ ev.data.fd == fd2 &amp;&amp; ev.events &amp; EPOLLOUT || \\ fsm12.state &gt; STATE_AUTO) fsm_driver(&amp;fsm12); if( ev.data.fd == fd2 &amp;&amp; ev.events &amp; EPOLLIN || \\ ev.data.fd == fd1 &amp;&amp; ev.events &amp; EPOLLOUT || \\ fsm21.state &gt; STATE_AUTO) fsm_driver(&amp;fsm21); &#125; fcntl(fd1,F_SETFL,fd1_save); fcntl(fd2,F_SETFL,fd2_save); close(epfd);&#125; 4.记录锁 记录锁就是用 fcntl(2) 函数创建一个锁文件，比较麻烦，感兴趣的童鞋可以自己看看书上的介绍，在这里 LZ 就不做介绍了，我们在最后会讨论两个方便的文件锁和锁文件。 5.异步 I/O 这部分主要是说信号驱动 IO，不是真正意义上的异步 IO。 异步 I/O 分为 System V 异步 I/O 和 BSD 异步 I/O，Linux 模仿的是后者，这里我们不过多讨论了，后面 LZ 在讨论内核的博文中会继续讨论异步。 1.5 其他读写函数readv(2) 和 writev(2)123456789101112 // readv, writev - read or write data into multiple buffers#include &lt;sys/uio.h&gt;ssize_t readv(int fd, const struct iovec *iov, int iovcnt);ssize_t writev(int fd, const struct iovec *iov, int iovcnt);struct iovec &#123; void *iov_base; /* 起始地址 */ size_t iov_len; /* Number of bytes to transfer */&#125;; 这两个函数的作用就是对多个碎片的读写操作，将所有的小碎片写到文件中。 readv(2) 当没有连续的空间存储从 fd 读取或写入的数据时，将其存储在 iovcnt 个 iov 结构体中，writev(2) 的作用相同。iov 是结构体数组起始位置，iovcnt 是数组长度。 1.5.1 readn() 和 writen()这两个函数可以从本书（《APUE》第三版）的光盘中找，它们并不是什么标准库的函数，也不是系统调用，只是本书作者自己封装的函数，算是方言中的方言，作用是坚持写够 n 个字节，之前我们在讨论 IO 的博文中实现过类似的效果。 对了，天朝在引入这本书的时候貌似没有引入配套光盘，需要的童鞋可以自己去网上搜索一下。 1.6 存储映射 I/O 把某一块内存，或者是说某一个文件的存储内容映射到当前进程空间里面来。你在当前进程空间中访问一段char型的内容就如同访问该块内存或者该文件一样。它能帮助我非常好用的共享内存，非常快的共享内存。 存储映射 I/O 是十四章的小重点。 在 *nix 系统中分配内存的方法有好几种，不一定非得使用 free(3) 函数。 通过 mmap(2) 和 unmap(2) 函数可以实现一个实时的类似于 malloc(3) 和 free(3) 函数的效果，我们在前面的博文中提到过，malloc(3) 和 free(3) 实际上是以打白条的形式实现的，就是在你调用函数的时候并没有立即分配内存给你，而是在你真正使用内存的时候才分配给你的。 存储映射I/O说的就是将一个文件的一部分或全部映射到内存中，用户拿到的就是这段内存的起始位置，访问这个文件就相当于访问一个大字符串一样。 12345678910111213141516171819 // mmap, munmap - map or unmap files or devices into memory#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);/** * addr： 你把空间放到哪里，如果 addr 参数传入 NULL 则由 kernel 帮我们选择一块空间并使用返回值返回这段内存的首地址。 * * length， 要把多长的内容映射进来 * * prot： 你想对映射过来的这块内存做什么操作 * * flag： 特殊标记，特殊要求 // 匿名映射 * * fd 文件描述符 * * offset 偏移量*/int munmap(void *addr, size_t length); // 解除映射 mmap(2) 函数的作用是把 fd 这个文件从 offset 偏移位置开始把 length 字节个长度映射到 addr 这个内存位置上，如果 addr 参数传入 NULL 则由 kernel 帮我们选择一块空间并使用返回值返回这段内存的首地址。 prot 参数是操作权限，可以使用下表中的宏通过按位或（|）来组合指定 宏 含义 PROT_READ 映射区可读 PROT_WRITE 映射区可写 PROT_EXEC 映射区可执行 PROT_NONE 映射区不可访问 表3 mmap(2) 函数的 prot 参数可选项 映射区不可访问（PROT_NONE）的含义是如果我映射的内存中有一块已经有某些数据了，绝对不能让我的程序越界覆盖了，就可以把这段空间设置为映射区不可访问。 flags 参数是特殊要求，以下二者必选其一： 宏 含义 MAP_SHARED 对映射区进行存储操作相当于对原来的文件进行写入，会改变原来文件的内容。 MAP_PRIVATE 当对映射区域进行存储操作时会创建一个私有副本，所有后来再对映射区的操作都相当于操作这个副本，而不影响原来的文件。 表4 mmap(2) 函数的 flags 参数可选项 其它常用选项： MAP_ANONYMOUS：不依赖于任何文件，映射出来的内存空间会被清 0，并且 fd 和 offset 参数会被忽略，通常我们在使用的时候会把 fd 设置为 -1。 用这个参数可以很容易的做出一个最简单最好用的在具有亲缘关系的进程之间的共享内存，比后面第15章我们要讨论的共享内存还好用。后面 LZ 会给出一个小栗子让大家看看这种方式如何使用。 mmap(2) 在成功的时候返回一个指针，会指向映射的内存区域的起始地址。失败时返回 MAP_FAILED 宏定义，其实是这样定义的：(void *) -1。 首先我们写一个栗子看看如何把一个文件映射到内存中访问。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define FNAME \"/etc/services\"int main(void)&#123; int fd,i; char *str; struct stat statres; int count = 0; fd = open(FNAME,O_RDONLY); if(fd &lt; 0) &#123; perror(\"open()\"); exit(1); &#125; // 通过 stat(2) 获得文件大小 if(fstat(fd,&amp;statres) &lt; 0) &#123; perror(\"fstat()\"); exit(1); &#125; str = mmap(NULL,statres.st_size,PROT_READ,MAP_SHARED,fd,0); if(str == MAP_FAILED) &#123; perror(\"mmap()\"); exit(1); &#125; // 将文件映射到内存之后文件描述符就可以关闭了，直接访问映射的内存就相当于访问文件了。 close(fd); for(i = 0 ; i &lt; statres.st_size; i++) &#123; // 因为访问的是文本文件，所以可以把映射的内存看作是一个大字符串处理 if(str[i] == 'a') &#123; count++; &#125; &#125; printf(\"count = %d\\n\",count); // 用完了别忘了解除映射，不然会造成内存泄漏！ munmap(str,statres.st_size); exit(0);&#125; 这段代码会统计 /etc/services 文件中包含多少个字符 ‘a’。 mmap(2) 的返回值是 void* 类型的，这是一种百搭的类型，在映射了不同的东西的情况下我们可以使用不同的指针来接收，这样就能用不同的方式访问这段内存空间了。上面这个文件是文本文件，所以我们可以使用 char* 来接收它的返回值，这样就将整个文件看作是一个大字符串来访问了。 这个还是比较常规的用法，下面我们看一下如何使用 mmap(2) 函数制作一个好用的共享内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 父读子写#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#define MEMSIZE 1024int main(void)&#123; char *str; pid_t pid; // 这里在 flags 中添加 MAP_ANONYMOUS，为制作共享内存做准备 str = mmap(NULL,MEMSIZE,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0); if(str == MAP_FAILED) &#123; perror(\"mmap()\"); exit(1); &#125; // 创建子进程，父子进程使用共享内存进行通信 pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // 子进程向共享内存中写入数据 &#123; strcpy(str,\"Hello!\"); munmap(str,MEMSIZE); // 注意，虽然共享内存是在 fork(2) 之前创建的，但是 fork(2) 的时候子进程也拷贝了一份，所以子进程使用完毕之后也要解除映射 exit(0); &#125; else // 父进程从共享内存中读取子进程写入的数据 &#123; wait(NULL); // 保障子进程先运行起来，因为就算父进程先运行了也会在这里阻塞等待 puts(str); // 把从共享内存中读取出来的数据打印出来 munmap(str,MEMSIZE); // 不要忘记解除映射 exit(0); &#125; exit(0);&#125; 共享内存是进程间通信的一种手段，就是在内存中开辟一块空间让多个进程之间可以共同访问这段空间，从而实现进程之间的数据交换。在后面讨论 IPC 的博文中我们还会详细介绍共享内存，不过用 mmap(2) 制作的共享内存比后面介绍的共享内存使用起来更简便一些。 大家自己运行一下这段代码，可以看到父进程打印出了子进程写入的“Hello”字符串，说明这段内存确实是在父子进程之间共享的。 大家在使用的时候不要忘记父子进程最后都要做解除映射的动作。 从这个栗子中我们也可以看出来，这种共享内存的方式只适合在具有亲缘关系的进程之间使用，没有亲缘关系的进程是无法获得指向同一个映射内存空间的指针的。 1.7 文件锁 文件为何要锁，建立一个下载任务，首先建一个跟目标大小相似的空洞文件。然后分块去多线程并发。每个线程负责一块。可以当前写的这一块如何避免别人没有过来发生竞争。就需要把这块内容加锁。加锁之后写文件就没问题了。 fcntl()flock()lockf() 1.7.1 flock(2) 和 lockf(3) 函数1234567891011// lockf - apply, test or remove a POSIX lock on an open file#include &lt;unistd.h&gt;int lockf(int fd, int cmd, off_t len);//flock - apply or remove an advisory lock on an open file#include &lt;sys/file.h&gt;int flock(int fd, int operation); 这两个函数可以实现好用的文件加锁。 我们这里只介绍 lockf(2) 函数，flock(2) 函数也差不多，都很简单，所以大家可以自己去查阅 man 手册。 lockf(3) 可以给文件进行局部加锁，简单来说就是从当前位置锁住 len 个字节。 参数列表： fd：要加锁的文件描述符； cmd：具体的命令见下表； 宏 说明 F_LOCK 为文件的一段加锁，如果已经被加锁就阻塞等待，如果两个锁要锁定的部分有交集就会被合并，文件关闭时或进程退出时会自动释放，不会被子进程继承。 F_TLOCK 与 F_LOCK 差不多，不过是尝试加锁，非阻塞。 F_ULOCK 解锁，如果是被合并的锁会分裂。 F_TEST 测试锁，如果文件中被测试的部分没有锁定或者是调用进程持有锁就返回 0；如果是其它进程持有锁就返回 -1，并且 errno 设置为 EAGAIN 或 EACCES。 图5 lockf(3) 函数的 cmd 参数可选值 len：要锁定的长度，如果为 0 表示文件有多长锁多长，从当前位置一直锁到文件结尾。 下面我们使用 lockf(3) 函数写一个栗子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#define PROCNUM 20#define FNAME \"./p\"#define LINESIZE 1024static void func_add (void)&#123; FILE *fp; int fd; char linebuf[LINESIZE]; fp = fopen(FNAME, \"r+\"); if(fp == NULL) &#123; perror(\"fopen()\"); exit(1); &#125; fd = fileno(fp); // fileno 从file流中把文件描述符挑出来 lockf(fd, F_LOCK, 0); // 写0 指的是文件有多长 锁多长 fgets(linebuf,LINESIZE,fp); // 将读取的内容放进 linebuf中 fseek(fp, 0, SEEK_SET); // 文件位置指针 指回去 fprintf(fp,\"%d\\n\", atoi(linebuf)+1); fflush(fp);// 因为文件是全缓冲模式，所以为了保证全部写到文件中去。这里需要刷新一下缓冲区 lockf(fd, F_ULOCK, 0); fclose(fp); return;&#125;int main()&#123; int i,err; pid_t pid; for(i=0;i&lt;PROCNUM;i++) &#123; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // 子进程 &#123; func_add(); exit(0); &#125; else // 父进程 &#123; &#125; &#125;; for(i =0; i&lt;PROCNUM; i++) &#123; wait(NULL); &#125; exit(0);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 博客版#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;sys/types.h&gt;#define PROCNUM 20#define FNAME \"/tmp/out\"#define BUFSIZE 1024static void func_add()&#123; FILE *fp; int fd; char buf[BUFSIZE]; fp = fopen(FNAME,\"r+\"); if(fp == NULL) &#123; perror(\"fopen()\"); exit(1); &#125; fd = fileno(fp); if(fd &lt; 0) &#123; perror(\"fd\"); exit(1); &#125; // 使用之前先锁定 lockf(fd,F_LOCK,0); fgets(buf,BUFSIZE,fp); rewind(fp); // 把文件位置指针定位到文件首 sleep(1); // 放大竞争 fprintf(fp,\"%d\\n\",atoi(buf)+1); fflush(fp); // 使用之后释放锁 lockf(fd,F_ULOCK,0); fclose(fp); return ;&#125;int main(void)&#123; int i; pid_t pid; for(i = 0 ; i &lt; PROCNUM ; i++) &#123; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) // child &#123; func_add(); exit(0); &#125; &#125; for(i = 0 ; i &lt; PROCNUM ; i++) wait(NULL); exit(0);&#125; 还是用我么以前的栗子改的，大家还记得以前写过一个栗子，让 20 个进程同时向 1 个文件中累加数字吗。 在这里每个进程在读写文件之前先加锁，如果加不上就等待别人释放锁再加。如果加上了锁就读出文件中当前的值，+1 之后再写回到文件中。 获得锁之后 sleep(1) 是为了放大竞争，让进程之间一定要出现竞争的现象，便于我们分析调试。 在调试并发的程序时，如果有些问题很难复现，那么可以通过加长每一个并发单位的执行时间来强制它们出现竞争的情况，这样可以让我们更容易的分析问题。 图3 flock(2) 和 lockf(3) 的缺点 文件锁还有一个机制是把一个文件当作锁，比如要操作的是 /tmp/out 文件，那么父进程可以先创建一个 /tmp/lcok文件，然后再创建 20 个子进程同时对 /tmp/out 文件进行读写，但是子进程必须先锁定 /tmp/lock 文件才能操作 /tmp/out 文件，没抢到锁文件的需要等待其它进程解锁再抢锁，等父进程为所有的子进程收尸之后再关闭/tmp/lock，/tmp/lock 这个文件就被称为锁文件。 高级 IO 部分大概就这些内容了。","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"进程关系与守护进程","slug":"apue-5","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:27.002Z","comments":true,"path":"2020/12/16/apue-5/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-5/","excerpt":"","text":"进程关系与守护进程1.1 终端真正意义上的终端是“笨设备”，只能接收命令的输入并返回结果。你问它 1+1=? 它也不知道，它只能把你的问题传给计算机，再把计算机返回的结果显示给你。 它出现在计算机既昂贵又庞大的年代。那时候的计算机昂贵到了只有一部分公司买得起、另一部分公司买不起，而且有些公司只能买一台，买第二台就要破产了的程度。 所以这么昂贵的设备如果只能给一个人使用太浪费了，于是为了让计算机可以被多人使用，就出现了终端这种设备。 接下来我们简单的聊聊 Linux 是如何使用户登录的。 图1 Linux 用户登录过程 如图1 所示，内核自举时创建 1 号 init 进程，init 对每一个终端执行 fork(2) + exec(3) + getty(1) 命令，getty(1) 命令的作用是要求用户输入用户名。 等待用户输入完成用户名后，getty(1) 会 exec(3) + login(1)。 login(1) 命令首先根据用户名通过 getpwnam(3) 函数得到用户的口令文件登录项，然后调用 getpass(3) 函数以屏蔽回显的形式获得用户的密码，最后再通过 crypt(3) 函数将加密后的用户口令与阴影口令文件用户登录项中的 pw_passwd 字段相比较，认证失败几次之后就会回到上图的第一步，init 进程将重新执行 fork(2) + exec(3) + getty(1)。 如果认证成功则启动用户登录 shell，并使用 chown(2) 更改当前登录终端的所有权，使登录用户成为它的所有者。登录之前的步骤都是 root 身份，所以真正用户权限被降下来就是在这个时候发生的。 当然 login 要做的事情不仅仅只有这点儿，它还要做许多其它需要为用户初始化的事情。 说句题外话，大家注意到了没有，如果获取用户名或密码的时候函数的编写者敢使用类似 scanf(3) 这样的函数读取用户输入，则很容易遭受缓冲区溢出攻击。 1.2 会话(Session)一次成功的终端登录就是一个会话。现在一次 shell 的成功登录，相当于那时候终端的成功登录。会话相当于是进程组的容器，它能承载一个或多个进程组。 1.3 进程组 进程组用来承载进程，一个进程组中有一个或多个进程，它是一个或多个进程的集合（也可以看作是容器）。一个进程不但拥有唯一的 PID，同时也属于一个进程组。一个进程最少有一个线程在运行， 如何产生一个进程组呢？很简单： 12# 使用管道可以用一条命令产生一个进程组(多个进程)。ls | more # 把第一个进程的标准输出作为第二个进程的标准输入 进程组分为前台进程组和后台进程组一个会话中只能有一个前台进程组，也可以没有前台进程组。 终端设备(如键盘)只能与前台进程通讯，不能与后台进程通讯，根据约定，如果终端设备与一个后台进程关联，就会杀掉这个后台进程。 什么是前台进程组呢？比如你正在使用 tar 命令进行打包的时候是无法再输入其它命令的。如果 tar 命令执行的时间很长，我们就会在命令后面添加一个 &amp; 参数，把它放到后台去运行。 ps(1) 命令的 SID(Session ID)列 就是程序运行的会话 ID。 进程是先出现的，后来人们发现进程可以拆分为多个小任务分别执行，于是便出现了线程的概念，这个到后面线程的章节会详细讨论。 如今进程已经退化为容器了，它的存在就是为了承载线程。PID 看似是进程号，实际上是线程在消耗它。处理器在处理当前的调度的时候，其实是以线程为单位来进行调度的。所以多线程的并发要比多进程并发更加规范。因为多进程的并发是先成为事实标准，后来有标准化的。多线程不同，它是现有标准化，再有标准实现的。 进程和线程只是我们的说法，内核中只能看到线程，内核所谓的进程管理其实就是线程管理，内核永远以线程为单位执行任务。 总结来说： 会话用来承载进程组，进程组用来承载进程，进程用来承载线程。 第九章了解这几个概念就差不多了，还记得我们前面提到的 myshell 吗，用 fork(2) + exec(3) + wait(2) 来实现一个可以执行外部命令的 shell。如果你想实现一个支持内部命令的 shell 那么可以仔细学习一下第九章的内容，shell 内部命令处理的主要知识点都在第九章。 setsid(2) 123//setsid - create session and set process group ID#include &lt;unistd.h&gt;pid_t setsid(void); getpgrp(); 12345pid_t getpgrp(void); // 返回当前进程所在进程组的idpid_t getpgrp(pid_t pid);// 查看一个指定进程所在进程组的idpid_t getpgid(pid_t pid); // 系统调用 // 获取某一个进程的 groupIdint setpgid(pid_t pid, pid_t pgid);// 把指定进程放到 指定的进程组中 创建一个会话并设置进程组的ID。这个函数是我们在第 9 章最有价值的函数，没有这个函数，我们后面就无法创建守护进程。 调用者不能是进程组组长，调用者在调用之后自动变为新进程组组长，并且脱离控制终端，进程 ID 将被设为进程组 ID 和会话 ID，所以守护进程通常 PID、PGID、SID 是相同的。通常的用法是父进程 fork(2) 一个子进程，然后子进程调用 setsid(2) 将自己变成守护进程，父进程退出即可。 1.4 守护进程 常常在系统自举时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以是在后台运行的。 守护进程的特点： 1）脱离控制终端，ps(1) axj tty 为问号(?)。 2）是进程组的 leader，也就是 PID 和 PGID 相同。 3）通常没有父进程，由 1 号 init 接管。 4）创建了一个新会话，是 session 的 leader，所以 PID 与 SID 相同。 使用 ps(1) axj 命令查看，PID、PGID、SID 相同的进程就是守护进程。 守护进程也可以使用标准输出，但是不符合常理了，因为守护进程没有控制终端，所以守护进程一般会关闭或重定向标准输入输出流。 写守护进程的时候我们会切换工作路径，把它切换到一个一定会存在的路径，比如 /。因为假设你的守护进程是在一个可卸载设备(如U盘)上被启动的，如果不修改工作路径，该设备无法被卸载。 调用 umask(2) 是为了将文件模式创建掩码设置为一个已知值，因为通过继承得来的掩码可能会被设置为拒绝某些权限，如果守护进程中需要这些权限则要设置它。 123456789$ ps axj# 守护进程的特点# ppid 是1# pid pgid sid 相同# tty ？ 脱离控制终端PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND1 2109 2109 2109 ? -1 Ss 0 0:00 /usr/sbin/sshd 对于书上的栗子，有两点要吐槽： 1）SIGHUP 信号用于通知服务进程软重启，比如修改了某服务的配置文件之后可以通过给服务进程发 SIGHUP 信号使它重新读取配置文件，所以如果没有特殊要求不必忽略该信号。 2）如果没有特殊要求，不必关闭所有的文件描述符，仅关闭标准输入、标准输出和标注错误即可。 1.4.1 实现一个守护进程（信号章节结束后补充完整）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define FNAME \"/tmp/out\"static int daemonize(void)&#123; pid_t pid; pid = fork(); int fd; if(pid &lt; 0) &#123; perror(\"fork()\"); return -1; &#125; if(pid &gt; 0) // parent &#123; exit(0); &#125; fd = open(\"/dev/null\", O_RDWR); if(fd &lt; 0) &#123; perror(\"open()\"); return -1; &#125; dup2(fd, 0); dup2(fd, 1); dup2(fd, 2); if(fd&gt;2) close(fd); setsid(); chdir(\"/\");// umask(0) return 0;&#125;int main()&#123; FILE *fp; int i; if( daemonize()) exit(1); fp = fopen(FNAME, \"w\"); if(fp == NULL) &#123; perror(\"fopen\"); exit(1); &#125; for(i=0; ;i++) &#123; fprintf(fp, \"%d\\n\", i); // 守护进程没办法使用标准输入输出了，应该放到系统日志里面了 fflush(fp); sleep(1); &#125; exit(0);&#125; 1234567891011121314tail -f /tmp/out # 动态查看该文件# 529# 530# 531# 532# 533# 534# 535# 536# 537# 。# 。# 。 1.4.2 如何杀死一个守护进程1kill pid 1.5 系统日志 每个程序都有必要写系统日志，但是写系统日志的权限没办法交给所有人。 守护进程不应使用标准输出，那么当守护进程需要记录一些事件或者是错误的时候怎么办呢？那就要采用系统日志了。 系统日志一般保存在 /var/log/ 目录下，但是这个目录下的日志文件权限几乎都是只有 root 才能读写，那么普通用户的日志如何写入呢？这就需要借助系统日志函数来写日志了。 1.5.1 syslogdroot 用户授权给 syslogd 服务专门写日志，然后其它程序都需要通过封装好的一系列函数调用 syslogd 服务来记录日志。这样就提高了日志的安全性了，可以防止日志文件被非法篡改。 123ps axj | grep \"syslogd\"1 1203 1203 1203 ? -1 Ssl 0 0:11 /usr/sbin/rsyslogd -n 12345// closelog, openlog, syslog - send messages to the system logger #include &lt;syslog.h&gt; void openlog(const char *ident, int option, int facility); void syslog(int priority, const char *format, ...); void closelog(void); openlog(3) 函数并非是打开日志文件，而是与 syslogd 服务建立链接，表示当前进程要写日志。 参数列表： ident：表明自己的身份，由程序员自行指定，写什么都行。 option：要在日志中附加什么内容，多个选项用按位或链接。LOG_PID 是附加 PID，这个是最常用的。 facility：消息来源。一般只能指定一个。 消息来源 含义 LOG_CRON 消息来自定时任务 LOG_DAEMON 消息来自守护进程 LOG_FTP 消息来自 FTP 服务 LOG_KERN 消息来自内核 LOG_USER 默认，常规用户级别消息 表1 facility 参数的常见需选项 syslog(3) 函数用于提交日志内容，参数列表： priority：优先级。详见下表： 级别 含义 LOG_EMERG 「严重」导致系统不可用的问题 LOG_ALERT 「严重」必须立即处理的情况 LOG_CRIT 「严重」临界条件 LOG_ERR 「严重」错误 LOG_WARNING 警告 LOG_NOTICE 正常 LOG_INFO 信息 LOG_DEBUG 调试 表2 日志优先级 以 LOG_ERR 为分界线，如果遇到了程序无法继续运行的问题，要报 LOG_ERR 以上的级别（包括 LOG_ERR）。 如果遇到的问题不会影响程序继续运行，报 LOG_ERR 以下级别的就可以了。 日志太多肯定对磁盘空间的要求就比较高，而且无用的日志太多会影响日志审计。日志文件中会记录哪些级别的日志是在配置文件中配置的，默认的情况是 LOG_DEBUG 以上级别的日志都会被记录。 format：类似于 printf(3) 函数的格式化字符串。注意不要使用转义字符 \\n，否则日志中会记录一个字符串”\\n”而不是记录一个换行符。 …：format 中占位符的参数。 closelog(3) 表示日志写入结束。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;syslog.h&gt;#include &lt;errno.h&gt;#define FNAME \"/tmp/out\"static int daemonize(void)&#123; pid_t pid; pid = fork(); int fd; if(pid &lt; 0) &#123; return -1; &#125; if(pid &gt; 0) // parent &#123; exit(0); &#125; fd = open(\"/dev/null\", O_RDWR); if(fd &lt; 0) &#123; return -1; &#125; dup2(fd, 0); dup2(fd, 1); dup2(fd, 2); if(fd&gt;2) close(fd); setsid(); chdir(\"/\");// umask(0) return 0;&#125;int main()&#123; FILE *fp; int i; openlog(\"mydaemon\", LOG_PID, LOG_DAEMON); if( daemonize()) &#123; syslog(LOG_ERR, \"daemonize() failed!\"); exit(1); &#125; else &#123; syslog(LOG_INFO, \"daemonize() successed\"); // 结尾写 \\n 会被当作文本 &#125; fp = fopen(FNAME, \"w\"); if(fp == NULL) &#123; syslog(LOG_ERR, \"fopen(): %s\", strerror(errno)); exit(1); &#125; syslog(LOG_INFO, \"%s was opend.\", FNAME); for(i=0; ;i++) &#123; fprintf(fp, \"%d\\n\", i); fflush(fp); syslog(LOG_DEBUG, \"%d is printed.\", i); sleep(1); &#125; // 目前执行不到下面这两句话，将来会用新的机制解决这个问题。把当前进程的异常终止改变为正常终止 fclose(fp); closelog(); exit(0);&#125; 1234567891011$ tail /var/log/messagesJul 14 21:06:13 localhost su: (to root) hy on pts/1Jul 14 21:06:13 localhost dbus[716]: [system] Activating service name='org.freedesktop.problems' (using servicehelper)Jul 14 21:06:13 localhost dbus[716]: [system] Successfully activated service 'org.freedesktop.problems'Jul 14 21:06:17 localhost mydaemon[39494]: daemonize() successedJul 14 21:06:17 localhost mydaemon[39494]: /tmp/out was opend.Jul 14 21:06:44 localhost chronyd[765]: Selected source 119.28.206.193# 只有两句被写进系统日志，原因在于 系统日志会根据文件优先级来决定要不要写进去。默认最少要是LOG_INFO以上才会被写进去。 这部分是可配置的， 配置文件好像在 /etc/sysconfig/rsyslog 1.5.2 单实例守护进程123456$ service vsftpd start # 确定$ service vsftpd start # 失败ps axj | grep \"ftp\"1 7204 7204 7204 ? -1 Ss 0 0:00 /usr/sbin/vsftpd 有些守护进程需要在同一时间只能有一个实例在运行，它们称为单实例守护进程。它们在启动的时候会在 /var/run 下面创建一个进程锁文件，守护进程启动的时候会先判断这个锁文件是否存在，如果已存在就报错并退出，如果不存在就继续运行并创建一个锁文件，退出的时候再删除它。 123$ cat /var/run/sshd.pid109 守护进程如果想要开机自动启动，可以配置到自动启动脚本中：/etc/rc.d/rc.local","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"线程控制","slug":"apue-8","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:41.420Z","comments":true,"path":"2020/12/16/apue-8/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-8/","excerpt":"","text":"线程控制 之前我们在创建线程的时候都是使用的默认属性，本章主要讨论的是自定义线程的属性。使用默认属性基本上能解决掉遇到的大部分问题，所以自定义属性在实际项目中用得比较少。 1.1 线程属性《APUE》第三版 P341 表中的属性可以用来限定一个进程能创建线程的最大数量，但是限定线程数量的宏不必太当真，因为在上一篇博文中我们说过了一个线程能创建的线程的数量是受很多因素影响的，并非一定是以这几个宏值为准的。 1int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); 线程属性使用 pthread_attr_t 类型表示。 123456#include &lt;pthread.h&gt;int pthread_attr_init(pthread_attr_t *attr);int pthread_attr_destroy(pthread_attr_t *attr);int pthread_attr_setstacksize();// 见手册 man pthread_attr_init 的 see also 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;static void *func(void *p)&#123; puts(\"Thread is working.\"); pthread_exit(NULL);&#125;int main()&#123; pthread_t tid; int err, i; pthread_attr_t attr; pthread_attr_init(&amp;attr); // 修改每个线程的栈大小 pthread_attr_setstacksize(&amp;attr,1024*1024); for(i = 0 ; ; i++) &#123; // 测试当前进程能创建多少个线程 err = pthread_create(&amp;tid,&amp;attr,func,NULL); if(err) &#123; fprintf(stderr,\"pthread_create():%s\\n\",strerror(err)); break; &#125; &#125; printf(\"i = %d\\n\",i); pthread_attr_destroy(&amp;attr); exit(0); &#125; 上面的栗子就是通过线程的属性修改了为每个线程分配的栈空间大小，这样创建出来的线程数量与默认的就不同了。 线程属性使用 pthread_attr_init(3) 函数初始化，用完之后使用 pthread_attr_destroy(3) 函数销毁。 线程属性不仅可以设定线程的栈空间大小，还可以创建分离的线程等等。 1.1.1 互斥量属性12int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr); 互斥量属性使用 pthread_mutexattr_t 类型表示，与线程属性一样，使用之前要初始化，使用完毕要销毁。 pthread_mutexattr_init(3) 函数用于初始化互斥量的属性，用法跟线程的属性很相似。 1.1.1.1 互斥量属性常用函数pthread_mutexattr_init();pthread_mutexattr_destroy();pthread_mutexattr_getpshared();pthread_mutexattr_setpshared(); 1234567// pthread_mutexattr_getpshared, pthread_mutexattr_setpshared - get and set the process-shared attribute#include &lt;pthread.h&gt;int pthread_mutexattr_getpshared(const pthread_mutexattr_t * restrict attr, int *restrict pshared);int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared); 函数名称里面的 p 是指 process，这两个函数的作用是设定线程的属性是否可以跨进程使用。这条有点乱是吧，线程的属性怎么能跨进程使用呢？别急，我们先看看 clone(2) 函数。 12345678// clone, __clone2 - create a child process#define _GNU_SOURCE#include &lt;sched.h&gt;int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ... /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ ); clone(2) 进程的 flags 如果设置了 CLONE_FILES 则父子进程共享文件描述符表，正常情况文件描述符表是线程之间共享的，因为多线程是运行在同一个进程的地址空间之内的。 虽然 clone(2) 函数的描述是创建子进程，但实际上如果将 flags 属性设置得极端分离(各种资源都独享)，相当于创建了一个子进程； 而如果 flags 属性设置得极端近似(各种资源都共享)，则相当于创建了兄弟线程。所以对于内核来讲并没有进程这个概念，只有线程的概念。你创建出来的到底是进程还是线程，并不影响内核进行调度。 如果需要创建一个“东西”与当前的线程既共享一部分资源，又独占一部分资源，就可以使用 clone(2) 函数创建一个既不是线程也不是进程的“东西”，因为对内核来说进程和线程本来就是模糊的概念。 现在能理解为什么上面说 pthread_mutexattr_setpshared(3) 函数的作用是设定线程的属性是否可以跨进程使用了吧？ 互斥量分为四种，不同的互斥量在遇到不同的情况时效果是不同的，《APUE》第三版 P347 有图12-5 说明了这个现象，LZ 把它照搬到这里。 互斥量类型 没有解锁时重新加锁 不占用时解锁 在已解锁时解锁 PTHREAD_MUTEX_NORMAL（常规） 死锁 未定义 未定义 PTHREAD_MUTEX_ERRORCHECK（检错） 返回错误 返回错误 返回错误 PTHREAD_MUTEX_RECURSIVE（递归） 允许 返回错误 返回错误 PTHREAD_MUTEX_DEFAULT（默认，我们平时使用的就是这个） 未定义 未定义 未定义 表1 互斥量类型行为 LZ 解释一下表头上的描述是什么意思： 1）没有解锁时重新加锁：当前 mutex 已 lock，再次 lock 的情况； 2）不占用时解锁：他人锁定由你解锁的情况； 3）在已解锁时解锁：当前 mutex 已 unlock，再次 unlock 的情况； 1.1.2 条件变量的属性1.1.2.1 条件变量常见属性pthread_condattr_init();pthread_condattr_destroy(); 1.1.3 读写锁属性1.2 重入第一次见到重入是在信号阶段是吧。 如果一个函数在相同的时间点可以被多个线程安全地调用，就称该函数是线程安全的。 POSIX 标准要求，在线程标准制定之后，所有的库必须支持线程安全，如果不支持线程安全需要在函数名添加 _unlocked 后缀，或发布一个支持线程安全的函数，函数名要添加 _r 后缀。 我们在 man 手册中已经见过很多带有 _r 后缀的函数了。 12345678// 拿puts举例puts('aaaaa');puts('bbbbb');puts('ccccc');// bbbbbcccccaaaaa// 绝对不可能出现 abccbabac... 之类的 为什么看不到 abccbabac, 是因为puts函数有这样的功能， 先锁住缓冲区，把内容填充进去，然后unlock。当三个puts几乎同时调用的时候。就看谁先抢到缓冲区。 1.2.1 多线程IO1.2.2 线程与信号1.2.3 线程与fork4.线程特定数据 就是为了某些数据支持多线程并发而做的改进。最典型的就是 errno，errno 最初是全局变量，现在早已变成宏定义了。 我们把 errno 预编译一下，看看它的庐山真面目。 12#include &lt;errno.h&gt;errno; 12345$ gcc -E errno.c# 2 \"errno.c\" 2 (*__errno_location ());$ 1.3 线程的取消在上一篇博文中我们说过，pthread_cancel(3) 函数只是提出取消请求，并不能强制取消线程。 线程的取消分为两种情况：允许取消 或 不允许取消。 pthread_cancel(3) 提出取消请求后，是否允许取消是由被请求取消的线程自己决定的。 不允许取消没什么好说的，我们说说允许取消。 允许取消分为两种情况：异步 cancel 和 推迟 cancel（默认） 1）异步 cancel：是内核的操作方式，这里不做解释。 2）推迟 cancel：推迟到取消点再响应取消操作。取消点其实就是一个函数，收到取消请求时取消点的代码不会执行。 《APUE》第三版 P362 图12-14 都是可能导致阻塞的系统调用，它们都是 POSIX 定义的一定存在的取消点。P363 图12-15 是 POSIX 定义的可选取消点，这些函数实际是否为取消点要看平台具体的实现。 为什么要采用推迟取消的策略，而不是收到请求在任何地方都立即取消呢？我们先举个栗子说明这个问题，大家请看下面的伪代码： 123456789101112131415161718192021thr_func()&#123; p = malloc(); --------------------------&gt;收到了一个取消请求 --------------------------&gt;pthread_cleanup_push();-&gt;free(p); // 不是取消点，继续执行fd1 = open(); // 是取消点，在取消点执行之前响应取消动作 --------------------------&gt;pthread_cleanup_push();-&gt;close(fd1);fd2 = open(); --------------------------&gt;pthread_cleanup_push();-&gt;close(fd2);pthread_exit();&#125; 在线程执行函数运行的任何时候都可能收到取消请求，假设上面的函数刚刚使用 malloc(3) 函数动态分配了一段内存，还没来得及挂钩子函数的时候就收到了一个取消请求，如果立即响应这个取消请求就会导致内存泄漏。而挂载钩子函数的宏 pthread_cleanup_push 不是取消点，所以会推迟这个取消请求继续工作。等它把钩子函数挂载完毕之后继续运行来到 open(2) 函数，由于 open(2) 函数时有效的取消点，所以响应了这个取消请求，线程被取消并且通过钩子函数释放了上面 malloc(3) 所申请的空间。这就是推迟取消最明显的作用。 pthread_setcancelstate(3) 函数的作用就是修改线程的可取消状态，可以将线程设置为可取消的或不可取消的。 pthread_setcanceltype(3) 函数用来修改取消类型，也就是可以选择 异步 cancel 和 推迟 cancel。 pthread_testcancel(3) 函数的作用是人为放置取消点。假如某个线程一启动就疯狂的做数学运算10分钟，没有调用任何函数，则这个线程无法响应取消，为了使这个线程可以响应取消就可以通过这个函数人为放置取消点。 1.3.1 线程和信号图1 线程级别的信号位图 在前面讨论信号的博文中，LZ 给大家画过一张信号处理过程的草图，在那幅图中简单的把一个线程的标准信号画成了两个位图。而实际上每个线程级别都持有一个 mask 位图和一个 padding 位图，每个进程级别持有一个 padding 位图而没有 mask 位图。从内核态回到用户态之前，当前线程先用自己的 mask 位图与进程级别的 padding 做按位与（&amp;）运算，如果有信号就要去处理；然后再用自己的 mask 位图与自己的 padding 位图做按位与运算，再处理相应的信号。 所以其实是哪个线程被调度，就由哪个线程响应进程级别的信号。 由此可见，线程之间也是可以互相发信号的。 1234567// pthread_kill - send a signal to a thread#include &lt;signal.h&gt;int pthread_kill(pthread_t thread, int sig);// Compile and link with -pthread. pthread_kill(3) 函数的作用就是在线程阶段发信号，thread 表示给哪个线程发送信号，sig 是发送哪个信号。 由于这个函数使用起来很简单，这里 LZ 就不把栗子贴出来了，大家自己动手写写试试吧。 pthread_sigmask(3) 函数的作用时人为的干预线程级别的 mask 位图。与 sigsetmask(3) 函数很像，大家自己动手试试吧。 1.3.2 线程和 fork这一小节主要说的是 fork(2) 在不同平台上实现有歧义。 在fork的发展过程中主要有两大阵营，一大阵营使用写时拷贝技术，另一大阵营使用类似 vfork(2) 的策略。 这两种策略在前面我们讨论进程关系的博文中都讨论过，感兴趣的童鞋可以自己看看书上的描述，这里就不做太多的介绍了。 1.3.3 线程和 I/O这一小节主要就是介绍了下 pread(2) 和 pwrite(2) 函数，这两个函数实际当中用得并不多，感兴趣的童鞋自己看看书上的介绍或者看看 man 手册里的说明吧，这里不做过多的讨论了。如果有什么问题可以在评论中留言。 到这里 POSIX 标准的线程就介绍完了。*nix 平台线程的标准不只有 POSIX 一家，还有像 OpenMP 等标准也定义了不同的线程实现方式。 1.3.4 OpenMP 标准我们使用 OpenMP 标准写一个 Hello World 程序。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;omp.h&gt;int main()&#123; #pragma omp parallel sections &#123; #pragma omp section printf(\"[%d]:Hello\\n\",omp_get_thread_num()); #pragma omp section printf(\"[%d]:World\\n\",omp_get_thread_num()); &#125; exit(0);&#125; OpenMP 标准的多线程就是使用 # 这种预处理标签实现的，使用 GCC 编译的时候需要加 -fopenmp 参数。 123456789$ make hellocc -fopenmp -Wall hello.c -o hello$ ./hello[0]:Hello[1]:World$ ./hello[1]:World[0]:Hello$ 从上面的运行结果可以看出来，线程已经创建，并且已经发生了竞争。 GCC 从 4.0 以上的版本开始支持 OpenMP 标准。 由于 OpenMP 标准不是 《APUE》里面介绍的，所以我们这里就不做过多的探讨了，感兴趣的小伙伴们可以去 http://www.openmp.org 了解更多内容","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"gitlab 使用","slug":"gitlab-使用","date":"2020-12-16T06:52:39.000Z","updated":"2020-12-18T05:43:13.922Z","comments":true,"path":"2020/12/16/gitlab-使用/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"软件开发阶段 软件开发十个阶段在gitlab中对应的管理方式方法 IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了Mattermost 它类似一个聊天工具。 ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在工单追踪器issue tracker中帮助你去提升这个点子。 PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用工单看板Issue Board。 CODE： 现在，当一切准备就绪，我们可以开始写代码了。 COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。 TEST： 通过GitLab CI，我们可以运行脚本来构建和测试我们的应用。 REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行代码复审code review以及批准。 STAGING：： 预发布环境。 PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了。 FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 Cycle Analytics来对当前项目中关键的部分进行的反馈 issue 和 milestone milestone里程碑，用来标识\b阶段性目标， 对目标进行细化，化整为零一个个的issues，然后根据每个issues的紧急程度选择性的完成。等所有issues解决完之后 就标志着阶段性目标已完成； 使用方法 把实际问题转化为issue，这些问题可以标记为正在解决和计划解决； milestone对应着阶段性项目计划，然后细分为多个issues，而且可以指定完成时间，gitlab会自动生成完成进度情况概略图。 issues也可以是一个建议，共给大家一起讨论； milestone 和issue建立时我们通常可以对问题进行简单描述，并且记录问题的解决过程，包括他人提出的疑问也可以在这里记录，后期可以随时查看； 创建milestone 可以在项目开始前创建milestone，后面建issues时关联它，也可以先建issues，后期由项目负责人建milestone，然后把所有issues关联过来； 创建一个名字 简单描述，简述创建的原因，这个里程碑最终的目的，编辑的时候可以直接贴图，也可以添加附件（支持markdown格式，可以预览） 指定计划的完成时间； 新建issues 一个issues表示一个功能、一个bug、一个建议; 新建议题很简单，标题+描述+计划时间+指定人+里程碑，里程碑一定要指定一下，还可以加标签。 功能：里程碑的细分，尽量小，方便merger时的代码审核； bug：解决程序中存在的某些问题； 建议：可以作为一个讨论交流区，也可以实现它; 一个issues 对应一个指定人，一个git 分支；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"socket","slug":"apue-11","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:55.714Z","comments":true,"path":"2020/12/16/apue-11/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-11/","excerpt":"","text":"socket 如图所示，socket 可以理解为中间层。底层是若干不同的协议来完成协议族的指定，上层可以是不同的网络实现方式（流失传输，报式传输等等）。在不同的协议族当中对于这些不同的网络实现方式都会有支持，比如IPv4既能支持流失套接字，也能支持报式套接字等等。这样的话，下层换一种协议，上层换一种实现方式，程序员都要新写一套代码。 解决方法： 借助一种机制，把下面用什么协议族，上面用什么实现方式指定起来，这样的机制就是socket。socket函数抽象出来 是一个文件描述符，也就是说拿着一个文件描述符就能完成套接字传输的问题。 对文件描述符的操作无非： 打开关闭读写定位 还有相关的函数能把文件描述符封装到流当中，封装成FILE *。 通过stream 的概念来操作，这个时候就能使用标准IO了。只要是文件，标准io和系统调用io都能拿来使用了。 说到守护进程，为什么写守护进程不把所有文件描述符关掉呢，因为守护进程脱离控制终端。（因为在apue某个版本上的demo上，有把1024个文件描述符都关闭掉的实现。）因为写守护进程，多半与传输有关系，和socket都会产生或多或少的关联。那关掉文件描述符的是没有必要的。所以写程序的时候主要还是要看目的。不要盲目的模仿 1.1 跨主机的传输要注意的问题 字节序， 对齐问题 前面讨论了进程间通讯（IPC）的各种常用手段，但是那些手段都是指通讯双方在同一台机器上的情况。在现实生活中我们会经常接触到各种各样的网络应用程序，比如大家经常使用的 ftp、svn、甚至QQ、迅雷等等，它们的通讯双方通常都是在不同的机器上的，那么它们的通讯就是跨主机的进程间通讯了，所以网络通讯也是一种进程间通讯的手段。 跨主机的程序在传输数据之前要制定严谨的协议，不然对方可能会看不懂你发送的数据，从而导致数据传送失败，甚至造成安全类bug，所以跨主机的通讯就不像我们之前学习的在同一台主机上的进程间通讯那么简单了。 制定协议要考虑的问题至少包括以下几点： 1）告诉对方自己的 IP 和端口； 先来看看 IP 和端口的概念。 当我们的程序在进行网络通讯之前，需要先与自己的机器进行约定，告诉操作系统我需要使用哪个端口，这样操作系统的某个端口在收到数据的时候就会发送给我们的进程。当另一个程序也来通知操作系统它要使用这个端口时，操作系统要保证这个端口只有我们使用而不能再让别人使用，否则当它收到数据的时候就不知道应该发送给谁了。 当我们需要发送数据的时候，也会使用这个端口进行发送，只有特殊情况才会使用别的端口或者使用多个端口。 1.1.1 类型长度问题2）还要考虑的问题是通信的双方应该采用什么数据类型呢？ 假如通讯双方要传送一个 int 类型的数据，那么对方机器上 int 类型的位数与我们机器上的位数是否相同呢？ 也就是说 int 类型在我的机器上是 32bit，但是在对方的机器上也是 32bit 吗？假设在对方机器上是 16bit，那么我发送给它的 int 值它能正确解析吗？ 解决方法 使用一些通用类型的数值 int32_t uint32_t int64_t int8_t uint8_t 所以通信双方的数据类型要采用完全一致的约定，这个我们在下面会讨论如何让数据类型一致。 1.1.2 字节序问题： 大端存储，小端存储大端存储： 低地址处放高字节小端存储： 低地址处放低字节 还要考虑字节序问题，这个说的是大小端的问题。 大端格式是：低地址存放高位数据，高地址存放低位数据。 小端格式是：低地址存放低位数据，高地址存放高位数据。 图1 大小端 如图1 所示，假设要存放的数据是一个16进制的数值， 0x30313233，那么 33 是低位，30 是高位，在大端存储格式中，30 存放在低位，33 存放在高位；而在小端存储格式中，33 存放在低位，30 存放在高位。 大小端存储跟发送的区别，不管是文件传输的时候，还是io来实现的时候，永远是低地址的数据先出去，高地址的数据后出去。就这有问题了，比如我现在发出去的一个数据是小端格式存放的。结果发到你那里去之后，你将它当作大端格式来接收。0x30313233 当大端存储的格式来接收，和按小端格式来接收的结果是天差地别的。解决的思路是 不再严格的去区分到底是大端存储还是小端存储，区分主机字节序和网络字节序； 主机字节序： host网络字节序： network 这个东西有什么作用呢？它其实就是我们使用的网络设备（计算机、平板电脑、智能手机等等）在内存当中存储数据的格式。所以如果通讯双方的设备存储数据的格式不同，那么一端发送过去的数据，另一端是无法正确解析的，这可怎么办呢？ 没关系，还好系统为我们准备了一组函数可以帮我们实现字节序转换，我们可以像使用公式一样使用它们。 12345678 // htonl, htons, ntohl, ntohs - convert values between host and network byte order#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong); // 主机到网络uint16_t htons(uint16_t hostshort); // 主机到网络uint32_t ntohl(uint32_t netlong); // 网络到主机uint16_t ntohs(uint16_t netshort); // 网络到主机 _ to __: 当前pc机上的内容要上传网络传给对端的话，当前就应该是主机序转网络序；如果数据是从网络上接收过来的话，那就是网络序转主机序； 这组函数的名字好奇怪是吧，所以为了便于记忆，在讨论它们的功能之前我们先来分析一下它们名字里的玄机： h 是 host，表示主机；n 是 network，表示网络。l 表示 long，s 表示 short。short为两个字节的， long为四个字节的 这样一来就好理解多了吧？它们的作用从名字中就可以看出来了，就是把数据从主机序转换为网络序，或者把数据从网络序转换为主机序。 网路字节序一般都是大端的，而主机字节序则根据硬件平台的不同而不同（在 x86 平台和绝大多数的 ARM 平台都是小端）。所以为了简化我们编程的复杂度，这些函数的内部会根据当前机器的结构自动为我们选择是否要转换数据的字节序。我们不用管到底我们自己的主机采用的是什么字节序，只要是从主机发送数据到网络就需要调用 hton 函数，从网络接收数据到主机就需要调用 ntoh 函数。 1.1.3 对齐问题4）最后一项约定是结构体成员不对齐，由于数据对齐也是与硬件平台相关的，所以不同的主机如果使用不同的对齐方式，就会导致数据无法解析。 解决的办法 不对齐 如何使数据不对齐呢，只需要在定义结构体的时候在结尾添加 attribute((packed)) 就可以了，见如下栗子： 123456// 1 struct msg_st &#123; uint8_t name[NAMESIZE]; uint32_t math; uint32_t chinese; &#125;__attribute__((packed)); 网络传输的结构体中的成员都是紧凑的，所以不能地址对齐，需要在结构体外面增加 attribute((packed))。 关于字节对齐的东西就足够写一篇博文了，LZ 在这里仅仅简单介绍一下什么是字节对齐，如果感兴趣大家可以去查阅专门的资料。 结构体的地址对齐是通过 起始地址 % sizeof(type) == 0 这个公式计算的，也就是说存放数据的起始地址位于数据类型本身长度的整倍数。如果当前成员的起始地址能被 sizeof 整除，就可以把数据存放在这；否则就得继续看下一个地址能不能被 sizeof 整除，直到找到合适的地址为止。不适合作为起始地址的空间将被空(lang)闲(fei)。 图2 字节对齐 1.2 报式套接字(UDP)从进程间通信开始，我们写程序就是一步一步按部就班的写就可以了，编写网络应用也一样，网络通信本质上就是一种跨主机的进程间通信（IPC）。 前面我们了解了主动端和被动端的概念，那么接下来看看在 Socket 中主动端和被动端都要做什么。 123456789101112131415161718192021主动端（先发包的一方）1.取得 Socket2.给 Socket 取得地址（可省略， 给socket取得地址指的是绑定本地地址，不必与操作系统约定端口，由操作系统指定随机端口）3.发&#x2F;收消息4.关闭 Socket被动端（先收包的一方，程序需要先运行）1.取得 Socket2.给 Socket 取得地址 （绑定地址）3.收&#x2F;发消息4.关闭 Socket proto.h 里面主要是通讯双方约定的协议，包含端口号、传送数据的结构体等等。 1234567891011121314151617181920/* proto.h */#ifndef PROTO_H__#define PROTO_H__#include &lt;stdint.h&gt;#define RCVPORT \"1989\"#define NAMESIZE 13struct msg_st&#123; uint8_t name[NAMESIZE]; uint32_t math; uint32_t chinese;&#125;__attribute__((packed));#endif rcver.c 是被动端的代码，也是通讯双方先启动的一端。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* rcver.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include \"proto.h\"#define IPSTRSIZE 64int main()&#123; int sd; struct sockaddr_in laddr,raddr; socklen_t raddr_len; struct msg_st rbuf; char ipstr[IPSTRSIZE]; sd = socket(AF_INET,SOCK_DGRAM, 0/*IPPROTO_UDP*/); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; laddr.sin_family = AF_INET; laddr.sin_port = htons(atoi(RCVPORT)); inet_pton(AF_INET,\"0.0.0.0\",&amp;laddr.sin_addr.s_addr); if(bind(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0) &#123; perror(\"bind()\"); exit(1); &#125; raddr_len = sizeof(raddr); while(1) &#123; if(recvfrom(sd,&amp;rbuf,sizeof(rbuf),0,(void *)&amp;raddr,&amp;raddr_len) &lt; 0) &#123; perror(\"recvfrom()\"); exit(1); &#125; inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE); printf(\"---MESSAGE FROM:%s:%d---\\n\",ipstr,ntohs(raddr.sin_port)); printf(\"Name = %s\\n\",rbuf.name); printf(\"Math = %d\\n\",ntohl(rbuf.math)); printf(\"Chinese = %d\\n\",ntohl(rbuf.chinese)); &#125; close(sd); exit(0);&#125; 12$&gt; ./rcver$&gt; netstat -anu # u代表 udp -ant t代表 tcp snder.c 是主动端，主动向另一端发送消息。这端可以不用向操作系统绑定端口，发送数据的时候由操作系统为我们分配可用的端口即可，当然如果想要自己绑定特定的端口也是可以的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* snder.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include \"proto.h\"int main(int argc,char **argv)&#123; int sd; struct msg_st sbuf; struct sockaddr_in raddr; if(argc &lt; 2) &#123; fprintf(stderr,\"Usage...\\n\"); exit(1); &#125; sd = socket(AF_INET,SOCK_DGRAM,0); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125;// bind(); // 主动端可省略绑定端口的步骤 memset(&amp;sbuf,'\\0',sizeof(sbuf)); strcpy(sbuf.name,\"Alan\"); sbuf.math = htonl(rand()%100); sbuf.chinese = htonl(rand()%100); raddr.sin_family = AF_INET; raddr.sin_port = htons(atoi(RCVPORT)); inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr); if(sendto(sd,&amp;sbuf,sizeof(sbuf),0,(void *)&amp;raddr,sizeof(raddr)) &lt; 0) &#123; perror(\"sendto()\"); exit(1); &#125; puts(\"ok!\"); close(sd); exit(0);&#125; 由这三个文件组成的程序就可以进行网络通讯了，不知道大家有没有注意到，无论是发送端还是接收端，执行的步骤都是固定的，将来大家在开发更复杂的网络应用时也是基于这几个步骤进行扩展。 根据上面的代码中协议（proto.h）的定义，我们知道其中 msg_st 结构体中 name 成员的长度是固定的，这样并不好用，那么我们就把它修改为变长结构体。 修改成变长结构体很简单，只需把变长的部分放到结构体的最后面，然后通过 malloc(3) 动态内存管理来为它分配我们需要的大小。如下所示： 123456struct msg_st&#123; uint32_t math; uint32_t chinese; uint8_t name[1];&#125;__attribute__((packed)); UDP 包常规的最大尺寸是 512 字节，去掉包头的 8 个字节，再去掉结构体中除了最后一个成员以外其它成员大小的总和，剩下的就是我们最后一个成员最大能分配的大小。 大家还记得如何操作一个文件吗？ 1.首先通过 open(2) 函数打开文件，并获得文件描述符； 2.通过 read(2)、write(2) 函数读写文件； 3.调用 close(2) 函数关闭文件，释放相关资源。 没错，在 Linux 的一切皆文件的设计理念中，网络也是文件，网络之间的通讯也可以像操作文件一样，对它进行读写。 在网络程序中，通常步骤是这样的： 1.首先通过 socket(2) 函数获得 socket 文件描述符； 2.通过 send(2)、sendto(2)、recv(2)、recvfrom(2) 等函数读写数据，这一步就相当于在网络上收发数据了。 3.调用 close(2) 函数关闭网络，释放相关资源。你没看错，这个函数就是我们关闭文件描述符的时候使用的函数。 下面我们依次介绍上面遇到的各种函数。 1.2.1 socket函数123456// socket - create an endpoint for communication#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); socket(2) 函数是用来获取对网络操作的文件描述符的，就像 open(2) 函数一样。 参数列表： domain：协议族/地址族； type：上层如何进行实现/链接方式； protocol：具体使用哪个协议。在 domain 的协议族中每一个对应的 type 都有一个或多个协议，使用协议族中默认的协议可以填写 0。 用 domain（协议族）中的 某种 protocol（具体哪个协议）进行 type类型的传输 返回值：如果成功，返回的是一个代表当前网络链接的文件描述符，你要保存好它，因为后续的网络操作都需要它。如果失败，返回 -1，并设置 errno。 下面就是 Linux 支持的协议族，也就是 domain 参数可以选择的宏，它们都定义在 sys/socket.h 头文件中，所以想要使用下面的宏不要忘记包含这个头文件哟。 1234567891011121314151617181920AF_UNIX、AF_LOCAL：本地协议；通过 man 7 unix 可以得到有关这个协议族更详细的描述。AF_INET：IPV4 协议；这是我们最常见的协议族，通过 man 7 ip 可以得到有关这个协议族更详细的描述。AF_INET6：IPV6 协议；，通过 man 7 ipv6 可以得到有关这个协议族更详细的描述。AF_IPX：Novell 当年是网络的代名词，是非常古老的操作系统，出现在 TCP&#x2F;IP 之前；AF_NETLINK：是用户态与内核态通信的协议；AF_X25：这是很早的协议，感兴趣的话可以自己去 Google 一下；AF_AX25：应用于业余无线电，也称为短波通信，都是一些无线电爱好者使用的协议。据说汶川地震时灾区所有通讯都瘫痪了，第一个求救信号就是短波发送出来的，因为这些无线电爱好者家里一般都有大大小小的发电机。AF_ATMPVC：当年如日中天，后来死于封闭。协议设计得非常好，后来几家公司都为了拿大头就僵持起来，谁都没有推广它，就在这时候以太网发展起来了，就把它打败了。以太网发展起来就是因为很简陋，所以更容易推广。AF_APPLETALK：苹果使用的一个局域网协议；AF_PACKET：底层 socket 所用到的协议，比如抓包器所遵循的协议一定要在网卡驱动层，而不能在应用层，否则无法见到包封装的过程。再比如 ping(1) 命令大家都熟悉吧，想要实现 ping(1) 命令就需要了解这个协议族，感兴趣的话大家可以自行 Google 一下。 如果想要对网络编程进行更深入的学习，那么《APUE》作者写的《UNIX 网络编程》有必要读一遍；《TCP/IP详解》三卷也要读一下，但是这三卷都很难读，而且翻译质量也一般，可以买一本中文的再找一本英文电子版的，遇到中文的读不通的时候拿出来英文原文对照一下就可以了。 下面我们看一下 type 参数有哪些可选项： 1234567891011121314151617181920212223242526SOCK_STREAM：流式套接字，特点是有序、可靠。有序、双工、基于链接的、以字节流为单位的。可靠不是指不丢包，而是流式套接字保证只要你能接收到这个包，那么包中的数据的完整性一定是正确的。双工是指双方都能收发。基于链接的是指：比如大街上张三、李四进行对话，一定不会说每句话之前都叫着对方的名字。也就是说通信双方是知道对方是谁的。字节流是指数据没有明显的界限，一端数据可以分为任意多个包发送。 SOCK_DGRAM：报式套接字，无链接的，固定的最大长度，不可靠的消息。就像写信，无法保证你发出的信对方一定能收到，而且无法保证内容不会被篡改。如果今天发了一封信，明天又发了一封信，不能保证哪封信先到。大家都能收到这个包，但是发现不是自己的之后就会丢弃，发现是自己的包再处理，有严格的数据分界线。更详细的解释可以参阅 man 手册。 SOCK_SEQPACKET：提供有序、可靠、双向基于连接的数据报通信。SOCK_RAW：原始的套接字，提供的是网络协议层的访问。SOCK_RDM：数据层的访问，不保证传输顺序。SOCK_PACKET：不好用，具体的 bug 要查 man 7 packet。 bind(2) 123456789101112// bind - bind a name to a socket#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);struct sockaddr &#123; sa_family_t sa_family; char sa_data[14];&#125; bind(2) 函数用于绑定本机端口，就是提前跟操作系统约定好，来自 xx 端口的数据都要转交给我（当前进程）处理，并且我占用了这个端口号别人（其它进程）就不能再使用了。 参数列表： sockfd：刚刚使用 socket(2) 函数得到的文件描述符，表示要对该网络链接绑定端口。 addr：要绑定到套接字上的地址。根据不同的协议要在 man 手册第 7 章查阅具体的章节，然后在 Address Types 一栏里面找到对应的结构体。比如你在调用 socket(2) 函数的时候，domain 参数选择的是 AF_INET，那么这个结构体就可以在 man 手册 ip(7) 章节中找到。 addrlen：addr 传递的地址结构体的长度。 以 AF_INET 为例，下面这两个结构体就是在 ip(7) 中找到的。 12345678910struct sockaddr_in &#123; sa_family_t sin_family; /* 指定协议族，一定是 AF_INET，因为既然是 man ip(7)，那么一定是 AF_INET 协议族的 */ in_port_t sin_port; /* 端口，需要使用 htons(3) 转换为网络序 */ struct in_addr sin_addr; /* internet address */&#125;;/* Internet address. */struct in_addr &#123; uint32_t s_addr; /* 无符号32位大整数，可以使用 inet_pton(3) 将便于记忆的点分式 IP 地址表示法转换为便于计算机使用的大整数，inet_ntop(3) 的作用则正好相反。本机地址转换的时候可以使用万能IP：0.0.0.0(称为any address)，函数会自动将 0.0.0.0 解析为真实的本机 IP 地址。 */&#125;; 大家可以看到，这个结构体的类型是 struct sockaddr_in，而 bind(2) 函数的第二个参数 的类型是 struct sockaddr，它们二者有什么关系呢？别瞎想，不是继承关系啦，C 语言中没有继承这种东东。在传参的时候直接把实参强转为 void* 类型即可，就像上面栗子中 rcver.c 写得那样。 recv(2) 和 recvfrom(2) 函数 1234567891011// recv, recvfrom - receive a message from a socket#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);// src_addr 对端的地址// addrlen 对端的地址长度 这两个函数的作用是从网络上接收内容并写入 len 个字节长度的数据到 buf 中，且将发送端的地址信息填写到 src_addr 中。 返回值是真正能接收到的字节数，返回 -1 表示失败。 recv(2) 函数一般用在流式（SOCK_STREAM）套接字中，而 recvfrom(2) 则一般用在报式（SOCK_DGRAM）套接字中。很明显 recv(2) 函数并没有地址相关的参数，因为是提前建立好连接的一对一点对点的，所以不必记录每次对方是谁。 recvfrom 函数用在报式套接字当中，比如做一下现场答疑，有10个学生在提问问题，每个学生提问的问题不一致，也就说是说话的来源不一致，大家说话是带着自己身份来的。比如a同学的请求，要把回答信息准备回递给a同学。b同学的请求要回递给b同学，这点跟流式套接字不同，流式套接字已经建立一对一点对点的传输了。 需要记录对端的地址和地址长度。 为什么这么说呢，还记得上面我们提到过吗，流式套接字是基于链接的，而报式套接字是无链接的。那么我们再来观察下这两个函数的参数列表，，而 recvfrom(2) 函数则会将对方的地址端口等信息回填给调用者。 网络中的数据只有单字节数据不用考虑字节序，从网络上接收过来的数据只要涉及到字节序就需要使用 ntoh 系列函数进行字节序转换。这一组函数我们上面介绍过了，没记住的童鞋可以往上翻。 12345小提示：通过 netstat(1) 命令 ant 参数可以查看 TCP 链接情况，或通过 netstat(1) 命令 anu 参数可以查看 UDP 链接情况。t 参数表示 TCP；u 参数表示 UDP； send(2) 和 sendto(2) 函数 123456789// send, sendto, sendmsg - send a message on a socket#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 这两个函数与 recv(2) 和 recvfrom(2) 函数正好是对应的，它们的作用是向网络上发送数据。 参数列表： sockfd：通过哪个 Socket 往外发数据，这个参数的值就是在调用 socket(2) 函数的时候取得的； buf：要发送的数据； len：要发送的数据的长度； flags：特殊要求，没有填 0； src_addr：目标地址；就像上面我们讨论 bind(2) 函数时一样，具体使用哪个结构体要根据你在调用 socket(2) 函数的时候使用的具体协议族有关系，然后到对应的 man 手册第 7 章去查找。 addrlen：目标地址的长度； 返回值是真正发送出去的数据的长度；出现错误返回 -1 并设置 errno。 动态报式套接字 1234567891011121314151617181920212223242526272829/* proto.h */#ifndef PROTO_H__#define PROTO_H__#include &lt;stdint.h&gt;// ip 到 agrv的地方去指定#define RCVPORT \"1989\"#define NAMEMAX 512-8-8 // 512 是 udp包的 推荐长度， -8 是两个 固有字节 math 和 Chinese，再减8 是减去udp的包头#define NAMESIZE 13struct msg_st&#123; uint32_t math; uint32_t chinese; uint8_t name[1]; // 把当前的数组 设为一个 变长的内容, // uint8_t name[1]; 把name放在 结构体的首部 发送的名字只能接收第一个字符 // uint32_t math; // uint32_t chinese; &#125;__attribute__((packed)); // 不对齐#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* snder.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include \"proto.h\"int main(int argc,char *argv[]) // ./snder IP NAME&#123; int sd; struct msg_st *sbufp; struct sockaddr_in raddr; int size; if(argc &lt; 3) // ./snder IP NAME &#123; fprintf(stderr,\"Usage...\\n\"); exit(1); &#125; if (strlen(argv[2]) &gt; NAMEMAX) &#123; fprintf(stderr, \"Name is too long\"); exit(1); &#125; size = sizeof(struct msg_st) + strlen(argv[2]); sbufp = malloc(size); if (sbufp == NULL) &#123; perror(\"malloc()\"); exit(1); &#125; sd = socket(AF_INET,SOCK_DGRAM,0); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125;// bind(); // 主动端可省略绑定端口的步骤 strcpy(sbufp-&gt;name, argv[2]); sbufp-&gt;math = htonl(rand()%100); sbufp-&gt;chinese = htonl(rand()%100); raddr.sin_family = AF_INET; raddr.sin_port = htons(atoi(RCVPORT)); inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr); if(sendto(sd, sbufp, size, 0, (void *)&amp;raddr, sizeof(raddr)) &lt; 0) &#123; perror(\"sendto()\"); exit(1); &#125; puts(\"ok!\"); close(sd); exit(0);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* rcver.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include \"proto.h\"#define IPSTRSIZE 64int main()&#123; int sd; struct sockaddr_in laddr,raddr; socklen_t raddr_len; struct msg_st *rbufp; char ipstr[IPSTRSIZE]; int size; size = sizeof(struct msg_st) + NAMEMAX -1; rbufp = malloc(size); if(rbufp == NULL) &#123; perror(\"malloc()\"); exit(1); &#125; sd = socket(AF_INET,SOCK_DGRAM, 0/*IPPROTO_UDP*/); // 如果不太确定那个具体协议的名字是多少， // 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话， //一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; /** * struct socket_in &#123; * sa_family_t sin_family; * in_port_t sin_port; // 端口号 * struct_in_addr sin_addr; // ip地址 * &#125; * * struct in addr &#123; * uint32_t s_addr; // 32位无符号的整型数 * &#125; * * // ip地址点分式和大整数之间的转换 * * // 将ipv4 和 ipv6的地址转成二进制的格式 * int inet_pton(int af, const char *src, void *dst); */ laddr.sin_family = AF_INET; laddr.sin_port = htons(atoi(RCVPORT)); // 跟本机约定哪个端口是给自己使用的； inet_pton(AF_INET,\"0.0.0.0\",&amp;laddr.sin_addr.s_addr); if(bind(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0) // bind 给socket取得地址 &#123; perror(\"bind()\"); exit(1); &#125; raddr_len = sizeof(raddr); // addrlen 需要初始化一个值 while(1) &#123; if(recvfrom(sd, rbufp,size,0,(void *)&amp;raddr,&amp;raddr_len) &lt; 0) // 接收消息 &#123; perror(\"recvfrom()\"); exit(1); &#125; inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);// 把一个大整数形式转成点分式 printf(\"---MESSAGE FROM:%s:%d---\\n\",ipstr,ntohs(raddr.sin_port)); printf(\"Name = %s\\n\",rbufp-&gt;name); printf(\"Math = %d\\n\",ntohl(rbufp-&gt;math)); printf(\"Chinese = %d\\n\",ntohl(rbufp-&gt;chinese)); &#125; close(sd); // 关闭socket exit(0);&#125; 最后剩下 close(2) 函数就不需要 LZ 在这里介绍了吧，如果还有童鞋对 close(2) 函数不熟悉，那么请翻阅到前面 文件 IO 部分的博文中复习一遍。 1.2.2 多点通讯上面我们讨论的是单点通讯，多点通讯只能用报式套接字来实现。 一般多点通讯分为：广播 和 多播（组播）两种方式。 广播又分为 全网广播（255.255.255.255） 和 子网广播 两种形式。 多播：都是 D 类地址，以 224. 开头。224.0.0.1 是一个组播中的特殊地址，发到这个地址的消息会强制所有组播地址中的主机接收，类似于全网广播。 广播：往（255，255，255，255发送消息）范围非常大，愿不愿意接收都得接收到； 组播： 建立一个播组，如果想接收到消息，就加入这个组；不想收就退组。多播的使用权更加灵活，当然多播当中有一个特殊地址，如果往这个特殊地址发送消息的话。实际就如同发送一个广播，效果是一样的。从另外一个角度来实现广播的特点 注意：广播和组播仅在局域网内有效。 一个广播实例 12345678910111213141516171819202122/* proto.h */#ifndef PROTO_H__#define PROTO_H__#include &lt;stdint.h&gt;// ip 到 agrv的地方去指定#define RCVPORT \"1989\"#define NAMESIZE 13struct msg_st&#123; uint8_t name[NAMESIZE]; uint32_t math; uint32_t chinese;&#125;__attribute__((packed)); // 不对齐#endif 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* rcver.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include \"proto.h\"#define IPSTRSIZE 64int main()&#123; int sd; struct sockaddr_in laddr,raddr; socklen_t raddr_len; struct msg_st rbuf; char ipstr[IPSTRSIZE]; sd = socket(AF_INET,SOCK_DGRAM, 0/*IPPROTO_UDP*/); // 如果不太确定那个具体协议的名字是多少， // 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话， //一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; int val =1; if(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &amp;val, sizeof(val))&lt;0) &#123; perror(\"setsocket()\"); exit(1); &#125; /** * struct socket_in &#123; * sa_family_t sin_family; * in_port_t sin_port; // 端口号 * struct_in_addr sin_addr; // ip地址 * &#125; * * struct in addr &#123; * uint32_t s_addr; // 32位无符号的整型数 * &#125; * * // ip地址点分式和大整数之间的转换 * * // 将ipv4 和 ipv6的地址转成二进制的格式 * int inet_pton(int af, const char *src, void *dst); */ laddr.sin_family = AF_INET; laddr.sin_port = htons(atoi(RCVPORT)); // 跟本机约定哪个端口是给自己使用的； inet_pton(AF_INET,\"0.0.0.0\",&amp;laddr.sin_addr.s_addr); if(bind(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0) // bind 给socket取得地址 &#123; perror(\"bind()\"); exit(1); &#125; raddr_len = sizeof(raddr); // addrlen 需要初始化一个值 while(1) &#123; if(recvfrom(sd,&amp;rbuf,sizeof(rbuf),0,(void *)&amp;raddr,&amp;raddr_len) &lt; 0) // 接收消息 &#123; perror(\"recvfrom()\"); exit(1); &#125; inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);// 把一个大整数形式转成点分式 printf(\"---MESSAGE FROM:%s:%d---\\n\",ipstr,ntohs(raddr.sin_port)); printf(\"Name = %s\\n\",rbuf.name); printf(\"Math = %d\\n\",ntohl(rbuf.math)); printf(\"Chinese = %d\\n\",ntohl(rbuf.chinese)); &#125; close(sd); // 关闭socket exit(0);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* snder.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include \"proto.h\"int main(int argc,char **argv)&#123; int sd; struct msg_st sbuf; struct sockaddr_in raddr; sd = socket(AF_INET,SOCK_DGRAM,0); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; /** * 当前广播默认要求是不能够发出的，组播其实也一样。 * socket层上面的实现层也好 还是下面的协议层也好。打开来看实际上有很多薄的层， * IP层，TCP层，UDP层，甚至socket层面。在不同的层上会有不同的开关或选钮加以控制。 * * 全网广播实际上是禁止被发送的，而有一个开关是能够使当前的广播是能够实现的。 */ int val = 1; if(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &amp;val, sizeof(val)) &lt; 0) &#123; perror(\"setsockopt()\"); exit(1); &#125; memset(&amp;sbuf,'\\0',sizeof(sbuf)); strcpy(sbuf.name,\"Alan\"); sbuf.math = htonl(rand()%100); sbuf.chinese = htonl(rand()%100); raddr.sin_family = AF_INET; raddr.sin_port = htons(atoi(RCVPORT)); inet_pton(AF_INET,\"255.255.255.255\",&amp;raddr.sin_addr); if(sendto(sd,&amp;sbuf,sizeof(sbuf),0,(void *)&amp;raddr,sizeof(raddr)) &lt; 0) &#123; perror(\"sendto()\"); exit(1); &#125; puts(\"ok!\"); close(sd); exit(0);&#125; 12345./rcver./snderok!# 客户端并没有收到响应， 原因可能是防火墙的问题 1.4 抓包工具使用过滤表达式 ip.dist == 255.255.255.255 getsockopt(2) 和 setsockopt(2) 函数 123456789// getsockopt, setsockopt - get and set options on sockets#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 这两个函数用于读取和设置套接字的特殊要求。 对 sockfd 这个套接字的 level 层的 optname 选项进行设置，值放在 optval 里，大小是 optlen。 参数 sockfd、level 和 optname 的对应关系就是：一个 sock 有多个 level，每个 level 有多个选项。 所有的选项需要在不同协议的 man 手册(第7章) Socket options 一栏查找。 常用 optname 参数： SO_BROADCAST：设置或获取广播标识，当这个标识被打开时才允许接收和发送报式套接字广播，所以大家使用广播的时候不要忘记设置这个 opt，但在流式套接字中无效。 IP_MULTICAST_IF：创建多播组，optval 参数应该使用 ip_mreqn 还是 ip_mreq 结构体，取决于 IP_ADD_MEMBERSHIP 选项。 12345struct ip_mreqn &#123;struct in_addr imr_multiaddr; /* 多播组 IP 地址，大整数，可以用 inet_pton(3) 将点分式转换为大整数 */struct in_addr imr_address; /* 本机 IP 地址，可以用 0.0.0.0 代替，大整数，可以用 inet_pton(3) 将点分式转换为大整数 */int imr_ifindex; /* 当前使用的网络设备的索引号，ip ad sh 命令可以查看编号，用 if_nametoindex(3) 函数也可以通过网络设备名字获取编号，名字就是 ifconfig(1) 看到的名字，如 eth0、wlan0 等 */&#125;; IP_ADD_MEMBERSHIP：加入多播组 1.4.1 多播/组播 多播属于D类IP地址，都是224. 开头 224.0.0.1 表示所有支持多播的节点；默认都存在这个组当中，并且无法离开。所以在sender方往这个地址发消息相当于往 255.255.255.255上发消息。 12345678910111213141516171819202122232425262728/* proto.h */#ifndef PROTO_H__#define PROTO_H__#include &lt;stdint.h&gt;#define MGROUP \"224.2.2.2\"#define RCVPORT \"1989\"#define NAMESIZE 13/** * 约定多播组 * * 发送方应该创建多播组，并且发组间消息。而接收方应该是加入多播组，从这个多播组中来收消息。 * 这个组就从为大家需要知道的内容*/struct msg_st&#123; uint8_t name[NAMESIZE]; uint32_t math; uint32_t chinese;&#125;__attribute__((packed)); // 不对齐#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* rcver.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include \"proto.h\"#define IPSTRSIZE 64int main()&#123; int sd; struct sockaddr_in laddr,raddr; socklen_t raddr_len; struct msg_st rbuf; char ipstr[IPSTRSIZE]; sd = socket(AF_INET,SOCK_DGRAM, 0/*IPPROTO_UDP*/); // 如果不太确定那个具体协议的名字是多少， // 写0。写0意味着，每个协议族当中对于一种实现方式的支持如果有协议或者有多个协议的话， //一定有一个是默认的，0就是这个默认的。这个默认的协议是IPPROTO_UDP if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; struct ip_mreqn mreq; inet_pton(AF_INET, MGROUP, &amp;mreq.imr_multiaddr); inet_pton(AF_INET, \"0.0.0.0\", &amp;mreq.imr_address); mreq.imr_ifindex = if_nametoindex(\"eth0\"); if(setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq) )&lt;0) &#123; perror(\"setsocket()\"); exit(1); &#125; laddr.sin_family = AF_INET; laddr.sin_port = htons(atoi(RCVPORT)); // 跟本机约定哪个端口是给自己使用的； inet_pton(AF_INET,\"0.0.0.0\",&amp;laddr.sin_addr.s_addr); if(bind(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0) // bind 给socket取得地址 &#123; perror(\"bind()\"); exit(1); &#125; raddr_len = sizeof(raddr); // addrlen 需要初始化一个值 while(1) &#123; if(recvfrom(sd,&amp;rbuf,sizeof(rbuf),0,(void *)&amp;raddr,&amp;raddr_len) &lt; 0) // 接收消息 &#123; perror(\"recvfrom()\"); exit(1); &#125; inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);// 把一个大整数形式转成点分式 printf(\"---MESSAGE FROM:%s:%d---\\n\",ipstr,ntohs(raddr.sin_port)); printf(\"Name = %s\\n\",rbuf.name); printf(\"Math = %d\\n\",ntohl(rbuf.math)); printf(\"Chinese = %d\\n\",ntohl(rbuf.chinese)); &#125; close(sd); // 关闭socket exit(0);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* snder.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include \"proto.h\"int main(int argc,char **argv)&#123; int sd; struct msg_st sbuf; struct sockaddr_in raddr; sd = socket(AF_INET,SOCK_DGRAM,0); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; /** * 当前广播默认要求是不能够发出的，组播其实也一样。 * socket层上面的实现层也好 还是下面的协议层也好。打开来看实际上有很多薄的层， * IP层，TCP层，UDP层，甚至socket层面。在不同的层上会有不同的开关或选钮加以控制。 * * 全网广播实际上是禁止被发送的，而有一个开关是能够使当前的广播是能够实现的。 */ struct ip_mreqn mrep; inet_pton(AF_INET, MGROUP, &amp;mrep.imr_multiaddr); inet_pton(AF_INET, \"0.0.0.0\", &amp;mrep.imr_address); mrep.imr_ifindex = if_nametoindex(\"eth0\"); if(setsockopt(sd, IPPROTO_IP, IP_MULTICAST_IF,&amp;mrep, sizeof(mrep) ) &lt; 0) &#123; perror(\"setsockopt()\"); exit(1); &#125; memset(&amp;sbuf,'\\0',sizeof(sbuf)); strcpy(sbuf.name,\"Alan\"); sbuf.math = htonl(rand()%100); sbuf.chinese = htonl(rand()%100); raddr.sin_family = AF_INET; raddr.sin_port = htons(atoi(RCVPORT)); /** * 约定多播组 * * 发送方应该创建多播组，并且发组间消息。而接收方应该是加入多播组，从这个多播组中来收消息。 * 这个组就从为大家需要知道的内容 */ inet_pton(AF_INET, MGROUP, &amp;raddr.sin_addr); if(sendto(sd,&amp;sbuf,sizeof(sbuf),0,(void *)&amp;raddr,sizeof(raddr)) &lt; 0) &#123; perror(\"sendto()\"); exit(1); &#125; puts(\"ok!\"); close(sd); exit(0);&#125; 1.4.2 wireShark 41:6c:61:6e:00:00:00:00:00:34:00:00:00:00:00:00:53:00:00:00:56 这是basic包中程序 实际发出的数据包。看到6e 到 53 中间的 34 就是内存泄漏，泄漏的是栈上残留的数据； 处理方法 12void *memset(void *s, int c, size_t n); * // 把从 某某位置开始 到 某某位置结束 中间 n个位置的数值 清空为 '\\0' 1.4.3 udp 丢包下面来谈谈丢包和校验的问题 TTl TTL（time to leave） 是一个数据包能够经过的路由器数量的上限; UDP 会丢包，为什么会丢包呢？丢包由于阻塞造成的 因为不同的请求会选择不同的路径经过不同的路由器，这些包到达路由器的时候会进入路由器的等待队列，当路由比较繁忙的时候队列就会满，当队列满了的时候各个路由会根据不同的“丢包算法（当队列达到80%的时候，选择随机丢包。或者当包占到这个队列百分之多少的时候，剩下的包不再接收等等）”丢弃多余的包（一般是丢弃新来的包或随机丢弃包）。所以丢包的根本原因是拥塞。 ping 命令的 TTL（time to leave） 是一个数据包能够经过的路由器数量的上限，这个上限在 Linux 环境里默认是 64，在 Windows 里默认是 128。 假设从中国某个点发送一个包到美国的某个点，从发出开始到中国的总路由器需要大约十几跳，从中国总路由到美国总路由大约两三跳就到了，再从美国总路由到达目标点也经过大约十几跳，因此无论 TTL 是 64 还是 128 都足以从全球任何一个点发送数据到另一个点了，况且发出去的这几个包走的路径也是不一致的，因为当前在经过沿途路由队列，本身会有一个选择算法（寻找最短路径），很有可能每个包走的都是不同路径。所以丢包绝不是因为 TTL 值太小导致的。 数据校验 网站图片显示不全打X，或者部分显示不全。类似web服务等，都会有一个断点续传的功能。这里不能做硬性数据校验（刷新发包请求）， 而应该是 尝试读-&gt;读不出来就跳一个字节-&gt; 依次循环，而不是读不到就卡住这种非硬性校验。在做一些网络操作的时候，网络的一些也不会做硬性的数据校验 解决丢包的方法是使用流量控制，之前我们写过令牌桶还记得吧？流控分为开环式（没有校验的流控）和闭环式。 我们在这里介绍一种停等式流控：它是一种闭环式流控。它的实现方式很简单，一问一答即可。就是发送方每次发送一个数据包之后要等待接收方的响应，确认接收方收到了自己的数据包后再发送下一个数据包。这种方式的特点是每次等待的时间是不确定的，因为每次发包走的路径是不同的，所以包到达目的地的时间也是不同的，而且还要受网络等环境因素影响。 （发包之后等待ACK反馈之后再接着发） 并且停等式流控的缺点也很明显：1.浪费时间，多数时间都花费在等待响应上面了。2.双方发送包的数量增加了，这也意味着丢包率升高了。3.为了降低错误率，实现的复杂度会变高。如果 s 端 data 包发过去了，但是 c 端响应的 ack 包丢了，s 端过了一会儿没收到 ack 认为 data 丢了再次发送 data，当 c 端再次收到一模一样的 data 包时不知道到底是有两段数据一模一样还是 s 端把包发重复了，所以需要给data包加编号，这样 c 端就知道当前这个 data 包是合法的数据还是多余的数据了。 停等式流控虽然上升了丢包率，但是能保证对方一定能收到数据包。 rtt（解决发送data丢失的问题） 平均等待时间，比如s第一次向c发送包就丢了，那又不可能一直傻等着根本来不了的ACK包。所以需要设置一个平均等待时间，初始化这个值设多大没有关系，只要发第一个data，收到ACK的时候，这个时间就作为一个完全的rrt。第二个ack到来的时候，又是一个时间。这两个rrt想办法做一个平均值。然后每一次的返回新的ack，都要拿新的时间汇总计算出平均值。所以第一次发包就丢的情况，在等待了一次rrt 之后就继续发一下包过去。等待ack返回在继续。然后依此类推。 给data包加编号 （解决没有ack丢失的问题） 同样，s第一次向c发送包成功了，但是c返回的ack包丢了。s在等待一个rtt时间之后，发现没见ack的踪迹。s没有能力去判断c那边到底是自己包没发成功，还是ack包丢包了。所以，s端只能认为是自己的data包丢了。所以就重新传了data包，这就有问题了，c那边接到两个一摸一样的data包。那c就怀疑两件事儿：1 自己的ack包是不是丢了，2 是不是就有两个一摸一样data包的情况呢。因此需要给data包添加编号。所以c端在处理刚才的情况的时候，发现两个data包编号一样的话，就知道自己丢ack包了，然后赶紧把给s端返回ack包，并顺带把重复的data给删除掉了。 web 传输通常采用两种校验方案： 1.不做硬性校验：交给用户来做。比如你在浏览网页，网页周边的广告都加载出来了，但是正文没有加载出来，你肯定会刷新页面吧？但是如果正文加载出来了，周边的广告没有加载出来，你会刷新网页一定要让整个网页全部都加载完整再看内容码？ 2.延迟应答：下次通讯的时候把上次的 ack 带过来，表示上次的通讯是完整的。 ack延迟 图3 ack 延迟 不仅仅 data 包会出现延迟， ack 包也会出现延迟（见图3）。所以 ack 包也需要加编号。 为了防止被抓包，所以往往不会把原始的编号暴露出来，比如将编号+1或-1再发送。 网络的拥塞不仅仅会带来丢包的问题，还会带来延迟的问题。延迟并不可怕，可怕的是延迟抖动。比如在北京看新闻联播和在云南看新闻联播会是同时的吗？肯定会有相应的延迟吧，每一帧都延迟就没关系，就怕其中某些帧延迟，其它帧不延迟，这样看到的内容就全乱了。 上面说了用停等式流控可以保证数据一定能够让对方接收到，但是有没有觉得速度慢了点？ 可以通过窗口或滑动窗口提高速度，见图4。 滑动窗口（最大限度抢占路由资源） 图4 窗口 使用窗口协议的停等式流控，不再是发送一个包之后等待 ack 然后再发送另一个包，而是一下子发送出去多个包（图中一次发送 5 个包），分别等待它们的响应后再发送下一批次的包。一次发送 5 个包，那么窗口的大小就是 5。使用窗口协议就可以尽可能多的抢占公共资源（交换机的等待队列等）了，这样传输效率相比简单的停等式流控就更高了。当然窗口的缺点也是显而易见的：窗口的大小不可变，对于复杂的网络情况并不灵活。那么只要对窗口稍加改变就可以更灵活的应对复杂多变的网络环境：动态改变窗口的大小，使之可以根据不同的网络情形动态的改变流控的速率，这样就可以平衡丢包率和传输速率之间的杠杆了，这种可以动态调整窗口大小的协议叫做“滑动窗口”。关于窗口和滑动窗口这里就不做过多介绍了，感兴趣的童鞋可以去查阅一些专门的资料。 新的问题 s第一次拿到的ack一定是第一个data包对应的ack吗？不一定把。所以s端和c端在进行对话之前，要进行编号的约定。 1.5 TCP说完了 UDP，接下来聊一聊 TCP。 图x tcp三次握手原理 由报式套接字过渡到流式套接字(三次握手（中间两步合成一步，四步并三步）主要目的就是为了协同编号，实际上也是约定对话格式，指定协议的过程 )c端向s端说，我的编号从哪里开始，s端回收到并告诉自己从什么编号开始，c端发起第一次握手，s端回第二次握手，c端发起第三次握手。有了这三次握手之后，s端和c端就建立起一对一的，点对点的安全传输。这就是TCP三次握手的精髓所在。然后后面会有四次挥手，会把当前传输过程，或者传输的数据来进行总结，进行断开链接等操作。 说到 TCP 就不得不谈到 TCP 的三次握手，见图 5。 图5 TCP 三次握手 TCP 都是要客户端先发起请求，所以客户端可以称为“主动端”，而服务器被动接收请求，所以服务端也可以称为“被动端”。往往服务端要先运行起来，然后客户端再发送消息，否则客户端发送的包会因为找不到目的地而被丢弃。 半连接状态 如图x所示，1，2两步被称为半连接状态。然后在s端会有一个池，叫做半链接池； 服务端收到客户端发来的 SYN 报文后（第1步），会响应 SYN+ACK 报文给客户端（第2步），并将当前链接的一些信息放入一个叫做“半链接池”的缓冲区中，当对方发起第三次握手的时候（第3步），就在池中找到对方的信息（ip，port protocol等）。如果都存在的话，就说明前面已经建立了两个成功的握手。那么就接收第三次握手，下面就进入正常的数据传输。当然如果超过一定时间后该客户端没有返回 ACK 报文给服务端，服务端再把这个半链接从半链接池中移除，释放相关资源。 半链接洪水（无法从根本上进行防范） 占满你的链接池 只要出现了“XX池”，那么该池的容量终归是有限的，所以有一种下流的拒绝服务攻击手段就是利用大量的半链接把服务端的半链接池沾满，以实现拒绝服务攻击。例如当很多肉鸡向某台服务器发送第一次握手（FIN）却永远不发送第三次握手（ACK），这样很快就把服务器的半链接池沾满了，有效的用户也就无法请求服务器了，这就是下流的半链接攻击手段的大致原理。 取消链接池 防范半链接的手段就是取消半链接池，然后通过一个算法为每个链接计算出一个独一无二的标识，再把这个标识放入 cookie 中通过 ACK 返回给客户端。cookie 由内核产生，仅保留这一秒和上一秒的 cookie。当用户再次请求时需要带着这个 cookie，用相同的 cookie 计算，只要与用户带来的 cookie 相同就认为是合法用户，如果不相同就用上一秒的cookie再次计算和比较，如果还不相同，就认为用户的cookie 是伪造的或是超时的，所以用户会立即重新建立第一次握手。 cookie计算公式：本机IP+本机端口+对端IP+对端端口 | Salt（由内核产生的，1秒变一次） 其实在实践当中也会保留半链接池，里面仅仅存放频繁访问的用户来优化 cookie 方式的链接。 简要的介绍了 TCP 的三次握手之后，我们来看看如何实现用 TCP 协议收发数据。有关更详细的 TCP 知识，感兴趣的童鞋可以参阅《TCP/IP 卷一：协议》。 1.5.1 TCP实现TCP 的步骤 S端（先运行） 1.取得 SOCKET (socket(2)) IPPROTO_SCTP 是一种新协议，也可以实现流式套接字2.给 SOCKET 取得地址 (bind(2))3.将 SOCKET 置为监听模式 (listen(2)) backlog 参数写什么正整数都行。4.接受链接 (accept(2)) 如果成功返回接受链接的文件描述符，失败返回 -1 并设置 errno。注意不能直接用存放之前 socket(2) 返回的文件描述符变量来接收 accept(2) 的返回值，因为accept(2) 可能会遇到假错，这样之前变量里保存的文件描述符就丢了，会导致内存泄漏。5.收/发消息 (send(2))6.关闭 SOCKET (close(2)) C端（主动端） 1.取得 SOCKET (socket)2.给 SOCKET 取得地址（可省） (bind)3.发起链接 (connect)4.收/发消息5.关闭 SOCKET proto.h，这个文件是客户端与服务端的协议，双方共同遵守的格式要定义在这里，所以两边都要包含这个头文件。 123456789#ifndef PROTO_H__#define PROTO_H__// 服务器端口号#define SERVERPORT \"12999\"#define FMT_STAMP \"%lld\\r\\n\"#endif server.c 服务端，要先运行起来，监听指定的端口，操作系统指定的端口收到数据后就会送到服务端程序这里来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include \"proto.h\"#define BUFSIZE 1024#define IPSTRSIZE 40static void server_job(int sd)&#123; char buf[BUFSIZE]; int len; len = sprintf(buf, FMT_STAMP,(long long)time(NULL)); if(send(sd,buf,len,0) &lt; 0) &#123; perror(\"send()\"); exit(1); &#125; return ;&#125;int main()&#123; int sd,newsd; struct sockaddr_in laddr/*local address*/, raddr /*remote address*/; socklen_t raddr_len; char ipstr[IPSTRSIZE]; // 选择 TCP 协议 sd = socket(AF_INET,SOCK_STREAM,0/*IPPROTO_TCP,IPPROTO_SCTP*/); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; // SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动 // 会导致 bind 端口短暂失效的情况 int val = 1; // bool值，除了0就是1； if(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,sizeof(val)) &lt; 0) &#123; perror(\"setsockopt()\"); exit(1); &#125; laddr.sin_family = AF_INET; // 指定服务端使用的端口号 laddr.sin_port = htons(atoi(SERVERPORT)); inet_pton(AF_INET,\"0.0.0.0\",&amp;laddr.sin_addr.s_addr); // 绑定端口 if(bind(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0) &#123; perror(\"bind()\"); exit(1); &#125; /** * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经 * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个 * 数值的上限。 * 所以backlog 现在指能能够承受C端的全链接的大小 */ // 开始监听端口 if(listen(sd,200) &lt; 0) &#123; perror(\"listen()\"); exit(1); &#125; raddr_len = sizeof(raddr); while(1) // server 端是作为一个守护进程在正常跑 &#123; // 阻塞等待新消息传入 newsd = accept(sd,(void *)&amp;raddr,&amp;raddr_len); if(newsd &lt; 0) &#123; if(errno == EINTR || errno == EAGAIN) continue; perror(\"newsd()\"); exit(1); &#125; inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE); printf(\"Client:%s:%d\\n\",ipstr,ntohs(raddr.sin_port)); //知悉对方是谁 server_job(newsd); // 解决sendto 问题的函数 close(newsd); // 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符， &#125; close(sd); // 正常情况下，执行不到 exit(0);&#125; 1234567891011121314$&gt; ./server$&gt; netstat -antProto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:1989 0.0.0.0:* LISTEN # 提到这个 State状态，当通过ctrl+c的方式 LISTEN会变为 TIME_WAIT, 并且服务无法被客户端访问，当再次启动服务端程序时，报错，bind(): address already in use.说明 1989这个端口还在工作当中，ctrl+c属于异常结束，程序中没法正确把socket实例释放掉。#当前被释放的资源 会被操作系统批量回收，也就是在说话期间，内核发现我们这个端口其实对应的socket已经被异常终止了。那么它就会帮你把这个资源释放掉。所以端口经过这个阶段就会变为一个free而可以使用的状态。再去bind就ok了。$&gt; nc 127.0.0.1 1989 # 使用系统提供的客户端工具发送请求 没有nc 可以用 telnet代替1597216327#serverClient:127.0.0.1:59672 client.c 是客户端，也就是主动端，它的发送端口可以不用手动指定而由操作系统来随机分配一个未被占用的端口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;errno.h&gt;#include \"proto.h\"int main(int argc, char *argv[])&#123; int sd; FILE *fp; struct sockaddr_in raddr; long long stamp; if(argc &lt; 2) &#123; fprintf(stderr,\"Usage...\\n\"); exit(1); &#125; // 使用 TCP 协议 sd = socket(AF_INET,SOCK_STREAM,0/*IPPROTO_TCP,IPPROTO_SCTP*/); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; raddr.sin_family = AF_INET; // 指定服务器的端口号 raddr.sin_port = htons(atoi(SERVERPORT)); // 指定服务端 IP 地址 inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr); // 发起连接请求 if(connect(sd,(void *)&amp;raddr,sizeof(raddr)) &lt; 0) &#123; perror(\"connect()\"); exit(1); &#125; fp = fdopen(sd,\"r+\"); // 把scoket 返回的文件描述符 封装成一个文件流来使用 if(fp == NULL) &#123; perror(\"fdopen()\"); exit(1); &#125; // 读取服务端的响应，当然也可以使用 recv(3P) 函数来替代 fscanf(3) 函数。 if(fscanf(fp,FMT_STAMP,&amp;stamp) &lt; 1) // 标准IO来 fprintf(stderr,\"fscanf() failed.\\n\"); else printf(\"stamp = %lld\\n\",stamp); fclose(fp); exit(0);&#125; 1.5.2 server端 并发版本重构 发现问题 12345678910111213141516171819202122232425262728293031323334353637// server.c 大部分时间在此段代码中重复循环while(1) // server 端是作为一个守护进程在正常跑&#123; // 阻塞等待新消息连接 newsd = accept(sd,(void *)&amp;raddr,&amp;raddr_len); if(newsd &lt; 0) &#123; if(errno == EINTR || errno == EAGAIN) continue; perror(\"newsd()\"); exit(1); &#125; inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE); printf(\"Client:%s:%d\\n\",ipstr,ntohs(raddr.sin_port)); //输出连接信息 server_job(newsd); // 主要处理请求函数， 阻塞10s，此函数阻塞10s的间隙，可能有几千个请求进来了。所以这个 请求函数应该变成一个并发的模式； close(newsd); &#125;static void server_job(int sd)&#123; char buf[BUFSIZE]; int len; len = sprintf(buf, FMT_STAMP,(long long)time(NULL)); if(send(sd,buf,len,0) &lt; 0) &#123; perror(\"send()\"); exit(1); &#125;// sleep(10) // 假如在这里停顿10s，表示如果此函数阻塞了，那后面的请求就无法进来了 return ;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// server#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include \"proto.h\"#define BUFSIZE 1024#define IPSTRSIZE 40static void server_job(int sd)&#123; char buf[BUFSIZE]; int len; len = sprintf(buf, FMT_STAMP,(long long)time(NULL)); if(send(sd,buf,len,0) &lt; 0) &#123; perror(\"send()\"); exit(1); &#125; return ;&#125;int main()&#123; int sd,newsd; struct sockaddr_in laddr/*local address*/, raddr /*remote address*/; socklen_t raddr_len; char ipstr[IPSTRSIZE]; pid_t pid; // 选择 TCP 协议 sd = socket(AF_INET,SOCK_STREAM,0/*IPPROTO_TCP,IPPROTO_SCTP*/); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; // SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动 // 会导致 bind 端口短暂失效的情况 int val = 1; // bool值，除了0就是1； if(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,sizeof(val)) &lt; 0) &#123; perror(\"setsockopt()\"); exit(1); &#125; laddr.sin_family = AF_INET; // 指定服务端使用的端口号 laddr.sin_port = htons(atoi(SERVERPORT)); inet_pton(AF_INET,\"0.0.0.0\",&amp;laddr.sin_addr.s_addr); // 绑定端口 if(bind(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0) &#123; perror(\"bind()\"); exit(1); &#125; /** * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经 * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个 * 数值的上限。 * 所以backlog 现在指能能够承受C端的全链接的大小 */ // 开始监听端口 if(listen(sd,200) &lt; 0) &#123; perror(\"listen()\"); exit(1); &#125; raddr_len = sizeof(raddr); while(1) // server 端是作为一个守护进程在正常跑 &#123; // 阻塞等待新消息传入 newsd = accept(sd,(void *)&amp;raddr,&amp;raddr_len); if(newsd &lt; 0) &#123; if(errno == EINTR || errno == EAGAIN) continue; perror(\"newsd()\"); exit(1); &#125; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid ==0) &#123; close(sd); // 子进程由于会拷贝一份 父进程的所有资源，包含sd，但子进程没有用到sd，所以需要关闭 inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE); printf(\"Client:%s:%d\\n\",ipstr,ntohs(raddr.sin_port)); //知悉对方是谁 server_job(newsd); // 解决sendto 问题的函数 close(newsd); // 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符， exit(0); // 子进程处理函数结果后，要结束进程 &#125; close(newsd); // 同样的，newsd 复制了一份给子进程，在父进程的域内，newsd没有被引用到了，所以需要主动去释放掉； &#125; close(sd); // 正常情况下，执行不到 exit(0);&#125; 总结 上面这个多进程版本虽然可以实现网络连接的并发问题，但假如请求服务端的客户端特别多的情况下，为每一个人都fork一个子进程。这个开销你能不能承受。又绕回去到老问题去了。实际情况下，根本没富裕的资源用来创造无限的进程空间来处理请求； 1.5.3 静态进程池重构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// 静态进程池版本#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include \"proto.h\"#define BUFSIZE 1024#define IPSTRSIZE 40#define PROCNUM 4static void server_job(int sd)&#123; char buf[BUFSIZE]; int len; len = sprintf(buf, FMT_STAMP,(long long)time(NULL)); if(send(sd,buf,len,0) &lt; 0) &#123; perror(\"send()\"); exit(1); &#125; return ;&#125;static void server_loop(int sd)&#123; struct sockaddr_in raddr; socklen_t raddr_len; raddr_len = sizeof(raddr); int newsd; char ipstr[IPSTRSIZE]; while(1) // server 端是作为一个守护进程在正常跑 &#123; // accept 本身就能实现单一的链接，也就是说它本身就能实现互斥 newsd = accept(sd,(void *)&amp;raddr,&amp;raddr_len); if(newsd &lt; 0) &#123; if(errno == EINTR || errno == EAGAIN) continue; perror(\"newsd()\"); exit(1); &#125; inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE); printf(\"[%d]Client:%s:%d\\n\",getpid(),ipstr,ntohs(raddr.sin_port)); //知悉对方是谁 server_job(newsd); // 解决sendto 问题的函数 close(newsd); // 不关的话会产生内存泄漏，下次循环到 accept会产生新的文件描述符， &#125;&#125;int main()&#123; int sd; pid_t pid; struct sockaddr_in laddr/*local address*/; // 选择 TCP 协议 sd = socket(AF_INET,SOCK_STREAM,0/*IPPROTO_TCP,IPPROTO_SCTP*/); if(sd &lt; 0) &#123; perror(\"socket()\"); exit(1); &#125; // SO_REUSEADDR 用来设置端口被释放后可立即被重新使用，防止关闭服务，立即重新启动 // 会导致 bind 端口短暂失效的情况 int val = 1; // bool值，除了0就是1； if(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,sizeof(val)) &lt; 0) &#123; perror(\"setsockopt()\"); exit(1); &#125; laddr.sin_family = AF_INET; // 指定服务端使用的端口号 laddr.sin_port = htons(atoi(SERVERPORT)); inet_pton(AF_INET,\"0.0.0.0\",&amp;laddr.sin_addr.s_addr); // 绑定端口 if(bind(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0) &#123; perror(\"bind()\"); exit(1); &#125; /** * int listen(int socket, int backlog); backlog 原来指半链接池大小，现在已经 * 变成你能够接受到的已经建立全链接的节点有多少。作为一个s端，你能承受的C端再多，也要有一个 * 数值的上限。 * 所以backlog 现在指能能够承受C端的全链接的大小 */ // 开始监听端口 if(listen(sd,200) &lt; 0) &#123; perror(\"listen()\"); exit(1); &#125; int i; for(i =0 ;i&lt; PROCNUM; i++) &#123; pid = fork(); if(pid &lt; 0) &#123; perror(\"fork()\"); exit(1); &#125; if(pid == 0) &#123; server_loop(sd); exit(0); &#125; &#125; for(i=0; i&lt;PROCNUM; i++) &#123; wait(NULL); &#125; close(sd); exit(0);&#125; 总结 当前静态进程池中就四个进程，如果每个服务要10s才能完成处理函数。这四个人肯定在某个时刻都在忙着。假如C端当前来了一万+请求，其实该程序也只能忙完当前四个再去忙下四个。这个池缺乏弹性。闲时四个进程闲置，千万级别并发请求时，四个进程也没法忙过来。 该模型能优化为动态进程池，比如当前池中最少有10个进程，最多可以容纳100个进程。闲时10个进程，十个accept在等着，防止访问激增。当请求来了，这10个进程能马上进入工作。父进程来主宰进程池中的状态，当发现进程池中10个常规进程都忙去了，父进程就需要动态创建新的进程去处理新任务了。要保证进程池中至少保证有10个闲置的进程在待命，当然进程池上限不超过200个。假如客户端真的有1万+，也管不了拉。进程池上限就是200个。一万个请求总归是会服务完了，当一个用户都没有的时候，进程池资源是需要释放到掉只保留常规的10个进程即可。总之，父进程需要管理不同状态下的进程池的增删改查。 模型在大一些，可以服务一个集群，根据负载均衡将请求分发给不同的服务器去处理； 1.5.4 动态进程池实现通过这几个栗子可以看出来，TCP 一般使用 recv(3P)、send(3P) 等函数来收发数据，而 UDP 一般使用 recvfrom(3P)、sendto(3P) 等函数来收发数据。因为 TCP 一开始就创建了稳定的链接，所以在通讯的过程中就不需要每次都指定对方的地址了。而 UDP 是报式传输协议，并没有建立一个稳定的链接，所以通讯的过程中要始终指定当前这个数据报要发送到哪里，或者是指明它是从哪里来的。 最后再补充一点：如果 Ctrl+C 结束服务端，再次启动后执行 bind(2) 就会报错。 bind(): Address already in use 使用 netstat -ant 命令会发现之前的链接都没有释放，且端口也没有释放，所以由于无法监听一个没有被释放的端口就报错了。 有两种办法，一种是等一会儿就好了，另一种是使用 setsockopt(2) 函数，这个在上面 server.c 的注释中说明过了，没有注意到的童鞋请翻到上面去参考一下。 为什么等一会儿就好了呢？因为操作系统会经常检查有哪些端口被无效的进程占用了，找到了就会释放这个端口。 在 bind(2) 之前使用 setsockopt(2) 函数，将 optname 设置为 SO_REUSEADDR，它表示如果占用当前端口的程序已经消亡了，那么重新使用这个端口。 1.5.5 抓包图片12345678910$&gt; eog xy.png # 打开一张图片$&gt; cp /home/hy/xy.png /var/www/html/test.jpg$&gt; ls /var/www/html/test.jpg$&gt; service httpd start# 浏览器127.0.0.1/test.jpg","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"信号","slug":"apue-6","date":"2020-12-16T06:52:39.000Z","updated":"2021-04-28T10:54:32.558Z","comments":true,"path":"2020/12/16/apue-6/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-6/","excerpt":"","text":"信号 信号的概念 signal(); 信号的不可靠 可重入函数 信号的响应过程（非常重要的图） 常用函数（kill raise alarm pause abort system sleep ） 信号集 信号屏蔽字/pending集的处理 扩展（sigsuspend sigaction setitimer） 实时信号 1. 并发到目前为止，之前写的程序还没有一个是异步运行的，全部都是同步运行的。 Linux 环境中的并发可以分为 多进程+信号 和 多线程两种，信号属于初级异步，多线程属于强烈异步。 在实际项目中信号和多线程基本不会一块儿使用，要么使用 多进程+信号 的形式，要么采用多线程的形式。 1.1 同步、异步， 异步意味着并发同步程序的特点是程序的执行流程、分支都是明确的。 异步事件的特点：事件到来的时间不确定，到来之后产生的结果是不确定的。比如在俄罗斯方块游戏中需要异步接收用户的方向控制输入，你永远无法知道用户什么时候按下方向键，以及按下哪个方向键。 1.2 异步事件的获取方式通常只有两种：查询法，通知法 如果当前这个异步时间发生的频率非常稀疏，就使用通知法。如果异步发生的频率高， 就使用主动的查询法； 假如我们使用一个烟雾传感器监测库房中是否发生了火灾，火灾的到来的时间就是一种异步事件。 我们可以通过两种方式获取是否发生了火灾： 1）查询法：传感器将状态写到一个位图当中，我们不停的查询位图的状态来得到传感器的最新监测结果。 2）通知法：当检测到火灾时传感器推送一个消息给我们，这样我们就不用不停的查询位图了。 1.3 那么什么情况使用查询法更好，什么情况使用通知法更好呢？异步事件到来的频率比较高的情况考虑使用查询法，因为撞到异步事件到来的概率比较高。 异步事件到来的频率比较稀疏的情况考虑通知法，因为比较经济实惠。 1.4 没有严格意义上的通知法 通知法的实现是需要在特定场景下的；因为通知法也必须满足一定的条件。比如订阅者需要保持接受的状态或者说保持能够准时接收到通知的状态。 所有的通知法都需要配合一个监听机制才行。否则比如你在垂钓，放下一个鱼竿之后你就走了，就算鱼上钩了你也不可能知道。 即使计算机中没有连接任何外部硬件设备，内核每秒钟也会发生成百上千个中断来打断正在运行的程序。 1.5 异步什么是真正的异步，单核的机器会出现真正意义的异步吗？ 回本溯源，不可打断的就是一条机器指令。在单核机器上，同时聊QQ，打游戏，听歌不是并发，而是大家轮流占用当前的处理器，但是每个人会有限定的时间片，当时间片耗尽，就需要进去就绪队列中排队。只不过操作系统的调度关系特别块，对于用户来讲，感知不到计算机做这样分时的实现。因此在单核机器上不会存在并发，不可能有两件事一起做的情况。 所以在单核 CPU 上其实是不存在真正意义上的异步的，你感受到的异步无非就是时间片切换给你带来的错觉。你以为你边听音乐边写程序，这两件事是同时进行的吗？其实内核在快速的不断的打断其中一个程序，然后再让另一个程序运行一会儿，如此往复，给你一种两件事情在同时发生的错觉。 时间片调度其实就是通过中断打断程序的执行，把时间片耗尽的进程移动到队列中等待。所以任何一个进程在执行的过程中都是磕磕绊绊的不断被打断的，程序在任何地方都可能被打断，唯独一条机器指令是无法被打断的（机器指令是原子的）。 比如你在执行一句 printf(“Hello World!\\n”); 的时候，看似是很流畅的打印出来了，但是执行过程中已经被打断很多次了。 2. 信号的概念 信号是软件中断， 信号的响应依赖于中断 信号不是中断，中断只能由硬件产生，信号是模拟硬件中断的原理在软件层面上进行的实现。设计信号这个机制的人，大概率有非常强的硬件中断的经验。所以在软件层面来模仿硬件的打断机制。可以使用 kill(1) 命令向其它进程查看或发送信号。 123456789101112131415$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX$#1 - 31 是标准信号，#34 - 64 是实时信号。 下面讨论的内容如果没有特殊说明则都是针对标准信号 信号有五种不同的默认行为：终止、终止+core、忽略、停止进程、继续。 core 文件就是程序在崩溃时由操作系统为它生成的内存现场映像和调试信息，主要是用来调试程序的，可以使用 ulimit(1) 命令设置允许生成的 core 文件的最大大小。 1）终止：使程序异常结束。还记得我们在前面的博文中提到的程序的 3 种异常终止情况吗？其中被信号杀死就是异常终止的一种。 2）终止+core：杀死进程，并为其产生一个 core dump 文件，可以使用这个 core dump 文件获得程序被杀死的原因。 3）忽略：程序会忽略该信号，不作出任何响应。 4）停止进程：将运行中的程序中断。被停止的进程就像被下了一个断点一样，停止运行并不会再被调度，直到收到继续运行的信号。当按下 Ctrl+Z 时就会将一个正在运行的前台进程停止，其实就是向这个进程发送了一个 SIGTSTP 信号。 5）继续：使被停止的进程继续运行。只有 SIGCONT 信号具有这项功能。 这里介绍下常用的标准信号，但是有时间所有的信号都要仔细的看（见《APUE》第三版 P252 - P256）。 信号 默认动作 说明 SIGABRT 终止+core 调用 abort(3) 函数会向自己发送该信号使程序异常终止，通常在程序自杀时使用。 SIGALRM 终止 调用 alarm(2) 或 setitimer(2) 定时器超时时向自身发送的信号。setitimer(2) 设置 which 参数的值为 ITIMER_REAL 时，超时后会发送此信号。 SIGCHLD（某些平台是 SIGCLD） 忽略 当子进程状态改变系统会将该信号发送给其父进程。状态改变是指由运行状态改变为暂停状态、由暂停状态改变为运行状态、由运行状态改变为终止状态等等。 SIGHUP 终止 如果终端接口检测到链接断开则将此信号发送给该终端的控制进程，通常会话首进程就是该终端的控制进程。 SIGINT 终止 当用户按下中断键(Ctrl+C)时，终端驱动程序产生此信号并发送给前台进程组中的每一个进程。大家经常使用 Ctrl + C 来杀死进程，这回知道是什么原理了吧？ SIGPROF 终止 setitimer(2) 设置 which 参数的值为 ITIMER_PROF 时，超时后会发送此信号。 SIGQUIT 终止+core 当用户在终端上按下退出键(Ctrl+)时，终端驱动程序产生此信号并发送给前台进程组中的所有进程。该信号与 SIGINT 的区别是，在终止进程的同时为它生成 core dump 文件。 SIGTERM 终止 使用 kill(1) 命令发送信号时，如果不指定具体的信号，则默认发送该信号。 SIGUSR1 终止 用户自定义的信号。有童鞋说不明白什么是用户自定义的信号，其实所谓自定义的信号就是系统不赋予它什么特殊的意义，你想用它来做什么都行，根据你的程序逻辑为它定义好相应的信号处理函数就行了。 SIGUSR2 终止 另一个用户自定义的信号，作用同上。 SIGVTALRM 终止 setitimer(2) 设置 which 参数的值为 ITIMER_VIRTUAL 时，超时后会发送此信号。 表1 常见的标准信号 signal(2) 123456789101112// signal - ANSI C signal handling#include &lt;signal.h&gt;/* man 手册中定义的写法 */typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);/* APUE 课本上的写法 */void (*signal (int signo, void (*func) (int))) (int); signal(2) 函数的作用是为某个信号注册一个信号处理函数。 课本上的写法比 man 手册中的写法更好，因为 sighandler_t 这个名字纯属手册捏造出来的，如果某一天标准库发布了一个函数的名字恰巧也叫 sighandler_t，那么手册就出问题了，这是C 语言名空间管理不善导致的。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;int main()&#123; int i; for(i=0; i&lt; 10; i++) &#123; write(1,\"*\", 1); sleep(1); &#125; exit(0);&#125; 123./star********** # 打印十次之后进程结束，如果在没到10次时，ctrl+c 相当于SIGINT 的快捷方式 参数列表： singno：1 - 31 是标准信号，34 - 64 是实时信号，当然也可以使用 kill(1) -l 所列出的宏名； func：收到信号时的处理行为，也就是信号处理函数； 也可以使用 SIG_DEF 和 SIG_IGN 两个宏来替代。 SIG_DEF 表示使用信号的默认处理行为。 SIG_IGN 表示忽略该信号。 返回值：原来的信号处理函数。有时候我们在定义自己的信号处理函数之前会把原来的信号处理函数保存下来，这样当我们的库使用完之后需要还原原来注册的信号处理函数，避免因为调用了我们的库而导致别人的库失效的问题。 12345678910111213141516// 用 SIG_IGN 来忽略信号#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;int main()&#123; int i; signal(SIGINT, SIG_IGN); // 忽略掉信号 for(i=0; i&lt; 10; i++) &#123; write(1,\"*\", 1); sleep(1); &#125; exit(0);&#125; 12$ ./star1******^C**** # ctrl+c 无法阻断进程 123456789101112131415161718192021222324// 用回调函数来 反馈信号#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;static void handler (int s)&#123; write(1, \"!\", 1);&#125;int main(void)&#123; int i = 0; signal(SIGINT, handler); for (i = 0; i &lt; 10; i++) &#123; write(1, \"*\", 1); sleep(1); &#125; return 0;&#125; 这个程序运行起来之后，每秒钟会打印一个星号（*），当按下 Ctrl+C 时会打印一个感叹号（!），直到 10 秒钟后程序退出，下面是不停的按 Ctrl+C 的运行结果。 12345678$ gcc -Wall signal.c$ time ./a.out*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C!*^C! # 按住ctrl c不放，程序运行不到10秒就结束！real 0m1.656suser 0m0.000ssys 0m0.002s$ 2.1 信号会打断阻塞的系统调用通过 time(1) 命令可以测试出来，程序并没有持续 10 秒钟才结束，这是因为信号会打断阻塞的系统调用，也就是说 SIGINT 这个信号打断了 sleep(3)。 如果加上信号机制的话，那么前面学习的例子没有一个是对的； 比如使用 read(2) 函数读取一个设备的时候，当设备中没有充足的数据供读取时，read(2) 函数会进入阻塞等待数据的状态，这时候如果收到了一个信号就会打断阻塞中的 read(2) 函数，它会设置 EINTR 的 errno。所以收到函数报错的时候往往需要判断一下是否被信号打断了，如果是被信号打断的，还要重新再执行一次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define BUFSIZE 1024int main (int argc, char **argv)&#123; int sfd, dfd; char buf[BUFSIZE]; int len; int ret; int pos; if (argc &lt; 3) &#123; fprintf(stderr, \"Usage .... \\n\"); &#125;; do&#123; sfd = open(argv[1], O_RDONLY); if (sfd &lt; 0) &#123; if(errno != EINTR) // 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行 &#123; perror(\"open()\"); exit(1); &#125; &#125; &#125; while(sfd &lt; 0); do&#123; dfd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0600); if (dfd &lt; 0) &#123; if(errno != EINTR)// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行 &#123; close(sfd); perror(\"open()\"); exit(1); &#125; &#125; &#125; while(dfd &lt; 0); len = 0; ret = 0; while(1) &#123; len = read(sfd,buf, BUFSIZE); if (len &lt;0 ) &#123; if(errno == EINTR)// 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行 continue; perror(\"read()\"); break; &#125; if (len == 0) &#123; break; &#125; pos = 0; while(len &gt; 0) &#123; ret = write(dfd, buf+pos, len); if (ret &lt; 0) &#123; if(errno == EINTR) // 碰到错误时，校验程序是否被信号打断而报的错，如果是被信号打算则忽略不计，继续循环执行 continue; perror(\"write()\"); exit(1); &#125;; pos += ret; len -= ret; &#125; &#125;; close(dfd); close(sfd); exit(0);&#125; 2.2 竞争当学习了信号之后，我们的程序中就出现异步的情况了，只要是异步的程序就可能会出现竞争，先来了解下什么是竞争。 竞争：一个十字路口没有红绿灯，两辆不同方向驶来车可能会发生碰撞，而且碰撞可能很严重也可能很轻微。当安装上红绿灯之后就相当于增加了一个协议，如果没有这个协议的限制，大家就可以随意的使用公共资源了，你在十字路口中间跳广场舞也可以。所以为了避免竞争带来的后果，我们会使用一些协议来避免竞争的发生。 当然，避免竞争的办法我们后面会讨论。 3. 信号的不可靠 标准信号会丢失 不可靠的信号 很多人看到了不可靠的信号这一章节，就认为因为额信号会丢失所以是不可靠的，其实这么理解是不对的，不可靠的信号是指信号的行为不可靠。 信号的处理就好比现在 LZ 正在写这篇博文，忽然来了一个电话，于是打断了手头的工作，先接电话去了。 信号处理函数的执行现场不是程序员布置的，而是内核布置的，因为程序中不会有调用信号处理函数的地方。 同一个信号处理函数的执行现场会被布置在同一个地方，所以当一次信号处理函数未执行完成时再次触发了相同的信号，信号处理函数发生了第二次调用，则第一次调用的执行现场会被覆盖。基于此，出过各种馊主意。有用队列存的，还有不管多少信号只执行第一次的回调函数，其他时候执行默认行为的。（比如上上面的例子，第一次执行ctrl+c打印出 ！，第二次执行ctrl+c 直接取ctrl+c默认行为，把进程杀了 😳） 4. 可重入函数 所有的系统调用都是可重入的，一部分库函数也是可重入的。尤其是返回值是一个指针的函数。比如说： memcpy 函数重入乍一看上去像是递归，但又是有区别的，递归调用的现场是程序员布置的，而重入是在一个函数执行未结束时再次发生了调用并且进入了同一个函数现场。 重入时函数会发生错误的函数称为“不可重入函数”，重入不会出现错误的函数叫做“可重入函数”。 所有的系统调用都是可重入函数，所以信号处理函数中可以放心的使用系统调用。但并不是说所有的非系统调用都是不可重入的。 man 手册所有的函数中如果有一个同名的带 _r 后缀的函数，那么不带_r 后缀的函数是不可重入的函数，而带 _r 后缀的函数是可重入的函数。比如下面这两个常见的函数： 1234567891011 // strerror, strerror_r - return string describing error number#include &lt;string.h&gt;char *strerror(int errnum);int strerror_r(int errnum, char *buf, size_t buflen);/* XSI-compliant */char *strerror_r(int errnum, char *buf, size_t buflen);/* GNU-specific */ 5. 信号的响应过程 这部分知识涉及调度问题，信号软件层面的中断， 信号从收到到响应是有一个不可避免的延迟， 思考： 如何忽略掉一个信号的？ 思考： 标准信号为什么要丢失 标准信号的响应没有严格的顺序（先响应哪个不知道，可能会根据优先级大小决定响应顺序，碰到优先级差不多的响应顺序不确定） 不能从信号处理函数中随意的往外跳 信号从收到到响应是有一个不可避免的延迟 因为只收到信号是体现在padding位图上，由0变成了1.要有中断来打断才能够去内核排队。从kernel回到user的时候，要做 mask&amp;padding 按位与才能看到这个信号。所以，信号就有一个不可避免的时延； 如何忽略掉一个信号的？ 把某个信号的mask位永远置成0； 标准信号为什么要丢失 位图，一万次1还是1，最终在执行信号回调的时候是需要 mask&amp;padding的， 通过这个按位与的结果来决定是否有收到该信号的 先把模型缩小 当程序在正常运行的时候，mask为1，padding为0；突然接到一个信号，mask继续是1，padding 变成了1. 这个时候被中断打断了，加内核排队。等待调度的时候往外走，当从kernel态回到user态的时候。拿 mask&amp;padding 做一个按位与，发现收到了1个信号了。然后再执行信号响应回调的时候，把mask和padding都置成0的，然后去执行响应回调。等执行完响应之后，把mask置成1.padding继续保持是0. 然后再做一次按位与，ok，发现没有信号了。然后程序执行其他的去了。 再把模型放大 当前没有信号的时候，mask为1，padding为0（初始化的状态）。当执行过程中，收到信号了，mask继续是1，padding变成1. 然后继续 中断。。排队。。调度。。kernel -》user 。。按位与。。。发现有信号。。执行响应回调前， 把 mask 和 padding 都置成0. 在这个时候又来了一个或者十万个信号，那么 mask继续是0， 而padding 被反复置换成1（置1次1，或者十万次1，位图不会累加，不会计数，不管多少次1，最终还是1）.所以这里会丢失信号。 标准信号的响应没有严格的顺序 不能从信号处理函数中随意的往外跳 6.1 可靠信号术语和语义这是信号这章比较重要的内容，通过这个我们来了解信号在 Linux 系统中是如何实现的。 图1 标准信号的处理过程（从进程角度来分析应该的响应过程） 进程线程并不分家，从内核的角度来看，当前操作的任务只有一个，叫线程。从开发者的角度来讲，先产生的概念叫进程，后来发现其实不是这么回事儿，其实细化到线程来进行调度。进程是容器。所以进程和线程其实是 开发者角度去区分的。从内核的角度来讲，内核只有进程一个概念。进程线程不分家，开发者完全可以做出既不是线程也不是进程的东西来使用。 内核为每个进程维护了一组位图（两个位置），mask（信号屏蔽字）和 padding， 理论来讲， mask 和 padding都是 32位的。mask用来表示当前的信号的状态，padding是一个位图，用来记录当前这个进程收到哪些信号。 mask屏蔽字的值一般情况下都是1，padding位初始值一上来初始值为0。都知道程序会被中断（打断），举个例子，比如说时间片耗尽了，实际上也可以理解为某种形式反映给你的中断。然后要抱着当前的执行现场扎内核（把当前的执行现场压栈存放，相当于整个进程暂停起来，然后去到内核）。内核中有个等待调度的就绪队列，然后在那里进行排队。排队等待调度到你的时候，别人把调度器出让给你。这个时候相当于你重新被调用。然后再从刚才（刚才已经压栈了一个现场）的现场进程恢复，来继续进行下面的程序。然后在执行过程当中，又被别人打断了。然后重复前面说的过程。继续压栈，排队，等待调度，恢复现场执行等等这样一个过程。 mask 和 padding 位图是一一对应的，它们用于反映当前进程信号的状态。每一位代表了一个标准信号。 mask 位图用于记录哪些信号可以响应。1 表示该信号可以响应，0 表示该信号不可响应（会被忽略）。 padding 位图用于记录收到了哪些信号。1 表示收到了该信号，0 表示没有收到该信号。 前面说过了，程序在执行的过程中会被内核打断无数次，也就是说程序被打断后要停止手头的工作，进入一个队列排队等待再次被调度才能继续工作。 当进程获得调度机会后，从内核态返回到用户态之前要做很多事情，其中一件事就是将 mask 位图和 padding 位图进行 &amp; 运算，当计算的结果不为 0 时就需要调用相应的信号处理函数或执行信号的默认动作。 这就是 Linux 的信号处理机制，从这个机制中，我们可以总结出几个信号的特点： 1）如果想要屏蔽某个信号，只需将对应的 mask 位 置为 0 即可。这样当程序从内核态返回用户态进行 mask &amp; padding 时，该信号位的计算结果一定为 0。 2）信号从收到到响应是存在延迟的，一般最长延迟 10 毫秒。因为只有程序被打断并且重新被调度的时候才有机会发现收到了信号，所以当我们向一个程序按下 Ctrl+C 时程序并没有立即挂掉，只不过这个时间非常短暂我们一般情况下感觉不到而已，我们自己以为程序是立即挂掉了。其实想要实验也很容易，写一个死循环不断打印一个字符，然后在它跑起来的时候按下 Ctrl+C，你会发现并不是打印了 ^C 之后程序会立即停止，而是继续打印了一些字符之后才停止。 3)当一个信号没有被处理时，无论再次接受到多少个相同的信号都只能保留一个，因为 padding 是位图，位图的特点就是只能保留最后一次的状态。这一点说的就是标准信号会丢失的特点，如果想要不丢失信号就只能使用实时信号了。 4）信号处理函数轻易不允许使用 longjmp(3) 进行跨函数跳转。因为处理信号之前系统会把 mask 对应的位设置为 0 来避免信号处理函数重入，当信号处理完成之后系统会把对应的 mask 位设置为 1 恢复进程对该信号的响应能力。如果进行了长跳转系统就不会恢复 mask 位图了，也就再也无法收到该信号了。其实这个图只是一个草图，信号实际上是线程级别的（这个我们在后面讲到线程的时候会详细讨论），所以即使 mask 位图在处理前被置为 0，依然有可能出现重入的现象，因为无法保证兄弟线程也同步屏蔽了相应的位。 5）信号处理函数的执行时间越短越好，因为信号处理函数是在用户态执行的，在它的执行过程中也会不停的被内核打断，所以如果信号处理函数执行的时间过长会使情况变得复杂。 6）信号的响应是嵌套执行的。就是说假设进程先收到了 SIGINT 信号，当它的信号处理函数还没有执行完毕时又收到了另一个信号 SIGQUIT，那么当进程从内核态返回到用户态时会优先执行 SIGQUIT 的信号处理函数，等 SIGQUIT 的信号处理函数执行完毕后再回到 SIGINT 信号处理函数上次被打断时的地方继续执行，函数调用栈看上去就像在 SIGINT 的信号处理函数中调用了 SIGQUIT 的信号处理函数一样。这也是上面所说的为什么信号处理函数的执行时间要越短越好，要尽量避免这种复杂的情况发生。 7）如果同时到来多个优先级差不多的信号，无法保证优先响应哪个信号，它们的响应没有严格意义上的顺序。除非是收到了优先级较高的信号，系统会保证高优先级的先被处理。 6.2 信号处理函数 信号处理函数 尽量使用可重入的函数，系统调用可以，一部分库函数可以。然后由于在信号当中不能用到大家都在用的东西，防止产生竞争和冲突，比如标准IO是不能用在信号处理函数当中的。因为公用缓冲区，防止别人在用缓冲区，自己也在用缓冲区。就会存在问题。信号处理函数还应该做到尽量小，小到尽量能够一闪而过才好。 6. 信号常用函数kill raise alarm pause abort system sleep 6.1 kill(2)123// kill - send a signal to a process or a group of processes#include &lt;signal.h&gt;int kill(pid_t pid, int sig); kill(2) 函数的作用是将指定的信号(sig)发送给指定的进程(pid)。 大家一看到 kill 就觉得有杀死进程的意味，其实未必如此，kill(3) 也负责给进程发送各种信号。 参数列表： pid：接收信号的进程 ID。可填的内容详见下表： 值 说明 &gt;0 接收信号的进程 ID。 ==0 发送信号给当前进程所在进程组的所有进程。 ==-1 发送信号给当前进程有权向它们发送信号的所有进程，1 号 init 进程除外。相当于一个全局广播信号，发送这种信号一般只有 1 号 init 会做，比如在关机的时候 init 进程会发送全局广播信号通知大家该结束了。 &lt;-1 将 pid 的绝对值作为组 ID，给这个组中所有的进程发送信号。 表2 kill(2) 函数 pid 参数的取值 sig：要发送的信号，可以使用 kill(1) -l 所列出的信号。如果 sig 是 0 会执行所有的错误检查，但并不真正发送信号。所以通常使用 0 值检查一个进程是否仍然存在，如果该进程不存在则返回 -1 并将 errno 设置为 ESRCH。需要注意的是这种检查并不原子，当 kill(2) 返回测试结果的时候也许被测试的进程已经终止了。当然也可以测试当前进程是否对目标进程有权限发送信号，如果 errno 为 EPERM 表示被测试的进程存在但当前进程无权限访问。 返回值：成功为 0，失败为 -1，并设置 errno。 6.2 raise12345678910// send a signal to the caller 对当前进程发一个信号#include &lt;signal.h&gt;int raise(int sig);// 此方法 单线程模式 相当于kill(getpid(), sig); // 以进程单位发信号// 此方法 多线程模式 相当于pthread_kill(pthread_self()); // 以线程为单位发 6.3 pause(3P)1234// pause - wait for signal#include &lt;unistd.h&gt;int pause(void); 专门用于阻塞当前进程，等待一个信号来打断它。 6.4 alarm(3P)1234// alarm - schedule an alarm signal#include &lt;unistd.h&gt;unsigned alarm(unsigned seconds); 指定 seconds 秒，发送一个 SIGALRM 信号给自己。 seconds 为 0 的时候，表示取消这个定时器，并且新设置的值会覆盖上次设置的值。所以当程序中出现了多个对 alarm(3P) 的调用时，计时是不准确的。 思考： 那如何用一个单一的计时器，来实现一个多任务的计时器 注意，SIGALRM 信号默认动作是杀死进程。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; alarm(5); alarm(1); // 新设置的值会覆盖上次设置的值。 while(1); exit(0);&#125;// 1 秒 之后结束程序// alarm没办法实现多任务的 计时器 上面提到 新设置的值会覆盖上次设置的值，当程序中出现了多个对 alarm(3P) 的调用时，计时是不准确的。 sleep -&gt; alarm + pause 尽量不要用sleep的原因 是因为在有些环境下， sleep是用 alarm 和 pause 封装的。 有些环境的sleep是用nanosleep封装的。所以考虑移植的情况下，不要在程序中使用 sleep。 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; alarm(5); // 5秒后 杀死进程 while(1) pause(); // 阻塞当前进程，等待信号 exit(0);&#125; 定时循环实验 1234567891011121314151617181920// 5sec.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; time_t end; int64_t count = 0; end = time(NULL) + 5; while(time(NULL) &lt;= end) &#123; count++; &#125; printf(\"%lld\\n\", count); exit(0);&#125; 123456789time ./5sec &gt; /tmp/out5.49s user0.00s system94% cpu5.831 totalcat /tmp/out2044174125 123456789101112int main()&#123; int64_t count = 0; alarm(5); // 5秒钟后杀掉进程 while(1) count++; printf(\"%lld\\n\", count); // 5秒后进程被杀，没机会打印printf了 exit(0);&#125;// 该功能无法通过 这种方式来实现 我们来看看代码 count_alarm.c、count_time.c，哪个效率更高。 1234567891011121314151617181920212223242526272829303132/* count_alarm.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;long long count = 0;static volatile int flag = 1;void alarm_handler (int s)&#123; flag = 0;&#125;int main (void)&#123; // 注意 signal 再 alarm之前 signal(SIGALRM, alarm_handler); // 先设置信号回调 alarm(5); // 再设置时钟 flag = 1; while (flag) &#123; count++; &#125; printf(\"%lld\\n\", count); return 0;&#125; 12345678910111213141516171819/* count_time.c */#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main (void)&#123;long long count = 0; time_t t; t = time(NULL) + 5; while (time(NULL) &lt; t) &#123; count++; &#125; printf(\"%lld\\n\", count); return 0;&#125; 编译运行： 12345678910111213141516$ make count_alarm count_timecc count_alarm.c -o count_alarmcc count_time.c -o count_time$ time ./count_alarm2374311494real 0m5.004suser 0m4.780ssys 0m0.194s$ time ./count_time2139947real 0m4.152suser 0m4.116ssys 0m0.021s$ 通过执行结果可以看出来，alarm(3P) 的方式和 time(2) 的方式执行效率竟然差了 1000 多倍，当然这个简单的测试精度是不高的。 上面的代码通过 gcc count_alarm.c -O1 优化之后就无法正确执行了。 我们先把 count_alarm.c 编译成汇编代码再讨论它为什么被优化之后无法正确执行了。 优化前： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&gt;$ gcc -S count_alarm.c -o count_alarm.S&gt;$ vim count_alarm.S ; ...... 省略不相关代码alarm_handler:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl %edi, -4(%rbp) movl $0, flag(%rip) ; 修改 flag 的值 leave .cfi_def_cfa 7, 8 ret .cfi_endproc ; ...... 省略不相关代码main:.LFB1: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $alarm_handler, %esi movl $14, %edi call signal movl $5, %edi call alarm movl $1, flag(%rip) jmp .L4.L5: movq count(%rip), %rax addq $1, %rax movq %rax, count(%rip).L4: movl flag(%rip), %eax testl %eax, %eax ; 每次循环会检测 flag 的值是否改变 jne .L5 movq count(%rip), %rdxmovl $.LC0, %eax movq %rdx, %rsi movq %rax, %rdi movl $0, %eax call printfmovl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc ; ...... 省略不相关代码 优化后： 1234567891011121314151617181920212223242526272829&gt;$ gcc -S count_alarm.c -O1 -o count_alarm1.S&gt;$ vim count_alarm1.S ; ...... 省略不相关代码alarm_handler:.LFB21: .cfi_startproc movl $0, flag(%rip) ; 修改 flag 的值 ret .cfi_endproc ; ...... 省略不相关代码main:.LFB22: .cfi_startproc subq $8, %rsp .cfi_def_cfa_offset 16 movl $alarm_handler, %esi movl $14, %edi call signal movl $5, %edi call alarm movl $1, flag(%rip).L4: jmp .L4 ; 变成了死循环 .cfi_endproc; ...... 省略不相关代码 从上面的代码不难看出，优化时编译器认为 flag 的值一直没有改变，所以直接把 flag 的值拿过来作为循环条件了，每次循环的时候不再从 flag 变量所在的内存位置取值了。 为了避免编译器犯这种错误，我们需要把 flag 定义成 volatile 变量，volatile 关键字表示一定要到变量定义的位置取变量的值，而不要轻信曾经拿到的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// mycat 初步实现#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define BUFSIZE 1024int main (int argc, char **argv)&#123;int sfd, dfd=1; // 目标文件改成标准输出位，1号文件描述符即标准输出位char buf[BUFSIZE];int len;int ret;int pos;if (argc &lt; 2) &#123; fprintf(stderr, \"Usage .... \\n\");&#125;;do&#123; sfd = open(argv[1], O_RDONLY); if (sfd &lt; 0) &#123; if(errno != EINTR) &#123; perror(\"open()\"); exit(1); &#125; &#125;&#125; while(sfd &lt; 0);// do&#123;// dfd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0600);// if (dfd &lt; 0)// &#123;// if(errno != EINTR)// &#123;// close(sfd);// perror(\"open()\");// exit(1);// &#125;// &#125;// &#125; while(dfd &lt; 0);len = 0;ret = 0;while(1)&#123; len = read(sfd,buf, BUFSIZE); if (len &lt;0 ) &#123; if(errno == EINTR) continue; perror(\"read()\"); break; &#125; if (len == 0) &#123; break; &#125; pos = 0; while(len &gt; 0) &#123; ret = write(dfd, buf+pos, len); if (ret &lt; 0) &#123; if(errno == EINTR) continue; perror(\"write()\"); exit(1); &#125;; pos += ret; len -= ret; &#125;&#125;;close(dfd);exit(0);&#125; 6.5 流量控制（流控算法）播放音乐和电影的时候都要按照播放的速率读取文件，而不能像 cat(1) 命令一样，直接将交给它的文件用最快的速度读取出来，否则你听到的音乐就转瞬即逝了。 我们先通过一个栗子了解下什么是流量控制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// slowcat 的实现#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#define CPS 10#define BUFSIZE CPSstatic volatile int loop = 0;static void alrm_handler(int s)&#123; alarm(1); loop = 1;&#125;int main (int argc, char **argv)&#123; int sfd, dfd=1; // 目标文件改成标准输出位，1号文件描述符即标准输出位 char buf[BUFSIZE]; int len; int ret; int pos; if (argc &lt; 2) &#123; fprintf(stderr, \"Usage .... \\n\"); &#125;; signal(SIGALRM, alrm_handler); alarm(1); do&#123; sfd = open(argv[1], O_RDONLY); if (sfd &lt; 0) &#123; if(errno != EINTR) &#123; perror(\"open()\"); exit(1); &#125; &#125; &#125; while(sfd &lt; 0); len = 0; ret = 0; while(1) &#123; while(!loop) &#123; pause(); // &#125; loop = 0; while((len = read(sfd,buf, BUFSIZE))&lt;0) // 假如读取的 sfd 是一个设备，现在这个 设备没有数据，我们都知道程序中信号总会到来，所以 一直 continue， 程序就在这个while语句里面一直打转。 // 另外，如果当前数据量非常大的话，那程序在这里也无能为力，因为1秒钟也只能读取 10个字节。 // 这里是一个 漏桶的实现，可以看见 当前数据量不管有多少，这里只慢慢的10个字节10个字节的读。如果没有数据也只能闲着。读不到东西，假错，continue，死循环。 &#123; if(errno == EINTR) continue; perror(\"read()\"); break; &#125; if (len == 0) &#123; break; &#125; pos = 0; while(len &gt; 0) &#123; ret = write(dfd, buf+pos, len); if (ret &lt; 0) &#123; if(errno == EINTR) continue; perror(\"write()\"); exit(1); &#125;; pos += ret; len -= ret; &#125; &#125;; close(dfd); exit(0);&#125; 前面文件 IO 的部分我们做过一个栗子 mycp，用来模仿 cp(1) 命令。这次我们把它修改为 mycat，用来模仿 cat(1) 命令，并且是慢慢的 cat，每秒钟输出 10 个字节的数据。 这个流控方案就是漏桶：当没有数据可读的时候就是闲着，并没有积攒权限，所以当数据再次可读的时候它的速率不会变。 我们前面提到过，stream 这种东西并非像小河流水一样是非常均匀的潺潺细流，而是要么没有数据，要么一下子来一大坨。如果用漏桶处理这种情况速度会非常慢，那么有没有什么更好的流控方案呢？当然有，用令牌桶来处理就可以很好的解决这种流量激增的情况。 令牌桶闲着的时候在积攒权限，既然有1秒钟可以传输10个字节的权限，那就攒着。如果暂停3秒钟，就攒下了传输30个字节的权限。这个时候突然来了一大波数据，然后瞬间就可以把这30个字节都解决掉。权限没有了，就只能一秒钟10个字节 10个字节的走。这种就叫做令牌桶 所以实际使用时令牌同比漏桶用得更普遍。 具体要用哪种桶需要根据实际需求来决定，比如在线听音乐的时候网速不好，不能等数据来了的时候用最快的速度把之前积攒了权限的数据一下子都播放出来，应当还保持原来的速率播放，所以这时候选择漏桶就更加合适了。 下面我们重构一下上面的漏桶流控代码，把它改成令牌桶的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#define CPS 10 // 流量速率#define BUFSIZE CPS#define BURST 100 // 令牌上限// 积攒的令牌数量static volatile sig_atomic_t token = 0; // sig_atomic_t 信号原子类型，保证该类型的取值和赋值操作一定是一条机器指令static void alrm_handler(int s)&#123; alarm(1); token++; if(token &gt; BURST) token = BURST;&#125;int main (int argc, char **argv)&#123; int sfd, dfd=1; // 目标文件改成标准输出位，1号文件描述符即标准输出位 char buf[BUFSIZE]; int len; int ret; int pos; if (argc &lt; 2) &#123; fprintf(stderr, \"Usage .... \\n\"); &#125;; signal(SIGALRM, alrm_handler); alarm(1); do&#123; sfd = open(argv[1], O_RDONLY); if (sfd &lt; 0) &#123; if(errno != EINTR) &#123; perror(\"open()\"); exit(1); &#125; &#125; &#125; while(sfd &lt; 0); len = 0; ret = 0; while(1) &#123; while (token &lt;= 0) &#123; // 如果令牌数量不足则等待添加令牌 pause(); // 因为添加令牌是通过信号实现的，所以可以使用 pause(2) 实现非忙等（通知法） &#125; token--; // 每次读取 BUFSIZE 个字节的数据时要扣减令牌 while((len = read(sfd,buf, BUFSIZE))&lt;0) &#123; if(errno == EINTR) continue; perror(\"read()\"); break; &#125; if (len == 0) &#123; break; &#125; pos = 0; while(len &gt; 0) &#123; ret = write(dfd, buf+pos, len); if (ret &lt; 0) &#123; if(errno == EINTR) continue; perror(\"write()\"); exit(1); &#125;; pos += ret; len -= ret; &#125; &#125;; close(dfd); exit(0);&#125; 当然这只是一个简单的令牌桶的雏形，不过已经足以让我们了解令牌桶的工作原理了。 令牌桶的三要素：令牌、令牌上限、流量速率（CPS）。 从上面的代码可以看出来：SIGALRM 的回调函数负责向令牌桶中添加令牌，而每次读取数据之前要先检查令牌的剩余数量。如果令牌充足则扣减令牌后开始读取数据，如果令牌数量不足则阻塞等待 SIGALRM 回调函数向令牌桶中补充令牌。 设计令牌上限是为了防止令牌桶溢出，通常没必要让令牌无限制的上涨。 6.6 封装令牌桶库用户进行一个程序当中多个不同速率的流控的时候，该如何去做。 把行为封装起来，把更改属性的接口暴露给用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// mytbf.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"mytbf.h\"#include &lt;signal.h&gt;#include &lt;errno.h&gt;typedef void (*sighandler_t)(int);static struct mytbf_st* job[MYTBF_MAX];static int inited = 0;static sighandler_t alrm_handler_save;struct mytbf_st&#123; int cps; int burst; int token; int pos;&#125;;static void module_unload(void)&#123; int i; signal(SIGALRM, alrm_handler_save); alarm(0); for(i=0; i&lt; MYTBF_MAX; i++) &#123; free(job[i]); &#125;&#125;static int get_free_pos(void)&#123; int i; for(i =0; i&lt;MYTBF_MAX; i++) &#123; if(job[i] == NULL) return i; &#125; return -1;&#125;static void alrm_handler(int s)&#123; int i; alarm(1); for(i=0; i&lt; MYTBF_MAX; i++) &#123; if(job[i]!= NULL) &#123; job[i]-&gt;token += job[i]-&gt;cps; if(job[i]-&gt;token &gt; job[i]-&gt;burst) job[i]-&gt;token = job[i]-&gt;burst; &#125; &#125;&#125;static void module_load(void)&#123; alrm_handler_save = signal(SIGALRM, alrm_handler); alarm(1); atexit(module_unload);&#125;mytbf_t *mytbf_init(int cps, int burst)&#123; int pos; struct mytbf_st *me; if(!inited) &#123; module_load(); inited = 1; &#125; pos = get_free_pos(); // 在数组中 找空位 if(pos &lt; 0) return NULL; me = malloc(sizeof(*me)); if (me == NULL) return NULL; me-&gt;token = 0; me-&gt;cps = cps; me-&gt;burst = burst; me-&gt;pos = pos; job[pos] = me; //将该结构体存储至 数组中 return me;&#125;static int min(int a, int b)&#123; if(a&lt;b)&#123; return a; &#125; return b;&#125;int mytbf_fetchtoken(mytbf_t *ptr, int size)&#123; int n; struct mytbf_st *me = ptr; if(size &lt;= 0) return -EINVAL; while(me-&gt;token &lt;= 0) &#123; pause(); &#125; n = min(me-&gt;token, size); me-&gt;token -= n; return n;&#125;int mytbf_returntoken(mytbf_t * ptr, int size)&#123; struct mytbf_st *me = ptr; if(size &lt;= 0) return -EINVAL; me-&gt;token += size; if(me-&gt;token &gt; me-&gt;burst) me-&gt;token = me-&gt;burst; return size;&#125;int mytbf_destroy(mytbf_t *ptr)&#123; // 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos struct mytbf_st *me = ptr; job[me -&gt; pos] = NULL; free(ptr); return 0;&#125; 123456789101112131415// mytbf.h#ifndef MYTBF_H__#define MYTBF_H__#define MYTBF_MAX 1024typedef void mytbf_t;mytbf_t * mytbf_init(int cps, int burst);int mytbf_fetchtoken(mytbf_t *, int);int mytbf_returntoken(mytbf_t *, int);int mytbf_destroy(mytbf_t *);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// main.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#define CPS 10#define BUFSIZE 1024#define BURST 100#include \"mytbf.h\"int main (int argc, char **argv)&#123; int sfd, dfd=1; // 目标文件改成标准输出位，1号文件描述符即标准输出位 char buf[BUFSIZE]; int len; int ret; int pos; mytbf_t *tbf; if (argc &lt; 2) &#123; fprintf(stderr, \"Usage .... \\n\"); &#125;; tbf = mytbf_init(CPS, BURST); if(tbf == NULL) &#123; fprintf(stderr, \"mutbf_int() failed!\\n\"); exit(1); &#125; do&#123; sfd = open(argv[1], O_RDONLY); if (sfd &lt; 0) &#123; if(errno != EINTR) &#123; perror(\"open()\"); exit(1); &#125; &#125; &#125; while(sfd &lt; 0); len = 0; ret = 0; while(1) &#123; int size; size = mytbf_fetchtoken(tbf, BUFSIZE); if(size &lt; 0) &#123; fprintf(stderr, \"mytbf_fetchtoken():%s\", strerror(-size)); exit(1); &#125; while((len = read(sfd,buf, size))&lt;0) &#123; if(errno == EINTR) continue; perror(\"read()\"); break; &#125; if (len == 0) &#123; break; &#125; if(size - len &gt; 0) &#123; mytbf_returntoken(tbf, size-len); &#125; pos = 0; while(len &gt; 0) &#123; ret = write(dfd, buf+pos, len); if (ret &lt; 0) &#123; if(errno == EINTR) continue; perror(\"write()\"); exit(1); &#125;; pos += ret; len -= ret; &#125; &#125;; close(dfd); mytbf_destroy(tbf); exit(0);&#125; 6.7 实现计时器 使用单一计时器，利用alarm或setitimer构造一组函数，实现任意数量的计时器（alarm实现） 什么是单一计时器 12345alarm(1);alarm(5);alarm(10);// 比如三个 alarm，其实只有最后一个 alarm有效；// 但能不能实现一个计时器，使 1分钟时 提示一下，5分钟时提示一下，10分钟时提示一下 getitimer(3P) 和 setitimer(3P) 函数 1234// getitimer, setitimer - get or set value of an interval timer#include &lt;sys/time.h&gt;int getitimer(int which, struct itimerval *curr_value);int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); setitimer(2) 函数可以用来替代 alarm(2) 函数。 setitimer(2) 函数主要有两点比 alarm(2) 函数更好： setitimer 函数没有延迟累计的； 1）setitimer(2) 函数可以使用精度更高的微秒为计时单位； alarm只能按秒计数 2）从 it_interval 赋值给 it_value 是采用原子操作的。 setitimer(2) 直接可以构成一个类似 alarm(2) 链的执行结构。也就是说当 it_value 的值被递减为 0 时会发送一个信号给当前进程，并且自动将 it_interval 的值赋给 it_value 使计时重新开始。 参数列表： which：使用不同的时间，并发送不同的信号；详见下表（其实在 表1 中我们也提到它们了） which 可选宏值 对应的信号 ITIMER_PROF SIGPROF ITIMER_REAL SIGALRM ITIMER_VIRTUAL SIGVTALRM 表3 which 与对应的信号 new_value：新的定时器周期；这个结构体的定义可以见下面的说明。 old_value：由该函数回填以前设定的定时器周期，不需要保存可以设置为 NULL； 123456789struct itimerval &#123; struct timeval it_interval; /* next value */ struct timeval it_value; /* current value */&#125;;struct timeval &#123; time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */&#125;; 递减的是 it_value 的值，当 it_value 被递减为 0 的时候将 it_interval 的值 原子化 的赋给 it_value。 tv_sec 表示以秒为单位；tv_usec 表示以微秒为单位。使用一种计时方式时，另一种必须设置为 0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 使用 setitimer 重构的漏桶程序#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/time.h&gt;#define CPS 10#define BUFSIZE CPSstatic volatile int loop = 0;static void alrm_handler(int s)&#123; //alarm(1); loop = 1;&#125;int main(int argc, char **argv)&#123; int sfd, dfd = 1; // 目标文件改成标准输出位，1号文件描述符即标准输出位 char buf[BUFSIZE]; int len; int ret; int pos; struct itimerval itv; &#123; /* data */ &#125;; if (argc &lt; 2) &#123; fprintf(stderr, \"Usage .... \\n\"); &#125;; signal(SIGALRM, alrm_handler); // alarm(1); itv.it_interval.tv_sec = 1; itv.it_interval.tv_usec = 0; itv.it_value.tv_sec = 1; itv.it_value.tv_usec = 0; if (setitimer(ITIMER_REAL, &amp;itv, NULL) &lt; 0) &#123; perror(\"setitimer()\"); exit(1); &#125; do &#123; sfd = open(argv[1], O_RDONLY); if (sfd &lt; 0) &#123; if (errno != EINTR) &#123; perror(\"open()\"); exit(1); &#125; &#125; &#125; while (sfd &lt; 0); len = 0; ret = 0; while (1) &#123; while (!loop) &#123; pause(); &#125; loop = 0; while ((len = read(sfd, buf, BUFSIZE)) &lt; 0) &#123; if (errno == EINTR) continue; perror(\"read()\"); break; &#125; if (len == 0) &#123; break; &#125; pos = 0; while (len &gt; 0) &#123; ret = write(dfd, buf + pos, len); if (ret &lt; 0) &#123; if (errno == EINTR) continue; perror(\"write()\"); exit(1); &#125;; pos += ret; len -= ret; &#125; // sleep(1); sleep可以帮助程序实现这个功能，但是不建议在线上程序使用sleep函数 &#125;; close(dfd); exit(0);&#125; 6.8 sleep 有些平台的sleep 是 用alarm + pause封装的，因此当程序出现多个alarm函数时， sleep是会出错的 6.9 nanosleep 可以用来替换sleep 6.10 usleep6. 11 abort(3)1234// abort - cause abnormal process termination #include &lt;stdlib.h&gt;void abort(void); 给调用者发送一个 SIGABRT 信号，收到这个信号的默认动作是终止 + 产生 coredump 文件。 我们在上面的 表1 中提到过它，一般都是程序发现自己出现了明显的异常，为了避免缺陷扩散，自杀的时候使用。 6.12 system(3)1234//system - execute a shell command#include &lt;stdlib.h&gt; int system(const char *command); 在前面介绍进程相关的博文中我们介绍过 system(3) 函数，所以对于它的功能我们这里就不再赘述了，今天聊点关于它与信号的花边新闻。 对于它的使用有一些需要注意的内容，想要正确的使用 system(3) 函数，必须阻塞 SIGCHLD 信号并忽略 SIGINT、SIGQUIT 信号。 为什么使用 system(3) 函数之前要做这些动作呢？这与 shell 的内部命令处理有关系，如果想要了解更详细的内容，请自行参阅 《APUE》 第三版第九章。 6.13 select(2)1234567891011// select, pselect - synchronous I/O multiplexing/* According to POSIX.1-2001 */#include &lt;sys/select.h&gt;/* According to earlier standards */#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 其实 sleep(3) 函数是不好用的，因为某些平台上是使用 alarm(2) + pause(2) 封装它的，大家知道 alarm(2) 的计时是不太准确的。 在当前平台（Linux）sleep(3) 函数是使用 nanosleep 封装的，所以如果不考虑移植的话在当前平台上可以安全的使用 sleep(3) 函数。 其实 usleep(3)、nanosleep(2)、select(2) 这些函数都比 sleep(3) 好用。 select 我们在第14章还会讲，这里说一下利用它的副作用来为我们实现一个安全的定时器。 这样设定它的参数列表就可以了：-1, NULL, NULL, NULL, 定时结构体。 本来不打算贴出代码的，但是后来 LZ 发现用 select(2) 作为计数器使用的时候有几个坑，有必要在这里强调一下。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;int main (void)&#123; int i = 0; struct timeval timeout; for (i = 0; i &lt; 5; i++) &#123; /* * struct timeval 结构体表示剩余的时间 * select(2) 函数内部会修改这个结构体的值 * 如果把这两行写在循环上面... * 效果大家可以自己测试一下 */ timeout.tv_sec = 1; timeout.tv_usec = 0; // 作为定时器使用时只给时间就行了，其它参数都填 0。 if (select(0,0,0,0, &amp;timeout) &lt; 0) &#123; perror(\"select()\"); exit(1); &#125; /* * 如果不写 \\n，那么程序会在结束的时候把所有的haha显示出来， * 而不是在每次循环的时候都显示， * 原因很简单，在前面我们讨论 IO 的时候就讨论过， * 默认情况下标准输出是行缓冲模式。 */ printf(\"hehe\\n\"); &#125; return 0;&#125; 7. 信号集信号集就是一种能表示一组信号的数据类型，一般都是用在批量设置信号掩码时使用。 信号集使用 sigset_t 类型表示，有一组函数可以操作它。 1234567// sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal set operations#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signum);int sigdelset(sigset_t *set, int signum);int sigismember(const sigset_t *set, int signum); 这一组函数的作用无非就是对信号集中的信号进行曾删改差，具体的用法各位可以自行查阅 man 手册。 8. 信号屏蔽字/pending集的处理8.1 sigprocmask(2)1234// sigprocmask - examine and change blocked signals#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); 前面我们提到过我们可以人为的干扰信号 mask 位图，唯一的途径就是通过这个函数实现。但是 padding 位图是无法人为干扰的。 我们不能保证信号什么时候来，使用这个函数的目的就是为了让我们来决定什么时候响应信号。 参数列表： how：指定如何来干扰 mask 位图，可以使用下表中三个宏中的任何一个来指定； 宏 含义 SIG_BLOCK 将当前进程的信号屏蔽字和 set 信号集中的信号全部屏蔽，也就是将它们的 mask 位设置为 0 SIG_UNBLOCK 将 set 信号集中与当前信号屏蔽字重叠的信号解除屏蔽，也就是将它们的 mask 位设置为 1 SIG_SETMASK 将 set 信号集中的信号 mask 位设置为 0，其它的信号全部恢复为 1 表4 干扰 mask 位图的方式 set：需要被干扰 mask 位图的信号集； oldset：由该函数回填之前被干扰的信号集。 使用这个函数，我们来重构上面那个打印星号和感叹号的程序，新需求是这样的： 每行打印 5 个星号，然后停止。期间如果收到了 SIGINT 信号不会立即响应，而是等待本行打印结束后再响应，并且在收到信号之后再打印下一行。 123456789101112131415161718192021222324252627282930313233//#include &lt;signal.h&gt;static void int_handler(int s)&#123; write(1,\"!\", 1);&#125;int main()&#123; int i,j; sigset_t set, oset; // signal(SIGINT, SIG_IGN); signal(SIGINT, int_handler); sigemptyset(&amp;set); sigaddset(&amp;set, SIGINT); sigprocmask(SIG_UNBLOCK,&amp;set,&amp;saveset); for(j=0; i&lt; 1000; i++) &#123; sigprocmask(SIG_BLOCK, &amp;set, &amp;oset); for(i=0;i&lt;5;i++) &#123; write(1,\"*\", 1); sleep(1); &#125; write(1,\"\\n\",1); sigprocmask(SIG_SETMASK, &amp;oset, NULL); &#125; sigprocmask(SIG_SETMASK,&amp;saveset,NULL); exit(0);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 原blog#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;static void int_handler(int s)&#123; write(1,\"!\",1);&#125;int main()&#123; sigset_t set,oset,saveset; // saveset 用来保存当前状态 int i,j; signal(SIGINT,int_handler); sigemptyset(&amp;set); sigaddset(&amp;set,SIGINT); sigprocmask(SIG_UNBLOCK,&amp;set,&amp;saveset); sigprocmask(SIG_BLOCK,&amp;set,&amp;oset); for(j = 0 ; j &lt; 10000; j++) &#123; for(i = 0 ; i &lt; 5; i++) &#123; write(1,\"*\",1); sleep(1); &#125; write(1,\"\\n\",1); // 相当于下面三行的原子操作 sigsuspend(&amp;oset); /* sigset_t tmpset; sigprocmask(SIG_SETMASK,&amp;oset,&amp;tmpset); pause(); sigprocmask(SIG_SETMASK,&amp;tmpset,NULL); */ &#125; sigprocmask(SIG_SETMASK,&amp;saveset,NULL); exit(0);&#125; 大致的实现思路是：开始打印每行星号之前先屏蔽信号，当打印完成之后再恢复信号，然后等待被信号打断，再重新屏蔽信号，打印星号。 但是在测试的时候会发现，这样只能实现当一行信号打印完毕时可以停住，然后按下 Ctrl+C 发送信号，可以继续打印下一行。但是当一行没有打印完成时就按 Ctrl+C 发送信号，下一行会在行首打印感叹号，但是却并不继续开始打印星号。 这是什么原因导致的呢？其实仔细分析一下信号的处理过程就明白了，在开始打印星号之前我们屏蔽了信号的 mask 位，当接收到信号时对应的 padding 位被置1，由于 mask 位是 0 所以程序不会响应信号。当星号打印完成时 mask 位被置为 1，程序会再次看到信号，所以会打印感叹号并进入 pause 状态等待被信号打断，所以程序只打印了一个感叹号却没有继续打印星号。 归根结底还是因为 解除信号屏蔽 — 等待被信号打断 — 屏蔽信号 的这三个步骤不原子导致的。 sigsuspend(2) 函数我们在这篇博文的最后面还会讲解。 当使用 sigsuspend(2) 函数使这三个步骤原子化时我们再来分析一下程序的执行过程： 开始打印星号之前将 mask 位设置为 0，开始打印星号，此时如果接收到了信号 padding 被设置为 1，但是由于 mask 为 0 所以程序不会响应信号。当程序打印完星号时将 mask 位设置为 1，此时响应信号打印出感叹号，并原子化的解除信号屏蔽 + 被信号打断 + 重新屏蔽信号，然后继续开始打印下一行星号。 我们再来看另一种情况：开始打印星号之前将 mask 位设置为 0 并开始打印星号，当一行星号打印完成时没有收到信号，那么原子化的解除信号屏蔽并等待被信号打断。当信号到来时重新屏蔽信号并继续开始打印下一行星号。 根据上面的分析，只要 解除信号屏蔽 — 等待被信号打断 — 屏蔽信号 的这三个步骤原子化后就没问题了。当某件事情需要信号驱动时，在该事件未处理完成时又不希望再次被信号打断的时候，就可以采用类似的这种方式。 当然，这个这个程序是用标准信号实现的，所以标准信号的特点也被它集成了下来：当连续接收到多个信号时只能驱动打印一行星号，而不能收到多少个信号就打印多少行星号，因为标准信号会丢失。 如果想要让程序收到多少个信号就打印多少行星号，其实代码别的地方都不用修改，直接把信号集中的标准信号替换成实时信号就可以了，因为实时信号的特点是不丢失。代码很简单 LZ 就不贴出来了，感兴趣的小伙伴可以自己实验一下。 8.2 sigpending(3P)1234// sigpending - examine pending signals#include &lt;signal.h&gt;int sigpending(sigset_t *set); 用于获取当前收到但是没有响应的信号。 它是一个系统调用，所以当它从内核中返回的时候需要对信号位图做 &amp; 操作，相应的信号已经被处理了，所以当它返回用户态的时候，它带回来的结果可能已经不准确了。 除非调用它之前先把所有的信号都 block 住，然后再调用它，返回的结果才是准确的。 目前还未发现这个函数在实际开发当中有什么作用，主要有两个理由： 1）该函数没有后续操作； 2）没有上面说的手段，取出来的信号集是不准确的。 8.3 sigaction(2)1234//sigaction - examine and change a signal action#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); 这个函数也是信号这章比较重要的一个函数。sigaction(2) 是用来替换 signal(2) 函数的。因为 signal(2) 有一些设计上的缺陷，所以小伙伴们学过了这个函数之后以后就尽量不要再使用 signal(2) 函数了。 参数列表： signum：要设定信号处理函数的信号； act：对信号处理函数的设定； oldact：由函数回填之前的信号处理函数设定，备份用，如果不需要可以填 NULL。 下面看看 struct sigaction 这个结构体的成员表示什么意思： 12345678struct sigaction &#123; // 前两个是信号处理函数，二选一，在某些平台上是一个共用体。 void (*sa_handler)(int); // 为了兼容 signal(2) 函数 void (*sa_sigaction)(int, siginfo_t *, void *); // 第二个参数可以获得信号的来源和属性。第三个参数最原始时是 ucontext_t* 而不是 void*，与 setcontext(3) 有关，目前该参数已经禁止使用。 sigset_t sa_mask; // 信号集位图，指定要处理的信号集，并且信号集中的任何一个信号被触发时，信号集中的其它成员同时会被 block，避免像 signal(2) 的信号处理函数一样当多个信号同时到来时发生重入。 int sa_flags; // 特殊要求。如果使用三参的信号处理函数，需要指定为 SA_SIGINFO void (*sa_restorer)(void); // 基本被废弃了，不用管&#125;; 实际上一个参数的信号处理函数和三个参数的信号处理函数使用哪个都行，一般一个参数的就够用了。假设你的程序需要区分信号的来源或属性信息，那么就需要使用三参的信号处理函数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;syslog.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#define FNAME \"/tmp/out\"FILE *fp;static int daemonize(void)&#123; pid_t pid; pid = fork(); int fd; if(pid &lt; 0) &#123; return -1; &#125; if(pid &gt; 0) // parent &#123; exit(0); &#125; fd = open(\"/dev/null\", O_RDWR); if(fd &lt; 0) &#123; return -1; &#125; dup2(fd, 0); dup2(fd, 1); dup2(fd, 2); if(fd&gt;2) close(fd); setsid(); chdir(\"/\");// umask(0) return 0;&#125;static void daemon_exit(int s)&#123; fclose(fp); closelog(); exit(0);&#125;int main()&#123; int i; struct sigaction sa; sa.sa_handler = daemon_exit; sigemptyset(&amp;sa.sa_mask); sigaddset(&amp;sa.sa_mask, SIGQUIT); sigaddset(&amp;sa.sa_mask, SIGTERM); sigaddset(&amp;sa.sa_mask, SIGINT); sa.sa_flags = 0; sigaction(SIGINT, &amp;sa, NULL); sigaction(SIGQUIT, &amp;sa, NULL); sigaction(SIGTERM, &amp;sa, NULL);// signal(SIGINT, daemon_exit);// signal(SIGQUIT, daemon_exit);// signal(SIGTERM, daemon_exit); openlog(\"mydaemon\", LOG_PID, LOG_DAEMON); if(daemonize()) &#123; syslog(LOG_ERR, \"daemonize() failed!\"); exit(1); &#125; else &#123; syslog(LOG_INFO, \"daemonize() successed\"); // 结尾写 \\n 会被当作文本 &#125; fp = fopen(FNAME, \"w\"); if(fp == NULL) &#123; syslog(LOG_ERR, \"fopen(): %s\", strerror(errno)); exit(1); &#125; syslog(LOG_INFO, \"%s was opend.\", FNAME); for(i=0; ;i++) &#123; fprintf(fp, \"%d\\n\", i); fflush(fp); syslog(LOG_DEBUG, \"%d is printed.\", i); sleep(1); &#125; // 以下两句执行不到，因为守护进程一定是异常中止。因为守护进程脱离控制终端，一定会是kill pid的 // 方式杀死。所以没办法做一个收尾的工作，释放资源等等。 // fclose(fp); // closelog(); exit(0); &#125; 我们再来说说 signal(2) 函数哪里不靠谱。 还记得使用 signal(2) 函数注册的信号处理函数的原型吗？它的参数 s 的作用被设计出来的目的是为了让信号处理函数区别出来是哪个信号触发了它，也就是允许多个不同的信号共用同一个信号处理函数，并且动作可以不一样，可以根据 s 的不同做不同的事。 下面举一个简单的小栗子给大家演示一下如何使用 sigaction(2) 代替 signal(2)，以及为什么说 signal(2) 函数是不靠谱的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;syslog.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define FNAME \"/tmp/out\"static FILE *fp;static int daemonize(void)&#123; pid_t pid; int fd; pid = fork(); if(pid &lt; 0)// syslog(LOG_ERR,\"fork():%s\",strerror(errno)); return -1; if(pid &gt; 0) exit(0); fd = open(\"/dev/null\",O_RDWR); if(fd &lt; 0) return -2; dup2(fd,0); dup2(fd,1); dup2(fd,2); if(fd &gt; 2) close(fd); setsid(); chdir(\"/\"); umask(0); return 0;&#125;static void daemon_exit(int s)&#123; fclose(fp); closelog(); syslog(LOG_INFO,\"daemonize exited.\"); exit(0);&#125;int main()&#123; int i; struct sigaction sa;// 如果使用 signal(2) 函数则是这样注册信号处理函数// signal(SIGINT,daemon_exit);// signal(SIGTERM,daemon_exit);// signal(SIGQUIT,daemon_exit);// 现在改用 sigaction(2) 来替代 signal(2) 函数 sa.sa_handler = daemon_exit; sigemptyset(&amp;sa.sa_mask); sigaddset(&amp;sa.sa_mask,SIGQUIT); sigaddset(&amp;sa.sa_mask,SIGTERM); sigaddset(&amp;sa.sa_mask,SIGINT); sa.sa_flags = 0; sigaction(SIGINT,&amp;sa,NULL); /*if error*/ sigaction(SIGTERM,&amp;sa,NULL); /*if error*/ sigaction(SIGQUIT,&amp;sa,NULL); /*if error*/ openlog(\"mydaemon\",LOG_PID,LOG_DAEMON);// 启动守护进程 if(daemonize()) &#123; syslog(LOG_ERR,\"daemonize() failed.\"); exit(1); &#125; else &#123; syslog(LOG_INFO,\"daemonize() successed.\"); &#125; fp = fopen(FNAME,\"w\"); if(fp == NULL) &#123; syslog(LOG_ERR,\"fopen():%s\",strerror(errno)); exit(1); &#125; for(i = 0 ; ; i++) &#123; fprintf(fp,\"%d\\n\",i); fflush(fp); syslog(LOG_DEBUG,\"%d was printed.\",i); sleep(1); &#125; exit(0);&#125; 这段代码很简单，就是启动一个守护进程每秒钟向 /tmp/out 文件输出一个序列。 上面的代码动机是好的，注册了三个信号处理函数，企图将异常结束行为改变为正常结束行为。但是信号处理函数中并不需要区分不同的信号，只要任何一个信号到来想要杀死进程的时候把资源释放掉再结束即可。 所以有一个重要的缺陷：当多个信号同时到来的时候，一定会发生内存泄漏。因为 signal(2) 函数在一个信号到来的时候不会把其它注册了同一个信号处理函数的信号屏蔽掉。 上面已经说过了，sigaction(2) 在收到信号集中的任何一个信号的时候，都会将信号集中的其它信号屏蔽掉，所以就会避免信号处理函数发生重入。上面的代码改成使用 sigaction(2) 的方式实现就变得安全了。 8.4 setjmp(3) 和 sigsetjmp(3) 函数1234567// setjmp, sigsetjmp - save stack context for nonlocal goto#include &lt;setjmp.h&gt;int setjmp(jmp_buf env);int sigsetjmp(sigjmp_buf env, int savesigs); 我们前面说过，在信号处理函数中是不能使用跨函数的长跳转的还记得吗？是因为进入处理函数之前系统会帮我们屏蔽对应的信号掩码，而当信号处理完成的时候系统会帮我们还原信号掩码。如果我们在信号处理函数中跳走了，那么信号掩码就不会被还原了，可能会造成当前进程再也无法接收到该信号了。 setjmp(3) 在 FreeBSD 平台上和其他平台上的实现不一致。FreeBSD 在跳转的时候还会保存信号掩码，并且在跳转的时候恢复信号掩码，所以在 FreeBSD 上使用 setjmp(3) 从信号处理函数中跳转是安全的。 由于其它平台的实现在跳转时不支持恢复信号掩码，大家一定猜到了为什么又出现了一个 sigsetjmp(3) 函数了。 果然标准再一次跳出来和稀泥了，制定了 sigsetjmp(3) 函数。 sigsetjmp(3) 函数的参数：如果 savesigs 为真，表示与 FreeBSD 平台的 setjmp(3) 实现相同，否则跳转时不保存信号掩码。就这么一点差别，仅此而已。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;static sigjmp_buf env;static void fun (void)&#123; long long i = 0; sigsetjmp(env, 1); printf(\"before %s\\n\", __FUNCTION__); for (i = 0; i &lt; 1000000000; i++); printf(\"end %s\\n\", __FUNCTION__);&#125;static void handler (int s)&#123; printf(\"before %s\\n\", __FUNCTION__); siglongjmp(env, 1); printf(\"end %s\\n\", __FUNCTION__);&#125;int main (void)&#123; long long i = 0; signal(SIGINT, handler); fun(); for (i = 0; ; i++) &#123; printf(\"%lld\\n\", i); pause(); &#125; return 0;&#125; 编译运行： 1234567891011121314151617&gt;$ gcc -Wall siglongjmp.c -o siglongjmp&gt;$ ./siglongjmp before fun^Cbefore handlerbefore fun^Cbefore handlerbefore fun^Cbefore handlerbefore funend fun0^Cbefore handlerbefore funend funSegmentation fault (core dumped)&gt;$ 从上面的执行结果可以看出来，第一次执行 fun() 函数的时候设置了跳转点，在 fun() 函数执行完成之前发送 SIGINT 信号使程序切换到 handler() 函数运行，并且在 handler() 函数中再次跳转到 fun() 函数。在 fun() 函数运行结束之前再次发送信号依然可以被程序看到，说明 siglongjmp(3) 在跳转的时候确实恢复信号掩码了。 但是继续往下看，当 fun() 函数执行完毕时再次发送 SIGINT 信号给程序，handler() 函数会再次被调用，但是当从 handler() 跳转到 fun() 函数的时候出现段错误了！ 为什么呢？经过 LZ 实验发现：siglongjmp(3) 函数只能从信号处理函数中跳转到当前被打断的函数，而不能随意跳转到其它函数中！（信号处理的过程可以见上面的图1） 也就是说当 fun() 函数在运行时被打断，从内核态回到用户态时发现收到了信号，这时候跳转到信号处理函数中运行，这个信号处理函数如果使用 siglongjmp(3) 函数进行跳转，则只能跳转到 fun() 函数中，否则会报段错误。 同理，上面的代码当 fun() 函数运行结束时回到 main() 函数继续运行，在 main() 被打断后进入内核排队等待被调度，当它获得调度机会从内核态回到用户态时发现收到了信号并且需要处理，这个时候信号处理函数 handler() 开始运行，如果信号处理函数需要使用 siglongjmp(3) 进行跳转，那么它只能选择跳转到 main() 函数中，而不能跳转到其它函数中。因为前面 LZ 说了，当前被打断的是 main() 函数，谁被打断就只能跳转到谁那去。这时候信号处理函数依然选择跳转到 fun() 函数中，所以引发了段错误。 为什么会有这么奇怪的现象 LZ 也不明白，估计跟执行现场有关系，各位如果知道是什么原因的话请在留言中告诉 LZ 哈。 8.5 sigsuspend(2)1234// sigsuspend - wait for a signal#include &lt;signal.h&gt;int sigsuspend(const sigset_t *mask); 与pause之间的区别 这个函数我们在上面已经见过了， 它就是为了解决解除信号阻塞和 pause(2) 之间不原子的问题。 如果本来程序期望的是解除该信号的阻塞之后用 pause(2) 来等待被该信号打断，结果这个信号在解除阻塞和 pause(2) 之间到来了，这就导致它无法打断 pause(2) 了，因为它是在进行 pause(2) 之前到来的。如果后面不会再见到该信号，那么 pause(2) 将永远阻塞下去。 我们用下面的栗子来说明这个问题。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;static void int_handler(int s)&#123; write(1,\"!\",1);&#125;int main()&#123; sigset_t set,oset,saveset; int i,j; signal(SIGINT,int_handler); sigemptyset(&amp;set); sigaddset(&amp;set,SIGINT); sigprocmask(SIG_UNBLOCK,&amp;set,&amp;saveset); for(j = 0 ; j &lt; 10000; j++) &#123; sigprocmask(SIG_BLOCK,&amp;set,&amp;oset); for(i = 0 ; i &lt; 5; i++) &#123; write(1,\"*\",1); sleep(1); &#125; write(1,\"\\n\",1); // sigprocmask 和 pause 不原子 sigprocmask(SIG_SETMASK,&amp;oset,NULL); pause(); &#125; sigprocmask(SIG_SETMASK,&amp;saveset,NULL); exit(0);&#125; 12345678910111213141516171819202122232425262728293031323334353637int main()&#123; sigset_t set,oset,saveset; int i,j; signal(SIGINT,int_handler); sigemptyset(&amp;set); sigaddset(&amp;set,SIGINT); sigprocmask(SIG_UNBLOCK,&amp;set,&amp;saveset); sigprocmask(SIG_BLOCK,&amp;set,&amp;oset); for(j = 0 ; j &lt; 10000; j++) &#123; for(i = 0 ; i &lt; 5; i++) &#123; write(1,\"*\",1); sleep(1); &#125; write(1,\"\\n\",1); sigsuspend(&amp;oset); // 原子操作 /* sigset_t tmpset; // sigprocmask 和 pause 不原子 sigprocmask(SIG_SETMASK, &amp;oset, &amp;tmpset); pause(); sigprocmask(SIG_SETMASK, &amp;tmpset, NULL); */ &#125; sigprocmask(SIG_SETMASK,&amp;saveset,NULL); exit(0);&#125; 这个程序跟上面的栗子类似，每秒钟打印一个星号，每 5 个星号组成一行，只有当一行星号打印完毕时才响应 SIGINT 信号。 如果解除阻塞和等待信号打断不采用原子操作，那么在 pause(2) 之前收到了信号就无法驱动下一行星号的打印了。 测试一个东西 1234#cd /apue/parallel/signal/mytbfmake./mytbf /etc/services 12345678910while true; do kill - ALRM 45625 ; done# 从user角度，给一个指定的进程发 alrm信号。你会发现流控已经不成立了。这个问题 signal 解决不了。问题是根源是 signal并没有管信号的来源，信号的属性信息，它要做的是，你只要来一个信号，我给这个信号注册一个行为了，那就执行这个信号的行为。它并没有区分信号的来源是哪儿，而直接执行这个信号的行为。如何能区分信号的来源了，那就好办了，可以只响应从kernel来的信号。#kill: kill 45625 failed: 没有那个进程#kill: kill 45625 failed: 没有那个进程#kill: kill 45625 failed: 没有那个进程#kill: kill 45625 failed: 没有那个进程#kill: kill 45625 failed: 没有那个进程#kill: kill 45625 failed: 没有那个进程 这个问题需要用到 sigaction 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"mytbf.h\"#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include &lt;sys/time.h&gt;//typedef void (*sighandler_t)(int);static struct mytbf_st* job[MYTBF_MAX];static int inited = 0;//static sighandler_t alrm_handler_save;static struct sigaction alrm_sa_save;struct mytbf_st&#123; int cps; int burst; int token; int pos;&#125;;static void module_unload(void)&#123; int i;// signal(SIGALRM, alrm_handler_save);// alarm(0); struct itimerval itv; sigaction(SIGALRM, &amp;alrm_sa_save, NULL); itv.it_interval.tv_sec = 0; itv.it_interval.tv_usec = 0; itv.it_value.tv_sec = 0; itv.it_value.tv_usec = 0;setitimer(ITIMER_REAL, &amp;itv, NULL); for(i=0; i&lt; MYTBF_MAX; i++) &#123; free(job[i]); &#125;&#125;static int get_free_pos(void)&#123; int i; for(i =0; i&lt;MYTBF_MAX; i++) &#123; if(job[i] == NULL) return i; &#125; return -1;&#125;static void alrm_action(int s, siginfo_t *infop, void *unused)&#123; int i;// alarm(1); if(infop -&gt; si_code != SI_KERNEL) return; for(i=0; i&lt; MYTBF_MAX; i++) &#123; if(job[i]!= NULL) &#123; job[i]-&gt;token += job[i]-&gt;cps; if(job[i]-&gt;token &gt; job[i]-&gt;burst) job[i]-&gt;token = job[i]-&gt;burst; &#125; &#125;&#125;static void module_load(void)&#123;// alrm_handler_save = signal(SIGALRM, alrm_handler);// alarm(1); struct sigaction sa; struct itimerval itv; sa.sa_sigaction = alrm_action; sigemptyset(&amp;sa.sa_mask); sa.sa_flags = SA_SIGINFO; sigaction(SIGALRM, &amp;sa, &amp;alrm_sa_save); /* if error */ itv.it_interval.tv_sec = 1; itv.it_interval.tv_usec = 0; itv.it_value.tv_sec = 1; itv.it_value.tv_usec = 0; setitimer(ITIMER_REAL, &amp;itv, NULL); /*if error*/ atexit(module_unload);&#125;mytbf_t *mytbf_init(int cps, int burst)&#123; int pos; struct mytbf_st *me; if(!inited) &#123; module_load(); inited = 1; &#125; pos = get_free_pos(); // 在数组中 找空位 if(pos &lt; 0) return NULL; me = malloc(sizeof(*me)); if (me == NULL) return NULL; me-&gt;token = 0; me-&gt;cps = cps; me-&gt;burst = burst; me-&gt;pos = pos; job[pos] = me; //将该结构体存储至 数组中 return me;&#125;static int min(int a, int b)&#123; if(a&lt;b)&#123; return a; &#125; return b;&#125;int mytbf_fetchtoken(mytbf_t *ptr, int size)&#123; int n; struct mytbf_st *me = ptr; if(size &lt;= 0) return -EINVAL; while(me-&gt;token &lt;= 0) &#123; pause(); &#125; n = min(me-&gt;token, size); me-&gt;token -= n; return n;&#125;int mytbf_returntoken(mytbf_t * ptr, int size)&#123; struct mytbf_st *me = ptr; if(size &lt;= 0) return -EINVAL; me-&gt;token += size; if(me-&gt;token &gt; me-&gt;burst) me-&gt;token = me-&gt;burst; return size;&#125;int mytbf_destroy(mytbf_t *ptr)&#123; // 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos struct mytbf_st *me = ptr; job[me -&gt; pos] = NULL; free(ptr); return 0;&#125; 12345// 该函数可以指定 响应从 哪儿来的信号#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction * act,struct sigaction * oldact); 用sigaction 重构 mytbf库，在信号处理函数当中。在alarm前面加 if判断，只有是kernel来的就响应，不是kernel来的一概不响应。 8.6 实时信号 标准信号会丢失，因为是用位图来进行记录的。 标准信号的响应没有严格的顺序，实时信号的产生是为了解决标准信号的不足。首先实时信号是需要排队的，其次实时信号的响应有一个顺序要求。标准信号的响应无顺序，不能说它是随机响应。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#define MYRTSIG (SIGRTMIN+6)static void mysig_handler(int s)&#123; write(1, \"!\", 1);&#125;int main()&#123; int i, j; sigset_t set, oset, saveset; signal(MYRTSIG, mysig_handler); sigemptyset(&amp;set); sigaddset(&amp;set, MYRTSIG); sigprocmask(SIG_UNBLOCK, &amp;set, &amp;saveset); sigprocmask(SIG_BLOCK, &amp;set, &amp;oset); for (j=0; j&lt;1000; j++) &#123; for(i=0; i&lt;5; i++) &#123; write(1,\"*\",1); sleep(1); &#125; write(1, \"\\n\", 1); sigsuspend(&amp;oset); &#125; sigprocmask(SIG_SETMASK, &amp;saveset, NULL); exit(0);&#125; 1234567891011121314151617181920212223242526272829#给 17177 号进程发信号kill -40 57245kill -40 57245kill -40 57245# 连续发送三次信号，我们发现 程序连续执行了三次。# 说明实时信号能做到 信号不丢失 （实时信号和标准信号的区别就在于此）# 当然这个信号也无法无休止的发的，也是有资源上限的ulimit -a-t: cpu time (seconds) unlimited-f: file size (blocks) unlimited-d: data seg size (kbytes) unlimited-s: stack size (kbytes) 8192-c: core file size (blocks) 0-m: resident set size (kbytes) unlimited-u: processes 7144-n: file descriptors 1024-l: locked-in-memory size (kbytes) 64-v: address space (kbytes) unlimited-x: file locks unlimited-i: pending signals 7144 # pending signals 实时信号上限-q: bytes in POSIX msg queues 819200-e: max nice 0-r: max rt priority 0-N 15: unlimited# 可以 ulimit -i 来更改这个最大实时信号的上限 8.7 有关信号的其它内容除了 kill -l 可以查看所有的信号，还可以通过 /usr/include/bits/signum.h 文件查看。 实时信号会按照先到先响应的顺序处理，并且信号会排队，不会丢失。 信号是否排队、是否丢失，不取决于使用哪个函数，而是取决于使用哪种信号。 实时信号具有这些特点是因为它不是采用位图实现的，而是采用链式结构实现的。 其它方面与标准信号没有区别。 信号处理函数中只能安全的使用可重入函数（所有系统调用都是可重入函数）和所有的科学计算（科学计算都是可重入的），编写信号处理函数要时刻防止重入发生。 尽量不要大范围的混用信号和多线程，如果在小范围内信号 + 多线程可以方便的解决某个问题时才可以在小范围内混用它们 小结 实际上，使用多线程并发要比信号并发简单的多。","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"线程","slug":"apue-7","date":"2020-12-16T06:52:39.000Z","updated":"2021-06-02T07:38:49.639Z","comments":true,"path":"2020/12/16/apue-7/","link":"","permalink":"http://yoursite.com/2020/12/16/apue-7/","excerpt":"","text":"线程 实际项目中多线程用得比较多，因为多线程是先有标准后有实现的，所以不会向多进程那样在不同平台上有许多不同的情况。 线程的概念 线程的创建、线程终止、 线程的取消、线程的清理 线程的同步（互斥量， 通知法，读写锁） 线程相关的属性 （线程同步属性） 重入，线程和信号的关系， 线程与fork 1.1 线程概念 线程就是一个正在运行函数 一个进程空间最少要有一个线程，一个进程里面最少有一个函数在运行。 线程没有主次之分，不分前后的，即使线程自己创建出来的线程反过来把自己取消或者收尸都是可以的。main函数产生的main进程并不是主线程 线程之间独立运行，而不是调用与被调用的关系。多个线程的内存是共享的。所以线程间通信依赖全局变量 线程是先有标准，然后才有标准实现的 一个新的库被开发出来，默认是需要支持多线程的，如果不能支持需要在函数的调用以及函数名上做说明。很多函数都是支持多线程的，比如getchar putchar等 1.1.1 线程有不同的标准 线程标准只是一套标准，而不是实现 POSIX标准C 语言线程有很多标准，POSIX 是其中的一种。POSIX 是一套标准，而不是一种实现。 openmp标准openmp是另外一种线程标准。约定了另外并发的方式，可以产生多线程的并发。它并发的方式不是从语言的角度了。 1.1.2 线程的标识pthread_t (p 表示 POSIX, thread 线程)· pthread_t类型 是 POSIX 下的线程标识， pthread_t是什么类型，不清楚，正因为 POSIX 是一套标准而不是实现，所以 POSIX 只是规定了 pthread_t 作为线程标识符，但是并没有规定它必须是由什么类型组成的，所以在有的平台上它可能是 int，有些平台上它可能是 struct，还有些平台上它可能是 union，所以不要直接操作这个类型，而是要使用 POSIX 规定的各种线程函数来操作它。 有木有觉得像标准 IO 里 FILE 的赶脚？没错，标准制定出来的很多东西都是这种风格的，它为你提供一个数据类型而不让你直接对这个类型操作，要通过它定义的一系列函数来实现对这个类型的操作，这样就在各个平台上实现统一的接口了，所以这样做才能让标准制定出来的东西具有较好的可移植性。 pthread_t 是个很重要的东西，我们所有使用 PSOIX 标准的线程操作都是围绕着它来进行的，通过它配合各种函数就可以对线程进行各种花样作死的玩了。 1234567891011$ ps ax -L # 以linux方式查看进程PID LWP TTY STAT TIME COMMAND 1 1 ? Ss 0:02 /sbin/init 2 2 ? S 0:00 [kthreadd] 3 3 ? S 0:00 [ksoftirqd/0] 877 877 ? Ss 0:06 dbus-daemon --system --fork 948 948 ? Ssl 0:00 /usr/sbin/ModemManager 948 965 ? Ssl 0:00 /usr/sbin/ModemManager 948 975 ? Ssl 0:00 /usr/sbin/ModemManager 956 956 ? Ss 0:00 /usr/sbin/bluetoothd$ PID 是进程号。 LWP虚拟进程ID，即线程 ID。 在linux环境下，其实是以线程来消耗当前进程号的。当前所看到的线程号其实就是用进程标识来进行描述的。 尽管如此 依然不能 printf(&quot;%d&quot;, pthread_t), 因为其他线程标准下的 pthread_t 并不一定是 int类型。 这里看到的 PID 为 948 的进程有三个 LWP，它们就是三个线程。 1.1.3 多线程相比信号要简单不少 多线程太规范了，信号处理函数应该越短越好。里面不能用IO，不能用不可重入的函数。只能安全的在里面做一些计算和系统调用。其他都慎用。线程不存在这样的问题。线程里面可以io，也可以使用可重用和不可重用的函数。要做到线程的安全比做到信号的安全 条件要松散一些。具体原因还是 多线程是先有标准 后有实现。更像亲儿子。同样是解决异步的两种方式，多线程和信号。至少要对其中一种方式掌握的很熟练。 1234$&gt; vim makefileCFLAGS+=-pthreadLDFLAGS+=-pthread pthread_equal(3) 1234// pthread_equal - compare thread IDs #include &lt;pthread.h&gt; int pthread_equal(pthread_t t1, pthread_t t2);// Compile and link with -pthread. 第一个要介绍的函数是 pthread_equal(3)，比较两个线程标识符是否相同。为什么不能使用 if (t1 == t2) 的方式比较两个线程标识符呢？就像我们上面说的，因为你不知道 pthread_t 是什么类型的，所以永远不要自己直接操作它。 pthread_self(3) 1234567// pthread_self - obtain ID of the calling thread// 当前线程的ID #include &lt;pthread.h&gt; pthread_t pthread_self(void);// Compile and link with -pthread. 大家还记得一个进程可以通过 getpid(2) 函数获得当前进程的 ID 号吧？pthread_self(3) 就是获得当前线程 ID 的函数。 1.2 线程操作1.2.1 线程的创建pthread_create(3) 12345// pthread_create - create a new thread #include &lt;pthread.h&gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);// Compile and link with -pthread. pthread_create(3) 函数的作用就是创建一个新线程。 参数列表： thread：由函数回填的线程标识符，它来唯一的标识产生的新线程，后面我们只要需要操作新线程就需要用到它； attr：线程属性，在本篇博文（第 11 章）中，所有的属性都是使用 NULL，也就是使用默认属性。 start_routine：线程的执行函数；入参是 void，返回值是 void，恭喜你，这两个值的类型都是百搭的，任何类型你都可以在这使用了。 arg：传递给 start_routine 的 void* 参数。 返回值：成功返回 0；失败返回 errno。为什么线程函数返回的是 errno 呢？因为在一些平台上 error 是全局变量，如果大家都使用同一个全局变量，在多线程的情况下就可能会出现竞争，所以 POSIX 的线程函数一般在失败的时候都是直接返回 errno 的，这样就避免了某些平台 errno 的缺陷了。 新线程和当前的线程是两个兄弟线程，他们是平等的，没有父子关系。 新线程被创建之后，这两个线程哪个先执行是不确定的，由调度器来决定。如果你希望哪个线程一定先执行，那么就在其它线程中使用类似 sleep(3) 的函数让它们等一会儿再运行。 123456789101112131415161718192021222324252627#include &lt;pthread.h&gt;static void *func(void *p)&#123; puts(\"Thread is working!\"); return NULL;&#125;int main()&#123; int error; pthread_t tid; puts(\"Begin!\"); error = pthread_create(&amp;tid, NULL,func, NULL); if(error) &#123; fprintf(stderr, \"pthread_create():%s\\n\", strerror(error)); exit(1); &#125; puts(\"End!\"); exit(0);&#125;// Begin!// End! 为何没有打印 “Thread is working!” 线程的调度取决于调度器的策略,这个现象也不难理解，因为在虚拟机的环境上，没办法去模拟一个多核并发的内容。因为虚拟机本身在宿主机上跑的，一定是在一个核上运行。所以单个核上无法虚拟出多个核。 回过头看代码， 123456789101112131415161718int main()&#123; int error; pthread_t tid; puts(\"Begin!\"); error = pthread_create(&amp;tid, NULL,func, NULL); if(error) &#123; fprintf(stderr, \"pthread_create():%s\\n\", strerror(error)); exit(1); &#125; puts(\"End!\"); exit(0); // 在创建的 func线程，还没来得及没调度的时候，就执行了exit(0) 结束掉了进程。在进程的任意位置 执行 exit 函数 都表示当前进程的结束。 所以没有机会打印出 Thread is working! 这句话了。&#125; 在一个多核机器上，理论是可以打印出 “new pthread working!” 的，有时存在 begin 和 end之间，有时存在 end之后 12345# macos# Begin!# end!# new pthread working! 1.2.2 线程的终止 线程的终止有三种方式 线程从启动例程返回，返回值就是线程的退出码 线程可以被同一进程中的其他线程取消（异常终止的一种方式） 线程调用 pthread_exit() 函数， pthread_exit(3) 这个函数相当于进程阶段的 exit 函数，它表示结束当前正在跑的线程（函数），当然如果你 用 pthread_exit 调用的线程是当前进程的最后一个正在跑的线程，那么进程也会被结束。最后一个线程从启动例程里面返回，也会导致进程结束。 12345// pthread_exit - terminate calling thread#include &lt;pthread.h&gt;void pthread_exit(void *retval);// Compile and link with -pthread. 在线程执行函数中调用，作用是退出当前线程，并将返回值通过 retval 参数返回给调用 pthread_join(3) 函数的地方，如果不需要返回值可以传入 NULL。 pthread_join(3) 是为线程收尸的函数，我们会在下面详细介绍。 1234int pthread_join(pthread_t thread, void **retval);// 如果第二个参数不传，指的是 只收尸，不关心状态// Compile and link with -pthread 为线程收尸，在上面的栗子中大家已经见到了。不像 wait(2) 函数，线程之间谁都可以为别人收尸，它们之间是没有父子关系的。而 wait(2) 函数只能是由父进程对子进程收尸。 参数列表： thread：指定为哪个线程收尸； retval：这个二级指针是什么呢？它就是线程在退出的时候的返回值（pthread_exit(3) 的参数），它会把线程的返回值的地址回填到这个参数中。 我们先来看个小栗子，直观的了解下线程是如何被创建的，以及它是如何工作的。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;static void *func(void *p)&#123; puts(\"Thread is working.\"); sleep(10); // 延时是为了方便我们使用 ps(1) 命令验证线程是否被创建了 pthread_exit(NULL);// return NULL; return 指的是一个函数的结束。&#125;int main()&#123; pthread_t tid; int err; puts(\"Begin!\"); // 创建线程 err = pthread_create(&amp;tid,NULL,func,NULL); if(err) &#123; fprintf(stderr,\"pthread_create():%s\\n\",strerror(err)); exit(1); &#125; // 为线程收尸 pthread_join(tid,NULL); // 这个等的动作相当于是等待创建完的线程执行完。所以最终控制台输出的结果，无论是单核还是双核，‘Thread is working.’都会在 ends 输出之前 输出出来。 puts(\"End!\"); exit(0);&#125; 编译并运行，同时使用 LZ 上面介绍过的 ps(1) 命令验证线程是否被创建成功了。 1234567891011$ ./createBegin!Thread is working.End!$# 在线程结束之前打开另一个终端，验证线程的状态$ ps ax -L PID LWP TTY STAT TIME COMMAND 4354 4354 pts/1 Sl+ 0:00 ./create 4354 4355 pts/1 Sl+ 0:00 ./create$ 通过 ps(1) 命令的验证，可以看到这两个线程拥有同一个 PID 不同的 LWP，所以可以直观的看出来我们的线程创建成功了！ 大家注意，编译 POSIX 线程程序的时候需要使用 -pthread 参数，这个其实在 man 手册里已经说得很清楚了. 1.2.3 线程的清理pthread_cleanup_push()pthread_cheanup_pop() 7.线程清理处理程序（thread cleanup handler） 12345678// pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers#include &lt;pthread.h&gt;void pthread_cleanup_push(void (*routine)(void *), void *arg);void pthread_cleanup_pop(int execute);// Compile and link with -pthread. 就像在进程级别使用 atexit(3) 函数挂钩子函数一样，线程可能也需要在结束时执行一些清理工作，这时候就需要派出线程清理处理程序上场了。钩子函数的调用顺序也是逆序的，也就是执行顺序与注册顺序相反。 这两个是带参的宏而不是函数，所以必须成对使用，而且必须先使用 pthread_cleanup_push 再使用 pthread_cleanup_pop，否则会报语法错误，括号不匹配。 参数列表： routine：钩子函数。 arg：传递给钩子函数的参数。 execute：0 不调用该钩子函数；1 调用该钩子函数。 pthread_cleanup_pop 写到哪都行，只要写了让语法不报错就行，就算你把它写到 pthread_exit(3) 下面也没问题，但是 execute 参数就看不到了，所以无论 pthread_cleanup_pop 的参数是什么，所有注册过的钩子函数都会被执行。 12345678910#include &lt;pthread.h&gt;void routine (void *p) &#123;&#125;void* fun (void *p)&#123; pthread_cleanup_push(routine, NULL); //这里是其它代码 pthread_cleanup_pop(1);&#125; 预编译，查看宏替换的结果： 123456789$ gcc -E cleanup.c # 预处理， 解决所有 #开发的语句void routine (void *p) &#123;&#125;void* fun (void *p)&#123; do &#123; __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (((void *)0)); int not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *) __cancel_buf.__cancel_jmp_buf, 0); if (__builtin_expect (not_first_call, 0)) &#123; __cancel_routine (__cancel_arg); __pthread_unwind_next (&amp;__cancel_buf); &#125; __pthread_register_cancel (&amp;__cancel_buf); do &#123;; // 这里是其它代码 do &#123; &#125; while (0); &#125; while (0); __pthread_unregister_cancel (&amp;__cancel_buf); if (1) __cancel_routine (__cancel_arg); &#125; while (0);&#125; 通过预编译可以看出来 pthread_cleanup_push 和 pthread_cleanup_pop 两个宏被替换了，并且每个宏仅定义了一半，如果不成对写另一个宏编译的时候就会报括号不匹配的错误。 1234567891011121314151617181920212223242526272829303132333435363738static void cleanup_func(void *p)&#123; puts(p);&#125;static void *func(void *p)&#123; puts(\"Thread is working\"); pthread_cleanup_push(cleanup_func, \"cleanup:1\"); pthread_cleanup_push(cleanup_func, \"cleanup:2\"); pthread_cleanup_push(cleanup_func, \"cleanup:3\"); puts(\"push over!\"); // // pthread_cleanup_pop 和 pthread_cleanup_push 需要成双成对出现， 有多少个push 就的有多少个pop pthread_cleanup_pop(1); // 参数 1表示调用，0表示只弹栈 不调用 pthread_cleanup_pop(1); // 栈方法，后进先出 pthread_cleanup_pop(1); pthread_exit(NULL);&#125;int main()&#123; int err; pthread_t tid; puts(\"begin\"); err = pthread_create(&amp;tid, NULL, func, NULL); if(err) &#123; fprintf(stderr,\"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; pthread_join(tid, NULL); puts(\"End!\"); exit(0);&#125; 1234567beginThread is workingpush over!cleanup:3cleanup:2cleanup:1End! 1.2.4 线程取消 linux 一共有8种终止进程的方式，其中5种正常终止和3种异常终止。 其中‘最后一个线程对取消请求作出响应；’ 是三种异常中止方式中的一种 pthread_cancel(3) 12345// pthread_cancel - send a cancellation request to a thread#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);// Compile and link with -pthread. setcanceltype 123int pthread_setcancelstate(int state, int *oldstate); // 设置是否允许取消int pthread_setcanceltype(int type, int *oldtype);// 设置取消方式void pthread_testcancel(void); // 本函数什么都不做，就是一个取消点 取消有两种状态： 允许 和 不允许 允许取消又分为 异步cancel 和 推迟 cancel(默认) -&gt; 推迟至cancel点再响应cancel点： POSIX定义的cancel点，都是可能引发阻塞的系统调用； pthread_cancel(3) 函数的作用是取消同一个进程中的其它线程线程。 为什么要取消线程呢？当一个线程没有必要继续执行下去时，我们又没法为它收尸，所以就需要先取消这个线程，然后再为它收尸。 比如在使用多线程遍历一个很大的二叉树查找一个数据时，其中某一个线程找到了要查找的数据，那么其它线程就没有必要继续执行了，所以就可以取消它们了。 注意 pthread_cancel(3) 并不等待线程终止，它仅仅提出请求。 而线程收到这个请求也不会立即终止，线程要执行到取消点才能被取消，关于取消点在下一篇博文中会介绍。 线程分离 pthread_detach(3) 不想管它，扔到一边去，生死存亡各有天命 123456// pthread_detach - detach a thread#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);// Compile and link with -pthread. pthread_detach(3) 函数用于分离线程，被分离的线程是不能被收尸的。 primer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define LEFT 30000000#define RIGHT 30000200#define THRNUM (RIGHT-LEFT+1)static void *thr_prime(void *p);int main()&#123; int i, err; pthread_t tid[THRNUM]; for(i = LEFT; i&lt;= RIGHT; i++) &#123; err = pthread_create(tid+(i-LEFT), NULL, thr_prime, &amp;i); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; for(i = LEFT; i&lt;=RIGHT; i++) pthread_join(tid[i-LEFT], NULL); exit(0);&#125;static void *thr_prime(void *p)&#123; int i, j, mark; i = *(int *)p; mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); pthread_exit(NULL);&#125; 12345678910./primer30000023 is a primer30000037 is a primer30000037 is a primer30000049 is a primer30000071 is a primer30000059 is a primer30000079 is a primer30000133 is a primer# 结果不对 这种现象是因为线程发生了竞争； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 简单粗暴的更改#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define LEFT 30000000#define RIGHT 30000200#define THRNUM (RIGHT-LEFT+1)static void *thr_prime(void *p);int main()&#123; int i, err; pthread_t tid[THRNUM]; for(i = LEFT; i&lt;= RIGHT; i++) &#123; err = pthread_create(tid+(i-LEFT), NULL, thr_prime, (void *)i); //主要处理这个 i 的问题，因为 prime0 程序里面这个 i 是地址传递 if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; for(i = LEFT; i&lt;=RIGHT; i++) pthread_join(tid[i-LEFT], NULL); exit(0);&#125;static void *thr_prime(void *p)&#123; int i, j, mark; i = (int)p; // 将p 强制 转换成int 类型 mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); pthread_exit(NULL);&#125; 12345678910111213141516171819202130000149 is a primer30000137 is a primer30000041 is a primer30000079 is a primer30000083 is a primer30000169 is a primer30000163 is a primer30000133 is a primer30000023 is a primer30000071 is a primer30000167 is a primer30000109 is a primer30000001 is a primer30000049 is a primer30000037 is a primer30000199 is a primer30000193 is a primer30000059 is a primer$ ./primer0 | wc -l18 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 使用更多的空间，优化策略是创建一个结构体数组用来存储#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define LEFT 30000000#define RIGHT 30000200#define THRNUM (RIGHT-LEFT+1)static void *thr_prime(void *p);int main()&#123; int i, err; pthread_t tid[THRNUM]; for(i = LEFT; i&lt;= RIGHT; i++) &#123; err = pthread_create(tid+(i-LEFT), NULL, thr_prime, (void *)i); //主要处理这个 i 的问题，因为 prime0 程序里面这个 i 是地址传递 if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; for(i = LEFT; i&lt;=RIGHT; i++) pthread_join(tid[i-LEFT], NULL); exit(0);&#125;static void *thr_prime(void *p)&#123; int i, j, mark; i = (int)p; // 将p 强制 转换成int 类型 mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); pthread_exit(NULL);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 创建结构体用于接受#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define LEFT 30000000#define RIGHT 30000200#define THRNUM (RIGHT-LEFT+1)struct thr_arg_st&#123; int n;&#125;;static void *thr_prime(void *p);int main()&#123; int i, err; pthread_t tid[THRNUM]; struct thr_arg_st *p; for(i = LEFT; i&lt;= RIGHT; i++) &#123; p = malloc(sizeof(*p)); if(p == NULL) &#123; perror(\"malloc()\"); exit(1); &#125; p-&gt;n = i; err = pthread_create(tid+(i-LEFT), NULL, thr_prime,p); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; for(i = LEFT; i&lt;=RIGHT; i++) pthread_join(tid[i-LEFT], NULL); exit(0);&#125;static void *thr_prime(void *p)&#123; int i, j, mark; i = ((struct thr_arg_st *)p) -&gt;n; free(p); // 及时回收，不然会造成内存泄露，且泄露200个结构体的空间 mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); pthread_exit(NULL);&#125;// 当然这个函数还有优化的空间，比如malloc 和 free 尽量放在一个函数当中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 将malloc 和free放在一个函数当中#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define LEFT 30000000#define RIGHT 30000200#define THRNUM (RIGHT-LEFT+1)struct thr_arg_st&#123; int n;&#125;;static void *thr_prime(void *p);int main()&#123; int i, err; pthread_t tid[THRNUM]; struct thr_arg_st *p; void *ptr; // 定义指针，接受线程 for(i = LEFT; i&lt;= RIGHT; i++) &#123; p = malloc(sizeof(*p)); if(p == NULL) &#123; perror(\"malloc()\"); exit(1); &#125; p-&gt;n = i; err = pthread_create(tid+(i-LEFT), NULL, thr_prime,p); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; for(i = LEFT; i&lt;=RIGHT; i++) &#123; pthread_join(tid[i-LEFT], &amp;ptr); free(ptr); // 收尸的同时调用 free ptr &#125; exit(0);&#125;static void *thr_prime(void *p)&#123; int i, j, mark; i = ((struct thr_arg_st *)p) -&gt;n; mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"%d is a primer\\n\", i); pthread_exit(p);&#125;// 目前的写法依然不科学，因为一个进程里面未必就能创建出来这么多的线程，那么如何测试一个进程能创建多少线程呢？ 一个进程能创建多少线程 32位的机器，一个进程最多创建300个左右的线程 thr_prime这个函数，该函数实际被扔出去201次，201份同时跑。在资源的使用上，他们的代码段是公用的，它们的栈是独立的。 12$&gt; ulimit -astack size 10240 # 栈大小是 10240 也就是10M c程序地址空间分布，32位环境上，c进程的虚拟空间是4GB，最高的一GB是给内核态使用的，用户态用的虚拟空间是不足3GB的。在这不足3GB的空间里面，代码段，静态区域，数据段，堆，栈都得预留出来。所以说，当前能创建多少个线程，也就要看在当前的进程空间里面能够创建多少个10MB大小的栈。所以能创建多少线程还是取决于资源量的 在64位的机器上，一个C程序的虚拟空间是128T。所以，是消耗不完的，纵使能消耗完，也是先消耗完pid号 1.3 线程的同步在介绍互斥量之前我们先思考一个问题：如何让 20 个线程同时从一个文件中读取数字，累加 1 然后再写入回去，并且保证程序运行之后文件中的数值比运行程序之前大 20？ 12$&gt; echo 100 &gt; /tmp/out/ # 往out文件里面写入一个 1个数cat /tmp/out 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 20个线程，打开一个文件，读数 + 1，写回去。不要乱// add.c,#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define THRNUM 20#define FNAME \"/tmp/out\"#define LINESIZE 1024static void* thr_add(void *p)&#123; FILE *fp; char linebuf[LINESIZE]; fp = fopen(FNAME, \"r+\"); if(fp == NULL) &#123; perror(\"fopen()\"); exit(1); &#125; fgets(linebuf,LINESIZE,fp); // 将读取的内容放进 linebuf中 fseek(fp, 0, SEEK_SET); // 文件位置指针 指回去 fprintf(fp,\"%d\\n\", atoi(linebuf)+1); fclose(fp); pthread_exit(NULL);&#125;int main()&#123; int i,err; pthread_t tid[THRNUM]; for(i=0;i&lt;THRNUM;i++) &#123; err = pthread_create(tid+i, NULL, thr_add, NULL); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\",strerror(err)); exit(1); &#125; &#125;; for(i=0; i&lt;THRNUM; i++) &#123; pthread_join(tid[i], NULL); &#125; exit(0);&#125; 我们发现，在虚拟机上是正确的，因为虚拟机是运行在一个核上面的。没办法做到并行而在macos上发现，结果是不正确的。 1.3.1 互斥量pthead_mutex_t 限制一段代码以独占的形势在实现 互斥量是一种机制 多线程就是为了充分利用硬件资源，使程序可以并发的运行，但是只要是并发就会遇到竞争的问题，互斥量就是解决竞争的多种手段之一。 程序中每一个线程都要做：读取文件 — 累加 1 — 写入文件 的动作，如果 20 个线程同时做这件事，那么就很有可能多个线程读到的数据是相同的，这样累加的结果也就是相同的了，就没办法保证 20 个线程每个人读到的数据都是独一无二的了。 怎么样才能让 20 个线程读到独一无二的数值呢？很简单，让 读取文件 — 累加 1 — 写入文件 的这个动作同一时刻只能有一个线程来做，这样每个线程读取到的数值都是上一个线程写入的数值了。那么 读取文件 — 累加 1 — 写入文件 这段代码（也就是发生竞争的这段区域）就叫做“临界区”。 互斥量正如它的名字描述的一般，可以使各个线程实现互斥的效果。由它来保护临界区每次只能由一个线程进入，当一个线程想要进入临界区之前需要先抢锁（加锁），如果能抢到锁就进入临界区工作，并且要在离开的时候解锁以便让其它线程可以抢到锁进入临界区；如果没有抢到锁则进入阻塞状态等待锁被释放然后再抢锁。 要在进入临界区之前加锁，在退出临界区的时候解锁。 与 ptread_t 一样，互斥量也使用一种数据类型来表示，它使用 pthread_mutex_t 类型来表示。 初始化互斥量有两种方式： 1）用宏初始化：如同使用默认属性； 2）使用 pthread_mutex_init(3) 函数初始化，可以为互斥量指定属性。 pthread_mutex_t 使用完成之后需要使用 pthread_mutex_destroy(3) 函数销毁，否则会导致内存泄漏。 一般什么情况使用宏初始化，什么情况使用函数初始化互斥量呢？请看下面的伪代码： 前面说了，要在进入临界区之前加锁，在退出临界区的时候解锁。我们来了解一下加锁和解锁的函数。 12int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr * restrict attr);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 1pthread_mutex_destroy(); 1234567// pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock - lock and unlock a mutex#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex); // 阻塞等待int pthread_mutex_trylock(pthread_mutex_t *mutex); // 尝试等待int pthread_mutex_unlock(pthread_mutex_t *mutex); _lock() 是阻塞加锁，当抢锁的时候被抢不到就死等，直到别人通过 _unlock() 把这把锁解锁再抢。 _trylock() 是尝试加锁，无论能否抢到锁都返回。 临界区是每个线程要单独执行的，所以临界区中的代码执行时间越短越好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// add1.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define THRNUM 20#define FNAME \"./p\"#define LINESIZE 1024static pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;static void* thr_add(void *p)&#123; FILE *fp; char linebuf[LINESIZE]; fp = fopen(FNAME, \"r+\"); if(fp == NULL) &#123; perror(\"fopen()\"); exit(1); &#125; pthread_mutex_lock(&amp;mut); // 上锁 fgets(linebuf,LINESIZE,fp); // 将读取的内容放进 linebuf中 fseek(fp, 0, SEEK_SET); // 文件位置指针 指回去 sleep(1); fprintf(fp,\"%d\\n\", atoi(linebuf)+1); fclose(fp); pthread_mutex_unlock(&amp;mut); // 开锁 // 保证临界区代码每次只有一个线程在运行 pthread_exit(NULL);&#125;int main()&#123; int i,err; pthread_t tid[THRNUM]; for(i=0;i&lt;THRNUM;i++) &#123; err = pthread_create(tid+i, NULL, thr_add, NULL); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\",strerror(err)); exit(1); &#125; &#125;; for(i=0; i&lt;THRNUM; i++) &#123; pthread_join(tid[i], NULL); &#125; pthread_mutex_destroy(&amp;mut); exit(0);&#125; 加锁解锁针对的是一段代码，而不是一个变量 了解了互斥量之后，我们再来看一道经典的面试题：用 4 个线程疯狂的打印 abcd 持续 5 秒钟，但是要按照顺序打印，不能是乱序的。 1234567891011121314151617181920212223242526272829303132333435363738// abcd.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define THRNUM 4static void *thr_func(void *p)&#123; int c = 'a' + (int)p; while(1) write(1, &amp;c, 1); pthread_exit(NULL);&#125;int main()&#123; pthread_t tid[THRNUM]; int i, err; for(i =0 ;i&lt;THRNUM; i++) &#123; err = pthread_create(tid+i, NULL, thr_func, (void *)i); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; alarm(1); for(i=0; i&lt; THRNUM; i++) &#123; pthread_join(tid[i], NULL); &#125; exit(0);&#125; 123./abcdaaaaaaaa...# 结果不对，连续打了满篇的a，然后b 然后c 然后d 解决思路： 锁链，打印a的线程去解锁打印b的线程，b打印完解锁c，c打印完解锁d，d打印完解锁a； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#define THRNUM 4static pthread_mutex_t mut[THRNUM];static int next(int a)&#123; if(a+1 == THRNUM) return 0; return a+1;&#125;static void *thr_func(void *p)&#123; int n = (int)p; int ch = n + 'a'; while(1) &#123; pthread_mutex_lock(mut+n); write(1,&amp;ch,1); pthread_mutex_unlock(mut+next(n)); &#125; pthread_exit(NULL);&#125;int main()&#123; int i,err; pthread_t tid[THRNUM]; for(i = 0 ; i &lt; THRNUM ; i++) &#123; pthread_mutex_init(mut+i,NULL); pthread_mutex_lock(mut+i); err = pthread_create(tid+i,NULL,thr_func,(void *)i); if(err) &#123; fprintf(stderr,\"pthread_create():%s\\n\",strerror(err)); exit(1); &#125; &#125; pthread_mutex_unlock(mut+0); alarm(5); for(i = 0 ; i &lt; THRNUM ; i++) pthread_join(tid[i],NULL); exit(0);&#125; 1abcdabcdabcdabcdabcdabcd... 上面这段代码是通过多个互斥量实现了一个锁链的结构巧妙的实现了要求的效果。 首先定义 4 个互斥量，然后创建 4 个线程，每个互斥量对应一个线程，每个线程负责打印一个字母。4 个线程刚刚被创建好时，4 把锁都处于锁定状态，4 个线程全部都阻塞在临界区之外，等 4 个线程全部都创建好之后解锁其中一把锁。被解锁的线程首先将自己的互斥量上锁，然后打印字符再解锁下一个线程对应的互斥量，然后再次等待自己被解锁。如此往复，使 4 个线程有条不紊的循环执行 锁定自己 — 打印字符 – 解锁下一个线程 的步骤，这样打印到控制台上的 abcd 就是有序的了。 从上面的栗子可以看出来：互斥量限制的是一段代码能否执行，而不是一个变量或一个资源。 上面的代码虽然使用锁链巧妙的完成了任务，但是它的实现方式并不是最漂亮的，更好的办法我们下面介绍条件变量（pthread_cond_t）的时候会讨论。 1.3.1.1线程池在primer程序中，201个数字 用 201个线程去处理。现在变幻一下思路，用201个数字对应 N个线程。（N可以是3/4/甚至更多）只要保证当前进程空间可以创建出来这么多线程即可 分块法/交叉分配/池类写法 1.3.1.2 池类写法 非标准线程池写法，标准的进程池/线程池。 这个池并非标准线程池的写法。这里是任务池。 简单描述一下， 就是main发牌到牌桌，线程池到牌桌抢牌，抢到之后，给num 写成0. main获取到num为0 之后，再次发牌。顺便把num写成一个非0的值。当main把最后一张牌扔下来，然后确定被某一个线程抢走之后。那main就负责把这一块写成 -1.这个 -1 提醒下游线程退出。上游线程等着收尸。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define LEFT 30000000#define RIGHT 30000200#define THRNUM 4static int num = 0;static pthread_mutex_t mut_num = PTHREAD_COND_INITIALIZER;static void *thr_prime(void *p);int main()&#123; int i, err; pthread_t tid[THRNUM]; for(i = 0; i&lt; THRNUM; i++) &#123; err = pthread_create(tid+i, NULL, thr_prime, (void *)i); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; for(i = LEFT; i&lt;= RIGHT; i++) &#123; pthread_mutex_lock(&amp;mut_num);//-------------------上游------------------ 期待num！=0 while(num != 0) &#123; pthread_mutex_unlock(&amp;mut_num); // sleep(1); sleep会让当前进程进入 沉睡状态 用下面sched_yield sched_yield(); // sched 开头的全部是针对于调度器来操作的，sched_yield的作用是出让调度器给其他的线程， // 可以理解为一个非常短的sleep，不会引起当前进程的调度颠簸 // 这里调用该函数是希望其他线程能拿到 num的值， 并有机会改写num的值 pthread_mutex_lock(&amp;mut_num); &#125;// ------------------------------------------- num = i; pthread_mutex_unlock(&amp;mut_num); &#125; pthread_mutex_lock(&amp;mut_num); while(num!= 0) &#123; pthread_mutex_unlock(&amp;mut_num); sched_yield(); pthread_mutex_lock(&amp;mut_num); &#125; num = -1; // 当main发放 最后一张牌的时候，并不能直接置成 -1. 所以需要上面 // 的sched_yield 出让出去，让其他线程抢到； pthread_mutex_unlock(&amp;mut_num); for(i = 0; i&lt;THRNUM; i++) pthread_join(tid[i], NULL); // 给线程收尸 pthread_mutex_destroy(&amp;mut_num); exit(0);&#125;static void *thr_prime(void *p)&#123; int i, j, mark; while(1) &#123; pthread_mutex_lock(&amp;mut_num);//--------------------下游------------------------------期待变成非 0 while(num == 0) &#123; pthread_mutex_unlock(&amp;mut_num); sched_yield(); pthread_mutex_lock(&amp;mut_num); &#125; if(num == -1) &#123; pthread_mutex_unlock(&amp;mut_num); break; // 临界区内的任何一个跳转语句，这个跳转如果是跳转到临界区以外的。一定不要忘了解锁再 // 跳转。 &#125; // 如何写多并发程序不会造成死锁。 i = num; num = 0; pthread_mutex_unlock(&amp;mut_num); mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"[%d]%d is a primer\\n\", (int)p, i); &#125; pthread_exit(NULL);&#125; 123456789101112131415161718[3]30000023 is a primer[1]30000037 is a primer[0]30000041 is a primer[2]30000001 is a primer[1]30000059 is a primer[3]30000049 is a primer[2]30000079 is a primer[0]30000071 is a primer[1]30000083 is a primer[3]30000109 is a primer[2]30000133 is a primer[0]30000137 is a primer[1]30000149 is a primer[3]30000163 is a primer[2]30000167 is a primer[0]30000169 is a primer[1]30000193 is a primer[3]30000199 is a primer 总结 细心会发现，在运行程序时，会有一些卡顿。而且cpu使用率一下上去了。该程序其实还是一个盲等的版本。 上下游都在等待。（代码中查看上下游位置）。现在某一个任务已经被下游线程取走了，上游的main总是抢不到锁，一直阻塞在lock。下游的线程总是在被调度，不停的lock，发现是0 然后解锁， 因为下游线程较多。上游是一个人在抢，下游是4个人在抢。因此抢到的几率是不同的所以该程序是个盲等版，盲在不停的在查看状态。确保这个状态是自己要的那个状态。可以尝试优化成通知法。上游等待num变成0，有人通知自己。就把新任务放进去。而下游等上游把任务放进去之后发一个通知或者消息，下游叫醒任何一个线程来计算这个任务。 大家还记得我们在上一篇博文中提到过令牌桶吗？当时只是实现了一个简单的令牌桶，这次我们来写一个通用的多线程并发版的令牌桶。 123456789101112131415161718/* mytbf.h */#ifndef MYTBF_H__#define MYTBF_H__#define MYTBF_MAX 1024typedef void mytbf_t;mytbf_t *mytbf_init(int cps,int burst);int mytbf_fetchtoken(mytbf_t *,int);int mytbf_returntoken(mytbf_t *,int );void mytbf_destroy(mytbf_t *);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/* mytbf.c 原博客 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include \"mytbf.h\"/* 每一个令牌桶 */struct mytbf_st&#123; int cps; // 速率 int burst; // 令牌上限 int token; // 可用令牌数量 int pos; // 当前令牌桶在 job 数组中的下标 pthread_mutex_t mut; // 用来保护令牌竞争的互斥量&#125;;/* 所有的令牌桶 */static struct mytbf_st *job[MYTBF_MAX];/* 用来保护令牌桶数组竞争的互斥量 */static pthread_mutex_t mut_job = PTHREAD_MUTEX_INITIALIZER;/* 添加令牌的线程 ID */static pthread_t tid;/* 初始化添加令牌的线程 */static pthread_once_t init_once = PTHREAD_ONCE_INIT;/* 线程处理函数：负责定时向令牌桶中添加令牌 */static void *thr_alrm(void *p)&#123; int i; while(1) &#123; pthread_mutex_lock(&amp;mut_job); // 遍历所有的桶 for(i = 0 ; i &lt; MYTBF_MAX; i++) &#123; // 为可用的桶添加令牌 if(job[i] != NULL) &#123; pthread_mutex_lock(&amp;job[i]-&gt;mut); job[i]-&gt;token += job[i]-&gt;cps; // 桶中可用的令牌不能超过上限 if(job[i]-&gt;token &gt; job[i]-&gt;burst) job[i]-&gt;token = job[i]-&gt;burst; pthread_mutex_unlock(&amp;job[i]-&gt;mut); &#125; &#125; pthread_mutex_unlock(&amp;mut_job); // 等待一秒钟后继续添加令牌 sleep(1); &#125; pthread_exit(NULL);&#125;static void module_unload(void)&#123; int i; pthread_cancel(tid); pthread_join(tid,NULL); pthread_mutex_lock(&amp;mut_job); for(i = 0 ; i &lt; MYTBF_MAX ; i++) &#123; if(job[i] != NULL) &#123; // 互斥量使用完毕不要忘记释放资源 pthread_mutex_destroy(&amp;job[i]-&gt;mut); free(job[i]); &#125; &#125; pthread_mutex_unlock(&amp;mut_job); pthread_mutex_destroy(&amp;mut_job);&#125;static void module_load(void)&#123; int err; err = pthread_create(&amp;tid,NULL,thr_alrm,NULL); if(err) &#123; fprintf(stderr,\"pthread_create():%s\\n\",strerror(err)); exit(1); &#125; atexit(module_unload);&#125;/* * 为了不破坏调用者对令牌桶操作的原子性，* 在该函数内加锁可能会导致死锁，* 所以该函数内部无法加锁，* 必须在调用该函数之前先加锁。*/static int get_free_pos_unlocked(void)&#123; int i; for(i = 0 ; i &lt; MYTBF_MAX; i++) if(job[i] == NULL) return i; return -1;&#125;mytbf_t *mytbf_init(int cps,int burst)&#123; struct mytbf_st *me; int pos; pthread_once(&amp;init_once,module_load); me = malloc(sizeof(*me)); if(me == NULL) return NULL; me-&gt;cps = cps; me-&gt;burst = burst; me-&gt;token = 0; pthread_mutex_init(&amp;me-&gt;mut,NULL); pthread_mutex_lock(&amp;mut_job); pos = get_free_pos_unlocked(); if(pos &lt; 0) &#123; // 带锁跳转不要忘记先解锁再跳转 pthread_mutex_unlock(&amp;mut_job); free(me); return NULL; &#125; me-&gt;pos = pos; job[pos] = me; pthread_mutex_unlock(&amp;mut_job); return me;&#125;static inline int min(int a,int b)&#123; return (a &lt; b) ? a : b;&#125;int mytbf_fetchtoken(mytbf_t *ptr,int size)&#123; int n; struct mytbf_st *me = ptr; if(size &lt; 0) return -EINVAL; pthread_mutex_lock(&amp;me-&gt;mut); // 令牌数量不足，等待令牌被添加进来 while(me-&gt;token &lt;= 0) &#123; // 先解锁，出让调度器让别人先跑起来，然后再抢锁检查令牌是否够用 pthread_mutex_unlock(&amp;me-&gt;mut); sched_yield(); pthread_mutex_lock(&amp;me-&gt;mut); &#125; n = min(me-&gt;token,size); me-&gt;token -= n; pthread_mutex_unlock(&amp;me-&gt;mut); return n;&#125;/* 令牌用不完要归还哟，可不能浪费了 */int mytbf_returntoken(mytbf_t *ptr,int size)&#123; struct mytbf_st *me = ptr; // 逗我玩呢？ if(size &lt; 0) return -EINVAL; pthread_mutex_lock(&amp;me-&gt;mut); me-&gt;token += size; if(me-&gt;token &gt; me-&gt;burst) me-&gt;token = me-&gt;burst; pthread_mutex_unlock(&amp;me-&gt;mut); return size;&#125;void mytbf_destroy(mytbf_t *ptr)&#123; struct mytbf_st *me = ptr; pthread_mutex_lock(&amp;mut_job); job[me-&gt;pos] = NULL;pthread_mutex_unlock(&amp;mut_job); pthread_mutex_destroy(&amp;me-&gt;mut); free(ptr);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186// me #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"mytbf.h\"#include &lt;pthread.h&gt;#include &lt;errno.h&gt;static struct mytbf_st* job[MYTBF_MAX];static pthread_mutex_t mut_job = PTHREAD_MUTEX_INITIALIZER;static pthread_t tid_alrm;static pthread_once_t init_once = PTHREAD_ONCE_INIT;static int inited = 0;struct mytbf_st&#123; int cps; int burst; int token; int pos; pthread_mutex_t mut;&#125;;static void module_unload(void)&#123; int i; pthread_cancel(tid_alrm); pthread_join(tid_alrm, NULL); for(i=0; i&lt; MYTBF_MAX; i++) &#123; mytbf_destroy(job[i]); &#125; pthread_mutex_destroy(&amp;mut_job);&#125;static int get_free_pos_unloaded(void)&#123; int i; for(i =0; i&lt;MYTBF_MAX; i++) &#123; if(job[i] == NULL) return i; &#125; return -1;&#125;static void *thr_alrm(void *s)&#123; int i; while(1) &#123; pthread_mutex_lock(&amp;mut_job); for(i=0; i&lt; MYTBF_MAX; i++) &#123; if(job[i]!= NULL) &#123; pthread_mutex_lock(&amp;job[i]-&gt;mut); job[i]-&gt;token += job[i]-&gt;cps; if(job[i]-&gt;token &gt; job[i]-&gt;burst) job[i]-&gt;token = job[i]-&gt;burst; pthread_mutex_unlock(&amp;job[i]-&gt;mut); &#125; &#125; pthread_mutex_unlock(&amp;mut_job); sleep(1); &#125;&#125;static void module_load(void)&#123; int err; err = pthread_create(&amp;tid_alrm, NULL, thr_alrm, NULL); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; atexit(module_unload);&#125;mytbf_t *mytbf_init(int cps, int burst)&#123; int pos; struct mytbf_st *me; // if(!inited) // &#123; // module_load(); // inited = 1; // &#125; // 用 pthread_once 代替上面语句 pthread_once(&amp;init_once, module_load); me = malloc(sizeof(*me)); if (me == NULL) return NULL; me-&gt;token = 0; me-&gt;cps = cps; me-&gt;burst = burst; pthread_mutex_init(&amp;me-&gt;mut, NULL); pthread_mutex_lock(&amp;mut_job); pos = get_free_pos_unloaded(); // 在数组中 找空位 if(pos &lt; 0) &#123; pthread_mutex_unlock(&amp;mut_job); free(me); return NULL; &#125; me-&gt;pos = pos; job[pos] = me; //将该结构体存储至 数组中 pthread_mutex_unlock(&amp;mut_job); return me;&#125;static int min(int a, int b)&#123; if(a&lt;b)&#123; return a; &#125; return b;&#125;int mytbf_fetchtoken(mytbf_t *ptr, int size)&#123; int n; struct mytbf_st *me = ptr; if(size &lt;= 0) return -EINVAL; pthread_mutex_lock(&amp;me-&gt;mut); // 盲在这里 while(me-&gt;token &lt;= 0) // 这里一秒钟 循环数次 &#123; pthread_mutex_unlock(&amp;me-&gt;mut); sched_yield(); pthread_mutex_lock(&amp;me-&gt;mut); &#125; n = min(me-&gt;token, size); me-&gt;token -= n; pthread_mutex_unlock(&amp;me-&gt;mut); return n;&#125;int mytbf_returntoken(mytbf_t * ptr, int size)&#123; struct mytbf_st *me = ptr; if(size &lt;= 0) return -EINVAL; pthread_mutex_lock(&amp;me-&gt;mut); me-&gt;token += size; if(me-&gt;token &gt; me-&gt;burst) me-&gt;token = me-&gt;burst; pthread_mutex_unlock(&amp;me-&gt;mut); return size;&#125;int mytbf_destroy(mytbf_t *ptr)&#123; // 因为 ptr是 void类型，所以不能直接 ptr-&gt;pos struct mytbf_st *me = ptr; pthread_mutex_lock(&amp;mut_job); job[me -&gt; pos] = NULL; pthread_mutex_unlock(&amp;mut_job); pthread_mutex_destroy(&amp;me-&gt;mut); free(ptr); return 0;&#125; 该程序依然是盲等法， 上面这个令牌桶库可以支持最多 1024 个桶，也就是可以使用多线程同时操作这 1024 个桶来获得不同的速率，每个桶的速率是固定的。 这 1024 个桶保存在一个数组中，所以每次访问桶的时候都需要对它进行加锁，避免多个线程同时访问发生竞争。 同样每个桶也允许使用多个线程同时访问，所以每个桶中也需要一个互斥量来保障处理令牌的时候不会发生竞争。 写互斥量的代码一定要注意临界区内的所有的跳转，通常在跳转之前需要解锁，避免产生死锁。常见的跳转包括 continue; break; return; goto; longjmp(3); 等等，甚至函数调用也是一种跳转。 当某个函数内包含临界区，也就是需要加锁再进入临界区，但是从程序的布局来看该函数无法加锁，那么根据 POSIX 标准的约定，这种函数的命名规则是必须以 _unlocked 作为后缀，所以大家在看到这样的函数时在调用之前一定要先加锁。总结起来说就是以这个后缀命名的函数表示函数内需要加锁但是没有加锁，所以调用者需要先加锁再调用，例如上面代码中的 get_free_pos_unlocked() 函数。 LZ 来解释一下上面这个令牌桶中用过的几个没见过的函数。 123// sched_yield — yield the processor#include &lt;sched.h&gt;int sched_yield(void); sched_yield(2) 这个函数的作用是出让调度器。在用户态无法模拟它的实现，它会让出当前线程所占用的调度器给其它线程使用，而不必等待时间片耗尽才切换调度器，大家暂时可以把它理解成一个很短暂的 sleep(3) 。一般用于在使用一个资源时需要同时获得多把锁但是却没法一次性获得全部的锁的场景下，只要有任何一把锁没有抢到，那么就立即释放已抢到的锁，并让出自己的调度器让其它线程有机会获得被自己释放的锁。当再次调度到自己时再重新抢锁，直到能一次性抢到所有的锁时再进入临界区，这样就避免了出现死锁的情况。 动态模块的单次初始化函数 1234567// pthread_once - dynamic package initialization#include &lt;pthread.h&gt;int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));pthread_once_t once_control = PTHREAD_ONCE_INIT; pthread_once(3) 函数一般用于动态单次初始化，它能保证 init_routine 函数仅被调用一次。 pthread_once_t 只能使用 PTHREAD_ONCE_INIT 宏初始化，没有提供其它初始化方式。这个与我们前面见到的初始化 pthread_t 和 pthread_nutex_t 不一样。 上面的代码中，向令牌桶添加令牌的线程只需要启动一次，而初始化令牌桶的函数却在开启每个令牌桶的时候都需要调用。为了在初始化令牌桶的函数中仅启动一次添加令牌的线程，采用 pthread_once(3) 函数来创建线程就可以了。这样之后在第一次调用 mytbf_init() 函数的时候会启动新线程添加令牌，而后续再调用 mytbf_init() 的时候就不会启动添加令牌的线程了。 上面代码中调用 pthread_once(3) 相当于下面的伪代码： 1234567lock();if (init_flag)&#123; init_flag = 0; // do sth&#125;unlock(); 1234567pthread_mutex_t;pthread_mutex_init();pthread_mutex_destroy();pthread_mutex_lock();pthread_mutex_trylock();pthread_mutex_unlock();pthread_once(); 1.3.2 通知法 上面的几种方法是盲等法，下面介绍通知法。 条件变量（pthread_cond_t）（通知法的一种机制） 上面的程序经过测试，发现 CPU 正在满负荷工作，说明程序中出现了忙等， 是哪里出现了忙等呢？其实就是 mytbf_fetchtoken() 函数获得锁的时候采用了忙等的方式。前面我们提到过，异步程序有两种处理方式，一种是通知法，一种是查询法，我们这里用的就是查询法，下面我们把它修改成个通知法来实现。 123456789#include &lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);pthread_cond_t cond = PTHREAD_COND_INITIALIZER;int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include \"mytbf.h\"/* 每一个令牌桶 */struct mytbf_st&#123; int cps; // 速率 int burst; // 令牌上限 int token; // 可用令牌数量 int pos; // 当前令牌桶在 job 数组中的下标 pthread_mutex_t mut; // 用来保护令牌竞争的互斥量 pthread_cond_t cond; // 用于在令牌互斥量状态改变时发送通知&#125;;/* 所有的令牌桶 */static struct mytbf_st *job[MYTBF_MAX];/* 用来保护令牌桶数组竞争的互斥量 */static pthread_mutex_t mut_job = PTHREAD_MUTEX_INITIALIZER;/* 添加令牌的线程 ID */static pthread_t tid;/* 初始化添加令牌的线程 */static pthread_once_t init_once = PTHREAD_ONCE_INIT;/* 线程处理函数：负责定时向令牌桶中添加令牌 */static void *thr_alrm(void *p)&#123; int i; while (1) &#123; pthread_mutex_lock(&amp;mut_job); // 遍历所有的桶 for (i = 0; i &lt; MYTBF_MAX; i++) &#123; // 为可用的桶添加令牌 if (job[i] != NULL) &#123; pthread_mutex_lock(&amp;job[i]-&gt;mut); job[i]-&gt;token += job[i]-&gt;cps; // 桶中可用的令牌不能超过上限 if (job[i]-&gt;token &gt; job[i]-&gt;burst) job[i]-&gt;token = job[i]-&gt;burst; // 令牌添加完毕之后，通知所有等待使用令牌的线程准备抢锁 // 因为 pthread_cond_sigal 只能唤醒一个等待，假如当前有10个令牌桶都在等待取token pthread_cond_broadcast(&amp;job[i]-&gt;cond); pthread_mutex_unlock(&amp;job[i]-&gt;mut); // 先broadcast/sigal 还是 先 unlock 区别并不大 &#125; &#125; pthread_mutex_unlock(&amp;mut_job); // 等待一秒钟后继续添加令牌 sleep(1); &#125; pthread_exit(NULL);&#125;static void module_unload(void)&#123; int i; pthread_cancel(tid); pthread_join(tid, NULL); pthread_mutex_lock(&amp;mut_job); for (i = 0; i &lt; MYTBF_MAX; i++) &#123; if (job[i] != NULL) &#123; // 互斥量和条件变量使用完之后不要忘记释放资源 pthread_mutex_destroy(&amp;job[i]-&gt;mut); pthread_cond_destroy(&amp;job[i]-&gt;cond); free(job[i]); &#125; &#125; pthread_mutex_unlock(&amp;mut_job); pthread_mutex_destroy(&amp;mut_job);&#125;static void module_load(void)&#123; int err; err = pthread_create(&amp;tid, NULL, thr_alrm, NULL); if (err) &#123; fprintf(stderr, \"pthread_create():%s\\n\", strerror(err)); exit(1); &#125; atexit(module_unload);&#125;/* * 为了不破坏调用者对令牌桶操作的原子性， * 在该函数内加锁可能会导致死锁， * 所以该函数内部无法加锁， * 必须在调用该函数之前先加锁。 */static int get_free_pos_unlocked(void)&#123; int i; for (i = 0; i &lt; MYTBF_MAX; i++) if (job[i] == NULL) return i; return -1;&#125;mytbf_t *mytbf_init(int cps, int burst)&#123; struct mytbf_st *me; int pos; pthread_once(&amp;init_once, module_load); me = malloc(sizeof(*me)); if (me == NULL) return NULL; me-&gt;cps = cps; me-&gt;burst = burst; me-&gt;token = 0; pthread_mutex_init(&amp;me-&gt;mut, NULL); pthread_cond_init(&amp;me-&gt;cond, NULL); pthread_mutex_lock(&amp;mut_job); pos = get_free_pos_unlocked(); if (pos &lt; 0) &#123; pthread_mutex_unlock(&amp;mut_job); free(me); return NULL; &#125; me-&gt;pos = pos; job[pos] = me; pthread_mutex_unlock(&amp;mut_job); return me;&#125;static inline int min(int a, int b)&#123; return (a &lt; b) ? a : b;&#125;int mytbf_fetchtoken(mytbf_t *ptr, int size)&#123; int n; struct mytbf_st *me = ptr; if (size &lt; 0) return -EINVAL; pthread_mutex_lock(&amp;me-&gt;mut); // 令牌数量不足，等待令牌被添加进来 while (me-&gt;token &lt;= 0) &#123; /* * 原子化的解锁、出让调度器再抢锁以便工作或等待 * 它会等待其它线程发送通知再唤醒 * 放在循环中是因为可能同时有多个线程再使用同一个桶， * 被唤醒时未必就能拿得到令牌，所以要直到能拿到令牌再出去工作 */ // 发现 me-&gt;token &lt;= 0 // 就解锁等待，等到什么时候。等待 pthread_cond_broadcast/pthread_cond_signal // pthread_cond_broadcast是发通知/发消息，来打断一个wait，signal是打断任意一个wait。 pthread_cond_wait(&amp;me-&gt;cond, &amp;me-&gt;mut); // 解锁等待 // pthread_cond_wait 相当于下面三句话的功能，但不是等价封装； // pthread_mutex_unlock(&amp;me-&gt;mut); // sched_yield(); // pthread_mutex_lock(&amp;me-&gt;mut); &#125; n = min(me-&gt;token, size); me-&gt;token -= n; pthread_mutex_unlock(&amp;me-&gt;mut); return n;&#125;/* 令牌用不完要归还哟，可不能浪费了 */int mytbf_returntoken(mytbf_t *ptr, int size)&#123; struct mytbf_st *me = ptr; // 逗我玩呢？ if (size &lt; 0) return -EINVAL; pthread_mutex_lock(&amp;me-&gt;mut); me-&gt;token += size; if (me-&gt;token &gt; me-&gt;burst) me-&gt;token = me-&gt;burst; /* * 令牌归还完毕，通知其它正在等待令牌的线程赶紧起床，准备抢锁 * 这两行谁在上面谁在后面都无所谓 * 如果先发通知再解锁，收到通知的线程发现锁没有释放会等待锁释放再抢； * 如果先解锁再发通知，反正已经出了临界区了， * 就算有线程在通知发出之前抢到了锁也不会发生竞争， * 大不了其它被唤醒的线程起床之后发现没有锁可以抢，那就继续睡呗。 */ pthread_cond_broadcast(&amp;me-&gt;cond); pthread_mutex_unlock(&amp;me-&gt;mut); return size;&#125;int mytbf_destroy(mytbf_t *ptr)&#123; struct mytbf_st *me = ptr; pthread_mutex_lock(&amp;mut_job); job[me-&gt;pos] = NULL; pthread_mutex_unlock(&amp;mut_job); pthread_mutex_destroy(&amp;me-&gt;mut); pthread_cond_destroy(&amp;me-&gt;cond); free(ptr);&#125; 大家不难看出这两段代码的差别，把查询法（忙等）修改为通知法（非忙等）仅仅加一个条件变量（pthread_cond_t） 就行了。 条件变量的作用是什么？其实就是让线程以无竞争的形式等待某个条件的发生，当条件发生时通知等待的线程醒来去做某件事。 通知进程醒来有两种方式，一种是仅通知一个线程醒来，如果有多个线程都在等待，那么不一定是哪个线程被唤醒；另一种方式是把所有等待同一个条件的线程都唤醒。 在下面我们会介绍这两种方式，先从条件变量的初始化和销毁开始讨论。 12345678// pthread_cond_destroy, pthread_cond_init - destroy and initialize condition variables #include &lt;pthread.h&gt; int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 与互斥量一样，条件变量也有两种方式初始化，一种是使用 pthread_cond_init(3) 函数，另一种是使用 PTHREAD_COND_INITIALIZER 宏。这两种方式的使用场景也与互斥量相同，这里就不再赘述了。 条件变量在使用完毕之后不要忘记用 pthread_cond_destroy(3) 函数释放资源，否则会导致内存泄漏！ 123456// pthread_cond_broadcast, pthread_cond_signal - broadcast or signal a condition#include &lt;pthread.h&gt; int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond); 这两个函数就是条件变量的关键操作了，大家注意看。 pthread_cond_signal(3) 函数用于唤醒当前多个等待的线程中的任何一个。虽然名字上有 signal，但是跟系统中的信号没有任何关系。 pthread_cond_broadcast(3) 惊群，将现在正在等待的线程全部唤醒。 123456789// pthread_cond_timedwait, pthread_cond_wait - wait on a condition#include &lt;pthread.h&gt;int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); 这几个函数与上面的两个函数的作用是成对的，上面的两个函数用于唤醒线程，唤醒什么线程呢？当然是唤醒 _wait() 等待条件满足的线程啦。 当一个线程做某件事之前发现条件不满足，那就使用这几个 _wait() 函数进入等待状态，当某个线程使条件满足了就要用上面的两个函数唤醒等待的线程继续工作了。 pthread_cond_wait(3) 在临界区外阻塞等待某一个条件发生变化，直到有一个通知到来打断它的等待。这种方式是死等。 pthread_cond_timedwait(3) 增加了超时功能的等待，超时之后无论能否拿到锁都返回。这种方式是尝试等。 pthread_cond_wait(3) 相当于下面三行代码的原子操作： 123pthread_mutex_unlock(mutex);sched_yield();pthread_mutex_lock(mutex); 通常等待会放在一个循环中，就像上面的令牌桶栗子一样，因为可能有多个线程都在等待条件满足，当前的线程被唤醒时不代表执行条件一定满足，可能先被唤醒的线程发现条件满足已经去工作了，等轮到当前线程调度的时候条件可能就又不满足了，所以如果条件不满足需要继续进入等待。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// primer0_pool.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define LEFT 30000000#define RIGHT 30000200#define THRNUM 4/** * 期待num 变成一个任务，然后就能去抢任务了。 * 忙等，忙在哪里？ * 忙在上流和下流在不停的 抢num， 看状态。下流在抢num ，期待它不是 0. * 变为通知法，逻辑应该是 * 下流一直处于等待状态，上流往num中放了一个任务之后。发一个通知，下流的几个都在wait。 * 上流其实 发一个 signal就可以，因为下游的任务长的一样，叫醒任何一个让它拿num的值去计算即可*/static int num = 0;static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t cond_num = PTHREAD_COND_INITIALIZER;static void *thr_prime(void *p);int main()&#123; int i, err; pthread_t tid[THRNUM]; for(i = 0; i&lt; THRNUM; i++) &#123; err = pthread_create(tid+i, NULL, thr_prime, (void *)i); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; for(i = LEFT; i&lt;= RIGHT; i++) &#123; pthread_mutex_lock(&amp;mut_num); while(num != 0) &#123; // pthread_mutex_unlock(&amp;mut_num); // // sleep(1); sleep会让当前进程进入 沉睡状态 造成调度颠簸，用下面sched_yield // sched_yield(); // sched 开头的全部是针对于调度器来操作的，sched_yield的作用是出让调度器给其他的线程， // // 可以理解为一个非常短的sleep，但不会引起当前进程的调度颠簸 // // 这里调用该函数是希望其他线程能拿到 num的值， 并有机会改写num的值 // pthread_mutex_lock(&amp;mut_num); pthread_cond_wait(&amp;cond_num, &amp;mut_num); // 解锁在临界区外的等待 &#125; num = i; pthread_cond_signal(&amp;cond_num); pthread_mutex_unlock(&amp;mut_num); &#125; pthread_mutex_lock(&amp;mut_num); while(num!= 0) &#123; pthread_mutex_unlock(&amp;mut_num); sched_yield(); pthread_mutex_lock(&amp;mut_num); &#125; num = -1; // 当main发放 最后一张牌的时候，并不能直接置成 -1. 须先调用sched_yield 出让出去，让其他线程抢到； pthread_cond_broadcast(&amp;cond_num); pthread_mutex_unlock(&amp;mut_num); for(i = 0; i&lt;THRNUM; i++) pthread_join(tid[i], NULL); // 给线程收尸 pthread_mutex_destroy(&amp;mut_num); // 销毁互斥量 pthread_cond_destroy(&amp;cond_num); // 销毁条件变量 exit(0);&#125;static void *thr_prime(void *p)&#123; int i, j, mark; while(1) &#123; pthread_mutex_lock(&amp;mut_num); while(num == 0) &#123; // pthread_mutex_unlock(&amp;mut_num); // sched_yield(); // pthread_mutex_lock(&amp;mut_num); pthread_cond_wait(&amp;cond_num, &amp;mut_num); &#125; if(num == -1) &#123; pthread_mutex_unlock(&amp;mut_num); break; // 临界区内的任何一个跳转到临界区以外的break。跳转之前须解锁 &#125; i = num; num = 0; pthread_cond_broadcast(&amp;cond_num); pthread_mutex_unlock(&amp;mut_num); mark = 1; for(j=2;j&lt;i/2;j++) &#123; if(i%j==0) &#123; mark = 0; break; &#125; &#125; if (mark) printf(\"[%d]%d is a primer\\n\", (int)p, i); &#125; pthread_exit(NULL);&#125; 还记得我们上面提到的面试题吗？用锁链实现的疯狂的有序的打印 abcd 5 秒钟。 上面我们说了，锁链的办法并不是这道题的考点，这道题真正的考点其实是使用互斥量 + 条件变量的方式来实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define THRNUM 4static int next(int n)&#123; if(n+1 == THRNUM) return 0; return n+1;&#125;/** * 使用条件变量将其变为通知法*/static int num = 0;static pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;static void *thr_func(void *p)&#123; int n = (int)p; int c = 'a' + n; while(1) &#123; pthread_mutex_lock(&amp;mut); while(num != n) pthread_cond_wait(&amp;cond, &amp;mut); write(1, &amp;c, 1); num = next(num); pthread_cond_broadcast(&amp;cond); pthread_mutex_unlock(&amp;mut); &#125; pthread_exit(NULL);&#125;int main()&#123; pthread_t tid[THRNUM]; int i, err; for(i =0 ;i&lt;THRNUM; i++) &#123; err = pthread_create(tid+i, NULL, thr_func, (void *)i); if(err) &#123; fprintf(stderr, \"pthread_create(): %s\\n\", strerror(err)); exit(1); &#125; &#125; alarm(1); for(i=0; i&lt; THRNUM; i++) &#123; pthread_join(tid[i], NULL); &#125; pthread_mutex_destroy(&amp;mut); pthread_cond_destroy(&amp;cond); exit(0);&#125; 1.3.3 信号量（Semaphore） 一个控制同时访问一个资源的线程（进程）数量的抽象数据类型； 信号量 内部封装了一个整数（p）和一个睡眠线程集合（s），并提供两个原子操作 up() p = p+1 如果s.size() &gt; 0, 从s中选择一个唤醒并执行 down() If(p==0){sleep(&amp;semaphore)} p– 如何理解TSL/Semaphore/Mutex的关系 TSL/XCHG是基础能力（否则就得用忙等待算法） Semaphore是一种基于TSL成立的算法和数据结构（理解成解决方案） Mutex是Semaphore的一种产出（特殊情况） 算法数据结构当然无穷无尽，参考：AQS(Abstract Queued) CAS（Compare and Swap） 线程1 和线程2 需要对需要访问的临界区变量a都保留了自己本地的一个copy； 当线程2，加1之后，并同步到临界区中。线程1也想将a+1， 因此先将本地a+1，为了不要出问题选择了将本地的101和临界区比较，因此发现了冲突；谁冲突谁解决，所以线程1需要自己解决；这种机制会唤做 乐观锁； 读不需要同步 写需要同步 适用于写操作较少，读操作较多的场景 注意：临界区的操作依然需锁 1.3.4 读写锁 互斥量和信号量的综合使用 读写锁： 读锁-&gt; 共享锁 写锁 -&gt; 互斥锁 那么应该在什么场景中选择使用 pthread_cond_signal(3) 还是使用 pthread_cond_broadcast(3) 呢？ 这个其实没有固定的套路，要根据具体的场景来选择。一般只有一个线程在等待或者明确知道哪个线程应该被唤醒的时候使用 _signal() 函数，如果有多个线程在等待并且不确定应该由谁起来工作的时候使用惊群。 LZ 说的不确定是指业务上不能确定哪个线程应该工作，而不是你作为程序猿稀里糊涂的不知道哪个线程该工作。程序猿应该保证了解你的每一行代码在做什么，而不要写出一坨自己都不知道它在做什么的代码。 至于应该先发通知再解锁还是先解锁再发通知，效果上没有太大的区别，这一点在上面令牌桶的栗子中已经阐述了。 11.下面纯属吐槽： 处理常规任务时，是采用多线程比较快还是采用多进程比较快？ 如果只回答多线程比较快，那么你歇了。 应该回答常规情况下是多线程较快，因为多进程需要重新布置进程的执行空间，还需要进行数据拷贝以及部分配置，所以会比创建线程慢xx倍。不要只回答一个大方向就完事了，而是要量化你的答案，这样才能体现出来你在平时学习工作中很注重这些细节问题。 12.一个进程最多能创建多少个线程 一个进程能够创建多少个线程呢？主要受两个因素影响，一个是 PID 耗尽，一个是我们在之前的博文中画 C 程序地址空间布局时的阴影区域被栈空间占满了 。（不记得那副图了，去前面的博文里找找。） PID 看上去是进程 ID，但是在之前讨论进程的博文中我们讨论过，内核的最小执行单元其实是线程，实际上是线程在消耗 PID。一个系统中的线程可以有很多，所以 PID 被耗尽也是有可能的。 使用 ulimit(1) 命令可以查看栈空间的大小，阴影区剩余空间的大小 / 栈空间的大小 == 就是我们能创建的线程数量。 大家可以自己写个程序测试一下一个进程最多能够创建多少个线程，然后使用 ulimit(1) 命令修改栈的大小再测试几次，看看能有什么发现。代码很简单，LZ 就不贴出来了。 13.管道的特点 1）管道的同义词是队列； 2）管道是单工的； 3）管道必须凑齐读写双方，如果只有一方，则阻塞等待。 关于管道的详细内容，我们在后面讨论进程间通信（IPC）的时候还会再详细讨论。","categories":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"nginx","slug":"test","date":"2020-12-09T14:19:03.750Z","updated":"2020-12-18T05:42:10.435Z","comments":true,"path":"2020/12/09/test/","link":"","permalink":"http://yoursite.com/2020/12/09/test/","excerpt":"","text":"配置hexo到阿里云 网上大多数教程问题不大，额外需要注意修改一些文件的写入权限 1234567# 将post-receive 设置为可执行文件chmod +x ~/hexo.git/hooks/post-receivecd ~# 设置博客源地址文件夹权限，不然git hooks写入不了，Unable to unlink 就是这种原因sudo chmod -R 777 /home/www/hexo","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo","slug":"hello-world","date":"2020-06-04T03:45:32.772Z","updated":"2020-12-18T05:41:36.853Z","comments":true,"path":"2020/06/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy test12345function helloworld() &#123; return 'hello world'&#125;console.log(helloworld); More info: Deployment","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"patten","slug":"patten","permalink":"http://yoursite.com/categories/patten/"},{"name":"chan","slug":"chan","permalink":"http://yoursite.com/categories/chan/"},{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"davinci","slug":"davinci","permalink":"http://yoursite.com/categories/davinci/"},{"name":"browser","slug":"browser","permalink":"http://yoursite.com/categories/browser/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"},{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"},{"name":"net","slug":"net","permalink":"http://yoursite.com/categories/net/"},{"name":"rust","slug":"rust","permalink":"http://yoursite.com/categories/rust/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"},{"name":"graphics","slug":"graphics","permalink":"http://yoursite.com/categories/graphics/"},{"name":"algebra","slug":"algebra","permalink":"http://yoursite.com/categories/algebra/"},{"name":"algo","slug":"algo","permalink":"http://yoursite.com/categories/algo/"},{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/categories/webgl/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/categories/canvas/"},{"name":"language","slug":"language","permalink":"http://yoursite.com/categories/language/"},{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"},{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"},{"name":"apue","slug":"apue","permalink":"http://yoursite.com/categories/apue/"}],"tags":[{"name":"guide","slug":"guide","permalink":"http://yoursite.com/tags/guide/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"pro","slug":"pro","permalink":"http://yoursite.com/tags/pro/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"},{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}