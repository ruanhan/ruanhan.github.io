{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-08-20T05:55:31.000Z","updated":"2020-08-20T07:19:22.806Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-20T05:58:38.000Z","updated":"2020-08-20T07:18:21.424Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ts doc","slug":"ts-doc","date":"2021-01-19T08:12:21.000Z","updated":"2021-01-20T09:11:44.538Z","comments":true,"path":"2021/01/19/ts-doc/","link":"","permalink":"http://yoursite.com/2021/01/19/ts-doc/","excerpt":"","text":"handbookA reader who completes the walkthrough should be able to: Read and understand commonly-used TypeScript syntax and patterns Explain the effects of important compiler options Correctly predict type system behavior in most cases Write a .d.ts declaration for a simple function, object, or class 1. basic Types 在TypeScript中，我们支持与JavaScript中期望的类型相同的类型，并添加了一个额外的枚举类型以帮助处理问题。 Boolean, Number, String, Array,Tuple,Enum,Unkown,Any,Void, Null and Undefined, Never, Object, Tuple 元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对字符串和一个数字： 123456// Declare a tuple typelet x: [string, number];// Initialize itx = [\"hello\", 10]; // OK// Initialize it incorrectlyx = [10, \"hello\"]; // Error Enum 枚举是JavaScript标准数据类型集的一个有用补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。 123456789enum Color &#123; Red = 1, Green, Blue,&#125;let colorName: string = Color[2];// Displays 'Green'console.log(colorName); Unknown 我们可能需要描述编写应用程序时不知道的变量类型。这些值可能来自动态内容，例如来自用户-或者我们可能要有意接受我们API中的所有值。在这些情况下，我们希望提供一种类型，该类型告诉编译器和将来的读者此变量可以是任何变量，因此我们将其赋予未知类型。 12345let notSure: unknown = 4;notSure = \"maybe a string instead\";// OK, definitely a booleannotSure = false; 如果您有一个类型未知的变量，则可以通过进行typeof检查，比较检查或更高级的类型防护来将其范围缩小到更具体的范围; 1234567891011121314151617181920declare const maybe: unknown;// 'maybe' could be a string, object, boolean, undefined, or other typesconst aNumber: number = maybe;//Type 'unknown' is not assignable to type 'number'.if (maybe === true) &#123; // TypeScript knows that maybe is a boolean now const aBoolean: boolean = maybe; // So, it cannot be a string const aString: string = maybe;//Type 'boolean' is not assignable to type 'string'.&#125;if (typeof maybe === \"string\") &#123; // TypeScript knows that maybe is a string const aString: string = maybe; // So, it cannot be a boolean const aBoolean: boolean = maybe;//Type 'string' is not assignable to type 'boolean'.&#125; Any 在某些情况下，并非所有类型信息都可用。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况，可能要选择退出类型检查。将这些值标记为any类型： 123declare function getValue(key: string): any;// OK, return value of 'getValue' is not checkedconst str: string = getValue(\"myString\"); 与 unknown 不同，any类型的变量使您可以访问任意属性，甚至是不存在的属性。这些属性包括函数，并且TypeScript不会检查它们的存在或类型 123456789let looselyTyped: any = 4;// OK, ifItExists might exist at runtimelooselyTyped.ifItExists();// OK, toFixed exists (but the compiler doesn't check)looselyTyped.toFixed();let strictlyTyped: unknown = 4;strictlyTyped.toFixed();// Object is of type 'unknown'. Void void有点像任何其他的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型： 123function warnUser(): void &#123; console.log(\"This is my warning message\");&#125; Null and Undefined 在TypeScript中，undefined和null实际上实际上分别将其类型命名为undefined和null。就像void一样，它们本身并不是非常有用： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Never The never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never. 1234567891011121314// Function returning never must not have a reachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must not have a reachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; Object object是代表非基本类型的类型，即不是数字，字符串，布尔值，bigint，symbol，null或undefined的任何类型。 123456789101112131415// With object type, APIs like Object.create can be better represented.declare function create(o: object | null): void;// OKcreate(&#123; prop: 0 &#125;);create(null);create(42);//Argument of type '42' is not assignable to parameter of type 'object | null'.create(\"string\");//Argument of type '\"string\"' is not assignable to parameter of type 'object | null'.create(false);//Argument of type 'false' is not assignable to parameter of type 'object | null'.create(undefined);//Argument of type 'undefined' is not assignable to parameter of type 'object | null'. Type assertions 类型断言是一种告诉编译器“相信我，我知道我在做什么”的方法。类型断言就像其他语言中的类型转换一样，但是它不执行数据的特殊检查或重构。它对运行时没有影响，仅由编译器使用。 TypeScript假定您（程序员）已经执行了所需的任何特殊检查。 类型断言的两种形式 123456// 类型1: as 语句let someValue: unknown = \"this is a string\";let strLength: number = (someValue as string).length;// 类型2: 尖括号let someValue: unknown = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; jsx中无法使用 类型2； About Number, String, Boolean, Symbol and Object 可能会认为数字，字符串，布尔值，符号或对象类型与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎永远不应将其用作类型。 2. interface2.1 readonly1234interface Point &#123; readonly x: number; readonly y: number;&#125; TypeScript具有与Array 相同的ReadonlyArray 类型，并且删除了所有变异方法，因此可以确保创建后不更改数组： 1234567891011let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!//Index signature in type 'readonly number[]' only permits reading.ro.push(5); // error!//Property 'push' does not exist on type 'readonly number[]'.ro.length = 100; // error!//Cannot assign to 'length' because it is a read-only property.a = ro; // error!//The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'. 在代码片段的最后一行，您可以看到，即使将整个ReadonlyArray分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它： 1234let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;a = ro as number[]; ReadOnly or const 记住是使用只读还是const的最简单方法是询问是否在变量或属性上使用它。变量使用const，而属性使用只读。 2.2 Optional1234interface SquareConfig &#123; color?: string; width?: number;&#125; 2.3 Excess Property Checks但是，TypeScript认为此代码中可能存在错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行过多的属性检查。如果对象文字具有“目标类型”所没有的任何属性，则会出现错误： 123456789101112131415interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; return &#123; color: config.color || \"red\", area: config.width ? config.width * config.width : 20, &#125;;&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;);//Argument of type '&#123; colour: string; width: number; &#125;' is not assignable to parameter of type 'SquareConfig'. // Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'? 解决方案 解决这些检查实际上非常简单。最简单的方法是只使用类型断言： 1const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125; as SquareConfig); 如果对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。 12345678910interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;const mySquare = createSquare(&#123;width: 100, opacity: 0.5&#125;);// 只要您在squareOptions和SquareConfig之间具有一个公共属性，上述变通办法就会起作用。但是，如果变量没有任何公共对象属性，它将失败。let squareOptions = &#123; colour: \"red\" &#125;;let mySquare = createSquare(squareOptions);// Type '&#123; colour: string; &#125;' has no properties in common with type 'SquareConfig'. 2.4 Function Types为了描述带有接口的函数类型，我们给接口一个调用签名。这就像只声明参数列表和返回类型的函数声明。参数列表中的每个参数都需要名称和类型。 1234567891011121314151617181920212223242526interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function (source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125;;let mySearch2: SearchFunc;// 参数不定义string，ts会自动推断mySearch2 = function (src, sub): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125;;let mySearch: SearchFunc;mySearch = function (src, sub) &#123; // 返回值需要遵守interface//Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.// Type 'string' is not assignable to type 'boolean'. let result = src.search(sub); return \"string\";&#125;; 2.5 Indexable Types可索引类型具有索引签名，该签名描述了可用于索引对象的类型以及建立索引时对应的返回类型 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为在用数字索引时，JavaScript实际上会在将其索引到对象之前将其转换为字符串。这意味着使用100（一个数字）进行索引与使用“ 100”（一个字符串）进行索引是同一回事，因此两者必须保持一致。 1234567891011121314interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;// Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay &#123; [x: number]: Animal;Numeric index type 'Animal' is not assignable to string index type 'Dog'. [x: string]: Dog;&#125; 尽管字符串索引签名是描述“字典”模式的强大方法，但它们还强制所有属性与其返回类型匹配。这是因为字符串索引声明obj.property也可以作为obj [“ property”]使用。在以下示例中，名称的类型与字符串索引的类型不匹配，并且类型检查器给出错误： 123456interface NumberDictionary &#123; [index: string]: number; length: number; // ok, length is a number name: string; // error, the type of 'name' is not a subtype of the indexer// Property 'name' of type 'string' is not assignable to string index type 'number'.&#125; 但是，如果索引签名是属性类型的并集，则可以接受不同类型的属性： 12345interface NumberOrStringDictionary &#123; [index: string]: number | string; // 属性类型 length: number; // ok, length is a number name: string; // ok, name is a string&#125; 最后，您可以将索引签名设为只读，以防止分配给它们的索引： 1234567interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];myArray[2] = \"Mallory\"; // error!// Index signature in type 'ReadonlyStringArray' only permits reading. 2.6 Class Types2.6.1 Implement123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 这是因为当类实现接口时，仅检查该类的实例侧。由于构造函数位于静态端，因此它不包含在此检查中。 123456789101112interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; // Class 'Clock' incorrectly implements interface 'ClockConstructor'. // Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'. currentTime: Date; constructor(h: number, m: number) &#123;&#125;&#125;const clock = new Clock(1, 3); 需要直接使用类的静态方面。在此示例中，我们定义了两个接口，用于构造函数的ClockConstructor和用于实例方法的ClockInterface。然后，为方便起见，我们定义了一个构造函数createClock，该函数创建传递给它的类型的实例 1234567891011121314151617181920212223242526272829303132interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;function createClock( ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"tick tock\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 另一种简单的方法是使用类表达式： 1234567891011121314151617interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;;let clock = new Clock(12, 17);clock.tick(); 2.7 Extending Interfaces12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &#123;&#125; as Square;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 2.8 Hybrid Typesan object that acts as both a function and an object, with additional properties: 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = function (start: number) &#123;&#125; as Counter; counter.interval = 123; counter.reset = function () &#123;&#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 与第三方JavaScript交互时，您可能需要使用上述模式来完全描述类型的形状 2.9 Interfaces Extending ClassesWhen an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it. This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example: 12345678910111213141516171819202122class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;class ImageControl implements SelectableControl &#123;//Class 'ImageControl' incorrectly implements interface 'SelectableControl'. // Types have separate declarations of a private property 'state'. private state: any; select() &#123;&#125;&#125; ​ In the above example, SelectableControl contains all of the members of Control, including the private state property. Since state is a private member it is only possible for descendants of Control to implement SelectableControl. This is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible. ​ Within the Control class it is possible to access the state private member through an instance of SelectableControl. Effectively, a SelectableControl acts like a Control that is known to have a select method. The Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method). The ImageControl class has it’s own state private member rather than extending Control, so it cannot implement SelectableControl. 3. Functions在TypeScript中，尽管有类，名称空间和模块，但是函数仍然在描述操作方式中起着关键作用。 TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。 3.1 thisLearning how to use this in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use this and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of this with a couple of techniques. If you need to learn how this works in JavaScript, though, first read Yehuda Katz’s Understanding JavaScript Function Invocation and “this”. Yehuda’s article explains the inner workings of this very well, so we’ll just cover the basics here. this and arrow functions In JavaScript, this is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument. Let’s look at an example: 1234567891011121314151617let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; return function () &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Notice that createCardPicker is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the this being used in the function created by createCardPicker will be set to window instead of our deck object. That’s because we call cardPicker() on its own. A top-level non-method syntax call like this will use window for this. (Note: under strict mode, this will be undefined rather than window). We can fix this by making sure the function is bound to the correct this before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original deck object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the this where the function is created rather than where it is invoked: 123456789101112131415161718let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function () &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Even better, TypeScript will warn you when you make this mistake if you pass the --noImplicitThis flag to the compiler. It will point out that this in this.suits[pickedSuit] is of type any. this parameters Unfortunately, the type of this.suits[pickedSuit] is still any. That’s because this comes from the function expression inside the object literal. To fix this, you can provide an explicit this parameter. this parameters are fake parameters that come first in the parameter list of a function: 123function f(this: void) &#123; // make sure `this` is unusable in this standalone function&#125; Let’s add a couple of interfaces to our example above, Card and Deck, to make the types clearer and easier to reuse: 1234567891011121314151617181920212223242526272829interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function (this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;,&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); Now TypeScript knows that createCardPicker expects to be called on a Deck object. That means that this is of type Deck now, not any, so --noImplicitThis will not cause any errors. this parameters in callbacks You can also run into errors with this in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, this will be undefined. With some work you can use this parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with this: 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this: 123456789101112131415class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used `this` here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error!//Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. //The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'.Argument of type '(this: Handler, e: Event) =&gt; void' is not assignable to parameter of type '(this: void, e: Event) =&gt; void'. // The 'this' types of each signature are incompatible. // Type 'void' is not assignable to type 'Handler'. With this annotated, you make it explicit that onClickBad must be called on an instance of Handler. Then TypeScript will detect that addClickListener requires a function that has this: void. To fix the error, change the type of this: 12345678910class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use `this` here because it's of type void! console.log(\"clicked!\"); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); Because onClickGood specifies its this type as void, it is legal to pass to addClickListener. Of course, this also means that it can’t use this.info. If you want both then you’ll have to use an arrow function: 123456class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message; &#125;;&#125; This works because arrow functions use the outer this, so you can always pass them to something that expects this: void. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler. 3.2 OverloadsJavaScript本质上是一种非常动态的语言。一个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。 1234567891011121314151617181920212223242526272829let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123; suit: string; card: number &#125;[]): number;function pickCard(x: number): &#123; suit: string; card: number &#125;;function pickCard(x) &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [ &#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;,];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 4. Classes4.1 abstract abstract关键字用于定义抽象类以及抽象类中的抽象方法。 抽象类， 是可以从中派成出其他类的基类；简单说就是只能被继承，不能new出实例；与interface不同的是，抽象类中可以有成员实现的详细信息。 12345678910111213141516171819202122232425export abstract class App &#123; public setTargetProps&lt;T&gt; (target: T, source: Partial&lt;T&gt;): T &#123; try &#123; Object.keys(target).forEach((property: keyof T) =&gt; &#123; this.setTargetPropsByProperty(target, property, source[property]) &#125;) &#125; catch (error) &#123; throw new Error(error) &#125; return target &#125;&#125;const app = new App();// Cannot create an instance of an abstract class.class B extends App&#123;&#125;;// 非抽象类“ B”未实现从类“ App”继承的抽象成员“ make”class C extends App&#123; make()&#123;&#125; // 需要实现抽象类中定义的抽象方法&#125; 抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含abstract关键字，并且可以选择包括访问修饰符。 4.2 public,private, and protected4.2.1 类型兼容12345678910111213141516171819202122232425262728class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super(\"Rhino\"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal(\"Goat\");let rhino = new Rhino();let employee = new Employee(\"Bob\");animal = rhino;animal = employee; // Type 'Employee' is not assignable to type 'Animal'. 没有继承关系的类型无法做赋值操作；// Types have separate declarations of a private property 'name' 4.2.2 protectedprotected修饰符的行为与private修饰符非常相似，除了声明为protected的成员也可以在派生类中访问之外； 123456789101112131415161718192021222324252627class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; // 派生类中可以访问到 基类中的 protected 属性； return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());// 虽然我们不能从Person外部使用name，但仍可以在Employee的实例方法中使用它，因为Employee源自Person。console.log(howard.name);// Property 'name' is protected and only accessible within class 'Person' and its subclasses. 构造函数也可能被标记为受保护的。这意味着该类不能在其包含的类之外实例化，但是可以扩展。 123456789101112131415161718192021222324class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee can extend Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\");// Constructor of class 'Person' is protected and only accessible within the class declaration. 因为 new Person的时候是需要调 Person的构造函数，由于其构造函数添加了 protected关键字。实例是无法调类的构造函数的，所以就无法被实例化了； 4.2.3 Readonly12345678910111213class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(readonly theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\";// Cannot assign to 'name' because it is a read-only property.console.log(dad.name) 4.2.4 accessorsTypeScript支持getters / setter方法，以拦截对对象成员的访问。这使您可以更好地控制如何访问每个对象上的成员的方式。 12345678910class Employee &#123; fullName: string;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 在此版本中，我们添加了一个setter来检查newName的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是这样，我们会抛出错误通知客户端代码出了点问题。 123456789101112131415161718192021222324const fullNameMaxLength = 10;class Employee &#123; private _fullName: string = \"\"; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123; throw new Error(\"fullName has a max length of \" + fullNameMaxLength); &#125; this._fullName = newName; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 注意事项 首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。 其次，带有get和no set的访问器会自动推断为只读。当代码生成.d.ts文件时很有用，因为用户通过ide可以看到这些无法进行更改。 4.2.5 Static1234567891011121314151617class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123; let xDist = point.x - Grid.origin.x; let yDist = point.y - Grid.origin.y; return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123;&#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 4.2.6 Using a class as an interface12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;; 5. Generics泛型，创建可重用组件的工具。 1234function loggingIdentity&lt;T&gt;(arg: T) &#123; console.log(arg.length); // Property 'length' does not exist on type 'T'. return arg;&#125; 5.1 泛型定义1234567891011function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;let myIdentity1: &#123; &lt;T&gt;(arg: T): T &#125; = identity;let myIdentity2: GenericIdentityFn = identity; 5.2 泛型类12345678910class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y;&#125;; 5.3 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 5.3.1 Using Type Parameters in Generic Constraints123456789function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\");getProperty(x, \"m\");// Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'. 5.3.2 泛型类使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型； 123function create&lt;T&gt;(c: &#123; new (): T &#125;): T &#123; return new c();&#125; 使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系 1234567891011121314151617181920212223242526class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask; 6. Modules6.1 import/export模块是在自己的范围内执行的，而不是在全局范围内执行的；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用导出形式之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种导入形式将其导入。 模块是声明性的，模块之间的关系是根据文件级别的导入和导出指定的； 模块使用模块加载器相互导入， 在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。 6.1.1 export可以通过添加export关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。 123export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125; 重命名导出 1234567class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;export &#123; ZipCodeValidator &#125;;export &#123; ZipCodeValidator as mainValidator &#125;; 重新导出不会将其导入本地，也不会引入局部变量。 12345678export class ParseIntBasedZipCodeValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; parseInt(s).toString() === s; &#125;&#125;// Export original validator but rename itexport &#123; ZipCodeValidator as RegExpBasedZipCodeValidator &#125; from \"./ZipCodeValidator\"; 导出所有 123456export * from \"./StringValidator\"; // exports 'StringValidator' interfaceexport * from \"./ZipCodeValidator\"; // exports 'ZipCodeValidator' class and 'numberRegexp' constant valueexport * from \"./ParseIntBasedZipCodeValidator\"; // exports the 'ParseIntBasedZipCodeValidator' class// and re-exports 'RegExpBasedZipCodeValidator' as alias// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'// module. 6.1.2 import12345678910// single exportimport &#123; ZipCodeValidator &#125; from \"./ZipCodeValidator\";// renamedimport &#123; ZipCodeValidator as ZCV &#125; from \"./ZipCodeValidator\";let myValidator = new ZCV();// 将整个模块导入单个变量，并使用它来访问模块导出import * as validator from \"./ZipCodeValidator\";let myValidator = new validator.ZipCodeValidator();// 某些模块会设置一些可由其他模块使用的全局状态。这些模块可能没有任何出口import \"./my-module.js\" 6.1.3 default exports 默认导出 ​ 每个模块可以选择导出默认导出。默认导出用关键字default标记；每个模块只能有一个默认导出。默认导出使用其他导入形式导入。 ​ 默认出口真的很方便。例如，像jQuery之类的库可能具有jQuery或$的默认导出，我们也可能以$或jQuery的名称导入 1234567// JQuery.d.tsdeclare let $:JQueryexport default $;// App.tsimport $ from \"jquery\";$(\"button\").html(\"xxx\") 6.1.4 Export all as x12export * as utilities from \"./utilities\";import &#123;utilities&#125; from './index'; 6.1.4 export = import = require() TypeScript supports export = to model the traditional CommonJS and AMD workflow. export =语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。 当使用export =导出模块时, 必须用 import module = require(&quot;module&quot;) 导入模块 1234567891011121314151617// z.tslet numberRegexp = /^[0-9]+$/;class ZipCodeValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;export = ZipCodeValidator;// t.tsimport zip = require(\"./ZipCodeValidator\");// Some samples to trylet strings = [\"Hello\", \"98052\", \"101\"];// Validators to uselet validator = new zip(); 6.2 code generation for Modulestypescript 会依据不同的模块规则，生成不同的代码 123// SimpleModule.tsimport m = require(\"mod\");export let t = m.something + 1; AMD / RequireJS SimpleModule.js 123define([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) &#123; exports.t = mod_1.something + 1;&#125;); CommonJS / Node SimpleModule.js 12var mod_1 = require(\"./mod\");exports.t = mod_1.something + 1; UMD SimpleModule.js 1234567891011(function (factory) &#123; if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") &#123; var v = factory(require, exports); if (v !== undefined) module.exports = v; &#125; else if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define([\"require\", \"exports\", \"./mod\"], factory); &#125;&#125;)(function (require, exports) &#123; var mod_1 = require(\"./mod\"); exports.t = mod_1.something + 1;&#125;); System SimpleModule.js 1234567891011121314System.register([\"./mod\"], function (exports_1) &#123; var mod_1; var t; return &#123; setters: [ function (mod_1_1) &#123; mod_1 = mod_1_1; &#125;, ], execute: function () &#123; exports_1(\"t\", (t = mod_1.something + 1)); &#125;, &#125;;&#125;); Native ECMAScript 2015 modules SimpleModule.js 12import &#123; something &#125; from \"./mod\";export var t = something + 1; 6.3 可选模块加载和其他高级加载方案为了保持类型安全，我们可以使用typeof关键字。当在类型位置中使用typeof关键字时，将产生值的类型，在这种情况下为模块的类型。 6.3.1 Dynamic Module Loading in Node.js1234567891011declare function require(moduleName: string): any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123; let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\"); let validator = new ZipCodeValidator(); if (validator.isAcceptable(\"...\")) &#123; /* ... */ &#125;&#125; 6.3.2 Sample: Dynamic Module Loading in require.js123456789101112131415declare function require( moduleNames: string[], onLoad: (...args: any[]) =&gt; void): void;import * as Zip from \"./ZipCodeValidator\";if (needZipValidation) &#123; require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) =&gt; &#123; let validator = new ZipCodeValidator.ZipCodeValidator(); if (validator.isAcceptable(\"...\")) &#123; /* ... */ &#125; &#125;);&#125; 6.3.3 Sample: Dynamic Module Loading in System.js123456789101112declare const System: any;import &#123; ZipCodeValidator as Zip &#125; from \"./ZipCodeValidator\";if (needZipValidation) &#123; System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) =&gt; &#123; var x = new ZipCodeValidator(); if (x.isAcceptable(\"...\")) &#123; /* ... */ &#125; &#125;);&#125; 6.4 使用其他js库为了描述非ts编写的库，我们需要声明该库公开的API；通常将这些声明定义在.d.ts文件中，就类似c/c++程序中的 .h文件； Ts程序在开发过程中，会不可避免的引用到第三方js库，但是无法使用Typescript诸如类型检查等特性功能，为了解决这个问题，需要将这些库的函数和方法去掉后只保留导出类型声明，而产生一个描述js库和模块信息的声明文件，通过引用这个声明文件，就可以借用TS的各种特性来使用库文件； 6.4.1 声明文件的存放方式 在tsconfig include 字段包含 的范围内编写.d.ts，都能被自动识别 在x.js 相同目录创建同名声明文件x.d.ts，这样也会被自动识别； node_modules/@types/ 下存放的各个第三方模块声明文件，自己编写的声明文件不要放这里； 作为npm模块发布时，声明文件可捆绑发布，需在package.json中指明“types”：”./types/index.d.ts” 6.4.1 无配置使用js在tsconfig.json中关闭”noImplicitAny”: false时，可直接在Ts中引用js的库，所有的引入都会被默认为any类型。此方法不推荐使用； 6.4.2 Ts中引入js123456789// hello.jsexport const hello = () =&gt; console.log('hello');// index.tsimport &#123;hello&#125; from './hello'// 无法找到模块'./hello'的声明文件// 这就告诉用户，需要为hello.js编写声明文件了；// hello.d.tsexport declare const hello: () =&gt; void 6.4.3 declarevar和declare的区别 ​ var表示创建一个新变量，declare用来告诉ts编译器这个变量已经在别处被创建过了， 如果你用declare，什么都不会添加到生成的js中， 它只是对编译器一个简单的提示； ​ 举例说明，如果你引入的第三方js文件中有 var externalModule，你需要定义declare var externalModule 去提示ts编译器，externalModule这个变量已经被创建了； 1export declare class Action &#123;&#125; 这个class Action的具体实现应该在其他什么地方，可以在个 .js文件里面 ​ 6.4.4 Ts中导入.png .json等导入.png .json 等文件时，同样也需要去编写声明文件； 提供一种方式，可以创建一个声明文件 src/@types/definition.d.ts 1234567891011121314// definition.d.tsdeclare module '*.png' &#123; const value: string export = value&#125;// index.ts// 之后在TS中导入也不会有问题import avatar from './img/avatar.png'const avatar = require('./img/avatar.png') // 可能会提示 require 未定义，有两种方式： // 1. 自行声明：declare const require: any // 2. yarn add -D @types/node 6.4.5 第三方模块没有可用的声明文件有些模块没有对应的声明文件时，需要我们自己编写声明文件，以rc-form为例子，需要在src/@types/defintion.d.ts中添加声明代码 1234567// defintion.d.tsdeclare module \"rc-form\" &#123; // 再次简单进行类型声明 export const createForm: any; export const createFormField: any; export const formShape: any;&#125; 6.4.6 webpack 别名 aliases1234567891011121314151617181920212223242526// webpack.config.jsconst config = &#123; aliases: &#123; // 公共的工具类、容器和组件 utils: path.resolve('../utils'), &#125; // &#125;// index.tsimport &#123;ua&#125; from 'utils/broswer'// cannot find module 'utils/browser'// 只需要在tsconfig.json 添加baseUrl 和 paths&#123; \"compilerOptions\": &#123; // ... // 添加配置 \"baseUrl\": \".\", \"paths\": &#123; \"utils/*\": [\"../utils/*\"], \"components/*\": [\"../components/*\"] &#125; &#125;, \"include\": [\"./src/*\", \"./src/**/*\"], \"exclude\": [\"node_modules\"]&#125; 6.4.7 类型Window上不存在属性“X”需要对window进行扩展，直接在src/@types/definition.d.ts中扩展 1234567// definition.d.tsinterface Window &#123; x: any&#125;// index.tsconsole.log(Window.x) // success 注意全局声明和局部声明 1234567891011121314151617181920212223// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'interface Window &#123; X: any&#125;// index.tsconsole.log(window.X); // fail: 类型“Window\"上不存在属性“X”// 解决思路// definition.d.tsimport &#123;IPerson&#125; from './intefaces/index.ts'declare global &#123; interface Window &#123; X: any &#125;&#125;// index.tsconsole.log(window.X) // success // 原因在于当一个 .ts文件加入import/export 语句的时候，该文件会变为一个模块；因为这个模块中的声明也会变为局部声明； 因此需要加到global的域上 6.5 Ambient Modules在nodejs中，很多任务的完成都需要引入一个或多个模块，我们可以给每个模块在他们的根目录建立一个.d.ts文件用来声明类型，但合并这些声明到一个大的.d.ts文件往往更方便一些。使用module关键字和 引号名 。这些引号名的名称将在以后的导入中使用； 1234567891011121314151617181920// node.d.tsdeclare module \"url\" &#123; export interface Url &#123; protocol?: string; hostname?: string; pathname?: string; &#125; export function parse( urlStr: string, parseQueryString?, slashesDenoteHost? ): Url;&#125;declare module \"path\" &#123; export function normalize(p: string): string; export function join(...paths: any[]): string; export var sep: string;&#125; Now we can /// &lt;reference&gt; node.d.ts and then load the modules using import url = require(&quot;url&quot;); or import * as URL from &quot;url&quot;. 123/// &lt;reference path=\"node.d.ts\"/&gt;import * as URL from \"url\";let myUrl = URL.parse('...') 6.5.1 不想为第三方js写声明If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly. 123456// declarations.d.tsdeclare module \"hot-new-module\";// All imports from shorthand module will have the any type;import x, &#123;y&#125; from \"hot-new-module\";x(y); 6.5.2 通配符一些模块加载器（例如SystemJS和AMD）允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。 12345678910111213141516// declareations.d.tsdeclare module \"*!text\" &#123; const content: string; export default content;&#125;// Some do it the other way around.declare module \"json!*\" &#123; const value: any; export default value;&#125;// Now you can import things that match \"*!text\" or \"json!*\".import fileContent from \"./xyz.txt!text\";import data from \"json!http://example.com/data.json\";console.log(data, fileContent); 6.5.3 UMD modules一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为UMD模块。可以通过导入或全局变量访问这些库。 123// math-lib.d.tsexport function isPreme(x: number):boolean;export as namespace mathLib; The library can then be used as an import within modules: 123import &#123; isPrime &#125; from \"math-lib\";isPrime(2);mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports) 1mathLib.isPrime(2); 6.7 Guidance for structuring modules6.7.1 Export as close to top-level as possible如果要导入大量内容，请使用名称空间导入模式 12345678// MyLargeModule.tsexport class Dog &#123; ... &#125;export class Cat &#123; ... &#125;export class Tree &#123; ... &#125;export class Flower &#123; ... &#125;// Consumer.tsimport * as myLargeModule from \"./MyLargeModule.ts\";let x = new myLargeModule.Dog(); 6.7.2 Re-export to extend通常，您将需要扩展模块上的功能。常见的JS模式是使用扩展来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样合并。推荐的解决方案是不要变更原始对象，而是导出提供新功能的新对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081export class Calculator &#123; private current = 0; private memory = 0; private operator: string; protected processDigit(digit: string, currentValue: number) &#123; // 只能做10以内的计算； if (digit &gt;= \"0\" &amp;&amp; digit &lt;= \"9\") &#123; return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0)); &#125; &#125; protected processOperator(operator: string) &#123; if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) &gt;= 0) &#123; return operator; &#125; &#125; protected evaluateOperator( operator: string, left: number, right: number ): number &#123; switch (this.operator) &#123; case \"+\": return left + right; case \"-\": return left - right; case \"*\": return left * right; case \"/\": return left / right; &#125; &#125; private evaluate() &#123; if (this.operator) &#123; this.memory = this.evaluateOperator( this.operator, this.memory, this.current ); &#125; else &#123; this.memory = this.current; &#125; this.current = 0; &#125; public handleChar(char: string) &#123; if (char === \"=\") &#123; this.evaluate(); return; &#125; else &#123; let value = this.processDigit(char, this.current); if (value !== undefined) &#123; this.current = value; return; &#125; else &#123; let value = this.processOperator(char); if (value !== undefined) &#123; this.evaluate(); this.operator = value; return; &#125; &#125; &#125; throw new Error(`Unsupported input: '$&#123;char&#125;'`); &#125; public getResult() &#123; return this.memory; &#125;&#125;export function test(c: Calculator, input: string) &#123; for (let i = 0; i &lt; input.length; i++) &#123; c.handleChar(input[i]); &#125; console.log(`result of '$&#123;input&#125;' is '$&#123;c.getResult()&#125;'`);&#125; 1234// 使用import &#123;Calculator, test&#125; from './ProgrammerCalculator';let c = new Calculator(2);test(c, \"1+2*33/11=\"); 新需求： 要求计算超过9的值 这个时候不在原类上更改，而是在继承类上做新功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ProgrammerCalculator.tsimport &#123; Calculator &#125; from \"./Calculator\";class ProgrammerCalculator extends Calculator &#123; static digits = [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", ]; constructor(public base: number) &#123; super(); const maxBase = ProgrammerCalculator.digits.length; if (base &lt;= 0 || base &gt; maxBase) &#123; throw new Error(`base has to be within 0 to $&#123;maxBase&#125; inclusive.`); &#125; &#125; protected processDigit(digit: string, currentValue: number) &#123; if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) &#123; return ( currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit) ); &#125; &#125;&#125;// Export the new extended calculator as Calculatorexport &#123; ProgrammerCalculator as Calculator &#125;;// Also, export the helper functionexport &#123; test &#125; from \"./Calculator\"; 12345// TestProgrammerCalculator.tsimport &#123; Calculator, test &#125; from \"./ProgrammerCalculator\";let c = new Calculator(2);test(c, \"001+010=\"); // prints 3 6.7.3 Do not use namespaces in modules当首次转向基于模块的组织时，一种普遍的趋势是将导出包装在命名空间的附加层中。模块具有自己的作用域，并且从模块外部仅可见导出的声明。考虑到这一点，名称空间在使用模块时几乎没有价值。 7. Namespaces在TypeScript 1.5中，模块命名法则已更改。 “Internal modules”现在是“namespaces”。为了与ECMAScript 2015的术语保持一致，“外部模块”现在简称为“模块”（即模块X {等同于现在首选的命名空间X {）","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"}]},{"title":"html5vedio","slug":"html5vedio","date":"2021-01-04T07:02:23.000Z","updated":"2021-01-04T07:06:43.133Z","comments":true,"path":"2021/01/04/html5vedio/","link":"","permalink":"http://yoursite.com/2021/01/04/html5vedio/","excerpt":"","text":"html5 播放器加速123const video = document.querySelector('video');video.playbackRate = 2 // 播放器播放速度","categories":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"}]},{"title":"graphics01","slug":"graphics01","date":"2020-12-21T14:10:08.000Z","updated":"2020-12-21T14:10:08.043Z","comments":true,"path":"2020/12/21/graphics01/","link":"","permalink":"http://yoursite.com/2020/12/21/graphics01/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"browser-sync","slug":"browser-sync","date":"2020-12-21T06:07:39.000Z","updated":"2020-12-21T09:30:13.203Z","comments":true,"path":"2020/12/21/browser-sync/","link":"","permalink":"http://yoursite.com/2020/12/21/browser-sync/","excerpt":"","text":"全局安装1231312312312123sudo npm install -g browser-sync 快速使用1234# 启动服务器 监听所有的html文件$ browser-sync start --server --files \"*.html\"# 启动服务器 监听所有的文件$ browser-sync start --server --files \"**\" 启动browser-sync start --server --port 3333 --files &quot;*.css,*.html,*.js&quot; start options1234567891011121314151617181920212223242526272829--help #输出使用信息--version #输出的版本号--browser #选择哪个浏览器应该是自动打开--files #文件路径看--exclude #文件模式忽视--server #运行本地服务器（使用您的CWD作为Web根）--index #指定哪些文件应该被用作索引页--extensions #指定文件扩展名回退--startPath #指定起始路径，打开浏览器--https #启用S​​SL地方发展--directory #显示服务器的目录列表--proxy #代理现有的服务器--xip #使用xip.io域路由--tunnel #使用公共网址--open #选择哪个URL是自动打开（本地，外部或隧道）--config #指定为BS-config.js文件的路径--host #指定主机名使用--logLevel #设置记录器输出电平（沉默，信息或调试）--port #指定要使用的端口--reload-delay #以毫秒为单位的时间延迟重装事件以下文件的变化--reload-debounce #限制在浏览器中的频率：刷新事件可以被发射到连接的客户机--ui-port #指定端口的UI使用--no-notify #禁用浏览器的通知元素--no-open #不要打开一个新的浏览器窗口--no-online #强制离线使用--no-ui #不要启动用户界面--no-ghost-mode #禁用幽灵模式--no-inject-changes #刷新上的每个文件更改--no-reload-on-restart #不要自动重新加载在重新启动所有浏览器","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"gitlab3","slug":"gitlab3","date":"2020-12-17T07:30:43.000Z","updated":"2020-12-18T05:40:47.918Z","comments":true,"path":"2020/12/17/gitlab3/","link":"","permalink":"http://yoursite.com/2020/12/17/gitlab3/","excerpt":"","text":"gitlab 分支策略 考虑到gitlab一般在企业内部使用，一般不存在社区开发者，所以在管理上不会采用github的upstream/origin双仓库模式。gitlab下，开发者们面向一个仓库进行提交即可； 设置对分支的保护权限 顾名思义，分支的权限必不可少，它可以约束开发者们的提交行为和提交策略。避免失误操作将未测试过的代码强制提交到生产分支；developer可以不关心； issue与Milestones issue可以理解为一个最小原子的任务，多个任务组成一个 milestones；Milestones 可以理解为某个时间区间内的任务集；一个Milestones可包含多个issue； 当该Milestones中所有issue完成，则标志着此Milestones的结束； 创建issue和mr 创建一个issue 关联一个mr branch name branch name 会以issue的序号开始，然后抓取title中的英文和数字做连接。 可采用index-categroy-content-[username]-[time]的自定义方式，括号部分可选 category feature bugfix chore enhance content，一到三个词简述任务 username，任务认领人 time，创建分支的时间，一般 201217或者1225 source 基于什么分支创建当前分支，feature/chore/enhance选择dev-0.3, bugfix选择env-dev 提交代码流程 123456git fetch # 获取issue关联的分支名git checkout -b 6-feature-pivotDrill origin/6-feature-pivotDrill # 基于远端新建一个本地开发分支git rebase dev-0.3 # 在开发过程中，不定时rebase 宿主分支，防止版本隔断git push origin 6-feature-pivotDrill # 提交至远程映射# 通知maintainer完成代码合并，并关闭issue commits规范&#39;type(module) some desc&#39; 1234567891011121314151617181920212223242526type = [ \"build\", // 构建执行 \"chore\", // 构建工具相关 \"ci\", // CI 相关 \"docs\", // 文档更新 \"feat\", // 新功能 \"fix\", // bug 修复 \"perf\", // 性能优化 \"refactor\", // 功能重构 \"release\", \"revert\", // 回滚操作 \"style\", // 样式变动 \"test\", // 单元测试]moduele = [ // 以davinci为例,只列出前端模块 \"project\", \"dashboard\", \"display\", \"widget\", \"schdule\", \"view\", \"source\", \"user\"] review代码的参考标准 格式化后的代码，在vscode中安装prettier工具，设置ctrl+s默认对当前页进行prettier格式化； 所有commits必须要关联issue，如果没有issue要新建issue然后关联mr（merge request），基于当前mr提交代码； 原则上，不能有肉眼可见的bug，一般review代码时会进行简单的测试； 其他规则（代码规范） 代码规范 原则上，所有新提交的代码参考项目代码风格即可。简述为下面几个方面 原则上，变量名含义精准，（ps：严禁全局作用域中出现单字符命名空间；） 不要求一定要加注释或者不加注释，我们的愿景是能够书写无注释就能看懂的代码。根据业务逻辑难易程度，自行决定。 尽量英文注释； 不建议提交大量重复代码，须做好代码的抽象复用； 尽量使用被主流浏览器支持的的es规范书写代码，原则上新es规范下已有的工具类和函数，不重复造轮子； 其他涉及html/css/javascript相关的推荐规范会渐进式纳入规范集；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab2","slug":"gitlab2","date":"2020-12-16T10:41:24.000Z","updated":"2020-12-18T05:41:03.023Z","comments":true,"path":"2020/12/16/gitlab2/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab2/","excerpt":"","text":"label 标签组 标签组的意义就是定义一次，多个项目统一使用 Platform 前端还是后端，ios 还是 android angular node Problems 目前产品中存在的问题，以及该问题的优先级程度 bug： 常规bug security： 安全漏洞 production： 涉及到生产环境 Mindless 影响较小的任务，比如更改文件夹目录，适配规范 chore legal Experience 影响用户体验，或者用户对产品的理解. These can be both opportunities and “UX bugs”. copy design ux: User Experience Environment 服务器环境，开发环境，生产环境或者测试环境 staging test Feedback 待确认的问题，比如一些拍脑袋的需求；或者某个需求我们还没决定怎么实现 discussion question： 还没到需要讨论的情况 rfc Improvements 现有功能或基础架构上的迭代。 enhancement: 现有模块有更高的完成度 optimization: 现有功能代码层面的重构，或者交互流程上的梳理 Additions 新功能，新页面 feature Pending 现在不好说，未来肯定有结果，可能做成功， 可能做不成； in progress： 进行中的需求 watchlist： 先拖着的需求，有可能就拖掉了 Inactive 无需采取任何行动或可能采取任何行动。该问题已解决，可以通过其他问题更好地解决； invalid： 无效的 wontfix： 不会修复 duplicate： 重复 on hold： 等待候听","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab 使用","slug":"gitlab-使用","date":"2020-12-16T06:52:39.000Z","updated":"2020-12-18T05:43:13.922Z","comments":true,"path":"2020/12/16/gitlab-使用/","link":"","permalink":"http://yoursite.com/2020/12/16/gitlab-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"软件开发阶段 软件开发十个阶段在gitlab中对应的管理方式方法 IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了Mattermost 它类似一个聊天工具。 ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在工单追踪器issue tracker中帮助你去提升这个点子。 PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用工单看板Issue Board。 CODE： 现在，当一切准备就绪，我们可以开始写代码了。 COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。 TEST： 通过GitLab CI，我们可以运行脚本来构建和测试我们的应用。 REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行代码复审code review以及批准。 STAGING：： 预发布环境。 PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了。 FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 Cycle Analytics来对当前项目中关键的部分进行的反馈 issue 和 milestone milestone里程碑，用来标识\b阶段性目标， 对目标进行细化，化整为零一个个的issues，然后根据每个issues的紧急程度选择性的完成。等所有issues解决完之后 就标志着阶段性目标已完成； 使用方法 把实际问题转化为issue，这些问题可以标记为正在解决和计划解决； milestone对应着阶段性项目计划，然后细分为多个issues，而且可以指定完成时间，gitlab会自动生成完成进度情况概略图。 issues也可以是一个建议，共给大家一起讨论； milestone 和issue建立时我们通常可以对问题进行简单描述，并且记录问题的解决过程，包括他人提出的疑问也可以在这里记录，后期可以随时查看； 创建milestone 可以在项目开始前创建milestone，后面建issues时关联它，也可以先建issues，后期由项目负责人建milestone，然后把所有issues关联过来； 创建一个名字 简单描述，简述创建的原因，这个里程碑最终的目的，编辑的时候可以直接贴图，也可以添加附件（支持markdown格式，可以预览） 指定计划的完成时间； 新建issues 一个issues表示一个功能、一个bug、一个建议; 新建议题很简单，标题+描述+计划时间+指定人+里程碑，里程碑一定要指定一下，还可以加标签。 功能：里程碑的细分，尽量小，方便merger时的代码审核； bug：解决程序中存在的某些问题； 建议：可以作为一个讨论交流区，也可以实现它; 一个issues 对应一个指定人，一个git 分支；","categories":[{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"nginx","slug":"test","date":"2020-12-09T14:19:03.750Z","updated":"2020-12-18T05:42:10.435Z","comments":true,"path":"2020/12/09/test/","link":"","permalink":"http://yoursite.com/2020/12/09/test/","excerpt":"","text":"配置hexo到阿里云 网上大多数教程问题不大，额外需要注意修改一些文件的写入权限 1234567# 将post-receive 设置为可执行文件chmod +x ~/hexo.git/hooks/post-receivecd ~# 设置博客源地址文件夹权限，不然git hooks写入不了，Unable to unlink 就是这种原因sudo chmod -R 777 /home/www/hexo","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo","slug":"hello-world","date":"2020-06-04T03:45:32.772Z","updated":"2020-12-18T05:41:36.853Z","comments":true,"path":"2020/06/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy test12345function helloworld() &#123; return 'hello world'&#125;console.log(helloworld); More info: Deployment","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/categories/html5/"},{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"},{"name":"project","slug":"project","permalink":"http://yoursite.com/categories/project/"}],"tags":[{"name":"doc","slug":"doc","permalink":"http://yoursite.com/tags/doc/"},{"name":"skill","slug":"skill","permalink":"http://yoursite.com/tags/skill/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}